[
  {
    "function_name": "slabinfo_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5904-5908",
    "snippet": "ssize_t slabinfo_write(struct file *file, const char __user *buffer,\n\t\t       size_t count, loff_t *ppos)\n{\n\treturn -EIO;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nssize_t slabinfo_write(struct file *file, const char __user *buffer,\n\t\t       size_t count, loff_t *ppos)\n{\n\treturn -EIO;\n}"
  },
  {
    "function_name": "slabinfo_show_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5900-5902",
    "snippet": "void slabinfo_show_stats(struct seq_file *m, struct kmem_cache *s)\n{\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid slabinfo_show_stats(struct seq_file *m, struct kmem_cache *s)\n{\n}"
  },
  {
    "function_name": "get_slabinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5878-5898",
    "snippet": "void get_slabinfo(struct kmem_cache *s, struct slabinfo *sinfo)\n{\n\tunsigned long nr_slabs = 0;\n\tunsigned long nr_objs = 0;\n\tunsigned long nr_free = 0;\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tfor_each_kmem_cache_node(s, node, n) {\n\t\tnr_slabs += node_nr_slabs(n);\n\t\tnr_objs += node_nr_objs(n);\n\t\tnr_free += count_partial(n, count_free);\n\t}\n\n\tsinfo->active_objs = nr_objs - nr_free;\n\tsinfo->num_objs = nr_objs;\n\tsinfo->active_slabs = nr_slabs;\n\tsinfo->num_slabs = nr_slabs;\n\tsinfo->objects_per_slab = oo_objects(s->oo);\n\tsinfo->cache_order = oo_order(s->oo);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *kmem_cache_node;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "oo_order",
          "args": [
            "s->oo"
          ],
          "line": 5897
        },
        "resolved": true,
        "details": {
          "function_name": "oo_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "332-335",
          "snippet": "static inline unsigned int oo_order(struct kmem_cache_order_objects x)\n{\n\treturn x.x >> OO_SHIFT;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define OO_SHIFT\t16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define OO_SHIFT\t16\n\nstatic inline unsigned int oo_order(struct kmem_cache_order_objects x)\n{\n\treturn x.x >> OO_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "oo_objects",
          "args": [
            "s->oo"
          ],
          "line": 5896
        },
        "resolved": true,
        "details": {
          "function_name": "oo_objects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "337-340",
          "snippet": "static inline unsigned int oo_objects(struct kmem_cache_order_objects x)\n{\n\treturn x.x & OO_MASK;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define OO_MASK\t\t((1 << OO_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define OO_MASK\t\t((1 << OO_SHIFT) - 1)\n\nstatic inline unsigned int oo_objects(struct kmem_cache_order_objects x)\n{\n\treturn x.x & OO_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "count_partial",
          "args": [
            "n",
            "count_free"
          ],
          "line": 5889
        },
        "resolved": true,
        "details": {
          "function_name": "count_partial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2389-2401",
          "snippet": "static unsigned long count_partial(struct kmem_cache_node *n,\n\t\t\t\t\tint (*get_count)(struct page *))\n{\n\tunsigned long flags;\n\tunsigned long x = 0;\n\tstruct page *page;\n\n\tspin_lock_irqsave(&n->list_lock, flags);\n\tlist_for_each_entry(page, &n->partial, lru)\n\t\tx += get_count(page);\n\tspin_unlock_irqrestore(&n->list_lock, flags);\n\treturn x;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic unsigned long count_partial(struct kmem_cache_node *n,\n\t\t\t\t\tint (*get_count)(struct page *))\n{\n\tunsigned long flags;\n\tunsigned long x = 0;\n\tstruct page *page;\n\n\tspin_lock_irqsave(&n->list_lock, flags);\n\tlist_for_each_entry(page, &n->partial, lru)\n\t\tx += get_count(page);\n\tspin_unlock_irqrestore(&n->list_lock, flags);\n\treturn x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "node_nr_objs",
          "args": [
            "n"
          ],
          "line": 5888
        },
        "resolved": true,
        "details": {
          "function_name": "node_nr_objs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2382-2385",
          "snippet": "static inline unsigned long node_nr_objs(struct kmem_cache_node *n)\n{\n\treturn atomic_long_read(&n->total_objects);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic inline unsigned long node_nr_objs(struct kmem_cache_node *n)\n{\n\treturn atomic_long_read(&n->total_objects);\n}"
        }
      },
      {
        "call_info": {
          "callee": "node_nr_slabs",
          "args": [
            "n"
          ],
          "line": 5887
        },
        "resolved": true,
        "details": {
          "function_name": "node_nr_slabs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1362-1363",
          "snippet": "static inline unsigned long node_nr_slabs(struct kmem_cache_node *n)\n\t\t\t\t\t\t\t{ return 0; }",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic inline unsigned long node_nr_slabs(struct kmem_cache_node *n)\n\t\t\t\t\t\t\t{ return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "for_each_kmem_cache_node",
          "args": [
            "s",
            "node",
            "n"
          ],
          "line": 5886
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nvoid get_slabinfo(struct kmem_cache *s, struct slabinfo *sinfo)\n{\n\tunsigned long nr_slabs = 0;\n\tunsigned long nr_objs = 0;\n\tunsigned long nr_free = 0;\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tfor_each_kmem_cache_node(s, node, n) {\n\t\tnr_slabs += node_nr_slabs(n);\n\t\tnr_objs += node_nr_objs(n);\n\t\tnr_free += count_partial(n, count_free);\n\t}\n\n\tsinfo->active_objs = nr_objs - nr_free;\n\tsinfo->num_objs = nr_objs;\n\tsinfo->active_slabs = nr_slabs;\n\tsinfo->num_slabs = nr_slabs;\n\tsinfo->objects_per_slab = oo_objects(s->oo);\n\tsinfo->cache_order = oo_order(s->oo);\n}"
  },
  {
    "function_name": "slab_sysfs_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5832-5869",
    "snippet": "static int __init slab_sysfs_init(void)\n{\n\tstruct kmem_cache *s;\n\tint err;\n\n\tmutex_lock(&slab_mutex);\n\n\tslab_kset = kset_create_and_add(\"slab\", &slab_uevent_ops, kernel_kobj);\n\tif (!slab_kset) {\n\t\tmutex_unlock(&slab_mutex);\n\t\tpr_err(\"Cannot register slab subsystem.\\n\");\n\t\treturn -ENOSYS;\n\t}\n\n\tslab_state = FULL;\n\n\tlist_for_each_entry(s, &slab_caches, list) {\n\t\terr = sysfs_slab_add(s);\n\t\tif (err)\n\t\t\tpr_err(\"SLUB: Unable to add boot slab %s to sysfs\\n\",\n\t\t\t       s->name);\n\t}\n\n\twhile (alias_list) {\n\t\tstruct saved_alias *al = alias_list;\n\n\t\talias_list = alias_list->next;\n\t\terr = sysfs_slab_alias(al->s, al->name);\n\t\tif (err)\n\t\t\tpr_err(\"SLUB: Unable to add boot slab alias %s to sysfs\\n\",\n\t\t\t       al->name);\n\t\tkfree(al);\n\t}\n\n\tmutex_unlock(&slab_mutex);\n\tresiliency_test();\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "resiliency_test",
          "args": [],
          "line": 5867
        },
        "resolved": true,
        "details": {
          "function_name": "resiliency_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "4744-4744",
          "snippet": "static void resiliency_test(void) {}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void resiliency_test(void) {}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&slab_mutex"
          ],
          "line": 5866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "al"
          ],
          "line": 5863
        },
        "resolved": true,
        "details": {
          "function_name": "kfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "3925-3943",
          "snippet": "void kfree(const void *x)\n{\n\tstruct page *page;\n\tvoid *object = (void *)x;\n\n\ttrace_kfree(_RET_IP_, x);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(x)))\n\t\treturn;\n\n\tpage = virt_to_head_page(x);\n\tif (unlikely(!PageSlab(page))) {\n\t\tBUG_ON(!PageCompound(page));\n\t\tkfree_hook(object);\n\t\t__free_pages(page, compound_order(page));\n\t\treturn;\n\t}\n\tslab_free(page->slab_cache, page, object, NULL, 1, _RET_IP_);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid kfree(const void *x)\n{\n\tstruct page *page;\n\tvoid *object = (void *)x;\n\n\ttrace_kfree(_RET_IP_, x);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(x)))\n\t\treturn;\n\n\tpage = virt_to_head_page(x);\n\tif (unlikely(!PageSlab(page))) {\n\t\tBUG_ON(!PageCompound(page));\n\t\tkfree_hook(object);\n\t\t__free_pages(page, compound_order(page));\n\t\treturn;\n\t}\n\tslab_free(page->slab_cache, page, object, NULL, 1, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"SLUB: Unable to add boot slab alias %s to sysfs\\n\"",
            "al->name"
          ],
          "line": 5861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_slab_alias",
          "args": [
            "al->s",
            "al->name"
          ],
          "line": 5859
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_slab_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "5809-5830",
          "snippet": "static int sysfs_slab_alias(struct kmem_cache *s, const char *name)\n{\n\tstruct saved_alias *al;\n\n\tif (slab_state == FULL) {\n\t\t/*\n\t\t * If we have a leftover link then remove it.\n\t\t */\n\t\tsysfs_remove_link(&slab_kset->kobj, name);\n\t\treturn sysfs_create_link(&slab_kset->kobj, &s->kobj, name);\n\t}\n\n\tal = kmalloc(sizeof(struct saved_alias), GFP_KERNEL);\n\tif (!al)\n\t\treturn -ENOMEM;\n\n\tal->s = s;\n\tal->name = name;\n\tal->next = alias_list;\n\talias_list = al;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic int sysfs_slab_alias(struct kmem_cache *s, const char *name)\n{\n\tstruct saved_alias *al;\n\n\tif (slab_state == FULL) {\n\t\t/*\n\t\t * If we have a leftover link then remove it.\n\t\t */\n\t\tsysfs_remove_link(&slab_kset->kobj, name);\n\t\treturn sysfs_create_link(&slab_kset->kobj, &s->kobj, name);\n\t}\n\n\tal = kmalloc(sizeof(struct saved_alias), GFP_KERNEL);\n\tif (!al)\n\t\treturn -ENOMEM;\n\n\tal->s = s;\n\tal->name = name;\n\tal->next = alias_list;\n\talias_list = al;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"SLUB: Unable to add boot slab %s to sysfs\\n\"",
            "s->name"
          ],
          "line": 5851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_slab_add",
          "args": [
            "s"
          ],
          "line": 5849
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_slab_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "5705-5770",
          "snippet": "static int sysfs_slab_add(struct kmem_cache *s)\n{\n\tint err;\n\tconst char *name;\n\tstruct kset *kset = cache_kset(s);\n\tint unmergeable = slab_unmergeable(s);\n\n\tINIT_WORK(&s->kobj_remove_work, sysfs_slab_remove_workfn);\n\n\tif (!kset) {\n\t\tkobject_init(&s->kobj, &slab_ktype);\n\t\treturn 0;\n\t}\n\n\tif (!unmergeable && disable_higher_order_debug &&\n\t\t\t(slub_debug & DEBUG_METADATA_FLAGS))\n\t\tunmergeable = 1;\n\n\tif (unmergeable) {\n\t\t/*\n\t\t * Slabcache can never be merged so we can use the name proper.\n\t\t * This is typically the case for debug situations. In that\n\t\t * case we can catch duplicate names easily.\n\t\t */\n\t\tsysfs_remove_link(&slab_kset->kobj, s->name);\n\t\tname = s->name;\n\t} else {\n\t\t/*\n\t\t * Create a unique name for the slab as a target\n\t\t * for the symlinks.\n\t\t */\n\t\tname = create_unique_id(s);\n\t}\n\n\ts->kobj.kset = kset;\n\terr = kobject_init_and_add(&s->kobj, &slab_ktype, NULL, \"%s\", name);\n\tif (err)\n\t\tgoto out;\n\n\terr = sysfs_create_group(&s->kobj, &slab_attr_group);\n\tif (err)\n\t\tgoto out_del_kobj;\n\n#ifdef CONFIG_MEMCG\n\tif (is_root_cache(s) && memcg_sysfs_enabled) {\n\t\ts->memcg_kset = kset_create_and_add(\"cgroup\", NULL, &s->kobj);\n\t\tif (!s->memcg_kset) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_del_kobj;\n\t\t}\n\t}\n#endif\n\n\tkobject_uevent(&s->kobj, KOBJ_ADD);\n\tif (!unmergeable) {\n\t\t/* Setup first alias */\n\t\tsysfs_slab_alias(s, s->name);\n\t}\nout:\n\tif (!unmergeable)\n\t\tkfree(name);\n\treturn err;\nout_del_kobj:\n\tkobject_del(&s->kobj);\n\tgoto out;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define disable_higher_order_debug 0",
            "#define slub_debug 0",
            "#define DEBUG_METADATA_FLAGS (SLAB_RED_ZONE | SLAB_POISON | SLAB_STORE_USER)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define disable_higher_order_debug 0\n#define slub_debug 0\n#define DEBUG_METADATA_FLAGS (SLAB_RED_ZONE | SLAB_POISON | SLAB_STORE_USER)\n\nstatic int sysfs_slab_add(struct kmem_cache *s)\n{\n\tint err;\n\tconst char *name;\n\tstruct kset *kset = cache_kset(s);\n\tint unmergeable = slab_unmergeable(s);\n\n\tINIT_WORK(&s->kobj_remove_work, sysfs_slab_remove_workfn);\n\n\tif (!kset) {\n\t\tkobject_init(&s->kobj, &slab_ktype);\n\t\treturn 0;\n\t}\n\n\tif (!unmergeable && disable_higher_order_debug &&\n\t\t\t(slub_debug & DEBUG_METADATA_FLAGS))\n\t\tunmergeable = 1;\n\n\tif (unmergeable) {\n\t\t/*\n\t\t * Slabcache can never be merged so we can use the name proper.\n\t\t * This is typically the case for debug situations. In that\n\t\t * case we can catch duplicate names easily.\n\t\t */\n\t\tsysfs_remove_link(&slab_kset->kobj, s->name);\n\t\tname = s->name;\n\t} else {\n\t\t/*\n\t\t * Create a unique name for the slab as a target\n\t\t * for the symlinks.\n\t\t */\n\t\tname = create_unique_id(s);\n\t}\n\n\ts->kobj.kset = kset;\n\terr = kobject_init_and_add(&s->kobj, &slab_ktype, NULL, \"%s\", name);\n\tif (err)\n\t\tgoto out;\n\n\terr = sysfs_create_group(&s->kobj, &slab_attr_group);\n\tif (err)\n\t\tgoto out_del_kobj;\n\n#ifdef CONFIG_MEMCG\n\tif (is_root_cache(s) && memcg_sysfs_enabled) {\n\t\ts->memcg_kset = kset_create_and_add(\"cgroup\", NULL, &s->kobj);\n\t\tif (!s->memcg_kset) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_del_kobj;\n\t\t}\n\t}\n#endif\n\n\tkobject_uevent(&s->kobj, KOBJ_ADD);\n\tif (!unmergeable) {\n\t\t/* Setup first alias */\n\t\tsysfs_slab_alias(s, s->name);\n\t}\nout:\n\tif (!unmergeable)\n\t\tkfree(name);\n\treturn err;\nout_del_kobj:\n\tkobject_del(&s->kobj);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "s",
            "&slab_caches",
            "list"
          ],
          "line": 5848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Cannot register slab subsystem.\\n\""
          ],
          "line": 5842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&slab_mutex"
          ],
          "line": 5841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kset_create_and_add",
          "args": [
            "\"slab\"",
            "&slab_uevent_ops",
            "kernel_kobj"
          ],
          "line": 5839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&slab_mutex"
          ],
          "line": 5837
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic int __init slab_sysfs_init(void)\n{\n\tstruct kmem_cache *s;\n\tint err;\n\n\tmutex_lock(&slab_mutex);\n\n\tslab_kset = kset_create_and_add(\"slab\", &slab_uevent_ops, kernel_kobj);\n\tif (!slab_kset) {\n\t\tmutex_unlock(&slab_mutex);\n\t\tpr_err(\"Cannot register slab subsystem.\\n\");\n\t\treturn -ENOSYS;\n\t}\n\n\tslab_state = FULL;\n\n\tlist_for_each_entry(s, &slab_caches, list) {\n\t\terr = sysfs_slab_add(s);\n\t\tif (err)\n\t\t\tpr_err(\"SLUB: Unable to add boot slab %s to sysfs\\n\",\n\t\t\t       s->name);\n\t}\n\n\twhile (alias_list) {\n\t\tstruct saved_alias *al = alias_list;\n\n\t\talias_list = alias_list->next;\n\t\terr = sysfs_slab_alias(al->s, al->name);\n\t\tif (err)\n\t\t\tpr_err(\"SLUB: Unable to add boot slab alias %s to sysfs\\n\",\n\t\t\t       al->name);\n\t\tkfree(al);\n\t}\n\n\tmutex_unlock(&slab_mutex);\n\tresiliency_test();\n\treturn 0;\n}"
  },
  {
    "function_name": "sysfs_slab_alias",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5809-5830",
    "snippet": "static int sysfs_slab_alias(struct kmem_cache *s, const char *name)\n{\n\tstruct saved_alias *al;\n\n\tif (slab_state == FULL) {\n\t\t/*\n\t\t * If we have a leftover link then remove it.\n\t\t */\n\t\tsysfs_remove_link(&slab_kset->kobj, name);\n\t\treturn sysfs_create_link(&slab_kset->kobj, &s->kobj, name);\n\t}\n\n\tal = kmalloc(sizeof(struct saved_alias), GFP_KERNEL);\n\tif (!al)\n\t\treturn -ENOMEM;\n\n\tal->s = s;\n\tal->name = name;\n\tal->next = alias_list;\n\talias_list = al;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct saved_alias)",
            "GFP_KERNEL"
          ],
          "line": 5821
        },
        "resolved": true,
        "details": {
          "function_name": "__kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "3770-3790",
          "snippet": "void *__kmalloc(size_t size, gfp_t flags)\n{\n\tstruct kmem_cache *s;\n\tvoid *ret;\n\n\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE))\n\t\treturn kmalloc_large(size, flags);\n\n\ts = kmalloc_slab(size, flags);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(s)))\n\t\treturn s;\n\n\tret = slab_alloc(s, flags, _RET_IP_);\n\n\ttrace_kmalloc(_RET_IP_, ret, size, s->size, flags);\n\n\tkasan_kmalloc(s, ret, size, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid *__kmalloc(size_t size, gfp_t flags)\n{\n\tstruct kmem_cache *s;\n\tvoid *ret;\n\n\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE))\n\t\treturn kmalloc_large(size, flags);\n\n\ts = kmalloc_slab(size, flags);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(s)))\n\t\treturn s;\n\n\tret = slab_alloc(s, flags, _RET_IP_);\n\n\ttrace_kmalloc(_RET_IP_, ret, size, s->size, flags);\n\n\tkasan_kmalloc(s, ret, size, flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysfs_create_link",
          "args": [
            "&slab_kset->kobj",
            "&s->kobj",
            "name"
          ],
          "line": 5818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_remove_link",
          "args": [
            "&slab_kset->kobj",
            "name"
          ],
          "line": 5817
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic int sysfs_slab_alias(struct kmem_cache *s, const char *name)\n{\n\tstruct saved_alias *al;\n\n\tif (slab_state == FULL) {\n\t\t/*\n\t\t * If we have a leftover link then remove it.\n\t\t */\n\t\tsysfs_remove_link(&slab_kset->kobj, name);\n\t\treturn sysfs_create_link(&slab_kset->kobj, &s->kobj, name);\n\t}\n\n\tal = kmalloc(sizeof(struct saved_alias), GFP_KERNEL);\n\tif (!al)\n\t\treturn -ENOMEM;\n\n\tal->s = s;\n\tal->name = name;\n\tal->next = alias_list;\n\talias_list = al;\n\treturn 0;\n}"
  },
  {
    "function_name": "sysfs_slab_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5791-5795",
    "snippet": "void sysfs_slab_release(struct kmem_cache *s)\n{\n\tif (slab_state >= FULL)\n\t\tkobject_put(&s->kobj);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kobject_put",
          "args": [
            "&s->kobj"
          ],
          "line": 5794
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid sysfs_slab_release(struct kmem_cache *s)\n{\n\tif (slab_state >= FULL)\n\t\tkobject_put(&s->kobj);\n}"
  },
  {
    "function_name": "sysfs_slab_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5785-5789",
    "snippet": "void sysfs_slab_unlink(struct kmem_cache *s)\n{\n\tif (slab_state >= FULL)\n\t\tkobject_del(&s->kobj);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kobject_del",
          "args": [
            "&s->kobj"
          ],
          "line": 5788
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid sysfs_slab_unlink(struct kmem_cache *s)\n{\n\tif (slab_state >= FULL)\n\t\tkobject_del(&s->kobj);\n}"
  },
  {
    "function_name": "sysfs_slab_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5772-5783",
    "snippet": "static void sysfs_slab_remove(struct kmem_cache *s)\n{\n\tif (slab_state < FULL)\n\t\t/*\n\t\t * Sysfs has not been setup yet so no need to remove the\n\t\t * cache from sysfs.\n\t\t */\n\t\treturn;\n\n\tkobject_get(&s->kobj);\n\tschedule_work(&s->kobj_remove_work);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&s->kobj_remove_work"
          ],
          "line": 5782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobject_get",
          "args": [
            "&s->kobj"
          ],
          "line": 5781
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void sysfs_slab_remove(struct kmem_cache *s)\n{\n\tif (slab_state < FULL)\n\t\t/*\n\t\t * Sysfs has not been setup yet so no need to remove the\n\t\t * cache from sysfs.\n\t\t */\n\t\treturn;\n\n\tkobject_get(&s->kobj);\n\tschedule_work(&s->kobj_remove_work);\n}"
  },
  {
    "function_name": "sysfs_slab_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5705-5770",
    "snippet": "static int sysfs_slab_add(struct kmem_cache *s)\n{\n\tint err;\n\tconst char *name;\n\tstruct kset *kset = cache_kset(s);\n\tint unmergeable = slab_unmergeable(s);\n\n\tINIT_WORK(&s->kobj_remove_work, sysfs_slab_remove_workfn);\n\n\tif (!kset) {\n\t\tkobject_init(&s->kobj, &slab_ktype);\n\t\treturn 0;\n\t}\n\n\tif (!unmergeable && disable_higher_order_debug &&\n\t\t\t(slub_debug & DEBUG_METADATA_FLAGS))\n\t\tunmergeable = 1;\n\n\tif (unmergeable) {\n\t\t/*\n\t\t * Slabcache can never be merged so we can use the name proper.\n\t\t * This is typically the case for debug situations. In that\n\t\t * case we can catch duplicate names easily.\n\t\t */\n\t\tsysfs_remove_link(&slab_kset->kobj, s->name);\n\t\tname = s->name;\n\t} else {\n\t\t/*\n\t\t * Create a unique name for the slab as a target\n\t\t * for the symlinks.\n\t\t */\n\t\tname = create_unique_id(s);\n\t}\n\n\ts->kobj.kset = kset;\n\terr = kobject_init_and_add(&s->kobj, &slab_ktype, NULL, \"%s\", name);\n\tif (err)\n\t\tgoto out;\n\n\terr = sysfs_create_group(&s->kobj, &slab_attr_group);\n\tif (err)\n\t\tgoto out_del_kobj;\n\n#ifdef CONFIG_MEMCG\n\tif (is_root_cache(s) && memcg_sysfs_enabled) {\n\t\ts->memcg_kset = kset_create_and_add(\"cgroup\", NULL, &s->kobj);\n\t\tif (!s->memcg_kset) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_del_kobj;\n\t\t}\n\t}\n#endif\n\n\tkobject_uevent(&s->kobj, KOBJ_ADD);\n\tif (!unmergeable) {\n\t\t/* Setup first alias */\n\t\tsysfs_slab_alias(s, s->name);\n\t}\nout:\n\tif (!unmergeable)\n\t\tkfree(name);\n\treturn err;\nout_del_kobj:\n\tkobject_del(&s->kobj);\n\tgoto out;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define disable_higher_order_debug 0",
      "#define slub_debug 0",
      "#define DEBUG_METADATA_FLAGS (SLAB_RED_ZONE | SLAB_POISON | SLAB_STORE_USER)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kobject_del",
          "args": [
            "&s->kobj"
          ],
          "line": 5768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 5765
        },
        "resolved": true,
        "details": {
          "function_name": "kfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "3925-3943",
          "snippet": "void kfree(const void *x)\n{\n\tstruct page *page;\n\tvoid *object = (void *)x;\n\n\ttrace_kfree(_RET_IP_, x);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(x)))\n\t\treturn;\n\n\tpage = virt_to_head_page(x);\n\tif (unlikely(!PageSlab(page))) {\n\t\tBUG_ON(!PageCompound(page));\n\t\tkfree_hook(object);\n\t\t__free_pages(page, compound_order(page));\n\t\treturn;\n\t}\n\tslab_free(page->slab_cache, page, object, NULL, 1, _RET_IP_);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid kfree(const void *x)\n{\n\tstruct page *page;\n\tvoid *object = (void *)x;\n\n\ttrace_kfree(_RET_IP_, x);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(x)))\n\t\treturn;\n\n\tpage = virt_to_head_page(x);\n\tif (unlikely(!PageSlab(page))) {\n\t\tBUG_ON(!PageCompound(page));\n\t\tkfree_hook(object);\n\t\t__free_pages(page, compound_order(page));\n\t\treturn;\n\t}\n\tslab_free(page->slab_cache, page, object, NULL, 1, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysfs_slab_alias",
          "args": [
            "s",
            "s->name"
          ],
          "line": 5761
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_slab_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "5809-5830",
          "snippet": "static int sysfs_slab_alias(struct kmem_cache *s, const char *name)\n{\n\tstruct saved_alias *al;\n\n\tif (slab_state == FULL) {\n\t\t/*\n\t\t * If we have a leftover link then remove it.\n\t\t */\n\t\tsysfs_remove_link(&slab_kset->kobj, name);\n\t\treturn sysfs_create_link(&slab_kset->kobj, &s->kobj, name);\n\t}\n\n\tal = kmalloc(sizeof(struct saved_alias), GFP_KERNEL);\n\tif (!al)\n\t\treturn -ENOMEM;\n\n\tal->s = s;\n\tal->name = name;\n\tal->next = alias_list;\n\talias_list = al;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic int sysfs_slab_alias(struct kmem_cache *s, const char *name)\n{\n\tstruct saved_alias *al;\n\n\tif (slab_state == FULL) {\n\t\t/*\n\t\t * If we have a leftover link then remove it.\n\t\t */\n\t\tsysfs_remove_link(&slab_kset->kobj, name);\n\t\treturn sysfs_create_link(&slab_kset->kobj, &s->kobj, name);\n\t}\n\n\tal = kmalloc(sizeof(struct saved_alias), GFP_KERNEL);\n\tif (!al)\n\t\treturn -ENOMEM;\n\n\tal->s = s;\n\tal->name = name;\n\tal->next = alias_list;\n\talias_list = al;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kobject_uevent",
          "args": [
            "&s->kobj",
            "KOBJ_ADD"
          ],
          "line": 5758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kset_create_and_add",
          "args": [
            "\"cgroup\"",
            "NULL",
            "&s->kobj"
          ],
          "line": 5750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_root_cache",
          "args": [
            "s"
          ],
          "line": 5749
        },
        "resolved": true,
        "details": {
          "function_name": "is_root_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "308-311",
          "snippet": "static inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn true;\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysfs_create_group",
          "args": [
            "&s->kobj",
            "&slab_attr_group"
          ],
          "line": 5744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobject_init_and_add",
          "args": [
            "&s->kobj",
            "&slab_ktype",
            "NULL",
            "\"%s\"",
            "name"
          ],
          "line": 5740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_unique_id",
          "args": [
            "s"
          ],
          "line": 5736
        },
        "resolved": true,
        "details": {
          "function_name": "create_unique_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "5652-5681",
          "snippet": "static char *create_unique_id(struct kmem_cache *s)\n{\n\tchar *name = kmalloc(ID_STR_LENGTH, GFP_KERNEL);\n\tchar *p = name;\n\n\tBUG_ON(!name);\n\n\t*p++ = ':';\n\t/*\n\t * First flags affecting slabcache operations. We will only\n\t * get here for aliasable slabs so we do not need to support\n\t * too many flags. The flags here must cover all flags that\n\t * are matched during merging to guarantee that the id is\n\t * unique.\n\t */\n\tif (s->flags & SLAB_CACHE_DMA)\n\t\t*p++ = 'd';\n\tif (s->flags & SLAB_RECLAIM_ACCOUNT)\n\t\t*p++ = 'a';\n\tif (s->flags & SLAB_CONSISTENCY_CHECKS)\n\t\t*p++ = 'F';\n\tif (s->flags & SLAB_ACCOUNT)\n\t\t*p++ = 'A';\n\tif (p != name + 1)\n\t\t*p++ = '-';\n\tp += sprintf(p, \"%07u\", s->size);\n\n\tBUG_ON(p > name + ID_STR_LENGTH - 1);\n\treturn name;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define ID_STR_LENGTH 64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define ID_STR_LENGTH 64\n\nstatic char *create_unique_id(struct kmem_cache *s)\n{\n\tchar *name = kmalloc(ID_STR_LENGTH, GFP_KERNEL);\n\tchar *p = name;\n\n\tBUG_ON(!name);\n\n\t*p++ = ':';\n\t/*\n\t * First flags affecting slabcache operations. We will only\n\t * get here for aliasable slabs so we do not need to support\n\t * too many flags. The flags here must cover all flags that\n\t * are matched during merging to guarantee that the id is\n\t * unique.\n\t */\n\tif (s->flags & SLAB_CACHE_DMA)\n\t\t*p++ = 'd';\n\tif (s->flags & SLAB_RECLAIM_ACCOUNT)\n\t\t*p++ = 'a';\n\tif (s->flags & SLAB_CONSISTENCY_CHECKS)\n\t\t*p++ = 'F';\n\tif (s->flags & SLAB_ACCOUNT)\n\t\t*p++ = 'A';\n\tif (p != name + 1)\n\t\t*p++ = '-';\n\tp += sprintf(p, \"%07u\", s->size);\n\n\tBUG_ON(p > name + ID_STR_LENGTH - 1);\n\treturn name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysfs_remove_link",
          "args": [
            "&slab_kset->kobj",
            "s->name"
          ],
          "line": 5729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobject_init",
          "args": [
            "&s->kobj",
            "&slab_ktype"
          ],
          "line": 5715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&s->kobj_remove_work",
            "sysfs_slab_remove_workfn"
          ],
          "line": 5712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_unmergeable",
          "args": [
            "s"
          ],
          "line": 5710
        },
        "resolved": true,
        "details": {
          "function_name": "slab_unmergeable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "293-314",
          "snippet": "int slab_unmergeable(struct kmem_cache *s)\n{\n\tif (slab_nomerge || (s->flags & SLAB_NEVER_MERGE))\n\t\treturn 1;\n\n\tif (!is_root_cache(s))\n\t\treturn 1;\n\n\tif (s->ctor)\n\t\treturn 1;\n\n\tif (s->usersize)\n\t\treturn 1;\n\n\t/*\n\t * We may have set a slab to be unmergeable during bootstrap.\n\t */\n\tif (s->refcount < 0)\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define SLAB_NEVER_MERGE (SLAB_RED_ZONE | SLAB_POISON | SLAB_STORE_USER | \\\n\t\tSLAB_TRACE | SLAB_TYPESAFE_BY_RCU | SLAB_NOLEAKTRACE | \\\n\t\tSLAB_FAILSLAB | SLAB_KASAN)"
          ],
          "globals_used": [
            "struct kmem_cache *kmem_cache;",
            "static bool slab_nomerge = !IS_ENABLED(CONFIG_SLAB_MERGE_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\n#define SLAB_NEVER_MERGE (SLAB_RED_ZONE | SLAB_POISON | SLAB_STORE_USER | \\\n\t\tSLAB_TRACE | SLAB_TYPESAFE_BY_RCU | SLAB_NOLEAKTRACE | \\\n\t\tSLAB_FAILSLAB | SLAB_KASAN)\n\nstruct kmem_cache *kmem_cache;\nstatic bool slab_nomerge = !IS_ENABLED(CONFIG_SLAB_MERGE_DEFAULT);\n\nint slab_unmergeable(struct kmem_cache *s)\n{\n\tif (slab_nomerge || (s->flags & SLAB_NEVER_MERGE))\n\t\treturn 1;\n\n\tif (!is_root_cache(s))\n\t\treturn 1;\n\n\tif (s->ctor)\n\t\treturn 1;\n\n\tif (s->usersize)\n\t\treturn 1;\n\n\t/*\n\t * We may have set a slab to be unmergeable during bootstrap.\n\t */\n\tif (s->refcount < 0)\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_kset",
          "args": [
            "s"
          ],
          "line": 5709
        },
        "resolved": true,
        "details": {
          "function_name": "cache_kset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "5637-5644",
          "snippet": "static inline struct kset *cache_kset(struct kmem_cache *s)\n{\n#ifdef CONFIG_MEMCG\n\tif (!is_root_cache(s))\n\t\treturn s->memcg_params.root_cache->memcg_kset;\n#endif\n\treturn slab_kset;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline struct kset *cache_kset(struct kmem_cache *s)\n{\n#ifdef CONFIG_MEMCG\n\tif (!is_root_cache(s))\n\t\treturn s->memcg_params.root_cache->memcg_kset;\n#endif\n\treturn slab_kset;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define disable_higher_order_debug 0\n#define slub_debug 0\n#define DEBUG_METADATA_FLAGS (SLAB_RED_ZONE | SLAB_POISON | SLAB_STORE_USER)\n\nstatic int sysfs_slab_add(struct kmem_cache *s)\n{\n\tint err;\n\tconst char *name;\n\tstruct kset *kset = cache_kset(s);\n\tint unmergeable = slab_unmergeable(s);\n\n\tINIT_WORK(&s->kobj_remove_work, sysfs_slab_remove_workfn);\n\n\tif (!kset) {\n\t\tkobject_init(&s->kobj, &slab_ktype);\n\t\treturn 0;\n\t}\n\n\tif (!unmergeable && disable_higher_order_debug &&\n\t\t\t(slub_debug & DEBUG_METADATA_FLAGS))\n\t\tunmergeable = 1;\n\n\tif (unmergeable) {\n\t\t/*\n\t\t * Slabcache can never be merged so we can use the name proper.\n\t\t * This is typically the case for debug situations. In that\n\t\t * case we can catch duplicate names easily.\n\t\t */\n\t\tsysfs_remove_link(&slab_kset->kobj, s->name);\n\t\tname = s->name;\n\t} else {\n\t\t/*\n\t\t * Create a unique name for the slab as a target\n\t\t * for the symlinks.\n\t\t */\n\t\tname = create_unique_id(s);\n\t}\n\n\ts->kobj.kset = kset;\n\terr = kobject_init_and_add(&s->kobj, &slab_ktype, NULL, \"%s\", name);\n\tif (err)\n\t\tgoto out;\n\n\terr = sysfs_create_group(&s->kobj, &slab_attr_group);\n\tif (err)\n\t\tgoto out_del_kobj;\n\n#ifdef CONFIG_MEMCG\n\tif (is_root_cache(s) && memcg_sysfs_enabled) {\n\t\ts->memcg_kset = kset_create_and_add(\"cgroup\", NULL, &s->kobj);\n\t\tif (!s->memcg_kset) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_del_kobj;\n\t\t}\n\t}\n#endif\n\n\tkobject_uevent(&s->kobj, KOBJ_ADD);\n\tif (!unmergeable) {\n\t\t/* Setup first alias */\n\t\tsysfs_slab_alias(s, s->name);\n\t}\nout:\n\tif (!unmergeable)\n\t\tkfree(name);\n\treturn err;\nout_del_kobj:\n\tkobject_del(&s->kobj);\n\tgoto out;\n}"
  },
  {
    "function_name": "sysfs_slab_remove_workfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5683-5703",
    "snippet": "static void sysfs_slab_remove_workfn(struct work_struct *work)\n{\n\tstruct kmem_cache *s =\n\t\tcontainer_of(work, struct kmem_cache, kobj_remove_work);\n\n\tif (!s->kobj.state_in_sysfs)\n\t\t/*\n\t\t * For a memcg cache, this may be called during\n\t\t * deactivation and again on shutdown.  Remove only once.\n\t\t * A cache is never shut down before deactivation is\n\t\t * complete, so no need to worry about synchronization.\n\t\t */\n\t\tgoto out;\n\n#ifdef CONFIG_MEMCG\n\tkset_unregister(s->memcg_kset);\n#endif\n\tkobject_uevent(&s->kobj, KOBJ_REMOVE);\nout:\n\tkobject_put(&s->kobj);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kobject_put",
          "args": [
            "&s->kobj"
          ],
          "line": 5702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobject_uevent",
          "args": [
            "&s->kobj",
            "KOBJ_REMOVE"
          ],
          "line": 5700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kset_unregister",
          "args": [
            "s->memcg_kset"
          ],
          "line": 5698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structkmem_cache",
            "kobj_remove_work"
          ],
          "line": 5686
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void sysfs_slab_remove_workfn(struct work_struct *work)\n{\n\tstruct kmem_cache *s =\n\t\tcontainer_of(work, struct kmem_cache, kobj_remove_work);\n\n\tif (!s->kobj.state_in_sysfs)\n\t\t/*\n\t\t * For a memcg cache, this may be called during\n\t\t * deactivation and again on shutdown.  Remove only once.\n\t\t * A cache is never shut down before deactivation is\n\t\t * complete, so no need to worry about synchronization.\n\t\t */\n\t\tgoto out;\n\n#ifdef CONFIG_MEMCG\n\tkset_unregister(s->memcg_kset);\n#endif\n\tkobject_uevent(&s->kobj, KOBJ_REMOVE);\nout:\n\tkobject_put(&s->kobj);\n}"
  },
  {
    "function_name": "create_unique_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5652-5681",
    "snippet": "static char *create_unique_id(struct kmem_cache *s)\n{\n\tchar *name = kmalloc(ID_STR_LENGTH, GFP_KERNEL);\n\tchar *p = name;\n\n\tBUG_ON(!name);\n\n\t*p++ = ':';\n\t/*\n\t * First flags affecting slabcache operations. We will only\n\t * get here for aliasable slabs so we do not need to support\n\t * too many flags. The flags here must cover all flags that\n\t * are matched during merging to guarantee that the id is\n\t * unique.\n\t */\n\tif (s->flags & SLAB_CACHE_DMA)\n\t\t*p++ = 'd';\n\tif (s->flags & SLAB_RECLAIM_ACCOUNT)\n\t\t*p++ = 'a';\n\tif (s->flags & SLAB_CONSISTENCY_CHECKS)\n\t\t*p++ = 'F';\n\tif (s->flags & SLAB_ACCOUNT)\n\t\t*p++ = 'A';\n\tif (p != name + 1)\n\t\t*p++ = '-';\n\tp += sprintf(p, \"%07u\", s->size);\n\n\tBUG_ON(p > name + ID_STR_LENGTH - 1);\n\treturn name;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define ID_STR_LENGTH 64"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "p > name + ID_STR_LENGTH - 1"
          ],
          "line": 5679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "p",
            "\"%07u\"",
            "s->size"
          ],
          "line": 5677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!name"
          ],
          "line": 5657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "ID_STR_LENGTH",
            "GFP_KERNEL"
          ],
          "line": 5654
        },
        "resolved": true,
        "details": {
          "function_name": "__kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "3770-3790",
          "snippet": "void *__kmalloc(size_t size, gfp_t flags)\n{\n\tstruct kmem_cache *s;\n\tvoid *ret;\n\n\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE))\n\t\treturn kmalloc_large(size, flags);\n\n\ts = kmalloc_slab(size, flags);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(s)))\n\t\treturn s;\n\n\tret = slab_alloc(s, flags, _RET_IP_);\n\n\ttrace_kmalloc(_RET_IP_, ret, size, s->size, flags);\n\n\tkasan_kmalloc(s, ret, size, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid *__kmalloc(size_t size, gfp_t flags)\n{\n\tstruct kmem_cache *s;\n\tvoid *ret;\n\n\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE))\n\t\treturn kmalloc_large(size, flags);\n\n\ts = kmalloc_slab(size, flags);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(s)))\n\t\treturn s;\n\n\tret = slab_alloc(s, flags, _RET_IP_);\n\n\ttrace_kmalloc(_RET_IP_, ret, size, s->size, flags);\n\n\tkasan_kmalloc(s, ret, size, flags);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define ID_STR_LENGTH 64\n\nstatic char *create_unique_id(struct kmem_cache *s)\n{\n\tchar *name = kmalloc(ID_STR_LENGTH, GFP_KERNEL);\n\tchar *p = name;\n\n\tBUG_ON(!name);\n\n\t*p++ = ':';\n\t/*\n\t * First flags affecting slabcache operations. We will only\n\t * get here for aliasable slabs so we do not need to support\n\t * too many flags. The flags here must cover all flags that\n\t * are matched during merging to guarantee that the id is\n\t * unique.\n\t */\n\tif (s->flags & SLAB_CACHE_DMA)\n\t\t*p++ = 'd';\n\tif (s->flags & SLAB_RECLAIM_ACCOUNT)\n\t\t*p++ = 'a';\n\tif (s->flags & SLAB_CONSISTENCY_CHECKS)\n\t\t*p++ = 'F';\n\tif (s->flags & SLAB_ACCOUNT)\n\t\t*p++ = 'A';\n\tif (p != name + 1)\n\t\t*p++ = '-';\n\tp += sprintf(p, \"%07u\", s->size);\n\n\tBUG_ON(p > name + ID_STR_LENGTH - 1);\n\treturn name;\n}"
  },
  {
    "function_name": "cache_kset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5637-5644",
    "snippet": "static inline struct kset *cache_kset(struct kmem_cache *s)\n{\n#ifdef CONFIG_MEMCG\n\tif (!is_root_cache(s))\n\t\treturn s->memcg_params.root_cache->memcg_kset;\n#endif\n\treturn slab_kset;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_root_cache",
          "args": [
            "s"
          ],
          "line": 5640
        },
        "resolved": true,
        "details": {
          "function_name": "is_root_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "308-311",
          "snippet": "static inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn true;\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline struct kset *cache_kset(struct kmem_cache *s)\n{\n#ifdef CONFIG_MEMCG\n\tif (!is_root_cache(s))\n\t\treturn s->memcg_params.root_cache->memcg_kset;\n#endif\n\treturn slab_kset;\n}"
  },
  {
    "function_name": "uevent_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5622-5629",
    "snippet": "static int uevent_filter(struct kset *kset, struct kobject *kobj)\n{\n\tstruct kobj_type *ktype = get_ktype(kobj);\n\n\tif (ktype == &slab_ktype)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_ktype",
          "args": [
            "kobj"
          ],
          "line": 5624
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic int uevent_filter(struct kset *kset, struct kobject *kobj)\n{\n\tstruct kobj_type *ktype = get_ktype(kobj);\n\n\tif (ktype == &slab_ktype)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "kmem_cache_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5607-5610",
    "snippet": "static void kmem_cache_release(struct kobject *k)\n{\n\tslab_kmem_cache_release(to_slab(k));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "slab_kmem_cache_release",
          "args": [
            "to_slab(k)"
          ],
          "line": 5609
        },
        "resolved": true,
        "details": {
          "function_name": "slab_kmem_cache_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "866-872",
          "snippet": "void slab_kmem_cache_release(struct kmem_cache *s)\n{\n\t__kmem_cache_release(s);\n\tdestroy_memcg_params(s);\n\tkfree_const(s->name);\n\tkmem_cache_free(kmem_cache, s);\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nvoid slab_kmem_cache_release(struct kmem_cache *s)\n{\n\t__kmem_cache_release(s);\n\tdestroy_memcg_params(s);\n\tkfree_const(s->name);\n\tkmem_cache_free(kmem_cache, s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_slab",
          "args": [
            "k"
          ],
          "line": 5609
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void kmem_cache_release(struct kobject *k)\n{\n\tslab_kmem_cache_release(to_slab(k));\n}"
  },
  {
    "function_name": "memcg_propagate_slab_attrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5549-5605",
    "snippet": "static void memcg_propagate_slab_attrs(struct kmem_cache *s)\n{\n#ifdef CONFIG_MEMCG\n\tint i;\n\tchar *buffer = NULL;\n\tstruct kmem_cache *root_cache;\n\n\tif (is_root_cache(s))\n\t\treturn;\n\n\troot_cache = s->memcg_params.root_cache;\n\n\t/*\n\t * This mean this cache had no attribute written. Therefore, no point\n\t * in copying default values around\n\t */\n\tif (!root_cache->max_attr_size)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(slab_attrs); i++) {\n\t\tchar mbuf[64];\n\t\tchar *buf;\n\t\tstruct slab_attribute *attr = to_slab_attr(slab_attrs[i]);\n\t\tssize_t len;\n\n\t\tif (!attr || !attr->store || !attr->show)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * It is really bad that we have to allocate here, so we will\n\t\t * do it only as a fallback. If we actually allocate, though,\n\t\t * we can just use the allocated buffer until the end.\n\t\t *\n\t\t * Most of the slub attributes will tend to be very small in\n\t\t * size, but sysfs allows buffers up to a page, so they can\n\t\t * theoretically happen.\n\t\t */\n\t\tif (buffer)\n\t\t\tbuf = buffer;\n\t\telse if (root_cache->max_attr_size < ARRAY_SIZE(mbuf))\n\t\t\tbuf = mbuf;\n\t\telse {\n\t\t\tbuffer = (char *) get_zeroed_page(GFP_KERNEL);\n\t\t\tif (WARN_ON(!buffer))\n\t\t\t\tcontinue;\n\t\t\tbuf = buffer;\n\t\t}\n\n\t\tlen = attr->show(root_cache, buf);\n\t\tif (len > 0)\n\t\t\tattr->store(s, buf, len);\n\t}\n\n\tif (buffer)\n\t\tfree_page((unsigned long)buffer);\n#endif\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)buffer"
          ],
          "line": 5603
        },
        "resolved": true,
        "details": {
          "function_name": "soft_offline_free_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "1857-1871",
          "snippet": "static int soft_offline_free_page(struct page *page)\n{\n\tint rc = 0;\n\tstruct page *head = compound_head(page);\n\n\tif (PageHuge(head))\n\t\trc = dissolve_free_huge_page(page);\n\tif (!rc) {\n\t\tif (set_hwpoison_free_buddy_page(page))\n\t\t\tnum_poisoned_pages_inc();\n\t\telse\n\t\t\trc = -EBUSY;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define head\t\t(1UL << PG_head)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define head\t\t(1UL << PG_head)\n\nstatic int soft_offline_free_page(struct page *page)\n{\n\tint rc = 0;\n\tstruct page *head = compound_head(page);\n\n\tif (PageHuge(head))\n\t\trc = dissolve_free_huge_page(page);\n\tif (!rc) {\n\t\tif (set_hwpoison_free_buddy_page(page))\n\t\t\tnum_poisoned_pages_inc();\n\t\telse\n\t\t\trc = -EBUSY;\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "attr->store",
          "args": [
            "s",
            "buf",
            "len"
          ],
          "line": 5599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "attr->show",
          "args": [
            "root_cache",
            "buf"
          ],
          "line": 5597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!buffer"
          ],
          "line": 5592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_zeroed_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 5591
        },
        "resolved": true,
        "details": {
          "function_name": "get_zeroed_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4424-4427",
          "snippet": "unsigned long get_zeroed_page(gfp_t gfp_mask)\n{\n\treturn __get_free_pages(gfp_mask | __GFP_ZERO, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nunsigned long get_zeroed_page(gfp_t gfp_mask)\n{\n\treturn __get_free_pages(gfp_mask | __GFP_ZERO, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "mbuf"
          ],
          "line": 5588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_slab_attr",
          "args": [
            "slab_attrs[i]"
          ],
          "line": 5571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "slab_attrs"
          ],
          "line": 5568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_root_cache",
          "args": [
            "s"
          ],
          "line": 5556
        },
        "resolved": true,
        "details": {
          "function_name": "is_root_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "308-311",
          "snippet": "static inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn true;\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void memcg_propagate_slab_attrs(struct kmem_cache *s)\n{\n#ifdef CONFIG_MEMCG\n\tint i;\n\tchar *buffer = NULL;\n\tstruct kmem_cache *root_cache;\n\n\tif (is_root_cache(s))\n\t\treturn;\n\n\troot_cache = s->memcg_params.root_cache;\n\n\t/*\n\t * This mean this cache had no attribute written. Therefore, no point\n\t * in copying default values around\n\t */\n\tif (!root_cache->max_attr_size)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(slab_attrs); i++) {\n\t\tchar mbuf[64];\n\t\tchar *buf;\n\t\tstruct slab_attribute *attr = to_slab_attr(slab_attrs[i]);\n\t\tssize_t len;\n\n\t\tif (!attr || !attr->store || !attr->show)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * It is really bad that we have to allocate here, so we will\n\t\t * do it only as a fallback. If we actually allocate, though,\n\t\t * we can just use the allocated buffer until the end.\n\t\t *\n\t\t * Most of the slub attributes will tend to be very small in\n\t\t * size, but sysfs allows buffers up to a page, so they can\n\t\t * theoretically happen.\n\t\t */\n\t\tif (buffer)\n\t\t\tbuf = buffer;\n\t\telse if (root_cache->max_attr_size < ARRAY_SIZE(mbuf))\n\t\t\tbuf = mbuf;\n\t\telse {\n\t\t\tbuffer = (char *) get_zeroed_page(GFP_KERNEL);\n\t\t\tif (WARN_ON(!buffer))\n\t\t\t\tcontinue;\n\t\t\tbuf = buffer;\n\t\t}\n\n\t\tlen = attr->show(root_cache, buf);\n\t\tif (len > 0)\n\t\t\tattr->store(s, buf, len);\n\t}\n\n\tif (buffer)\n\t\tfree_page((unsigned long)buffer);\n#endif\n}"
  },
  {
    "function_name": "slab_attr_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5501-5547",
    "snippet": "static ssize_t slab_attr_store(struct kobject *kobj,\n\t\t\t\tstruct attribute *attr,\n\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct slab_attribute *attribute;\n\tstruct kmem_cache *s;\n\tint err;\n\n\tattribute = to_slab_attr(attr);\n\ts = to_slab(kobj);\n\n\tif (!attribute->store)\n\t\treturn -EIO;\n\n\terr = attribute->store(s, buf, len);\n#ifdef CONFIG_MEMCG\n\tif (slab_state >= FULL && err >= 0 && is_root_cache(s)) {\n\t\tstruct kmem_cache *c;\n\n\t\tmutex_lock(&slab_mutex);\n\t\tif (s->max_attr_size < len)\n\t\t\ts->max_attr_size = len;\n\n\t\t/*\n\t\t * This is a best effort propagation, so this function's return\n\t\t * value will be determined by the parent cache only. This is\n\t\t * basically because not all attributes will have a well\n\t\t * defined semantics for rollbacks - most of the actions will\n\t\t * have permanent effects.\n\t\t *\n\t\t * Returning the error value of any of the children that fail\n\t\t * is not 100 % defined, in the sense that users seeing the\n\t\t * error code won't be able to know anything about the state of\n\t\t * the cache.\n\t\t *\n\t\t * Only returning the error code for the parent cache at least\n\t\t * has well defined semantics. The cache being written to\n\t\t * directly either failed or succeeded, in which case we loop\n\t\t * through the descendants with best-effort propagation.\n\t\t */\n\t\tfor_each_memcg_cache(c, s)\n\t\t\tattribute->store(c, buf, len);\n\t\tmutex_unlock(&slab_mutex);\n\t}\n#endif\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&slab_mutex"
          ],
          "line": 5543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_memcg_cache",
          "args": [
            "c",
            "buf",
            "len"
          ],
          "line": 5541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_memcg_cache",
          "args": [
            "c",
            "s"
          ],
          "line": 5541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&slab_mutex"
          ],
          "line": 5520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_root_cache",
          "args": [
            "s"
          ],
          "line": 5517
        },
        "resolved": true,
        "details": {
          "function_name": "is_root_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "308-311",
          "snippet": "static inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn true;\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "attribute->store",
          "args": [
            "s",
            "buf",
            "len"
          ],
          "line": 5515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_slab",
          "args": [
            "kobj"
          ],
          "line": 5510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_slab_attr",
          "args": [
            "attr"
          ],
          "line": 5509
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic ssize_t slab_attr_store(struct kobject *kobj,\n\t\t\t\tstruct attribute *attr,\n\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct slab_attribute *attribute;\n\tstruct kmem_cache *s;\n\tint err;\n\n\tattribute = to_slab_attr(attr);\n\ts = to_slab(kobj);\n\n\tif (!attribute->store)\n\t\treturn -EIO;\n\n\terr = attribute->store(s, buf, len);\n#ifdef CONFIG_MEMCG\n\tif (slab_state >= FULL && err >= 0 && is_root_cache(s)) {\n\t\tstruct kmem_cache *c;\n\n\t\tmutex_lock(&slab_mutex);\n\t\tif (s->max_attr_size < len)\n\t\t\ts->max_attr_size = len;\n\n\t\t/*\n\t\t * This is a best effort propagation, so this function's return\n\t\t * value will be determined by the parent cache only. This is\n\t\t * basically because not all attributes will have a well\n\t\t * defined semantics for rollbacks - most of the actions will\n\t\t * have permanent effects.\n\t\t *\n\t\t * Returning the error value of any of the children that fail\n\t\t * is not 100 % defined, in the sense that users seeing the\n\t\t * error code won't be able to know anything about the state of\n\t\t * the cache.\n\t\t *\n\t\t * Only returning the error code for the parent cache at least\n\t\t * has well defined semantics. The cache being written to\n\t\t * directly either failed or succeeded, in which case we loop\n\t\t * through the descendants with best-effort propagation.\n\t\t */\n\t\tfor_each_memcg_cache(c, s)\n\t\t\tattribute->store(c, buf, len);\n\t\tmutex_unlock(&slab_mutex);\n\t}\n#endif\n\treturn err;\n}"
  },
  {
    "function_name": "slab_attr_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5482-5499",
    "snippet": "static ssize_t slab_attr_show(struct kobject *kobj,\n\t\t\t\tstruct attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct slab_attribute *attribute;\n\tstruct kmem_cache *s;\n\tint err;\n\n\tattribute = to_slab_attr(attr);\n\ts = to_slab(kobj);\n\n\tif (!attribute->show)\n\t\treturn -EIO;\n\n\terr = attribute->show(s, buf);\n\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "attribute->show",
          "args": [
            "s",
            "buf"
          ],
          "line": 5496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_slab",
          "args": [
            "kobj"
          ],
          "line": 5491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_slab_attr",
          "args": [
            "attr"
          ],
          "line": 5490
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic ssize_t slab_attr_show(struct kobject *kobj,\n\t\t\t\tstruct attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct slab_attribute *attribute;\n\tstruct kmem_cache *s;\n\tint err;\n\n\tattribute = to_slab_attr(attr);\n\ts = to_slab(kobj);\n\n\tif (!attribute->show)\n\t\treturn -EIO;\n\n\terr = attribute->show(s, buf);\n\n\treturn err;\n}"
  },
  {
    "function_name": "clear_stat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5354-5360",
    "snippet": "static void clear_stat(struct kmem_cache *s, enum stat_item si)\n{\n\tint cpu;\n\n\tfor_each_online_cpu(cpu)\n\t\tper_cpu_ptr(s->cpu_slab, cpu)->stat[si] = 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void clear_stat(struct kmem_cache *s, enum stat_item si)\n{\n\tint cpu;\n\n\tfor_each_online_cpu(cpu)\n\t\tper_cpu_ptr(s->cpu_slab, cpu)->stat[si] = 0;\n}"
  },
  {
    "function_name": "show_stat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5325-5352",
    "snippet": "static int show_stat(struct kmem_cache *s, char *buf, enum stat_item si)\n{\n\tunsigned long sum  = 0;\n\tint cpu;\n\tint len;\n\tint *data = kmalloc_array(nr_cpu_ids, sizeof(int), GFP_KERNEL);\n\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tfor_each_online_cpu(cpu) {\n\t\tunsigned x = per_cpu_ptr(s->cpu_slab, cpu)->stat[si];\n\n\t\tdata[cpu] = x;\n\t\tsum += x;\n\t}\n\n\tlen = sprintf(buf, \"%lu\", sum);\n\n#ifdef CONFIG_SMP\n\tfor_each_online_cpu(cpu) {\n\t\tif (data[cpu] && len < PAGE_SIZE - 20)\n\t\t\tlen += sprintf(buf + len, \" C%d=%u\", cpu, data[cpu]);\n\t}\n#endif\n\tkfree(data);\n\treturn len + sprintf(buf + len, \"\\n\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf + len",
            "\"\\n\""
          ],
          "line": 5351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 5350
        },
        "resolved": true,
        "details": {
          "function_name": "kfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "3925-3943",
          "snippet": "void kfree(const void *x)\n{\n\tstruct page *page;\n\tvoid *object = (void *)x;\n\n\ttrace_kfree(_RET_IP_, x);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(x)))\n\t\treturn;\n\n\tpage = virt_to_head_page(x);\n\tif (unlikely(!PageSlab(page))) {\n\t\tBUG_ON(!PageCompound(page));\n\t\tkfree_hook(object);\n\t\t__free_pages(page, compound_order(page));\n\t\treturn;\n\t}\n\tslab_free(page->slab_cache, page, object, NULL, 1, _RET_IP_);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid kfree(const void *x)\n{\n\tstruct page *page;\n\tvoid *object = (void *)x;\n\n\ttrace_kfree(_RET_IP_, x);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(x)))\n\t\treturn;\n\n\tpage = virt_to_head_page(x);\n\tif (unlikely(!PageSlab(page))) {\n\t\tBUG_ON(!PageCompound(page));\n\t\tkfree_hook(object);\n\t\t__free_pages(page, compound_order(page));\n\t\treturn;\n\t}\n\tslab_free(page->slab_cache, page, object, NULL, 1, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf + len",
            "\" C%d=%u\"",
            "cpu",
            "data[cpu]"
          ],
          "line": 5347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%lu\"",
            "sum"
          ],
          "line": 5342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "s->cpu_slab",
            "cpu"
          ],
          "line": 5336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "nr_cpu_ids",
            "sizeof(int)",
            "GFP_KERNEL"
          ],
          "line": 5330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic int show_stat(struct kmem_cache *s, char *buf, enum stat_item si)\n{\n\tunsigned long sum  = 0;\n\tint cpu;\n\tint len;\n\tint *data = kmalloc_array(nr_cpu_ids, sizeof(int), GFP_KERNEL);\n\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tfor_each_online_cpu(cpu) {\n\t\tunsigned x = per_cpu_ptr(s->cpu_slab, cpu)->stat[si];\n\n\t\tdata[cpu] = x;\n\t\tsum += x;\n\t}\n\n\tlen = sprintf(buf, \"%lu\", sum);\n\n#ifdef CONFIG_SMP\n\tfor_each_online_cpu(cpu) {\n\t\tif (data[cpu] && len < PAGE_SIZE - 20)\n\t\t\tlen += sprintf(buf + len, \" C%d=%u\", cpu, data[cpu]);\n\t}\n#endif\n\tkfree(data);\n\treturn len + sprintf(buf + len, \"\\n\");\n}"
  },
  {
    "function_name": "remote_node_defrag_ratio_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5305-5320",
    "snippet": "static ssize_t remote_node_defrag_ratio_store(struct kmem_cache *s,\n\t\t\t\tconst char *buf, size_t length)\n{\n\tunsigned int ratio;\n\tint err;\n\n\terr = kstrtouint(buf, 10, &ratio);\n\tif (err)\n\t\treturn err;\n\tif (ratio > 100)\n\t\treturn -ERANGE;\n\n\ts->remote_node_defrag_ratio = ratio * 10;\n\n\treturn length;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtouint",
          "args": [
            "buf",
            "10",
            "&ratio"
          ],
          "line": 5311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic ssize_t remote_node_defrag_ratio_store(struct kmem_cache *s,\n\t\t\t\tconst char *buf, size_t length)\n{\n\tunsigned int ratio;\n\tint err;\n\n\terr = kstrtouint(buf, 10, &ratio);\n\tif (err)\n\t\treturn err;\n\tif (ratio > 100)\n\t\treturn -ERANGE;\n\n\ts->remote_node_defrag_ratio = ratio * 10;\n\n\treturn length;\n}"
  },
  {
    "function_name": "remote_node_defrag_ratio_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5300-5303",
    "snippet": "static ssize_t remote_node_defrag_ratio_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", s->remote_node_defrag_ratio / 10);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%u\\n\"",
            "s->remote_node_defrag_ratio / 10"
          ],
          "line": 5302
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic ssize_t remote_node_defrag_ratio_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", s->remote_node_defrag_ratio / 10);\n}"
  },
  {
    "function_name": "shrink_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5288-5296",
    "snippet": "static ssize_t shrink_store(struct kmem_cache *s,\n\t\t\tconst char *buf, size_t length)\n{\n\tif (buf[0] == '1')\n\t\tkmem_cache_shrink(s);\n\telse\n\t\treturn -EINVAL;\n\treturn length;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_shrink",
          "args": [
            "s"
          ],
          "line": 5292
        },
        "resolved": true,
        "details": {
          "function_name": "__kmem_cache_shrink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "3957-4017",
          "snippet": "int __kmem_cache_shrink(struct kmem_cache *s)\n{\n\tint node;\n\tint i;\n\tstruct kmem_cache_node *n;\n\tstruct page *page;\n\tstruct page *t;\n\tstruct list_head discard;\n\tstruct list_head promote[SHRINK_PROMOTE_MAX];\n\tunsigned long flags;\n\tint ret = 0;\n\n\tflush_all(s);\n\tfor_each_kmem_cache_node(s, node, n) {\n\t\tINIT_LIST_HEAD(&discard);\n\t\tfor (i = 0; i < SHRINK_PROMOTE_MAX; i++)\n\t\t\tINIT_LIST_HEAD(promote + i);\n\n\t\tspin_lock_irqsave(&n->list_lock, flags);\n\n\t\t/*\n\t\t * Build lists of slabs to discard or promote.\n\t\t *\n\t\t * Note that concurrent frees may occur while we hold the\n\t\t * list_lock. page->inuse here is the upper limit.\n\t\t */\n\t\tlist_for_each_entry_safe(page, t, &n->partial, lru) {\n\t\t\tint free = page->objects - page->inuse;\n\n\t\t\t/* Do not reread page->inuse */\n\t\t\tbarrier();\n\n\t\t\t/* We do not keep full slabs on the list */\n\t\t\tBUG_ON(free <= 0);\n\n\t\t\tif (free == page->objects) {\n\t\t\t\tlist_move(&page->lru, &discard);\n\t\t\t\tn->nr_partial--;\n\t\t\t} else if (free <= SHRINK_PROMOTE_MAX)\n\t\t\t\tlist_move(&page->lru, promote + free - 1);\n\t\t}\n\n\t\t/*\n\t\t * Promote the slabs filled up most to the head of the\n\t\t * partial list.\n\t\t */\n\t\tfor (i = SHRINK_PROMOTE_MAX - 1; i >= 0; i--)\n\t\t\tlist_splice(promote + i, &n->partial);\n\n\t\tspin_unlock_irqrestore(&n->list_lock, flags);\n\n\t\t/* Release empty slabs */\n\t\tlist_for_each_entry_safe(page, t, &discard, lru)\n\t\t\tdiscard_slab(s, page);\n\n\t\tif (slabs_node(s, node))\n\t\t\tret = 1;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SHRINK_PROMOTE_MAX 32"
          ],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define SHRINK_PROMOTE_MAX 32\n\nstatic struct kmem_cache *kmem_cache_node;\n\nint __kmem_cache_shrink(struct kmem_cache *s)\n{\n\tint node;\n\tint i;\n\tstruct kmem_cache_node *n;\n\tstruct page *page;\n\tstruct page *t;\n\tstruct list_head discard;\n\tstruct list_head promote[SHRINK_PROMOTE_MAX];\n\tunsigned long flags;\n\tint ret = 0;\n\n\tflush_all(s);\n\tfor_each_kmem_cache_node(s, node, n) {\n\t\tINIT_LIST_HEAD(&discard);\n\t\tfor (i = 0; i < SHRINK_PROMOTE_MAX; i++)\n\t\t\tINIT_LIST_HEAD(promote + i);\n\n\t\tspin_lock_irqsave(&n->list_lock, flags);\n\n\t\t/*\n\t\t * Build lists of slabs to discard or promote.\n\t\t *\n\t\t * Note that concurrent frees may occur while we hold the\n\t\t * list_lock. page->inuse here is the upper limit.\n\t\t */\n\t\tlist_for_each_entry_safe(page, t, &n->partial, lru) {\n\t\t\tint free = page->objects - page->inuse;\n\n\t\t\t/* Do not reread page->inuse */\n\t\t\tbarrier();\n\n\t\t\t/* We do not keep full slabs on the list */\n\t\t\tBUG_ON(free <= 0);\n\n\t\t\tif (free == page->objects) {\n\t\t\t\tlist_move(&page->lru, &discard);\n\t\t\t\tn->nr_partial--;\n\t\t\t} else if (free <= SHRINK_PROMOTE_MAX)\n\t\t\t\tlist_move(&page->lru, promote + free - 1);\n\t\t}\n\n\t\t/*\n\t\t * Promote the slabs filled up most to the head of the\n\t\t * partial list.\n\t\t */\n\t\tfor (i = SHRINK_PROMOTE_MAX - 1; i >= 0; i--)\n\t\t\tlist_splice(promote + i, &n->partial);\n\n\t\tspin_unlock_irqrestore(&n->list_lock, flags);\n\n\t\t/* Release empty slabs */\n\t\tlist_for_each_entry_safe(page, t, &discard, lru)\n\t\t\tdiscard_slab(s, page);\n\n\t\tif (slabs_node(s, node))\n\t\t\tret = 1;\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic ssize_t shrink_store(struct kmem_cache *s,\n\t\t\tconst char *buf, size_t length)\n{\n\tif (buf[0] == '1')\n\t\tkmem_cache_shrink(s);\n\telse\n\t\treturn -EINVAL;\n\treturn length;\n}"
  },
  {
    "function_name": "shrink_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5283-5286",
    "snippet": "static ssize_t shrink_show(struct kmem_cache *s, char *buf)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic ssize_t shrink_show(struct kmem_cache *s, char *buf)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "failslab_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5269-5279",
    "snippet": "static ssize_t failslab_store(struct kmem_cache *s, const char *buf,\n\t\t\t\t\t\t\tsize_t length)\n{\n\tif (s->refcount > 1)\n\t\treturn -EINVAL;\n\n\ts->flags &= ~SLAB_FAILSLAB;\n\tif (buf[0] == '1')\n\t\ts->flags |= SLAB_FAILSLAB;\n\treturn length;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic ssize_t failslab_store(struct kmem_cache *s, const char *buf,\n\t\t\t\t\t\t\tsize_t length)\n{\n\tif (s->refcount > 1)\n\t\treturn -EINVAL;\n\n\ts->flags &= ~SLAB_FAILSLAB;\n\tif (buf[0] == '1')\n\t\ts->flags |= SLAB_FAILSLAB;\n\treturn length;\n}"
  },
  {
    "function_name": "failslab_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5264-5267",
    "snippet": "static ssize_t failslab_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", !!(s->flags & SLAB_FAILSLAB));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "!!(s->flags & SLAB_FAILSLAB)"
          ],
          "line": 5266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic ssize_t failslab_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", !!(s->flags & SLAB_FAILSLAB));\n}"
  },
  {
    "function_name": "free_calls_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5254-5259",
    "snippet": "static ssize_t free_calls_show(struct kmem_cache *s, char *buf)\n{\n\tif (!(s->flags & SLAB_STORE_USER))\n\t\treturn -ENOSYS;\n\treturn list_locations(s, buf, TRACK_FREE);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_locations",
          "args": [
            "s",
            "buf",
            "TRACK_FREE"
          ],
          "line": 5258
        },
        "resolved": true,
        "details": {
          "function_name": "list_locations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "4603-4685",
          "snippet": "static int list_locations(struct kmem_cache *s, char *buf,\n\t\t\t\t\tenum track_item alloc)\n{\n\tint len = 0;\n\tunsigned long i;\n\tstruct loc_track t = { 0, 0, NULL };\n\tint node;\n\tstruct kmem_cache_node *n;\n\tunsigned long *map = bitmap_alloc(oo_objects(s->max), GFP_KERNEL);\n\n\tif (!map || !alloc_loc_track(&t, PAGE_SIZE / sizeof(struct location),\n\t\t\t\t     GFP_KERNEL)) {\n\t\tbitmap_free(map);\n\t\treturn sprintf(buf, \"Out of memory\\n\");\n\t}\n\t/* Push back cpu slabs */\n\tflush_all(s);\n\n\tfor_each_kmem_cache_node(s, node, n) {\n\t\tunsigned long flags;\n\t\tstruct page *page;\n\n\t\tif (!atomic_long_read(&n->nr_slabs))\n\t\t\tcontinue;\n\n\t\tspin_lock_irqsave(&n->list_lock, flags);\n\t\tlist_for_each_entry(page, &n->partial, lru)\n\t\t\tprocess_slab(&t, s, page, alloc, map);\n\t\tlist_for_each_entry(page, &n->full, lru)\n\t\t\tprocess_slab(&t, s, page, alloc, map);\n\t\tspin_unlock_irqrestore(&n->list_lock, flags);\n\t}\n\n\tfor (i = 0; i < t.count; i++) {\n\t\tstruct location *l = &t.loc[i];\n\n\t\tif (len > PAGE_SIZE - KSYM_SYMBOL_LEN - 100)\n\t\t\tbreak;\n\t\tlen += sprintf(buf + len, \"%7ld \", l->count);\n\n\t\tif (l->addr)\n\t\t\tlen += sprintf(buf + len, \"%pS\", (void *)l->addr);\n\t\telse\n\t\t\tlen += sprintf(buf + len, \"<not-available>\");\n\n\t\tif (l->sum_time != l->min_time) {\n\t\t\tlen += sprintf(buf + len, \" age=%ld/%ld/%ld\",\n\t\t\t\tl->min_time,\n\t\t\t\t(long)div_u64(l->sum_time, l->count),\n\t\t\t\tl->max_time);\n\t\t} else\n\t\t\tlen += sprintf(buf + len, \" age=%ld\",\n\t\t\t\tl->min_time);\n\n\t\tif (l->min_pid != l->max_pid)\n\t\t\tlen += sprintf(buf + len, \" pid=%ld-%ld\",\n\t\t\t\tl->min_pid, l->max_pid);\n\t\telse\n\t\t\tlen += sprintf(buf + len, \" pid=%ld\",\n\t\t\t\tl->min_pid);\n\n\t\tif (num_online_cpus() > 1 &&\n\t\t\t\t!cpumask_empty(to_cpumask(l->cpus)) &&\n\t\t\t\tlen < PAGE_SIZE - 60)\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len - 50,\n\t\t\t\t\t \" cpus=%*pbl\",\n\t\t\t\t\t cpumask_pr_args(to_cpumask(l->cpus)));\n\n\t\tif (nr_online_nodes > 1 && !nodes_empty(l->nodes) &&\n\t\t\t\tlen < PAGE_SIZE - 60)\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len - 50,\n\t\t\t\t\t \" nodes=%*pbl\",\n\t\t\t\t\t nodemask_pr_args(&l->nodes));\n\n\t\tlen += sprintf(buf + len, \"\\n\");\n\t}\n\n\tfree_loc_track(&t);\n\tbitmap_free(map);\n\tif (!t.count)\n\t\tlen += sprintf(buf, \"No data\\n\");\n\treturn len;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic int list_locations(struct kmem_cache *s, char *buf,\n\t\t\t\t\tenum track_item alloc)\n{\n\tint len = 0;\n\tunsigned long i;\n\tstruct loc_track t = { 0, 0, NULL };\n\tint node;\n\tstruct kmem_cache_node *n;\n\tunsigned long *map = bitmap_alloc(oo_objects(s->max), GFP_KERNEL);\n\n\tif (!map || !alloc_loc_track(&t, PAGE_SIZE / sizeof(struct location),\n\t\t\t\t     GFP_KERNEL)) {\n\t\tbitmap_free(map);\n\t\treturn sprintf(buf, \"Out of memory\\n\");\n\t}\n\t/* Push back cpu slabs */\n\tflush_all(s);\n\n\tfor_each_kmem_cache_node(s, node, n) {\n\t\tunsigned long flags;\n\t\tstruct page *page;\n\n\t\tif (!atomic_long_read(&n->nr_slabs))\n\t\t\tcontinue;\n\n\t\tspin_lock_irqsave(&n->list_lock, flags);\n\t\tlist_for_each_entry(page, &n->partial, lru)\n\t\t\tprocess_slab(&t, s, page, alloc, map);\n\t\tlist_for_each_entry(page, &n->full, lru)\n\t\t\tprocess_slab(&t, s, page, alloc, map);\n\t\tspin_unlock_irqrestore(&n->list_lock, flags);\n\t}\n\n\tfor (i = 0; i < t.count; i++) {\n\t\tstruct location *l = &t.loc[i];\n\n\t\tif (len > PAGE_SIZE - KSYM_SYMBOL_LEN - 100)\n\t\t\tbreak;\n\t\tlen += sprintf(buf + len, \"%7ld \", l->count);\n\n\t\tif (l->addr)\n\t\t\tlen += sprintf(buf + len, \"%pS\", (void *)l->addr);\n\t\telse\n\t\t\tlen += sprintf(buf + len, \"<not-available>\");\n\n\t\tif (l->sum_time != l->min_time) {\n\t\t\tlen += sprintf(buf + len, \" age=%ld/%ld/%ld\",\n\t\t\t\tl->min_time,\n\t\t\t\t(long)div_u64(l->sum_time, l->count),\n\t\t\t\tl->max_time);\n\t\t} else\n\t\t\tlen += sprintf(buf + len, \" age=%ld\",\n\t\t\t\tl->min_time);\n\n\t\tif (l->min_pid != l->max_pid)\n\t\t\tlen += sprintf(buf + len, \" pid=%ld-%ld\",\n\t\t\t\tl->min_pid, l->max_pid);\n\t\telse\n\t\t\tlen += sprintf(buf + len, \" pid=%ld\",\n\t\t\t\tl->min_pid);\n\n\t\tif (num_online_cpus() > 1 &&\n\t\t\t\t!cpumask_empty(to_cpumask(l->cpus)) &&\n\t\t\t\tlen < PAGE_SIZE - 60)\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len - 50,\n\t\t\t\t\t \" cpus=%*pbl\",\n\t\t\t\t\t cpumask_pr_args(to_cpumask(l->cpus)));\n\n\t\tif (nr_online_nodes > 1 && !nodes_empty(l->nodes) &&\n\t\t\t\tlen < PAGE_SIZE - 60)\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len - 50,\n\t\t\t\t\t \" nodes=%*pbl\",\n\t\t\t\t\t nodemask_pr_args(&l->nodes));\n\n\t\tlen += sprintf(buf + len, \"\\n\");\n\t}\n\n\tfree_loc_track(&t);\n\tbitmap_free(map);\n\tif (!t.count)\n\t\tlen += sprintf(buf, \"No data\\n\");\n\treturn len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic ssize_t free_calls_show(struct kmem_cache *s, char *buf)\n{\n\tif (!(s->flags & SLAB_STORE_USER))\n\t\treturn -ENOSYS;\n\treturn list_locations(s, buf, TRACK_FREE);\n}"
  },
  {
    "function_name": "alloc_calls_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5246-5251",
    "snippet": "static ssize_t alloc_calls_show(struct kmem_cache *s, char *buf)\n{\n\tif (!(s->flags & SLAB_STORE_USER))\n\t\treturn -ENOSYS;\n\treturn list_locations(s, buf, TRACK_ALLOC);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_locations",
          "args": [
            "s",
            "buf",
            "TRACK_ALLOC"
          ],
          "line": 5250
        },
        "resolved": true,
        "details": {
          "function_name": "list_locations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "4603-4685",
          "snippet": "static int list_locations(struct kmem_cache *s, char *buf,\n\t\t\t\t\tenum track_item alloc)\n{\n\tint len = 0;\n\tunsigned long i;\n\tstruct loc_track t = { 0, 0, NULL };\n\tint node;\n\tstruct kmem_cache_node *n;\n\tunsigned long *map = bitmap_alloc(oo_objects(s->max), GFP_KERNEL);\n\n\tif (!map || !alloc_loc_track(&t, PAGE_SIZE / sizeof(struct location),\n\t\t\t\t     GFP_KERNEL)) {\n\t\tbitmap_free(map);\n\t\treturn sprintf(buf, \"Out of memory\\n\");\n\t}\n\t/* Push back cpu slabs */\n\tflush_all(s);\n\n\tfor_each_kmem_cache_node(s, node, n) {\n\t\tunsigned long flags;\n\t\tstruct page *page;\n\n\t\tif (!atomic_long_read(&n->nr_slabs))\n\t\t\tcontinue;\n\n\t\tspin_lock_irqsave(&n->list_lock, flags);\n\t\tlist_for_each_entry(page, &n->partial, lru)\n\t\t\tprocess_slab(&t, s, page, alloc, map);\n\t\tlist_for_each_entry(page, &n->full, lru)\n\t\t\tprocess_slab(&t, s, page, alloc, map);\n\t\tspin_unlock_irqrestore(&n->list_lock, flags);\n\t}\n\n\tfor (i = 0; i < t.count; i++) {\n\t\tstruct location *l = &t.loc[i];\n\n\t\tif (len > PAGE_SIZE - KSYM_SYMBOL_LEN - 100)\n\t\t\tbreak;\n\t\tlen += sprintf(buf + len, \"%7ld \", l->count);\n\n\t\tif (l->addr)\n\t\t\tlen += sprintf(buf + len, \"%pS\", (void *)l->addr);\n\t\telse\n\t\t\tlen += sprintf(buf + len, \"<not-available>\");\n\n\t\tif (l->sum_time != l->min_time) {\n\t\t\tlen += sprintf(buf + len, \" age=%ld/%ld/%ld\",\n\t\t\t\tl->min_time,\n\t\t\t\t(long)div_u64(l->sum_time, l->count),\n\t\t\t\tl->max_time);\n\t\t} else\n\t\t\tlen += sprintf(buf + len, \" age=%ld\",\n\t\t\t\tl->min_time);\n\n\t\tif (l->min_pid != l->max_pid)\n\t\t\tlen += sprintf(buf + len, \" pid=%ld-%ld\",\n\t\t\t\tl->min_pid, l->max_pid);\n\t\telse\n\t\t\tlen += sprintf(buf + len, \" pid=%ld\",\n\t\t\t\tl->min_pid);\n\n\t\tif (num_online_cpus() > 1 &&\n\t\t\t\t!cpumask_empty(to_cpumask(l->cpus)) &&\n\t\t\t\tlen < PAGE_SIZE - 60)\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len - 50,\n\t\t\t\t\t \" cpus=%*pbl\",\n\t\t\t\t\t cpumask_pr_args(to_cpumask(l->cpus)));\n\n\t\tif (nr_online_nodes > 1 && !nodes_empty(l->nodes) &&\n\t\t\t\tlen < PAGE_SIZE - 60)\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len - 50,\n\t\t\t\t\t \" nodes=%*pbl\",\n\t\t\t\t\t nodemask_pr_args(&l->nodes));\n\n\t\tlen += sprintf(buf + len, \"\\n\");\n\t}\n\n\tfree_loc_track(&t);\n\tbitmap_free(map);\n\tif (!t.count)\n\t\tlen += sprintf(buf, \"No data\\n\");\n\treturn len;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic int list_locations(struct kmem_cache *s, char *buf,\n\t\t\t\t\tenum track_item alloc)\n{\n\tint len = 0;\n\tunsigned long i;\n\tstruct loc_track t = { 0, 0, NULL };\n\tint node;\n\tstruct kmem_cache_node *n;\n\tunsigned long *map = bitmap_alloc(oo_objects(s->max), GFP_KERNEL);\n\n\tif (!map || !alloc_loc_track(&t, PAGE_SIZE / sizeof(struct location),\n\t\t\t\t     GFP_KERNEL)) {\n\t\tbitmap_free(map);\n\t\treturn sprintf(buf, \"Out of memory\\n\");\n\t}\n\t/* Push back cpu slabs */\n\tflush_all(s);\n\n\tfor_each_kmem_cache_node(s, node, n) {\n\t\tunsigned long flags;\n\t\tstruct page *page;\n\n\t\tif (!atomic_long_read(&n->nr_slabs))\n\t\t\tcontinue;\n\n\t\tspin_lock_irqsave(&n->list_lock, flags);\n\t\tlist_for_each_entry(page, &n->partial, lru)\n\t\t\tprocess_slab(&t, s, page, alloc, map);\n\t\tlist_for_each_entry(page, &n->full, lru)\n\t\t\tprocess_slab(&t, s, page, alloc, map);\n\t\tspin_unlock_irqrestore(&n->list_lock, flags);\n\t}\n\n\tfor (i = 0; i < t.count; i++) {\n\t\tstruct location *l = &t.loc[i];\n\n\t\tif (len > PAGE_SIZE - KSYM_SYMBOL_LEN - 100)\n\t\t\tbreak;\n\t\tlen += sprintf(buf + len, \"%7ld \", l->count);\n\n\t\tif (l->addr)\n\t\t\tlen += sprintf(buf + len, \"%pS\", (void *)l->addr);\n\t\telse\n\t\t\tlen += sprintf(buf + len, \"<not-available>\");\n\n\t\tif (l->sum_time != l->min_time) {\n\t\t\tlen += sprintf(buf + len, \" age=%ld/%ld/%ld\",\n\t\t\t\tl->min_time,\n\t\t\t\t(long)div_u64(l->sum_time, l->count),\n\t\t\t\tl->max_time);\n\t\t} else\n\t\t\tlen += sprintf(buf + len, \" age=%ld\",\n\t\t\t\tl->min_time);\n\n\t\tif (l->min_pid != l->max_pid)\n\t\t\tlen += sprintf(buf + len, \" pid=%ld-%ld\",\n\t\t\t\tl->min_pid, l->max_pid);\n\t\telse\n\t\t\tlen += sprintf(buf + len, \" pid=%ld\",\n\t\t\t\tl->min_pid);\n\n\t\tif (num_online_cpus() > 1 &&\n\t\t\t\t!cpumask_empty(to_cpumask(l->cpus)) &&\n\t\t\t\tlen < PAGE_SIZE - 60)\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len - 50,\n\t\t\t\t\t \" cpus=%*pbl\",\n\t\t\t\t\t cpumask_pr_args(to_cpumask(l->cpus)));\n\n\t\tif (nr_online_nodes > 1 && !nodes_empty(l->nodes) &&\n\t\t\t\tlen < PAGE_SIZE - 60)\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len - 50,\n\t\t\t\t\t \" nodes=%*pbl\",\n\t\t\t\t\t nodemask_pr_args(&l->nodes));\n\n\t\tlen += sprintf(buf + len, \"\\n\");\n\t}\n\n\tfree_loc_track(&t);\n\tbitmap_free(map);\n\tif (!t.count)\n\t\tlen += sprintf(buf, \"No data\\n\");\n\treturn len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic ssize_t alloc_calls_show(struct kmem_cache *s, char *buf)\n{\n\tif (!(s->flags & SLAB_STORE_USER))\n\t\treturn -ENOSYS;\n\treturn list_locations(s, buf, TRACK_ALLOC);\n}"
  },
  {
    "function_name": "validate_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5232-5243",
    "snippet": "static ssize_t validate_store(struct kmem_cache *s,\n\t\t\tconst char *buf, size_t length)\n{\n\tint ret = -EINVAL;\n\n\tif (buf[0] == '1') {\n\t\tret = validate_slab_cache(s);\n\t\tif (ret >= 0)\n\t\t\tret = length;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "validate_slab_cache",
          "args": [
            "s"
          ],
          "line": 5238
        },
        "resolved": true,
        "details": {
          "function_name": "validate_slab_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "4446-4461",
          "snippet": "static long validate_slab_cache(struct kmem_cache *s)\n{\n\tint node;\n\tunsigned long count = 0;\n\tstruct kmem_cache_node *n;\n\tunsigned long *map = bitmap_alloc(oo_objects(s->max), GFP_KERNEL);\n\n\tif (!map)\n\t\treturn -ENOMEM;\n\n\tflush_all(s);\n\tfor_each_kmem_cache_node(s, node, n)\n\t\tcount += validate_slab_node(s, n, map);\n\tbitmap_free(map);\n\treturn count;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic long validate_slab_cache(struct kmem_cache *s)\n{\n\tint node;\n\tunsigned long count = 0;\n\tstruct kmem_cache_node *n;\n\tunsigned long *map = bitmap_alloc(oo_objects(s->max), GFP_KERNEL);\n\n\tif (!map)\n\t\treturn -ENOMEM;\n\n\tflush_all(s);\n\tfor_each_kmem_cache_node(s, node, n)\n\t\tcount += validate_slab_node(s, n, map);\n\tbitmap_free(map);\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic ssize_t validate_store(struct kmem_cache *s,\n\t\t\tconst char *buf, size_t length)\n{\n\tint ret = -EINVAL;\n\n\tif (buf[0] == '1') {\n\t\tret = validate_slab_cache(s);\n\t\tif (ret >= 0)\n\t\t\tret = length;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "validate_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5227-5230",
    "snippet": "static ssize_t validate_show(struct kmem_cache *s, char *buf)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic ssize_t validate_show(struct kmem_cache *s, char *buf)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "store_user_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5211-5224",
    "snippet": "static ssize_t store_user_store(struct kmem_cache *s,\n\t\t\t\tconst char *buf, size_t length)\n{\n\tif (any_slab_objects(s))\n\t\treturn -EBUSY;\n\n\ts->flags &= ~SLAB_STORE_USER;\n\tif (buf[0] == '1') {\n\t\ts->flags &= ~__CMPXCHG_DOUBLE;\n\t\ts->flags |= SLAB_STORE_USER;\n\t}\n\tcalculate_sizes(s, -1);\n\treturn length;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define __CMPXCHG_DOUBLE\t((slab_flags_t __force)0x40000000U)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "calculate_sizes",
          "args": [
            "s",
            "-1"
          ],
          "line": 5222
        },
        "resolved": true,
        "details": {
          "function_name": "calculate_sizes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "3476-3592",
          "snippet": "static int calculate_sizes(struct kmem_cache *s, int forced_order)\n{\n\tslab_flags_t flags = s->flags;\n\tunsigned int size = s->object_size;\n\tunsigned int order;\n\n\t/*\n\t * Round up object size to the next word boundary. We can only\n\t * place the free pointer at word boundaries and this determines\n\t * the possible location of the free pointer.\n\t */\n\tsize = ALIGN(size, sizeof(void *));\n\n#ifdef CONFIG_SLUB_DEBUG\n\t/*\n\t * Determine if we can poison the object itself. If the user of\n\t * the slab may touch the object after free or before allocation\n\t * then we should never poison the object itself.\n\t */\n\tif ((flags & SLAB_POISON) && !(flags & SLAB_TYPESAFE_BY_RCU) &&\n\t\t\t!s->ctor)\n\t\ts->flags |= __OBJECT_POISON;\n\telse\n\t\ts->flags &= ~__OBJECT_POISON;\n\n\n\t/*\n\t * If we are Redzoning then check if there is some space between the\n\t * end of the object and the free pointer. If not then add an\n\t * additional word to have some bytes to store Redzone information.\n\t */\n\tif ((flags & SLAB_RED_ZONE) && size == s->object_size)\n\t\tsize += sizeof(void *);\n#endif\n\n\t/*\n\t * With that we have determined the number of bytes in actual use\n\t * by the object. This is the potential offset to the free pointer.\n\t */\n\ts->inuse = size;\n\n\tif (((flags & (SLAB_TYPESAFE_BY_RCU | SLAB_POISON)) ||\n\t\ts->ctor)) {\n\t\t/*\n\t\t * Relocate free pointer after the object if it is not\n\t\t * permitted to overwrite the first word of the object on\n\t\t * kmem_cache_free.\n\t\t *\n\t\t * This is the case if we do RCU, have a constructor or\n\t\t * destructor or are poisoning the objects.\n\t\t */\n\t\ts->offset = size;\n\t\tsize += sizeof(void *);\n\t}\n\n#ifdef CONFIG_SLUB_DEBUG\n\tif (flags & SLAB_STORE_USER)\n\t\t/*\n\t\t * Need to store information about allocs and frees after\n\t\t * the object.\n\t\t */\n\t\tsize += 2 * sizeof(struct track);\n#endif\n\n\tkasan_cache_create(s, &size, &s->flags);\n#ifdef CONFIG_SLUB_DEBUG\n\tif (flags & SLAB_RED_ZONE) {\n\t\t/*\n\t\t * Add some empty padding so that we can catch\n\t\t * overwrites from earlier objects rather than let\n\t\t * tracking information or the free pointer be\n\t\t * corrupted if a user writes before the start\n\t\t * of the object.\n\t\t */\n\t\tsize += sizeof(void *);\n\n\t\ts->red_left_pad = sizeof(void *);\n\t\ts->red_left_pad = ALIGN(s->red_left_pad, s->align);\n\t\tsize += s->red_left_pad;\n\t}\n#endif\n\n\t/*\n\t * SLUB stores one object immediately after another beginning from\n\t * offset 0. In order to align the objects we have to simply size\n\t * each object to conform to the alignment.\n\t */\n\tsize = ALIGN(size, s->align);\n\ts->size = size;\n\tif (forced_order >= 0)\n\t\torder = forced_order;\n\telse\n\t\torder = calculate_order(size);\n\n\tif ((int)order < 0)\n\t\treturn 0;\n\n\ts->allocflags = 0;\n\tif (order)\n\t\ts->allocflags |= __GFP_COMP;\n\n\tif (s->flags & SLAB_CACHE_DMA)\n\t\ts->allocflags |= GFP_DMA;\n\n\tif (s->flags & SLAB_RECLAIM_ACCOUNT)\n\t\ts->allocflags |= __GFP_RECLAIMABLE;\n\n\t/*\n\t * Determine the number of objects per slab\n\t */\n\ts->oo = oo_make(order, size);\n\ts->min = oo_make(get_order(size), size);\n\tif (oo_objects(s->oo) > oo_objects(s->max))\n\t\ts->max = s->oo;\n\n\treturn !!oo_objects(s->oo);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define __OBJECT_POISON\t\t((slab_flags_t __force)0x80000000U)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define __OBJECT_POISON\t\t((slab_flags_t __force)0x80000000U)\n\nstatic int calculate_sizes(struct kmem_cache *s, int forced_order)\n{\n\tslab_flags_t flags = s->flags;\n\tunsigned int size = s->object_size;\n\tunsigned int order;\n\n\t/*\n\t * Round up object size to the next word boundary. We can only\n\t * place the free pointer at word boundaries and this determines\n\t * the possible location of the free pointer.\n\t */\n\tsize = ALIGN(size, sizeof(void *));\n\n#ifdef CONFIG_SLUB_DEBUG\n\t/*\n\t * Determine if we can poison the object itself. If the user of\n\t * the slab may touch the object after free or before allocation\n\t * then we should never poison the object itself.\n\t */\n\tif ((flags & SLAB_POISON) && !(flags & SLAB_TYPESAFE_BY_RCU) &&\n\t\t\t!s->ctor)\n\t\ts->flags |= __OBJECT_POISON;\n\telse\n\t\ts->flags &= ~__OBJECT_POISON;\n\n\n\t/*\n\t * If we are Redzoning then check if there is some space between the\n\t * end of the object and the free pointer. If not then add an\n\t * additional word to have some bytes to store Redzone information.\n\t */\n\tif ((flags & SLAB_RED_ZONE) && size == s->object_size)\n\t\tsize += sizeof(void *);\n#endif\n\n\t/*\n\t * With that we have determined the number of bytes in actual use\n\t * by the object. This is the potential offset to the free pointer.\n\t */\n\ts->inuse = size;\n\n\tif (((flags & (SLAB_TYPESAFE_BY_RCU | SLAB_POISON)) ||\n\t\ts->ctor)) {\n\t\t/*\n\t\t * Relocate free pointer after the object if it is not\n\t\t * permitted to overwrite the first word of the object on\n\t\t * kmem_cache_free.\n\t\t *\n\t\t * This is the case if we do RCU, have a constructor or\n\t\t * destructor or are poisoning the objects.\n\t\t */\n\t\ts->offset = size;\n\t\tsize += sizeof(void *);\n\t}\n\n#ifdef CONFIG_SLUB_DEBUG\n\tif (flags & SLAB_STORE_USER)\n\t\t/*\n\t\t * Need to store information about allocs and frees after\n\t\t * the object.\n\t\t */\n\t\tsize += 2 * sizeof(struct track);\n#endif\n\n\tkasan_cache_create(s, &size, &s->flags);\n#ifdef CONFIG_SLUB_DEBUG\n\tif (flags & SLAB_RED_ZONE) {\n\t\t/*\n\t\t * Add some empty padding so that we can catch\n\t\t * overwrites from earlier objects rather than let\n\t\t * tracking information or the free pointer be\n\t\t * corrupted if a user writes before the start\n\t\t * of the object.\n\t\t */\n\t\tsize += sizeof(void *);\n\n\t\ts->red_left_pad = sizeof(void *);\n\t\ts->red_left_pad = ALIGN(s->red_left_pad, s->align);\n\t\tsize += s->red_left_pad;\n\t}\n#endif\n\n\t/*\n\t * SLUB stores one object immediately after another beginning from\n\t * offset 0. In order to align the objects we have to simply size\n\t * each object to conform to the alignment.\n\t */\n\tsize = ALIGN(size, s->align);\n\ts->size = size;\n\tif (forced_order >= 0)\n\t\torder = forced_order;\n\telse\n\t\torder = calculate_order(size);\n\n\tif ((int)order < 0)\n\t\treturn 0;\n\n\ts->allocflags = 0;\n\tif (order)\n\t\ts->allocflags |= __GFP_COMP;\n\n\tif (s->flags & SLAB_CACHE_DMA)\n\t\ts->allocflags |= GFP_DMA;\n\n\tif (s->flags & SLAB_RECLAIM_ACCOUNT)\n\t\ts->allocflags |= __GFP_RECLAIMABLE;\n\n\t/*\n\t * Determine the number of objects per slab\n\t */\n\ts->oo = oo_make(order, size);\n\ts->min = oo_make(get_order(size), size);\n\tif (oo_objects(s->oo) > oo_objects(s->max))\n\t\ts->max = s->oo;\n\n\treturn !!oo_objects(s->oo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "any_slab_objects",
          "args": [
            "s"
          ],
          "line": 5214
        },
        "resolved": true,
        "details": {
          "function_name": "any_slab_objects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "4877-4887",
          "snippet": "static int any_slab_objects(struct kmem_cache *s)\n{\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tfor_each_kmem_cache_node(s, node, n)\n\t\tif (atomic_long_read(&n->total_objects))\n\t\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic int any_slab_objects(struct kmem_cache *s)\n{\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tfor_each_kmem_cache_node(s, node, n)\n\t\tif (atomic_long_read(&n->total_objects))\n\t\t\treturn 1;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define __CMPXCHG_DOUBLE\t((slab_flags_t __force)0x40000000U)\n\nstatic ssize_t store_user_store(struct kmem_cache *s,\n\t\t\t\tconst char *buf, size_t length)\n{\n\tif (any_slab_objects(s))\n\t\treturn -EBUSY;\n\n\ts->flags &= ~SLAB_STORE_USER;\n\tif (buf[0] == '1') {\n\t\ts->flags &= ~__CMPXCHG_DOUBLE;\n\t\ts->flags |= SLAB_STORE_USER;\n\t}\n\tcalculate_sizes(s, -1);\n\treturn length;\n}"
  },
  {
    "function_name": "store_user_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5206-5209",
    "snippet": "static ssize_t store_user_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", !!(s->flags & SLAB_STORE_USER));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "!!(s->flags & SLAB_STORE_USER)"
          ],
          "line": 5208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic ssize_t store_user_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", !!(s->flags & SLAB_STORE_USER));\n}"
  },
  {
    "function_name": "poison_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5191-5203",
    "snippet": "static ssize_t poison_store(struct kmem_cache *s,\n\t\t\t\tconst char *buf, size_t length)\n{\n\tif (any_slab_objects(s))\n\t\treturn -EBUSY;\n\n\ts->flags &= ~SLAB_POISON;\n\tif (buf[0] == '1') {\n\t\ts->flags |= SLAB_POISON;\n\t}\n\tcalculate_sizes(s, -1);\n\treturn length;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "calculate_sizes",
          "args": [
            "s",
            "-1"
          ],
          "line": 5201
        },
        "resolved": true,
        "details": {
          "function_name": "calculate_sizes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "3476-3592",
          "snippet": "static int calculate_sizes(struct kmem_cache *s, int forced_order)\n{\n\tslab_flags_t flags = s->flags;\n\tunsigned int size = s->object_size;\n\tunsigned int order;\n\n\t/*\n\t * Round up object size to the next word boundary. We can only\n\t * place the free pointer at word boundaries and this determines\n\t * the possible location of the free pointer.\n\t */\n\tsize = ALIGN(size, sizeof(void *));\n\n#ifdef CONFIG_SLUB_DEBUG\n\t/*\n\t * Determine if we can poison the object itself. If the user of\n\t * the slab may touch the object after free or before allocation\n\t * then we should never poison the object itself.\n\t */\n\tif ((flags & SLAB_POISON) && !(flags & SLAB_TYPESAFE_BY_RCU) &&\n\t\t\t!s->ctor)\n\t\ts->flags |= __OBJECT_POISON;\n\telse\n\t\ts->flags &= ~__OBJECT_POISON;\n\n\n\t/*\n\t * If we are Redzoning then check if there is some space between the\n\t * end of the object and the free pointer. If not then add an\n\t * additional word to have some bytes to store Redzone information.\n\t */\n\tif ((flags & SLAB_RED_ZONE) && size == s->object_size)\n\t\tsize += sizeof(void *);\n#endif\n\n\t/*\n\t * With that we have determined the number of bytes in actual use\n\t * by the object. This is the potential offset to the free pointer.\n\t */\n\ts->inuse = size;\n\n\tif (((flags & (SLAB_TYPESAFE_BY_RCU | SLAB_POISON)) ||\n\t\ts->ctor)) {\n\t\t/*\n\t\t * Relocate free pointer after the object if it is not\n\t\t * permitted to overwrite the first word of the object on\n\t\t * kmem_cache_free.\n\t\t *\n\t\t * This is the case if we do RCU, have a constructor or\n\t\t * destructor or are poisoning the objects.\n\t\t */\n\t\ts->offset = size;\n\t\tsize += sizeof(void *);\n\t}\n\n#ifdef CONFIG_SLUB_DEBUG\n\tif (flags & SLAB_STORE_USER)\n\t\t/*\n\t\t * Need to store information about allocs and frees after\n\t\t * the object.\n\t\t */\n\t\tsize += 2 * sizeof(struct track);\n#endif\n\n\tkasan_cache_create(s, &size, &s->flags);\n#ifdef CONFIG_SLUB_DEBUG\n\tif (flags & SLAB_RED_ZONE) {\n\t\t/*\n\t\t * Add some empty padding so that we can catch\n\t\t * overwrites from earlier objects rather than let\n\t\t * tracking information or the free pointer be\n\t\t * corrupted if a user writes before the start\n\t\t * of the object.\n\t\t */\n\t\tsize += sizeof(void *);\n\n\t\ts->red_left_pad = sizeof(void *);\n\t\ts->red_left_pad = ALIGN(s->red_left_pad, s->align);\n\t\tsize += s->red_left_pad;\n\t}\n#endif\n\n\t/*\n\t * SLUB stores one object immediately after another beginning from\n\t * offset 0. In order to align the objects we have to simply size\n\t * each object to conform to the alignment.\n\t */\n\tsize = ALIGN(size, s->align);\n\ts->size = size;\n\tif (forced_order >= 0)\n\t\torder = forced_order;\n\telse\n\t\torder = calculate_order(size);\n\n\tif ((int)order < 0)\n\t\treturn 0;\n\n\ts->allocflags = 0;\n\tif (order)\n\t\ts->allocflags |= __GFP_COMP;\n\n\tif (s->flags & SLAB_CACHE_DMA)\n\t\ts->allocflags |= GFP_DMA;\n\n\tif (s->flags & SLAB_RECLAIM_ACCOUNT)\n\t\ts->allocflags |= __GFP_RECLAIMABLE;\n\n\t/*\n\t * Determine the number of objects per slab\n\t */\n\ts->oo = oo_make(order, size);\n\ts->min = oo_make(get_order(size), size);\n\tif (oo_objects(s->oo) > oo_objects(s->max))\n\t\ts->max = s->oo;\n\n\treturn !!oo_objects(s->oo);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define __OBJECT_POISON\t\t((slab_flags_t __force)0x80000000U)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define __OBJECT_POISON\t\t((slab_flags_t __force)0x80000000U)\n\nstatic int calculate_sizes(struct kmem_cache *s, int forced_order)\n{\n\tslab_flags_t flags = s->flags;\n\tunsigned int size = s->object_size;\n\tunsigned int order;\n\n\t/*\n\t * Round up object size to the next word boundary. We can only\n\t * place the free pointer at word boundaries and this determines\n\t * the possible location of the free pointer.\n\t */\n\tsize = ALIGN(size, sizeof(void *));\n\n#ifdef CONFIG_SLUB_DEBUG\n\t/*\n\t * Determine if we can poison the object itself. If the user of\n\t * the slab may touch the object after free or before allocation\n\t * then we should never poison the object itself.\n\t */\n\tif ((flags & SLAB_POISON) && !(flags & SLAB_TYPESAFE_BY_RCU) &&\n\t\t\t!s->ctor)\n\t\ts->flags |= __OBJECT_POISON;\n\telse\n\t\ts->flags &= ~__OBJECT_POISON;\n\n\n\t/*\n\t * If we are Redzoning then check if there is some space between the\n\t * end of the object and the free pointer. If not then add an\n\t * additional word to have some bytes to store Redzone information.\n\t */\n\tif ((flags & SLAB_RED_ZONE) && size == s->object_size)\n\t\tsize += sizeof(void *);\n#endif\n\n\t/*\n\t * With that we have determined the number of bytes in actual use\n\t * by the object. This is the potential offset to the free pointer.\n\t */\n\ts->inuse = size;\n\n\tif (((flags & (SLAB_TYPESAFE_BY_RCU | SLAB_POISON)) ||\n\t\ts->ctor)) {\n\t\t/*\n\t\t * Relocate free pointer after the object if it is not\n\t\t * permitted to overwrite the first word of the object on\n\t\t * kmem_cache_free.\n\t\t *\n\t\t * This is the case if we do RCU, have a constructor or\n\t\t * destructor or are poisoning the objects.\n\t\t */\n\t\ts->offset = size;\n\t\tsize += sizeof(void *);\n\t}\n\n#ifdef CONFIG_SLUB_DEBUG\n\tif (flags & SLAB_STORE_USER)\n\t\t/*\n\t\t * Need to store information about allocs and frees after\n\t\t * the object.\n\t\t */\n\t\tsize += 2 * sizeof(struct track);\n#endif\n\n\tkasan_cache_create(s, &size, &s->flags);\n#ifdef CONFIG_SLUB_DEBUG\n\tif (flags & SLAB_RED_ZONE) {\n\t\t/*\n\t\t * Add some empty padding so that we can catch\n\t\t * overwrites from earlier objects rather than let\n\t\t * tracking information or the free pointer be\n\t\t * corrupted if a user writes before the start\n\t\t * of the object.\n\t\t */\n\t\tsize += sizeof(void *);\n\n\t\ts->red_left_pad = sizeof(void *);\n\t\ts->red_left_pad = ALIGN(s->red_left_pad, s->align);\n\t\tsize += s->red_left_pad;\n\t}\n#endif\n\n\t/*\n\t * SLUB stores one object immediately after another beginning from\n\t * offset 0. In order to align the objects we have to simply size\n\t * each object to conform to the alignment.\n\t */\n\tsize = ALIGN(size, s->align);\n\ts->size = size;\n\tif (forced_order >= 0)\n\t\torder = forced_order;\n\telse\n\t\torder = calculate_order(size);\n\n\tif ((int)order < 0)\n\t\treturn 0;\n\n\ts->allocflags = 0;\n\tif (order)\n\t\ts->allocflags |= __GFP_COMP;\n\n\tif (s->flags & SLAB_CACHE_DMA)\n\t\ts->allocflags |= GFP_DMA;\n\n\tif (s->flags & SLAB_RECLAIM_ACCOUNT)\n\t\ts->allocflags |= __GFP_RECLAIMABLE;\n\n\t/*\n\t * Determine the number of objects per slab\n\t */\n\ts->oo = oo_make(order, size);\n\ts->min = oo_make(get_order(size), size);\n\tif (oo_objects(s->oo) > oo_objects(s->max))\n\t\ts->max = s->oo;\n\n\treturn !!oo_objects(s->oo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "any_slab_objects",
          "args": [
            "s"
          ],
          "line": 5194
        },
        "resolved": true,
        "details": {
          "function_name": "any_slab_objects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "4877-4887",
          "snippet": "static int any_slab_objects(struct kmem_cache *s)\n{\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tfor_each_kmem_cache_node(s, node, n)\n\t\tif (atomic_long_read(&n->total_objects))\n\t\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic int any_slab_objects(struct kmem_cache *s)\n{\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tfor_each_kmem_cache_node(s, node, n)\n\t\tif (atomic_long_read(&n->total_objects))\n\t\t\treturn 1;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic ssize_t poison_store(struct kmem_cache *s,\n\t\t\t\tconst char *buf, size_t length)\n{\n\tif (any_slab_objects(s))\n\t\treturn -EBUSY;\n\n\ts->flags &= ~SLAB_POISON;\n\tif (buf[0] == '1') {\n\t\ts->flags |= SLAB_POISON;\n\t}\n\tcalculate_sizes(s, -1);\n\treturn length;\n}"
  },
  {
    "function_name": "poison_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5186-5189",
    "snippet": "static ssize_t poison_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", !!(s->flags & SLAB_POISON));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "!!(s->flags & SLAB_POISON)"
          ],
          "line": 5188
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic ssize_t poison_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", !!(s->flags & SLAB_POISON));\n}"
  },
  {
    "function_name": "red_zone_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5171-5183",
    "snippet": "static ssize_t red_zone_store(struct kmem_cache *s,\n\t\t\t\tconst char *buf, size_t length)\n{\n\tif (any_slab_objects(s))\n\t\treturn -EBUSY;\n\n\ts->flags &= ~SLAB_RED_ZONE;\n\tif (buf[0] == '1') {\n\t\ts->flags |= SLAB_RED_ZONE;\n\t}\n\tcalculate_sizes(s, -1);\n\treturn length;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "calculate_sizes",
          "args": [
            "s",
            "-1"
          ],
          "line": 5181
        },
        "resolved": true,
        "details": {
          "function_name": "calculate_sizes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "3476-3592",
          "snippet": "static int calculate_sizes(struct kmem_cache *s, int forced_order)\n{\n\tslab_flags_t flags = s->flags;\n\tunsigned int size = s->object_size;\n\tunsigned int order;\n\n\t/*\n\t * Round up object size to the next word boundary. We can only\n\t * place the free pointer at word boundaries and this determines\n\t * the possible location of the free pointer.\n\t */\n\tsize = ALIGN(size, sizeof(void *));\n\n#ifdef CONFIG_SLUB_DEBUG\n\t/*\n\t * Determine if we can poison the object itself. If the user of\n\t * the slab may touch the object after free or before allocation\n\t * then we should never poison the object itself.\n\t */\n\tif ((flags & SLAB_POISON) && !(flags & SLAB_TYPESAFE_BY_RCU) &&\n\t\t\t!s->ctor)\n\t\ts->flags |= __OBJECT_POISON;\n\telse\n\t\ts->flags &= ~__OBJECT_POISON;\n\n\n\t/*\n\t * If we are Redzoning then check if there is some space between the\n\t * end of the object and the free pointer. If not then add an\n\t * additional word to have some bytes to store Redzone information.\n\t */\n\tif ((flags & SLAB_RED_ZONE) && size == s->object_size)\n\t\tsize += sizeof(void *);\n#endif\n\n\t/*\n\t * With that we have determined the number of bytes in actual use\n\t * by the object. This is the potential offset to the free pointer.\n\t */\n\ts->inuse = size;\n\n\tif (((flags & (SLAB_TYPESAFE_BY_RCU | SLAB_POISON)) ||\n\t\ts->ctor)) {\n\t\t/*\n\t\t * Relocate free pointer after the object if it is not\n\t\t * permitted to overwrite the first word of the object on\n\t\t * kmem_cache_free.\n\t\t *\n\t\t * This is the case if we do RCU, have a constructor or\n\t\t * destructor or are poisoning the objects.\n\t\t */\n\t\ts->offset = size;\n\t\tsize += sizeof(void *);\n\t}\n\n#ifdef CONFIG_SLUB_DEBUG\n\tif (flags & SLAB_STORE_USER)\n\t\t/*\n\t\t * Need to store information about allocs and frees after\n\t\t * the object.\n\t\t */\n\t\tsize += 2 * sizeof(struct track);\n#endif\n\n\tkasan_cache_create(s, &size, &s->flags);\n#ifdef CONFIG_SLUB_DEBUG\n\tif (flags & SLAB_RED_ZONE) {\n\t\t/*\n\t\t * Add some empty padding so that we can catch\n\t\t * overwrites from earlier objects rather than let\n\t\t * tracking information or the free pointer be\n\t\t * corrupted if a user writes before the start\n\t\t * of the object.\n\t\t */\n\t\tsize += sizeof(void *);\n\n\t\ts->red_left_pad = sizeof(void *);\n\t\ts->red_left_pad = ALIGN(s->red_left_pad, s->align);\n\t\tsize += s->red_left_pad;\n\t}\n#endif\n\n\t/*\n\t * SLUB stores one object immediately after another beginning from\n\t * offset 0. In order to align the objects we have to simply size\n\t * each object to conform to the alignment.\n\t */\n\tsize = ALIGN(size, s->align);\n\ts->size = size;\n\tif (forced_order >= 0)\n\t\torder = forced_order;\n\telse\n\t\torder = calculate_order(size);\n\n\tif ((int)order < 0)\n\t\treturn 0;\n\n\ts->allocflags = 0;\n\tif (order)\n\t\ts->allocflags |= __GFP_COMP;\n\n\tif (s->flags & SLAB_CACHE_DMA)\n\t\ts->allocflags |= GFP_DMA;\n\n\tif (s->flags & SLAB_RECLAIM_ACCOUNT)\n\t\ts->allocflags |= __GFP_RECLAIMABLE;\n\n\t/*\n\t * Determine the number of objects per slab\n\t */\n\ts->oo = oo_make(order, size);\n\ts->min = oo_make(get_order(size), size);\n\tif (oo_objects(s->oo) > oo_objects(s->max))\n\t\ts->max = s->oo;\n\n\treturn !!oo_objects(s->oo);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define __OBJECT_POISON\t\t((slab_flags_t __force)0x80000000U)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define __OBJECT_POISON\t\t((slab_flags_t __force)0x80000000U)\n\nstatic int calculate_sizes(struct kmem_cache *s, int forced_order)\n{\n\tslab_flags_t flags = s->flags;\n\tunsigned int size = s->object_size;\n\tunsigned int order;\n\n\t/*\n\t * Round up object size to the next word boundary. We can only\n\t * place the free pointer at word boundaries and this determines\n\t * the possible location of the free pointer.\n\t */\n\tsize = ALIGN(size, sizeof(void *));\n\n#ifdef CONFIG_SLUB_DEBUG\n\t/*\n\t * Determine if we can poison the object itself. If the user of\n\t * the slab may touch the object after free or before allocation\n\t * then we should never poison the object itself.\n\t */\n\tif ((flags & SLAB_POISON) && !(flags & SLAB_TYPESAFE_BY_RCU) &&\n\t\t\t!s->ctor)\n\t\ts->flags |= __OBJECT_POISON;\n\telse\n\t\ts->flags &= ~__OBJECT_POISON;\n\n\n\t/*\n\t * If we are Redzoning then check if there is some space between the\n\t * end of the object and the free pointer. If not then add an\n\t * additional word to have some bytes to store Redzone information.\n\t */\n\tif ((flags & SLAB_RED_ZONE) && size == s->object_size)\n\t\tsize += sizeof(void *);\n#endif\n\n\t/*\n\t * With that we have determined the number of bytes in actual use\n\t * by the object. This is the potential offset to the free pointer.\n\t */\n\ts->inuse = size;\n\n\tif (((flags & (SLAB_TYPESAFE_BY_RCU | SLAB_POISON)) ||\n\t\ts->ctor)) {\n\t\t/*\n\t\t * Relocate free pointer after the object if it is not\n\t\t * permitted to overwrite the first word of the object on\n\t\t * kmem_cache_free.\n\t\t *\n\t\t * This is the case if we do RCU, have a constructor or\n\t\t * destructor or are poisoning the objects.\n\t\t */\n\t\ts->offset = size;\n\t\tsize += sizeof(void *);\n\t}\n\n#ifdef CONFIG_SLUB_DEBUG\n\tif (flags & SLAB_STORE_USER)\n\t\t/*\n\t\t * Need to store information about allocs and frees after\n\t\t * the object.\n\t\t */\n\t\tsize += 2 * sizeof(struct track);\n#endif\n\n\tkasan_cache_create(s, &size, &s->flags);\n#ifdef CONFIG_SLUB_DEBUG\n\tif (flags & SLAB_RED_ZONE) {\n\t\t/*\n\t\t * Add some empty padding so that we can catch\n\t\t * overwrites from earlier objects rather than let\n\t\t * tracking information or the free pointer be\n\t\t * corrupted if a user writes before the start\n\t\t * of the object.\n\t\t */\n\t\tsize += sizeof(void *);\n\n\t\ts->red_left_pad = sizeof(void *);\n\t\ts->red_left_pad = ALIGN(s->red_left_pad, s->align);\n\t\tsize += s->red_left_pad;\n\t}\n#endif\n\n\t/*\n\t * SLUB stores one object immediately after another beginning from\n\t * offset 0. In order to align the objects we have to simply size\n\t * each object to conform to the alignment.\n\t */\n\tsize = ALIGN(size, s->align);\n\ts->size = size;\n\tif (forced_order >= 0)\n\t\torder = forced_order;\n\telse\n\t\torder = calculate_order(size);\n\n\tif ((int)order < 0)\n\t\treturn 0;\n\n\ts->allocflags = 0;\n\tif (order)\n\t\ts->allocflags |= __GFP_COMP;\n\n\tif (s->flags & SLAB_CACHE_DMA)\n\t\ts->allocflags |= GFP_DMA;\n\n\tif (s->flags & SLAB_RECLAIM_ACCOUNT)\n\t\ts->allocflags |= __GFP_RECLAIMABLE;\n\n\t/*\n\t * Determine the number of objects per slab\n\t */\n\ts->oo = oo_make(order, size);\n\ts->min = oo_make(get_order(size), size);\n\tif (oo_objects(s->oo) > oo_objects(s->max))\n\t\ts->max = s->oo;\n\n\treturn !!oo_objects(s->oo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "any_slab_objects",
          "args": [
            "s"
          ],
          "line": 5174
        },
        "resolved": true,
        "details": {
          "function_name": "any_slab_objects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "4877-4887",
          "snippet": "static int any_slab_objects(struct kmem_cache *s)\n{\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tfor_each_kmem_cache_node(s, node, n)\n\t\tif (atomic_long_read(&n->total_objects))\n\t\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic int any_slab_objects(struct kmem_cache *s)\n{\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tfor_each_kmem_cache_node(s, node, n)\n\t\tif (atomic_long_read(&n->total_objects))\n\t\t\treturn 1;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic ssize_t red_zone_store(struct kmem_cache *s,\n\t\t\t\tconst char *buf, size_t length)\n{\n\tif (any_slab_objects(s))\n\t\treturn -EBUSY;\n\n\ts->flags &= ~SLAB_RED_ZONE;\n\tif (buf[0] == '1') {\n\t\ts->flags |= SLAB_RED_ZONE;\n\t}\n\tcalculate_sizes(s, -1);\n\treturn length;\n}"
  },
  {
    "function_name": "red_zone_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5166-5169",
    "snippet": "static ssize_t red_zone_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", !!(s->flags & SLAB_RED_ZONE));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "!!(s->flags & SLAB_RED_ZONE)"
          ],
          "line": 5168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic ssize_t red_zone_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", !!(s->flags & SLAB_RED_ZONE));\n}"
  },
  {
    "function_name": "trace_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5146-5163",
    "snippet": "static ssize_t trace_store(struct kmem_cache *s, const char *buf,\n\t\t\t\t\t\t\tsize_t length)\n{\n\t/*\n\t * Tracing a merged cache is going to give confusing results\n\t * as well as cause other issues like converting a mergeable\n\t * cache into an umergeable one.\n\t */\n\tif (s->refcount > 1)\n\t\treturn -EINVAL;\n\n\ts->flags &= ~SLAB_TRACE;\n\tif (buf[0] == '1') {\n\t\ts->flags &= ~__CMPXCHG_DOUBLE;\n\t\ts->flags |= SLAB_TRACE;\n\t}\n\treturn length;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define __CMPXCHG_DOUBLE\t((slab_flags_t __force)0x40000000U)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define __CMPXCHG_DOUBLE\t((slab_flags_t __force)0x40000000U)\n\nstatic ssize_t trace_store(struct kmem_cache *s, const char *buf,\n\t\t\t\t\t\t\tsize_t length)\n{\n\t/*\n\t * Tracing a merged cache is going to give confusing results\n\t * as well as cause other issues like converting a mergeable\n\t * cache into an umergeable one.\n\t */\n\tif (s->refcount > 1)\n\t\treturn -EINVAL;\n\n\ts->flags &= ~SLAB_TRACE;\n\tif (buf[0] == '1') {\n\t\ts->flags &= ~__CMPXCHG_DOUBLE;\n\t\ts->flags |= SLAB_TRACE;\n\t}\n\treturn length;\n}"
  },
  {
    "function_name": "trace_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5141-5144",
    "snippet": "static ssize_t trace_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", !!(s->flags & SLAB_TRACE));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "!!(s->flags & SLAB_TRACE)"
          ],
          "line": 5143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic ssize_t trace_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", !!(s->flags & SLAB_TRACE));\n}"
  },
  {
    "function_name": "sanity_checks_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5129-5138",
    "snippet": "static ssize_t sanity_checks_store(struct kmem_cache *s,\n\t\t\t\tconst char *buf, size_t length)\n{\n\ts->flags &= ~SLAB_CONSISTENCY_CHECKS;\n\tif (buf[0] == '1') {\n\t\ts->flags &= ~__CMPXCHG_DOUBLE;\n\t\ts->flags |= SLAB_CONSISTENCY_CHECKS;\n\t}\n\treturn length;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define __CMPXCHG_DOUBLE\t((slab_flags_t __force)0x40000000U)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define __CMPXCHG_DOUBLE\t((slab_flags_t __force)0x40000000U)\n\nstatic ssize_t sanity_checks_store(struct kmem_cache *s,\n\t\t\t\tconst char *buf, size_t length)\n{\n\ts->flags &= ~SLAB_CONSISTENCY_CHECKS;\n\tif (buf[0] == '1') {\n\t\ts->flags &= ~__CMPXCHG_DOUBLE;\n\t\ts->flags |= SLAB_CONSISTENCY_CHECKS;\n\t}\n\treturn length;\n}"
  },
  {
    "function_name": "sanity_checks_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5124-5127",
    "snippet": "static ssize_t sanity_checks_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", !!(s->flags & SLAB_CONSISTENCY_CHECKS));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "!!(s->flags & SLAB_CONSISTENCY_CHECKS)"
          ],
          "line": 5126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic ssize_t sanity_checks_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", !!(s->flags & SLAB_CONSISTENCY_CHECKS));\n}"
  },
  {
    "function_name": "total_objects_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5118-5121",
    "snippet": "static ssize_t total_objects_show(struct kmem_cache *s, char *buf)\n{\n\treturn show_slab_objects(s, buf, SO_ALL|SO_TOTAL);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define SO_TOTAL\t(1 << SL_TOTAL)",
      "#define SO_ALL\t\t(1 << SL_ALL)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_slab_objects",
          "args": [
            "s",
            "buf",
            "SO_ALL|SO_TOTAL"
          ],
          "line": 5120
        },
        "resolved": true,
        "details": {
          "function_name": "show_slab_objects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "4779-4874",
          "snippet": "static ssize_t show_slab_objects(struct kmem_cache *s,\n\t\t\t    char *buf, unsigned long flags)\n{\n\tunsigned long total = 0;\n\tint node;\n\tint x;\n\tunsigned long *nodes;\n\n\tnodes = kcalloc(nr_node_ids, sizeof(unsigned long), GFP_KERNEL);\n\tif (!nodes)\n\t\treturn -ENOMEM;\n\n\tif (flags & SO_CPU) {\n\t\tint cpu;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct kmem_cache_cpu *c = per_cpu_ptr(s->cpu_slab,\n\t\t\t\t\t\t\t       cpu);\n\t\t\tint node;\n\t\t\tstruct page *page;\n\n\t\t\tpage = READ_ONCE(c->page);\n\t\t\tif (!page)\n\t\t\t\tcontinue;\n\n\t\t\tnode = page_to_nid(page);\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = page->objects;\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = page->inuse;\n\t\t\telse\n\t\t\t\tx = 1;\n\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\n\t\t\tpage = slub_percpu_partial_read_once(c);\n\t\t\tif (page) {\n\t\t\t\tnode = page_to_nid(page);\n\t\t\t\tif (flags & SO_TOTAL)\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\telse\n\t\t\t\t\tx = page->pages;\n\t\t\t\ttotal += x;\n\t\t\t\tnodes[node] += x;\n\t\t\t}\n\t\t}\n\t}\n\n\tget_online_mems();\n#ifdef CONFIG_SLUB_DEBUG\n\tif (flags & SO_ALL) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tfor_each_kmem_cache_node(s, node, n) {\n\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = atomic_long_read(&n->total_objects);\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = atomic_long_read(&n->total_objects) -\n\t\t\t\t\tcount_partial(n, count_free);\n\t\t\telse\n\t\t\t\tx = atomic_long_read(&n->nr_slabs);\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\t\t}\n\n\t} else\n#endif\n\tif (flags & SO_PARTIAL) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tfor_each_kmem_cache_node(s, node, n) {\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = count_partial(n, count_total);\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = count_partial(n, count_inuse);\n\t\t\telse\n\t\t\t\tx = n->nr_partial;\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\t\t}\n\t}\n\tx = sprintf(buf, \"%lu\", total);\n#ifdef CONFIG_NUMA\n\tfor (node = 0; node < nr_node_ids; node++)\n\t\tif (nodes[node])\n\t\t\tx += sprintf(buf + x, \" N%d=%lu\",\n\t\t\t\t\tnode, nodes[node]);\n#endif\n\tput_online_mems();\n\tkfree(nodes);\n\treturn x + sprintf(buf + x, \"\\n\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SO_TOTAL\t(1 << SL_TOTAL)",
            "#define SO_OBJECTS\t(1 << SL_OBJECTS)",
            "#define SO_CPU\t\t(1 << SL_CPU)",
            "#define SO_PARTIAL\t(1 << SL_PARTIAL)",
            "#define SO_ALL\t\t(1 << SL_ALL)"
          ],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define SO_TOTAL\t(1 << SL_TOTAL)\n#define SO_OBJECTS\t(1 << SL_OBJECTS)\n#define SO_CPU\t\t(1 << SL_CPU)\n#define SO_PARTIAL\t(1 << SL_PARTIAL)\n#define SO_ALL\t\t(1 << SL_ALL)\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic ssize_t show_slab_objects(struct kmem_cache *s,\n\t\t\t    char *buf, unsigned long flags)\n{\n\tunsigned long total = 0;\n\tint node;\n\tint x;\n\tunsigned long *nodes;\n\n\tnodes = kcalloc(nr_node_ids, sizeof(unsigned long), GFP_KERNEL);\n\tif (!nodes)\n\t\treturn -ENOMEM;\n\n\tif (flags & SO_CPU) {\n\t\tint cpu;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct kmem_cache_cpu *c = per_cpu_ptr(s->cpu_slab,\n\t\t\t\t\t\t\t       cpu);\n\t\t\tint node;\n\t\t\tstruct page *page;\n\n\t\t\tpage = READ_ONCE(c->page);\n\t\t\tif (!page)\n\t\t\t\tcontinue;\n\n\t\t\tnode = page_to_nid(page);\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = page->objects;\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = page->inuse;\n\t\t\telse\n\t\t\t\tx = 1;\n\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\n\t\t\tpage = slub_percpu_partial_read_once(c);\n\t\t\tif (page) {\n\t\t\t\tnode = page_to_nid(page);\n\t\t\t\tif (flags & SO_TOTAL)\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\telse\n\t\t\t\t\tx = page->pages;\n\t\t\t\ttotal += x;\n\t\t\t\tnodes[node] += x;\n\t\t\t}\n\t\t}\n\t}\n\n\tget_online_mems();\n#ifdef CONFIG_SLUB_DEBUG\n\tif (flags & SO_ALL) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tfor_each_kmem_cache_node(s, node, n) {\n\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = atomic_long_read(&n->total_objects);\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = atomic_long_read(&n->total_objects) -\n\t\t\t\t\tcount_partial(n, count_free);\n\t\t\telse\n\t\t\t\tx = atomic_long_read(&n->nr_slabs);\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\t\t}\n\n\t} else\n#endif\n\tif (flags & SO_PARTIAL) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tfor_each_kmem_cache_node(s, node, n) {\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = count_partial(n, count_total);\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = count_partial(n, count_inuse);\n\t\t\telse\n\t\t\t\tx = n->nr_partial;\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\t\t}\n\t}\n\tx = sprintf(buf, \"%lu\", total);\n#ifdef CONFIG_NUMA\n\tfor (node = 0; node < nr_node_ids; node++)\n\t\tif (nodes[node])\n\t\t\tx += sprintf(buf + x, \" N%d=%lu\",\n\t\t\t\t\tnode, nodes[node]);\n#endif\n\tput_online_mems();\n\tkfree(nodes);\n\treturn x + sprintf(buf + x, \"\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define SO_TOTAL\t(1 << SL_TOTAL)\n#define SO_ALL\t\t(1 << SL_ALL)\n\nstatic ssize_t total_objects_show(struct kmem_cache *s, char *buf)\n{\n\treturn show_slab_objects(s, buf, SO_ALL|SO_TOTAL);\n}"
  },
  {
    "function_name": "slabs_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5112-5115",
    "snippet": "static ssize_t slabs_show(struct kmem_cache *s, char *buf)\n{\n\treturn show_slab_objects(s, buf, SO_ALL);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define SO_ALL\t\t(1 << SL_ALL)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_slab_objects",
          "args": [
            "s",
            "buf",
            "SO_ALL"
          ],
          "line": 5114
        },
        "resolved": true,
        "details": {
          "function_name": "show_slab_objects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "4779-4874",
          "snippet": "static ssize_t show_slab_objects(struct kmem_cache *s,\n\t\t\t    char *buf, unsigned long flags)\n{\n\tunsigned long total = 0;\n\tint node;\n\tint x;\n\tunsigned long *nodes;\n\n\tnodes = kcalloc(nr_node_ids, sizeof(unsigned long), GFP_KERNEL);\n\tif (!nodes)\n\t\treturn -ENOMEM;\n\n\tif (flags & SO_CPU) {\n\t\tint cpu;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct kmem_cache_cpu *c = per_cpu_ptr(s->cpu_slab,\n\t\t\t\t\t\t\t       cpu);\n\t\t\tint node;\n\t\t\tstruct page *page;\n\n\t\t\tpage = READ_ONCE(c->page);\n\t\t\tif (!page)\n\t\t\t\tcontinue;\n\n\t\t\tnode = page_to_nid(page);\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = page->objects;\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = page->inuse;\n\t\t\telse\n\t\t\t\tx = 1;\n\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\n\t\t\tpage = slub_percpu_partial_read_once(c);\n\t\t\tif (page) {\n\t\t\t\tnode = page_to_nid(page);\n\t\t\t\tif (flags & SO_TOTAL)\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\telse\n\t\t\t\t\tx = page->pages;\n\t\t\t\ttotal += x;\n\t\t\t\tnodes[node] += x;\n\t\t\t}\n\t\t}\n\t}\n\n\tget_online_mems();\n#ifdef CONFIG_SLUB_DEBUG\n\tif (flags & SO_ALL) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tfor_each_kmem_cache_node(s, node, n) {\n\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = atomic_long_read(&n->total_objects);\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = atomic_long_read(&n->total_objects) -\n\t\t\t\t\tcount_partial(n, count_free);\n\t\t\telse\n\t\t\t\tx = atomic_long_read(&n->nr_slabs);\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\t\t}\n\n\t} else\n#endif\n\tif (flags & SO_PARTIAL) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tfor_each_kmem_cache_node(s, node, n) {\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = count_partial(n, count_total);\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = count_partial(n, count_inuse);\n\t\t\telse\n\t\t\t\tx = n->nr_partial;\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\t\t}\n\t}\n\tx = sprintf(buf, \"%lu\", total);\n#ifdef CONFIG_NUMA\n\tfor (node = 0; node < nr_node_ids; node++)\n\t\tif (nodes[node])\n\t\t\tx += sprintf(buf + x, \" N%d=%lu\",\n\t\t\t\t\tnode, nodes[node]);\n#endif\n\tput_online_mems();\n\tkfree(nodes);\n\treturn x + sprintf(buf + x, \"\\n\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SO_TOTAL\t(1 << SL_TOTAL)",
            "#define SO_OBJECTS\t(1 << SL_OBJECTS)",
            "#define SO_CPU\t\t(1 << SL_CPU)",
            "#define SO_PARTIAL\t(1 << SL_PARTIAL)",
            "#define SO_ALL\t\t(1 << SL_ALL)"
          ],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define SO_TOTAL\t(1 << SL_TOTAL)\n#define SO_OBJECTS\t(1 << SL_OBJECTS)\n#define SO_CPU\t\t(1 << SL_CPU)\n#define SO_PARTIAL\t(1 << SL_PARTIAL)\n#define SO_ALL\t\t(1 << SL_ALL)\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic ssize_t show_slab_objects(struct kmem_cache *s,\n\t\t\t    char *buf, unsigned long flags)\n{\n\tunsigned long total = 0;\n\tint node;\n\tint x;\n\tunsigned long *nodes;\n\n\tnodes = kcalloc(nr_node_ids, sizeof(unsigned long), GFP_KERNEL);\n\tif (!nodes)\n\t\treturn -ENOMEM;\n\n\tif (flags & SO_CPU) {\n\t\tint cpu;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct kmem_cache_cpu *c = per_cpu_ptr(s->cpu_slab,\n\t\t\t\t\t\t\t       cpu);\n\t\t\tint node;\n\t\t\tstruct page *page;\n\n\t\t\tpage = READ_ONCE(c->page);\n\t\t\tif (!page)\n\t\t\t\tcontinue;\n\n\t\t\tnode = page_to_nid(page);\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = page->objects;\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = page->inuse;\n\t\t\telse\n\t\t\t\tx = 1;\n\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\n\t\t\tpage = slub_percpu_partial_read_once(c);\n\t\t\tif (page) {\n\t\t\t\tnode = page_to_nid(page);\n\t\t\t\tif (flags & SO_TOTAL)\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\telse\n\t\t\t\t\tx = page->pages;\n\t\t\t\ttotal += x;\n\t\t\t\tnodes[node] += x;\n\t\t\t}\n\t\t}\n\t}\n\n\tget_online_mems();\n#ifdef CONFIG_SLUB_DEBUG\n\tif (flags & SO_ALL) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tfor_each_kmem_cache_node(s, node, n) {\n\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = atomic_long_read(&n->total_objects);\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = atomic_long_read(&n->total_objects) -\n\t\t\t\t\tcount_partial(n, count_free);\n\t\t\telse\n\t\t\t\tx = atomic_long_read(&n->nr_slabs);\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\t\t}\n\n\t} else\n#endif\n\tif (flags & SO_PARTIAL) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tfor_each_kmem_cache_node(s, node, n) {\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = count_partial(n, count_total);\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = count_partial(n, count_inuse);\n\t\t\telse\n\t\t\t\tx = n->nr_partial;\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\t\t}\n\t}\n\tx = sprintf(buf, \"%lu\", total);\n#ifdef CONFIG_NUMA\n\tfor (node = 0; node < nr_node_ids; node++)\n\t\tif (nodes[node])\n\t\t\tx += sprintf(buf + x, \" N%d=%lu\",\n\t\t\t\t\tnode, nodes[node]);\n#endif\n\tput_online_mems();\n\tkfree(nodes);\n\treturn x + sprintf(buf + x, \"\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define SO_ALL\t\t(1 << SL_ALL)\n\nstatic ssize_t slabs_show(struct kmem_cache *s, char *buf)\n{\n\treturn show_slab_objects(s, buf, SO_ALL);\n}"
  },
  {
    "function_name": "destroy_by_rcu_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5105-5108",
    "snippet": "static ssize_t destroy_by_rcu_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", !!(s->flags & SLAB_TYPESAFE_BY_RCU));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "!!(s->flags & SLAB_TYPESAFE_BY_RCU)"
          ],
          "line": 5107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic ssize_t destroy_by_rcu_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", !!(s->flags & SLAB_TYPESAFE_BY_RCU));\n}"
  },
  {
    "function_name": "usersize_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5099-5102",
    "snippet": "static ssize_t usersize_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", s->usersize);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%u\\n\"",
            "s->usersize"
          ],
          "line": 5101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic ssize_t usersize_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", s->usersize);\n}"
  },
  {
    "function_name": "cache_dma_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5092-5095",
    "snippet": "static ssize_t cache_dma_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", !!(s->flags & SLAB_CACHE_DMA));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "!!(s->flags & SLAB_CACHE_DMA)"
          ],
          "line": 5094
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic ssize_t cache_dma_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", !!(s->flags & SLAB_CACHE_DMA));\n}"
  },
  {
    "function_name": "hwcache_align_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5085-5088",
    "snippet": "static ssize_t hwcache_align_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", !!(s->flags & SLAB_HWCACHE_ALIGN));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "!!(s->flags & SLAB_HWCACHE_ALIGN)"
          ],
          "line": 5087
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic ssize_t hwcache_align_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", !!(s->flags & SLAB_HWCACHE_ALIGN));\n}"
  },
  {
    "function_name": "reclaim_account_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5075-5082",
    "snippet": "static ssize_t reclaim_account_store(struct kmem_cache *s,\n\t\t\t\tconst char *buf, size_t length)\n{\n\ts->flags &= ~SLAB_RECLAIM_ACCOUNT;\n\tif (buf[0] == '1')\n\t\ts->flags |= SLAB_RECLAIM_ACCOUNT;\n\treturn length;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic ssize_t reclaim_account_store(struct kmem_cache *s,\n\t\t\t\tconst char *buf, size_t length)\n{\n\ts->flags &= ~SLAB_RECLAIM_ACCOUNT;\n\tif (buf[0] == '1')\n\t\ts->flags |= SLAB_RECLAIM_ACCOUNT;\n\treturn length;\n}"
  },
  {
    "function_name": "reclaim_account_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5070-5073",
    "snippet": "static ssize_t reclaim_account_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", !!(s->flags & SLAB_RECLAIM_ACCOUNT));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "!!(s->flags & SLAB_RECLAIM_ACCOUNT)"
          ],
          "line": 5072
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic ssize_t reclaim_account_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", !!(s->flags & SLAB_RECLAIM_ACCOUNT));\n}"
  },
  {
    "function_name": "slabs_cpu_partial_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5035-5067",
    "snippet": "static ssize_t slabs_cpu_partial_show(struct kmem_cache *s, char *buf)\n{\n\tint objects = 0;\n\tint pages = 0;\n\tint cpu;\n\tint len;\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct page *page;\n\n\t\tpage = slub_percpu_partial(per_cpu_ptr(s->cpu_slab, cpu));\n\n\t\tif (page) {\n\t\t\tpages += page->pages;\n\t\t\tobjects += page->pobjects;\n\t\t}\n\t}\n\n\tlen = sprintf(buf, \"%d(%d)\", objects, pages);\n\n#ifdef CONFIG_SMP\n\tfor_each_online_cpu(cpu) {\n\t\tstruct page *page;\n\n\t\tpage = slub_percpu_partial(per_cpu_ptr(s->cpu_slab, cpu));\n\n\t\tif (page && len < PAGE_SIZE - 20)\n\t\t\tlen += sprintf(buf + len, \" C%d=%d(%d)\", cpu,\n\t\t\t\tpage->pobjects, page->pages);\n\t}\n#endif\n\treturn len + sprintf(buf + len, \"\\n\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf + len",
            "\"\\n\""
          ],
          "line": 5066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf + len",
            "\" C%d=%d(%d)\"",
            "cpu",
            "page->pobjects",
            "page->pages"
          ],
          "line": 5062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slub_percpu_partial",
          "args": [
            "per_cpu_ptr(s->cpu_slab, cpu)"
          ],
          "line": 5059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "s->cpu_slab",
            "cpu"
          ],
          "line": 5059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d(%d)\"",
            "objects",
            "pages"
          ],
          "line": 5053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slub_percpu_partial",
          "args": [
            "per_cpu_ptr(s->cpu_slab, cpu)"
          ],
          "line": 5045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "s->cpu_slab",
            "cpu"
          ],
          "line": 5045
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic ssize_t slabs_cpu_partial_show(struct kmem_cache *s, char *buf)\n{\n\tint objects = 0;\n\tint pages = 0;\n\tint cpu;\n\tint len;\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct page *page;\n\n\t\tpage = slub_percpu_partial(per_cpu_ptr(s->cpu_slab, cpu));\n\n\t\tif (page) {\n\t\t\tpages += page->pages;\n\t\t\tobjects += page->pobjects;\n\t\t}\n\t}\n\n\tlen = sprintf(buf, \"%d(%d)\", objects, pages);\n\n#ifdef CONFIG_SMP\n\tfor_each_online_cpu(cpu) {\n\t\tstruct page *page;\n\n\t\tpage = slub_percpu_partial(per_cpu_ptr(s->cpu_slab, cpu));\n\n\t\tif (page && len < PAGE_SIZE - 20)\n\t\t\tlen += sprintf(buf + len, \" C%d=%d(%d)\", cpu,\n\t\t\t\tpage->pobjects, page->pages);\n\t}\n#endif\n\treturn len + sprintf(buf + len, \"\\n\");\n}"
  },
  {
    "function_name": "objects_partial_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5029-5032",
    "snippet": "static ssize_t objects_partial_show(struct kmem_cache *s, char *buf)\n{\n\treturn show_slab_objects(s, buf, SO_PARTIAL|SO_OBJECTS);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define SO_OBJECTS\t(1 << SL_OBJECTS)",
      "#define SO_PARTIAL\t(1 << SL_PARTIAL)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_slab_objects",
          "args": [
            "s",
            "buf",
            "SO_PARTIAL|SO_OBJECTS"
          ],
          "line": 5031
        },
        "resolved": true,
        "details": {
          "function_name": "show_slab_objects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "4779-4874",
          "snippet": "static ssize_t show_slab_objects(struct kmem_cache *s,\n\t\t\t    char *buf, unsigned long flags)\n{\n\tunsigned long total = 0;\n\tint node;\n\tint x;\n\tunsigned long *nodes;\n\n\tnodes = kcalloc(nr_node_ids, sizeof(unsigned long), GFP_KERNEL);\n\tif (!nodes)\n\t\treturn -ENOMEM;\n\n\tif (flags & SO_CPU) {\n\t\tint cpu;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct kmem_cache_cpu *c = per_cpu_ptr(s->cpu_slab,\n\t\t\t\t\t\t\t       cpu);\n\t\t\tint node;\n\t\t\tstruct page *page;\n\n\t\t\tpage = READ_ONCE(c->page);\n\t\t\tif (!page)\n\t\t\t\tcontinue;\n\n\t\t\tnode = page_to_nid(page);\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = page->objects;\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = page->inuse;\n\t\t\telse\n\t\t\t\tx = 1;\n\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\n\t\t\tpage = slub_percpu_partial_read_once(c);\n\t\t\tif (page) {\n\t\t\t\tnode = page_to_nid(page);\n\t\t\t\tif (flags & SO_TOTAL)\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\telse\n\t\t\t\t\tx = page->pages;\n\t\t\t\ttotal += x;\n\t\t\t\tnodes[node] += x;\n\t\t\t}\n\t\t}\n\t}\n\n\tget_online_mems();\n#ifdef CONFIG_SLUB_DEBUG\n\tif (flags & SO_ALL) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tfor_each_kmem_cache_node(s, node, n) {\n\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = atomic_long_read(&n->total_objects);\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = atomic_long_read(&n->total_objects) -\n\t\t\t\t\tcount_partial(n, count_free);\n\t\t\telse\n\t\t\t\tx = atomic_long_read(&n->nr_slabs);\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\t\t}\n\n\t} else\n#endif\n\tif (flags & SO_PARTIAL) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tfor_each_kmem_cache_node(s, node, n) {\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = count_partial(n, count_total);\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = count_partial(n, count_inuse);\n\t\t\telse\n\t\t\t\tx = n->nr_partial;\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\t\t}\n\t}\n\tx = sprintf(buf, \"%lu\", total);\n#ifdef CONFIG_NUMA\n\tfor (node = 0; node < nr_node_ids; node++)\n\t\tif (nodes[node])\n\t\t\tx += sprintf(buf + x, \" N%d=%lu\",\n\t\t\t\t\tnode, nodes[node]);\n#endif\n\tput_online_mems();\n\tkfree(nodes);\n\treturn x + sprintf(buf + x, \"\\n\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SO_TOTAL\t(1 << SL_TOTAL)",
            "#define SO_OBJECTS\t(1 << SL_OBJECTS)",
            "#define SO_CPU\t\t(1 << SL_CPU)",
            "#define SO_PARTIAL\t(1 << SL_PARTIAL)",
            "#define SO_ALL\t\t(1 << SL_ALL)"
          ],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define SO_TOTAL\t(1 << SL_TOTAL)\n#define SO_OBJECTS\t(1 << SL_OBJECTS)\n#define SO_CPU\t\t(1 << SL_CPU)\n#define SO_PARTIAL\t(1 << SL_PARTIAL)\n#define SO_ALL\t\t(1 << SL_ALL)\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic ssize_t show_slab_objects(struct kmem_cache *s,\n\t\t\t    char *buf, unsigned long flags)\n{\n\tunsigned long total = 0;\n\tint node;\n\tint x;\n\tunsigned long *nodes;\n\n\tnodes = kcalloc(nr_node_ids, sizeof(unsigned long), GFP_KERNEL);\n\tif (!nodes)\n\t\treturn -ENOMEM;\n\n\tif (flags & SO_CPU) {\n\t\tint cpu;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct kmem_cache_cpu *c = per_cpu_ptr(s->cpu_slab,\n\t\t\t\t\t\t\t       cpu);\n\t\t\tint node;\n\t\t\tstruct page *page;\n\n\t\t\tpage = READ_ONCE(c->page);\n\t\t\tif (!page)\n\t\t\t\tcontinue;\n\n\t\t\tnode = page_to_nid(page);\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = page->objects;\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = page->inuse;\n\t\t\telse\n\t\t\t\tx = 1;\n\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\n\t\t\tpage = slub_percpu_partial_read_once(c);\n\t\t\tif (page) {\n\t\t\t\tnode = page_to_nid(page);\n\t\t\t\tif (flags & SO_TOTAL)\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\telse\n\t\t\t\t\tx = page->pages;\n\t\t\t\ttotal += x;\n\t\t\t\tnodes[node] += x;\n\t\t\t}\n\t\t}\n\t}\n\n\tget_online_mems();\n#ifdef CONFIG_SLUB_DEBUG\n\tif (flags & SO_ALL) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tfor_each_kmem_cache_node(s, node, n) {\n\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = atomic_long_read(&n->total_objects);\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = atomic_long_read(&n->total_objects) -\n\t\t\t\t\tcount_partial(n, count_free);\n\t\t\telse\n\t\t\t\tx = atomic_long_read(&n->nr_slabs);\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\t\t}\n\n\t} else\n#endif\n\tif (flags & SO_PARTIAL) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tfor_each_kmem_cache_node(s, node, n) {\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = count_partial(n, count_total);\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = count_partial(n, count_inuse);\n\t\t\telse\n\t\t\t\tx = n->nr_partial;\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\t\t}\n\t}\n\tx = sprintf(buf, \"%lu\", total);\n#ifdef CONFIG_NUMA\n\tfor (node = 0; node < nr_node_ids; node++)\n\t\tif (nodes[node])\n\t\t\tx += sprintf(buf + x, \" N%d=%lu\",\n\t\t\t\t\tnode, nodes[node]);\n#endif\n\tput_online_mems();\n\tkfree(nodes);\n\treturn x + sprintf(buf + x, \"\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define SO_OBJECTS\t(1 << SL_OBJECTS)\n#define SO_PARTIAL\t(1 << SL_PARTIAL)\n\nstatic ssize_t objects_partial_show(struct kmem_cache *s, char *buf)\n{\n\treturn show_slab_objects(s, buf, SO_PARTIAL|SO_OBJECTS);\n}"
  },
  {
    "function_name": "objects_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5023-5026",
    "snippet": "static ssize_t objects_show(struct kmem_cache *s, char *buf)\n{\n\treturn show_slab_objects(s, buf, SO_ALL|SO_OBJECTS);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define SO_OBJECTS\t(1 << SL_OBJECTS)",
      "#define SO_ALL\t\t(1 << SL_ALL)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_slab_objects",
          "args": [
            "s",
            "buf",
            "SO_ALL|SO_OBJECTS"
          ],
          "line": 5025
        },
        "resolved": true,
        "details": {
          "function_name": "show_slab_objects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "4779-4874",
          "snippet": "static ssize_t show_slab_objects(struct kmem_cache *s,\n\t\t\t    char *buf, unsigned long flags)\n{\n\tunsigned long total = 0;\n\tint node;\n\tint x;\n\tunsigned long *nodes;\n\n\tnodes = kcalloc(nr_node_ids, sizeof(unsigned long), GFP_KERNEL);\n\tif (!nodes)\n\t\treturn -ENOMEM;\n\n\tif (flags & SO_CPU) {\n\t\tint cpu;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct kmem_cache_cpu *c = per_cpu_ptr(s->cpu_slab,\n\t\t\t\t\t\t\t       cpu);\n\t\t\tint node;\n\t\t\tstruct page *page;\n\n\t\t\tpage = READ_ONCE(c->page);\n\t\t\tif (!page)\n\t\t\t\tcontinue;\n\n\t\t\tnode = page_to_nid(page);\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = page->objects;\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = page->inuse;\n\t\t\telse\n\t\t\t\tx = 1;\n\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\n\t\t\tpage = slub_percpu_partial_read_once(c);\n\t\t\tif (page) {\n\t\t\t\tnode = page_to_nid(page);\n\t\t\t\tif (flags & SO_TOTAL)\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\telse\n\t\t\t\t\tx = page->pages;\n\t\t\t\ttotal += x;\n\t\t\t\tnodes[node] += x;\n\t\t\t}\n\t\t}\n\t}\n\n\tget_online_mems();\n#ifdef CONFIG_SLUB_DEBUG\n\tif (flags & SO_ALL) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tfor_each_kmem_cache_node(s, node, n) {\n\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = atomic_long_read(&n->total_objects);\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = atomic_long_read(&n->total_objects) -\n\t\t\t\t\tcount_partial(n, count_free);\n\t\t\telse\n\t\t\t\tx = atomic_long_read(&n->nr_slabs);\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\t\t}\n\n\t} else\n#endif\n\tif (flags & SO_PARTIAL) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tfor_each_kmem_cache_node(s, node, n) {\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = count_partial(n, count_total);\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = count_partial(n, count_inuse);\n\t\t\telse\n\t\t\t\tx = n->nr_partial;\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\t\t}\n\t}\n\tx = sprintf(buf, \"%lu\", total);\n#ifdef CONFIG_NUMA\n\tfor (node = 0; node < nr_node_ids; node++)\n\t\tif (nodes[node])\n\t\t\tx += sprintf(buf + x, \" N%d=%lu\",\n\t\t\t\t\tnode, nodes[node]);\n#endif\n\tput_online_mems();\n\tkfree(nodes);\n\treturn x + sprintf(buf + x, \"\\n\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SO_TOTAL\t(1 << SL_TOTAL)",
            "#define SO_OBJECTS\t(1 << SL_OBJECTS)",
            "#define SO_CPU\t\t(1 << SL_CPU)",
            "#define SO_PARTIAL\t(1 << SL_PARTIAL)",
            "#define SO_ALL\t\t(1 << SL_ALL)"
          ],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define SO_TOTAL\t(1 << SL_TOTAL)\n#define SO_OBJECTS\t(1 << SL_OBJECTS)\n#define SO_CPU\t\t(1 << SL_CPU)\n#define SO_PARTIAL\t(1 << SL_PARTIAL)\n#define SO_ALL\t\t(1 << SL_ALL)\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic ssize_t show_slab_objects(struct kmem_cache *s,\n\t\t\t    char *buf, unsigned long flags)\n{\n\tunsigned long total = 0;\n\tint node;\n\tint x;\n\tunsigned long *nodes;\n\n\tnodes = kcalloc(nr_node_ids, sizeof(unsigned long), GFP_KERNEL);\n\tif (!nodes)\n\t\treturn -ENOMEM;\n\n\tif (flags & SO_CPU) {\n\t\tint cpu;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct kmem_cache_cpu *c = per_cpu_ptr(s->cpu_slab,\n\t\t\t\t\t\t\t       cpu);\n\t\t\tint node;\n\t\t\tstruct page *page;\n\n\t\t\tpage = READ_ONCE(c->page);\n\t\t\tif (!page)\n\t\t\t\tcontinue;\n\n\t\t\tnode = page_to_nid(page);\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = page->objects;\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = page->inuse;\n\t\t\telse\n\t\t\t\tx = 1;\n\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\n\t\t\tpage = slub_percpu_partial_read_once(c);\n\t\t\tif (page) {\n\t\t\t\tnode = page_to_nid(page);\n\t\t\t\tif (flags & SO_TOTAL)\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\telse\n\t\t\t\t\tx = page->pages;\n\t\t\t\ttotal += x;\n\t\t\t\tnodes[node] += x;\n\t\t\t}\n\t\t}\n\t}\n\n\tget_online_mems();\n#ifdef CONFIG_SLUB_DEBUG\n\tif (flags & SO_ALL) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tfor_each_kmem_cache_node(s, node, n) {\n\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = atomic_long_read(&n->total_objects);\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = atomic_long_read(&n->total_objects) -\n\t\t\t\t\tcount_partial(n, count_free);\n\t\t\telse\n\t\t\t\tx = atomic_long_read(&n->nr_slabs);\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\t\t}\n\n\t} else\n#endif\n\tif (flags & SO_PARTIAL) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tfor_each_kmem_cache_node(s, node, n) {\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = count_partial(n, count_total);\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = count_partial(n, count_inuse);\n\t\t\telse\n\t\t\t\tx = n->nr_partial;\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\t\t}\n\t}\n\tx = sprintf(buf, \"%lu\", total);\n#ifdef CONFIG_NUMA\n\tfor (node = 0; node < nr_node_ids; node++)\n\t\tif (nodes[node])\n\t\t\tx += sprintf(buf + x, \" N%d=%lu\",\n\t\t\t\t\tnode, nodes[node]);\n#endif\n\tput_online_mems();\n\tkfree(nodes);\n\treturn x + sprintf(buf + x, \"\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define SO_OBJECTS\t(1 << SL_OBJECTS)\n#define SO_ALL\t\t(1 << SL_ALL)\n\nstatic ssize_t objects_show(struct kmem_cache *s, char *buf)\n{\n\treturn show_slab_objects(s, buf, SO_ALL|SO_OBJECTS);\n}"
  },
  {
    "function_name": "cpu_slabs_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5017-5020",
    "snippet": "static ssize_t cpu_slabs_show(struct kmem_cache *s, char *buf)\n{\n\treturn show_slab_objects(s, buf, SO_CPU);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define SO_CPU\t\t(1 << SL_CPU)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_slab_objects",
          "args": [
            "s",
            "buf",
            "SO_CPU"
          ],
          "line": 5019
        },
        "resolved": true,
        "details": {
          "function_name": "show_slab_objects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "4779-4874",
          "snippet": "static ssize_t show_slab_objects(struct kmem_cache *s,\n\t\t\t    char *buf, unsigned long flags)\n{\n\tunsigned long total = 0;\n\tint node;\n\tint x;\n\tunsigned long *nodes;\n\n\tnodes = kcalloc(nr_node_ids, sizeof(unsigned long), GFP_KERNEL);\n\tif (!nodes)\n\t\treturn -ENOMEM;\n\n\tif (flags & SO_CPU) {\n\t\tint cpu;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct kmem_cache_cpu *c = per_cpu_ptr(s->cpu_slab,\n\t\t\t\t\t\t\t       cpu);\n\t\t\tint node;\n\t\t\tstruct page *page;\n\n\t\t\tpage = READ_ONCE(c->page);\n\t\t\tif (!page)\n\t\t\t\tcontinue;\n\n\t\t\tnode = page_to_nid(page);\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = page->objects;\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = page->inuse;\n\t\t\telse\n\t\t\t\tx = 1;\n\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\n\t\t\tpage = slub_percpu_partial_read_once(c);\n\t\t\tif (page) {\n\t\t\t\tnode = page_to_nid(page);\n\t\t\t\tif (flags & SO_TOTAL)\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\telse\n\t\t\t\t\tx = page->pages;\n\t\t\t\ttotal += x;\n\t\t\t\tnodes[node] += x;\n\t\t\t}\n\t\t}\n\t}\n\n\tget_online_mems();\n#ifdef CONFIG_SLUB_DEBUG\n\tif (flags & SO_ALL) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tfor_each_kmem_cache_node(s, node, n) {\n\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = atomic_long_read(&n->total_objects);\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = atomic_long_read(&n->total_objects) -\n\t\t\t\t\tcount_partial(n, count_free);\n\t\t\telse\n\t\t\t\tx = atomic_long_read(&n->nr_slabs);\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\t\t}\n\n\t} else\n#endif\n\tif (flags & SO_PARTIAL) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tfor_each_kmem_cache_node(s, node, n) {\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = count_partial(n, count_total);\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = count_partial(n, count_inuse);\n\t\t\telse\n\t\t\t\tx = n->nr_partial;\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\t\t}\n\t}\n\tx = sprintf(buf, \"%lu\", total);\n#ifdef CONFIG_NUMA\n\tfor (node = 0; node < nr_node_ids; node++)\n\t\tif (nodes[node])\n\t\t\tx += sprintf(buf + x, \" N%d=%lu\",\n\t\t\t\t\tnode, nodes[node]);\n#endif\n\tput_online_mems();\n\tkfree(nodes);\n\treturn x + sprintf(buf + x, \"\\n\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SO_TOTAL\t(1 << SL_TOTAL)",
            "#define SO_OBJECTS\t(1 << SL_OBJECTS)",
            "#define SO_CPU\t\t(1 << SL_CPU)",
            "#define SO_PARTIAL\t(1 << SL_PARTIAL)",
            "#define SO_ALL\t\t(1 << SL_ALL)"
          ],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define SO_TOTAL\t(1 << SL_TOTAL)\n#define SO_OBJECTS\t(1 << SL_OBJECTS)\n#define SO_CPU\t\t(1 << SL_CPU)\n#define SO_PARTIAL\t(1 << SL_PARTIAL)\n#define SO_ALL\t\t(1 << SL_ALL)\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic ssize_t show_slab_objects(struct kmem_cache *s,\n\t\t\t    char *buf, unsigned long flags)\n{\n\tunsigned long total = 0;\n\tint node;\n\tint x;\n\tunsigned long *nodes;\n\n\tnodes = kcalloc(nr_node_ids, sizeof(unsigned long), GFP_KERNEL);\n\tif (!nodes)\n\t\treturn -ENOMEM;\n\n\tif (flags & SO_CPU) {\n\t\tint cpu;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct kmem_cache_cpu *c = per_cpu_ptr(s->cpu_slab,\n\t\t\t\t\t\t\t       cpu);\n\t\t\tint node;\n\t\t\tstruct page *page;\n\n\t\t\tpage = READ_ONCE(c->page);\n\t\t\tif (!page)\n\t\t\t\tcontinue;\n\n\t\t\tnode = page_to_nid(page);\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = page->objects;\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = page->inuse;\n\t\t\telse\n\t\t\t\tx = 1;\n\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\n\t\t\tpage = slub_percpu_partial_read_once(c);\n\t\t\tif (page) {\n\t\t\t\tnode = page_to_nid(page);\n\t\t\t\tif (flags & SO_TOTAL)\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\telse\n\t\t\t\t\tx = page->pages;\n\t\t\t\ttotal += x;\n\t\t\t\tnodes[node] += x;\n\t\t\t}\n\t\t}\n\t}\n\n\tget_online_mems();\n#ifdef CONFIG_SLUB_DEBUG\n\tif (flags & SO_ALL) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tfor_each_kmem_cache_node(s, node, n) {\n\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = atomic_long_read(&n->total_objects);\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = atomic_long_read(&n->total_objects) -\n\t\t\t\t\tcount_partial(n, count_free);\n\t\t\telse\n\t\t\t\tx = atomic_long_read(&n->nr_slabs);\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\t\t}\n\n\t} else\n#endif\n\tif (flags & SO_PARTIAL) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tfor_each_kmem_cache_node(s, node, n) {\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = count_partial(n, count_total);\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = count_partial(n, count_inuse);\n\t\t\telse\n\t\t\t\tx = n->nr_partial;\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\t\t}\n\t}\n\tx = sprintf(buf, \"%lu\", total);\n#ifdef CONFIG_NUMA\n\tfor (node = 0; node < nr_node_ids; node++)\n\t\tif (nodes[node])\n\t\t\tx += sprintf(buf + x, \" N%d=%lu\",\n\t\t\t\t\tnode, nodes[node]);\n#endif\n\tput_online_mems();\n\tkfree(nodes);\n\treturn x + sprintf(buf + x, \"\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define SO_CPU\t\t(1 << SL_CPU)\n\nstatic ssize_t cpu_slabs_show(struct kmem_cache *s, char *buf)\n{\n\treturn show_slab_objects(s, buf, SO_CPU);\n}"
  },
  {
    "function_name": "partial_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5011-5014",
    "snippet": "static ssize_t partial_show(struct kmem_cache *s, char *buf)\n{\n\treturn show_slab_objects(s, buf, SO_PARTIAL);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define SO_PARTIAL\t(1 << SL_PARTIAL)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_slab_objects",
          "args": [
            "s",
            "buf",
            "SO_PARTIAL"
          ],
          "line": 5013
        },
        "resolved": true,
        "details": {
          "function_name": "show_slab_objects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "4779-4874",
          "snippet": "static ssize_t show_slab_objects(struct kmem_cache *s,\n\t\t\t    char *buf, unsigned long flags)\n{\n\tunsigned long total = 0;\n\tint node;\n\tint x;\n\tunsigned long *nodes;\n\n\tnodes = kcalloc(nr_node_ids, sizeof(unsigned long), GFP_KERNEL);\n\tif (!nodes)\n\t\treturn -ENOMEM;\n\n\tif (flags & SO_CPU) {\n\t\tint cpu;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct kmem_cache_cpu *c = per_cpu_ptr(s->cpu_slab,\n\t\t\t\t\t\t\t       cpu);\n\t\t\tint node;\n\t\t\tstruct page *page;\n\n\t\t\tpage = READ_ONCE(c->page);\n\t\t\tif (!page)\n\t\t\t\tcontinue;\n\n\t\t\tnode = page_to_nid(page);\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = page->objects;\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = page->inuse;\n\t\t\telse\n\t\t\t\tx = 1;\n\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\n\t\t\tpage = slub_percpu_partial_read_once(c);\n\t\t\tif (page) {\n\t\t\t\tnode = page_to_nid(page);\n\t\t\t\tif (flags & SO_TOTAL)\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\telse\n\t\t\t\t\tx = page->pages;\n\t\t\t\ttotal += x;\n\t\t\t\tnodes[node] += x;\n\t\t\t}\n\t\t}\n\t}\n\n\tget_online_mems();\n#ifdef CONFIG_SLUB_DEBUG\n\tif (flags & SO_ALL) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tfor_each_kmem_cache_node(s, node, n) {\n\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = atomic_long_read(&n->total_objects);\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = atomic_long_read(&n->total_objects) -\n\t\t\t\t\tcount_partial(n, count_free);\n\t\t\telse\n\t\t\t\tx = atomic_long_read(&n->nr_slabs);\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\t\t}\n\n\t} else\n#endif\n\tif (flags & SO_PARTIAL) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tfor_each_kmem_cache_node(s, node, n) {\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = count_partial(n, count_total);\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = count_partial(n, count_inuse);\n\t\t\telse\n\t\t\t\tx = n->nr_partial;\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\t\t}\n\t}\n\tx = sprintf(buf, \"%lu\", total);\n#ifdef CONFIG_NUMA\n\tfor (node = 0; node < nr_node_ids; node++)\n\t\tif (nodes[node])\n\t\t\tx += sprintf(buf + x, \" N%d=%lu\",\n\t\t\t\t\tnode, nodes[node]);\n#endif\n\tput_online_mems();\n\tkfree(nodes);\n\treturn x + sprintf(buf + x, \"\\n\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SO_TOTAL\t(1 << SL_TOTAL)",
            "#define SO_OBJECTS\t(1 << SL_OBJECTS)",
            "#define SO_CPU\t\t(1 << SL_CPU)",
            "#define SO_PARTIAL\t(1 << SL_PARTIAL)",
            "#define SO_ALL\t\t(1 << SL_ALL)"
          ],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define SO_TOTAL\t(1 << SL_TOTAL)\n#define SO_OBJECTS\t(1 << SL_OBJECTS)\n#define SO_CPU\t\t(1 << SL_CPU)\n#define SO_PARTIAL\t(1 << SL_PARTIAL)\n#define SO_ALL\t\t(1 << SL_ALL)\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic ssize_t show_slab_objects(struct kmem_cache *s,\n\t\t\t    char *buf, unsigned long flags)\n{\n\tunsigned long total = 0;\n\tint node;\n\tint x;\n\tunsigned long *nodes;\n\n\tnodes = kcalloc(nr_node_ids, sizeof(unsigned long), GFP_KERNEL);\n\tif (!nodes)\n\t\treturn -ENOMEM;\n\n\tif (flags & SO_CPU) {\n\t\tint cpu;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct kmem_cache_cpu *c = per_cpu_ptr(s->cpu_slab,\n\t\t\t\t\t\t\t       cpu);\n\t\t\tint node;\n\t\t\tstruct page *page;\n\n\t\t\tpage = READ_ONCE(c->page);\n\t\t\tif (!page)\n\t\t\t\tcontinue;\n\n\t\t\tnode = page_to_nid(page);\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = page->objects;\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = page->inuse;\n\t\t\telse\n\t\t\t\tx = 1;\n\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\n\t\t\tpage = slub_percpu_partial_read_once(c);\n\t\t\tif (page) {\n\t\t\t\tnode = page_to_nid(page);\n\t\t\t\tif (flags & SO_TOTAL)\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\telse\n\t\t\t\t\tx = page->pages;\n\t\t\t\ttotal += x;\n\t\t\t\tnodes[node] += x;\n\t\t\t}\n\t\t}\n\t}\n\n\tget_online_mems();\n#ifdef CONFIG_SLUB_DEBUG\n\tif (flags & SO_ALL) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tfor_each_kmem_cache_node(s, node, n) {\n\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = atomic_long_read(&n->total_objects);\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = atomic_long_read(&n->total_objects) -\n\t\t\t\t\tcount_partial(n, count_free);\n\t\t\telse\n\t\t\t\tx = atomic_long_read(&n->nr_slabs);\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\t\t}\n\n\t} else\n#endif\n\tif (flags & SO_PARTIAL) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tfor_each_kmem_cache_node(s, node, n) {\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = count_partial(n, count_total);\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = count_partial(n, count_inuse);\n\t\t\telse\n\t\t\t\tx = n->nr_partial;\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\t\t}\n\t}\n\tx = sprintf(buf, \"%lu\", total);\n#ifdef CONFIG_NUMA\n\tfor (node = 0; node < nr_node_ids; node++)\n\t\tif (nodes[node])\n\t\t\tx += sprintf(buf + x, \" N%d=%lu\",\n\t\t\t\t\tnode, nodes[node]);\n#endif\n\tput_online_mems();\n\tkfree(nodes);\n\treturn x + sprintf(buf + x, \"\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define SO_PARTIAL\t(1 << SL_PARTIAL)\n\nstatic ssize_t partial_show(struct kmem_cache *s, char *buf)\n{\n\treturn show_slab_objects(s, buf, SO_PARTIAL);\n}"
  },
  {
    "function_name": "aliases_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "5005-5008",
    "snippet": "static ssize_t aliases_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", s->refcount < 0 ? 0 : s->refcount - 1);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "s->refcount < 0 ? 0 : s->refcount - 1"
          ],
          "line": 5007
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic ssize_t aliases_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", s->refcount < 0 ? 0 : s->refcount - 1);\n}"
  },
  {
    "function_name": "ctor_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "4997-5002",
    "snippet": "static ssize_t ctor_show(struct kmem_cache *s, char *buf)\n{\n\tif (!s->ctor)\n\t\treturn 0;\n\treturn sprintf(buf, \"%pS\\n\", s->ctor);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%pS\\n\"",
            "s->ctor"
          ],
          "line": 5001
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic ssize_t ctor_show(struct kmem_cache *s, char *buf)\n{\n\tif (!s->ctor)\n\t\treturn 0;\n\treturn sprintf(buf, \"%pS\\n\", s->ctor);\n}"
  },
  {
    "function_name": "cpu_partial_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "4979-4994",
    "snippet": "static ssize_t cpu_partial_store(struct kmem_cache *s, const char *buf,\n\t\t\t\t size_t length)\n{\n\tunsigned int objects;\n\tint err;\n\n\terr = kstrtouint(buf, 10, &objects);\n\tif (err)\n\t\treturn err;\n\tif (objects && !kmem_cache_has_cpu_partial(s))\n\t\treturn -EINVAL;\n\n\tslub_set_cpu_partial(s, objects);\n\tflush_all(s);\n\treturn length;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_all",
          "args": [
            "s"
          ],
          "line": 4992
        },
        "resolved": true,
        "details": {
          "function_name": "flush_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2339-2342",
          "snippet": "static void flush_all(struct kmem_cache *s)\n{\n\ton_each_cpu_cond(has_cpu_slab, flush_cpu_slab, s, 1, GFP_ATOMIC);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void flush_all(struct kmem_cache *s)\n{\n\ton_each_cpu_cond(has_cpu_slab, flush_cpu_slab, s, 1, GFP_ATOMIC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "slub_set_cpu_partial",
          "args": [
            "s",
            "objects"
          ],
          "line": 4991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_has_cpu_partial",
          "args": [
            "s"
          ],
          "line": 4988
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_has_cpu_partial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "135-142",
          "snippet": "static inline bool kmem_cache_has_cpu_partial(struct kmem_cache *s)\n{\n#ifdef CONFIG_SLUB_CPU_PARTIAL\n\treturn !kmem_cache_debug(s);\n#else\n\treturn false;\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline bool kmem_cache_has_cpu_partial(struct kmem_cache *s)\n{\n#ifdef CONFIG_SLUB_CPU_PARTIAL\n\treturn !kmem_cache_debug(s);\n#else\n\treturn false;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtouint",
          "args": [
            "buf",
            "10",
            "&objects"
          ],
          "line": 4985
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic ssize_t cpu_partial_store(struct kmem_cache *s, const char *buf,\n\t\t\t\t size_t length)\n{\n\tunsigned int objects;\n\tint err;\n\n\terr = kstrtouint(buf, 10, &objects);\n\tif (err)\n\t\treturn err;\n\tif (objects && !kmem_cache_has_cpu_partial(s))\n\t\treturn -EINVAL;\n\n\tslub_set_cpu_partial(s, objects);\n\tflush_all(s);\n\treturn length;\n}"
  },
  {
    "function_name": "cpu_partial_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "4974-4977",
    "snippet": "static ssize_t cpu_partial_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", slub_cpu_partial(s));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%u\\n\"",
            "slub_cpu_partial(s)"
          ],
          "line": 4976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slub_cpu_partial",
          "args": [
            "s"
          ],
          "line": 4976
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic ssize_t cpu_partial_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", slub_cpu_partial(s));\n}"
  },
  {
    "function_name": "min_partial_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "4959-4971",
    "snippet": "static ssize_t min_partial_store(struct kmem_cache *s, const char *buf,\n\t\t\t\t size_t length)\n{\n\tunsigned long min;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &min);\n\tif (err)\n\t\treturn err;\n\n\tset_min_partial(s, min);\n\treturn length;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_min_partial",
          "args": [
            "s",
            "min"
          ],
          "line": 4969
        },
        "resolved": true,
        "details": {
          "function_name": "set_min_partial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "3430-3437",
          "snippet": "static void set_min_partial(struct kmem_cache *s, unsigned long min)\n{\n\tif (min < MIN_PARTIAL)\n\t\tmin = MIN_PARTIAL;\n\telse if (min > MAX_PARTIAL)\n\t\tmin = MAX_PARTIAL;\n\ts->min_partial = min;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define MAX_PARTIAL 10",
            "#define MIN_PARTIAL 5"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define MAX_PARTIAL 10\n#define MIN_PARTIAL 5\n\nstatic void set_min_partial(struct kmem_cache *s, unsigned long min)\n{\n\tif (min < MIN_PARTIAL)\n\t\tmin = MIN_PARTIAL;\n\telse if (min > MAX_PARTIAL)\n\t\tmin = MAX_PARTIAL;\n\ts->min_partial = min;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "buf",
            "10",
            "&min"
          ],
          "line": 4965
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic ssize_t min_partial_store(struct kmem_cache *s, const char *buf,\n\t\t\t\t size_t length)\n{\n\tunsigned long min;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &min);\n\tif (err)\n\t\treturn err;\n\n\tset_min_partial(s, min);\n\treturn length;\n}"
  },
  {
    "function_name": "min_partial_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "4954-4957",
    "snippet": "static ssize_t min_partial_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", s->min_partial);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%lu\\n\"",
            "s->min_partial"
          ],
          "line": 4956
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic ssize_t min_partial_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", s->min_partial);\n}"
  },
  {
    "function_name": "order_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "4948-4951",
    "snippet": "static ssize_t order_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", oo_order(s->oo));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%u\\n\"",
            "oo_order(s->oo)"
          ],
          "line": 4950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oo_order",
          "args": [
            "s->oo"
          ],
          "line": 4950
        },
        "resolved": true,
        "details": {
          "function_name": "oo_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "332-335",
          "snippet": "static inline unsigned int oo_order(struct kmem_cache_order_objects x)\n{\n\treturn x.x >> OO_SHIFT;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define OO_SHIFT\t16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define OO_SHIFT\t16\n\nstatic inline unsigned int oo_order(struct kmem_cache_order_objects x)\n{\n\treturn x.x >> OO_SHIFT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic ssize_t order_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", oo_order(s->oo));\n}"
  },
  {
    "function_name": "order_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "4931-4946",
    "snippet": "static ssize_t order_store(struct kmem_cache *s,\n\t\t\t\tconst char *buf, size_t length)\n{\n\tunsigned int order;\n\tint err;\n\n\terr = kstrtouint(buf, 10, &order);\n\tif (err)\n\t\treturn err;\n\n\tif (order > slub_max_order || order < slub_min_order)\n\t\treturn -EINVAL;\n\n\tcalculate_sizes(s, order);\n\treturn length;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int slub_min_order;",
      "static unsigned int slub_max_order = PAGE_ALLOC_COSTLY_ORDER;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "calculate_sizes",
          "args": [
            "s",
            "order"
          ],
          "line": 4944
        },
        "resolved": true,
        "details": {
          "function_name": "calculate_sizes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "3476-3592",
          "snippet": "static int calculate_sizes(struct kmem_cache *s, int forced_order)\n{\n\tslab_flags_t flags = s->flags;\n\tunsigned int size = s->object_size;\n\tunsigned int order;\n\n\t/*\n\t * Round up object size to the next word boundary. We can only\n\t * place the free pointer at word boundaries and this determines\n\t * the possible location of the free pointer.\n\t */\n\tsize = ALIGN(size, sizeof(void *));\n\n#ifdef CONFIG_SLUB_DEBUG\n\t/*\n\t * Determine if we can poison the object itself. If the user of\n\t * the slab may touch the object after free or before allocation\n\t * then we should never poison the object itself.\n\t */\n\tif ((flags & SLAB_POISON) && !(flags & SLAB_TYPESAFE_BY_RCU) &&\n\t\t\t!s->ctor)\n\t\ts->flags |= __OBJECT_POISON;\n\telse\n\t\ts->flags &= ~__OBJECT_POISON;\n\n\n\t/*\n\t * If we are Redzoning then check if there is some space between the\n\t * end of the object and the free pointer. If not then add an\n\t * additional word to have some bytes to store Redzone information.\n\t */\n\tif ((flags & SLAB_RED_ZONE) && size == s->object_size)\n\t\tsize += sizeof(void *);\n#endif\n\n\t/*\n\t * With that we have determined the number of bytes in actual use\n\t * by the object. This is the potential offset to the free pointer.\n\t */\n\ts->inuse = size;\n\n\tif (((flags & (SLAB_TYPESAFE_BY_RCU | SLAB_POISON)) ||\n\t\ts->ctor)) {\n\t\t/*\n\t\t * Relocate free pointer after the object if it is not\n\t\t * permitted to overwrite the first word of the object on\n\t\t * kmem_cache_free.\n\t\t *\n\t\t * This is the case if we do RCU, have a constructor or\n\t\t * destructor or are poisoning the objects.\n\t\t */\n\t\ts->offset = size;\n\t\tsize += sizeof(void *);\n\t}\n\n#ifdef CONFIG_SLUB_DEBUG\n\tif (flags & SLAB_STORE_USER)\n\t\t/*\n\t\t * Need to store information about allocs and frees after\n\t\t * the object.\n\t\t */\n\t\tsize += 2 * sizeof(struct track);\n#endif\n\n\tkasan_cache_create(s, &size, &s->flags);\n#ifdef CONFIG_SLUB_DEBUG\n\tif (flags & SLAB_RED_ZONE) {\n\t\t/*\n\t\t * Add some empty padding so that we can catch\n\t\t * overwrites from earlier objects rather than let\n\t\t * tracking information or the free pointer be\n\t\t * corrupted if a user writes before the start\n\t\t * of the object.\n\t\t */\n\t\tsize += sizeof(void *);\n\n\t\ts->red_left_pad = sizeof(void *);\n\t\ts->red_left_pad = ALIGN(s->red_left_pad, s->align);\n\t\tsize += s->red_left_pad;\n\t}\n#endif\n\n\t/*\n\t * SLUB stores one object immediately after another beginning from\n\t * offset 0. In order to align the objects we have to simply size\n\t * each object to conform to the alignment.\n\t */\n\tsize = ALIGN(size, s->align);\n\ts->size = size;\n\tif (forced_order >= 0)\n\t\torder = forced_order;\n\telse\n\t\torder = calculate_order(size);\n\n\tif ((int)order < 0)\n\t\treturn 0;\n\n\ts->allocflags = 0;\n\tif (order)\n\t\ts->allocflags |= __GFP_COMP;\n\n\tif (s->flags & SLAB_CACHE_DMA)\n\t\ts->allocflags |= GFP_DMA;\n\n\tif (s->flags & SLAB_RECLAIM_ACCOUNT)\n\t\ts->allocflags |= __GFP_RECLAIMABLE;\n\n\t/*\n\t * Determine the number of objects per slab\n\t */\n\ts->oo = oo_make(order, size);\n\ts->min = oo_make(get_order(size), size);\n\tif (oo_objects(s->oo) > oo_objects(s->max))\n\t\ts->max = s->oo;\n\n\treturn !!oo_objects(s->oo);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define __OBJECT_POISON\t\t((slab_flags_t __force)0x80000000U)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define __OBJECT_POISON\t\t((slab_flags_t __force)0x80000000U)\n\nstatic int calculate_sizes(struct kmem_cache *s, int forced_order)\n{\n\tslab_flags_t flags = s->flags;\n\tunsigned int size = s->object_size;\n\tunsigned int order;\n\n\t/*\n\t * Round up object size to the next word boundary. We can only\n\t * place the free pointer at word boundaries and this determines\n\t * the possible location of the free pointer.\n\t */\n\tsize = ALIGN(size, sizeof(void *));\n\n#ifdef CONFIG_SLUB_DEBUG\n\t/*\n\t * Determine if we can poison the object itself. If the user of\n\t * the slab may touch the object after free or before allocation\n\t * then we should never poison the object itself.\n\t */\n\tif ((flags & SLAB_POISON) && !(flags & SLAB_TYPESAFE_BY_RCU) &&\n\t\t\t!s->ctor)\n\t\ts->flags |= __OBJECT_POISON;\n\telse\n\t\ts->flags &= ~__OBJECT_POISON;\n\n\n\t/*\n\t * If we are Redzoning then check if there is some space between the\n\t * end of the object and the free pointer. If not then add an\n\t * additional word to have some bytes to store Redzone information.\n\t */\n\tif ((flags & SLAB_RED_ZONE) && size == s->object_size)\n\t\tsize += sizeof(void *);\n#endif\n\n\t/*\n\t * With that we have determined the number of bytes in actual use\n\t * by the object. This is the potential offset to the free pointer.\n\t */\n\ts->inuse = size;\n\n\tif (((flags & (SLAB_TYPESAFE_BY_RCU | SLAB_POISON)) ||\n\t\ts->ctor)) {\n\t\t/*\n\t\t * Relocate free pointer after the object if it is not\n\t\t * permitted to overwrite the first word of the object on\n\t\t * kmem_cache_free.\n\t\t *\n\t\t * This is the case if we do RCU, have a constructor or\n\t\t * destructor or are poisoning the objects.\n\t\t */\n\t\ts->offset = size;\n\t\tsize += sizeof(void *);\n\t}\n\n#ifdef CONFIG_SLUB_DEBUG\n\tif (flags & SLAB_STORE_USER)\n\t\t/*\n\t\t * Need to store information about allocs and frees after\n\t\t * the object.\n\t\t */\n\t\tsize += 2 * sizeof(struct track);\n#endif\n\n\tkasan_cache_create(s, &size, &s->flags);\n#ifdef CONFIG_SLUB_DEBUG\n\tif (flags & SLAB_RED_ZONE) {\n\t\t/*\n\t\t * Add some empty padding so that we can catch\n\t\t * overwrites from earlier objects rather than let\n\t\t * tracking information or the free pointer be\n\t\t * corrupted if a user writes before the start\n\t\t * of the object.\n\t\t */\n\t\tsize += sizeof(void *);\n\n\t\ts->red_left_pad = sizeof(void *);\n\t\ts->red_left_pad = ALIGN(s->red_left_pad, s->align);\n\t\tsize += s->red_left_pad;\n\t}\n#endif\n\n\t/*\n\t * SLUB stores one object immediately after another beginning from\n\t * offset 0. In order to align the objects we have to simply size\n\t * each object to conform to the alignment.\n\t */\n\tsize = ALIGN(size, s->align);\n\ts->size = size;\n\tif (forced_order >= 0)\n\t\torder = forced_order;\n\telse\n\t\torder = calculate_order(size);\n\n\tif ((int)order < 0)\n\t\treturn 0;\n\n\ts->allocflags = 0;\n\tif (order)\n\t\ts->allocflags |= __GFP_COMP;\n\n\tif (s->flags & SLAB_CACHE_DMA)\n\t\ts->allocflags |= GFP_DMA;\n\n\tif (s->flags & SLAB_RECLAIM_ACCOUNT)\n\t\ts->allocflags |= __GFP_RECLAIMABLE;\n\n\t/*\n\t * Determine the number of objects per slab\n\t */\n\ts->oo = oo_make(order, size);\n\ts->min = oo_make(get_order(size), size);\n\tif (oo_objects(s->oo) > oo_objects(s->max))\n\t\ts->max = s->oo;\n\n\treturn !!oo_objects(s->oo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtouint",
          "args": [
            "buf",
            "10",
            "&order"
          ],
          "line": 4937
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic unsigned int slub_min_order;\nstatic unsigned int slub_max_order = PAGE_ALLOC_COSTLY_ORDER;\n\nstatic ssize_t order_store(struct kmem_cache *s,\n\t\t\t\tconst char *buf, size_t length)\n{\n\tunsigned int order;\n\tint err;\n\n\terr = kstrtouint(buf, 10, &order);\n\tif (err)\n\t\treturn err;\n\n\tif (order > slub_max_order || order < slub_min_order)\n\t\treturn -EINVAL;\n\n\tcalculate_sizes(s, order);\n\treturn length;\n}"
  },
  {
    "function_name": "objs_per_slab_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "4925-4928",
    "snippet": "static ssize_t objs_per_slab_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", oo_objects(s->oo));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%u\\n\"",
            "oo_objects(s->oo)"
          ],
          "line": 4927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oo_objects",
          "args": [
            "s->oo"
          ],
          "line": 4927
        },
        "resolved": true,
        "details": {
          "function_name": "oo_objects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "337-340",
          "snippet": "static inline unsigned int oo_objects(struct kmem_cache_order_objects x)\n{\n\treturn x.x & OO_MASK;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define OO_MASK\t\t((1 << OO_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define OO_MASK\t\t((1 << OO_SHIFT) - 1)\n\nstatic inline unsigned int oo_objects(struct kmem_cache_order_objects x)\n{\n\treturn x.x & OO_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic ssize_t objs_per_slab_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", oo_objects(s->oo));\n}"
  },
  {
    "function_name": "object_size_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "4919-4922",
    "snippet": "static ssize_t object_size_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", s->object_size);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%u\\n\"",
            "s->object_size"
          ],
          "line": 4921
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic ssize_t object_size_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", s->object_size);\n}"
  },
  {
    "function_name": "align_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "4913-4916",
    "snippet": "static ssize_t align_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", s->align);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%u\\n\"",
            "s->align"
          ],
          "line": 4915
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic ssize_t align_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", s->align);\n}"
  },
  {
    "function_name": "slab_size_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "4907-4910",
    "snippet": "static ssize_t slab_size_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", s->size);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%u\\n\"",
            "s->size"
          ],
          "line": 4909
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic ssize_t slab_size_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", s->size);\n}"
  },
  {
    "function_name": "any_slab_objects",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "4877-4887",
    "snippet": "static int any_slab_objects(struct kmem_cache *s)\n{\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tfor_each_kmem_cache_node(s, node, n)\n\t\tif (atomic_long_read(&n->total_objects))\n\t\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *kmem_cache_node;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&n->total_objects"
          ],
          "line": 4883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_kmem_cache_node",
          "args": [
            "s",
            "node",
            "n"
          ],
          "line": 4882
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic int any_slab_objects(struct kmem_cache *s)\n{\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tfor_each_kmem_cache_node(s, node, n)\n\t\tif (atomic_long_read(&n->total_objects))\n\t\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "show_slab_objects",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "4779-4874",
    "snippet": "static ssize_t show_slab_objects(struct kmem_cache *s,\n\t\t\t    char *buf, unsigned long flags)\n{\n\tunsigned long total = 0;\n\tint node;\n\tint x;\n\tunsigned long *nodes;\n\n\tnodes = kcalloc(nr_node_ids, sizeof(unsigned long), GFP_KERNEL);\n\tif (!nodes)\n\t\treturn -ENOMEM;\n\n\tif (flags & SO_CPU) {\n\t\tint cpu;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct kmem_cache_cpu *c = per_cpu_ptr(s->cpu_slab,\n\t\t\t\t\t\t\t       cpu);\n\t\t\tint node;\n\t\t\tstruct page *page;\n\n\t\t\tpage = READ_ONCE(c->page);\n\t\t\tif (!page)\n\t\t\t\tcontinue;\n\n\t\t\tnode = page_to_nid(page);\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = page->objects;\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = page->inuse;\n\t\t\telse\n\t\t\t\tx = 1;\n\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\n\t\t\tpage = slub_percpu_partial_read_once(c);\n\t\t\tif (page) {\n\t\t\t\tnode = page_to_nid(page);\n\t\t\t\tif (flags & SO_TOTAL)\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\telse\n\t\t\t\t\tx = page->pages;\n\t\t\t\ttotal += x;\n\t\t\t\tnodes[node] += x;\n\t\t\t}\n\t\t}\n\t}\n\n\tget_online_mems();\n#ifdef CONFIG_SLUB_DEBUG\n\tif (flags & SO_ALL) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tfor_each_kmem_cache_node(s, node, n) {\n\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = atomic_long_read(&n->total_objects);\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = atomic_long_read(&n->total_objects) -\n\t\t\t\t\tcount_partial(n, count_free);\n\t\t\telse\n\t\t\t\tx = atomic_long_read(&n->nr_slabs);\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\t\t}\n\n\t} else\n#endif\n\tif (flags & SO_PARTIAL) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tfor_each_kmem_cache_node(s, node, n) {\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = count_partial(n, count_total);\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = count_partial(n, count_inuse);\n\t\t\telse\n\t\t\t\tx = n->nr_partial;\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\t\t}\n\t}\n\tx = sprintf(buf, \"%lu\", total);\n#ifdef CONFIG_NUMA\n\tfor (node = 0; node < nr_node_ids; node++)\n\t\tif (nodes[node])\n\t\t\tx += sprintf(buf + x, \" N%d=%lu\",\n\t\t\t\t\tnode, nodes[node]);\n#endif\n\tput_online_mems();\n\tkfree(nodes);\n\treturn x + sprintf(buf + x, \"\\n\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define SO_TOTAL\t(1 << SL_TOTAL)",
      "#define SO_OBJECTS\t(1 << SL_OBJECTS)",
      "#define SO_CPU\t\t(1 << SL_CPU)",
      "#define SO_PARTIAL\t(1 << SL_PARTIAL)",
      "#define SO_ALL\t\t(1 << SL_ALL)"
    ],
    "globals_used": [
      "static struct kmem_cache *kmem_cache_node;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf + x",
            "\"\\n\""
          ],
          "line": 4873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nodes"
          ],
          "line": 4872
        },
        "resolved": true,
        "details": {
          "function_name": "kfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "3925-3943",
          "snippet": "void kfree(const void *x)\n{\n\tstruct page *page;\n\tvoid *object = (void *)x;\n\n\ttrace_kfree(_RET_IP_, x);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(x)))\n\t\treturn;\n\n\tpage = virt_to_head_page(x);\n\tif (unlikely(!PageSlab(page))) {\n\t\tBUG_ON(!PageCompound(page));\n\t\tkfree_hook(object);\n\t\t__free_pages(page, compound_order(page));\n\t\treturn;\n\t}\n\tslab_free(page->slab_cache, page, object, NULL, 1, _RET_IP_);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid kfree(const void *x)\n{\n\tstruct page *page;\n\tvoid *object = (void *)x;\n\n\ttrace_kfree(_RET_IP_, x);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(x)))\n\t\treturn;\n\n\tpage = virt_to_head_page(x);\n\tif (unlikely(!PageSlab(page))) {\n\t\tBUG_ON(!PageCompound(page));\n\t\tkfree_hook(object);\n\t\t__free_pages(page, compound_order(page));\n\t\treturn;\n\t}\n\tslab_free(page->slab_cache, page, object, NULL, 1, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_online_mems",
          "args": [],
          "line": 4871
        },
        "resolved": true,
        "details": {
          "function_name": "put_online_mems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "61-64",
          "snippet": "void put_online_mems(void)\n{\n\tpercpu_up_read(&mem_hotplug_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid put_online_mems(void)\n{\n\tpercpu_up_read(&mem_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf + x",
            "\" N%d=%lu\"",
            "node",
            "nodes[node]"
          ],
          "line": 4868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%lu\"",
            "total"
          ],
          "line": 4864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_partial",
          "args": [
            "n",
            "count_inuse"
          ],
          "line": 4857
        },
        "resolved": true,
        "details": {
          "function_name": "count_partial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2389-2401",
          "snippet": "static unsigned long count_partial(struct kmem_cache_node *n,\n\t\t\t\t\tint (*get_count)(struct page *))\n{\n\tunsigned long flags;\n\tunsigned long x = 0;\n\tstruct page *page;\n\n\tspin_lock_irqsave(&n->list_lock, flags);\n\tlist_for_each_entry(page, &n->partial, lru)\n\t\tx += get_count(page);\n\tspin_unlock_irqrestore(&n->list_lock, flags);\n\treturn x;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic unsigned long count_partial(struct kmem_cache_node *n,\n\t\t\t\t\tint (*get_count)(struct page *))\n{\n\tunsigned long flags;\n\tunsigned long x = 0;\n\tstruct page *page;\n\n\tspin_lock_irqsave(&n->list_lock, flags);\n\tlist_for_each_entry(page, &n->partial, lru)\n\t\tx += get_count(page);\n\tspin_unlock_irqrestore(&n->list_lock, flags);\n\treturn x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_kmem_cache_node",
          "args": [
            "s",
            "node",
            "n"
          ],
          "line": 4853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&n->nr_slabs"
          ],
          "line": 4843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&n->total_objects"
          ],
          "line": 4840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&n->total_objects"
          ],
          "line": 4838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_kmem_cache_node",
          "args": [
            "s",
            "node",
            "n"
          ],
          "line": 4835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_online_mems",
          "args": [],
          "line": 4830
        },
        "resolved": true,
        "details": {
          "function_name": "get_online_mems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "56-59",
          "snippet": "void get_online_mems(void)\n{\n\tpercpu_down_read(&mem_hotplug_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid get_online_mems(void)\n{\n\tpercpu_down_read(&mem_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 4821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 4819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 4817
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "slub_percpu_partial_read_once",
          "args": [
            "c"
          ],
          "line": 4815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "c->page"
          ],
          "line": 4800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "s->cpu_slab",
            "cpu"
          ],
          "line": 4795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "nr_node_ids",
            "sizeof(unsigned long)",
            "GFP_KERNEL"
          ],
          "line": 4787
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define SO_TOTAL\t(1 << SL_TOTAL)\n#define SO_OBJECTS\t(1 << SL_OBJECTS)\n#define SO_CPU\t\t(1 << SL_CPU)\n#define SO_PARTIAL\t(1 << SL_PARTIAL)\n#define SO_ALL\t\t(1 << SL_ALL)\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic ssize_t show_slab_objects(struct kmem_cache *s,\n\t\t\t    char *buf, unsigned long flags)\n{\n\tunsigned long total = 0;\n\tint node;\n\tint x;\n\tunsigned long *nodes;\n\n\tnodes = kcalloc(nr_node_ids, sizeof(unsigned long), GFP_KERNEL);\n\tif (!nodes)\n\t\treturn -ENOMEM;\n\n\tif (flags & SO_CPU) {\n\t\tint cpu;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct kmem_cache_cpu *c = per_cpu_ptr(s->cpu_slab,\n\t\t\t\t\t\t\t       cpu);\n\t\t\tint node;\n\t\t\tstruct page *page;\n\n\t\t\tpage = READ_ONCE(c->page);\n\t\t\tif (!page)\n\t\t\t\tcontinue;\n\n\t\t\tnode = page_to_nid(page);\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = page->objects;\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = page->inuse;\n\t\t\telse\n\t\t\t\tx = 1;\n\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\n\t\t\tpage = slub_percpu_partial_read_once(c);\n\t\t\tif (page) {\n\t\t\t\tnode = page_to_nid(page);\n\t\t\t\tif (flags & SO_TOTAL)\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\telse\n\t\t\t\t\tx = page->pages;\n\t\t\t\ttotal += x;\n\t\t\t\tnodes[node] += x;\n\t\t\t}\n\t\t}\n\t}\n\n\tget_online_mems();\n#ifdef CONFIG_SLUB_DEBUG\n\tif (flags & SO_ALL) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tfor_each_kmem_cache_node(s, node, n) {\n\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = atomic_long_read(&n->total_objects);\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = atomic_long_read(&n->total_objects) -\n\t\t\t\t\tcount_partial(n, count_free);\n\t\t\telse\n\t\t\t\tx = atomic_long_read(&n->nr_slabs);\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\t\t}\n\n\t} else\n#endif\n\tif (flags & SO_PARTIAL) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tfor_each_kmem_cache_node(s, node, n) {\n\t\t\tif (flags & SO_TOTAL)\n\t\t\t\tx = count_partial(n, count_total);\n\t\t\telse if (flags & SO_OBJECTS)\n\t\t\t\tx = count_partial(n, count_inuse);\n\t\t\telse\n\t\t\t\tx = n->nr_partial;\n\t\t\ttotal += x;\n\t\t\tnodes[node] += x;\n\t\t}\n\t}\n\tx = sprintf(buf, \"%lu\", total);\n#ifdef CONFIG_NUMA\n\tfor (node = 0; node < nr_node_ids; node++)\n\t\tif (nodes[node])\n\t\t\tx += sprintf(buf + x, \" N%d=%lu\",\n\t\t\t\t\tnode, nodes[node]);\n#endif\n\tput_online_mems();\n\tkfree(nodes);\n\treturn x + sprintf(buf + x, \"\\n\");\n}"
  },
  {
    "function_name": "setup_slub_memcg_sysfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "4766-4774",
    "snippet": "static int __init setup_slub_memcg_sysfs(char *str)\n{\n\tint v;\n\n\tif (get_option(&str, &v) > 0)\n\t\tmemcg_sysfs_enabled = v;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_option",
          "args": [
            "&str",
            "&v"
          ],
          "line": 4770
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic int __init setup_slub_memcg_sysfs(char *str)\n{\n\tint v;\n\n\tif (get_option(&str, &v) > 0)\n\t\tmemcg_sysfs_enabled = v;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "resiliency_test",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "4744-4744",
    "snippet": "static void resiliency_test(void) {}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void resiliency_test(void) {}"
  },
  {
    "function_name": "resiliency_test",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "4689-4741",
    "snippet": "static void __init resiliency_test(void)\n{\n\tu8 *p;\n\tint type = KMALLOC_NORMAL;\n\n\tBUILD_BUG_ON(KMALLOC_MIN_SIZE > 16 || KMALLOC_SHIFT_HIGH < 10);\n\n\tpr_err(\"SLUB resiliency testing\\n\");\n\tpr_err(\"-----------------------\\n\");\n\tpr_err(\"A. Corruption after allocation\\n\");\n\n\tp = kzalloc(16, GFP_KERNEL);\n\tp[16] = 0x12;\n\tpr_err(\"\\n1. kmalloc-16: Clobber Redzone/next pointer 0x12->0x%p\\n\\n\",\n\t       p + 16);\n\n\tvalidate_slab_cache(kmalloc_caches[type][4]);\n\n\t/* Hmmm... The next two are dangerous */\n\tp = kzalloc(32, GFP_KERNEL);\n\tp[32 + sizeof(void *)] = 0x34;\n\tpr_err(\"\\n2. kmalloc-32: Clobber next pointer/next slab 0x34 -> -0x%p\\n\",\n\t       p);\n\tpr_err(\"If allocated object is overwritten then not detectable\\n\\n\");\n\n\tvalidate_slab_cache(kmalloc_caches[type][5]);\n\tp = kzalloc(64, GFP_KERNEL);\n\tp += 64 + (get_cycles() & 0xff) * sizeof(void *);\n\t*p = 0x56;\n\tpr_err(\"\\n3. kmalloc-64: corrupting random byte 0x56->0x%p\\n\",\n\t       p);\n\tpr_err(\"If allocated object is overwritten then not detectable\\n\\n\");\n\tvalidate_slab_cache(kmalloc_caches[type][6]);\n\n\tpr_err(\"\\nB. Corruption after free\\n\");\n\tp = kzalloc(128, GFP_KERNEL);\n\tkfree(p);\n\t*p = 0x78;\n\tpr_err(\"1. kmalloc-128: Clobber first word 0x78->0x%p\\n\\n\", p);\n\tvalidate_slab_cache(kmalloc_caches[type][7]);\n\n\tp = kzalloc(256, GFP_KERNEL);\n\tkfree(p);\n\tp[50] = 0x9a;\n\tpr_err(\"\\n2. kmalloc-256: Clobber 50th byte 0x9a->0x%p\\n\\n\", p);\n\tvalidate_slab_cache(kmalloc_caches[type][8]);\n\n\tp = kzalloc(512, GFP_KERNEL);\n\tkfree(p);\n\tp[512] = 0xab;\n\tpr_err(\"\\n3. kmalloc-512: Clobber redzone 0xab->0x%p\\n\\n\", p);\n\tvalidate_slab_cache(kmalloc_caches[type][9]);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "validate_slab_cache",
          "args": [
            "kmalloc_caches[type][9]"
          ],
          "line": 4740
        },
        "resolved": true,
        "details": {
          "function_name": "validate_slab_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "4446-4461",
          "snippet": "static long validate_slab_cache(struct kmem_cache *s)\n{\n\tint node;\n\tunsigned long count = 0;\n\tstruct kmem_cache_node *n;\n\tunsigned long *map = bitmap_alloc(oo_objects(s->max), GFP_KERNEL);\n\n\tif (!map)\n\t\treturn -ENOMEM;\n\n\tflush_all(s);\n\tfor_each_kmem_cache_node(s, node, n)\n\t\tcount += validate_slab_node(s, n, map);\n\tbitmap_free(map);\n\treturn count;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic long validate_slab_cache(struct kmem_cache *s)\n{\n\tint node;\n\tunsigned long count = 0;\n\tstruct kmem_cache_node *n;\n\tunsigned long *map = bitmap_alloc(oo_objects(s->max), GFP_KERNEL);\n\n\tif (!map)\n\t\treturn -ENOMEM;\n\n\tflush_all(s);\n\tfor_each_kmem_cache_node(s, node, n)\n\t\tcount += validate_slab_node(s, n, map);\n\tbitmap_free(map);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"\\n3. kmalloc-512: Clobber redzone 0xab->0x%p\\n\\n\"",
            "p"
          ],
          "line": 4739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "p"
          ],
          "line": 4737
        },
        "resolved": true,
        "details": {
          "function_name": "kfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "3925-3943",
          "snippet": "void kfree(const void *x)\n{\n\tstruct page *page;\n\tvoid *object = (void *)x;\n\n\ttrace_kfree(_RET_IP_, x);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(x)))\n\t\treturn;\n\n\tpage = virt_to_head_page(x);\n\tif (unlikely(!PageSlab(page))) {\n\t\tBUG_ON(!PageCompound(page));\n\t\tkfree_hook(object);\n\t\t__free_pages(page, compound_order(page));\n\t\treturn;\n\t}\n\tslab_free(page->slab_cache, page, object, NULL, 1, _RET_IP_);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid kfree(const void *x)\n{\n\tstruct page *page;\n\tvoid *object = (void *)x;\n\n\ttrace_kfree(_RET_IP_, x);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(x)))\n\t\treturn;\n\n\tpage = virt_to_head_page(x);\n\tif (unlikely(!PageSlab(page))) {\n\t\tBUG_ON(!PageCompound(page));\n\t\tkfree_hook(object);\n\t\t__free_pages(page, compound_order(page));\n\t\treturn;\n\t}\n\tslab_free(page->slab_cache, page, object, NULL, 1, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "512",
            "GFP_KERNEL"
          ],
          "line": 4736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"\\n2. kmalloc-256: Clobber 50th byte 0x9a->0x%p\\n\\n\"",
            "p"
          ],
          "line": 4733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "256",
            "GFP_KERNEL"
          ],
          "line": 4730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"1. kmalloc-128: Clobber first word 0x78->0x%p\\n\\n\"",
            "p"
          ],
          "line": 4727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "128",
            "GFP_KERNEL"
          ],
          "line": 4724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"\\nB. Corruption after free\\n\""
          ],
          "line": 4723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"If allocated object is overwritten then not detectable\\n\\n\""
          ],
          "line": 4720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"\\n3. kmalloc-64: corrupting random byte 0x56->0x%p\\n\"",
            "p"
          ],
          "line": 4718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cycles",
          "args": [],
          "line": 4716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "64",
            "GFP_KERNEL"
          ],
          "line": 4715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"If allocated object is overwritten then not detectable\\n\\n\""
          ],
          "line": 4712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"\\n2. kmalloc-32: Clobber next pointer/next slab 0x34 -> -0x%p\\n\"",
            "p"
          ],
          "line": 4710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "32",
            "GFP_KERNEL"
          ],
          "line": 4708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"\\n1. kmalloc-16: Clobber Redzone/next pointer 0x12->0x%p\\n\\n\"",
            "p + 16"
          ],
          "line": 4702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "16",
            "GFP_KERNEL"
          ],
          "line": 4700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"A. Corruption after allocation\\n\""
          ],
          "line": 4698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"-----------------------\\n\""
          ],
          "line": 4697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"SLUB resiliency testing\\n\""
          ],
          "line": 4696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "KMALLOC_MIN_SIZE > 16 || KMALLOC_SHIFT_HIGH < 10"
          ],
          "line": 4694
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void __init resiliency_test(void)\n{\n\tu8 *p;\n\tint type = KMALLOC_NORMAL;\n\n\tBUILD_BUG_ON(KMALLOC_MIN_SIZE > 16 || KMALLOC_SHIFT_HIGH < 10);\n\n\tpr_err(\"SLUB resiliency testing\\n\");\n\tpr_err(\"-----------------------\\n\");\n\tpr_err(\"A. Corruption after allocation\\n\");\n\n\tp = kzalloc(16, GFP_KERNEL);\n\tp[16] = 0x12;\n\tpr_err(\"\\n1. kmalloc-16: Clobber Redzone/next pointer 0x12->0x%p\\n\\n\",\n\t       p + 16);\n\n\tvalidate_slab_cache(kmalloc_caches[type][4]);\n\n\t/* Hmmm... The next two are dangerous */\n\tp = kzalloc(32, GFP_KERNEL);\n\tp[32 + sizeof(void *)] = 0x34;\n\tpr_err(\"\\n2. kmalloc-32: Clobber next pointer/next slab 0x34 -> -0x%p\\n\",\n\t       p);\n\tpr_err(\"If allocated object is overwritten then not detectable\\n\\n\");\n\n\tvalidate_slab_cache(kmalloc_caches[type][5]);\n\tp = kzalloc(64, GFP_KERNEL);\n\tp += 64 + (get_cycles() & 0xff) * sizeof(void *);\n\t*p = 0x56;\n\tpr_err(\"\\n3. kmalloc-64: corrupting random byte 0x56->0x%p\\n\",\n\t       p);\n\tpr_err(\"If allocated object is overwritten then not detectable\\n\\n\");\n\tvalidate_slab_cache(kmalloc_caches[type][6]);\n\n\tpr_err(\"\\nB. Corruption after free\\n\");\n\tp = kzalloc(128, GFP_KERNEL);\n\tkfree(p);\n\t*p = 0x78;\n\tpr_err(\"1. kmalloc-128: Clobber first word 0x78->0x%p\\n\\n\", p);\n\tvalidate_slab_cache(kmalloc_caches[type][7]);\n\n\tp = kzalloc(256, GFP_KERNEL);\n\tkfree(p);\n\tp[50] = 0x9a;\n\tpr_err(\"\\n2. kmalloc-256: Clobber 50th byte 0x9a->0x%p\\n\\n\", p);\n\tvalidate_slab_cache(kmalloc_caches[type][8]);\n\n\tp = kzalloc(512, GFP_KERNEL);\n\tkfree(p);\n\tp[512] = 0xab;\n\tpr_err(\"\\n3. kmalloc-512: Clobber redzone 0xab->0x%p\\n\\n\", p);\n\tvalidate_slab_cache(kmalloc_caches[type][9]);\n}"
  },
  {
    "function_name": "list_locations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "4603-4685",
    "snippet": "static int list_locations(struct kmem_cache *s, char *buf,\n\t\t\t\t\tenum track_item alloc)\n{\n\tint len = 0;\n\tunsigned long i;\n\tstruct loc_track t = { 0, 0, NULL };\n\tint node;\n\tstruct kmem_cache_node *n;\n\tunsigned long *map = bitmap_alloc(oo_objects(s->max), GFP_KERNEL);\n\n\tif (!map || !alloc_loc_track(&t, PAGE_SIZE / sizeof(struct location),\n\t\t\t\t     GFP_KERNEL)) {\n\t\tbitmap_free(map);\n\t\treturn sprintf(buf, \"Out of memory\\n\");\n\t}\n\t/* Push back cpu slabs */\n\tflush_all(s);\n\n\tfor_each_kmem_cache_node(s, node, n) {\n\t\tunsigned long flags;\n\t\tstruct page *page;\n\n\t\tif (!atomic_long_read(&n->nr_slabs))\n\t\t\tcontinue;\n\n\t\tspin_lock_irqsave(&n->list_lock, flags);\n\t\tlist_for_each_entry(page, &n->partial, lru)\n\t\t\tprocess_slab(&t, s, page, alloc, map);\n\t\tlist_for_each_entry(page, &n->full, lru)\n\t\t\tprocess_slab(&t, s, page, alloc, map);\n\t\tspin_unlock_irqrestore(&n->list_lock, flags);\n\t}\n\n\tfor (i = 0; i < t.count; i++) {\n\t\tstruct location *l = &t.loc[i];\n\n\t\tif (len > PAGE_SIZE - KSYM_SYMBOL_LEN - 100)\n\t\t\tbreak;\n\t\tlen += sprintf(buf + len, \"%7ld \", l->count);\n\n\t\tif (l->addr)\n\t\t\tlen += sprintf(buf + len, \"%pS\", (void *)l->addr);\n\t\telse\n\t\t\tlen += sprintf(buf + len, \"<not-available>\");\n\n\t\tif (l->sum_time != l->min_time) {\n\t\t\tlen += sprintf(buf + len, \" age=%ld/%ld/%ld\",\n\t\t\t\tl->min_time,\n\t\t\t\t(long)div_u64(l->sum_time, l->count),\n\t\t\t\tl->max_time);\n\t\t} else\n\t\t\tlen += sprintf(buf + len, \" age=%ld\",\n\t\t\t\tl->min_time);\n\n\t\tif (l->min_pid != l->max_pid)\n\t\t\tlen += sprintf(buf + len, \" pid=%ld-%ld\",\n\t\t\t\tl->min_pid, l->max_pid);\n\t\telse\n\t\t\tlen += sprintf(buf + len, \" pid=%ld\",\n\t\t\t\tl->min_pid);\n\n\t\tif (num_online_cpus() > 1 &&\n\t\t\t\t!cpumask_empty(to_cpumask(l->cpus)) &&\n\t\t\t\tlen < PAGE_SIZE - 60)\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len - 50,\n\t\t\t\t\t \" cpus=%*pbl\",\n\t\t\t\t\t cpumask_pr_args(to_cpumask(l->cpus)));\n\n\t\tif (nr_online_nodes > 1 && !nodes_empty(l->nodes) &&\n\t\t\t\tlen < PAGE_SIZE - 60)\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len - 50,\n\t\t\t\t\t \" nodes=%*pbl\",\n\t\t\t\t\t nodemask_pr_args(&l->nodes));\n\n\t\tlen += sprintf(buf + len, \"\\n\");\n\t}\n\n\tfree_loc_track(&t);\n\tbitmap_free(map);\n\tif (!t.count)\n\t\tlen += sprintf(buf, \"No data\\n\");\n\treturn len;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *kmem_cache_node;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"No data\\n\""
          ],
          "line": 4683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_free",
          "args": [
            "map"
          ],
          "line": 4681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_loc_track",
          "args": [
            "&t"
          ],
          "line": 4680
        },
        "resolved": true,
        "details": {
          "function_name": "free_loc_track",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "4485-4490",
          "snippet": "static void free_loc_track(struct loc_track *t)\n{\n\tif (t->max)\n\t\tfree_pages((unsigned long)t->loc,\n\t\t\tget_order(sizeof(struct location) * t->max));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void free_loc_track(struct loc_track *t)\n{\n\tif (t->max)\n\t\tfree_pages((unsigned long)t->loc,\n\t\t\tget_order(sizeof(struct location) * t->max));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf + len",
            "\"\\n\""
          ],
          "line": 4677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf + len",
            "PAGE_SIZE - len - 50",
            "\" nodes=%*pbl\"",
            "nodemask_pr_args(&l->nodes)"
          ],
          "line": 4673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodemask_pr_args",
          "args": [
            "&l->nodes"
          ],
          "line": 4675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_empty",
          "args": [
            "l->nodes"
          ],
          "line": 4671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf + len",
            "PAGE_SIZE - len - 50",
            "\" cpus=%*pbl\"",
            "cpumask_pr_args(to_cpumask(l->cpus))"
          ],
          "line": 4667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "to_cpumask(l->cpus)"
          ],
          "line": 4669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_cpumask",
          "args": [
            "l->cpus"
          ],
          "line": 4669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "to_cpumask(l->cpus)"
          ],
          "line": 4665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_cpumask",
          "args": [
            "l->cpus"
          ],
          "line": 4665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 4664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf + len",
            "\" pid=%ld\"",
            "l->min_pid"
          ],
          "line": 4661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf + len",
            "\" pid=%ld-%ld\"",
            "l->min_pid",
            "l->max_pid"
          ],
          "line": 4658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf + len",
            "\" age=%ld\"",
            "l->min_time"
          ],
          "line": 4654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf + len",
            "\" age=%ld/%ld/%ld\"",
            "l->min_time",
            "(long)div_u64(l->sum_time, l->count)",
            "l->max_time"
          ],
          "line": 4649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "l->sum_time",
            "l->count"
          ],
          "line": 4651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf + len",
            "\"<not-available>\""
          ],
          "line": 4646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf + len",
            "\"%pS\"",
            "(void *)l->addr"
          ],
          "line": 4644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf + len",
            "\"%7ld \"",
            "l->count"
          ],
          "line": 4641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&n->list_lock",
            "flags"
          ],
          "line": 4633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_slab",
          "args": [
            "&t",
            "s",
            "page",
            "alloc",
            "map"
          ],
          "line": 4632
        },
        "resolved": true,
        "details": {
          "function_name": "process_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "4588-4601",
          "snippet": "static void process_slab(struct loc_track *t, struct kmem_cache *s,\n\t\tstruct page *page, enum track_item alloc,\n\t\tunsigned long *map)\n{\n\tvoid *addr = page_address(page);\n\tvoid *p;\n\n\tbitmap_zero(map, page->objects);\n\tget_map(s, page, map);\n\n\tfor_each_object(p, s, addr, page->objects)\n\t\tif (!test_bit(slab_index(p, s, addr), map))\n\t\t\tadd_location(t, s, get_track(s, p, alloc));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void process_slab(struct loc_track *t, struct kmem_cache *s,\n\t\tstruct page *page, enum track_item alloc,\n\t\tunsigned long *map)\n{\n\tvoid *addr = page_address(page);\n\tvoid *p;\n\n\tbitmap_zero(map, page->objects);\n\tget_map(s, page, map);\n\n\tfor_each_object(p, s, addr, page->objects)\n\t\tif (!test_bit(slab_index(p, s, addr), map))\n\t\t\tadd_location(t, s, get_track(s, p, alloc));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "page",
            "&n->full",
            "lru"
          ],
          "line": 4631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "page",
            "&n->partial",
            "lru"
          ],
          "line": 4629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&n->list_lock",
            "flags"
          ],
          "line": 4628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&n->nr_slabs"
          ],
          "line": 4625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_kmem_cache_node",
          "args": [
            "s",
            "node",
            "n"
          ],
          "line": 4621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_all",
          "args": [
            "s"
          ],
          "line": 4619
        },
        "resolved": true,
        "details": {
          "function_name": "flush_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2339-2342",
          "snippet": "static void flush_all(struct kmem_cache *s)\n{\n\ton_each_cpu_cond(has_cpu_slab, flush_cpu_slab, s, 1, GFP_ATOMIC);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void flush_all(struct kmem_cache *s)\n{\n\ton_each_cpu_cond(has_cpu_slab, flush_cpu_slab, s, 1, GFP_ATOMIC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"Out of memory\\n\""
          ],
          "line": 4616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_free",
          "args": [
            "map"
          ],
          "line": 4615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_loc_track",
          "args": [
            "&t",
            "PAGE_SIZE / sizeof(struct location)",
            "GFP_KERNEL"
          ],
          "line": 4613
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_loc_track",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "4492-4510",
          "snippet": "static int alloc_loc_track(struct loc_track *t, unsigned long max, gfp_t flags)\n{\n\tstruct location *l;\n\tint order;\n\n\torder = get_order(sizeof(struct location) * max);\n\n\tl = (void *)__get_free_pages(flags, order);\n\tif (!l)\n\t\treturn 0;\n\n\tif (t->count) {\n\t\tmemcpy(l, t->loc, sizeof(struct location) * t->count);\n\t\tfree_loc_track(t);\n\t}\n\tt->max = max;\n\tt->loc = l;\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic int alloc_loc_track(struct loc_track *t, unsigned long max, gfp_t flags)\n{\n\tstruct location *l;\n\tint order;\n\n\torder = get_order(sizeof(struct location) * max);\n\n\tl = (void *)__get_free_pages(flags, order);\n\tif (!l)\n\t\treturn 0;\n\n\tif (t->count) {\n\t\tmemcpy(l, t->loc, sizeof(struct location) * t->count);\n\t\tfree_loc_track(t);\n\t}\n\tt->max = max;\n\tt->loc = l;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_alloc",
          "args": [
            "oo_objects(s->max)",
            "GFP_KERNEL"
          ],
          "line": 4611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oo_objects",
          "args": [
            "s->max"
          ],
          "line": 4611
        },
        "resolved": true,
        "details": {
          "function_name": "oo_objects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "337-340",
          "snippet": "static inline unsigned int oo_objects(struct kmem_cache_order_objects x)\n{\n\treturn x.x & OO_MASK;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define OO_MASK\t\t((1 << OO_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define OO_MASK\t\t((1 << OO_SHIFT) - 1)\n\nstatic inline unsigned int oo_objects(struct kmem_cache_order_objects x)\n{\n\treturn x.x & OO_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic int list_locations(struct kmem_cache *s, char *buf,\n\t\t\t\t\tenum track_item alloc)\n{\n\tint len = 0;\n\tunsigned long i;\n\tstruct loc_track t = { 0, 0, NULL };\n\tint node;\n\tstruct kmem_cache_node *n;\n\tunsigned long *map = bitmap_alloc(oo_objects(s->max), GFP_KERNEL);\n\n\tif (!map || !alloc_loc_track(&t, PAGE_SIZE / sizeof(struct location),\n\t\t\t\t     GFP_KERNEL)) {\n\t\tbitmap_free(map);\n\t\treturn sprintf(buf, \"Out of memory\\n\");\n\t}\n\t/* Push back cpu slabs */\n\tflush_all(s);\n\n\tfor_each_kmem_cache_node(s, node, n) {\n\t\tunsigned long flags;\n\t\tstruct page *page;\n\n\t\tif (!atomic_long_read(&n->nr_slabs))\n\t\t\tcontinue;\n\n\t\tspin_lock_irqsave(&n->list_lock, flags);\n\t\tlist_for_each_entry(page, &n->partial, lru)\n\t\t\tprocess_slab(&t, s, page, alloc, map);\n\t\tlist_for_each_entry(page, &n->full, lru)\n\t\t\tprocess_slab(&t, s, page, alloc, map);\n\t\tspin_unlock_irqrestore(&n->list_lock, flags);\n\t}\n\n\tfor (i = 0; i < t.count; i++) {\n\t\tstruct location *l = &t.loc[i];\n\n\t\tif (len > PAGE_SIZE - KSYM_SYMBOL_LEN - 100)\n\t\t\tbreak;\n\t\tlen += sprintf(buf + len, \"%7ld \", l->count);\n\n\t\tif (l->addr)\n\t\t\tlen += sprintf(buf + len, \"%pS\", (void *)l->addr);\n\t\telse\n\t\t\tlen += sprintf(buf + len, \"<not-available>\");\n\n\t\tif (l->sum_time != l->min_time) {\n\t\t\tlen += sprintf(buf + len, \" age=%ld/%ld/%ld\",\n\t\t\t\tl->min_time,\n\t\t\t\t(long)div_u64(l->sum_time, l->count),\n\t\t\t\tl->max_time);\n\t\t} else\n\t\t\tlen += sprintf(buf + len, \" age=%ld\",\n\t\t\t\tl->min_time);\n\n\t\tif (l->min_pid != l->max_pid)\n\t\t\tlen += sprintf(buf + len, \" pid=%ld-%ld\",\n\t\t\t\tl->min_pid, l->max_pid);\n\t\telse\n\t\t\tlen += sprintf(buf + len, \" pid=%ld\",\n\t\t\t\tl->min_pid);\n\n\t\tif (num_online_cpus() > 1 &&\n\t\t\t\t!cpumask_empty(to_cpumask(l->cpus)) &&\n\t\t\t\tlen < PAGE_SIZE - 60)\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len - 50,\n\t\t\t\t\t \" cpus=%*pbl\",\n\t\t\t\t\t cpumask_pr_args(to_cpumask(l->cpus)));\n\n\t\tif (nr_online_nodes > 1 && !nodes_empty(l->nodes) &&\n\t\t\t\tlen < PAGE_SIZE - 60)\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len - 50,\n\t\t\t\t\t \" nodes=%*pbl\",\n\t\t\t\t\t nodemask_pr_args(&l->nodes));\n\n\t\tlen += sprintf(buf + len, \"\\n\");\n\t}\n\n\tfree_loc_track(&t);\n\tbitmap_free(map);\n\tif (!t.count)\n\t\tlen += sprintf(buf, \"No data\\n\");\n\treturn len;\n}"
  },
  {
    "function_name": "process_slab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "4588-4601",
    "snippet": "static void process_slab(struct loc_track *t, struct kmem_cache *s,\n\t\tstruct page *page, enum track_item alloc,\n\t\tunsigned long *map)\n{\n\tvoid *addr = page_address(page);\n\tvoid *p;\n\n\tbitmap_zero(map, page->objects);\n\tget_map(s, page, map);\n\n\tfor_each_object(p, s, addr, page->objects)\n\t\tif (!test_bit(slab_index(p, s, addr), map))\n\t\t\tadd_location(t, s, get_track(s, p, alloc));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_location",
          "args": [
            "t",
            "s",
            "get_track(s, p, alloc)"
          ],
          "line": 4600
        },
        "resolved": true,
        "details": {
          "function_name": "add_location",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "4512-4586",
          "snippet": "static int add_location(struct loc_track *t, struct kmem_cache *s,\n\t\t\t\tconst struct track *track)\n{\n\tlong start, end, pos;\n\tstruct location *l;\n\tunsigned long caddr;\n\tunsigned long age = jiffies - track->when;\n\n\tstart = -1;\n\tend = t->count;\n\n\tfor ( ; ; ) {\n\t\tpos = start + (end - start + 1) / 2;\n\n\t\t/*\n\t\t * There is nothing at \"end\". If we end up there\n\t\t * we need to add something to before end.\n\t\t */\n\t\tif (pos == end)\n\t\t\tbreak;\n\n\t\tcaddr = t->loc[pos].addr;\n\t\tif (track->addr == caddr) {\n\n\t\t\tl = &t->loc[pos];\n\t\t\tl->count++;\n\t\t\tif (track->when) {\n\t\t\t\tl->sum_time += age;\n\t\t\t\tif (age < l->min_time)\n\t\t\t\t\tl->min_time = age;\n\t\t\t\tif (age > l->max_time)\n\t\t\t\t\tl->max_time = age;\n\n\t\t\t\tif (track->pid < l->min_pid)\n\t\t\t\t\tl->min_pid = track->pid;\n\t\t\t\tif (track->pid > l->max_pid)\n\t\t\t\t\tl->max_pid = track->pid;\n\n\t\t\t\tcpumask_set_cpu(track->cpu,\n\t\t\t\t\t\tto_cpumask(l->cpus));\n\t\t\t}\n\t\t\tnode_set(page_to_nid(virt_to_page(track)), l->nodes);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (track->addr < caddr)\n\t\t\tend = pos;\n\t\telse\n\t\t\tstart = pos;\n\t}\n\n\t/*\n\t * Not found. Insert new tracking element.\n\t */\n\tif (t->count >= t->max && !alloc_loc_track(t, 2 * t->max, GFP_ATOMIC))\n\t\treturn 0;\n\n\tl = t->loc + pos;\n\tif (pos < t->count)\n\t\tmemmove(l + 1, l,\n\t\t\t(t->count - pos) * sizeof(struct location));\n\tt->count++;\n\tl->count = 1;\n\tl->addr = track->addr;\n\tl->sum_time = age;\n\tl->min_time = age;\n\tl->max_time = age;\n\tl->min_pid = track->pid;\n\tl->max_pid = track->pid;\n\tcpumask_clear(to_cpumask(l->cpus));\n\tcpumask_set_cpu(track->cpu, to_cpumask(l->cpus));\n\tnodes_clear(l->nodes);\n\tnode_set(page_to_nid(virt_to_page(track)), l->nodes);\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic int add_location(struct loc_track *t, struct kmem_cache *s,\n\t\t\t\tconst struct track *track)\n{\n\tlong start, end, pos;\n\tstruct location *l;\n\tunsigned long caddr;\n\tunsigned long age = jiffies - track->when;\n\n\tstart = -1;\n\tend = t->count;\n\n\tfor ( ; ; ) {\n\t\tpos = start + (end - start + 1) / 2;\n\n\t\t/*\n\t\t * There is nothing at \"end\". If we end up there\n\t\t * we need to add something to before end.\n\t\t */\n\t\tif (pos == end)\n\t\t\tbreak;\n\n\t\tcaddr = t->loc[pos].addr;\n\t\tif (track->addr == caddr) {\n\n\t\t\tl = &t->loc[pos];\n\t\t\tl->count++;\n\t\t\tif (track->when) {\n\t\t\t\tl->sum_time += age;\n\t\t\t\tif (age < l->min_time)\n\t\t\t\t\tl->min_time = age;\n\t\t\t\tif (age > l->max_time)\n\t\t\t\t\tl->max_time = age;\n\n\t\t\t\tif (track->pid < l->min_pid)\n\t\t\t\t\tl->min_pid = track->pid;\n\t\t\t\tif (track->pid > l->max_pid)\n\t\t\t\t\tl->max_pid = track->pid;\n\n\t\t\t\tcpumask_set_cpu(track->cpu,\n\t\t\t\t\t\tto_cpumask(l->cpus));\n\t\t\t}\n\t\t\tnode_set(page_to_nid(virt_to_page(track)), l->nodes);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (track->addr < caddr)\n\t\t\tend = pos;\n\t\telse\n\t\t\tstart = pos;\n\t}\n\n\t/*\n\t * Not found. Insert new tracking element.\n\t */\n\tif (t->count >= t->max && !alloc_loc_track(t, 2 * t->max, GFP_ATOMIC))\n\t\treturn 0;\n\n\tl = t->loc + pos;\n\tif (pos < t->count)\n\t\tmemmove(l + 1, l,\n\t\t\t(t->count - pos) * sizeof(struct location));\n\tt->count++;\n\tl->count = 1;\n\tl->addr = track->addr;\n\tl->sum_time = age;\n\tl->min_time = age;\n\tl->max_time = age;\n\tl->min_pid = track->pid;\n\tl->max_pid = track->pid;\n\tcpumask_clear(to_cpumask(l->cpus));\n\tcpumask_set_cpu(track->cpu, to_cpumask(l->cpus));\n\tnodes_clear(l->nodes);\n\tnode_set(page_to_nid(virt_to_page(track)), l->nodes);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_track",
          "args": [
            "s",
            "p",
            "alloc"
          ],
          "line": 4600
        },
        "resolved": true,
        "details": {
          "function_name": "get_track",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "528-539",
          "snippet": "static struct track *get_track(struct kmem_cache *s, void *object,\n\tenum track_item alloc)\n{\n\tstruct track *p;\n\n\tif (s->offset)\n\t\tp = object + s->offset + sizeof(void *);\n\telse\n\t\tp = object + s->inuse;\n\n\treturn p + alloc;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct track *get_track(struct kmem_cache *s, void *object,\n\tenum track_item alloc)\n{\n\tstruct track *p;\n\n\tif (s->offset)\n\t\tp = object + s->offset + sizeof(void *);\n\telse\n\t\tp = object + s->inuse;\n\n\treturn p + alloc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "slab_index(p, s, addr)",
            "map"
          ],
          "line": 4599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_index",
          "args": [
            "p",
            "s",
            "addr"
          ],
          "line": 4599
        },
        "resolved": true,
        "details": {
          "function_name": "slab_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "312-315",
          "snippet": "static inline unsigned int slab_index(void *p, struct kmem_cache *s, void *addr)\n{\n\treturn (p - addr) / s->size;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline unsigned int slab_index(void *p, struct kmem_cache *s, void *addr)\n{\n\treturn (p - addr) / s->size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_object",
          "args": [
            "p",
            "s",
            "addr",
            "page->objects"
          ],
          "line": 4598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_map",
          "args": [
            "s",
            "page",
            "map"
          ],
          "line": 4596
        },
        "resolved": true,
        "details": {
          "function_name": "get_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "443-450",
          "snippet": "static void get_map(struct kmem_cache *s, struct page *page, unsigned long *map)\n{\n\tvoid *p;\n\tvoid *addr = page_address(page);\n\n\tfor (p = page->freelist; p; p = get_freepointer(s, p))\n\t\tset_bit(slab_index(p, s, addr), map);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void get_map(struct kmem_cache *s, struct page *page, unsigned long *map)\n{\n\tvoid *p;\n\tvoid *addr = page_address(page);\n\n\tfor (p = page->freelist; p; p = get_freepointer(s, p))\n\t\tset_bit(slab_index(p, s, addr), map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_zero",
          "args": [
            "map",
            "page->objects"
          ],
          "line": 4595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 4592
        },
        "resolved": true,
        "details": {
          "function_name": "page_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "409-434",
          "snippet": "void *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void process_slab(struct loc_track *t, struct kmem_cache *s,\n\t\tstruct page *page, enum track_item alloc,\n\t\tunsigned long *map)\n{\n\tvoid *addr = page_address(page);\n\tvoid *p;\n\n\tbitmap_zero(map, page->objects);\n\tget_map(s, page, map);\n\n\tfor_each_object(p, s, addr, page->objects)\n\t\tif (!test_bit(slab_index(p, s, addr), map))\n\t\t\tadd_location(t, s, get_track(s, p, alloc));\n}"
  },
  {
    "function_name": "add_location",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "4512-4586",
    "snippet": "static int add_location(struct loc_track *t, struct kmem_cache *s,\n\t\t\t\tconst struct track *track)\n{\n\tlong start, end, pos;\n\tstruct location *l;\n\tunsigned long caddr;\n\tunsigned long age = jiffies - track->when;\n\n\tstart = -1;\n\tend = t->count;\n\n\tfor ( ; ; ) {\n\t\tpos = start + (end - start + 1) / 2;\n\n\t\t/*\n\t\t * There is nothing at \"end\". If we end up there\n\t\t * we need to add something to before end.\n\t\t */\n\t\tif (pos == end)\n\t\t\tbreak;\n\n\t\tcaddr = t->loc[pos].addr;\n\t\tif (track->addr == caddr) {\n\n\t\t\tl = &t->loc[pos];\n\t\t\tl->count++;\n\t\t\tif (track->when) {\n\t\t\t\tl->sum_time += age;\n\t\t\t\tif (age < l->min_time)\n\t\t\t\t\tl->min_time = age;\n\t\t\t\tif (age > l->max_time)\n\t\t\t\t\tl->max_time = age;\n\n\t\t\t\tif (track->pid < l->min_pid)\n\t\t\t\t\tl->min_pid = track->pid;\n\t\t\t\tif (track->pid > l->max_pid)\n\t\t\t\t\tl->max_pid = track->pid;\n\n\t\t\t\tcpumask_set_cpu(track->cpu,\n\t\t\t\t\t\tto_cpumask(l->cpus));\n\t\t\t}\n\t\t\tnode_set(page_to_nid(virt_to_page(track)), l->nodes);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (track->addr < caddr)\n\t\t\tend = pos;\n\t\telse\n\t\t\tstart = pos;\n\t}\n\n\t/*\n\t * Not found. Insert new tracking element.\n\t */\n\tif (t->count >= t->max && !alloc_loc_track(t, 2 * t->max, GFP_ATOMIC))\n\t\treturn 0;\n\n\tl = t->loc + pos;\n\tif (pos < t->count)\n\t\tmemmove(l + 1, l,\n\t\t\t(t->count - pos) * sizeof(struct location));\n\tt->count++;\n\tl->count = 1;\n\tl->addr = track->addr;\n\tl->sum_time = age;\n\tl->min_time = age;\n\tl->max_time = age;\n\tl->min_pid = track->pid;\n\tl->max_pid = track->pid;\n\tcpumask_clear(to_cpumask(l->cpus));\n\tcpumask_set_cpu(track->cpu, to_cpumask(l->cpus));\n\tnodes_clear(l->nodes);\n\tnode_set(page_to_nid(virt_to_page(track)), l->nodes);\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "node_set",
          "args": [
            "page_to_nid(virt_to_page(track))",
            "l->nodes"
          ],
          "line": 4584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "virt_to_page(track)"
          ],
          "line": 4584
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "track"
          ],
          "line": 4584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_clear",
          "args": [
            "l->nodes"
          ],
          "line": 4583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "track->cpu",
            "to_cpumask(l->cpus)"
          ],
          "line": 4582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_cpumask",
          "args": [
            "l->cpus"
          ],
          "line": 4582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear",
          "args": [
            "to_cpumask(l->cpus)"
          ],
          "line": 4581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_cpumask",
          "args": [
            "l->cpus"
          ],
          "line": 4581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "l + 1",
            "l",
            "(t->count - pos) * sizeof(struct location)"
          ],
          "line": 4571
        },
        "resolved": true,
        "details": {
          "function_name": "memmove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "291-297",
          "snippet": "void *memmove(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memmove(dest, src, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memmove(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memmove(dest, src, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_loc_track",
          "args": [
            "t",
            "2 * t->max",
            "GFP_ATOMIC"
          ],
          "line": 4566
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_loc_track",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "4492-4510",
          "snippet": "static int alloc_loc_track(struct loc_track *t, unsigned long max, gfp_t flags)\n{\n\tstruct location *l;\n\tint order;\n\n\torder = get_order(sizeof(struct location) * max);\n\n\tl = (void *)__get_free_pages(flags, order);\n\tif (!l)\n\t\treturn 0;\n\n\tif (t->count) {\n\t\tmemcpy(l, t->loc, sizeof(struct location) * t->count);\n\t\tfree_loc_track(t);\n\t}\n\tt->max = max;\n\tt->loc = l;\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic int alloc_loc_track(struct loc_track *t, unsigned long max, gfp_t flags)\n{\n\tstruct location *l;\n\tint order;\n\n\torder = get_order(sizeof(struct location) * max);\n\n\tl = (void *)__get_free_pages(flags, order);\n\tif (!l)\n\t\treturn 0;\n\n\tif (t->count) {\n\t\tmemcpy(l, t->loc, sizeof(struct location) * t->count);\n\t\tfree_loc_track(t);\n\t}\n\tt->max = max;\n\tt->loc = l;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "node_set",
          "args": [
            "page_to_nid(virt_to_page(track))",
            "l->nodes"
          ],
          "line": 4553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "track"
          ],
          "line": 4553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "track->cpu",
            "to_cpumask(l->cpus)"
          ],
          "line": 4550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_cpumask",
          "args": [
            "l->cpus"
          ],
          "line": 4551
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic int add_location(struct loc_track *t, struct kmem_cache *s,\n\t\t\t\tconst struct track *track)\n{\n\tlong start, end, pos;\n\tstruct location *l;\n\tunsigned long caddr;\n\tunsigned long age = jiffies - track->when;\n\n\tstart = -1;\n\tend = t->count;\n\n\tfor ( ; ; ) {\n\t\tpos = start + (end - start + 1) / 2;\n\n\t\t/*\n\t\t * There is nothing at \"end\". If we end up there\n\t\t * we need to add something to before end.\n\t\t */\n\t\tif (pos == end)\n\t\t\tbreak;\n\n\t\tcaddr = t->loc[pos].addr;\n\t\tif (track->addr == caddr) {\n\n\t\t\tl = &t->loc[pos];\n\t\t\tl->count++;\n\t\t\tif (track->when) {\n\t\t\t\tl->sum_time += age;\n\t\t\t\tif (age < l->min_time)\n\t\t\t\t\tl->min_time = age;\n\t\t\t\tif (age > l->max_time)\n\t\t\t\t\tl->max_time = age;\n\n\t\t\t\tif (track->pid < l->min_pid)\n\t\t\t\t\tl->min_pid = track->pid;\n\t\t\t\tif (track->pid > l->max_pid)\n\t\t\t\t\tl->max_pid = track->pid;\n\n\t\t\t\tcpumask_set_cpu(track->cpu,\n\t\t\t\t\t\tto_cpumask(l->cpus));\n\t\t\t}\n\t\t\tnode_set(page_to_nid(virt_to_page(track)), l->nodes);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (track->addr < caddr)\n\t\t\tend = pos;\n\t\telse\n\t\t\tstart = pos;\n\t}\n\n\t/*\n\t * Not found. Insert new tracking element.\n\t */\n\tif (t->count >= t->max && !alloc_loc_track(t, 2 * t->max, GFP_ATOMIC))\n\t\treturn 0;\n\n\tl = t->loc + pos;\n\tif (pos < t->count)\n\t\tmemmove(l + 1, l,\n\t\t\t(t->count - pos) * sizeof(struct location));\n\tt->count++;\n\tl->count = 1;\n\tl->addr = track->addr;\n\tl->sum_time = age;\n\tl->min_time = age;\n\tl->max_time = age;\n\tl->min_pid = track->pid;\n\tl->max_pid = track->pid;\n\tcpumask_clear(to_cpumask(l->cpus));\n\tcpumask_set_cpu(track->cpu, to_cpumask(l->cpus));\n\tnodes_clear(l->nodes);\n\tnode_set(page_to_nid(virt_to_page(track)), l->nodes);\n\treturn 1;\n}"
  },
  {
    "function_name": "alloc_loc_track",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "4492-4510",
    "snippet": "static int alloc_loc_track(struct loc_track *t, unsigned long max, gfp_t flags)\n{\n\tstruct location *l;\n\tint order;\n\n\torder = get_order(sizeof(struct location) * max);\n\n\tl = (void *)__get_free_pages(flags, order);\n\tif (!l)\n\t\treturn 0;\n\n\tif (t->count) {\n\t\tmemcpy(l, t->loc, sizeof(struct location) * t->count);\n\t\tfree_loc_track(t);\n\t}\n\tt->max = max;\n\tt->loc = l;\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_loc_track",
          "args": [
            "t"
          ],
          "line": 4505
        },
        "resolved": true,
        "details": {
          "function_name": "free_loc_track",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "4485-4490",
          "snippet": "static void free_loc_track(struct loc_track *t)\n{\n\tif (t->max)\n\t\tfree_pages((unsigned long)t->loc,\n\t\t\tget_order(sizeof(struct location) * t->max));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void free_loc_track(struct loc_track *t)\n{\n\tif (t->max)\n\t\tfree_pages((unsigned long)t->loc,\n\t\t\tget_order(sizeof(struct location) * t->max));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "l",
            "t->loc",
            "sizeof(struct location) * t->count"
          ],
          "line": 4504
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "300-306",
          "snippet": "void *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_free_pages",
          "args": [
            "flags",
            "order"
          ],
          "line": 4499
        },
        "resolved": true,
        "details": {
          "function_name": "__get_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4413-4421",
          "snippet": "unsigned long __get_free_pages(gfp_t gfp_mask, unsigned int order)\n{\n\tstruct page *page;\n\n\tpage = alloc_pages(gfp_mask & ~__GFP_HIGHMEM, order);\n\tif (!page)\n\t\treturn 0;\n\treturn (unsigned long) page_address(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nunsigned long __get_free_pages(gfp_t gfp_mask, unsigned int order)\n{\n\tstruct page *page;\n\n\tpage = alloc_pages(gfp_mask & ~__GFP_HIGHMEM, order);\n\tif (!page)\n\t\treturn 0;\n\treturn (unsigned long) page_address(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "sizeof(struct location) * max"
          ],
          "line": 4497
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic int alloc_loc_track(struct loc_track *t, unsigned long max, gfp_t flags)\n{\n\tstruct location *l;\n\tint order;\n\n\torder = get_order(sizeof(struct location) * max);\n\n\tl = (void *)__get_free_pages(flags, order);\n\tif (!l)\n\t\treturn 0;\n\n\tif (t->count) {\n\t\tmemcpy(l, t->loc, sizeof(struct location) * t->count);\n\t\tfree_loc_track(t);\n\t}\n\tt->max = max;\n\tt->loc = l;\n\treturn 1;\n}"
  },
  {
    "function_name": "free_loc_track",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "4485-4490",
    "snippet": "static void free_loc_track(struct loc_track *t)\n{\n\tif (t->max)\n\t\tfree_pages((unsigned long)t->loc,\n\t\t\tget_order(sizeof(struct location) * t->max));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_pages",
          "args": [
            "(unsigned long)t->loc",
            "get_order(sizeof(struct location) * t->max)"
          ],
          "line": 4488
        },
        "resolved": true,
        "details": {
          "function_name": "free_pages_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4630-4639",
          "snippet": "void free_pages_exact(void *virt, size_t size)\n{\n\tunsigned long addr = (unsigned long)virt;\n\tunsigned long end = addr + PAGE_ALIGN(size);\n\n\twhile (addr < end) {\n\t\tfree_page(addr);\n\t\taddr += PAGE_SIZE;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid free_pages_exact(void *virt, size_t size)\n{\n\tunsigned long addr = (unsigned long)virt;\n\tunsigned long end = addr + PAGE_ALIGN(size);\n\n\twhile (addr < end) {\n\t\tfree_page(addr);\n\t\taddr += PAGE_SIZE;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "sizeof(struct location) * t->max"
          ],
          "line": 4489
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void free_loc_track(struct loc_track *t)\n{\n\tif (t->max)\n\t\tfree_pages((unsigned long)t->loc,\n\t\t\tget_order(sizeof(struct location) * t->max));\n}"
  },
  {
    "function_name": "validate_slab_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "4446-4461",
    "snippet": "static long validate_slab_cache(struct kmem_cache *s)\n{\n\tint node;\n\tunsigned long count = 0;\n\tstruct kmem_cache_node *n;\n\tunsigned long *map = bitmap_alloc(oo_objects(s->max), GFP_KERNEL);\n\n\tif (!map)\n\t\treturn -ENOMEM;\n\n\tflush_all(s);\n\tfor_each_kmem_cache_node(s, node, n)\n\t\tcount += validate_slab_node(s, n, map);\n\tbitmap_free(map);\n\treturn count;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *kmem_cache_node;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bitmap_free",
          "args": [
            "map"
          ],
          "line": 4459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_slab_node",
          "args": [
            "s",
            "n",
            "map"
          ],
          "line": 4458
        },
        "resolved": true,
        "details": {
          "function_name": "validate_slab_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "4413-4444",
          "snippet": "static int validate_slab_node(struct kmem_cache *s,\n\t\tstruct kmem_cache_node *n, unsigned long *map)\n{\n\tunsigned long count = 0;\n\tstruct page *page;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&n->list_lock, flags);\n\n\tlist_for_each_entry(page, &n->partial, lru) {\n\t\tvalidate_slab_slab(s, page, map);\n\t\tcount++;\n\t}\n\tif (count != n->nr_partial)\n\t\tpr_err(\"SLUB %s: %ld partial slabs counted but counter=%ld\\n\",\n\t\t       s->name, count, n->nr_partial);\n\n\tif (!(s->flags & SLAB_STORE_USER))\n\t\tgoto out;\n\n\tlist_for_each_entry(page, &n->full, lru) {\n\t\tvalidate_slab_slab(s, page, map);\n\t\tcount++;\n\t}\n\tif (count != atomic_long_read(&n->nr_slabs))\n\t\tpr_err(\"SLUB: %s %ld slabs counted but counter=%ld\\n\",\n\t\t       s->name, count, atomic_long_read(&n->nr_slabs));\n\nout:\n\tspin_unlock_irqrestore(&n->list_lock, flags);\n\treturn count;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic int validate_slab_node(struct kmem_cache *s,\n\t\tstruct kmem_cache_node *n, unsigned long *map)\n{\n\tunsigned long count = 0;\n\tstruct page *page;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&n->list_lock, flags);\n\n\tlist_for_each_entry(page, &n->partial, lru) {\n\t\tvalidate_slab_slab(s, page, map);\n\t\tcount++;\n\t}\n\tif (count != n->nr_partial)\n\t\tpr_err(\"SLUB %s: %ld partial slabs counted but counter=%ld\\n\",\n\t\t       s->name, count, n->nr_partial);\n\n\tif (!(s->flags & SLAB_STORE_USER))\n\t\tgoto out;\n\n\tlist_for_each_entry(page, &n->full, lru) {\n\t\tvalidate_slab_slab(s, page, map);\n\t\tcount++;\n\t}\n\tif (count != atomic_long_read(&n->nr_slabs))\n\t\tpr_err(\"SLUB: %s %ld slabs counted but counter=%ld\\n\",\n\t\t       s->name, count, atomic_long_read(&n->nr_slabs));\n\nout:\n\tspin_unlock_irqrestore(&n->list_lock, flags);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_kmem_cache_node",
          "args": [
            "s",
            "node",
            "n"
          ],
          "line": 4457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_all",
          "args": [
            "s"
          ],
          "line": 4456
        },
        "resolved": true,
        "details": {
          "function_name": "flush_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2339-2342",
          "snippet": "static void flush_all(struct kmem_cache *s)\n{\n\ton_each_cpu_cond(has_cpu_slab, flush_cpu_slab, s, 1, GFP_ATOMIC);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void flush_all(struct kmem_cache *s)\n{\n\ton_each_cpu_cond(has_cpu_slab, flush_cpu_slab, s, 1, GFP_ATOMIC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_alloc",
          "args": [
            "oo_objects(s->max)",
            "GFP_KERNEL"
          ],
          "line": 4451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oo_objects",
          "args": [
            "s->max"
          ],
          "line": 4451
        },
        "resolved": true,
        "details": {
          "function_name": "oo_objects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "337-340",
          "snippet": "static inline unsigned int oo_objects(struct kmem_cache_order_objects x)\n{\n\treturn x.x & OO_MASK;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define OO_MASK\t\t((1 << OO_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define OO_MASK\t\t((1 << OO_SHIFT) - 1)\n\nstatic inline unsigned int oo_objects(struct kmem_cache_order_objects x)\n{\n\treturn x.x & OO_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic long validate_slab_cache(struct kmem_cache *s)\n{\n\tint node;\n\tunsigned long count = 0;\n\tstruct kmem_cache_node *n;\n\tunsigned long *map = bitmap_alloc(oo_objects(s->max), GFP_KERNEL);\n\n\tif (!map)\n\t\treturn -ENOMEM;\n\n\tflush_all(s);\n\tfor_each_kmem_cache_node(s, node, n)\n\t\tcount += validate_slab_node(s, n, map);\n\tbitmap_free(map);\n\treturn count;\n}"
  },
  {
    "function_name": "validate_slab_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "4413-4444",
    "snippet": "static int validate_slab_node(struct kmem_cache *s,\n\t\tstruct kmem_cache_node *n, unsigned long *map)\n{\n\tunsigned long count = 0;\n\tstruct page *page;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&n->list_lock, flags);\n\n\tlist_for_each_entry(page, &n->partial, lru) {\n\t\tvalidate_slab_slab(s, page, map);\n\t\tcount++;\n\t}\n\tif (count != n->nr_partial)\n\t\tpr_err(\"SLUB %s: %ld partial slabs counted but counter=%ld\\n\",\n\t\t       s->name, count, n->nr_partial);\n\n\tif (!(s->flags & SLAB_STORE_USER))\n\t\tgoto out;\n\n\tlist_for_each_entry(page, &n->full, lru) {\n\t\tvalidate_slab_slab(s, page, map);\n\t\tcount++;\n\t}\n\tif (count != atomic_long_read(&n->nr_slabs))\n\t\tpr_err(\"SLUB: %s %ld slabs counted but counter=%ld\\n\",\n\t\t       s->name, count, atomic_long_read(&n->nr_slabs));\n\nout:\n\tspin_unlock_irqrestore(&n->list_lock, flags);\n\treturn count;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *kmem_cache_node;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&n->list_lock",
            "flags"
          ],
          "line": 4442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"SLUB: %s %ld slabs counted but counter=%ld\\n\"",
            "s->name",
            "count",
            "atomic_long_read(&n->nr_slabs)"
          ],
          "line": 4438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&n->nr_slabs"
          ],
          "line": 4439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&n->nr_slabs"
          ],
          "line": 4437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_slab_slab",
          "args": [
            "s",
            "page",
            "map"
          ],
          "line": 4434
        },
        "resolved": true,
        "details": {
          "function_name": "validate_slab_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "4405-4411",
          "snippet": "static void validate_slab_slab(struct kmem_cache *s, struct page *page,\n\t\t\t\t\t\tunsigned long *map)\n{\n\tslab_lock(page);\n\tvalidate_slab(s, page, map);\n\tslab_unlock(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void validate_slab_slab(struct kmem_cache *s, struct page *page,\n\t\t\t\t\t\tunsigned long *map)\n{\n\tslab_lock(page);\n\tvalidate_slab(s, page, map);\n\tslab_unlock(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "page",
            "&n->full",
            "lru"
          ],
          "line": 4433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"SLUB %s: %ld partial slabs counted but counter=%ld\\n\"",
            "s->name",
            "count",
            "n->nr_partial"
          ],
          "line": 4427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "page",
            "&n->partial",
            "lru"
          ],
          "line": 4422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&n->list_lock",
            "flags"
          ],
          "line": 4420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic int validate_slab_node(struct kmem_cache *s,\n\t\tstruct kmem_cache_node *n, unsigned long *map)\n{\n\tunsigned long count = 0;\n\tstruct page *page;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&n->list_lock, flags);\n\n\tlist_for_each_entry(page, &n->partial, lru) {\n\t\tvalidate_slab_slab(s, page, map);\n\t\tcount++;\n\t}\n\tif (count != n->nr_partial)\n\t\tpr_err(\"SLUB %s: %ld partial slabs counted but counter=%ld\\n\",\n\t\t       s->name, count, n->nr_partial);\n\n\tif (!(s->flags & SLAB_STORE_USER))\n\t\tgoto out;\n\n\tlist_for_each_entry(page, &n->full, lru) {\n\t\tvalidate_slab_slab(s, page, map);\n\t\tcount++;\n\t}\n\tif (count != atomic_long_read(&n->nr_slabs))\n\t\tpr_err(\"SLUB: %s %ld slabs counted but counter=%ld\\n\",\n\t\t       s->name, count, atomic_long_read(&n->nr_slabs));\n\nout:\n\tspin_unlock_irqrestore(&n->list_lock, flags);\n\treturn count;\n}"
  },
  {
    "function_name": "validate_slab_slab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "4405-4411",
    "snippet": "static void validate_slab_slab(struct kmem_cache *s, struct page *page,\n\t\t\t\t\t\tunsigned long *map)\n{\n\tslab_lock(page);\n\tvalidate_slab(s, page, map);\n\tslab_unlock(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "slab_unlock",
          "args": [
            "page"
          ],
          "line": 4410
        },
        "resolved": true,
        "details": {
          "function_name": "slab_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "351-355",
          "snippet": "static __always_inline void slab_unlock(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\t__bit_spin_unlock(PG_locked, &page->flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic __always_inline void slab_unlock(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\t__bit_spin_unlock(PG_locked, &page->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_slab",
          "args": [
            "s",
            "page",
            "map"
          ],
          "line": 4409
        },
        "resolved": true,
        "details": {
          "function_name": "validate_slab_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "4413-4444",
          "snippet": "static int validate_slab_node(struct kmem_cache *s,\n\t\tstruct kmem_cache_node *n, unsigned long *map)\n{\n\tunsigned long count = 0;\n\tstruct page *page;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&n->list_lock, flags);\n\n\tlist_for_each_entry(page, &n->partial, lru) {\n\t\tvalidate_slab_slab(s, page, map);\n\t\tcount++;\n\t}\n\tif (count != n->nr_partial)\n\t\tpr_err(\"SLUB %s: %ld partial slabs counted but counter=%ld\\n\",\n\t\t       s->name, count, n->nr_partial);\n\n\tif (!(s->flags & SLAB_STORE_USER))\n\t\tgoto out;\n\n\tlist_for_each_entry(page, &n->full, lru) {\n\t\tvalidate_slab_slab(s, page, map);\n\t\tcount++;\n\t}\n\tif (count != atomic_long_read(&n->nr_slabs))\n\t\tpr_err(\"SLUB: %s %ld slabs counted but counter=%ld\\n\",\n\t\t       s->name, count, atomic_long_read(&n->nr_slabs));\n\nout:\n\tspin_unlock_irqrestore(&n->list_lock, flags);\n\treturn count;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic int validate_slab_node(struct kmem_cache *s,\n\t\tstruct kmem_cache_node *n, unsigned long *map)\n{\n\tunsigned long count = 0;\n\tstruct page *page;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&n->list_lock, flags);\n\n\tlist_for_each_entry(page, &n->partial, lru) {\n\t\tvalidate_slab_slab(s, page, map);\n\t\tcount++;\n\t}\n\tif (count != n->nr_partial)\n\t\tpr_err(\"SLUB %s: %ld partial slabs counted but counter=%ld\\n\",\n\t\t       s->name, count, n->nr_partial);\n\n\tif (!(s->flags & SLAB_STORE_USER))\n\t\tgoto out;\n\n\tlist_for_each_entry(page, &n->full, lru) {\n\t\tvalidate_slab_slab(s, page, map);\n\t\tcount++;\n\t}\n\tif (count != atomic_long_read(&n->nr_slabs))\n\t\tpr_err(\"SLUB: %s %ld slabs counted but counter=%ld\\n\",\n\t\t       s->name, count, atomic_long_read(&n->nr_slabs));\n\nout:\n\tspin_unlock_irqrestore(&n->list_lock, flags);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "slab_lock",
          "args": [
            "page"
          ],
          "line": 4408
        },
        "resolved": true,
        "details": {
          "function_name": "slab_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "345-349",
          "snippet": "static __always_inline void slab_lock(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tbit_spin_lock(PG_locked, &page->flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic __always_inline void slab_lock(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tbit_spin_lock(PG_locked, &page->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void validate_slab_slab(struct kmem_cache *s, struct page *page,\n\t\t\t\t\t\tunsigned long *map)\n{\n\tslab_lock(page);\n\tvalidate_slab(s, page, map);\n\tslab_unlock(page);\n}"
  },
  {
    "function_name": "validate_slab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "4378-4403",
    "snippet": "static int validate_slab(struct kmem_cache *s, struct page *page,\n\t\t\t\t\t\tunsigned long *map)\n{\n\tvoid *p;\n\tvoid *addr = page_address(page);\n\n\tif (!check_slab(s, page) ||\n\t\t\t!on_freelist(s, page, NULL))\n\t\treturn 0;\n\n\t/* Now we know that a valid freelist exists */\n\tbitmap_zero(map, page->objects);\n\n\tget_map(s, page, map);\n\tfor_each_object(p, s, addr, page->objects) {\n\t\tif (test_bit(slab_index(p, s, addr), map))\n\t\t\tif (!check_object(s, page, p, SLUB_RED_INACTIVE))\n\t\t\t\treturn 0;\n\t}\n\n\tfor_each_object(p, s, addr, page->objects)\n\t\tif (!test_bit(slab_index(p, s, addr), map))\n\t\t\tif (!check_object(s, page, p, SLUB_RED_ACTIVE))\n\t\t\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_object",
          "args": [
            "s",
            "page",
            "p",
            "SLUB_RED_ACTIVE"
          ],
          "line": 4400
        },
        "resolved": true,
        "details": {
          "function_name": "check_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1344-1345",
          "snippet": "static inline int check_object(struct kmem_cache *s, struct page *page,\n\t\t\tvoid *object, u8 val) { return 1; }",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline int check_object(struct kmem_cache *s, struct page *page,\n\t\t\tvoid *object, u8 val) { return 1; }"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "slab_index(p, s, addr)",
            "map"
          ],
          "line": 4399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_index",
          "args": [
            "p",
            "s",
            "addr"
          ],
          "line": 4399
        },
        "resolved": true,
        "details": {
          "function_name": "slab_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "312-315",
          "snippet": "static inline unsigned int slab_index(void *p, struct kmem_cache *s, void *addr)\n{\n\treturn (p - addr) / s->size;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline unsigned int slab_index(void *p, struct kmem_cache *s, void *addr)\n{\n\treturn (p - addr) / s->size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_object",
          "args": [
            "p",
            "s",
            "addr",
            "page->objects"
          ],
          "line": 4398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "slab_index(p, s, addr)",
            "map"
          ],
          "line": 4393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_object",
          "args": [
            "p",
            "s",
            "addr",
            "page->objects"
          ],
          "line": 4392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_map",
          "args": [
            "s",
            "page",
            "map"
          ],
          "line": 4391
        },
        "resolved": true,
        "details": {
          "function_name": "get_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "443-450",
          "snippet": "static void get_map(struct kmem_cache *s, struct page *page, unsigned long *map)\n{\n\tvoid *p;\n\tvoid *addr = page_address(page);\n\n\tfor (p = page->freelist; p; p = get_freepointer(s, p))\n\t\tset_bit(slab_index(p, s, addr), map);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void get_map(struct kmem_cache *s, struct page *page, unsigned long *map)\n{\n\tvoid *p;\n\tvoid *addr = page_address(page);\n\n\tfor (p = page->freelist; p; p = get_freepointer(s, p))\n\t\tset_bit(slab_index(p, s, addr), map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_zero",
          "args": [
            "map",
            "page->objects"
          ],
          "line": 4389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "on_freelist",
          "args": [
            "s",
            "page",
            "NULL"
          ],
          "line": 4385
        },
        "resolved": true,
        "details": {
          "function_name": "on_freelist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "942-989",
          "snippet": "static int on_freelist(struct kmem_cache *s, struct page *page, void *search)\n{\n\tint nr = 0;\n\tvoid *fp;\n\tvoid *object = NULL;\n\tint max_objects;\n\n\tfp = page->freelist;\n\twhile (fp && nr <= page->objects) {\n\t\tif (fp == search)\n\t\t\treturn 1;\n\t\tif (!check_valid_pointer(s, page, fp)) {\n\t\t\tif (object) {\n\t\t\t\tobject_err(s, page, object,\n\t\t\t\t\t\"Freechain corrupt\");\n\t\t\t\tset_freepointer(s, object, NULL);\n\t\t\t} else {\n\t\t\t\tslab_err(s, page, \"Freepointer corrupt\");\n\t\t\t\tpage->freelist = NULL;\n\t\t\t\tpage->inuse = page->objects;\n\t\t\t\tslab_fix(s, \"Freelist cleared\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tobject = fp;\n\t\tfp = get_freepointer(s, object);\n\t\tnr++;\n\t}\n\n\tmax_objects = order_objects(compound_order(page), s->size);\n\tif (max_objects > MAX_OBJS_PER_PAGE)\n\t\tmax_objects = MAX_OBJS_PER_PAGE;\n\n\tif (page->objects != max_objects) {\n\t\tslab_err(s, page, \"Wrong number of objects. Found %d but should be %d\",\n\t\t\t page->objects, max_objects);\n\t\tpage->objects = max_objects;\n\t\tslab_fix(s, \"Number of objects adjusted.\");\n\t}\n\tif (page->inuse != page->objects - nr) {\n\t\tslab_err(s, page, \"Wrong object count. Counter is %d but counted were %d\",\n\t\t\t page->inuse, page->objects - nr);\n\t\tpage->inuse = page->objects - nr;\n\t\tslab_fix(s, \"Object count adjusted.\");\n\t}\n\treturn search == NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define MAX_OBJS_PER_PAGE\t32767 /* since page.objects is u15 */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define MAX_OBJS_PER_PAGE\t32767 /* since page.objects is u15 */\n\nstatic int on_freelist(struct kmem_cache *s, struct page *page, void *search)\n{\n\tint nr = 0;\n\tvoid *fp;\n\tvoid *object = NULL;\n\tint max_objects;\n\n\tfp = page->freelist;\n\twhile (fp && nr <= page->objects) {\n\t\tif (fp == search)\n\t\t\treturn 1;\n\t\tif (!check_valid_pointer(s, page, fp)) {\n\t\t\tif (object) {\n\t\t\t\tobject_err(s, page, object,\n\t\t\t\t\t\"Freechain corrupt\");\n\t\t\t\tset_freepointer(s, object, NULL);\n\t\t\t} else {\n\t\t\t\tslab_err(s, page, \"Freepointer corrupt\");\n\t\t\t\tpage->freelist = NULL;\n\t\t\t\tpage->inuse = page->objects;\n\t\t\t\tslab_fix(s, \"Freelist cleared\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tobject = fp;\n\t\tfp = get_freepointer(s, object);\n\t\tnr++;\n\t}\n\n\tmax_objects = order_objects(compound_order(page), s->size);\n\tif (max_objects > MAX_OBJS_PER_PAGE)\n\t\tmax_objects = MAX_OBJS_PER_PAGE;\n\n\tif (page->objects != max_objects) {\n\t\tslab_err(s, page, \"Wrong number of objects. Found %d but should be %d\",\n\t\t\t page->objects, max_objects);\n\t\tpage->objects = max_objects;\n\t\tslab_fix(s, \"Number of objects adjusted.\");\n\t}\n\tif (page->inuse != page->objects - nr) {\n\t\tslab_err(s, page, \"Wrong object count. Counter is %d but counted were %d\",\n\t\t\t page->inuse, page->objects - nr);\n\t\tpage->inuse = page->objects - nr;\n\t\tslab_fix(s, \"Object count adjusted.\");\n\t}\n\treturn search == NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_slab",
          "args": [
            "s",
            "page"
          ],
          "line": 4384
        },
        "resolved": true,
        "details": {
          "function_name": "check_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "911-936",
          "snippet": "static int check_slab(struct kmem_cache *s, struct page *page)\n{\n\tint maxobj;\n\n\tVM_BUG_ON(!irqs_disabled());\n\n\tif (!PageSlab(page)) {\n\t\tslab_err(s, page, \"Not a valid slab page\");\n\t\treturn 0;\n\t}\n\n\tmaxobj = order_objects(compound_order(page), s->size);\n\tif (page->objects > maxobj) {\n\t\tslab_err(s, page, \"objects %u > max %u\",\n\t\t\tpage->objects, maxobj);\n\t\treturn 0;\n\t}\n\tif (page->inuse > page->objects) {\n\t\tslab_err(s, page, \"inuse %u > max %u\",\n\t\t\tpage->inuse, page->objects);\n\t\treturn 0;\n\t}\n\t/* Slab_pad_check fixes things up after itself */\n\tslab_pad_check(s, page);\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic int check_slab(struct kmem_cache *s, struct page *page)\n{\n\tint maxobj;\n\n\tVM_BUG_ON(!irqs_disabled());\n\n\tif (!PageSlab(page)) {\n\t\tslab_err(s, page, \"Not a valid slab page\");\n\t\treturn 0;\n\t}\n\n\tmaxobj = order_objects(compound_order(page), s->size);\n\tif (page->objects > maxobj) {\n\t\tslab_err(s, page, \"objects %u > max %u\",\n\t\t\tpage->objects, maxobj);\n\t\treturn 0;\n\t}\n\tif (page->inuse > page->objects) {\n\t\tslab_err(s, page, \"inuse %u > max %u\",\n\t\t\tpage->inuse, page->objects);\n\t\treturn 0;\n\t}\n\t/* Slab_pad_check fixes things up after itself */\n\tslab_pad_check(s, page);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 4382
        },
        "resolved": true,
        "details": {
          "function_name": "page_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "409-434",
          "snippet": "void *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic int validate_slab(struct kmem_cache *s, struct page *page,\n\t\t\t\t\t\tunsigned long *map)\n{\n\tvoid *p;\n\tvoid *addr = page_address(page);\n\n\tif (!check_slab(s, page) ||\n\t\t\t!on_freelist(s, page, NULL))\n\t\treturn 0;\n\n\t/* Now we know that a valid freelist exists */\n\tbitmap_zero(map, page->objects);\n\n\tget_map(s, page, map);\n\tfor_each_object(p, s, addr, page->objects) {\n\t\tif (test_bit(slab_index(p, s, addr), map))\n\t\t\tif (!check_object(s, page, p, SLUB_RED_INACTIVE))\n\t\t\t\treturn 0;\n\t}\n\n\tfor_each_object(p, s, addr, page->objects)\n\t\tif (!test_bit(slab_index(p, s, addr), map))\n\t\t\tif (!check_object(s, page, p, SLUB_RED_ACTIVE))\n\t\t\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "count_total",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "4371-4374",
    "snippet": "static int count_total(struct page *page)\n{\n\treturn page->objects;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic int count_total(struct page *page)\n{\n\treturn page->objects;\n}"
  },
  {
    "function_name": "count_inuse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "4366-4369",
    "snippet": "static int count_inuse(struct page *page)\n{\n\treturn page->inuse;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic int count_inuse(struct page *page)\n{\n\treturn page->inuse;\n}"
  },
  {
    "function_name": "__kmalloc_node_track_caller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "4335-4362",
    "snippet": "void *__kmalloc_node_track_caller(size_t size, gfp_t gfpflags,\n\t\t\t\t\tint node, unsigned long caller)\n{\n\tstruct kmem_cache *s;\n\tvoid *ret;\n\n\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE)) {\n\t\tret = kmalloc_large_node(size, gfpflags, node);\n\n\t\ttrace_kmalloc_node(caller, ret,\n\t\t\t\t   size, PAGE_SIZE << get_order(size),\n\t\t\t\t   gfpflags, node);\n\n\t\treturn ret;\n\t}\n\n\ts = kmalloc_slab(size, gfpflags);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(s)))\n\t\treturn s;\n\n\tret = slab_alloc_node(s, gfpflags, node, caller);\n\n\t/* Honor the call site pointer we received. */\n\ttrace_kmalloc_node(caller, ret, size, s->size, gfpflags, node);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kmalloc_node",
          "args": [
            "caller",
            "ret",
            "size",
            "s->size",
            "gfpflags",
            "node"
          ],
          "line": 4359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_alloc_node",
          "args": [
            "s",
            "gfpflags",
            "node",
            "caller"
          ],
          "line": 4356
        },
        "resolved": true,
        "details": {
          "function_name": "slab_alloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2662-2747",
          "snippet": "static __always_inline void *slab_alloc_node(struct kmem_cache *s,\n\t\tgfp_t gfpflags, int node, unsigned long addr)\n{\n\tvoid *object;\n\tstruct kmem_cache_cpu *c;\n\tstruct page *page;\n\tunsigned long tid;\n\n\ts = slab_pre_alloc_hook(s, gfpflags);\n\tif (!s)\n\t\treturn NULL;\nredo:\n\t/*\n\t * Must read kmem_cache cpu data via this cpu ptr. Preemption is\n\t * enabled. We may switch back and forth between cpus while\n\t * reading from one cpu area. That does not matter as long\n\t * as we end up on the original cpu again when doing the cmpxchg.\n\t *\n\t * We should guarantee that tid and kmem_cache are retrieved on\n\t * the same cpu. It could be different if CONFIG_PREEMPT so we need\n\t * to check if it is matched or not.\n\t */\n\tdo {\n\t\ttid = this_cpu_read(s->cpu_slab->tid);\n\t\tc = raw_cpu_ptr(s->cpu_slab);\n\t} while (IS_ENABLED(CONFIG_PREEMPT) &&\n\t\t unlikely(tid != READ_ONCE(c->tid)));\n\n\t/*\n\t * Irqless object alloc/free algorithm used here depends on sequence\n\t * of fetching cpu_slab's data. tid should be fetched before anything\n\t * on c to guarantee that object and page associated with previous tid\n\t * won't be used with current tid. If we fetch tid first, object and\n\t * page could be one associated with next tid and our alloc/free\n\t * request will be failed. In this case, we will retry. So, no problem.\n\t */\n\tbarrier();\n\n\t/*\n\t * The transaction ids are globally unique per cpu and per operation on\n\t * a per cpu queue. Thus they can be guarantee that the cmpxchg_double\n\t * occurs on the right processor and that there was no operation on the\n\t * linked list in between.\n\t */\n\n\tobject = c->freelist;\n\tpage = c->page;\n\tif (unlikely(!object || !node_match(page, node))) {\n\t\tobject = __slab_alloc(s, gfpflags, node, addr, c);\n\t\tstat(s, ALLOC_SLOWPATH);\n\t} else {\n\t\tvoid *next_object = get_freepointer_safe(s, object);\n\n\t\t/*\n\t\t * The cmpxchg will only match if there was no additional\n\t\t * operation and if we are on the right processor.\n\t\t *\n\t\t * The cmpxchg does the following atomically (without lock\n\t\t * semantics!)\n\t\t * 1. Relocate first pointer to the current per cpu area.\n\t\t * 2. Verify that tid and freelist have not been changed\n\t\t * 3. If they were not changed replace tid and freelist\n\t\t *\n\t\t * Since this is without lock semantics the protection is only\n\t\t * against code executing on this cpu *not* from access by\n\t\t * other cpus.\n\t\t */\n\t\tif (unlikely(!this_cpu_cmpxchg_double(\n\t\t\t\ts->cpu_slab->freelist, s->cpu_slab->tid,\n\t\t\t\tobject, tid,\n\t\t\t\tnext_object, next_tid(tid)))) {\n\n\t\t\tnote_cmpxchg_failure(\"slab_alloc\", s, tid);\n\t\t\tgoto redo;\n\t\t}\n\t\tprefetch_freepointer(s, next_object);\n\t\tstat(s, ALLOC_FASTPATH);\n\t}\n\n\tif (unlikely(gfpflags & __GFP_ZERO) && object)\n\t\tmemset(object, 0, s->object_size);\n\n\tslab_post_alloc_hook(s, gfpflags, 1, &object);\n\n\treturn object;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);\n\nstatic __always_inline void *slab_alloc_node(struct kmem_cache *s,\n\t\tgfp_t gfpflags, int node, unsigned long addr)\n{\n\tvoid *object;\n\tstruct kmem_cache_cpu *c;\n\tstruct page *page;\n\tunsigned long tid;\n\n\ts = slab_pre_alloc_hook(s, gfpflags);\n\tif (!s)\n\t\treturn NULL;\nredo:\n\t/*\n\t * Must read kmem_cache cpu data via this cpu ptr. Preemption is\n\t * enabled. We may switch back and forth between cpus while\n\t * reading from one cpu area. That does not matter as long\n\t * as we end up on the original cpu again when doing the cmpxchg.\n\t *\n\t * We should guarantee that tid and kmem_cache are retrieved on\n\t * the same cpu. It could be different if CONFIG_PREEMPT so we need\n\t * to check if it is matched or not.\n\t */\n\tdo {\n\t\ttid = this_cpu_read(s->cpu_slab->tid);\n\t\tc = raw_cpu_ptr(s->cpu_slab);\n\t} while (IS_ENABLED(CONFIG_PREEMPT) &&\n\t\t unlikely(tid != READ_ONCE(c->tid)));\n\n\t/*\n\t * Irqless object alloc/free algorithm used here depends on sequence\n\t * of fetching cpu_slab's data. tid should be fetched before anything\n\t * on c to guarantee that object and page associated with previous tid\n\t * won't be used with current tid. If we fetch tid first, object and\n\t * page could be one associated with next tid and our alloc/free\n\t * request will be failed. In this case, we will retry. So, no problem.\n\t */\n\tbarrier();\n\n\t/*\n\t * The transaction ids are globally unique per cpu and per operation on\n\t * a per cpu queue. Thus they can be guarantee that the cmpxchg_double\n\t * occurs on the right processor and that there was no operation on the\n\t * linked list in between.\n\t */\n\n\tobject = c->freelist;\n\tpage = c->page;\n\tif (unlikely(!object || !node_match(page, node))) {\n\t\tobject = __slab_alloc(s, gfpflags, node, addr, c);\n\t\tstat(s, ALLOC_SLOWPATH);\n\t} else {\n\t\tvoid *next_object = get_freepointer_safe(s, object);\n\n\t\t/*\n\t\t * The cmpxchg will only match if there was no additional\n\t\t * operation and if we are on the right processor.\n\t\t *\n\t\t * The cmpxchg does the following atomically (without lock\n\t\t * semantics!)\n\t\t * 1. Relocate first pointer to the current per cpu area.\n\t\t * 2. Verify that tid and freelist have not been changed\n\t\t * 3. If they were not changed replace tid and freelist\n\t\t *\n\t\t * Since this is without lock semantics the protection is only\n\t\t * against code executing on this cpu *not* from access by\n\t\t * other cpus.\n\t\t */\n\t\tif (unlikely(!this_cpu_cmpxchg_double(\n\t\t\t\ts->cpu_slab->freelist, s->cpu_slab->tid,\n\t\t\t\tobject, tid,\n\t\t\t\tnext_object, next_tid(tid)))) {\n\n\t\t\tnote_cmpxchg_failure(\"slab_alloc\", s, tid);\n\t\t\tgoto redo;\n\t\t}\n\t\tprefetch_freepointer(s, next_object);\n\t\tstat(s, ALLOC_FASTPATH);\n\t}\n\n\tif (unlikely(gfpflags & __GFP_ZERO) && object)\n\t\tmemset(object, 0, s->object_size);\n\n\tslab_post_alloc_hook(s, gfpflags, 1, &object);\n\n\treturn object;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ZERO_OR_NULL_PTR(s)"
          ],
          "line": 4353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ZERO_OR_NULL_PTR",
          "args": [
            "s"
          ],
          "line": 4353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_slab",
          "args": [
            "size",
            "gfpflags"
          ],
          "line": 4351
        },
        "resolved": true,
        "details": {
          "function_name": "kmalloc_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "1022-1040",
          "snippet": "struct kmem_cache *kmalloc_slab(size_t size, gfp_t flags)\n{\n\tunsigned int index;\n\n\tif (size <= 192) {\n\t\tif (!size)\n\t\t\treturn ZERO_SIZE_PTR;\n\n\t\tindex = size_index[size_index_elem(size)];\n\t} else {\n\t\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE)) {\n\t\t\tWARN_ON(1);\n\t\t\treturn NULL;\n\t\t}\n\t\tindex = fls(size - 1);\n\t}\n\n\treturn kmalloc_caches[kmalloc_type(flags)][index];\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstruct kmem_cache *kmalloc_slab(size_t size, gfp_t flags)\n{\n\tunsigned int index;\n\n\tif (size <= 192) {\n\t\tif (!size)\n\t\t\treturn ZERO_SIZE_PTR;\n\n\t\tindex = size_index[size_index_elem(size)];\n\t} else {\n\t\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE)) {\n\t\t\tWARN_ON(1);\n\t\t\treturn NULL;\n\t\t}\n\t\tindex = fls(size - 1);\n\t}\n\n\treturn kmalloc_caches[kmalloc_type(flags)][index];\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kmalloc_node",
          "args": [
            "caller",
            "ret",
            "size",
            "PAGE_SIZE << get_order(size)",
            "gfpflags",
            "node"
          ],
          "line": 4344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "size"
          ],
          "line": 4345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_large_node",
          "args": [
            "size",
            "gfpflags",
            "node"
          ],
          "line": 4342
        },
        "resolved": true,
        "details": {
          "function_name": "kmalloc_large_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "3794-3806",
          "snippet": "static void *kmalloc_large_node(size_t size, gfp_t flags, int node)\n{\n\tstruct page *page;\n\tvoid *ptr = NULL;\n\n\tflags |= __GFP_COMP;\n\tpage = alloc_pages_node(node, flags, get_order(size));\n\tif (page)\n\t\tptr = page_address(page);\n\n\tkmalloc_large_node_hook(ptr, size, flags);\n\treturn ptr;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void *kmalloc_large_node(size_t size, gfp_t flags, int node)\n{\n\tstruct page *page;\n\tvoid *ptr = NULL;\n\n\tflags |= __GFP_COMP;\n\tpage = alloc_pages_node(node, flags, get_order(size));\n\tif (page)\n\t\tptr = page_address(page);\n\n\tkmalloc_large_node_hook(ptr, size, flags);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "size > KMALLOC_MAX_CACHE_SIZE"
          ],
          "line": 4341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);\n\nvoid *__kmalloc_node_track_caller(size_t size, gfp_t gfpflags,\n\t\t\t\t\tint node, unsigned long caller)\n{\n\tstruct kmem_cache *s;\n\tvoid *ret;\n\n\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE)) {\n\t\tret = kmalloc_large_node(size, gfpflags, node);\n\n\t\ttrace_kmalloc_node(caller, ret,\n\t\t\t\t   size, PAGE_SIZE << get_order(size),\n\t\t\t\t   gfpflags, node);\n\n\t\treturn ret;\n\t}\n\n\ts = kmalloc_slab(size, gfpflags);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(s)))\n\t\treturn s;\n\n\tret = slab_alloc_node(s, gfpflags, node, caller);\n\n\t/* Honor the call site pointer we received. */\n\ttrace_kmalloc_node(caller, ret, size, s->size, gfpflags, node);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__kmalloc_track_caller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "4313-4332",
    "snippet": "void *__kmalloc_track_caller(size_t size, gfp_t gfpflags, unsigned long caller)\n{\n\tstruct kmem_cache *s;\n\tvoid *ret;\n\n\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE))\n\t\treturn kmalloc_large(size, gfpflags);\n\n\ts = kmalloc_slab(size, gfpflags);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(s)))\n\t\treturn s;\n\n\tret = slab_alloc(s, gfpflags, caller);\n\n\t/* Honor the call site pointer we received. */\n\ttrace_kmalloc(caller, ret, size, s->size, gfpflags);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kmalloc",
          "args": [
            "caller",
            "ret",
            "size",
            "s->size",
            "gfpflags"
          ],
          "line": 4329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_alloc",
          "args": [
            "s",
            "gfpflags",
            "caller"
          ],
          "line": 4326
        },
        "resolved": true,
        "details": {
          "function_name": "slab_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2749-2753",
          "snippet": "static __always_inline void *slab_alloc(struct kmem_cache *s,\n\t\tgfp_t gfpflags, unsigned long addr)\n{\n\treturn slab_alloc_node(s, gfpflags, NUMA_NO_NODE, addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);\n\nstatic __always_inline void *slab_alloc(struct kmem_cache *s,\n\t\tgfp_t gfpflags, unsigned long addr)\n{\n\treturn slab_alloc_node(s, gfpflags, NUMA_NO_NODE, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ZERO_OR_NULL_PTR(s)"
          ],
          "line": 4323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ZERO_OR_NULL_PTR",
          "args": [
            "s"
          ],
          "line": 4323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_slab",
          "args": [
            "size",
            "gfpflags"
          ],
          "line": 4321
        },
        "resolved": true,
        "details": {
          "function_name": "kmalloc_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "1022-1040",
          "snippet": "struct kmem_cache *kmalloc_slab(size_t size, gfp_t flags)\n{\n\tunsigned int index;\n\n\tif (size <= 192) {\n\t\tif (!size)\n\t\t\treturn ZERO_SIZE_PTR;\n\n\t\tindex = size_index[size_index_elem(size)];\n\t} else {\n\t\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE)) {\n\t\t\tWARN_ON(1);\n\t\t\treturn NULL;\n\t\t}\n\t\tindex = fls(size - 1);\n\t}\n\n\treturn kmalloc_caches[kmalloc_type(flags)][index];\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstruct kmem_cache *kmalloc_slab(size_t size, gfp_t flags)\n{\n\tunsigned int index;\n\n\tif (size <= 192) {\n\t\tif (!size)\n\t\t\treturn ZERO_SIZE_PTR;\n\n\t\tindex = size_index[size_index_elem(size)];\n\t} else {\n\t\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE)) {\n\t\t\tWARN_ON(1);\n\t\t\treturn NULL;\n\t\t}\n\t\tindex = fls(size - 1);\n\t}\n\n\treturn kmalloc_caches[kmalloc_type(flags)][index];\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc_large",
          "args": [
            "size",
            "gfpflags"
          ],
          "line": 4319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "size > KMALLOC_MAX_CACHE_SIZE"
          ],
          "line": 4318
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);\n\nvoid *__kmalloc_track_caller(size_t size, gfp_t gfpflags, unsigned long caller)\n{\n\tstruct kmem_cache *s;\n\tvoid *ret;\n\n\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE))\n\t\treturn kmalloc_large(size, gfpflags);\n\n\ts = kmalloc_slab(size, gfpflags);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(s)))\n\t\treturn s;\n\n\tret = slab_alloc(s, gfpflags, caller);\n\n\t/* Honor the call site pointer we received. */\n\ttrace_kmalloc(caller, ret, size, s->size, gfpflags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__kmem_cache_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "4293-4311",
    "snippet": "int __kmem_cache_create(struct kmem_cache *s, slab_flags_t flags)\n{\n\tint err;\n\n\terr = kmem_cache_open(s, flags);\n\tif (err)\n\t\treturn err;\n\n\t/* Mutex is not taken during early boot */\n\tif (slab_state <= UP)\n\t\treturn 0;\n\n\tmemcg_propagate_slab_attrs(s);\n\terr = sysfs_slab_add(s);\n\tif (err)\n\t\t__kmem_cache_release(s);\n\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__kmem_cache_release",
          "args": [
            "s"
          ],
          "line": 4308
        },
        "resolved": true,
        "details": {
          "function_name": "__kmem_cache_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "3398-3403",
          "snippet": "void __kmem_cache_release(struct kmem_cache *s)\n{\n\tcache_random_seq_destroy(s);\n\tfree_percpu(s->cpu_slab);\n\tfree_kmem_cache_nodes(s);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid __kmem_cache_release(struct kmem_cache *s)\n{\n\tcache_random_seq_destroy(s);\n\tfree_percpu(s->cpu_slab);\n\tfree_kmem_cache_nodes(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysfs_slab_add",
          "args": [
            "s"
          ],
          "line": 4306
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_slab_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "5705-5770",
          "snippet": "static int sysfs_slab_add(struct kmem_cache *s)\n{\n\tint err;\n\tconst char *name;\n\tstruct kset *kset = cache_kset(s);\n\tint unmergeable = slab_unmergeable(s);\n\n\tINIT_WORK(&s->kobj_remove_work, sysfs_slab_remove_workfn);\n\n\tif (!kset) {\n\t\tkobject_init(&s->kobj, &slab_ktype);\n\t\treturn 0;\n\t}\n\n\tif (!unmergeable && disable_higher_order_debug &&\n\t\t\t(slub_debug & DEBUG_METADATA_FLAGS))\n\t\tunmergeable = 1;\n\n\tif (unmergeable) {\n\t\t/*\n\t\t * Slabcache can never be merged so we can use the name proper.\n\t\t * This is typically the case for debug situations. In that\n\t\t * case we can catch duplicate names easily.\n\t\t */\n\t\tsysfs_remove_link(&slab_kset->kobj, s->name);\n\t\tname = s->name;\n\t} else {\n\t\t/*\n\t\t * Create a unique name for the slab as a target\n\t\t * for the symlinks.\n\t\t */\n\t\tname = create_unique_id(s);\n\t}\n\n\ts->kobj.kset = kset;\n\terr = kobject_init_and_add(&s->kobj, &slab_ktype, NULL, \"%s\", name);\n\tif (err)\n\t\tgoto out;\n\n\terr = sysfs_create_group(&s->kobj, &slab_attr_group);\n\tif (err)\n\t\tgoto out_del_kobj;\n\n#ifdef CONFIG_MEMCG\n\tif (is_root_cache(s) && memcg_sysfs_enabled) {\n\t\ts->memcg_kset = kset_create_and_add(\"cgroup\", NULL, &s->kobj);\n\t\tif (!s->memcg_kset) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_del_kobj;\n\t\t}\n\t}\n#endif\n\n\tkobject_uevent(&s->kobj, KOBJ_ADD);\n\tif (!unmergeable) {\n\t\t/* Setup first alias */\n\t\tsysfs_slab_alias(s, s->name);\n\t}\nout:\n\tif (!unmergeable)\n\t\tkfree(name);\n\treturn err;\nout_del_kobj:\n\tkobject_del(&s->kobj);\n\tgoto out;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define disable_higher_order_debug 0",
            "#define slub_debug 0",
            "#define DEBUG_METADATA_FLAGS (SLAB_RED_ZONE | SLAB_POISON | SLAB_STORE_USER)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define disable_higher_order_debug 0\n#define slub_debug 0\n#define DEBUG_METADATA_FLAGS (SLAB_RED_ZONE | SLAB_POISON | SLAB_STORE_USER)\n\nstatic int sysfs_slab_add(struct kmem_cache *s)\n{\n\tint err;\n\tconst char *name;\n\tstruct kset *kset = cache_kset(s);\n\tint unmergeable = slab_unmergeable(s);\n\n\tINIT_WORK(&s->kobj_remove_work, sysfs_slab_remove_workfn);\n\n\tif (!kset) {\n\t\tkobject_init(&s->kobj, &slab_ktype);\n\t\treturn 0;\n\t}\n\n\tif (!unmergeable && disable_higher_order_debug &&\n\t\t\t(slub_debug & DEBUG_METADATA_FLAGS))\n\t\tunmergeable = 1;\n\n\tif (unmergeable) {\n\t\t/*\n\t\t * Slabcache can never be merged so we can use the name proper.\n\t\t * This is typically the case for debug situations. In that\n\t\t * case we can catch duplicate names easily.\n\t\t */\n\t\tsysfs_remove_link(&slab_kset->kobj, s->name);\n\t\tname = s->name;\n\t} else {\n\t\t/*\n\t\t * Create a unique name for the slab as a target\n\t\t * for the symlinks.\n\t\t */\n\t\tname = create_unique_id(s);\n\t}\n\n\ts->kobj.kset = kset;\n\terr = kobject_init_and_add(&s->kobj, &slab_ktype, NULL, \"%s\", name);\n\tif (err)\n\t\tgoto out;\n\n\terr = sysfs_create_group(&s->kobj, &slab_attr_group);\n\tif (err)\n\t\tgoto out_del_kobj;\n\n#ifdef CONFIG_MEMCG\n\tif (is_root_cache(s) && memcg_sysfs_enabled) {\n\t\ts->memcg_kset = kset_create_and_add(\"cgroup\", NULL, &s->kobj);\n\t\tif (!s->memcg_kset) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_del_kobj;\n\t\t}\n\t}\n#endif\n\n\tkobject_uevent(&s->kobj, KOBJ_ADD);\n\tif (!unmergeable) {\n\t\t/* Setup first alias */\n\t\tsysfs_slab_alias(s, s->name);\n\t}\nout:\n\tif (!unmergeable)\n\t\tkfree(name);\n\treturn err;\nout_del_kobj:\n\tkobject_del(&s->kobj);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_propagate_slab_attrs",
          "args": [
            "s"
          ],
          "line": 4305
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_propagate_slab_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "5549-5605",
          "snippet": "static void memcg_propagate_slab_attrs(struct kmem_cache *s)\n{\n#ifdef CONFIG_MEMCG\n\tint i;\n\tchar *buffer = NULL;\n\tstruct kmem_cache *root_cache;\n\n\tif (is_root_cache(s))\n\t\treturn;\n\n\troot_cache = s->memcg_params.root_cache;\n\n\t/*\n\t * This mean this cache had no attribute written. Therefore, no point\n\t * in copying default values around\n\t */\n\tif (!root_cache->max_attr_size)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(slab_attrs); i++) {\n\t\tchar mbuf[64];\n\t\tchar *buf;\n\t\tstruct slab_attribute *attr = to_slab_attr(slab_attrs[i]);\n\t\tssize_t len;\n\n\t\tif (!attr || !attr->store || !attr->show)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * It is really bad that we have to allocate here, so we will\n\t\t * do it only as a fallback. If we actually allocate, though,\n\t\t * we can just use the allocated buffer until the end.\n\t\t *\n\t\t * Most of the slub attributes will tend to be very small in\n\t\t * size, but sysfs allows buffers up to a page, so they can\n\t\t * theoretically happen.\n\t\t */\n\t\tif (buffer)\n\t\t\tbuf = buffer;\n\t\telse if (root_cache->max_attr_size < ARRAY_SIZE(mbuf))\n\t\t\tbuf = mbuf;\n\t\telse {\n\t\t\tbuffer = (char *) get_zeroed_page(GFP_KERNEL);\n\t\t\tif (WARN_ON(!buffer))\n\t\t\t\tcontinue;\n\t\t\tbuf = buffer;\n\t\t}\n\n\t\tlen = attr->show(root_cache, buf);\n\t\tif (len > 0)\n\t\t\tattr->store(s, buf, len);\n\t}\n\n\tif (buffer)\n\t\tfree_page((unsigned long)buffer);\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void memcg_propagate_slab_attrs(struct kmem_cache *s)\n{\n#ifdef CONFIG_MEMCG\n\tint i;\n\tchar *buffer = NULL;\n\tstruct kmem_cache *root_cache;\n\n\tif (is_root_cache(s))\n\t\treturn;\n\n\troot_cache = s->memcg_params.root_cache;\n\n\t/*\n\t * This mean this cache had no attribute written. Therefore, no point\n\t * in copying default values around\n\t */\n\tif (!root_cache->max_attr_size)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(slab_attrs); i++) {\n\t\tchar mbuf[64];\n\t\tchar *buf;\n\t\tstruct slab_attribute *attr = to_slab_attr(slab_attrs[i]);\n\t\tssize_t len;\n\n\t\tif (!attr || !attr->store || !attr->show)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * It is really bad that we have to allocate here, so we will\n\t\t * do it only as a fallback. If we actually allocate, though,\n\t\t * we can just use the allocated buffer until the end.\n\t\t *\n\t\t * Most of the slub attributes will tend to be very small in\n\t\t * size, but sysfs allows buffers up to a page, so they can\n\t\t * theoretically happen.\n\t\t */\n\t\tif (buffer)\n\t\t\tbuf = buffer;\n\t\telse if (root_cache->max_attr_size < ARRAY_SIZE(mbuf))\n\t\t\tbuf = mbuf;\n\t\telse {\n\t\t\tbuffer = (char *) get_zeroed_page(GFP_KERNEL);\n\t\t\tif (WARN_ON(!buffer))\n\t\t\t\tcontinue;\n\t\t\tbuf = buffer;\n\t\t}\n\n\t\tlen = attr->show(root_cache, buf);\n\t\tif (len > 0)\n\t\t\tattr->store(s, buf, len);\n\t}\n\n\tif (buffer)\n\t\tfree_page((unsigned long)buffer);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_open",
          "args": [
            "s",
            "flags"
          ],
          "line": 4297
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "3594-3654",
          "snippet": "static int kmem_cache_open(struct kmem_cache *s, slab_flags_t flags)\n{\n\ts->flags = kmem_cache_flags(s->size, flags, s->name, s->ctor);\n#ifdef CONFIG_SLAB_FREELIST_HARDENED\n\ts->random = get_random_long();\n#endif\n\n\tif (!calculate_sizes(s, -1))\n\t\tgoto error;\n\tif (disable_higher_order_debug) {\n\t\t/*\n\t\t * Disable debugging flags that store metadata if the min slab\n\t\t * order increased.\n\t\t */\n\t\tif (get_order(s->size) > get_order(s->object_size)) {\n\t\t\ts->flags &= ~DEBUG_METADATA_FLAGS;\n\t\t\ts->offset = 0;\n\t\t\tif (!calculate_sizes(s, -1))\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\n#if defined(CONFIG_HAVE_CMPXCHG_DOUBLE) && \\\n    defined(CONFIG_HAVE_ALIGNED_STRUCT_PAGE)\n\tif (system_has_cmpxchg_double() && (s->flags & SLAB_NO_CMPXCHG) == 0)\n\t\t/* Enable fast mode */\n\t\ts->flags |= __CMPXCHG_DOUBLE;\n#endif\n\n\t/*\n\t * The larger the object size is, the more pages we want on the partial\n\t * list to avoid pounding the page allocator excessively.\n\t */\n\tset_min_partial(s, ilog2(s->size) / 2);\n\n\tset_cpu_partial(s);\n\n#ifdef CONFIG_NUMA\n\ts->remote_node_defrag_ratio = 1000;\n#endif\n\n\t/* Initialize the pre-computed randomized freelist if slab is up */\n\tif (slab_state >= UP) {\n\t\tif (init_cache_random_seq(s))\n\t\t\tgoto error;\n\t}\n\n\tif (!init_kmem_cache_nodes(s))\n\t\tgoto error;\n\n\tif (alloc_kmem_cache_cpus(s))\n\t\treturn 0;\n\n\tfree_kmem_cache_nodes(s);\nerror:\n\tif (flags & SLAB_PANIC)\n\t\tpanic(\"Cannot create slab %s size=%u realsize=%u order=%u offset=%u flags=%lx\\n\",\n\t\t      s->name, s->size, s->size,\n\t\t      oo_order(s->oo), s->offset, (unsigned long)flags);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define disable_higher_order_debug 0",
            "#define __CMPXCHG_DOUBLE\t((slab_flags_t __force)0x40000000U)",
            "#define DEBUG_METADATA_FLAGS (SLAB_RED_ZONE | SLAB_POISON | SLAB_STORE_USER)",
            "#define SLAB_NO_CMPXCHG (SLAB_CONSISTENCY_CHECKS | SLAB_STORE_USER | \\\n\t\t\t\tSLAB_TRACE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define disable_higher_order_debug 0\n#define __CMPXCHG_DOUBLE\t((slab_flags_t __force)0x40000000U)\n#define DEBUG_METADATA_FLAGS (SLAB_RED_ZONE | SLAB_POISON | SLAB_STORE_USER)\n#define SLAB_NO_CMPXCHG (SLAB_CONSISTENCY_CHECKS | SLAB_STORE_USER | \\\n\t\t\t\tSLAB_TRACE)\n\nstatic int kmem_cache_open(struct kmem_cache *s, slab_flags_t flags)\n{\n\ts->flags = kmem_cache_flags(s->size, flags, s->name, s->ctor);\n#ifdef CONFIG_SLAB_FREELIST_HARDENED\n\ts->random = get_random_long();\n#endif\n\n\tif (!calculate_sizes(s, -1))\n\t\tgoto error;\n\tif (disable_higher_order_debug) {\n\t\t/*\n\t\t * Disable debugging flags that store metadata if the min slab\n\t\t * order increased.\n\t\t */\n\t\tif (get_order(s->size) > get_order(s->object_size)) {\n\t\t\ts->flags &= ~DEBUG_METADATA_FLAGS;\n\t\t\ts->offset = 0;\n\t\t\tif (!calculate_sizes(s, -1))\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\n#if defined(CONFIG_HAVE_CMPXCHG_DOUBLE) && \\\n    defined(CONFIG_HAVE_ALIGNED_STRUCT_PAGE)\n\tif (system_has_cmpxchg_double() && (s->flags & SLAB_NO_CMPXCHG) == 0)\n\t\t/* Enable fast mode */\n\t\ts->flags |= __CMPXCHG_DOUBLE;\n#endif\n\n\t/*\n\t * The larger the object size is, the more pages we want on the partial\n\t * list to avoid pounding the page allocator excessively.\n\t */\n\tset_min_partial(s, ilog2(s->size) / 2);\n\n\tset_cpu_partial(s);\n\n#ifdef CONFIG_NUMA\n\ts->remote_node_defrag_ratio = 1000;\n#endif\n\n\t/* Initialize the pre-computed randomized freelist if slab is up */\n\tif (slab_state >= UP) {\n\t\tif (init_cache_random_seq(s))\n\t\t\tgoto error;\n\t}\n\n\tif (!init_kmem_cache_nodes(s))\n\t\tgoto error;\n\n\tif (alloc_kmem_cache_cpus(s))\n\t\treturn 0;\n\n\tfree_kmem_cache_nodes(s);\nerror:\n\tif (flags & SLAB_PANIC)\n\t\tpanic(\"Cannot create slab %s size=%u realsize=%u order=%u offset=%u flags=%lx\\n\",\n\t\t      s->name, s->size, s->size,\n\t\t      oo_order(s->oo), s->offset, (unsigned long)flags);\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nint __kmem_cache_create(struct kmem_cache *s, slab_flags_t flags)\n{\n\tint err;\n\n\terr = kmem_cache_open(s, flags);\n\tif (err)\n\t\treturn err;\n\n\t/* Mutex is not taken during early boot */\n\tif (slab_state <= UP)\n\t\treturn 0;\n\n\tmemcg_propagate_slab_attrs(s);\n\terr = sysfs_slab_add(s);\n\tif (err)\n\t\t__kmem_cache_release(s);\n\n\treturn err;\n}"
  },
  {
    "function_name": "__kmem_cache_alias",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "4262-4291",
    "snippet": "struct kmem_cache *\n__kmem_cache_alias(const char *name, unsigned int size, unsigned int align,\n\t\t   slab_flags_t flags, void (*ctor)(void *))\n{\n\tstruct kmem_cache *s, *c;\n\n\ts = find_mergeable(size, align, flags, name, ctor);\n\tif (s) {\n\t\ts->refcount++;\n\n\t\t/*\n\t\t * Adjust the object sizes so that we clear\n\t\t * the complete object on kzalloc.\n\t\t */\n\t\ts->object_size = max(s->object_size, size);\n\t\ts->inuse = max(s->inuse, ALIGN(size, sizeof(void *)));\n\n\t\tfor_each_memcg_cache(c, s) {\n\t\t\tc->object_size = s->object_size;\n\t\t\tc->inuse = max(c->inuse, ALIGN(size, sizeof(void *)));\n\t\t}\n\n\t\tif (sysfs_slab_alias(s, name)) {\n\t\t\ts->refcount--;\n\t\t\ts = NULL;\n\t\t}\n\t}\n\n\treturn s;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysfs_slab_alias",
          "args": [
            "s",
            "name"
          ],
          "line": 4284
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_slab_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "5809-5830",
          "snippet": "static int sysfs_slab_alias(struct kmem_cache *s, const char *name)\n{\n\tstruct saved_alias *al;\n\n\tif (slab_state == FULL) {\n\t\t/*\n\t\t * If we have a leftover link then remove it.\n\t\t */\n\t\tsysfs_remove_link(&slab_kset->kobj, name);\n\t\treturn sysfs_create_link(&slab_kset->kobj, &s->kobj, name);\n\t}\n\n\tal = kmalloc(sizeof(struct saved_alias), GFP_KERNEL);\n\tif (!al)\n\t\treturn -ENOMEM;\n\n\tal->s = s;\n\tal->name = name;\n\tal->next = alias_list;\n\talias_list = al;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic int sysfs_slab_alias(struct kmem_cache *s, const char *name)\n{\n\tstruct saved_alias *al;\n\n\tif (slab_state == FULL) {\n\t\t/*\n\t\t * If we have a leftover link then remove it.\n\t\t */\n\t\tsysfs_remove_link(&slab_kset->kobj, name);\n\t\treturn sysfs_create_link(&slab_kset->kobj, &s->kobj, name);\n\t}\n\n\tal = kmalloc(sizeof(struct saved_alias), GFP_KERNEL);\n\tif (!al)\n\t\treturn -ENOMEM;\n\n\tal->s = s;\n\tal->name = name;\n\tal->next = alias_list;\n\talias_list = al;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "c->inuse",
            "ALIGN(size, sizeof(void *))"
          ],
          "line": 4281
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "size",
            "sizeof(void *)"
          ],
          "line": 4281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_memcg_cache",
          "args": [
            "c",
            "s"
          ],
          "line": 4279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "size",
            "sizeof(void *)"
          ],
          "line": 4277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_mergeable",
          "args": [
            "size",
            "align",
            "flags",
            "name",
            "ctor"
          ],
          "line": 4268
        },
        "resolved": true,
        "details": {
          "function_name": "find_mergeable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "316-361",
          "snippet": "struct kmem_cache *find_mergeable(unsigned int size, unsigned int align,\n\t\tslab_flags_t flags, const char *name, void (*ctor)(void *))\n{\n\tstruct kmem_cache *s;\n\n\tif (slab_nomerge)\n\t\treturn NULL;\n\n\tif (ctor)\n\t\treturn NULL;\n\n\tsize = ALIGN(size, sizeof(void *));\n\talign = calculate_alignment(flags, align, size);\n\tsize = ALIGN(size, align);\n\tflags = kmem_cache_flags(size, flags, name, NULL);\n\n\tif (flags & SLAB_NEVER_MERGE)\n\t\treturn NULL;\n\n\tlist_for_each_entry_reverse(s, &slab_root_caches, root_caches_node) {\n\t\tif (slab_unmergeable(s))\n\t\t\tcontinue;\n\n\t\tif (size > s->size)\n\t\t\tcontinue;\n\n\t\tif ((flags & SLAB_MERGE_SAME) != (s->flags & SLAB_MERGE_SAME))\n\t\t\tcontinue;\n\t\t/*\n\t\t * Check if alignment is compatible.\n\t\t * Courtesy of Adrian Drzewiecki\n\t\t */\n\t\tif ((s->size & ~(align - 1)) != s->size)\n\t\t\tcontinue;\n\n\t\tif (s->size - size >= sizeof(void *))\n\t\t\tcontinue;\n\n\t\tif (IS_ENABLED(CONFIG_SLAB) && align &&\n\t\t\t(align > s->align || s->align % align))\n\t\t\tcontinue;\n\n\t\treturn s;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define SLAB_MERGE_SAME (SLAB_RECLAIM_ACCOUNT | SLAB_CACHE_DMA | \\\n\t\t\t SLAB_ACCOUNT)",
            "#define SLAB_NEVER_MERGE (SLAB_RED_ZONE | SLAB_POISON | SLAB_STORE_USER | \\\n\t\tSLAB_TRACE | SLAB_TYPESAFE_BY_RCU | SLAB_NOLEAKTRACE | \\\n\t\tSLAB_FAILSLAB | SLAB_KASAN)"
          ],
          "globals_used": [
            "struct kmem_cache *kmem_cache;",
            "static bool slab_nomerge = !IS_ENABLED(CONFIG_SLAB_MERGE_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\n#define SLAB_MERGE_SAME (SLAB_RECLAIM_ACCOUNT | SLAB_CACHE_DMA | \\\n\t\t\t SLAB_ACCOUNT)\n#define SLAB_NEVER_MERGE (SLAB_RED_ZONE | SLAB_POISON | SLAB_STORE_USER | \\\n\t\tSLAB_TRACE | SLAB_TYPESAFE_BY_RCU | SLAB_NOLEAKTRACE | \\\n\t\tSLAB_FAILSLAB | SLAB_KASAN)\n\nstruct kmem_cache *kmem_cache;\nstatic bool slab_nomerge = !IS_ENABLED(CONFIG_SLAB_MERGE_DEFAULT);\n\nstruct kmem_cache *find_mergeable(unsigned int size, unsigned int align,\n\t\tslab_flags_t flags, const char *name, void (*ctor)(void *))\n{\n\tstruct kmem_cache *s;\n\n\tif (slab_nomerge)\n\t\treturn NULL;\n\n\tif (ctor)\n\t\treturn NULL;\n\n\tsize = ALIGN(size, sizeof(void *));\n\talign = calculate_alignment(flags, align, size);\n\tsize = ALIGN(size, align);\n\tflags = kmem_cache_flags(size, flags, name, NULL);\n\n\tif (flags & SLAB_NEVER_MERGE)\n\t\treturn NULL;\n\n\tlist_for_each_entry_reverse(s, &slab_root_caches, root_caches_node) {\n\t\tif (slab_unmergeable(s))\n\t\t\tcontinue;\n\n\t\tif (size > s->size)\n\t\t\tcontinue;\n\n\t\tif ((flags & SLAB_MERGE_SAME) != (s->flags & SLAB_MERGE_SAME))\n\t\t\tcontinue;\n\t\t/*\n\t\t * Check if alignment is compatible.\n\t\t * Courtesy of Adrian Drzewiecki\n\t\t */\n\t\tif ((s->size & ~(align - 1)) != s->size)\n\t\t\tcontinue;\n\n\t\tif (s->size - size >= sizeof(void *))\n\t\t\tcontinue;\n\n\t\tif (IS_ENABLED(CONFIG_SLAB) && align &&\n\t\t\t(align > s->align || s->align % align))\n\t\t\tcontinue;\n\n\t\treturn s;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstruct kmem_cache *\n__kmem_cache_alias(const char *name, unsigned int size, unsigned int align,\n\t\t   slab_flags_t flags, void (*ctor)(void *))\n{\n\tstruct kmem_cache *s, *c;\n\n\ts = find_mergeable(size, align, flags, name, ctor);\n\tif (s) {\n\t\ts->refcount++;\n\n\t\t/*\n\t\t * Adjust the object sizes so that we clear\n\t\t * the complete object on kzalloc.\n\t\t */\n\t\ts->object_size = max(s->object_size, size);\n\t\ts->inuse = max(s->inuse, ALIGN(size, sizeof(void *)));\n\n\t\tfor_each_memcg_cache(c, s) {\n\t\t\tc->object_size = s->object_size;\n\t\t\tc->inuse = max(c->inuse, ALIGN(size, sizeof(void *)));\n\t\t}\n\n\t\tif (sysfs_slab_alias(s, name)) {\n\t\t\ts->refcount--;\n\t\t\ts = NULL;\n\t\t}\n\t}\n\n\treturn s;\n}"
  },
  {
    "function_name": "kmem_cache_init_late",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "4258-4260",
    "snippet": "void __init kmem_cache_init_late(void)\n{\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid __init kmem_cache_init_late(void)\n{\n}"
  },
  {
    "function_name": "kmem_cache_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "4215-4256",
    "snippet": "void __init kmem_cache_init(void)\n{\n\tstatic __initdata struct kmem_cache boot_kmem_cache,\n\t\tboot_kmem_cache_node;\n\n\tif (debug_guardpage_minorder())\n\t\tslub_max_order = 0;\n\n\tkmem_cache_node = &boot_kmem_cache_node;\n\tkmem_cache = &boot_kmem_cache;\n\n\tcreate_boot_cache(kmem_cache_node, \"kmem_cache_node\",\n\t\tsizeof(struct kmem_cache_node), SLAB_HWCACHE_ALIGN, 0, 0);\n\n\tregister_hotmemory_notifier(&slab_memory_callback_nb);\n\n\t/* Able to allocate the per node structures */\n\tslab_state = PARTIAL;\n\n\tcreate_boot_cache(kmem_cache, \"kmem_cache\",\n\t\t\toffsetof(struct kmem_cache, node) +\n\t\t\t\tnr_node_ids * sizeof(struct kmem_cache_node *),\n\t\t       SLAB_HWCACHE_ALIGN, 0, 0);\n\n\tkmem_cache = bootstrap(&boot_kmem_cache);\n\tkmem_cache_node = bootstrap(&boot_kmem_cache_node);\n\n\t/* Now we can use the kmem_cache to allocate kmalloc slabs */\n\tsetup_kmalloc_cache_index_table();\n\tcreate_kmalloc_caches(0);\n\n\t/* Setup random freelists for each cache */\n\tinit_freelist_randomization();\n\n\tcpuhp_setup_state_nocalls(CPUHP_SLUB_DEAD, \"slub:dead\", NULL,\n\t\t\t\t  slub_cpu_dead);\n\n\tpr_info(\"SLUB: HWalign=%d, Order=%u-%u, MinObjects=%u, CPUs=%u, Nodes=%d\\n\",\n\t\tcache_line_size(),\n\t\tslub_min_order, slub_max_order, slub_min_objects,\n\t\tnr_cpu_ids, nr_node_ids);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int slub_min_order;",
      "static unsigned int slub_max_order = PAGE_ALLOC_COSTLY_ORDER;",
      "static unsigned int slub_min_objects;",
      "static struct kmem_cache *kmem_cache_node;",
      "static struct notifier_block slab_memory_callback_nb = {\n\t.notifier_call = slab_memory_callback,\n\t.priority = SLAB_CALLBACK_PRI,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"SLUB: HWalign=%d, Order=%u-%u, MinObjects=%u, CPUs=%u, Nodes=%d\\n\"",
            "cache_line_size()",
            "slub_min_order",
            "slub_max_order",
            "slub_min_objects",
            "nr_cpu_ids",
            "nr_node_ids"
          ],
          "line": 4252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_line_size",
          "args": [],
          "line": 4253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_setup_state_nocalls",
          "args": [
            "CPUHP_SLUB_DEAD",
            "\"slub:dead\"",
            "NULL",
            "slub_cpu_dead"
          ],
          "line": 4249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_freelist_randomization",
          "args": [],
          "line": 4247
        },
        "resolved": true,
        "details": {
          "function_name": "init_freelist_randomization",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1590-1590",
          "snippet": "static inline void init_freelist_randomization(void) { }",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void init_freelist_randomization(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "create_kmalloc_caches",
          "args": [
            "0"
          ],
          "line": 4244
        },
        "resolved": true,
        "details": {
          "function_name": "create_kmalloc_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "1150-1190",
          "snippet": "void __init create_kmalloc_caches(slab_flags_t flags)\n{\n\tint i, type;\n\n\tfor (type = KMALLOC_NORMAL; type <= KMALLOC_RECLAIM; type++) {\n\t\tfor (i = KMALLOC_SHIFT_LOW; i <= KMALLOC_SHIFT_HIGH; i++) {\n\t\t\tif (!kmalloc_caches[type][i])\n\t\t\t\tnew_kmalloc_cache(i, type, flags);\n\n\t\t\t/*\n\t\t\t * Caches that are not of the two-to-the-power-of size.\n\t\t\t * These have to be created immediately after the\n\t\t\t * earlier power of two caches\n\t\t\t */\n\t\t\tif (KMALLOC_MIN_SIZE <= 32 && i == 6 &&\n\t\t\t\t\t!kmalloc_caches[type][1])\n\t\t\t\tnew_kmalloc_cache(1, type, flags);\n\t\t\tif (KMALLOC_MIN_SIZE <= 64 && i == 7 &&\n\t\t\t\t\t!kmalloc_caches[type][2])\n\t\t\t\tnew_kmalloc_cache(2, type, flags);\n\t\t}\n\t}\n\n\t/* Kmalloc array is now usable */\n\tslab_state = UP;\n\n#ifdef CONFIG_ZONE_DMA\n\tfor (i = 0; i <= KMALLOC_SHIFT_HIGH; i++) {\n\t\tstruct kmem_cache *s = kmalloc_caches[KMALLOC_NORMAL][i];\n\n\t\tif (s) {\n\t\t\tunsigned int size = kmalloc_size(i);\n\t\t\tconst char *n = kmalloc_cache_name(\"dma-kmalloc\", size);\n\n\t\t\tBUG_ON(!n);\n\t\t\tkmalloc_caches[KMALLOC_DMA][i] = create_kmalloc_cache(\n\t\t\t\tn, size, SLAB_CACHE_DMA | flags, 0, 0);\n\t\t}\n\t}\n#endif\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum slab_state slab_state;",
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nenum slab_state slab_state;\nstruct kmem_cache *kmem_cache;\n\nvoid __init create_kmalloc_caches(slab_flags_t flags)\n{\n\tint i, type;\n\n\tfor (type = KMALLOC_NORMAL; type <= KMALLOC_RECLAIM; type++) {\n\t\tfor (i = KMALLOC_SHIFT_LOW; i <= KMALLOC_SHIFT_HIGH; i++) {\n\t\t\tif (!kmalloc_caches[type][i])\n\t\t\t\tnew_kmalloc_cache(i, type, flags);\n\n\t\t\t/*\n\t\t\t * Caches that are not of the two-to-the-power-of size.\n\t\t\t * These have to be created immediately after the\n\t\t\t * earlier power of two caches\n\t\t\t */\n\t\t\tif (KMALLOC_MIN_SIZE <= 32 && i == 6 &&\n\t\t\t\t\t!kmalloc_caches[type][1])\n\t\t\t\tnew_kmalloc_cache(1, type, flags);\n\t\t\tif (KMALLOC_MIN_SIZE <= 64 && i == 7 &&\n\t\t\t\t\t!kmalloc_caches[type][2])\n\t\t\t\tnew_kmalloc_cache(2, type, flags);\n\t\t}\n\t}\n\n\t/* Kmalloc array is now usable */\n\tslab_state = UP;\n\n#ifdef CONFIG_ZONE_DMA\n\tfor (i = 0; i <= KMALLOC_SHIFT_HIGH; i++) {\n\t\tstruct kmem_cache *s = kmalloc_caches[KMALLOC_NORMAL][i];\n\n\t\tif (s) {\n\t\t\tunsigned int size = kmalloc_size(i);\n\t\t\tconst char *n = kmalloc_cache_name(\"dma-kmalloc\", size);\n\n\t\t\tBUG_ON(!n);\n\t\t\tkmalloc_caches[KMALLOC_DMA][i] = create_kmalloc_cache(\n\t\t\t\tn, size, SLAB_CACHE_DMA | flags, 0, 0);\n\t\t}\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_kmalloc_cache_index_table",
          "args": [],
          "line": 4243
        },
        "resolved": true,
        "details": {
          "function_name": "setup_kmalloc_cache_index_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "1075-1109",
          "snippet": "void __init setup_kmalloc_cache_index_table(void)\n{\n\tunsigned int i;\n\n\tBUILD_BUG_ON(KMALLOC_MIN_SIZE > 256 ||\n\t\t(KMALLOC_MIN_SIZE & (KMALLOC_MIN_SIZE - 1)));\n\n\tfor (i = 8; i < KMALLOC_MIN_SIZE; i += 8) {\n\t\tunsigned int elem = size_index_elem(i);\n\n\t\tif (elem >= ARRAY_SIZE(size_index))\n\t\t\tbreak;\n\t\tsize_index[elem] = KMALLOC_SHIFT_LOW;\n\t}\n\n\tif (KMALLOC_MIN_SIZE >= 64) {\n\t\t/*\n\t\t * The 96 byte size cache is not used if the alignment\n\t\t * is 64 byte.\n\t\t */\n\t\tfor (i = 64 + 8; i <= 96; i += 8)\n\t\t\tsize_index[size_index_elem(i)] = 7;\n\n\t}\n\n\tif (KMALLOC_MIN_SIZE >= 128) {\n\t\t/*\n\t\t * The 192 byte sized cache is not used if the alignment\n\t\t * is 128 byte. Redirect kmalloc to use the 256 byte cache\n\t\t * instead.\n\t\t */\n\t\tfor (i = 128 + 8; i <= 192; i += 8)\n\t\t\tsize_index[size_index_elem(i)] = 8;\n\t}\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nvoid __init setup_kmalloc_cache_index_table(void)\n{\n\tunsigned int i;\n\n\tBUILD_BUG_ON(KMALLOC_MIN_SIZE > 256 ||\n\t\t(KMALLOC_MIN_SIZE & (KMALLOC_MIN_SIZE - 1)));\n\n\tfor (i = 8; i < KMALLOC_MIN_SIZE; i += 8) {\n\t\tunsigned int elem = size_index_elem(i);\n\n\t\tif (elem >= ARRAY_SIZE(size_index))\n\t\t\tbreak;\n\t\tsize_index[elem] = KMALLOC_SHIFT_LOW;\n\t}\n\n\tif (KMALLOC_MIN_SIZE >= 64) {\n\t\t/*\n\t\t * The 96 byte size cache is not used if the alignment\n\t\t * is 64 byte.\n\t\t */\n\t\tfor (i = 64 + 8; i <= 96; i += 8)\n\t\t\tsize_index[size_index_elem(i)] = 7;\n\n\t}\n\n\tif (KMALLOC_MIN_SIZE >= 128) {\n\t\t/*\n\t\t * The 192 byte sized cache is not used if the alignment\n\t\t * is 128 byte. Redirect kmalloc to use the 256 byte cache\n\t\t * instead.\n\t\t */\n\t\tfor (i = 128 + 8; i <= 192; i += 8)\n\t\t\tsize_index[size_index_elem(i)] = 8;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bootstrap",
          "args": [
            "&boot_kmem_cache_node"
          ],
          "line": 4240
        },
        "resolved": true,
        "details": {
          "function_name": "bootstrap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "4184-4213",
          "snippet": "static struct kmem_cache * __init bootstrap(struct kmem_cache *static_cache)\n{\n\tint node;\n\tstruct kmem_cache *s = kmem_cache_zalloc(kmem_cache, GFP_NOWAIT);\n\tstruct kmem_cache_node *n;\n\n\tmemcpy(s, static_cache, kmem_cache->object_size);\n\n\t/*\n\t * This runs very early, and only the boot processor is supposed to be\n\t * up.  Even if it weren't true, IRQs are not up so we couldn't fire\n\t * IPIs around.\n\t */\n\t__flush_cpu_slab(s, smp_processor_id());\n\tfor_each_kmem_cache_node(s, node, n) {\n\t\tstruct page *p;\n\n\t\tlist_for_each_entry(p, &n->partial, lru)\n\t\t\tp->slab_cache = s;\n\n#ifdef CONFIG_SLUB_DEBUG\n\t\tlist_for_each_entry(p, &n->full, lru)\n\t\t\tp->slab_cache = s;\n#endif\n\t}\n\tslab_init_memcg_params(s);\n\tlist_add(&s->list, &slab_caches);\n\tmemcg_link_cache(s);\n\treturn s;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic struct kmem_cache * __init bootstrap(struct kmem_cache *static_cache)\n{\n\tint node;\n\tstruct kmem_cache *s = kmem_cache_zalloc(kmem_cache, GFP_NOWAIT);\n\tstruct kmem_cache_node *n;\n\n\tmemcpy(s, static_cache, kmem_cache->object_size);\n\n\t/*\n\t * This runs very early, and only the boot processor is supposed to be\n\t * up.  Even if it weren't true, IRQs are not up so we couldn't fire\n\t * IPIs around.\n\t */\n\t__flush_cpu_slab(s, smp_processor_id());\n\tfor_each_kmem_cache_node(s, node, n) {\n\t\tstruct page *p;\n\n\t\tlist_for_each_entry(p, &n->partial, lru)\n\t\t\tp->slab_cache = s;\n\n#ifdef CONFIG_SLUB_DEBUG\n\t\tlist_for_each_entry(p, &n->full, lru)\n\t\t\tp->slab_cache = s;\n#endif\n\t}\n\tslab_init_memcg_params(s);\n\tlist_add(&s->list, &slab_caches);\n\tmemcg_link_cache(s);\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_boot_cache",
          "args": [
            "kmem_cache",
            "\"kmem_cache\"",
            "offsetof(struct kmem_cache, node) +\n\t\t\t\tnr_node_ids * sizeof(struct kmem_cache_node *)",
            "SLAB_HWCACHE_ALIGN",
            "0",
            "0"
          ],
          "line": 4234
        },
        "resolved": true,
        "details": {
          "function_name": "create_boot_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "937-958",
          "snippet": "void __init create_boot_cache(struct kmem_cache *s, const char *name,\n\t\tunsigned int size, slab_flags_t flags,\n\t\tunsigned int useroffset, unsigned int usersize)\n{\n\tint err;\n\n\ts->name = name;\n\ts->size = s->object_size = size;\n\ts->align = calculate_alignment(flags, ARCH_KMALLOC_MINALIGN, size);\n\ts->useroffset = useroffset;\n\ts->usersize = usersize;\n\n\tslab_init_memcg_params(s);\n\n\terr = __kmem_cache_create(s, flags);\n\n\tif (err)\n\t\tpanic(\"Creation of kmalloc slab %s size=%u failed. Reason %d\\n\",\n\t\t\t\t\tname, size, err);\n\n\ts->refcount = -1;\t/* Exempt from merging for now */\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nvoid __init create_boot_cache(struct kmem_cache *s, const char *name,\n\t\tunsigned int size, slab_flags_t flags,\n\t\tunsigned int useroffset, unsigned int usersize)\n{\n\tint err;\n\n\ts->name = name;\n\ts->size = s->object_size = size;\n\ts->align = calculate_alignment(flags, ARCH_KMALLOC_MINALIGN, size);\n\ts->useroffset = useroffset;\n\ts->usersize = usersize;\n\n\tslab_init_memcg_params(s);\n\n\terr = __kmem_cache_create(s, flags);\n\n\tif (err)\n\t\tpanic(\"Creation of kmalloc slab %s size=%u failed. Reason %d\\n\",\n\t\t\t\t\tname, size, err);\n\n\ts->refcount = -1;\t/* Exempt from merging for now */\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_hotmemory_notifier",
          "args": [
            "&slab_memory_callback_nb"
          ],
          "line": 4229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_guardpage_minorder",
          "args": [],
          "line": 4220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic unsigned int slub_min_order;\nstatic unsigned int slub_max_order = PAGE_ALLOC_COSTLY_ORDER;\nstatic unsigned int slub_min_objects;\nstatic struct kmem_cache *kmem_cache_node;\nstatic struct notifier_block slab_memory_callback_nb = {\n\t.notifier_call = slab_memory_callback,\n\t.priority = SLAB_CALLBACK_PRI,\n};\n\nvoid __init kmem_cache_init(void)\n{\n\tstatic __initdata struct kmem_cache boot_kmem_cache,\n\t\tboot_kmem_cache_node;\n\n\tif (debug_guardpage_minorder())\n\t\tslub_max_order = 0;\n\n\tkmem_cache_node = &boot_kmem_cache_node;\n\tkmem_cache = &boot_kmem_cache;\n\n\tcreate_boot_cache(kmem_cache_node, \"kmem_cache_node\",\n\t\tsizeof(struct kmem_cache_node), SLAB_HWCACHE_ALIGN, 0, 0);\n\n\tregister_hotmemory_notifier(&slab_memory_callback_nb);\n\n\t/* Able to allocate the per node structures */\n\tslab_state = PARTIAL;\n\n\tcreate_boot_cache(kmem_cache, \"kmem_cache\",\n\t\t\toffsetof(struct kmem_cache, node) +\n\t\t\t\tnr_node_ids * sizeof(struct kmem_cache_node *),\n\t\t       SLAB_HWCACHE_ALIGN, 0, 0);\n\n\tkmem_cache = bootstrap(&boot_kmem_cache);\n\tkmem_cache_node = bootstrap(&boot_kmem_cache_node);\n\n\t/* Now we can use the kmem_cache to allocate kmalloc slabs */\n\tsetup_kmalloc_cache_index_table();\n\tcreate_kmalloc_caches(0);\n\n\t/* Setup random freelists for each cache */\n\tinit_freelist_randomization();\n\n\tcpuhp_setup_state_nocalls(CPUHP_SLUB_DEAD, \"slub:dead\", NULL,\n\t\t\t\t  slub_cpu_dead);\n\n\tpr_info(\"SLUB: HWalign=%d, Order=%u-%u, MinObjects=%u, CPUs=%u, Nodes=%d\\n\",\n\t\tcache_line_size(),\n\t\tslub_min_order, slub_max_order, slub_min_objects,\n\t\tnr_cpu_ids, nr_node_ids);\n}"
  },
  {
    "function_name": "bootstrap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "4184-4213",
    "snippet": "static struct kmem_cache * __init bootstrap(struct kmem_cache *static_cache)\n{\n\tint node;\n\tstruct kmem_cache *s = kmem_cache_zalloc(kmem_cache, GFP_NOWAIT);\n\tstruct kmem_cache_node *n;\n\n\tmemcpy(s, static_cache, kmem_cache->object_size);\n\n\t/*\n\t * This runs very early, and only the boot processor is supposed to be\n\t * up.  Even if it weren't true, IRQs are not up so we couldn't fire\n\t * IPIs around.\n\t */\n\t__flush_cpu_slab(s, smp_processor_id());\n\tfor_each_kmem_cache_node(s, node, n) {\n\t\tstruct page *p;\n\n\t\tlist_for_each_entry(p, &n->partial, lru)\n\t\t\tp->slab_cache = s;\n\n#ifdef CONFIG_SLUB_DEBUG\n\t\tlist_for_each_entry(p, &n->full, lru)\n\t\t\tp->slab_cache = s;\n#endif\n\t}\n\tslab_init_memcg_params(s);\n\tlist_add(&s->list, &slab_caches);\n\tmemcg_link_cache(s);\n\treturn s;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *kmem_cache_node;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcg_link_cache",
          "args": [
            "s"
          ],
          "line": 4211
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_link_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "350-352",
          "snippet": "static inline void memcg_link_cache(struct kmem_cache *s)\n{\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline void memcg_link_cache(struct kmem_cache *s)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&s->list",
            "&slab_caches"
          ],
          "line": 4210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_init_memcg_params",
          "args": [
            "s"
          ],
          "line": 4209
        },
        "resolved": true,
        "details": {
          "function_name": "slab_init_memcg_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "346-348",
          "snippet": "static inline void slab_init_memcg_params(struct kmem_cache *s)\n{\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline void slab_init_memcg_params(struct kmem_cache *s)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "p",
            "&n->full",
            "lru"
          ],
          "line": 4205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "p",
            "&n->partial",
            "lru"
          ],
          "line": 4201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_kmem_cache_node",
          "args": [
            "s",
            "node",
            "n"
          ],
          "line": 4198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__flush_cpu_slab",
          "args": [
            "s",
            "smp_processor_id()"
          ],
          "line": 4197
        },
        "resolved": true,
        "details": {
          "function_name": "__flush_cpu_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2312-2322",
          "snippet": "static inline void __flush_cpu_slab(struct kmem_cache *s, int cpu)\n{\n\tstruct kmem_cache_cpu *c = per_cpu_ptr(s->cpu_slab, cpu);\n\n\tif (likely(c)) {\n\t\tif (c->page)\n\t\t\tflush_slab(s, c);\n\n\t\tunfreeze_partials(s, c);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void __flush_cpu_slab(struct kmem_cache *s, int cpu)\n{\n\tstruct kmem_cache_cpu *c = per_cpu_ptr(s->cpu_slab, cpu);\n\n\tif (likely(c)) {\n\t\tif (c->page)\n\t\t\tflush_slab(s, c);\n\n\t\tunfreeze_partials(s, c);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 4197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "s",
            "static_cache",
            "kmem_cache->object_size"
          ],
          "line": 4190
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "300-306",
          "snippet": "void *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "kmem_cache",
            "GFP_NOWAIT"
          ],
          "line": 4187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic struct kmem_cache * __init bootstrap(struct kmem_cache *static_cache)\n{\n\tint node;\n\tstruct kmem_cache *s = kmem_cache_zalloc(kmem_cache, GFP_NOWAIT);\n\tstruct kmem_cache_node *n;\n\n\tmemcpy(s, static_cache, kmem_cache->object_size);\n\n\t/*\n\t * This runs very early, and only the boot processor is supposed to be\n\t * up.  Even if it weren't true, IRQs are not up so we couldn't fire\n\t * IPIs around.\n\t */\n\t__flush_cpu_slab(s, smp_processor_id());\n\tfor_each_kmem_cache_node(s, node, n) {\n\t\tstruct page *p;\n\n\t\tlist_for_each_entry(p, &n->partial, lru)\n\t\t\tp->slab_cache = s;\n\n#ifdef CONFIG_SLUB_DEBUG\n\t\tlist_for_each_entry(p, &n->full, lru)\n\t\t\tp->slab_cache = s;\n#endif\n\t}\n\tslab_init_memcg_params(s);\n\tlist_add(&s->list, &slab_caches);\n\tmemcg_link_cache(s);\n\treturn s;\n}"
  },
  {
    "function_name": "slab_memory_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "4142-4167",
    "snippet": "static int slab_memory_callback(struct notifier_block *self,\n\t\t\t\tunsigned long action, void *arg)\n{\n\tint ret = 0;\n\n\tswitch (action) {\n\tcase MEM_GOING_ONLINE:\n\t\tret = slab_mem_going_online_callback(arg);\n\t\tbreak;\n\tcase MEM_GOING_OFFLINE:\n\t\tret = slab_mem_going_offline_callback(arg);\n\t\tbreak;\n\tcase MEM_OFFLINE:\n\tcase MEM_CANCEL_ONLINE:\n\t\tslab_mem_offline_callback(arg);\n\t\tbreak;\n\tcase MEM_ONLINE:\n\tcase MEM_CANCEL_OFFLINE:\n\t\tbreak;\n\t}\n\tif (ret)\n\t\tret = notifier_from_errno(ret);\n\telse\n\t\tret = NOTIFY_OK;\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "notifier_from_errno",
          "args": [
            "ret"
          ],
          "line": 4163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_mem_offline_callback",
          "args": [
            "arg"
          ],
          "line": 4156
        },
        "resolved": true,
        "details": {
          "function_name": "slab_mem_offline_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "4067-4100",
          "snippet": "static void slab_mem_offline_callback(void *arg)\n{\n\tstruct kmem_cache_node *n;\n\tstruct kmem_cache *s;\n\tstruct memory_notify *marg = arg;\n\tint offline_node;\n\n\toffline_node = marg->status_change_nid_normal;\n\n\t/*\n\t * If the node still has available memory. we need kmem_cache_node\n\t * for it yet.\n\t */\n\tif (offline_node < 0)\n\t\treturn;\n\n\tmutex_lock(&slab_mutex);\n\tlist_for_each_entry(s, &slab_caches, list) {\n\t\tn = get_node(s, offline_node);\n\t\tif (n) {\n\t\t\t/*\n\t\t\t * if n->nr_slabs > 0, slabs still exist on the node\n\t\t\t * that is going down. We were unable to free them,\n\t\t\t * and offline_pages() function shouldn't call this\n\t\t\t * callback. So, we must fail.\n\t\t\t */\n\t\t\tBUG_ON(slabs_node(s, offline_node));\n\n\t\t\ts->node[offline_node] = NULL;\n\t\t\tkmem_cache_free(kmem_cache_node, n);\n\t\t}\n\t}\n\tmutex_unlock(&slab_mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic void slab_mem_offline_callback(void *arg)\n{\n\tstruct kmem_cache_node *n;\n\tstruct kmem_cache *s;\n\tstruct memory_notify *marg = arg;\n\tint offline_node;\n\n\toffline_node = marg->status_change_nid_normal;\n\n\t/*\n\t * If the node still has available memory. we need kmem_cache_node\n\t * for it yet.\n\t */\n\tif (offline_node < 0)\n\t\treturn;\n\n\tmutex_lock(&slab_mutex);\n\tlist_for_each_entry(s, &slab_caches, list) {\n\t\tn = get_node(s, offline_node);\n\t\tif (n) {\n\t\t\t/*\n\t\t\t * if n->nr_slabs > 0, slabs still exist on the node\n\t\t\t * that is going down. We were unable to free them,\n\t\t\t * and offline_pages() function shouldn't call this\n\t\t\t * callback. So, we must fail.\n\t\t\t */\n\t\t\tBUG_ON(slabs_node(s, offline_node));\n\n\t\t\ts->node[offline_node] = NULL;\n\t\t\tkmem_cache_free(kmem_cache_node, n);\n\t\t}\n\t}\n\tmutex_unlock(&slab_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "slab_mem_going_offline_callback",
          "args": [
            "arg"
          ],
          "line": 4152
        },
        "resolved": true,
        "details": {
          "function_name": "slab_mem_going_offline_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "4055-4065",
          "snippet": "static int slab_mem_going_offline_callback(void *arg)\n{\n\tstruct kmem_cache *s;\n\n\tmutex_lock(&slab_mutex);\n\tlist_for_each_entry(s, &slab_caches, list)\n\t\t__kmem_cache_shrink(s);\n\tmutex_unlock(&slab_mutex);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic int slab_mem_going_offline_callback(void *arg)\n{\n\tstruct kmem_cache *s;\n\n\tmutex_lock(&slab_mutex);\n\tlist_for_each_entry(s, &slab_caches, list)\n\t\t__kmem_cache_shrink(s);\n\tmutex_unlock(&slab_mutex);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "slab_mem_going_online_callback",
          "args": [
            "arg"
          ],
          "line": 4149
        },
        "resolved": true,
        "details": {
          "function_name": "slab_mem_going_online_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "4102-4140",
          "snippet": "static int slab_mem_going_online_callback(void *arg)\n{\n\tstruct kmem_cache_node *n;\n\tstruct kmem_cache *s;\n\tstruct memory_notify *marg = arg;\n\tint nid = marg->status_change_nid_normal;\n\tint ret = 0;\n\n\t/*\n\t * If the node's memory is already available, then kmem_cache_node is\n\t * already created. Nothing to do.\n\t */\n\tif (nid < 0)\n\t\treturn 0;\n\n\t/*\n\t * We are bringing a node online. No memory is available yet. We must\n\t * allocate a kmem_cache_node structure in order to bring the node\n\t * online.\n\t */\n\tmutex_lock(&slab_mutex);\n\tlist_for_each_entry(s, &slab_caches, list) {\n\t\t/*\n\t\t * XXX: kmem_cache_alloc_node will fallback to other nodes\n\t\t *      since memory is not yet available from the node that\n\t\t *      is brought up.\n\t\t */\n\t\tn = kmem_cache_alloc(kmem_cache_node, GFP_KERNEL);\n\t\tif (!n) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tinit_kmem_cache_node(n);\n\t\ts->node[nid] = n;\n\t}\nout:\n\tmutex_unlock(&slab_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic int slab_mem_going_online_callback(void *arg)\n{\n\tstruct kmem_cache_node *n;\n\tstruct kmem_cache *s;\n\tstruct memory_notify *marg = arg;\n\tint nid = marg->status_change_nid_normal;\n\tint ret = 0;\n\n\t/*\n\t * If the node's memory is already available, then kmem_cache_node is\n\t * already created. Nothing to do.\n\t */\n\tif (nid < 0)\n\t\treturn 0;\n\n\t/*\n\t * We are bringing a node online. No memory is available yet. We must\n\t * allocate a kmem_cache_node structure in order to bring the node\n\t * online.\n\t */\n\tmutex_lock(&slab_mutex);\n\tlist_for_each_entry(s, &slab_caches, list) {\n\t\t/*\n\t\t * XXX: kmem_cache_alloc_node will fallback to other nodes\n\t\t *      since memory is not yet available from the node that\n\t\t *      is brought up.\n\t\t */\n\t\tn = kmem_cache_alloc(kmem_cache_node, GFP_KERNEL);\n\t\tif (!n) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tinit_kmem_cache_node(n);\n\t\ts->node[nid] = n;\n\t}\nout:\n\tmutex_unlock(&slab_mutex);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic int slab_memory_callback(struct notifier_block *self,\n\t\t\t\tunsigned long action, void *arg)\n{\n\tint ret = 0;\n\n\tswitch (action) {\n\tcase MEM_GOING_ONLINE:\n\t\tret = slab_mem_going_online_callback(arg);\n\t\tbreak;\n\tcase MEM_GOING_OFFLINE:\n\t\tret = slab_mem_going_offline_callback(arg);\n\t\tbreak;\n\tcase MEM_OFFLINE:\n\tcase MEM_CANCEL_ONLINE:\n\t\tslab_mem_offline_callback(arg);\n\t\tbreak;\n\tcase MEM_ONLINE:\n\tcase MEM_CANCEL_OFFLINE:\n\t\tbreak;\n\t}\n\tif (ret)\n\t\tret = notifier_from_errno(ret);\n\telse\n\t\tret = NOTIFY_OK;\n\treturn ret;\n}"
  },
  {
    "function_name": "slab_mem_going_online_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "4102-4140",
    "snippet": "static int slab_mem_going_online_callback(void *arg)\n{\n\tstruct kmem_cache_node *n;\n\tstruct kmem_cache *s;\n\tstruct memory_notify *marg = arg;\n\tint nid = marg->status_change_nid_normal;\n\tint ret = 0;\n\n\t/*\n\t * If the node's memory is already available, then kmem_cache_node is\n\t * already created. Nothing to do.\n\t */\n\tif (nid < 0)\n\t\treturn 0;\n\n\t/*\n\t * We are bringing a node online. No memory is available yet. We must\n\t * allocate a kmem_cache_node structure in order to bring the node\n\t * online.\n\t */\n\tmutex_lock(&slab_mutex);\n\tlist_for_each_entry(s, &slab_caches, list) {\n\t\t/*\n\t\t * XXX: kmem_cache_alloc_node will fallback to other nodes\n\t\t *      since memory is not yet available from the node that\n\t\t *      is brought up.\n\t\t */\n\t\tn = kmem_cache_alloc(kmem_cache_node, GFP_KERNEL);\n\t\tif (!n) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tinit_kmem_cache_node(n);\n\t\ts->node[nid] = n;\n\t}\nout:\n\tmutex_unlock(&slab_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *kmem_cache_node;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&slab_mutex"
          ],
          "line": 4138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_kmem_cache_node",
          "args": [
            "n"
          ],
          "line": 4134
        },
        "resolved": true,
        "details": {
          "function_name": "init_kmem_cache_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "3405-3428",
          "snippet": "static int init_kmem_cache_nodes(struct kmem_cache *s)\n{\n\tint node;\n\n\tfor_each_node_state(node, N_NORMAL_MEMORY) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tif (slab_state == DOWN) {\n\t\t\tearly_kmem_cache_node_alloc(node);\n\t\t\tcontinue;\n\t\t}\n\t\tn = kmem_cache_alloc_node(kmem_cache_node,\n\t\t\t\t\t\tGFP_KERNEL, node);\n\n\t\tif (!n) {\n\t\t\tfree_kmem_cache_nodes(s);\n\t\t\treturn 0;\n\t\t}\n\n\t\tinit_kmem_cache_node(n);\n\t\ts->node[node] = n;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic int init_kmem_cache_nodes(struct kmem_cache *s)\n{\n\tint node;\n\n\tfor_each_node_state(node, N_NORMAL_MEMORY) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tif (slab_state == DOWN) {\n\t\t\tearly_kmem_cache_node_alloc(node);\n\t\t\tcontinue;\n\t\t}\n\t\tn = kmem_cache_alloc_node(kmem_cache_node,\n\t\t\t\t\t\tGFP_KERNEL, node);\n\n\t\tif (!n) {\n\t\t\tfree_kmem_cache_nodes(s);\n\t\t\treturn 0;\n\t\t}\n\n\t\tinit_kmem_cache_node(n);\n\t\ts->node[node] = n;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "kmem_cache_node",
            "GFP_KERNEL"
          ],
          "line": 4129
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2755-2763",
          "snippet": "void *kmem_cache_alloc(struct kmem_cache *s, gfp_t gfpflags)\n{\n\tvoid *ret = slab_alloc(s, gfpflags, _RET_IP_);\n\n\ttrace_kmem_cache_alloc(_RET_IP_, ret, s->object_size,\n\t\t\t\ts->size, gfpflags);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);\n\nvoid *kmem_cache_alloc(struct kmem_cache *s, gfp_t gfpflags)\n{\n\tvoid *ret = slab_alloc(s, gfpflags, _RET_IP_);\n\n\ttrace_kmem_cache_alloc(_RET_IP_, ret, s->object_size,\n\t\t\t\ts->size, gfpflags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "s",
            "&slab_caches",
            "list"
          ],
          "line": 4123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&slab_mutex"
          ],
          "line": 4122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic int slab_mem_going_online_callback(void *arg)\n{\n\tstruct kmem_cache_node *n;\n\tstruct kmem_cache *s;\n\tstruct memory_notify *marg = arg;\n\tint nid = marg->status_change_nid_normal;\n\tint ret = 0;\n\n\t/*\n\t * If the node's memory is already available, then kmem_cache_node is\n\t * already created. Nothing to do.\n\t */\n\tif (nid < 0)\n\t\treturn 0;\n\n\t/*\n\t * We are bringing a node online. No memory is available yet. We must\n\t * allocate a kmem_cache_node structure in order to bring the node\n\t * online.\n\t */\n\tmutex_lock(&slab_mutex);\n\tlist_for_each_entry(s, &slab_caches, list) {\n\t\t/*\n\t\t * XXX: kmem_cache_alloc_node will fallback to other nodes\n\t\t *      since memory is not yet available from the node that\n\t\t *      is brought up.\n\t\t */\n\t\tn = kmem_cache_alloc(kmem_cache_node, GFP_KERNEL);\n\t\tif (!n) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tinit_kmem_cache_node(n);\n\t\ts->node[nid] = n;\n\t}\nout:\n\tmutex_unlock(&slab_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "slab_mem_offline_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "4067-4100",
    "snippet": "static void slab_mem_offline_callback(void *arg)\n{\n\tstruct kmem_cache_node *n;\n\tstruct kmem_cache *s;\n\tstruct memory_notify *marg = arg;\n\tint offline_node;\n\n\toffline_node = marg->status_change_nid_normal;\n\n\t/*\n\t * If the node still has available memory. we need kmem_cache_node\n\t * for it yet.\n\t */\n\tif (offline_node < 0)\n\t\treturn;\n\n\tmutex_lock(&slab_mutex);\n\tlist_for_each_entry(s, &slab_caches, list) {\n\t\tn = get_node(s, offline_node);\n\t\tif (n) {\n\t\t\t/*\n\t\t\t * if n->nr_slabs > 0, slabs still exist on the node\n\t\t\t * that is going down. We were unable to free them,\n\t\t\t * and offline_pages() function shouldn't call this\n\t\t\t * callback. So, we must fail.\n\t\t\t */\n\t\t\tBUG_ON(slabs_node(s, offline_node));\n\n\t\t\ts->node[offline_node] = NULL;\n\t\t\tkmem_cache_free(kmem_cache_node, n);\n\t\t}\n\t}\n\tmutex_unlock(&slab_mutex);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *kmem_cache_node;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&slab_mutex"
          ],
          "line": 4099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "kmem_cache_node",
            "n"
          ],
          "line": 4096
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "3002-3009",
          "snippet": "void kmem_cache_free(struct kmem_cache *s, void *x)\n{\n\ts = cache_from_obj(s, x);\n\tif (!s)\n\t\treturn;\n\tslab_free(s, virt_to_head_page(x), x, NULL, 1, _RET_IP_);\n\ttrace_kmem_cache_free(_RET_IP_, x);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid kmem_cache_free(struct kmem_cache *s, void *x)\n{\n\ts = cache_from_obj(s, x);\n\tif (!s)\n\t\treturn;\n\tslab_free(s, virt_to_head_page(x), x, NULL, 1, _RET_IP_);\n\ttrace_kmem_cache_free(_RET_IP_, x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "slabs_node(s, offline_node)"
          ],
          "line": 4093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slabs_node",
          "args": [
            "s",
            "offline_node"
          ],
          "line": 4093
        },
        "resolved": true,
        "details": {
          "function_name": "slabs_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1360-1361",
          "snippet": "static inline unsigned long slabs_node(struct kmem_cache *s, int node)\n\t\t\t\t\t\t\t{ return 0; }",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline unsigned long slabs_node(struct kmem_cache *s, int node)\n\t\t\t\t\t\t\t{ return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "get_node",
          "args": [
            "s",
            "offline_node"
          ],
          "line": 4085
        },
        "resolved": true,
        "details": {
          "function_name": "get_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "485-488",
          "snippet": "static inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "s",
            "&slab_caches",
            "list"
          ],
          "line": 4084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&slab_mutex"
          ],
          "line": 4083
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic void slab_mem_offline_callback(void *arg)\n{\n\tstruct kmem_cache_node *n;\n\tstruct kmem_cache *s;\n\tstruct memory_notify *marg = arg;\n\tint offline_node;\n\n\toffline_node = marg->status_change_nid_normal;\n\n\t/*\n\t * If the node still has available memory. we need kmem_cache_node\n\t * for it yet.\n\t */\n\tif (offline_node < 0)\n\t\treturn;\n\n\tmutex_lock(&slab_mutex);\n\tlist_for_each_entry(s, &slab_caches, list) {\n\t\tn = get_node(s, offline_node);\n\t\tif (n) {\n\t\t\t/*\n\t\t\t * if n->nr_slabs > 0, slabs still exist on the node\n\t\t\t * that is going down. We were unable to free them,\n\t\t\t * and offline_pages() function shouldn't call this\n\t\t\t * callback. So, we must fail.\n\t\t\t */\n\t\t\tBUG_ON(slabs_node(s, offline_node));\n\n\t\t\ts->node[offline_node] = NULL;\n\t\t\tkmem_cache_free(kmem_cache_node, n);\n\t\t}\n\t}\n\tmutex_unlock(&slab_mutex);\n}"
  },
  {
    "function_name": "slab_mem_going_offline_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "4055-4065",
    "snippet": "static int slab_mem_going_offline_callback(void *arg)\n{\n\tstruct kmem_cache *s;\n\n\tmutex_lock(&slab_mutex);\n\tlist_for_each_entry(s, &slab_caches, list)\n\t\t__kmem_cache_shrink(s);\n\tmutex_unlock(&slab_mutex);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&slab_mutex"
          ],
          "line": 4062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kmem_cache_shrink",
          "args": [
            "s"
          ],
          "line": 4061
        },
        "resolved": true,
        "details": {
          "function_name": "__kmem_cache_shrink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "3957-4017",
          "snippet": "int __kmem_cache_shrink(struct kmem_cache *s)\n{\n\tint node;\n\tint i;\n\tstruct kmem_cache_node *n;\n\tstruct page *page;\n\tstruct page *t;\n\tstruct list_head discard;\n\tstruct list_head promote[SHRINK_PROMOTE_MAX];\n\tunsigned long flags;\n\tint ret = 0;\n\n\tflush_all(s);\n\tfor_each_kmem_cache_node(s, node, n) {\n\t\tINIT_LIST_HEAD(&discard);\n\t\tfor (i = 0; i < SHRINK_PROMOTE_MAX; i++)\n\t\t\tINIT_LIST_HEAD(promote + i);\n\n\t\tspin_lock_irqsave(&n->list_lock, flags);\n\n\t\t/*\n\t\t * Build lists of slabs to discard or promote.\n\t\t *\n\t\t * Note that concurrent frees may occur while we hold the\n\t\t * list_lock. page->inuse here is the upper limit.\n\t\t */\n\t\tlist_for_each_entry_safe(page, t, &n->partial, lru) {\n\t\t\tint free = page->objects - page->inuse;\n\n\t\t\t/* Do not reread page->inuse */\n\t\t\tbarrier();\n\n\t\t\t/* We do not keep full slabs on the list */\n\t\t\tBUG_ON(free <= 0);\n\n\t\t\tif (free == page->objects) {\n\t\t\t\tlist_move(&page->lru, &discard);\n\t\t\t\tn->nr_partial--;\n\t\t\t} else if (free <= SHRINK_PROMOTE_MAX)\n\t\t\t\tlist_move(&page->lru, promote + free - 1);\n\t\t}\n\n\t\t/*\n\t\t * Promote the slabs filled up most to the head of the\n\t\t * partial list.\n\t\t */\n\t\tfor (i = SHRINK_PROMOTE_MAX - 1; i >= 0; i--)\n\t\t\tlist_splice(promote + i, &n->partial);\n\n\t\tspin_unlock_irqrestore(&n->list_lock, flags);\n\n\t\t/* Release empty slabs */\n\t\tlist_for_each_entry_safe(page, t, &discard, lru)\n\t\t\tdiscard_slab(s, page);\n\n\t\tif (slabs_node(s, node))\n\t\t\tret = 1;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SHRINK_PROMOTE_MAX 32"
          ],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define SHRINK_PROMOTE_MAX 32\n\nstatic struct kmem_cache *kmem_cache_node;\n\nint __kmem_cache_shrink(struct kmem_cache *s)\n{\n\tint node;\n\tint i;\n\tstruct kmem_cache_node *n;\n\tstruct page *page;\n\tstruct page *t;\n\tstruct list_head discard;\n\tstruct list_head promote[SHRINK_PROMOTE_MAX];\n\tunsigned long flags;\n\tint ret = 0;\n\n\tflush_all(s);\n\tfor_each_kmem_cache_node(s, node, n) {\n\t\tINIT_LIST_HEAD(&discard);\n\t\tfor (i = 0; i < SHRINK_PROMOTE_MAX; i++)\n\t\t\tINIT_LIST_HEAD(promote + i);\n\n\t\tspin_lock_irqsave(&n->list_lock, flags);\n\n\t\t/*\n\t\t * Build lists of slabs to discard or promote.\n\t\t *\n\t\t * Note that concurrent frees may occur while we hold the\n\t\t * list_lock. page->inuse here is the upper limit.\n\t\t */\n\t\tlist_for_each_entry_safe(page, t, &n->partial, lru) {\n\t\t\tint free = page->objects - page->inuse;\n\n\t\t\t/* Do not reread page->inuse */\n\t\t\tbarrier();\n\n\t\t\t/* We do not keep full slabs on the list */\n\t\t\tBUG_ON(free <= 0);\n\n\t\t\tif (free == page->objects) {\n\t\t\t\tlist_move(&page->lru, &discard);\n\t\t\t\tn->nr_partial--;\n\t\t\t} else if (free <= SHRINK_PROMOTE_MAX)\n\t\t\t\tlist_move(&page->lru, promote + free - 1);\n\t\t}\n\n\t\t/*\n\t\t * Promote the slabs filled up most to the head of the\n\t\t * partial list.\n\t\t */\n\t\tfor (i = SHRINK_PROMOTE_MAX - 1; i >= 0; i--)\n\t\t\tlist_splice(promote + i, &n->partial);\n\n\t\tspin_unlock_irqrestore(&n->list_lock, flags);\n\n\t\t/* Release empty slabs */\n\t\tlist_for_each_entry_safe(page, t, &discard, lru)\n\t\t\tdiscard_slab(s, page);\n\n\t\tif (slabs_node(s, node))\n\t\t\tret = 1;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "s",
            "&slab_caches",
            "list"
          ],
          "line": 4060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&slab_mutex"
          ],
          "line": 4059
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic int slab_mem_going_offline_callback(void *arg)\n{\n\tstruct kmem_cache *s;\n\n\tmutex_lock(&slab_mutex);\n\tlist_for_each_entry(s, &slab_caches, list)\n\t\t__kmem_cache_shrink(s);\n\tmutex_unlock(&slab_mutex);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__kmemcg_cache_deactivate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "4038-4052",
    "snippet": "void __kmemcg_cache_deactivate(struct kmem_cache *s)\n{\n\t/*\n\t * Disable empty slabs caching. Used to avoid pinning offline\n\t * memory cgroups by kmem pages that can be freed.\n\t */\n\tslub_set_cpu_partial(s, 0);\n\ts->min_partial = 0;\n\n\t/*\n\t * s->cpu_partial is checked locklessly (see put_cpu_partial), so\n\t * we have to make sure the change is visible before shrinking.\n\t */\n\tslab_deactivate_memcg_cache_rcu_sched(s, kmemcg_cache_deact_after_rcu);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "slab_deactivate_memcg_cache_rcu_sched",
          "args": [
            "s",
            "kmemcg_cache_deact_after_rcu"
          ],
          "line": 4051
        },
        "resolved": true,
        "details": {
          "function_name": "slab_deactivate_memcg_cache_rcu_sched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "713-728",
          "snippet": "void slab_deactivate_memcg_cache_rcu_sched(struct kmem_cache *s,\n\t\t\t\t\t   void (*deact_fn)(struct kmem_cache *))\n{\n\tif (WARN_ON_ONCE(is_root_cache(s)) ||\n\t    WARN_ON_ONCE(s->memcg_params.deact_fn))\n\t\treturn;\n\n\tif (s->memcg_params.root_cache->memcg_params.dying)\n\t\treturn;\n\n\t/* pin memcg so that @s doesn't get destroyed in the middle */\n\tcss_get(&s->memcg_params.memcg->css);\n\n\ts->memcg_params.deact_fn = deact_fn;\n\tcall_rcu_sched(&s->memcg_params.deact_rcu_head, kmemcg_deactivate_rcufn);\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nvoid slab_deactivate_memcg_cache_rcu_sched(struct kmem_cache *s,\n\t\t\t\t\t   void (*deact_fn)(struct kmem_cache *))\n{\n\tif (WARN_ON_ONCE(is_root_cache(s)) ||\n\t    WARN_ON_ONCE(s->memcg_params.deact_fn))\n\t\treturn;\n\n\tif (s->memcg_params.root_cache->memcg_params.dying)\n\t\treturn;\n\n\t/* pin memcg so that @s doesn't get destroyed in the middle */\n\tcss_get(&s->memcg_params.memcg->css);\n\n\ts->memcg_params.deact_fn = deact_fn;\n\tcall_rcu_sched(&s->memcg_params.deact_rcu_head, kmemcg_deactivate_rcufn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "slub_set_cpu_partial",
          "args": [
            "s",
            "0"
          ],
          "line": 4044
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid __kmemcg_cache_deactivate(struct kmem_cache *s)\n{\n\t/*\n\t * Disable empty slabs caching. Used to avoid pinning offline\n\t * memory cgroups by kmem pages that can be freed.\n\t */\n\tslub_set_cpu_partial(s, 0);\n\ts->min_partial = 0;\n\n\t/*\n\t * s->cpu_partial is checked locklessly (see put_cpu_partial), so\n\t * we have to make sure the change is visible before shrinking.\n\t */\n\tslab_deactivate_memcg_cache_rcu_sched(s, kmemcg_cache_deact_after_rcu);\n}"
  },
  {
    "function_name": "kmemcg_cache_deact_after_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "4020-4036",
    "snippet": "static void kmemcg_cache_deact_after_rcu(struct kmem_cache *s)\n{\n\t/*\n\t * Called with all the locks held after a sched RCU grace period.\n\t * Even if @s becomes empty after shrinking, we can't know that @s\n\t * doesn't have allocations already in-flight and thus can't\n\t * destroy @s until the associated memcg is released.\n\t *\n\t * However, let's remove the sysfs files for empty caches here.\n\t * Each cache has a lot of interface files which aren't\n\t * particularly useful for empty draining caches; otherwise, we can\n\t * easily end up with millions of unnecessary sysfs files on\n\t * systems which have a lot of memory and transient cgroups.\n\t */\n\tif (!__kmem_cache_shrink(s))\n\t\tsysfs_slab_remove(s);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysfs_slab_remove",
          "args": [
            "s"
          ],
          "line": 4035
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_slab_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "5772-5783",
          "snippet": "static void sysfs_slab_remove(struct kmem_cache *s)\n{\n\tif (slab_state < FULL)\n\t\t/*\n\t\t * Sysfs has not been setup yet so no need to remove the\n\t\t * cache from sysfs.\n\t\t */\n\t\treturn;\n\n\tkobject_get(&s->kobj);\n\tschedule_work(&s->kobj_remove_work);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void sysfs_slab_remove(struct kmem_cache *s)\n{\n\tif (slab_state < FULL)\n\t\t/*\n\t\t * Sysfs has not been setup yet so no need to remove the\n\t\t * cache from sysfs.\n\t\t */\n\t\treturn;\n\n\tkobject_get(&s->kobj);\n\tschedule_work(&s->kobj_remove_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__kmem_cache_shrink",
          "args": [
            "s"
          ],
          "line": 4034
        },
        "resolved": true,
        "details": {
          "function_name": "__kmem_cache_shrink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "3957-4017",
          "snippet": "int __kmem_cache_shrink(struct kmem_cache *s)\n{\n\tint node;\n\tint i;\n\tstruct kmem_cache_node *n;\n\tstruct page *page;\n\tstruct page *t;\n\tstruct list_head discard;\n\tstruct list_head promote[SHRINK_PROMOTE_MAX];\n\tunsigned long flags;\n\tint ret = 0;\n\n\tflush_all(s);\n\tfor_each_kmem_cache_node(s, node, n) {\n\t\tINIT_LIST_HEAD(&discard);\n\t\tfor (i = 0; i < SHRINK_PROMOTE_MAX; i++)\n\t\t\tINIT_LIST_HEAD(promote + i);\n\n\t\tspin_lock_irqsave(&n->list_lock, flags);\n\n\t\t/*\n\t\t * Build lists of slabs to discard or promote.\n\t\t *\n\t\t * Note that concurrent frees may occur while we hold the\n\t\t * list_lock. page->inuse here is the upper limit.\n\t\t */\n\t\tlist_for_each_entry_safe(page, t, &n->partial, lru) {\n\t\t\tint free = page->objects - page->inuse;\n\n\t\t\t/* Do not reread page->inuse */\n\t\t\tbarrier();\n\n\t\t\t/* We do not keep full slabs on the list */\n\t\t\tBUG_ON(free <= 0);\n\n\t\t\tif (free == page->objects) {\n\t\t\t\tlist_move(&page->lru, &discard);\n\t\t\t\tn->nr_partial--;\n\t\t\t} else if (free <= SHRINK_PROMOTE_MAX)\n\t\t\t\tlist_move(&page->lru, promote + free - 1);\n\t\t}\n\n\t\t/*\n\t\t * Promote the slabs filled up most to the head of the\n\t\t * partial list.\n\t\t */\n\t\tfor (i = SHRINK_PROMOTE_MAX - 1; i >= 0; i--)\n\t\t\tlist_splice(promote + i, &n->partial);\n\n\t\tspin_unlock_irqrestore(&n->list_lock, flags);\n\n\t\t/* Release empty slabs */\n\t\tlist_for_each_entry_safe(page, t, &discard, lru)\n\t\t\tdiscard_slab(s, page);\n\n\t\tif (slabs_node(s, node))\n\t\t\tret = 1;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SHRINK_PROMOTE_MAX 32"
          ],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define SHRINK_PROMOTE_MAX 32\n\nstatic struct kmem_cache *kmem_cache_node;\n\nint __kmem_cache_shrink(struct kmem_cache *s)\n{\n\tint node;\n\tint i;\n\tstruct kmem_cache_node *n;\n\tstruct page *page;\n\tstruct page *t;\n\tstruct list_head discard;\n\tstruct list_head promote[SHRINK_PROMOTE_MAX];\n\tunsigned long flags;\n\tint ret = 0;\n\n\tflush_all(s);\n\tfor_each_kmem_cache_node(s, node, n) {\n\t\tINIT_LIST_HEAD(&discard);\n\t\tfor (i = 0; i < SHRINK_PROMOTE_MAX; i++)\n\t\t\tINIT_LIST_HEAD(promote + i);\n\n\t\tspin_lock_irqsave(&n->list_lock, flags);\n\n\t\t/*\n\t\t * Build lists of slabs to discard or promote.\n\t\t *\n\t\t * Note that concurrent frees may occur while we hold the\n\t\t * list_lock. page->inuse here is the upper limit.\n\t\t */\n\t\tlist_for_each_entry_safe(page, t, &n->partial, lru) {\n\t\t\tint free = page->objects - page->inuse;\n\n\t\t\t/* Do not reread page->inuse */\n\t\t\tbarrier();\n\n\t\t\t/* We do not keep full slabs on the list */\n\t\t\tBUG_ON(free <= 0);\n\n\t\t\tif (free == page->objects) {\n\t\t\t\tlist_move(&page->lru, &discard);\n\t\t\t\tn->nr_partial--;\n\t\t\t} else if (free <= SHRINK_PROMOTE_MAX)\n\t\t\t\tlist_move(&page->lru, promote + free - 1);\n\t\t}\n\n\t\t/*\n\t\t * Promote the slabs filled up most to the head of the\n\t\t * partial list.\n\t\t */\n\t\tfor (i = SHRINK_PROMOTE_MAX - 1; i >= 0; i--)\n\t\t\tlist_splice(promote + i, &n->partial);\n\n\t\tspin_unlock_irqrestore(&n->list_lock, flags);\n\n\t\t/* Release empty slabs */\n\t\tlist_for_each_entry_safe(page, t, &discard, lru)\n\t\t\tdiscard_slab(s, page);\n\n\t\tif (slabs_node(s, node))\n\t\t\tret = 1;\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void kmemcg_cache_deact_after_rcu(struct kmem_cache *s)\n{\n\t/*\n\t * Called with all the locks held after a sched RCU grace period.\n\t * Even if @s becomes empty after shrinking, we can't know that @s\n\t * doesn't have allocations already in-flight and thus can't\n\t * destroy @s until the associated memcg is released.\n\t *\n\t * However, let's remove the sysfs files for empty caches here.\n\t * Each cache has a lot of interface files which aren't\n\t * particularly useful for empty draining caches; otherwise, we can\n\t * easily end up with millions of unnecessary sysfs files on\n\t * systems which have a lot of memory and transient cgroups.\n\t */\n\tif (!__kmem_cache_shrink(s))\n\t\tsysfs_slab_remove(s);\n}"
  },
  {
    "function_name": "__kmem_cache_shrink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "3957-4017",
    "snippet": "int __kmem_cache_shrink(struct kmem_cache *s)\n{\n\tint node;\n\tint i;\n\tstruct kmem_cache_node *n;\n\tstruct page *page;\n\tstruct page *t;\n\tstruct list_head discard;\n\tstruct list_head promote[SHRINK_PROMOTE_MAX];\n\tunsigned long flags;\n\tint ret = 0;\n\n\tflush_all(s);\n\tfor_each_kmem_cache_node(s, node, n) {\n\t\tINIT_LIST_HEAD(&discard);\n\t\tfor (i = 0; i < SHRINK_PROMOTE_MAX; i++)\n\t\t\tINIT_LIST_HEAD(promote + i);\n\n\t\tspin_lock_irqsave(&n->list_lock, flags);\n\n\t\t/*\n\t\t * Build lists of slabs to discard or promote.\n\t\t *\n\t\t * Note that concurrent frees may occur while we hold the\n\t\t * list_lock. page->inuse here is the upper limit.\n\t\t */\n\t\tlist_for_each_entry_safe(page, t, &n->partial, lru) {\n\t\t\tint free = page->objects - page->inuse;\n\n\t\t\t/* Do not reread page->inuse */\n\t\t\tbarrier();\n\n\t\t\t/* We do not keep full slabs on the list */\n\t\t\tBUG_ON(free <= 0);\n\n\t\t\tif (free == page->objects) {\n\t\t\t\tlist_move(&page->lru, &discard);\n\t\t\t\tn->nr_partial--;\n\t\t\t} else if (free <= SHRINK_PROMOTE_MAX)\n\t\t\t\tlist_move(&page->lru, promote + free - 1);\n\t\t}\n\n\t\t/*\n\t\t * Promote the slabs filled up most to the head of the\n\t\t * partial list.\n\t\t */\n\t\tfor (i = SHRINK_PROMOTE_MAX - 1; i >= 0; i--)\n\t\t\tlist_splice(promote + i, &n->partial);\n\n\t\tspin_unlock_irqrestore(&n->list_lock, flags);\n\n\t\t/* Release empty slabs */\n\t\tlist_for_each_entry_safe(page, t, &discard, lru)\n\t\t\tdiscard_slab(s, page);\n\n\t\tif (slabs_node(s, node))\n\t\t\tret = 1;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define SHRINK_PROMOTE_MAX 32"
    ],
    "globals_used": [
      "static struct kmem_cache *kmem_cache_node;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slabs_node",
          "args": [
            "s",
            "node"
          ],
          "line": 4012
        },
        "resolved": true,
        "details": {
          "function_name": "slabs_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1360-1361",
          "snippet": "static inline unsigned long slabs_node(struct kmem_cache *s, int node)\n\t\t\t\t\t\t\t{ return 0; }",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline unsigned long slabs_node(struct kmem_cache *s, int node)\n\t\t\t\t\t\t\t{ return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "discard_slab",
          "args": [
            "s",
            "page"
          ],
          "line": 4010
        },
        "resolved": true,
        "details": {
          "function_name": "discard_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1740-1744",
          "snippet": "static void discard_slab(struct kmem_cache *s, struct page *page)\n{\n\tdec_slabs_node(s, page_to_nid(page), page->objects);\n\tfree_slab(s, page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void discard_slab(struct kmem_cache *s, struct page *page)\n{\n\tdec_slabs_node(s, page_to_nid(page), page->objects);\n\tfree_slab(s, page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "page",
            "t",
            "&discard",
            "lru"
          ],
          "line": 4009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&n->list_lock",
            "flags"
          ],
          "line": 4006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice",
          "args": [
            "promote + i",
            "&n->partial"
          ],
          "line": 4004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&page->lru",
            "promote + free - 1"
          ],
          "line": 3996
        },
        "resolved": true,
        "details": {
          "function_name": "qlist_move_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/quarantine.c",
          "lines": "72-88",
          "snippet": "static void qlist_move_all(struct qlist_head *from, struct qlist_head *to)\n{\n\tif (unlikely(qlist_empty(from)))\n\t\treturn;\n\n\tif (qlist_empty(to)) {\n\t\t*to = *from;\n\t\tqlist_init(from);\n\t\treturn;\n\t}\n\n\tto->tail->next = from->head;\n\tto->tail = from->tail;\n\tto->bytes += from->bytes;\n\n\tqlist_init(from);\n}",
          "includes": [
            "#include \"kasan.h\"",
            "#include \"../slab.h\"",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/srcu.h>",
            "#include <linux/slab.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/printk.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hash.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kasan.h\"\n#include \"../slab.h\"\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/srcu.h>\n#include <linux/slab.h>\n#include <linux/shrinker.h>\n#include <linux/printk.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/hash.h>\n#include <linux/gfp.h>\n\nstatic void qlist_move_all(struct qlist_head *from, struct qlist_head *to)\n{\n\tif (unlikely(qlist_empty(from)))\n\t\treturn;\n\n\tif (qlist_empty(to)) {\n\t\t*to = *from;\n\t\tqlist_init(from);\n\t\treturn;\n\t}\n\n\tto->tail->next = from->head;\n\tto->tail = from->tail;\n\tto->bytes += from->bytes;\n\n\tqlist_init(from);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "free <= 0"
          ],
          "line": 3990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 3987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "page",
            "t",
            "&n->partial",
            "lru"
          ],
          "line": 3983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&n->list_lock",
            "flags"
          ],
          "line": 3975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "promote + i"
          ],
          "line": 3973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&discard"
          ],
          "line": 3971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_kmem_cache_node",
          "args": [
            "s",
            "node",
            "n"
          ],
          "line": 3970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_all",
          "args": [
            "s"
          ],
          "line": 3969
        },
        "resolved": true,
        "details": {
          "function_name": "flush_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2339-2342",
          "snippet": "static void flush_all(struct kmem_cache *s)\n{\n\ton_each_cpu_cond(has_cpu_slab, flush_cpu_slab, s, 1, GFP_ATOMIC);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void flush_all(struct kmem_cache *s)\n{\n\ton_each_cpu_cond(has_cpu_slab, flush_cpu_slab, s, 1, GFP_ATOMIC);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define SHRINK_PROMOTE_MAX 32\n\nstatic struct kmem_cache *kmem_cache_node;\n\nint __kmem_cache_shrink(struct kmem_cache *s)\n{\n\tint node;\n\tint i;\n\tstruct kmem_cache_node *n;\n\tstruct page *page;\n\tstruct page *t;\n\tstruct list_head discard;\n\tstruct list_head promote[SHRINK_PROMOTE_MAX];\n\tunsigned long flags;\n\tint ret = 0;\n\n\tflush_all(s);\n\tfor_each_kmem_cache_node(s, node, n) {\n\t\tINIT_LIST_HEAD(&discard);\n\t\tfor (i = 0; i < SHRINK_PROMOTE_MAX; i++)\n\t\t\tINIT_LIST_HEAD(promote + i);\n\n\t\tspin_lock_irqsave(&n->list_lock, flags);\n\n\t\t/*\n\t\t * Build lists of slabs to discard or promote.\n\t\t *\n\t\t * Note that concurrent frees may occur while we hold the\n\t\t * list_lock. page->inuse here is the upper limit.\n\t\t */\n\t\tlist_for_each_entry_safe(page, t, &n->partial, lru) {\n\t\t\tint free = page->objects - page->inuse;\n\n\t\t\t/* Do not reread page->inuse */\n\t\t\tbarrier();\n\n\t\t\t/* We do not keep full slabs on the list */\n\t\t\tBUG_ON(free <= 0);\n\n\t\t\tif (free == page->objects) {\n\t\t\t\tlist_move(&page->lru, &discard);\n\t\t\t\tn->nr_partial--;\n\t\t\t} else if (free <= SHRINK_PROMOTE_MAX)\n\t\t\t\tlist_move(&page->lru, promote + free - 1);\n\t\t}\n\n\t\t/*\n\t\t * Promote the slabs filled up most to the head of the\n\t\t * partial list.\n\t\t */\n\t\tfor (i = SHRINK_PROMOTE_MAX - 1; i >= 0; i--)\n\t\t\tlist_splice(promote + i, &n->partial);\n\n\t\tspin_unlock_irqrestore(&n->list_lock, flags);\n\n\t\t/* Release empty slabs */\n\t\tlist_for_each_entry_safe(page, t, &discard, lru)\n\t\t\tdiscard_slab(s, page);\n\n\t\tif (slabs_node(s, node))\n\t\t\tret = 1;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "kfree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "3925-3943",
    "snippet": "void kfree(const void *x)\n{\n\tstruct page *page;\n\tvoid *object = (void *)x;\n\n\ttrace_kfree(_RET_IP_, x);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(x)))\n\t\treturn;\n\n\tpage = virt_to_head_page(x);\n\tif (unlikely(!PageSlab(page))) {\n\t\tBUG_ON(!PageCompound(page));\n\t\tkfree_hook(object);\n\t\t__free_pages(page, compound_order(page));\n\t\treturn;\n\t}\n\tslab_free(page->slab_cache, page, object, NULL, 1, _RET_IP_);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "slab_free",
          "args": [
            "page->slab_cache",
            "page",
            "object",
            "NULL",
            "1",
            "_RET_IP_"
          ],
          "line": 3942
        },
        "resolved": true,
        "details": {
          "function_name": "slab_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2983-2993",
          "snippet": "static __always_inline void slab_free(struct kmem_cache *s, struct page *page,\n\t\t\t\t      void *head, void *tail, int cnt,\n\t\t\t\t      unsigned long addr)\n{\n\t/*\n\t * With KASAN enabled slab_free_freelist_hook modifies the freelist\n\t * to remove objects, whose reuse must be delayed.\n\t */\n\tif (slab_free_freelist_hook(s, &head, &tail))\n\t\tdo_slab_free(s, page, head, tail, cnt, addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic __always_inline void slab_free(struct kmem_cache *s, struct page *page,\n\t\t\t\t      void *head, void *tail, int cnt,\n\t\t\t\t      unsigned long addr)\n{\n\t/*\n\t * With KASAN enabled slab_free_freelist_hook modifies the freelist\n\t * to remove objects, whose reuse must be delayed.\n\t */\n\tif (slab_free_freelist_hook(s, &head, &tail))\n\t\tdo_slab_free(s, page, head, tail, cnt, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_pages",
          "args": [
            "page",
            "compound_order(page)"
          ],
          "line": 3939
        },
        "resolved": true,
        "details": {
          "function_name": "__free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4430-4438",
          "snippet": "void __free_pages(struct page *page, unsigned int order)\n{\n\tif (put_page_testzero(page)) {\n\t\tif (order == 0)\n\t\t\tfree_unref_page(page);\n\t\telse\n\t\t\t__free_pages_ok(page, order);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid __free_pages(struct page *page, unsigned int order)\n{\n\tif (put_page_testzero(page)) {\n\t\tif (order == 0)\n\t\t\tfree_unref_page(page);\n\t\telse\n\t\t\t__free_pages_ok(page, order);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "page"
          ],
          "line": 3939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree_hook",
          "args": [
            "object"
          ],
          "line": 3938
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_hook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1381-1385",
          "snippet": "static __always_inline void kfree_hook(void *x)\n{\n\tkmemleak_free(x);\n\tkasan_kfree_large(x, _RET_IP_);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic __always_inline void kfree_hook(void *x)\n{\n\tkmemleak_free(x);\n\tkasan_kfree_large(x, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageCompound(page)"
          ],
          "line": 3937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "page"
          ],
          "line": 3937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!PageSlab(page)"
          ],
          "line": 3936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSlab",
          "args": [
            "page"
          ],
          "line": 3936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_head_page",
          "args": [
            "x"
          ],
          "line": 3935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ZERO_OR_NULL_PTR(x)"
          ],
          "line": 3932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ZERO_OR_NULL_PTR",
          "args": [
            "x"
          ],
          "line": 3932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kfree",
          "args": [
            "_RET_IP_",
            "x"
          ],
          "line": 3930
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid kfree(const void *x)\n{\n\tstruct page *page;\n\tvoid *object = (void *)x;\n\n\ttrace_kfree(_RET_IP_, x);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(x)))\n\t\treturn;\n\n\tpage = virt_to_head_page(x);\n\tif (unlikely(!PageSlab(page))) {\n\t\tBUG_ON(!PageCompound(page));\n\t\tkfree_hook(object);\n\t\t__free_pages(page, compound_order(page));\n\t\treturn;\n\t}\n\tslab_free(page->slab_cache, page, object, NULL, 1, _RET_IP_);\n}"
  },
  {
    "function_name": "ksize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "3914-3922",
    "snippet": "size_t ksize(const void *object)\n{\n\tsize_t size = __ksize(object);\n\t/* We assume that ksize callers could use whole allocated area,\n\t * so we need to unpoison this area.\n\t */\n\tkasan_unpoison_shadow(object, size);\n\treturn size;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kasan_unpoison_shadow",
          "args": [
            "object",
            "size"
          ],
          "line": 3920
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_unpoison_shadow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "67-75",
          "snippet": "void kasan_unpoison_shadow(const void *address, size_t size)\n{\n\tkasan_poison_shadow(address, size, 0);\n\n\tif (size & KASAN_SHADOW_MASK) {\n\t\tu8 *shadow = (u8 *)kasan_mem_to_shadow(address + size);\n\t\t*shadow = size & KASAN_SHADOW_MASK;\n\t}\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid kasan_unpoison_shadow(const void *address, size_t size)\n{\n\tkasan_poison_shadow(address, size, 0);\n\n\tif (size & KASAN_SHADOW_MASK) {\n\t\tu8 *shadow = (u8 *)kasan_mem_to_shadow(address + size);\n\t\t*shadow = size & KASAN_SHADOW_MASK;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ksize",
          "args": [
            "object"
          ],
          "line": 3916
        },
        "resolved": true,
        "details": {
          "function_name": "__ksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "3897-3912",
          "snippet": "static size_t __ksize(const void *object)\n{\n\tstruct page *page;\n\n\tif (unlikely(object == ZERO_SIZE_PTR))\n\t\treturn 0;\n\n\tpage = virt_to_head_page(object);\n\n\tif (unlikely(!PageSlab(page))) {\n\t\tWARN_ON(!PageCompound(page));\n\t\treturn PAGE_SIZE << compound_order(page);\n\t}\n\n\treturn slab_ksize(page->slab_cache);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic size_t __ksize(const void *object)\n{\n\tstruct page *page;\n\n\tif (unlikely(object == ZERO_SIZE_PTR))\n\t\treturn 0;\n\n\tpage = virt_to_head_page(object);\n\n\tif (unlikely(!PageSlab(page))) {\n\t\tWARN_ON(!PageCompound(page));\n\t\treturn PAGE_SIZE << compound_order(page);\n\t}\n\n\treturn slab_ksize(page->slab_cache);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nsize_t ksize(const void *object)\n{\n\tsize_t size = __ksize(object);\n\t/* We assume that ksize callers could use whole allocated area,\n\t * so we need to unpoison this area.\n\t */\n\tkasan_unpoison_shadow(object, size);\n\treturn size;\n}"
  },
  {
    "function_name": "__ksize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "3897-3912",
    "snippet": "static size_t __ksize(const void *object)\n{\n\tstruct page *page;\n\n\tif (unlikely(object == ZERO_SIZE_PTR))\n\t\treturn 0;\n\n\tpage = virt_to_head_page(object);\n\n\tif (unlikely(!PageSlab(page))) {\n\t\tWARN_ON(!PageCompound(page));\n\t\treturn PAGE_SIZE << compound_order(page);\n\t}\n\n\treturn slab_ksize(page->slab_cache);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "slab_ksize",
          "args": [
            "page->slab_cache"
          ],
          "line": 3911
        },
        "resolved": true,
        "details": {
          "function_name": "slab_ksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "383-411",
          "snippet": "static inline size_t slab_ksize(const struct kmem_cache *s)\n{\n#ifndef CONFIG_SLUB\n\treturn s->object_size;\n\n#else /* CONFIG_SLUB */\n# ifdef CONFIG_SLUB_DEBUG\n\t/*\n\t * Debugging requires use of the padding between object\n\t * and whatever may come after it.\n\t */\n\tif (s->flags & (SLAB_RED_ZONE | SLAB_POISON))\n\t\treturn s->object_size;\n# endif\n\tif (s->flags & SLAB_KASAN)\n\t\treturn s->object_size;\n\t/*\n\t * If we have the need to store the freelist pointer\n\t * back there or track user information then we can\n\t * only use the space before that information.\n\t */\n\tif (s->flags & (SLAB_TYPESAFE_BY_RCU | SLAB_STORE_USER))\n\t\treturn s->inuse;\n\t/*\n\t * Else we can use all the padding etc for the allocation\n\t */\n\treturn s->size;\n#endif\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline size_t slab_ksize(const struct kmem_cache *s)\n{\n#ifndef CONFIG_SLUB\n\treturn s->object_size;\n\n#else /* CONFIG_SLUB */\n# ifdef CONFIG_SLUB_DEBUG\n\t/*\n\t * Debugging requires use of the padding between object\n\t * and whatever may come after it.\n\t */\n\tif (s->flags & (SLAB_RED_ZONE | SLAB_POISON))\n\t\treturn s->object_size;\n# endif\n\tif (s->flags & SLAB_KASAN)\n\t\treturn s->object_size;\n\t/*\n\t * If we have the need to store the freelist pointer\n\t * back there or track user information then we can\n\t * only use the space before that information.\n\t */\n\tif (s->flags & (SLAB_TYPESAFE_BY_RCU | SLAB_STORE_USER))\n\t\treturn s->inuse;\n\t/*\n\t * Else we can use all the padding etc for the allocation\n\t */\n\treturn s->size;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "page"
          ],
          "line": 3908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!PageCompound(page)"
          ],
          "line": 3907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "page"
          ],
          "line": 3907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!PageSlab(page)"
          ],
          "line": 3906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSlab",
          "args": [
            "page"
          ],
          "line": 3906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_head_page",
          "args": [
            "object"
          ],
          "line": 3904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "object == ZERO_SIZE_PTR"
          ],
          "line": 3901
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic size_t __ksize(const void *object)\n{\n\tstruct page *page;\n\n\tif (unlikely(object == ZERO_SIZE_PTR))\n\t\treturn 0;\n\n\tpage = virt_to_head_page(object);\n\n\tif (unlikely(!PageSlab(page))) {\n\t\tWARN_ON(!PageCompound(page));\n\t\treturn PAGE_SIZE << compound_order(page);\n\t}\n\n\treturn slab_ksize(page->slab_cache);\n}"
  },
  {
    "function_name": "__check_heap_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "3848-3894",
    "snippet": "void __check_heap_object(const void *ptr, unsigned long n, struct page *page,\n\t\t\t bool to_user)\n{\n\tstruct kmem_cache *s;\n\tunsigned int offset;\n\tsize_t object_size;\n\n\t/* Find object and usable object size. */\n\ts = page->slab_cache;\n\n\t/* Reject impossible pointers. */\n\tif (ptr < page_address(page))\n\t\tusercopy_abort(\"SLUB object not in SLUB page?!\", NULL,\n\t\t\t       to_user, 0, n);\n\n\t/* Find offset within object. */\n\toffset = (ptr - page_address(page)) % s->size;\n\n\t/* Adjust for redzone and reject if within the redzone. */\n\tif (kmem_cache_debug(s) && s->flags & SLAB_RED_ZONE) {\n\t\tif (offset < s->red_left_pad)\n\t\t\tusercopy_abort(\"SLUB object in left red zone\",\n\t\t\t\t       s->name, to_user, offset, n);\n\t\toffset -= s->red_left_pad;\n\t}\n\n\t/* Allow address range falling entirely within usercopy region. */\n\tif (offset >= s->useroffset &&\n\t    offset - s->useroffset <= s->usersize &&\n\t    n <= s->useroffset - offset + s->usersize)\n\t\treturn;\n\n\t/*\n\t * If the copy is still within the allocated object, produce\n\t * a warning instead of rejecting the copy. This is intended\n\t * to be a temporary method to find any missing usercopy\n\t * whitelists.\n\t */\n\tobject_size = slab_ksize(s);\n\tif (usercopy_fallback &&\n\t    offset <= object_size && n <= object_size - offset) {\n\t\tusercopy_warn(\"SLUB object\", s->name, to_user, offset, n);\n\t\treturn;\n\t}\n\n\tusercopy_abort(\"SLUB object\", s->name, to_user, offset, n);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "usercopy_abort",
          "args": [
            "\"SLUB object\"",
            "s->name",
            "to_user",
            "offset",
            "n"
          ],
          "line": 3893
        },
        "resolved": true,
        "details": {
          "function_name": "usercopy_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/usercopy.c",
          "lines": "86-103",
          "snippet": "void __noreturn usercopy_abort(const char *name, const char *detail,\n\t\t\t       bool to_user, unsigned long offset,\n\t\t\t       unsigned long len)\n{\n\tpr_emerg(\"Kernel memory %s attempt detected %s %s%s%s%s (offset %lu, size %lu)!\\n\",\n\t\t to_user ? \"exposure\" : \"overwrite\",\n\t\t to_user ? \"from\" : \"to\",\n\t\t name ? : \"unknown?!\",\n\t\t detail ? \" '\" : \"\", detail ? : \"\", detail ? \"'\" : \"\",\n\t\t offset, len);\n\n\t/*\n\t * For greater effect, it would be nice to do do_group_exit(),\n\t * but BUG() actually hooks all the lock-breaking and per-arch\n\t * Oops code, so that is used here instead.\n\t */\n\tBUG();\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <linux/thread_info.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid __noreturn usercopy_abort(const char *name, const char *detail,\n\t\t\t       bool to_user, unsigned long offset,\n\t\t\t       unsigned long len)\n{\n\tpr_emerg(\"Kernel memory %s attempt detected %s %s%s%s%s (offset %lu, size %lu)!\\n\",\n\t\t to_user ? \"exposure\" : \"overwrite\",\n\t\t to_user ? \"from\" : \"to\",\n\t\t name ? : \"unknown?!\",\n\t\t detail ? \" '\" : \"\", detail ? : \"\", detail ? \"'\" : \"\",\n\t\t offset, len);\n\n\t/*\n\t * For greater effect, it would be nice to do do_group_exit(),\n\t * but BUG() actually hooks all the lock-breaking and per-arch\n\t * Oops code, so that is used here instead.\n\t */\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "usercopy_warn",
          "args": [
            "\"SLUB object\"",
            "s->name",
            "to_user",
            "offset",
            "n"
          ],
          "line": 3889
        },
        "resolved": true,
        "details": {
          "function_name": "usercopy_warn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/usercopy.c",
          "lines": "75-84",
          "snippet": "void usercopy_warn(const char *name, const char *detail, bool to_user,\n\t\t   unsigned long offset, unsigned long len)\n{\n\tWARN_ONCE(1, \"Bad or missing usercopy whitelist? Kernel memory %s attempt detected %s %s%s%s%s (offset %lu, size %lu)!\\n\",\n\t\t to_user ? \"exposure\" : \"overwrite\",\n\t\t to_user ? \"from\" : \"to\",\n\t\t name ? : \"unknown?!\",\n\t\t detail ? \" '\" : \"\", detail ? : \"\", detail ? \"'\" : \"\",\n\t\t offset, len);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <linux/thread_info.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid usercopy_warn(const char *name, const char *detail, bool to_user,\n\t\t   unsigned long offset, unsigned long len)\n{\n\tWARN_ONCE(1, \"Bad or missing usercopy whitelist? Kernel memory %s attempt detected %s %s%s%s%s (offset %lu, size %lu)!\\n\",\n\t\t to_user ? \"exposure\" : \"overwrite\",\n\t\t to_user ? \"from\" : \"to\",\n\t\t name ? : \"unknown?!\",\n\t\t detail ? \" '\" : \"\", detail ? : \"\", detail ? \"'\" : \"\",\n\t\t offset, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "slab_ksize",
          "args": [
            "s"
          ],
          "line": 3886
        },
        "resolved": true,
        "details": {
          "function_name": "slab_ksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "383-411",
          "snippet": "static inline size_t slab_ksize(const struct kmem_cache *s)\n{\n#ifndef CONFIG_SLUB\n\treturn s->object_size;\n\n#else /* CONFIG_SLUB */\n# ifdef CONFIG_SLUB_DEBUG\n\t/*\n\t * Debugging requires use of the padding between object\n\t * and whatever may come after it.\n\t */\n\tif (s->flags & (SLAB_RED_ZONE | SLAB_POISON))\n\t\treturn s->object_size;\n# endif\n\tif (s->flags & SLAB_KASAN)\n\t\treturn s->object_size;\n\t/*\n\t * If we have the need to store the freelist pointer\n\t * back there or track user information then we can\n\t * only use the space before that information.\n\t */\n\tif (s->flags & (SLAB_TYPESAFE_BY_RCU | SLAB_STORE_USER))\n\t\treturn s->inuse;\n\t/*\n\t * Else we can use all the padding etc for the allocation\n\t */\n\treturn s->size;\n#endif\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline size_t slab_ksize(const struct kmem_cache *s)\n{\n#ifndef CONFIG_SLUB\n\treturn s->object_size;\n\n#else /* CONFIG_SLUB */\n# ifdef CONFIG_SLUB_DEBUG\n\t/*\n\t * Debugging requires use of the padding between object\n\t * and whatever may come after it.\n\t */\n\tif (s->flags & (SLAB_RED_ZONE | SLAB_POISON))\n\t\treturn s->object_size;\n# endif\n\tif (s->flags & SLAB_KASAN)\n\t\treturn s->object_size;\n\t/*\n\t * If we have the need to store the freelist pointer\n\t * back there or track user information then we can\n\t * only use the space before that information.\n\t */\n\tif (s->flags & (SLAB_TYPESAFE_BY_RCU | SLAB_STORE_USER))\n\t\treturn s->inuse;\n\t/*\n\t * Else we can use all the padding etc for the allocation\n\t */\n\treturn s->size;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_debug",
          "args": [
            "s"
          ],
          "line": 3867
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "118-125",
          "snippet": "static inline int kmem_cache_debug(struct kmem_cache *s)\n{\n#ifdef CONFIG_SLUB_DEBUG\n\treturn unlikely(s->flags & SLAB_DEBUG_FLAGS);\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline int kmem_cache_debug(struct kmem_cache *s)\n{\n#ifdef CONFIG_SLUB_DEBUG\n\treturn unlikely(s->flags & SLAB_DEBUG_FLAGS);\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 3864
        },
        "resolved": true,
        "details": {
          "function_name": "page_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "409-434",
          "snippet": "void *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid __check_heap_object(const void *ptr, unsigned long n, struct page *page,\n\t\t\t bool to_user)\n{\n\tstruct kmem_cache *s;\n\tunsigned int offset;\n\tsize_t object_size;\n\n\t/* Find object and usable object size. */\n\ts = page->slab_cache;\n\n\t/* Reject impossible pointers. */\n\tif (ptr < page_address(page))\n\t\tusercopy_abort(\"SLUB object not in SLUB page?!\", NULL,\n\t\t\t       to_user, 0, n);\n\n\t/* Find offset within object. */\n\toffset = (ptr - page_address(page)) % s->size;\n\n\t/* Adjust for redzone and reject if within the redzone. */\n\tif (kmem_cache_debug(s) && s->flags & SLAB_RED_ZONE) {\n\t\tif (offset < s->red_left_pad)\n\t\t\tusercopy_abort(\"SLUB object in left red zone\",\n\t\t\t\t       s->name, to_user, offset, n);\n\t\toffset -= s->red_left_pad;\n\t}\n\n\t/* Allow address range falling entirely within usercopy region. */\n\tif (offset >= s->useroffset &&\n\t    offset - s->useroffset <= s->usersize &&\n\t    n <= s->useroffset - offset + s->usersize)\n\t\treturn;\n\n\t/*\n\t * If the copy is still within the allocated object, produce\n\t * a warning instead of rejecting the copy. This is intended\n\t * to be a temporary method to find any missing usercopy\n\t * whitelists.\n\t */\n\tobject_size = slab_ksize(s);\n\tif (usercopy_fallback &&\n\t    offset <= object_size && n <= object_size - offset) {\n\t\tusercopy_warn(\"SLUB object\", s->name, to_user, offset, n);\n\t\treturn;\n\t}\n\n\tusercopy_abort(\"SLUB object\", s->name, to_user, offset, n);\n}"
  },
  {
    "function_name": "__kmalloc_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "3808-3835",
    "snippet": "void *__kmalloc_node(size_t size, gfp_t flags, int node)\n{\n\tstruct kmem_cache *s;\n\tvoid *ret;\n\n\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE)) {\n\t\tret = kmalloc_large_node(size, flags, node);\n\n\t\ttrace_kmalloc_node(_RET_IP_, ret,\n\t\t\t\t   size, PAGE_SIZE << get_order(size),\n\t\t\t\t   flags, node);\n\n\t\treturn ret;\n\t}\n\n\ts = kmalloc_slab(size, flags);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(s)))\n\t\treturn s;\n\n\tret = slab_alloc_node(s, flags, node, _RET_IP_);\n\n\ttrace_kmalloc_node(_RET_IP_, ret, size, s->size, flags, node);\n\n\tkasan_kmalloc(s, ret, size, flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kasan_kmalloc",
          "args": [
            "s",
            "ret",
            "size",
            "flags"
          ],
          "line": 3832
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "531-554",
          "snippet": "void kasan_kmalloc(struct kmem_cache *cache, const void *object, size_t size,\n\t\t   gfp_t flags)\n{\n\tunsigned long redzone_start;\n\tunsigned long redzone_end;\n\n\tif (gfpflags_allow_blocking(flags))\n\t\tquarantine_reduce();\n\n\tif (unlikely(object == NULL))\n\t\treturn;\n\n\tredzone_start = round_up((unsigned long)(object + size),\n\t\t\t\tKASAN_SHADOW_SCALE_SIZE);\n\tredzone_end = round_up((unsigned long)object + cache->object_size,\n\t\t\t\tKASAN_SHADOW_SCALE_SIZE);\n\n\tkasan_unpoison_shadow(object, size);\n\tkasan_poison_shadow((void *)redzone_start, redzone_end - redzone_start,\n\t\tKASAN_KMALLOC_REDZONE);\n\n\tif (cache->flags & SLAB_KASAN)\n\t\tset_track(&get_alloc_info(cache, object)->alloc_track, flags);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid kasan_kmalloc(struct kmem_cache *cache, const void *object, size_t size,\n\t\t   gfp_t flags)\n{\n\tunsigned long redzone_start;\n\tunsigned long redzone_end;\n\n\tif (gfpflags_allow_blocking(flags))\n\t\tquarantine_reduce();\n\n\tif (unlikely(object == NULL))\n\t\treturn;\n\n\tredzone_start = round_up((unsigned long)(object + size),\n\t\t\t\tKASAN_SHADOW_SCALE_SIZE);\n\tredzone_end = round_up((unsigned long)object + cache->object_size,\n\t\t\t\tKASAN_SHADOW_SCALE_SIZE);\n\n\tkasan_unpoison_shadow(object, size);\n\tkasan_poison_shadow((void *)redzone_start, redzone_end - redzone_start,\n\t\tKASAN_KMALLOC_REDZONE);\n\n\tif (cache->flags & SLAB_KASAN)\n\t\tset_track(&get_alloc_info(cache, object)->alloc_track, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kmalloc_node",
          "args": [
            "_RET_IP_",
            "ret",
            "size",
            "s->size",
            "flags",
            "node"
          ],
          "line": 3830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_alloc_node",
          "args": [
            "s",
            "flags",
            "node",
            "_RET_IP_"
          ],
          "line": 3828
        },
        "resolved": true,
        "details": {
          "function_name": "slab_alloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2662-2747",
          "snippet": "static __always_inline void *slab_alloc_node(struct kmem_cache *s,\n\t\tgfp_t gfpflags, int node, unsigned long addr)\n{\n\tvoid *object;\n\tstruct kmem_cache_cpu *c;\n\tstruct page *page;\n\tunsigned long tid;\n\n\ts = slab_pre_alloc_hook(s, gfpflags);\n\tif (!s)\n\t\treturn NULL;\nredo:\n\t/*\n\t * Must read kmem_cache cpu data via this cpu ptr. Preemption is\n\t * enabled. We may switch back and forth between cpus while\n\t * reading from one cpu area. That does not matter as long\n\t * as we end up on the original cpu again when doing the cmpxchg.\n\t *\n\t * We should guarantee that tid and kmem_cache are retrieved on\n\t * the same cpu. It could be different if CONFIG_PREEMPT so we need\n\t * to check if it is matched or not.\n\t */\n\tdo {\n\t\ttid = this_cpu_read(s->cpu_slab->tid);\n\t\tc = raw_cpu_ptr(s->cpu_slab);\n\t} while (IS_ENABLED(CONFIG_PREEMPT) &&\n\t\t unlikely(tid != READ_ONCE(c->tid)));\n\n\t/*\n\t * Irqless object alloc/free algorithm used here depends on sequence\n\t * of fetching cpu_slab's data. tid should be fetched before anything\n\t * on c to guarantee that object and page associated with previous tid\n\t * won't be used with current tid. If we fetch tid first, object and\n\t * page could be one associated with next tid and our alloc/free\n\t * request will be failed. In this case, we will retry. So, no problem.\n\t */\n\tbarrier();\n\n\t/*\n\t * The transaction ids are globally unique per cpu and per operation on\n\t * a per cpu queue. Thus they can be guarantee that the cmpxchg_double\n\t * occurs on the right processor and that there was no operation on the\n\t * linked list in between.\n\t */\n\n\tobject = c->freelist;\n\tpage = c->page;\n\tif (unlikely(!object || !node_match(page, node))) {\n\t\tobject = __slab_alloc(s, gfpflags, node, addr, c);\n\t\tstat(s, ALLOC_SLOWPATH);\n\t} else {\n\t\tvoid *next_object = get_freepointer_safe(s, object);\n\n\t\t/*\n\t\t * The cmpxchg will only match if there was no additional\n\t\t * operation and if we are on the right processor.\n\t\t *\n\t\t * The cmpxchg does the following atomically (without lock\n\t\t * semantics!)\n\t\t * 1. Relocate first pointer to the current per cpu area.\n\t\t * 2. Verify that tid and freelist have not been changed\n\t\t * 3. If they were not changed replace tid and freelist\n\t\t *\n\t\t * Since this is without lock semantics the protection is only\n\t\t * against code executing on this cpu *not* from access by\n\t\t * other cpus.\n\t\t */\n\t\tif (unlikely(!this_cpu_cmpxchg_double(\n\t\t\t\ts->cpu_slab->freelist, s->cpu_slab->tid,\n\t\t\t\tobject, tid,\n\t\t\t\tnext_object, next_tid(tid)))) {\n\n\t\t\tnote_cmpxchg_failure(\"slab_alloc\", s, tid);\n\t\t\tgoto redo;\n\t\t}\n\t\tprefetch_freepointer(s, next_object);\n\t\tstat(s, ALLOC_FASTPATH);\n\t}\n\n\tif (unlikely(gfpflags & __GFP_ZERO) && object)\n\t\tmemset(object, 0, s->object_size);\n\n\tslab_post_alloc_hook(s, gfpflags, 1, &object);\n\n\treturn object;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);\n\nstatic __always_inline void *slab_alloc_node(struct kmem_cache *s,\n\t\tgfp_t gfpflags, int node, unsigned long addr)\n{\n\tvoid *object;\n\tstruct kmem_cache_cpu *c;\n\tstruct page *page;\n\tunsigned long tid;\n\n\ts = slab_pre_alloc_hook(s, gfpflags);\n\tif (!s)\n\t\treturn NULL;\nredo:\n\t/*\n\t * Must read kmem_cache cpu data via this cpu ptr. Preemption is\n\t * enabled. We may switch back and forth between cpus while\n\t * reading from one cpu area. That does not matter as long\n\t * as we end up on the original cpu again when doing the cmpxchg.\n\t *\n\t * We should guarantee that tid and kmem_cache are retrieved on\n\t * the same cpu. It could be different if CONFIG_PREEMPT so we need\n\t * to check if it is matched or not.\n\t */\n\tdo {\n\t\ttid = this_cpu_read(s->cpu_slab->tid);\n\t\tc = raw_cpu_ptr(s->cpu_slab);\n\t} while (IS_ENABLED(CONFIG_PREEMPT) &&\n\t\t unlikely(tid != READ_ONCE(c->tid)));\n\n\t/*\n\t * Irqless object alloc/free algorithm used here depends on sequence\n\t * of fetching cpu_slab's data. tid should be fetched before anything\n\t * on c to guarantee that object and page associated with previous tid\n\t * won't be used with current tid. If we fetch tid first, object and\n\t * page could be one associated with next tid and our alloc/free\n\t * request will be failed. In this case, we will retry. So, no problem.\n\t */\n\tbarrier();\n\n\t/*\n\t * The transaction ids are globally unique per cpu and per operation on\n\t * a per cpu queue. Thus they can be guarantee that the cmpxchg_double\n\t * occurs on the right processor and that there was no operation on the\n\t * linked list in between.\n\t */\n\n\tobject = c->freelist;\n\tpage = c->page;\n\tif (unlikely(!object || !node_match(page, node))) {\n\t\tobject = __slab_alloc(s, gfpflags, node, addr, c);\n\t\tstat(s, ALLOC_SLOWPATH);\n\t} else {\n\t\tvoid *next_object = get_freepointer_safe(s, object);\n\n\t\t/*\n\t\t * The cmpxchg will only match if there was no additional\n\t\t * operation and if we are on the right processor.\n\t\t *\n\t\t * The cmpxchg does the following atomically (without lock\n\t\t * semantics!)\n\t\t * 1. Relocate first pointer to the current per cpu area.\n\t\t * 2. Verify that tid and freelist have not been changed\n\t\t * 3. If they were not changed replace tid and freelist\n\t\t *\n\t\t * Since this is without lock semantics the protection is only\n\t\t * against code executing on this cpu *not* from access by\n\t\t * other cpus.\n\t\t */\n\t\tif (unlikely(!this_cpu_cmpxchg_double(\n\t\t\t\ts->cpu_slab->freelist, s->cpu_slab->tid,\n\t\t\t\tobject, tid,\n\t\t\t\tnext_object, next_tid(tid)))) {\n\n\t\t\tnote_cmpxchg_failure(\"slab_alloc\", s, tid);\n\t\t\tgoto redo;\n\t\t}\n\t\tprefetch_freepointer(s, next_object);\n\t\tstat(s, ALLOC_FASTPATH);\n\t}\n\n\tif (unlikely(gfpflags & __GFP_ZERO) && object)\n\t\tmemset(object, 0, s->object_size);\n\n\tslab_post_alloc_hook(s, gfpflags, 1, &object);\n\n\treturn object;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ZERO_OR_NULL_PTR(s)"
          ],
          "line": 3825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ZERO_OR_NULL_PTR",
          "args": [
            "s"
          ],
          "line": 3825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_slab",
          "args": [
            "size",
            "flags"
          ],
          "line": 3823
        },
        "resolved": true,
        "details": {
          "function_name": "kmalloc_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "1022-1040",
          "snippet": "struct kmem_cache *kmalloc_slab(size_t size, gfp_t flags)\n{\n\tunsigned int index;\n\n\tif (size <= 192) {\n\t\tif (!size)\n\t\t\treturn ZERO_SIZE_PTR;\n\n\t\tindex = size_index[size_index_elem(size)];\n\t} else {\n\t\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE)) {\n\t\t\tWARN_ON(1);\n\t\t\treturn NULL;\n\t\t}\n\t\tindex = fls(size - 1);\n\t}\n\n\treturn kmalloc_caches[kmalloc_type(flags)][index];\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstruct kmem_cache *kmalloc_slab(size_t size, gfp_t flags)\n{\n\tunsigned int index;\n\n\tif (size <= 192) {\n\t\tif (!size)\n\t\t\treturn ZERO_SIZE_PTR;\n\n\t\tindex = size_index[size_index_elem(size)];\n\t} else {\n\t\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE)) {\n\t\t\tWARN_ON(1);\n\t\t\treturn NULL;\n\t\t}\n\t\tindex = fls(size - 1);\n\t}\n\n\treturn kmalloc_caches[kmalloc_type(flags)][index];\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kmalloc_node",
          "args": [
            "_RET_IP_",
            "ret",
            "size",
            "PAGE_SIZE << get_order(size)",
            "flags",
            "node"
          ],
          "line": 3816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "size"
          ],
          "line": 3817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_large_node",
          "args": [
            "size",
            "flags",
            "node"
          ],
          "line": 3814
        },
        "resolved": true,
        "details": {
          "function_name": "kmalloc_large_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "3794-3806",
          "snippet": "static void *kmalloc_large_node(size_t size, gfp_t flags, int node)\n{\n\tstruct page *page;\n\tvoid *ptr = NULL;\n\n\tflags |= __GFP_COMP;\n\tpage = alloc_pages_node(node, flags, get_order(size));\n\tif (page)\n\t\tptr = page_address(page);\n\n\tkmalloc_large_node_hook(ptr, size, flags);\n\treturn ptr;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void *kmalloc_large_node(size_t size, gfp_t flags, int node)\n{\n\tstruct page *page;\n\tvoid *ptr = NULL;\n\n\tflags |= __GFP_COMP;\n\tpage = alloc_pages_node(node, flags, get_order(size));\n\tif (page)\n\t\tptr = page_address(page);\n\n\tkmalloc_large_node_hook(ptr, size, flags);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "size > KMALLOC_MAX_CACHE_SIZE"
          ],
          "line": 3813
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid *__kmalloc_node(size_t size, gfp_t flags, int node)\n{\n\tstruct kmem_cache *s;\n\tvoid *ret;\n\n\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE)) {\n\t\tret = kmalloc_large_node(size, flags, node);\n\n\t\ttrace_kmalloc_node(_RET_IP_, ret,\n\t\t\t\t   size, PAGE_SIZE << get_order(size),\n\t\t\t\t   flags, node);\n\n\t\treturn ret;\n\t}\n\n\ts = kmalloc_slab(size, flags);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(s)))\n\t\treturn s;\n\n\tret = slab_alloc_node(s, flags, node, _RET_IP_);\n\n\ttrace_kmalloc_node(_RET_IP_, ret, size, s->size, flags, node);\n\n\tkasan_kmalloc(s, ret, size, flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "kmalloc_large_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "3794-3806",
    "snippet": "static void *kmalloc_large_node(size_t size, gfp_t flags, int node)\n{\n\tstruct page *page;\n\tvoid *ptr = NULL;\n\n\tflags |= __GFP_COMP;\n\tpage = alloc_pages_node(node, flags, get_order(size));\n\tif (page)\n\t\tptr = page_address(page);\n\n\tkmalloc_large_node_hook(ptr, size, flags);\n\treturn ptr;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmalloc_large_node_hook",
          "args": [
            "ptr",
            "size",
            "flags"
          ],
          "line": 3804
        },
        "resolved": true,
        "details": {
          "function_name": "kmalloc_large_node_hook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1375-1379",
          "snippet": "static inline void kmalloc_large_node_hook(void *ptr, size_t size, gfp_t flags)\n{\n\tkmemleak_alloc(ptr, size, 1, flags);\n\tkasan_kmalloc_large(ptr, size, flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void kmalloc_large_node_hook(void *ptr, size_t size, gfp_t flags)\n{\n\tkmemleak_alloc(ptr, size, 1, flags);\n\tkasan_kmalloc_large(ptr, size, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 3802
        },
        "resolved": true,
        "details": {
          "function_name": "page_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "409-434",
          "snippet": "void *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_pages_node",
          "args": [
            "node",
            "flags",
            "get_order(size)"
          ],
          "line": 3800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "size"
          ],
          "line": 3800
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void *kmalloc_large_node(size_t size, gfp_t flags, int node)\n{\n\tstruct page *page;\n\tvoid *ptr = NULL;\n\n\tflags |= __GFP_COMP;\n\tpage = alloc_pages_node(node, flags, get_order(size));\n\tif (page)\n\t\tptr = page_address(page);\n\n\tkmalloc_large_node_hook(ptr, size, flags);\n\treturn ptr;\n}"
  },
  {
    "function_name": "__kmalloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "3770-3790",
    "snippet": "void *__kmalloc(size_t size, gfp_t flags)\n{\n\tstruct kmem_cache *s;\n\tvoid *ret;\n\n\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE))\n\t\treturn kmalloc_large(size, flags);\n\n\ts = kmalloc_slab(size, flags);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(s)))\n\t\treturn s;\n\n\tret = slab_alloc(s, flags, _RET_IP_);\n\n\ttrace_kmalloc(_RET_IP_, ret, size, s->size, flags);\n\n\tkasan_kmalloc(s, ret, size, flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kasan_kmalloc",
          "args": [
            "s",
            "ret",
            "size",
            "flags"
          ],
          "line": 3787
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "531-554",
          "snippet": "void kasan_kmalloc(struct kmem_cache *cache, const void *object, size_t size,\n\t\t   gfp_t flags)\n{\n\tunsigned long redzone_start;\n\tunsigned long redzone_end;\n\n\tif (gfpflags_allow_blocking(flags))\n\t\tquarantine_reduce();\n\n\tif (unlikely(object == NULL))\n\t\treturn;\n\n\tredzone_start = round_up((unsigned long)(object + size),\n\t\t\t\tKASAN_SHADOW_SCALE_SIZE);\n\tredzone_end = round_up((unsigned long)object + cache->object_size,\n\t\t\t\tKASAN_SHADOW_SCALE_SIZE);\n\n\tkasan_unpoison_shadow(object, size);\n\tkasan_poison_shadow((void *)redzone_start, redzone_end - redzone_start,\n\t\tKASAN_KMALLOC_REDZONE);\n\n\tif (cache->flags & SLAB_KASAN)\n\t\tset_track(&get_alloc_info(cache, object)->alloc_track, flags);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid kasan_kmalloc(struct kmem_cache *cache, const void *object, size_t size,\n\t\t   gfp_t flags)\n{\n\tunsigned long redzone_start;\n\tunsigned long redzone_end;\n\n\tif (gfpflags_allow_blocking(flags))\n\t\tquarantine_reduce();\n\n\tif (unlikely(object == NULL))\n\t\treturn;\n\n\tredzone_start = round_up((unsigned long)(object + size),\n\t\t\t\tKASAN_SHADOW_SCALE_SIZE);\n\tredzone_end = round_up((unsigned long)object + cache->object_size,\n\t\t\t\tKASAN_SHADOW_SCALE_SIZE);\n\n\tkasan_unpoison_shadow(object, size);\n\tkasan_poison_shadow((void *)redzone_start, redzone_end - redzone_start,\n\t\tKASAN_KMALLOC_REDZONE);\n\n\tif (cache->flags & SLAB_KASAN)\n\t\tset_track(&get_alloc_info(cache, object)->alloc_track, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kmalloc",
          "args": [
            "_RET_IP_",
            "ret",
            "size",
            "s->size",
            "flags"
          ],
          "line": 3785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_alloc",
          "args": [
            "s",
            "flags",
            "_RET_IP_"
          ],
          "line": 3783
        },
        "resolved": true,
        "details": {
          "function_name": "slab_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2749-2753",
          "snippet": "static __always_inline void *slab_alloc(struct kmem_cache *s,\n\t\tgfp_t gfpflags, unsigned long addr)\n{\n\treturn slab_alloc_node(s, gfpflags, NUMA_NO_NODE, addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);\n\nstatic __always_inline void *slab_alloc(struct kmem_cache *s,\n\t\tgfp_t gfpflags, unsigned long addr)\n{\n\treturn slab_alloc_node(s, gfpflags, NUMA_NO_NODE, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ZERO_OR_NULL_PTR(s)"
          ],
          "line": 3780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ZERO_OR_NULL_PTR",
          "args": [
            "s"
          ],
          "line": 3780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_slab",
          "args": [
            "size",
            "flags"
          ],
          "line": 3778
        },
        "resolved": true,
        "details": {
          "function_name": "kmalloc_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "1022-1040",
          "snippet": "struct kmem_cache *kmalloc_slab(size_t size, gfp_t flags)\n{\n\tunsigned int index;\n\n\tif (size <= 192) {\n\t\tif (!size)\n\t\t\treturn ZERO_SIZE_PTR;\n\n\t\tindex = size_index[size_index_elem(size)];\n\t} else {\n\t\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE)) {\n\t\t\tWARN_ON(1);\n\t\t\treturn NULL;\n\t\t}\n\t\tindex = fls(size - 1);\n\t}\n\n\treturn kmalloc_caches[kmalloc_type(flags)][index];\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstruct kmem_cache *kmalloc_slab(size_t size, gfp_t flags)\n{\n\tunsigned int index;\n\n\tif (size <= 192) {\n\t\tif (!size)\n\t\t\treturn ZERO_SIZE_PTR;\n\n\t\tindex = size_index[size_index_elem(size)];\n\t} else {\n\t\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE)) {\n\t\t\tWARN_ON(1);\n\t\t\treturn NULL;\n\t\t}\n\t\tindex = fls(size - 1);\n\t}\n\n\treturn kmalloc_caches[kmalloc_type(flags)][index];\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc_large",
          "args": [
            "size",
            "flags"
          ],
          "line": 3776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "size > KMALLOC_MAX_CACHE_SIZE"
          ],
          "line": 3775
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid *__kmalloc(size_t size, gfp_t flags)\n{\n\tstruct kmem_cache *s;\n\tvoid *ret;\n\n\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE))\n\t\treturn kmalloc_large(size, flags);\n\n\ts = kmalloc_slab(size, flags);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(s)))\n\t\treturn s;\n\n\tret = slab_alloc(s, flags, _RET_IP_);\n\n\ttrace_kmalloc(_RET_IP_, ret, size, s->size, flags);\n\n\tkasan_kmalloc(s, ret, size, flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "setup_slub_min_objects",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "3761-3766",
    "snippet": "static int __init setup_slub_min_objects(char *str)\n{\n\tget_option(&str, (int *)&slub_min_objects);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int slub_min_objects;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_option",
          "args": [
            "&str",
            "(int *)&slub_min_objects"
          ],
          "line": 3763
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic unsigned int slub_min_objects;\n\nstatic int __init setup_slub_min_objects(char *str)\n{\n\tget_option(&str, (int *)&slub_min_objects);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "setup_slub_max_order",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "3751-3757",
    "snippet": "static int __init setup_slub_max_order(char *str)\n{\n\tget_option(&str, (int *)&slub_max_order);\n\tslub_max_order = min(slub_max_order, (unsigned int)MAX_ORDER - 1);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int slub_max_order = PAGE_ALLOC_COSTLY_ORDER;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "slub_max_order",
            "(unsigned int)MAX_ORDER - 1"
          ],
          "line": 3754
        },
        "resolved": true,
        "details": {
          "function_name": "min_partial_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "4954-4957",
          "snippet": "static ssize_t min_partial_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", s->min_partial);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic ssize_t min_partial_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", s->min_partial);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_option",
          "args": [
            "&str",
            "(int *)&slub_max_order"
          ],
          "line": 3753
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic unsigned int slub_max_order = PAGE_ALLOC_COSTLY_ORDER;\n\nstatic int __init setup_slub_max_order(char *str)\n{\n\tget_option(&str, (int *)&slub_max_order);\n\tslub_max_order = min(slub_max_order, (unsigned int)MAX_ORDER - 1);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "setup_slub_min_order",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "3742-3747",
    "snippet": "static int __init setup_slub_min_order(char *str)\n{\n\tget_option(&str, (int *)&slub_min_order);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int slub_min_order;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_option",
          "args": [
            "&str",
            "(int *)&slub_min_order"
          ],
          "line": 3744
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic unsigned int slub_min_order;\n\nstatic int __init setup_slub_min_order(char *str)\n{\n\tget_option(&str, (int *)&slub_min_order);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "__kmem_cache_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "3722-3736",
    "snippet": "int __kmem_cache_shutdown(struct kmem_cache *s)\n{\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tflush_all(s);\n\t/* Attempt to free all objects */\n\tfor_each_kmem_cache_node(s, node, n) {\n\t\tfree_partial(s, n);\n\t\tif (n->nr_partial || slabs_node(s, node))\n\t\t\treturn 1;\n\t}\n\tsysfs_slab_remove(s);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *kmem_cache_node;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysfs_slab_remove",
          "args": [
            "s"
          ],
          "line": 3734
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_slab_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "5772-5783",
          "snippet": "static void sysfs_slab_remove(struct kmem_cache *s)\n{\n\tif (slab_state < FULL)\n\t\t/*\n\t\t * Sysfs has not been setup yet so no need to remove the\n\t\t * cache from sysfs.\n\t\t */\n\t\treturn;\n\n\tkobject_get(&s->kobj);\n\tschedule_work(&s->kobj_remove_work);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void sysfs_slab_remove(struct kmem_cache *s)\n{\n\tif (slab_state < FULL)\n\t\t/*\n\t\t * Sysfs has not been setup yet so no need to remove the\n\t\t * cache from sysfs.\n\t\t */\n\t\treturn;\n\n\tkobject_get(&s->kobj);\n\tschedule_work(&s->kobj_remove_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "slabs_node",
          "args": [
            "s",
            "node"
          ],
          "line": 3731
        },
        "resolved": true,
        "details": {
          "function_name": "slabs_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1360-1361",
          "snippet": "static inline unsigned long slabs_node(struct kmem_cache *s, int node)\n\t\t\t\t\t\t\t{ return 0; }",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline unsigned long slabs_node(struct kmem_cache *s, int node)\n\t\t\t\t\t\t\t{ return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "free_partial",
          "args": [
            "s",
            "n"
          ],
          "line": 3730
        },
        "resolved": true,
        "details": {
          "function_name": "free_partial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "3686-3706",
          "snippet": "static void free_partial(struct kmem_cache *s, struct kmem_cache_node *n)\n{\n\tLIST_HEAD(discard);\n\tstruct page *page, *h;\n\n\tBUG_ON(irqs_disabled());\n\tspin_lock_irq(&n->list_lock);\n\tlist_for_each_entry_safe(page, h, &n->partial, lru) {\n\t\tif (!page->inuse) {\n\t\t\tremove_partial(n, page);\n\t\t\tlist_add(&page->lru, &discard);\n\t\t} else {\n\t\t\tlist_slab_objects(s, page,\n\t\t\t\"Objects remaining in %s on __kmem_cache_shutdown()\");\n\t\t}\n\t}\n\tspin_unlock_irq(&n->list_lock);\n\n\tlist_for_each_entry_safe(page, h, &discard, lru)\n\t\tdiscard_slab(s, page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic void free_partial(struct kmem_cache *s, struct kmem_cache_node *n)\n{\n\tLIST_HEAD(discard);\n\tstruct page *page, *h;\n\n\tBUG_ON(irqs_disabled());\n\tspin_lock_irq(&n->list_lock);\n\tlist_for_each_entry_safe(page, h, &n->partial, lru) {\n\t\tif (!page->inuse) {\n\t\t\tremove_partial(n, page);\n\t\t\tlist_add(&page->lru, &discard);\n\t\t} else {\n\t\t\tlist_slab_objects(s, page,\n\t\t\t\"Objects remaining in %s on __kmem_cache_shutdown()\");\n\t\t}\n\t}\n\tspin_unlock_irq(&n->list_lock);\n\n\tlist_for_each_entry_safe(page, h, &discard, lru)\n\t\tdiscard_slab(s, page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_kmem_cache_node",
          "args": [
            "s",
            "node",
            "n"
          ],
          "line": 3729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_all",
          "args": [
            "s"
          ],
          "line": 3727
        },
        "resolved": true,
        "details": {
          "function_name": "flush_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2339-2342",
          "snippet": "static void flush_all(struct kmem_cache *s)\n{\n\ton_each_cpu_cond(has_cpu_slab, flush_cpu_slab, s, 1, GFP_ATOMIC);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void flush_all(struct kmem_cache *s)\n{\n\ton_each_cpu_cond(has_cpu_slab, flush_cpu_slab, s, 1, GFP_ATOMIC);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nint __kmem_cache_shutdown(struct kmem_cache *s)\n{\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tflush_all(s);\n\t/* Attempt to free all objects */\n\tfor_each_kmem_cache_node(s, node, n) {\n\t\tfree_partial(s, n);\n\t\tif (n->nr_partial || slabs_node(s, node))\n\t\t\treturn 1;\n\t}\n\tsysfs_slab_remove(s);\n\treturn 0;\n}"
  },
  {
    "function_name": "__kmem_cache_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "3708-3717",
    "snippet": "bool __kmem_cache_empty(struct kmem_cache *s)\n{\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tfor_each_kmem_cache_node(s, node, n)\n\t\tif (n->nr_partial || slabs_node(s, node))\n\t\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *kmem_cache_node;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slabs_node",
          "args": [
            "s",
            "node"
          ],
          "line": 3714
        },
        "resolved": true,
        "details": {
          "function_name": "slabs_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1360-1361",
          "snippet": "static inline unsigned long slabs_node(struct kmem_cache *s, int node)\n\t\t\t\t\t\t\t{ return 0; }",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline unsigned long slabs_node(struct kmem_cache *s, int node)\n\t\t\t\t\t\t\t{ return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "for_each_kmem_cache_node",
          "args": [
            "s",
            "node",
            "n"
          ],
          "line": 3713
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nbool __kmem_cache_empty(struct kmem_cache *s)\n{\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tfor_each_kmem_cache_node(s, node, n)\n\t\tif (n->nr_partial || slabs_node(s, node))\n\t\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "free_partial",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "3686-3706",
    "snippet": "static void free_partial(struct kmem_cache *s, struct kmem_cache_node *n)\n{\n\tLIST_HEAD(discard);\n\tstruct page *page, *h;\n\n\tBUG_ON(irqs_disabled());\n\tspin_lock_irq(&n->list_lock);\n\tlist_for_each_entry_safe(page, h, &n->partial, lru) {\n\t\tif (!page->inuse) {\n\t\t\tremove_partial(n, page);\n\t\t\tlist_add(&page->lru, &discard);\n\t\t} else {\n\t\t\tlist_slab_objects(s, page,\n\t\t\t\"Objects remaining in %s on __kmem_cache_shutdown()\");\n\t\t}\n\t}\n\tspin_unlock_irq(&n->list_lock);\n\n\tlist_for_each_entry_safe(page, h, &discard, lru)\n\t\tdiscard_slab(s, page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *kmem_cache_node;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "discard_slab",
          "args": [
            "s",
            "page"
          ],
          "line": 3705
        },
        "resolved": true,
        "details": {
          "function_name": "discard_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1740-1744",
          "snippet": "static void discard_slab(struct kmem_cache *s, struct page *page)\n{\n\tdec_slabs_node(s, page_to_nid(page), page->objects);\n\tfree_slab(s, page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void discard_slab(struct kmem_cache *s, struct page *page)\n{\n\tdec_slabs_node(s, page_to_nid(page), page->objects);\n\tfree_slab(s, page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "page",
            "h",
            "&discard",
            "lru"
          ],
          "line": 3704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&n->list_lock"
          ],
          "line": 3702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_slab_objects",
          "args": [
            "s",
            "page",
            "\"Objects remaining in %s on __kmem_cache_shutdown()\""
          ],
          "line": 3698
        },
        "resolved": true,
        "details": {
          "function_name": "list_slab_objects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "3656-3679",
          "snippet": "static void list_slab_objects(struct kmem_cache *s, struct page *page,\n\t\t\t\t\t\t\tconst char *text)\n{\n#ifdef CONFIG_SLUB_DEBUG\n\tvoid *addr = page_address(page);\n\tvoid *p;\n\tunsigned long *map = bitmap_zalloc(page->objects, GFP_ATOMIC);\n\tif (!map)\n\t\treturn;\n\tslab_err(s, page, text, s->name);\n\tslab_lock(page);\n\n\tget_map(s, page, map);\n\tfor_each_object(p, s, addr, page->objects) {\n\n\t\tif (!test_bit(slab_index(p, s, addr), map)) {\n\t\t\tpr_err(\"INFO: Object 0x%p @offset=%tu\\n\", p, p - addr);\n\t\t\tprint_tracking(s, p);\n\t\t}\n\t}\n\tslab_unlock(page);\n\tbitmap_free(map);\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void list_slab_objects(struct kmem_cache *s, struct page *page,\n\t\t\t\t\t\t\tconst char *text)\n{\n#ifdef CONFIG_SLUB_DEBUG\n\tvoid *addr = page_address(page);\n\tvoid *p;\n\tunsigned long *map = bitmap_zalloc(page->objects, GFP_ATOMIC);\n\tif (!map)\n\t\treturn;\n\tslab_err(s, page, text, s->name);\n\tslab_lock(page);\n\n\tget_map(s, page, map);\n\tfor_each_object(p, s, addr, page->objects) {\n\n\t\tif (!test_bit(slab_index(p, s, addr), map)) {\n\t\t\tpr_err(\"INFO: Object 0x%p @offset=%tu\\n\", p, p - addr);\n\t\t\tprint_tracking(s, p);\n\t\t}\n\t}\n\tslab_unlock(page);\n\tbitmap_free(map);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&page->lru",
            "&discard"
          ],
          "line": 3696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_partial",
          "args": [
            "n",
            "page"
          ],
          "line": 3695
        },
        "resolved": true,
        "details": {
          "function_name": "remove_partial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1766-1772",
          "snippet": "static inline void remove_partial(struct kmem_cache_node *n,\n\t\t\t\t\tstruct page *page)\n{\n\tlockdep_assert_held(&n->list_lock);\n\tlist_del(&page->lru);\n\tn->nr_partial--;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic inline void remove_partial(struct kmem_cache_node *n,\n\t\t\t\t\tstruct page *page)\n{\n\tlockdep_assert_held(&n->list_lock);\n\tlist_del(&page->lru);\n\tn->nr_partial--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "page",
            "h",
            "&n->partial",
            "lru"
          ],
          "line": 3693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&n->list_lock"
          ],
          "line": 3692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "irqs_disabled()"
          ],
          "line": 3691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 3691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "discard"
          ],
          "line": 3688
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic void free_partial(struct kmem_cache *s, struct kmem_cache_node *n)\n{\n\tLIST_HEAD(discard);\n\tstruct page *page, *h;\n\n\tBUG_ON(irqs_disabled());\n\tspin_lock_irq(&n->list_lock);\n\tlist_for_each_entry_safe(page, h, &n->partial, lru) {\n\t\tif (!page->inuse) {\n\t\t\tremove_partial(n, page);\n\t\t\tlist_add(&page->lru, &discard);\n\t\t} else {\n\t\t\tlist_slab_objects(s, page,\n\t\t\t\"Objects remaining in %s on __kmem_cache_shutdown()\");\n\t\t}\n\t}\n\tspin_unlock_irq(&n->list_lock);\n\n\tlist_for_each_entry_safe(page, h, &discard, lru)\n\t\tdiscard_slab(s, page);\n}"
  },
  {
    "function_name": "list_slab_objects",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "3656-3679",
    "snippet": "static void list_slab_objects(struct kmem_cache *s, struct page *page,\n\t\t\t\t\t\t\tconst char *text)\n{\n#ifdef CONFIG_SLUB_DEBUG\n\tvoid *addr = page_address(page);\n\tvoid *p;\n\tunsigned long *map = bitmap_zalloc(page->objects, GFP_ATOMIC);\n\tif (!map)\n\t\treturn;\n\tslab_err(s, page, text, s->name);\n\tslab_lock(page);\n\n\tget_map(s, page, map);\n\tfor_each_object(p, s, addr, page->objects) {\n\n\t\tif (!test_bit(slab_index(p, s, addr), map)) {\n\t\t\tpr_err(\"INFO: Object 0x%p @offset=%tu\\n\", p, p - addr);\n\t\t\tprint_tracking(s, p);\n\t\t}\n\t}\n\tslab_unlock(page);\n\tbitmap_free(map);\n#endif\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bitmap_free",
          "args": [
            "map"
          ],
          "line": 3677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_unlock",
          "args": [
            "page"
          ],
          "line": 3676
        },
        "resolved": true,
        "details": {
          "function_name": "slab_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "351-355",
          "snippet": "static __always_inline void slab_unlock(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\t__bit_spin_unlock(PG_locked, &page->flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic __always_inline void slab_unlock(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\t__bit_spin_unlock(PG_locked, &page->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_tracking",
          "args": [
            "s",
            "p"
          ],
          "line": 3673
        },
        "resolved": true,
        "details": {
          "function_name": "print_tracking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "603-611",
          "snippet": "static void print_tracking(struct kmem_cache *s, void *object)\n{\n\tunsigned long pr_time = jiffies;\n\tif (!(s->flags & SLAB_STORE_USER))\n\t\treturn;\n\n\tprint_track(\"Allocated\", get_track(s, object, TRACK_ALLOC), pr_time);\n\tprint_track(\"Freed\", get_track(s, object, TRACK_FREE), pr_time);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void print_tracking(struct kmem_cache *s, void *object)\n{\n\tunsigned long pr_time = jiffies;\n\tif (!(s->flags & SLAB_STORE_USER))\n\t\treturn;\n\n\tprint_track(\"Allocated\", get_track(s, object, TRACK_ALLOC), pr_time);\n\tprint_track(\"Freed\", get_track(s, object, TRACK_FREE), pr_time);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"INFO: Object 0x%p @offset=%tu\\n\"",
            "p",
            "p - addr"
          ],
          "line": 3672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "slab_index(p, s, addr)",
            "map"
          ],
          "line": 3671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_index",
          "args": [
            "p",
            "s",
            "addr"
          ],
          "line": 3671
        },
        "resolved": true,
        "details": {
          "function_name": "slab_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "312-315",
          "snippet": "static inline unsigned int slab_index(void *p, struct kmem_cache *s, void *addr)\n{\n\treturn (p - addr) / s->size;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline unsigned int slab_index(void *p, struct kmem_cache *s, void *addr)\n{\n\treturn (p - addr) / s->size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_object",
          "args": [
            "p",
            "s",
            "addr",
            "page->objects"
          ],
          "line": 3669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_map",
          "args": [
            "s",
            "page",
            "map"
          ],
          "line": 3668
        },
        "resolved": true,
        "details": {
          "function_name": "get_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "443-450",
          "snippet": "static void get_map(struct kmem_cache *s, struct page *page, unsigned long *map)\n{\n\tvoid *p;\n\tvoid *addr = page_address(page);\n\n\tfor (p = page->freelist; p; p = get_freepointer(s, p))\n\t\tset_bit(slab_index(p, s, addr), map);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void get_map(struct kmem_cache *s, struct page *page, unsigned long *map)\n{\n\tvoid *p;\n\tvoid *addr = page_address(page);\n\n\tfor (p = page->freelist; p; p = get_freepointer(s, p))\n\t\tset_bit(slab_index(p, s, addr), map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "slab_lock",
          "args": [
            "page"
          ],
          "line": 3666
        },
        "resolved": true,
        "details": {
          "function_name": "slab_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "345-349",
          "snippet": "static __always_inline void slab_lock(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tbit_spin_lock(PG_locked, &page->flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic __always_inline void slab_lock(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tbit_spin_lock(PG_locked, &page->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "slab_err",
          "args": [
            "s",
            "page",
            "text",
            "s->name"
          ],
          "line": 3665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_zalloc",
          "args": [
            "page->objects",
            "GFP_ATOMIC"
          ],
          "line": 3662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 3660
        },
        "resolved": true,
        "details": {
          "function_name": "page_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "409-434",
          "snippet": "void *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void list_slab_objects(struct kmem_cache *s, struct page *page,\n\t\t\t\t\t\t\tconst char *text)\n{\n#ifdef CONFIG_SLUB_DEBUG\n\tvoid *addr = page_address(page);\n\tvoid *p;\n\tunsigned long *map = bitmap_zalloc(page->objects, GFP_ATOMIC);\n\tif (!map)\n\t\treturn;\n\tslab_err(s, page, text, s->name);\n\tslab_lock(page);\n\n\tget_map(s, page, map);\n\tfor_each_object(p, s, addr, page->objects) {\n\n\t\tif (!test_bit(slab_index(p, s, addr), map)) {\n\t\t\tpr_err(\"INFO: Object 0x%p @offset=%tu\\n\", p, p - addr);\n\t\t\tprint_tracking(s, p);\n\t\t}\n\t}\n\tslab_unlock(page);\n\tbitmap_free(map);\n#endif\n}"
  },
  {
    "function_name": "kmem_cache_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "3594-3654",
    "snippet": "static int kmem_cache_open(struct kmem_cache *s, slab_flags_t flags)\n{\n\ts->flags = kmem_cache_flags(s->size, flags, s->name, s->ctor);\n#ifdef CONFIG_SLAB_FREELIST_HARDENED\n\ts->random = get_random_long();\n#endif\n\n\tif (!calculate_sizes(s, -1))\n\t\tgoto error;\n\tif (disable_higher_order_debug) {\n\t\t/*\n\t\t * Disable debugging flags that store metadata if the min slab\n\t\t * order increased.\n\t\t */\n\t\tif (get_order(s->size) > get_order(s->object_size)) {\n\t\t\ts->flags &= ~DEBUG_METADATA_FLAGS;\n\t\t\ts->offset = 0;\n\t\t\tif (!calculate_sizes(s, -1))\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\n#if defined(CONFIG_HAVE_CMPXCHG_DOUBLE) && \\\n    defined(CONFIG_HAVE_ALIGNED_STRUCT_PAGE)\n\tif (system_has_cmpxchg_double() && (s->flags & SLAB_NO_CMPXCHG) == 0)\n\t\t/* Enable fast mode */\n\t\ts->flags |= __CMPXCHG_DOUBLE;\n#endif\n\n\t/*\n\t * The larger the object size is, the more pages we want on the partial\n\t * list to avoid pounding the page allocator excessively.\n\t */\n\tset_min_partial(s, ilog2(s->size) / 2);\n\n\tset_cpu_partial(s);\n\n#ifdef CONFIG_NUMA\n\ts->remote_node_defrag_ratio = 1000;\n#endif\n\n\t/* Initialize the pre-computed randomized freelist if slab is up */\n\tif (slab_state >= UP) {\n\t\tif (init_cache_random_seq(s))\n\t\t\tgoto error;\n\t}\n\n\tif (!init_kmem_cache_nodes(s))\n\t\tgoto error;\n\n\tif (alloc_kmem_cache_cpus(s))\n\t\treturn 0;\n\n\tfree_kmem_cache_nodes(s);\nerror:\n\tif (flags & SLAB_PANIC)\n\t\tpanic(\"Cannot create slab %s size=%u realsize=%u order=%u offset=%u flags=%lx\\n\",\n\t\t      s->name, s->size, s->size,\n\t\t      oo_order(s->oo), s->offset, (unsigned long)flags);\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define disable_higher_order_debug 0",
      "#define __CMPXCHG_DOUBLE\t((slab_flags_t __force)0x40000000U)",
      "#define DEBUG_METADATA_FLAGS (SLAB_RED_ZONE | SLAB_POISON | SLAB_STORE_USER)",
      "#define SLAB_NO_CMPXCHG (SLAB_CONSISTENCY_CHECKS | SLAB_STORE_USER | \\\n\t\t\t\tSLAB_TRACE)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Cannot create slab %s size=%u realsize=%u order=%u offset=%u flags=%lx\\n\"",
            "s->name",
            "s->size",
            "s->size",
            "oo_order(s->oo)",
            "s->offset",
            "(unsigned long)flags"
          ],
          "line": 3650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oo_order",
          "args": [
            "s->oo"
          ],
          "line": 3652
        },
        "resolved": true,
        "details": {
          "function_name": "oo_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "332-335",
          "snippet": "static inline unsigned int oo_order(struct kmem_cache_order_objects x)\n{\n\treturn x.x >> OO_SHIFT;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define OO_SHIFT\t16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define OO_SHIFT\t16\n\nstatic inline unsigned int oo_order(struct kmem_cache_order_objects x)\n{\n\treturn x.x >> OO_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_kmem_cache_nodes",
          "args": [
            "s"
          ],
          "line": 3647
        },
        "resolved": true,
        "details": {
          "function_name": "free_kmem_cache_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "3387-3396",
          "snippet": "static void free_kmem_cache_nodes(struct kmem_cache *s)\n{\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tfor_each_kmem_cache_node(s, node, n) {\n\t\ts->node[node] = NULL;\n\t\tkmem_cache_free(kmem_cache_node, n);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic void free_kmem_cache_nodes(struct kmem_cache *s)\n{\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tfor_each_kmem_cache_node(s, node, n) {\n\t\ts->node[node] = NULL;\n\t\tkmem_cache_free(kmem_cache_node, n);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_kmem_cache_cpus",
          "args": [
            "s"
          ],
          "line": 3644
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_kmem_cache_cpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "3319-3337",
          "snippet": "static inline int alloc_kmem_cache_cpus(struct kmem_cache *s)\n{\n\tBUILD_BUG_ON(PERCPU_DYNAMIC_EARLY_SIZE <\n\t\t\tKMALLOC_SHIFT_HIGH * sizeof(struct kmem_cache_cpu));\n\n\t/*\n\t * Must align to double word boundary for the double cmpxchg\n\t * instructions to work; see __pcpu_double_call_return_bool().\n\t */\n\ts->cpu_slab = __alloc_percpu(sizeof(struct kmem_cache_cpu),\n\t\t\t\t     2 * sizeof(void *));\n\n\tif (!s->cpu_slab)\n\t\treturn 0;\n\n\tinit_kmem_cache_cpus(s);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline int alloc_kmem_cache_cpus(struct kmem_cache *s)\n{\n\tBUILD_BUG_ON(PERCPU_DYNAMIC_EARLY_SIZE <\n\t\t\tKMALLOC_SHIFT_HIGH * sizeof(struct kmem_cache_cpu));\n\n\t/*\n\t * Must align to double word boundary for the double cmpxchg\n\t * instructions to work; see __pcpu_double_call_return_bool().\n\t */\n\ts->cpu_slab = __alloc_percpu(sizeof(struct kmem_cache_cpu),\n\t\t\t\t     2 * sizeof(void *));\n\n\tif (!s->cpu_slab)\n\t\treturn 0;\n\n\tinit_kmem_cache_cpus(s);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_kmem_cache_nodes",
          "args": [
            "s"
          ],
          "line": 3641
        },
        "resolved": true,
        "details": {
          "function_name": "init_kmem_cache_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "3405-3428",
          "snippet": "static int init_kmem_cache_nodes(struct kmem_cache *s)\n{\n\tint node;\n\n\tfor_each_node_state(node, N_NORMAL_MEMORY) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tif (slab_state == DOWN) {\n\t\t\tearly_kmem_cache_node_alloc(node);\n\t\t\tcontinue;\n\t\t}\n\t\tn = kmem_cache_alloc_node(kmem_cache_node,\n\t\t\t\t\t\tGFP_KERNEL, node);\n\n\t\tif (!n) {\n\t\t\tfree_kmem_cache_nodes(s);\n\t\t\treturn 0;\n\t\t}\n\n\t\tinit_kmem_cache_node(n);\n\t\ts->node[node] = n;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic int init_kmem_cache_nodes(struct kmem_cache *s)\n{\n\tint node;\n\n\tfor_each_node_state(node, N_NORMAL_MEMORY) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tif (slab_state == DOWN) {\n\t\t\tearly_kmem_cache_node_alloc(node);\n\t\t\tcontinue;\n\t\t}\n\t\tn = kmem_cache_alloc_node(kmem_cache_node,\n\t\t\t\t\t\tGFP_KERNEL, node);\n\n\t\tif (!n) {\n\t\t\tfree_kmem_cache_nodes(s);\n\t\t\treturn 0;\n\t\t}\n\n\t\tinit_kmem_cache_node(n);\n\t\ts->node[node] = n;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_cache_random_seq",
          "args": [
            "s"
          ],
          "line": 3637
        },
        "resolved": true,
        "details": {
          "function_name": "init_cache_random_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1586-1589",
          "snippet": "static inline int init_cache_random_seq(struct kmem_cache *s)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline int init_cache_random_seq(struct kmem_cache *s)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_cpu_partial",
          "args": [
            "s"
          ],
          "line": 3629
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpu_partial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "3439-3470",
          "snippet": "static void set_cpu_partial(struct kmem_cache *s)\n{\n#ifdef CONFIG_SLUB_CPU_PARTIAL\n\t/*\n\t * cpu_partial determined the maximum number of objects kept in the\n\t * per cpu partial lists of a processor.\n\t *\n\t * Per cpu partial lists mainly contain slabs that just have one\n\t * object freed. If they are used for allocation then they can be\n\t * filled up again with minimal effort. The slab will never hit the\n\t * per node partial lists and therefore no locking will be required.\n\t *\n\t * This setting also determines\n\t *\n\t * A) The number of objects from per cpu partial slabs dumped to the\n\t *    per node list when we reach the limit.\n\t * B) The number of objects in cpu partial slabs to extract from the\n\t *    per node list when we run out of per cpu objects. We only fetch\n\t *    50% to keep some capacity around for frees.\n\t */\n\tif (!kmem_cache_has_cpu_partial(s))\n\t\ts->cpu_partial = 0;\n\telse if (s->size >= PAGE_SIZE)\n\t\ts->cpu_partial = 2;\n\telse if (s->size >= 1024)\n\t\ts->cpu_partial = 6;\n\telse if (s->size >= 256)\n\t\ts->cpu_partial = 13;\n\telse\n\t\ts->cpu_partial = 30;\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void set_cpu_partial(struct kmem_cache *s)\n{\n#ifdef CONFIG_SLUB_CPU_PARTIAL\n\t/*\n\t * cpu_partial determined the maximum number of objects kept in the\n\t * per cpu partial lists of a processor.\n\t *\n\t * Per cpu partial lists mainly contain slabs that just have one\n\t * object freed. If they are used for allocation then they can be\n\t * filled up again with minimal effort. The slab will never hit the\n\t * per node partial lists and therefore no locking will be required.\n\t *\n\t * This setting also determines\n\t *\n\t * A) The number of objects from per cpu partial slabs dumped to the\n\t *    per node list when we reach the limit.\n\t * B) The number of objects in cpu partial slabs to extract from the\n\t *    per node list when we run out of per cpu objects. We only fetch\n\t *    50% to keep some capacity around for frees.\n\t */\n\tif (!kmem_cache_has_cpu_partial(s))\n\t\ts->cpu_partial = 0;\n\telse if (s->size >= PAGE_SIZE)\n\t\ts->cpu_partial = 2;\n\telse if (s->size >= 1024)\n\t\ts->cpu_partial = 6;\n\telse if (s->size >= 256)\n\t\ts->cpu_partial = 13;\n\telse\n\t\ts->cpu_partial = 30;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_min_partial",
          "args": [
            "s",
            "ilog2(s->size) / 2"
          ],
          "line": 3627
        },
        "resolved": true,
        "details": {
          "function_name": "set_min_partial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "3430-3437",
          "snippet": "static void set_min_partial(struct kmem_cache *s, unsigned long min)\n{\n\tif (min < MIN_PARTIAL)\n\t\tmin = MIN_PARTIAL;\n\telse if (min > MAX_PARTIAL)\n\t\tmin = MAX_PARTIAL;\n\ts->min_partial = min;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define MAX_PARTIAL 10",
            "#define MIN_PARTIAL 5"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define MAX_PARTIAL 10\n#define MIN_PARTIAL 5\n\nstatic void set_min_partial(struct kmem_cache *s, unsigned long min)\n{\n\tif (min < MIN_PARTIAL)\n\t\tmin = MIN_PARTIAL;\n\telse if (min > MAX_PARTIAL)\n\t\tmin = MAX_PARTIAL;\n\ts->min_partial = min;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "s->size"
          ],
          "line": 3627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system_has_cmpxchg_double",
          "args": [],
          "line": 3618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calculate_sizes",
          "args": [
            "s",
            "-1"
          ],
          "line": 3611
        },
        "resolved": true,
        "details": {
          "function_name": "calculate_sizes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "3476-3592",
          "snippet": "static int calculate_sizes(struct kmem_cache *s, int forced_order)\n{\n\tslab_flags_t flags = s->flags;\n\tunsigned int size = s->object_size;\n\tunsigned int order;\n\n\t/*\n\t * Round up object size to the next word boundary. We can only\n\t * place the free pointer at word boundaries and this determines\n\t * the possible location of the free pointer.\n\t */\n\tsize = ALIGN(size, sizeof(void *));\n\n#ifdef CONFIG_SLUB_DEBUG\n\t/*\n\t * Determine if we can poison the object itself. If the user of\n\t * the slab may touch the object after free or before allocation\n\t * then we should never poison the object itself.\n\t */\n\tif ((flags & SLAB_POISON) && !(flags & SLAB_TYPESAFE_BY_RCU) &&\n\t\t\t!s->ctor)\n\t\ts->flags |= __OBJECT_POISON;\n\telse\n\t\ts->flags &= ~__OBJECT_POISON;\n\n\n\t/*\n\t * If we are Redzoning then check if there is some space between the\n\t * end of the object and the free pointer. If not then add an\n\t * additional word to have some bytes to store Redzone information.\n\t */\n\tif ((flags & SLAB_RED_ZONE) && size == s->object_size)\n\t\tsize += sizeof(void *);\n#endif\n\n\t/*\n\t * With that we have determined the number of bytes in actual use\n\t * by the object. This is the potential offset to the free pointer.\n\t */\n\ts->inuse = size;\n\n\tif (((flags & (SLAB_TYPESAFE_BY_RCU | SLAB_POISON)) ||\n\t\ts->ctor)) {\n\t\t/*\n\t\t * Relocate free pointer after the object if it is not\n\t\t * permitted to overwrite the first word of the object on\n\t\t * kmem_cache_free.\n\t\t *\n\t\t * This is the case if we do RCU, have a constructor or\n\t\t * destructor or are poisoning the objects.\n\t\t */\n\t\ts->offset = size;\n\t\tsize += sizeof(void *);\n\t}\n\n#ifdef CONFIG_SLUB_DEBUG\n\tif (flags & SLAB_STORE_USER)\n\t\t/*\n\t\t * Need to store information about allocs and frees after\n\t\t * the object.\n\t\t */\n\t\tsize += 2 * sizeof(struct track);\n#endif\n\n\tkasan_cache_create(s, &size, &s->flags);\n#ifdef CONFIG_SLUB_DEBUG\n\tif (flags & SLAB_RED_ZONE) {\n\t\t/*\n\t\t * Add some empty padding so that we can catch\n\t\t * overwrites from earlier objects rather than let\n\t\t * tracking information or the free pointer be\n\t\t * corrupted if a user writes before the start\n\t\t * of the object.\n\t\t */\n\t\tsize += sizeof(void *);\n\n\t\ts->red_left_pad = sizeof(void *);\n\t\ts->red_left_pad = ALIGN(s->red_left_pad, s->align);\n\t\tsize += s->red_left_pad;\n\t}\n#endif\n\n\t/*\n\t * SLUB stores one object immediately after another beginning from\n\t * offset 0. In order to align the objects we have to simply size\n\t * each object to conform to the alignment.\n\t */\n\tsize = ALIGN(size, s->align);\n\ts->size = size;\n\tif (forced_order >= 0)\n\t\torder = forced_order;\n\telse\n\t\torder = calculate_order(size);\n\n\tif ((int)order < 0)\n\t\treturn 0;\n\n\ts->allocflags = 0;\n\tif (order)\n\t\ts->allocflags |= __GFP_COMP;\n\n\tif (s->flags & SLAB_CACHE_DMA)\n\t\ts->allocflags |= GFP_DMA;\n\n\tif (s->flags & SLAB_RECLAIM_ACCOUNT)\n\t\ts->allocflags |= __GFP_RECLAIMABLE;\n\n\t/*\n\t * Determine the number of objects per slab\n\t */\n\ts->oo = oo_make(order, size);\n\ts->min = oo_make(get_order(size), size);\n\tif (oo_objects(s->oo) > oo_objects(s->max))\n\t\ts->max = s->oo;\n\n\treturn !!oo_objects(s->oo);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define __OBJECT_POISON\t\t((slab_flags_t __force)0x80000000U)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define __OBJECT_POISON\t\t((slab_flags_t __force)0x80000000U)\n\nstatic int calculate_sizes(struct kmem_cache *s, int forced_order)\n{\n\tslab_flags_t flags = s->flags;\n\tunsigned int size = s->object_size;\n\tunsigned int order;\n\n\t/*\n\t * Round up object size to the next word boundary. We can only\n\t * place the free pointer at word boundaries and this determines\n\t * the possible location of the free pointer.\n\t */\n\tsize = ALIGN(size, sizeof(void *));\n\n#ifdef CONFIG_SLUB_DEBUG\n\t/*\n\t * Determine if we can poison the object itself. If the user of\n\t * the slab may touch the object after free or before allocation\n\t * then we should never poison the object itself.\n\t */\n\tif ((flags & SLAB_POISON) && !(flags & SLAB_TYPESAFE_BY_RCU) &&\n\t\t\t!s->ctor)\n\t\ts->flags |= __OBJECT_POISON;\n\telse\n\t\ts->flags &= ~__OBJECT_POISON;\n\n\n\t/*\n\t * If we are Redzoning then check if there is some space between the\n\t * end of the object and the free pointer. If not then add an\n\t * additional word to have some bytes to store Redzone information.\n\t */\n\tif ((flags & SLAB_RED_ZONE) && size == s->object_size)\n\t\tsize += sizeof(void *);\n#endif\n\n\t/*\n\t * With that we have determined the number of bytes in actual use\n\t * by the object. This is the potential offset to the free pointer.\n\t */\n\ts->inuse = size;\n\n\tif (((flags & (SLAB_TYPESAFE_BY_RCU | SLAB_POISON)) ||\n\t\ts->ctor)) {\n\t\t/*\n\t\t * Relocate free pointer after the object if it is not\n\t\t * permitted to overwrite the first word of the object on\n\t\t * kmem_cache_free.\n\t\t *\n\t\t * This is the case if we do RCU, have a constructor or\n\t\t * destructor or are poisoning the objects.\n\t\t */\n\t\ts->offset = size;\n\t\tsize += sizeof(void *);\n\t}\n\n#ifdef CONFIG_SLUB_DEBUG\n\tif (flags & SLAB_STORE_USER)\n\t\t/*\n\t\t * Need to store information about allocs and frees after\n\t\t * the object.\n\t\t */\n\t\tsize += 2 * sizeof(struct track);\n#endif\n\n\tkasan_cache_create(s, &size, &s->flags);\n#ifdef CONFIG_SLUB_DEBUG\n\tif (flags & SLAB_RED_ZONE) {\n\t\t/*\n\t\t * Add some empty padding so that we can catch\n\t\t * overwrites from earlier objects rather than let\n\t\t * tracking information or the free pointer be\n\t\t * corrupted if a user writes before the start\n\t\t * of the object.\n\t\t */\n\t\tsize += sizeof(void *);\n\n\t\ts->red_left_pad = sizeof(void *);\n\t\ts->red_left_pad = ALIGN(s->red_left_pad, s->align);\n\t\tsize += s->red_left_pad;\n\t}\n#endif\n\n\t/*\n\t * SLUB stores one object immediately after another beginning from\n\t * offset 0. In order to align the objects we have to simply size\n\t * each object to conform to the alignment.\n\t */\n\tsize = ALIGN(size, s->align);\n\ts->size = size;\n\tif (forced_order >= 0)\n\t\torder = forced_order;\n\telse\n\t\torder = calculate_order(size);\n\n\tif ((int)order < 0)\n\t\treturn 0;\n\n\ts->allocflags = 0;\n\tif (order)\n\t\ts->allocflags |= __GFP_COMP;\n\n\tif (s->flags & SLAB_CACHE_DMA)\n\t\ts->allocflags |= GFP_DMA;\n\n\tif (s->flags & SLAB_RECLAIM_ACCOUNT)\n\t\ts->allocflags |= __GFP_RECLAIMABLE;\n\n\t/*\n\t * Determine the number of objects per slab\n\t */\n\ts->oo = oo_make(order, size);\n\ts->min = oo_make(get_order(size), size);\n\tif (oo_objects(s->oo) > oo_objects(s->max))\n\t\ts->max = s->oo;\n\n\treturn !!oo_objects(s->oo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "s->object_size"
          ],
          "line": 3608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "s->size"
          ],
          "line": 3608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_random_long",
          "args": [],
          "line": 3598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_flags",
          "args": [
            "s->size",
            "flags",
            "s->name",
            "s->ctor"
          ],
          "line": 3596
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1350-1355",
          "snippet": "slab_flags_t kmem_cache_flags(unsigned int object_size,\n\tslab_flags_t flags, const char *name,\n\tvoid (*ctor)(void *))\n{\n\treturn flags;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nslab_flags_t kmem_cache_flags(unsigned int object_size,\n\tslab_flags_t flags, const char *name,\n\tvoid (*ctor)(void *))\n{\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define disable_higher_order_debug 0\n#define __CMPXCHG_DOUBLE\t((slab_flags_t __force)0x40000000U)\n#define DEBUG_METADATA_FLAGS (SLAB_RED_ZONE | SLAB_POISON | SLAB_STORE_USER)\n#define SLAB_NO_CMPXCHG (SLAB_CONSISTENCY_CHECKS | SLAB_STORE_USER | \\\n\t\t\t\tSLAB_TRACE)\n\nstatic int kmem_cache_open(struct kmem_cache *s, slab_flags_t flags)\n{\n\ts->flags = kmem_cache_flags(s->size, flags, s->name, s->ctor);\n#ifdef CONFIG_SLAB_FREELIST_HARDENED\n\ts->random = get_random_long();\n#endif\n\n\tif (!calculate_sizes(s, -1))\n\t\tgoto error;\n\tif (disable_higher_order_debug) {\n\t\t/*\n\t\t * Disable debugging flags that store metadata if the min slab\n\t\t * order increased.\n\t\t */\n\t\tif (get_order(s->size) > get_order(s->object_size)) {\n\t\t\ts->flags &= ~DEBUG_METADATA_FLAGS;\n\t\t\ts->offset = 0;\n\t\t\tif (!calculate_sizes(s, -1))\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\n#if defined(CONFIG_HAVE_CMPXCHG_DOUBLE) && \\\n    defined(CONFIG_HAVE_ALIGNED_STRUCT_PAGE)\n\tif (system_has_cmpxchg_double() && (s->flags & SLAB_NO_CMPXCHG) == 0)\n\t\t/* Enable fast mode */\n\t\ts->flags |= __CMPXCHG_DOUBLE;\n#endif\n\n\t/*\n\t * The larger the object size is, the more pages we want on the partial\n\t * list to avoid pounding the page allocator excessively.\n\t */\n\tset_min_partial(s, ilog2(s->size) / 2);\n\n\tset_cpu_partial(s);\n\n#ifdef CONFIG_NUMA\n\ts->remote_node_defrag_ratio = 1000;\n#endif\n\n\t/* Initialize the pre-computed randomized freelist if slab is up */\n\tif (slab_state >= UP) {\n\t\tif (init_cache_random_seq(s))\n\t\t\tgoto error;\n\t}\n\n\tif (!init_kmem_cache_nodes(s))\n\t\tgoto error;\n\n\tif (alloc_kmem_cache_cpus(s))\n\t\treturn 0;\n\n\tfree_kmem_cache_nodes(s);\nerror:\n\tif (flags & SLAB_PANIC)\n\t\tpanic(\"Cannot create slab %s size=%u realsize=%u order=%u offset=%u flags=%lx\\n\",\n\t\t      s->name, s->size, s->size,\n\t\t      oo_order(s->oo), s->offset, (unsigned long)flags);\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "calculate_sizes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "3476-3592",
    "snippet": "static int calculate_sizes(struct kmem_cache *s, int forced_order)\n{\n\tslab_flags_t flags = s->flags;\n\tunsigned int size = s->object_size;\n\tunsigned int order;\n\n\t/*\n\t * Round up object size to the next word boundary. We can only\n\t * place the free pointer at word boundaries and this determines\n\t * the possible location of the free pointer.\n\t */\n\tsize = ALIGN(size, sizeof(void *));\n\n#ifdef CONFIG_SLUB_DEBUG\n\t/*\n\t * Determine if we can poison the object itself. If the user of\n\t * the slab may touch the object after free or before allocation\n\t * then we should never poison the object itself.\n\t */\n\tif ((flags & SLAB_POISON) && !(flags & SLAB_TYPESAFE_BY_RCU) &&\n\t\t\t!s->ctor)\n\t\ts->flags |= __OBJECT_POISON;\n\telse\n\t\ts->flags &= ~__OBJECT_POISON;\n\n\n\t/*\n\t * If we are Redzoning then check if there is some space between the\n\t * end of the object and the free pointer. If not then add an\n\t * additional word to have some bytes to store Redzone information.\n\t */\n\tif ((flags & SLAB_RED_ZONE) && size == s->object_size)\n\t\tsize += sizeof(void *);\n#endif\n\n\t/*\n\t * With that we have determined the number of bytes in actual use\n\t * by the object. This is the potential offset to the free pointer.\n\t */\n\ts->inuse = size;\n\n\tif (((flags & (SLAB_TYPESAFE_BY_RCU | SLAB_POISON)) ||\n\t\ts->ctor)) {\n\t\t/*\n\t\t * Relocate free pointer after the object if it is not\n\t\t * permitted to overwrite the first word of the object on\n\t\t * kmem_cache_free.\n\t\t *\n\t\t * This is the case if we do RCU, have a constructor or\n\t\t * destructor or are poisoning the objects.\n\t\t */\n\t\ts->offset = size;\n\t\tsize += sizeof(void *);\n\t}\n\n#ifdef CONFIG_SLUB_DEBUG\n\tif (flags & SLAB_STORE_USER)\n\t\t/*\n\t\t * Need to store information about allocs and frees after\n\t\t * the object.\n\t\t */\n\t\tsize += 2 * sizeof(struct track);\n#endif\n\n\tkasan_cache_create(s, &size, &s->flags);\n#ifdef CONFIG_SLUB_DEBUG\n\tif (flags & SLAB_RED_ZONE) {\n\t\t/*\n\t\t * Add some empty padding so that we can catch\n\t\t * overwrites from earlier objects rather than let\n\t\t * tracking information or the free pointer be\n\t\t * corrupted if a user writes before the start\n\t\t * of the object.\n\t\t */\n\t\tsize += sizeof(void *);\n\n\t\ts->red_left_pad = sizeof(void *);\n\t\ts->red_left_pad = ALIGN(s->red_left_pad, s->align);\n\t\tsize += s->red_left_pad;\n\t}\n#endif\n\n\t/*\n\t * SLUB stores one object immediately after another beginning from\n\t * offset 0. In order to align the objects we have to simply size\n\t * each object to conform to the alignment.\n\t */\n\tsize = ALIGN(size, s->align);\n\ts->size = size;\n\tif (forced_order >= 0)\n\t\torder = forced_order;\n\telse\n\t\torder = calculate_order(size);\n\n\tif ((int)order < 0)\n\t\treturn 0;\n\n\ts->allocflags = 0;\n\tif (order)\n\t\ts->allocflags |= __GFP_COMP;\n\n\tif (s->flags & SLAB_CACHE_DMA)\n\t\ts->allocflags |= GFP_DMA;\n\n\tif (s->flags & SLAB_RECLAIM_ACCOUNT)\n\t\ts->allocflags |= __GFP_RECLAIMABLE;\n\n\t/*\n\t * Determine the number of objects per slab\n\t */\n\ts->oo = oo_make(order, size);\n\ts->min = oo_make(get_order(size), size);\n\tif (oo_objects(s->oo) > oo_objects(s->max))\n\t\ts->max = s->oo;\n\n\treturn !!oo_objects(s->oo);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define __OBJECT_POISON\t\t((slab_flags_t __force)0x80000000U)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "oo_objects",
          "args": [
            "s->oo"
          ],
          "line": 3591
        },
        "resolved": true,
        "details": {
          "function_name": "oo_objects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "337-340",
          "snippet": "static inline unsigned int oo_objects(struct kmem_cache_order_objects x)\n{\n\treturn x.x & OO_MASK;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define OO_MASK\t\t((1 << OO_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define OO_MASK\t\t((1 << OO_SHIFT) - 1)\n\nstatic inline unsigned int oo_objects(struct kmem_cache_order_objects x)\n{\n\treturn x.x & OO_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "oo_make",
          "args": [
            "get_order(size)",
            "size"
          ],
          "line": 3587
        },
        "resolved": true,
        "details": {
          "function_name": "oo_make",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "322-330",
          "snippet": "static inline struct kmem_cache_order_objects oo_make(unsigned int order,\n\t\tunsigned int size)\n{\n\tstruct kmem_cache_order_objects x = {\n\t\t(order << OO_SHIFT) + order_objects(order, size)\n\t};\n\n\treturn x;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define OO_SHIFT\t16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define OO_SHIFT\t16\n\nstatic inline struct kmem_cache_order_objects oo_make(unsigned int order,\n\t\tunsigned int size)\n{\n\tstruct kmem_cache_order_objects x = {\n\t\t(order << OO_SHIFT) + order_objects(order, size)\n\t};\n\n\treturn x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "size"
          ],
          "line": 3587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calculate_order",
          "args": [
            "size"
          ],
          "line": 3568
        },
        "resolved": true,
        "details": {
          "function_name": "calculate_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "3255-3304",
          "snippet": "static inline int calculate_order(unsigned int size)\n{\n\tunsigned int order;\n\tunsigned int min_objects;\n\tunsigned int max_objects;\n\n\t/*\n\t * Attempt to find best configuration for a slab. This\n\t * works by first attempting to generate a layout with\n\t * the best configuration and backing off gradually.\n\t *\n\t * First we increase the acceptable waste in a slab. Then\n\t * we reduce the minimum objects required in a slab.\n\t */\n\tmin_objects = slub_min_objects;\n\tif (!min_objects)\n\t\tmin_objects = 4 * (fls(nr_cpu_ids) + 1);\n\tmax_objects = order_objects(slub_max_order, size);\n\tmin_objects = min(min_objects, max_objects);\n\n\twhile (min_objects > 1) {\n\t\tunsigned int fraction;\n\n\t\tfraction = 16;\n\t\twhile (fraction >= 4) {\n\t\t\torder = slab_order(size, min_objects,\n\t\t\t\t\tslub_max_order, fraction);\n\t\t\tif (order <= slub_max_order)\n\t\t\t\treturn order;\n\t\t\tfraction /= 2;\n\t\t}\n\t\tmin_objects--;\n\t}\n\n\t/*\n\t * We were unable to place multiple objects in a slab. Now\n\t * lets see if we can place a single object there.\n\t */\n\torder = slab_order(size, 1, slub_max_order, 1);\n\tif (order <= slub_max_order)\n\t\treturn order;\n\n\t/*\n\t * Doh this slab cannot be placed using slub_max_order.\n\t */\n\torder = slab_order(size, 1, MAX_ORDER, 1);\n\tif (order < MAX_ORDER)\n\t\treturn order;\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int slub_max_order = PAGE_ALLOC_COSTLY_ORDER;",
            "static unsigned int slub_min_objects;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic unsigned int slub_max_order = PAGE_ALLOC_COSTLY_ORDER;\nstatic unsigned int slub_min_objects;\n\nstatic inline int calculate_order(unsigned int size)\n{\n\tunsigned int order;\n\tunsigned int min_objects;\n\tunsigned int max_objects;\n\n\t/*\n\t * Attempt to find best configuration for a slab. This\n\t * works by first attempting to generate a layout with\n\t * the best configuration and backing off gradually.\n\t *\n\t * First we increase the acceptable waste in a slab. Then\n\t * we reduce the minimum objects required in a slab.\n\t */\n\tmin_objects = slub_min_objects;\n\tif (!min_objects)\n\t\tmin_objects = 4 * (fls(nr_cpu_ids) + 1);\n\tmax_objects = order_objects(slub_max_order, size);\n\tmin_objects = min(min_objects, max_objects);\n\n\twhile (min_objects > 1) {\n\t\tunsigned int fraction;\n\n\t\tfraction = 16;\n\t\twhile (fraction >= 4) {\n\t\t\torder = slab_order(size, min_objects,\n\t\t\t\t\tslub_max_order, fraction);\n\t\t\tif (order <= slub_max_order)\n\t\t\t\treturn order;\n\t\t\tfraction /= 2;\n\t\t}\n\t\tmin_objects--;\n\t}\n\n\t/*\n\t * We were unable to place multiple objects in a slab. Now\n\t * lets see if we can place a single object there.\n\t */\n\torder = slab_order(size, 1, slub_max_order, 1);\n\tif (order <= slub_max_order)\n\t\treturn order;\n\n\t/*\n\t * Doh this slab cannot be placed using slub_max_order.\n\t */\n\torder = slab_order(size, 1, MAX_ORDER, 1);\n\tif (order < MAX_ORDER)\n\t\treturn order;\n\treturn -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "size",
            "s->align"
          ],
          "line": 3563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "s->red_left_pad",
            "s->align"
          ],
          "line": 3553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasan_cache_create",
          "args": [
            "s",
            "&size",
            "&s->flags"
          ],
          "line": 3540
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_cache_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "338-376",
          "snippet": "void kasan_cache_create(struct kmem_cache *cache, unsigned int *size,\n\t\t\tslab_flags_t *flags)\n{\n\tunsigned int orig_size = *size;\n\tint redzone_adjust;\n\n\t/* Add alloc meta. */\n\tcache->kasan_info.alloc_meta_offset = *size;\n\t*size += sizeof(struct kasan_alloc_meta);\n\n\t/* Add free meta. */\n\tif (cache->flags & SLAB_TYPESAFE_BY_RCU || cache->ctor ||\n\t    cache->object_size < sizeof(struct kasan_free_meta)) {\n\t\tcache->kasan_info.free_meta_offset = *size;\n\t\t*size += sizeof(struct kasan_free_meta);\n\t}\n\tredzone_adjust = optimal_redzone(cache->object_size) -\n\t\t(*size - cache->object_size);\n\n\tif (redzone_adjust > 0)\n\t\t*size += redzone_adjust;\n\n\t*size = min_t(unsigned int, KMALLOC_MAX_SIZE,\n\t\t\tmax(*size, cache->object_size +\n\t\t\t\t\toptimal_redzone(cache->object_size)));\n\n\t/*\n\t * If the metadata doesn't fit, don't enable KASAN at all.\n\t */\n\tif (*size <= cache->kasan_info.alloc_meta_offset ||\n\t\t\t*size <= cache->kasan_info.free_meta_offset) {\n\t\tcache->kasan_info.alloc_meta_offset = 0;\n\t\tcache->kasan_info.free_meta_offset = 0;\n\t\t*size = orig_size;\n\t\treturn;\n\t}\n\n\t*flags |= SLAB_KASAN;\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\nvoid kasan_cache_create(struct kmem_cache *cache, unsigned int *size,\n\t\t\tslab_flags_t *flags)\n{\n\tunsigned int orig_size = *size;\n\tint redzone_adjust;\n\n\t/* Add alloc meta. */\n\tcache->kasan_info.alloc_meta_offset = *size;\n\t*size += sizeof(struct kasan_alloc_meta);\n\n\t/* Add free meta. */\n\tif (cache->flags & SLAB_TYPESAFE_BY_RCU || cache->ctor ||\n\t    cache->object_size < sizeof(struct kasan_free_meta)) {\n\t\tcache->kasan_info.free_meta_offset = *size;\n\t\t*size += sizeof(struct kasan_free_meta);\n\t}\n\tredzone_adjust = optimal_redzone(cache->object_size) -\n\t\t(*size - cache->object_size);\n\n\tif (redzone_adjust > 0)\n\t\t*size += redzone_adjust;\n\n\t*size = min_t(unsigned int, KMALLOC_MAX_SIZE,\n\t\t\tmax(*size, cache->object_size +\n\t\t\t\t\toptimal_redzone(cache->object_size)));\n\n\t/*\n\t * If the metadata doesn't fit, don't enable KASAN at all.\n\t */\n\tif (*size <= cache->kasan_info.alloc_meta_offset ||\n\t\t\t*size <= cache->kasan_info.free_meta_offset) {\n\t\tcache->kasan_info.alloc_meta_offset = 0;\n\t\tcache->kasan_info.free_meta_offset = 0;\n\t\t*size = orig_size;\n\t\treturn;\n\t}\n\n\t*flags |= SLAB_KASAN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "size",
            "sizeof(void *)"
          ],
          "line": 3487
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define __OBJECT_POISON\t\t((slab_flags_t __force)0x80000000U)\n\nstatic int calculate_sizes(struct kmem_cache *s, int forced_order)\n{\n\tslab_flags_t flags = s->flags;\n\tunsigned int size = s->object_size;\n\tunsigned int order;\n\n\t/*\n\t * Round up object size to the next word boundary. We can only\n\t * place the free pointer at word boundaries and this determines\n\t * the possible location of the free pointer.\n\t */\n\tsize = ALIGN(size, sizeof(void *));\n\n#ifdef CONFIG_SLUB_DEBUG\n\t/*\n\t * Determine if we can poison the object itself. If the user of\n\t * the slab may touch the object after free or before allocation\n\t * then we should never poison the object itself.\n\t */\n\tif ((flags & SLAB_POISON) && !(flags & SLAB_TYPESAFE_BY_RCU) &&\n\t\t\t!s->ctor)\n\t\ts->flags |= __OBJECT_POISON;\n\telse\n\t\ts->flags &= ~__OBJECT_POISON;\n\n\n\t/*\n\t * If we are Redzoning then check if there is some space between the\n\t * end of the object and the free pointer. If not then add an\n\t * additional word to have some bytes to store Redzone information.\n\t */\n\tif ((flags & SLAB_RED_ZONE) && size == s->object_size)\n\t\tsize += sizeof(void *);\n#endif\n\n\t/*\n\t * With that we have determined the number of bytes in actual use\n\t * by the object. This is the potential offset to the free pointer.\n\t */\n\ts->inuse = size;\n\n\tif (((flags & (SLAB_TYPESAFE_BY_RCU | SLAB_POISON)) ||\n\t\ts->ctor)) {\n\t\t/*\n\t\t * Relocate free pointer after the object if it is not\n\t\t * permitted to overwrite the first word of the object on\n\t\t * kmem_cache_free.\n\t\t *\n\t\t * This is the case if we do RCU, have a constructor or\n\t\t * destructor or are poisoning the objects.\n\t\t */\n\t\ts->offset = size;\n\t\tsize += sizeof(void *);\n\t}\n\n#ifdef CONFIG_SLUB_DEBUG\n\tif (flags & SLAB_STORE_USER)\n\t\t/*\n\t\t * Need to store information about allocs and frees after\n\t\t * the object.\n\t\t */\n\t\tsize += 2 * sizeof(struct track);\n#endif\n\n\tkasan_cache_create(s, &size, &s->flags);\n#ifdef CONFIG_SLUB_DEBUG\n\tif (flags & SLAB_RED_ZONE) {\n\t\t/*\n\t\t * Add some empty padding so that we can catch\n\t\t * overwrites from earlier objects rather than let\n\t\t * tracking information or the free pointer be\n\t\t * corrupted if a user writes before the start\n\t\t * of the object.\n\t\t */\n\t\tsize += sizeof(void *);\n\n\t\ts->red_left_pad = sizeof(void *);\n\t\ts->red_left_pad = ALIGN(s->red_left_pad, s->align);\n\t\tsize += s->red_left_pad;\n\t}\n#endif\n\n\t/*\n\t * SLUB stores one object immediately after another beginning from\n\t * offset 0. In order to align the objects we have to simply size\n\t * each object to conform to the alignment.\n\t */\n\tsize = ALIGN(size, s->align);\n\ts->size = size;\n\tif (forced_order >= 0)\n\t\torder = forced_order;\n\telse\n\t\torder = calculate_order(size);\n\n\tif ((int)order < 0)\n\t\treturn 0;\n\n\ts->allocflags = 0;\n\tif (order)\n\t\ts->allocflags |= __GFP_COMP;\n\n\tif (s->flags & SLAB_CACHE_DMA)\n\t\ts->allocflags |= GFP_DMA;\n\n\tif (s->flags & SLAB_RECLAIM_ACCOUNT)\n\t\ts->allocflags |= __GFP_RECLAIMABLE;\n\n\t/*\n\t * Determine the number of objects per slab\n\t */\n\ts->oo = oo_make(order, size);\n\ts->min = oo_make(get_order(size), size);\n\tif (oo_objects(s->oo) > oo_objects(s->max))\n\t\ts->max = s->oo;\n\n\treturn !!oo_objects(s->oo);\n}"
  },
  {
    "function_name": "set_cpu_partial",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "3439-3470",
    "snippet": "static void set_cpu_partial(struct kmem_cache *s)\n{\n#ifdef CONFIG_SLUB_CPU_PARTIAL\n\t/*\n\t * cpu_partial determined the maximum number of objects kept in the\n\t * per cpu partial lists of a processor.\n\t *\n\t * Per cpu partial lists mainly contain slabs that just have one\n\t * object freed. If they are used for allocation then they can be\n\t * filled up again with minimal effort. The slab will never hit the\n\t * per node partial lists and therefore no locking will be required.\n\t *\n\t * This setting also determines\n\t *\n\t * A) The number of objects from per cpu partial slabs dumped to the\n\t *    per node list when we reach the limit.\n\t * B) The number of objects in cpu partial slabs to extract from the\n\t *    per node list when we run out of per cpu objects. We only fetch\n\t *    50% to keep some capacity around for frees.\n\t */\n\tif (!kmem_cache_has_cpu_partial(s))\n\t\ts->cpu_partial = 0;\n\telse if (s->size >= PAGE_SIZE)\n\t\ts->cpu_partial = 2;\n\telse if (s->size >= 1024)\n\t\ts->cpu_partial = 6;\n\telse if (s->size >= 256)\n\t\ts->cpu_partial = 13;\n\telse\n\t\ts->cpu_partial = 30;\n#endif\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_has_cpu_partial",
          "args": [
            "s"
          ],
          "line": 3459
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_has_cpu_partial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "135-142",
          "snippet": "static inline bool kmem_cache_has_cpu_partial(struct kmem_cache *s)\n{\n#ifdef CONFIG_SLUB_CPU_PARTIAL\n\treturn !kmem_cache_debug(s);\n#else\n\treturn false;\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline bool kmem_cache_has_cpu_partial(struct kmem_cache *s)\n{\n#ifdef CONFIG_SLUB_CPU_PARTIAL\n\treturn !kmem_cache_debug(s);\n#else\n\treturn false;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void set_cpu_partial(struct kmem_cache *s)\n{\n#ifdef CONFIG_SLUB_CPU_PARTIAL\n\t/*\n\t * cpu_partial determined the maximum number of objects kept in the\n\t * per cpu partial lists of a processor.\n\t *\n\t * Per cpu partial lists mainly contain slabs that just have one\n\t * object freed. If they are used for allocation then they can be\n\t * filled up again with minimal effort. The slab will never hit the\n\t * per node partial lists and therefore no locking will be required.\n\t *\n\t * This setting also determines\n\t *\n\t * A) The number of objects from per cpu partial slabs dumped to the\n\t *    per node list when we reach the limit.\n\t * B) The number of objects in cpu partial slabs to extract from the\n\t *    per node list when we run out of per cpu objects. We only fetch\n\t *    50% to keep some capacity around for frees.\n\t */\n\tif (!kmem_cache_has_cpu_partial(s))\n\t\ts->cpu_partial = 0;\n\telse if (s->size >= PAGE_SIZE)\n\t\ts->cpu_partial = 2;\n\telse if (s->size >= 1024)\n\t\ts->cpu_partial = 6;\n\telse if (s->size >= 256)\n\t\ts->cpu_partial = 13;\n\telse\n\t\ts->cpu_partial = 30;\n#endif\n}"
  },
  {
    "function_name": "set_min_partial",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "3430-3437",
    "snippet": "static void set_min_partial(struct kmem_cache *s, unsigned long min)\n{\n\tif (min < MIN_PARTIAL)\n\t\tmin = MIN_PARTIAL;\n\telse if (min > MAX_PARTIAL)\n\t\tmin = MAX_PARTIAL;\n\ts->min_partial = min;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define MAX_PARTIAL 10",
      "#define MIN_PARTIAL 5"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define MAX_PARTIAL 10\n#define MIN_PARTIAL 5\n\nstatic void set_min_partial(struct kmem_cache *s, unsigned long min)\n{\n\tif (min < MIN_PARTIAL)\n\t\tmin = MIN_PARTIAL;\n\telse if (min > MAX_PARTIAL)\n\t\tmin = MAX_PARTIAL;\n\ts->min_partial = min;\n}"
  },
  {
    "function_name": "init_kmem_cache_nodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "3405-3428",
    "snippet": "static int init_kmem_cache_nodes(struct kmem_cache *s)\n{\n\tint node;\n\n\tfor_each_node_state(node, N_NORMAL_MEMORY) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tif (slab_state == DOWN) {\n\t\t\tearly_kmem_cache_node_alloc(node);\n\t\t\tcontinue;\n\t\t}\n\t\tn = kmem_cache_alloc_node(kmem_cache_node,\n\t\t\t\t\t\tGFP_KERNEL, node);\n\n\t\tif (!n) {\n\t\t\tfree_kmem_cache_nodes(s);\n\t\t\treturn 0;\n\t\t}\n\n\t\tinit_kmem_cache_node(n);\n\t\ts->node[node] = n;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *kmem_cache_node;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_kmem_cache_node",
          "args": [
            "n"
          ],
          "line": 3424
        },
        "resolved": true,
        "details": {
          "function_name": "init_kmem_cache_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "3405-3428",
          "snippet": "static int init_kmem_cache_nodes(struct kmem_cache *s)\n{\n\tint node;\n\n\tfor_each_node_state(node, N_NORMAL_MEMORY) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tif (slab_state == DOWN) {\n\t\t\tearly_kmem_cache_node_alloc(node);\n\t\t\tcontinue;\n\t\t}\n\t\tn = kmem_cache_alloc_node(kmem_cache_node,\n\t\t\t\t\t\tGFP_KERNEL, node);\n\n\t\tif (!n) {\n\t\t\tfree_kmem_cache_nodes(s);\n\t\t\treturn 0;\n\t\t}\n\n\t\tinit_kmem_cache_node(n);\n\t\ts->node[node] = n;\n\t}\n\treturn 1;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "free_kmem_cache_nodes",
          "args": [
            "s"
          ],
          "line": 3420
        },
        "resolved": true,
        "details": {
          "function_name": "free_kmem_cache_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "3387-3396",
          "snippet": "static void free_kmem_cache_nodes(struct kmem_cache *s)\n{\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tfor_each_kmem_cache_node(s, node, n) {\n\t\ts->node[node] = NULL;\n\t\tkmem_cache_free(kmem_cache_node, n);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic void free_kmem_cache_nodes(struct kmem_cache *s)\n{\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tfor_each_kmem_cache_node(s, node, n) {\n\t\ts->node[node] = NULL;\n\t\tkmem_cache_free(kmem_cache_node, n);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc_node",
          "args": [
            "kmem_cache_node",
            "GFP_KERNEL",
            "node"
          ],
          "line": 3416
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_alloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2778-2786",
          "snippet": "void *kmem_cache_alloc_node(struct kmem_cache *s, gfp_t gfpflags, int node)\n{\n\tvoid *ret = slab_alloc_node(s, gfpflags, node, _RET_IP_);\n\n\ttrace_kmem_cache_alloc_node(_RET_IP_, ret,\n\t\t\t\t    s->object_size, s->size, gfpflags, node);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);\n\nvoid *kmem_cache_alloc_node(struct kmem_cache *s, gfp_t gfpflags, int node)\n{\n\tvoid *ret = slab_alloc_node(s, gfpflags, node, _RET_IP_);\n\n\ttrace_kmem_cache_alloc_node(_RET_IP_, ret,\n\t\t\t\t    s->object_size, s->size, gfpflags, node);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "early_kmem_cache_node_alloc",
          "args": [
            "node"
          ],
          "line": 3413
        },
        "resolved": true,
        "details": {
          "function_name": "early_kmem_cache_node_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "3350-3385",
          "snippet": "static void early_kmem_cache_node_alloc(int node)\n{\n\tstruct page *page;\n\tstruct kmem_cache_node *n;\n\n\tBUG_ON(kmem_cache_node->size < sizeof(struct kmem_cache_node));\n\n\tpage = new_slab(kmem_cache_node, GFP_NOWAIT, node);\n\n\tBUG_ON(!page);\n\tif (page_to_nid(page) != node) {\n\t\tpr_err(\"SLUB: Unable to allocate memory from node %d\\n\", node);\n\t\tpr_err(\"SLUB: Allocating a useless per node structure in order to be able to continue\\n\");\n\t}\n\n\tn = page->freelist;\n\tBUG_ON(!n);\n\tpage->freelist = get_freepointer(kmem_cache_node, n);\n\tpage->inuse = 1;\n\tpage->frozen = 0;\n\tkmem_cache_node->node[node] = n;\n#ifdef CONFIG_SLUB_DEBUG\n\tinit_object(kmem_cache_node, n, SLUB_RED_ACTIVE);\n\tinit_tracking(kmem_cache_node, n);\n#endif\n\tkasan_kmalloc(kmem_cache_node, n, sizeof(struct kmem_cache_node),\n\t\t      GFP_KERNEL);\n\tinit_kmem_cache_node(n);\n\tinc_slabs_node(kmem_cache_node, node, page->objects);\n\n\t/*\n\t * No locks need to be taken here as it has just been\n\t * initialized and there is no concurrent access.\n\t */\n\t__add_partial(n, page, DEACTIVATE_TO_HEAD);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic void early_kmem_cache_node_alloc(int node)\n{\n\tstruct page *page;\n\tstruct kmem_cache_node *n;\n\n\tBUG_ON(kmem_cache_node->size < sizeof(struct kmem_cache_node));\n\n\tpage = new_slab(kmem_cache_node, GFP_NOWAIT, node);\n\n\tBUG_ON(!page);\n\tif (page_to_nid(page) != node) {\n\t\tpr_err(\"SLUB: Unable to allocate memory from node %d\\n\", node);\n\t\tpr_err(\"SLUB: Allocating a useless per node structure in order to be able to continue\\n\");\n\t}\n\n\tn = page->freelist;\n\tBUG_ON(!n);\n\tpage->freelist = get_freepointer(kmem_cache_node, n);\n\tpage->inuse = 1;\n\tpage->frozen = 0;\n\tkmem_cache_node->node[node] = n;\n#ifdef CONFIG_SLUB_DEBUG\n\tinit_object(kmem_cache_node, n, SLUB_RED_ACTIVE);\n\tinit_tracking(kmem_cache_node, n);\n#endif\n\tkasan_kmalloc(kmem_cache_node, n, sizeof(struct kmem_cache_node),\n\t\t      GFP_KERNEL);\n\tinit_kmem_cache_node(n);\n\tinc_slabs_node(kmem_cache_node, node, page->objects);\n\n\t/*\n\t * No locks need to be taken here as it has just been\n\t * initialized and there is no concurrent access.\n\t */\n\t__add_partial(n, page, DEACTIVATE_TO_HEAD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_node_state",
          "args": [
            "node",
            "N_NORMAL_MEMORY"
          ],
          "line": 3409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic int init_kmem_cache_nodes(struct kmem_cache *s)\n{\n\tint node;\n\n\tfor_each_node_state(node, N_NORMAL_MEMORY) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tif (slab_state == DOWN) {\n\t\t\tearly_kmem_cache_node_alloc(node);\n\t\t\tcontinue;\n\t\t}\n\t\tn = kmem_cache_alloc_node(kmem_cache_node,\n\t\t\t\t\t\tGFP_KERNEL, node);\n\n\t\tif (!n) {\n\t\t\tfree_kmem_cache_nodes(s);\n\t\t\treturn 0;\n\t\t}\n\n\t\tinit_kmem_cache_node(n);\n\t\ts->node[node] = n;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "__kmem_cache_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "3398-3403",
    "snippet": "void __kmem_cache_release(struct kmem_cache *s)\n{\n\tcache_random_seq_destroy(s);\n\tfree_percpu(s->cpu_slab);\n\tfree_kmem_cache_nodes(s);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_kmem_cache_nodes",
          "args": [
            "s"
          ],
          "line": 3402
        },
        "resolved": true,
        "details": {
          "function_name": "free_kmem_cache_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "3387-3396",
          "snippet": "static void free_kmem_cache_nodes(struct kmem_cache *s)\n{\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tfor_each_kmem_cache_node(s, node, n) {\n\t\ts->node[node] = NULL;\n\t\tkmem_cache_free(kmem_cache_node, n);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic void free_kmem_cache_nodes(struct kmem_cache *s)\n{\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tfor_each_kmem_cache_node(s, node, n) {\n\t\ts->node[node] = NULL;\n\t\tkmem_cache_free(kmem_cache_node, n);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "s->cpu_slab"
          ],
          "line": 3401
        },
        "resolved": true,
        "details": {
          "function_name": "free_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "1718-1753",
          "snippet": "void free_percpu(void __percpu *ptr)\n{\n\tvoid *addr;\n\tstruct pcpu_chunk *chunk;\n\tunsigned long flags;\n\tint off;\n\n\tif (!ptr)\n\t\treturn;\n\n\tkmemleak_free_percpu(ptr);\n\n\taddr = __pcpu_ptr_to_addr(ptr);\n\n\tspin_lock_irqsave(&pcpu_lock, flags);\n\n\tchunk = pcpu_chunk_addr_search(addr);\n\toff = addr - chunk->base_addr;\n\n\tpcpu_free_area(chunk, off);\n\n\t/* if there are more than one fully free chunks, wake up grim reaper */\n\tif (chunk->free_bytes == pcpu_unit_size) {\n\t\tstruct pcpu_chunk *pos;\n\n\t\tlist_for_each_entry(pos, &pcpu_slot[pcpu_nr_slots - 1], list)\n\t\t\tif (pos != chunk) {\n\t\t\t\tpcpu_schedule_balance_work();\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\ttrace_percpu_free_percpu(chunk->base_addr, off, ptr);\n\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int pcpu_unit_size",
            "int pcpu_nr_slots",
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);",
            "static struct page *pcpu_addr_to_page(void *addr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int pcpu_unit_size;\nint pcpu_nr_slots;\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\nstatic struct page *pcpu_addr_to_page(void *addr);\n\nvoid free_percpu(void __percpu *ptr)\n{\n\tvoid *addr;\n\tstruct pcpu_chunk *chunk;\n\tunsigned long flags;\n\tint off;\n\n\tif (!ptr)\n\t\treturn;\n\n\tkmemleak_free_percpu(ptr);\n\n\taddr = __pcpu_ptr_to_addr(ptr);\n\n\tspin_lock_irqsave(&pcpu_lock, flags);\n\n\tchunk = pcpu_chunk_addr_search(addr);\n\toff = addr - chunk->base_addr;\n\n\tpcpu_free_area(chunk, off);\n\n\t/* if there are more than one fully free chunks, wake up grim reaper */\n\tif (chunk->free_bytes == pcpu_unit_size) {\n\t\tstruct pcpu_chunk *pos;\n\n\t\tlist_for_each_entry(pos, &pcpu_slot[pcpu_nr_slots - 1], list)\n\t\t\tif (pos != chunk) {\n\t\t\t\tpcpu_schedule_balance_work();\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\ttrace_percpu_free_percpu(chunk->base_addr, off, ptr);\n\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_random_seq_destroy",
          "args": [
            "s"
          ],
          "line": 3400
        },
        "resolved": true,
        "details": {
          "function_name": "cache_random_seq_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "528-528",
          "snippet": "static inline void cache_random_seq_destroy(struct kmem_cache *cachep) { }",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline void cache_random_seq_destroy(struct kmem_cache *cachep) { }"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid __kmem_cache_release(struct kmem_cache *s)\n{\n\tcache_random_seq_destroy(s);\n\tfree_percpu(s->cpu_slab);\n\tfree_kmem_cache_nodes(s);\n}"
  },
  {
    "function_name": "free_kmem_cache_nodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "3387-3396",
    "snippet": "static void free_kmem_cache_nodes(struct kmem_cache *s)\n{\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tfor_each_kmem_cache_node(s, node, n) {\n\t\ts->node[node] = NULL;\n\t\tkmem_cache_free(kmem_cache_node, n);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *kmem_cache_node;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "kmem_cache_node",
            "n"
          ],
          "line": 3394
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "3002-3009",
          "snippet": "void kmem_cache_free(struct kmem_cache *s, void *x)\n{\n\ts = cache_from_obj(s, x);\n\tif (!s)\n\t\treturn;\n\tslab_free(s, virt_to_head_page(x), x, NULL, 1, _RET_IP_);\n\ttrace_kmem_cache_free(_RET_IP_, x);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid kmem_cache_free(struct kmem_cache *s, void *x)\n{\n\ts = cache_from_obj(s, x);\n\tif (!s)\n\t\treturn;\n\tslab_free(s, virt_to_head_page(x), x, NULL, 1, _RET_IP_);\n\ttrace_kmem_cache_free(_RET_IP_, x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_kmem_cache_node",
          "args": [
            "s",
            "node",
            "n"
          ],
          "line": 3392
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic void free_kmem_cache_nodes(struct kmem_cache *s)\n{\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tfor_each_kmem_cache_node(s, node, n) {\n\t\ts->node[node] = NULL;\n\t\tkmem_cache_free(kmem_cache_node, n);\n\t}\n}"
  },
  {
    "function_name": "early_kmem_cache_node_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "3350-3385",
    "snippet": "static void early_kmem_cache_node_alloc(int node)\n{\n\tstruct page *page;\n\tstruct kmem_cache_node *n;\n\n\tBUG_ON(kmem_cache_node->size < sizeof(struct kmem_cache_node));\n\n\tpage = new_slab(kmem_cache_node, GFP_NOWAIT, node);\n\n\tBUG_ON(!page);\n\tif (page_to_nid(page) != node) {\n\t\tpr_err(\"SLUB: Unable to allocate memory from node %d\\n\", node);\n\t\tpr_err(\"SLUB: Allocating a useless per node structure in order to be able to continue\\n\");\n\t}\n\n\tn = page->freelist;\n\tBUG_ON(!n);\n\tpage->freelist = get_freepointer(kmem_cache_node, n);\n\tpage->inuse = 1;\n\tpage->frozen = 0;\n\tkmem_cache_node->node[node] = n;\n#ifdef CONFIG_SLUB_DEBUG\n\tinit_object(kmem_cache_node, n, SLUB_RED_ACTIVE);\n\tinit_tracking(kmem_cache_node, n);\n#endif\n\tkasan_kmalloc(kmem_cache_node, n, sizeof(struct kmem_cache_node),\n\t\t      GFP_KERNEL);\n\tinit_kmem_cache_node(n);\n\tinc_slabs_node(kmem_cache_node, node, page->objects);\n\n\t/*\n\t * No locks need to be taken here as it has just been\n\t * initialized and there is no concurrent access.\n\t */\n\t__add_partial(n, page, DEACTIVATE_TO_HEAD);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *kmem_cache_node;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__add_partial",
          "args": [
            "n",
            "page",
            "DEACTIVATE_TO_HEAD"
          ],
          "line": 3384
        },
        "resolved": true,
        "details": {
          "function_name": "__add_partial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1749-1757",
          "snippet": "static inline void\n__add_partial(struct kmem_cache_node *n, struct page *page, int tail)\n{\n\tn->nr_partial++;\n\tif (tail == DEACTIVATE_TO_TAIL)\n\t\tlist_add_tail(&page->lru, &n->partial);\n\telse\n\t\tlist_add(&page->lru, &n->partial);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic inline void\n__add_partial(struct kmem_cache_node *n, struct page *page, int tail)\n{\n\tn->nr_partial++;\n\tif (tail == DEACTIVATE_TO_TAIL)\n\t\tlist_add_tail(&page->lru, &n->partial);\n\telse\n\t\tlist_add(&page->lru, &n->partial);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_slabs_node",
          "args": [
            "kmem_cache_node",
            "node",
            "page->objects"
          ],
          "line": 3378
        },
        "resolved": true,
        "details": {
          "function_name": "inc_slabs_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1364-1365",
          "snippet": "static inline void inc_slabs_node(struct kmem_cache *s, int node,\n\t\t\t\t\t\t\tint objects) {}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void inc_slabs_node(struct kmem_cache *s, int node,\n\t\t\t\t\t\t\tint objects) {}"
        }
      },
      {
        "call_info": {
          "callee": "init_kmem_cache_node",
          "args": [
            "n"
          ],
          "line": 3377
        },
        "resolved": true,
        "details": {
          "function_name": "init_kmem_cache_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "3405-3428",
          "snippet": "static int init_kmem_cache_nodes(struct kmem_cache *s)\n{\n\tint node;\n\n\tfor_each_node_state(node, N_NORMAL_MEMORY) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tif (slab_state == DOWN) {\n\t\t\tearly_kmem_cache_node_alloc(node);\n\t\t\tcontinue;\n\t\t}\n\t\tn = kmem_cache_alloc_node(kmem_cache_node,\n\t\t\t\t\t\tGFP_KERNEL, node);\n\n\t\tif (!n) {\n\t\t\tfree_kmem_cache_nodes(s);\n\t\t\treturn 0;\n\t\t}\n\n\t\tinit_kmem_cache_node(n);\n\t\ts->node[node] = n;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic int init_kmem_cache_nodes(struct kmem_cache *s)\n{\n\tint node;\n\n\tfor_each_node_state(node, N_NORMAL_MEMORY) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tif (slab_state == DOWN) {\n\t\t\tearly_kmem_cache_node_alloc(node);\n\t\t\tcontinue;\n\t\t}\n\t\tn = kmem_cache_alloc_node(kmem_cache_node,\n\t\t\t\t\t\tGFP_KERNEL, node);\n\n\t\tif (!n) {\n\t\t\tfree_kmem_cache_nodes(s);\n\t\t\treturn 0;\n\t\t}\n\n\t\tinit_kmem_cache_node(n);\n\t\ts->node[node] = n;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kasan_kmalloc",
          "args": [
            "kmem_cache_node",
            "n",
            "sizeof(struct kmem_cache_node)",
            "GFP_KERNEL"
          ],
          "line": 3375
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "531-554",
          "snippet": "void kasan_kmalloc(struct kmem_cache *cache, const void *object, size_t size,\n\t\t   gfp_t flags)\n{\n\tunsigned long redzone_start;\n\tunsigned long redzone_end;\n\n\tif (gfpflags_allow_blocking(flags))\n\t\tquarantine_reduce();\n\n\tif (unlikely(object == NULL))\n\t\treturn;\n\n\tredzone_start = round_up((unsigned long)(object + size),\n\t\t\t\tKASAN_SHADOW_SCALE_SIZE);\n\tredzone_end = round_up((unsigned long)object + cache->object_size,\n\t\t\t\tKASAN_SHADOW_SCALE_SIZE);\n\n\tkasan_unpoison_shadow(object, size);\n\tkasan_poison_shadow((void *)redzone_start, redzone_end - redzone_start,\n\t\tKASAN_KMALLOC_REDZONE);\n\n\tif (cache->flags & SLAB_KASAN)\n\t\tset_track(&get_alloc_info(cache, object)->alloc_track, flags);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid kasan_kmalloc(struct kmem_cache *cache, const void *object, size_t size,\n\t\t   gfp_t flags)\n{\n\tunsigned long redzone_start;\n\tunsigned long redzone_end;\n\n\tif (gfpflags_allow_blocking(flags))\n\t\tquarantine_reduce();\n\n\tif (unlikely(object == NULL))\n\t\treturn;\n\n\tredzone_start = round_up((unsigned long)(object + size),\n\t\t\t\tKASAN_SHADOW_SCALE_SIZE);\n\tredzone_end = round_up((unsigned long)object + cache->object_size,\n\t\t\t\tKASAN_SHADOW_SCALE_SIZE);\n\n\tkasan_unpoison_shadow(object, size);\n\tkasan_poison_shadow((void *)redzone_start, redzone_end - redzone_start,\n\t\tKASAN_KMALLOC_REDZONE);\n\n\tif (cache->flags & SLAB_KASAN)\n\t\tset_track(&get_alloc_info(cache, object)->alloc_track, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_tracking",
          "args": [
            "kmem_cache_node",
            "n"
          ],
          "line": 3373
        },
        "resolved": true,
        "details": {
          "function_name": "init_tracking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "575-582",
          "snippet": "static void init_tracking(struct kmem_cache *s, void *object)\n{\n\tif (!(s->flags & SLAB_STORE_USER))\n\t\treturn;\n\n\tset_track(s, object, TRACK_FREE, 0UL);\n\tset_track(s, object, TRACK_ALLOC, 0UL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void init_tracking(struct kmem_cache *s, void *object)\n{\n\tif (!(s->flags & SLAB_STORE_USER))\n\t\treturn;\n\n\tset_track(s, object, TRACK_FREE, 0UL);\n\tset_track(s, object, TRACK_ALLOC, 0UL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_object",
          "args": [
            "kmem_cache_node",
            "n",
            "SLUB_RED_ACTIVE"
          ],
          "line": 3372
        },
        "resolved": true,
        "details": {
          "function_name": "init_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "711-725",
          "snippet": "static void init_object(struct kmem_cache *s, void *object, u8 val)\n{\n\tu8 *p = object;\n\n\tif (s->flags & SLAB_RED_ZONE)\n\t\tmemset(p - s->red_left_pad, val, s->red_left_pad);\n\n\tif (s->flags & __OBJECT_POISON) {\n\t\tmemset(p, POISON_FREE, s->object_size - 1);\n\t\tp[s->object_size - 1] = POISON_END;\n\t}\n\n\tif (s->flags & SLAB_RED_ZONE)\n\t\tmemset(p + s->object_size, val, s->inuse - s->object_size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define __OBJECT_POISON\t\t((slab_flags_t __force)0x80000000U)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define __OBJECT_POISON\t\t((slab_flags_t __force)0x80000000U)\n\nstatic void init_object(struct kmem_cache *s, void *object, u8 val)\n{\n\tu8 *p = object;\n\n\tif (s->flags & SLAB_RED_ZONE)\n\t\tmemset(p - s->red_left_pad, val, s->red_left_pad);\n\n\tif (s->flags & __OBJECT_POISON) {\n\t\tmemset(p, POISON_FREE, s->object_size - 1);\n\t\tp[s->object_size - 1] = POISON_END;\n\t}\n\n\tif (s->flags & SLAB_RED_ZONE)\n\t\tmemset(p + s->object_size, val, s->inuse - s->object_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_freepointer",
          "args": [
            "kmem_cache_node",
            "n"
          ],
          "line": 3367
        },
        "resolved": true,
        "details": {
          "function_name": "get_freepointer_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "276-287",
          "snippet": "static inline void *get_freepointer_safe(struct kmem_cache *s, void *object)\n{\n\tunsigned long freepointer_addr;\n\tvoid *p;\n\n\tif (!debug_pagealloc_enabled())\n\t\treturn get_freepointer(s, object);\n\n\tfreepointer_addr = (unsigned long)object + s->offset;\n\tprobe_kernel_read(&p, (void **)freepointer_addr, sizeof(p));\n\treturn freelist_ptr(s, p, freepointer_addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void *get_freepointer_safe(struct kmem_cache *s, void *object)\n{\n\tunsigned long freepointer_addr;\n\tvoid *p;\n\n\tif (!debug_pagealloc_enabled())\n\t\treturn get_freepointer(s, object);\n\n\tfreepointer_addr = (unsigned long)object + s->offset;\n\tprobe_kernel_read(&p, (void **)freepointer_addr, sizeof(p));\n\treturn freelist_ptr(s, p, freepointer_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!n"
          ],
          "line": 3366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"SLUB: Allocating a useless per node structure in order to be able to continue\\n\""
          ],
          "line": 3362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"SLUB: Unable to allocate memory from node %d\\n\"",
            "node"
          ],
          "line": 3361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 3360
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!page"
          ],
          "line": 3359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_slab",
          "args": [
            "kmem_cache_node",
            "GFP_NOWAIT",
            "node"
          ],
          "line": 3357
        },
        "resolved": true,
        "details": {
          "function_name": "new_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1682-1694",
          "snippet": "static struct page *new_slab(struct kmem_cache *s, gfp_t flags, int node)\n{\n\tif (unlikely(flags & GFP_SLAB_BUG_MASK)) {\n\t\tgfp_t invalid_mask = flags & GFP_SLAB_BUG_MASK;\n\t\tflags &= ~GFP_SLAB_BUG_MASK;\n\t\tpr_warn(\"Unexpected gfp: %#x (%pGg). Fixing up to gfp: %#x (%pGg). Fix your code!\\n\",\n\t\t\t\tinvalid_mask, &invalid_mask, flags, &flags);\n\t\tdump_stack();\n\t}\n\n\treturn allocate_slab(s,\n\t\tflags & (GFP_RECLAIM_MASK | GFP_CONSTRAINT_MASK), node);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct page *new_slab(struct kmem_cache *s, gfp_t flags, int node)\n{\n\tif (unlikely(flags & GFP_SLAB_BUG_MASK)) {\n\t\tgfp_t invalid_mask = flags & GFP_SLAB_BUG_MASK;\n\t\tflags &= ~GFP_SLAB_BUG_MASK;\n\t\tpr_warn(\"Unexpected gfp: %#x (%pGg). Fixing up to gfp: %#x (%pGg). Fix your code!\\n\",\n\t\t\t\tinvalid_mask, &invalid_mask, flags, &flags);\n\t\tdump_stack();\n\t}\n\n\treturn allocate_slab(s,\n\t\tflags & (GFP_RECLAIM_MASK | GFP_CONSTRAINT_MASK), node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "kmem_cache_node->size < sizeof(struct kmem_cache_node)"
          ],
          "line": 3355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic void early_kmem_cache_node_alloc(int node)\n{\n\tstruct page *page;\n\tstruct kmem_cache_node *n;\n\n\tBUG_ON(kmem_cache_node->size < sizeof(struct kmem_cache_node));\n\n\tpage = new_slab(kmem_cache_node, GFP_NOWAIT, node);\n\n\tBUG_ON(!page);\n\tif (page_to_nid(page) != node) {\n\t\tpr_err(\"SLUB: Unable to allocate memory from node %d\\n\", node);\n\t\tpr_err(\"SLUB: Allocating a useless per node structure in order to be able to continue\\n\");\n\t}\n\n\tn = page->freelist;\n\tBUG_ON(!n);\n\tpage->freelist = get_freepointer(kmem_cache_node, n);\n\tpage->inuse = 1;\n\tpage->frozen = 0;\n\tkmem_cache_node->node[node] = n;\n#ifdef CONFIG_SLUB_DEBUG\n\tinit_object(kmem_cache_node, n, SLUB_RED_ACTIVE);\n\tinit_tracking(kmem_cache_node, n);\n#endif\n\tkasan_kmalloc(kmem_cache_node, n, sizeof(struct kmem_cache_node),\n\t\t      GFP_KERNEL);\n\tinit_kmem_cache_node(n);\n\tinc_slabs_node(kmem_cache_node, node, page->objects);\n\n\t/*\n\t * No locks need to be taken here as it has just been\n\t * initialized and there is no concurrent access.\n\t */\n\t__add_partial(n, page, DEACTIVATE_TO_HEAD);\n}"
  },
  {
    "function_name": "alloc_kmem_cache_cpus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "3319-3337",
    "snippet": "static inline int alloc_kmem_cache_cpus(struct kmem_cache *s)\n{\n\tBUILD_BUG_ON(PERCPU_DYNAMIC_EARLY_SIZE <\n\t\t\tKMALLOC_SHIFT_HIGH * sizeof(struct kmem_cache_cpu));\n\n\t/*\n\t * Must align to double word boundary for the double cmpxchg\n\t * instructions to work; see __pcpu_double_call_return_bool().\n\t */\n\ts->cpu_slab = __alloc_percpu(sizeof(struct kmem_cache_cpu),\n\t\t\t\t     2 * sizeof(void *));\n\n\tif (!s->cpu_slab)\n\t\treturn 0;\n\n\tinit_kmem_cache_cpus(s);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_kmem_cache_cpus",
          "args": [
            "s"
          ],
          "line": 3334
        },
        "resolved": true,
        "details": {
          "function_name": "init_kmem_cache_cpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2016-2022",
          "snippet": "static void init_kmem_cache_cpus(struct kmem_cache *s)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu_ptr(s->cpu_slab, cpu)->tid = init_tid(cpu);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void init_kmem_cache_cpus(struct kmem_cache *s)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu_ptr(s->cpu_slab, cpu)->tid = init_tid(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__alloc_percpu",
          "args": [
            "sizeof(struct kmem_cache_cpu)",
            "2 * sizeof(void *)"
          ],
          "line": 3328
        },
        "resolved": true,
        "details": {
          "function_name": "__alloc_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "1557-1560",
          "snippet": "void __percpu *__alloc_percpu(size_t size, size_t align)\n{\n\treturn pcpu_alloc(size, align, false, GFP_KERNEL);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nvoid __percpu *__alloc_percpu(size_t size, size_t align)\n{\n\treturn pcpu_alloc(size, align, false, GFP_KERNEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "PERCPU_DYNAMIC_EARLY_SIZE <\n\t\t\tKMALLOC_SHIFT_HIGH * sizeof(struct kmem_cache_cpu)"
          ],
          "line": 3321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline int alloc_kmem_cache_cpus(struct kmem_cache *s)\n{\n\tBUILD_BUG_ON(PERCPU_DYNAMIC_EARLY_SIZE <\n\t\t\tKMALLOC_SHIFT_HIGH * sizeof(struct kmem_cache_cpu));\n\n\t/*\n\t * Must align to double word boundary for the double cmpxchg\n\t * instructions to work; see __pcpu_double_call_return_bool().\n\t */\n\ts->cpu_slab = __alloc_percpu(sizeof(struct kmem_cache_cpu),\n\t\t\t\t     2 * sizeof(void *));\n\n\tif (!s->cpu_slab)\n\t\treturn 0;\n\n\tinit_kmem_cache_cpus(s);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "init_kmem_cache_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "3306-3317",
    "snippet": "static void\ninit_kmem_cache_node(struct kmem_cache_node *n)\n{\n\tn->nr_partial = 0;\n\tspin_lock_init(&n->list_lock);\n\tINIT_LIST_HEAD(&n->partial);\n#ifdef CONFIG_SLUB_DEBUG\n\tatomic_long_set(&n->nr_slabs, 0);\n\tatomic_long_set(&n->total_objects, 0);\n\tINIT_LIST_HEAD(&n->full);\n#endif\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *kmem_cache_node;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&n->full"
          ],
          "line": 3315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_set",
          "args": [
            "&n->total_objects",
            "0"
          ],
          "line": 3314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_set",
          "args": [
            "&n->nr_slabs",
            "0"
          ],
          "line": 3313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&n->partial"
          ],
          "line": 3311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&n->list_lock"
          ],
          "line": 3310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic void\ninit_kmem_cache_node(struct kmem_cache_node *n)\n{\n\tn->nr_partial = 0;\n\tspin_lock_init(&n->list_lock);\n\tINIT_LIST_HEAD(&n->partial);\n#ifdef CONFIG_SLUB_DEBUG\n\tatomic_long_set(&n->nr_slabs, 0);\n\tatomic_long_set(&n->total_objects, 0);\n\tINIT_LIST_HEAD(&n->full);\n#endif\n}"
  },
  {
    "function_name": "calculate_order",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "3255-3304",
    "snippet": "static inline int calculate_order(unsigned int size)\n{\n\tunsigned int order;\n\tunsigned int min_objects;\n\tunsigned int max_objects;\n\n\t/*\n\t * Attempt to find best configuration for a slab. This\n\t * works by first attempting to generate a layout with\n\t * the best configuration and backing off gradually.\n\t *\n\t * First we increase the acceptable waste in a slab. Then\n\t * we reduce the minimum objects required in a slab.\n\t */\n\tmin_objects = slub_min_objects;\n\tif (!min_objects)\n\t\tmin_objects = 4 * (fls(nr_cpu_ids) + 1);\n\tmax_objects = order_objects(slub_max_order, size);\n\tmin_objects = min(min_objects, max_objects);\n\n\twhile (min_objects > 1) {\n\t\tunsigned int fraction;\n\n\t\tfraction = 16;\n\t\twhile (fraction >= 4) {\n\t\t\torder = slab_order(size, min_objects,\n\t\t\t\t\tslub_max_order, fraction);\n\t\t\tif (order <= slub_max_order)\n\t\t\t\treturn order;\n\t\t\tfraction /= 2;\n\t\t}\n\t\tmin_objects--;\n\t}\n\n\t/*\n\t * We were unable to place multiple objects in a slab. Now\n\t * lets see if we can place a single object there.\n\t */\n\torder = slab_order(size, 1, slub_max_order, 1);\n\tif (order <= slub_max_order)\n\t\treturn order;\n\n\t/*\n\t * Doh this slab cannot be placed using slub_max_order.\n\t */\n\torder = slab_order(size, 1, MAX_ORDER, 1);\n\tif (order < MAX_ORDER)\n\t\treturn order;\n\treturn -ENOSYS;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int slub_max_order = PAGE_ALLOC_COSTLY_ORDER;",
      "static unsigned int slub_min_objects;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slab_order",
          "args": [
            "size",
            "1",
            "MAX_ORDER",
            "1"
          ],
          "line": 3300
        },
        "resolved": true,
        "details": {
          "function_name": "slab_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "3230-3253",
          "snippet": "static inline unsigned int slab_order(unsigned int size,\n\t\tunsigned int min_objects, unsigned int max_order,\n\t\tunsigned int fract_leftover)\n{\n\tunsigned int min_order = slub_min_order;\n\tunsigned int order;\n\n\tif (order_objects(min_order, size) > MAX_OBJS_PER_PAGE)\n\t\treturn get_order(size * MAX_OBJS_PER_PAGE) - 1;\n\n\tfor (order = max(min_order, (unsigned int)get_order(min_objects * size));\n\t\t\torder <= max_order; order++) {\n\n\t\tunsigned int slab_size = (unsigned int)PAGE_SIZE << order;\n\t\tunsigned int rem;\n\n\t\trem = slab_size % size;\n\n\t\tif (rem <= slab_size / fract_leftover)\n\t\t\tbreak;\n\t}\n\n\treturn order;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define MAX_OBJS_PER_PAGE\t32767 /* since page.objects is u15 */"
          ],
          "globals_used": [
            "static unsigned int slub_min_order;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define MAX_OBJS_PER_PAGE\t32767 /* since page.objects is u15 */\n\nstatic unsigned int slub_min_order;\n\nstatic inline unsigned int slab_order(unsigned int size,\n\t\tunsigned int min_objects, unsigned int max_order,\n\t\tunsigned int fract_leftover)\n{\n\tunsigned int min_order = slub_min_order;\n\tunsigned int order;\n\n\tif (order_objects(min_order, size) > MAX_OBJS_PER_PAGE)\n\t\treturn get_order(size * MAX_OBJS_PER_PAGE) - 1;\n\n\tfor (order = max(min_order, (unsigned int)get_order(min_objects * size));\n\t\t\torder <= max_order; order++) {\n\n\t\tunsigned int slab_size = (unsigned int)PAGE_SIZE << order;\n\t\tunsigned int rem;\n\n\t\trem = slab_size % size;\n\n\t\tif (rem <= slab_size / fract_leftover)\n\t\t\tbreak;\n\t}\n\n\treturn order;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "min_objects",
            "max_objects"
          ],
          "line": 3273
        },
        "resolved": true,
        "details": {
          "function_name": "min_partial_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "4954-4957",
          "snippet": "static ssize_t min_partial_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", s->min_partial);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic ssize_t min_partial_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", s->min_partial);\n}"
        }
      },
      {
        "call_info": {
          "callee": "order_objects",
          "args": [
            "slub_max_order",
            "size"
          ],
          "line": 3272
        },
        "resolved": true,
        "details": {
          "function_name": "order_objects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "317-320",
          "snippet": "static inline unsigned int order_objects(unsigned int order, unsigned int size)\n{\n\treturn ((unsigned int)PAGE_SIZE << order) / size;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline unsigned int order_objects(unsigned int order, unsigned int size)\n{\n\treturn ((unsigned int)PAGE_SIZE << order) / size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fls",
          "args": [
            "nr_cpu_ids"
          ],
          "line": 3271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic unsigned int slub_max_order = PAGE_ALLOC_COSTLY_ORDER;\nstatic unsigned int slub_min_objects;\n\nstatic inline int calculate_order(unsigned int size)\n{\n\tunsigned int order;\n\tunsigned int min_objects;\n\tunsigned int max_objects;\n\n\t/*\n\t * Attempt to find best configuration for a slab. This\n\t * works by first attempting to generate a layout with\n\t * the best configuration and backing off gradually.\n\t *\n\t * First we increase the acceptable waste in a slab. Then\n\t * we reduce the minimum objects required in a slab.\n\t */\n\tmin_objects = slub_min_objects;\n\tif (!min_objects)\n\t\tmin_objects = 4 * (fls(nr_cpu_ids) + 1);\n\tmax_objects = order_objects(slub_max_order, size);\n\tmin_objects = min(min_objects, max_objects);\n\n\twhile (min_objects > 1) {\n\t\tunsigned int fraction;\n\n\t\tfraction = 16;\n\t\twhile (fraction >= 4) {\n\t\t\torder = slab_order(size, min_objects,\n\t\t\t\t\tslub_max_order, fraction);\n\t\t\tif (order <= slub_max_order)\n\t\t\t\treturn order;\n\t\t\tfraction /= 2;\n\t\t}\n\t\tmin_objects--;\n\t}\n\n\t/*\n\t * We were unable to place multiple objects in a slab. Now\n\t * lets see if we can place a single object there.\n\t */\n\torder = slab_order(size, 1, slub_max_order, 1);\n\tif (order <= slub_max_order)\n\t\treturn order;\n\n\t/*\n\t * Doh this slab cannot be placed using slub_max_order.\n\t */\n\torder = slab_order(size, 1, MAX_ORDER, 1);\n\tif (order < MAX_ORDER)\n\t\treturn order;\n\treturn -ENOSYS;\n}"
  },
  {
    "function_name": "slab_order",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "3230-3253",
    "snippet": "static inline unsigned int slab_order(unsigned int size,\n\t\tunsigned int min_objects, unsigned int max_order,\n\t\tunsigned int fract_leftover)\n{\n\tunsigned int min_order = slub_min_order;\n\tunsigned int order;\n\n\tif (order_objects(min_order, size) > MAX_OBJS_PER_PAGE)\n\t\treturn get_order(size * MAX_OBJS_PER_PAGE) - 1;\n\n\tfor (order = max(min_order, (unsigned int)get_order(min_objects * size));\n\t\t\torder <= max_order; order++) {\n\n\t\tunsigned int slab_size = (unsigned int)PAGE_SIZE << order;\n\t\tunsigned int rem;\n\n\t\trem = slab_size % size;\n\n\t\tif (rem <= slab_size / fract_leftover)\n\t\t\tbreak;\n\t}\n\n\treturn order;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define MAX_OBJS_PER_PAGE\t32767 /* since page.objects is u15 */"
    ],
    "globals_used": [
      "static unsigned int slub_min_order;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "max",
          "args": [
            "min_order",
            "(unsigned int)get_order(min_objects * size)"
          ],
          "line": 3240
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "min_objects * size"
          ],
          "line": 3240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "size * MAX_OBJS_PER_PAGE"
          ],
          "line": 3238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "order_objects",
          "args": [
            "min_order",
            "size"
          ],
          "line": 3237
        },
        "resolved": true,
        "details": {
          "function_name": "order_objects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "317-320",
          "snippet": "static inline unsigned int order_objects(unsigned int order, unsigned int size)\n{\n\treturn ((unsigned int)PAGE_SIZE << order) / size;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline unsigned int order_objects(unsigned int order, unsigned int size)\n{\n\treturn ((unsigned int)PAGE_SIZE << order) / size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define MAX_OBJS_PER_PAGE\t32767 /* since page.objects is u15 */\n\nstatic unsigned int slub_min_order;\n\nstatic inline unsigned int slab_order(unsigned int size,\n\t\tunsigned int min_objects, unsigned int max_order,\n\t\tunsigned int fract_leftover)\n{\n\tunsigned int min_order = slub_min_order;\n\tunsigned int order;\n\n\tif (order_objects(min_order, size) > MAX_OBJS_PER_PAGE)\n\t\treturn get_order(size * MAX_OBJS_PER_PAGE) - 1;\n\n\tfor (order = max(min_order, (unsigned int)get_order(min_objects * size));\n\t\t\torder <= max_order; order++) {\n\n\t\tunsigned int slab_size = (unsigned int)PAGE_SIZE << order;\n\t\tunsigned int rem;\n\n\t\trem = slab_size % size;\n\n\t\tif (rem <= slab_size / fract_leftover)\n\t\t\tbreak;\n\t}\n\n\treturn order;\n}"
  },
  {
    "function_name": "kmem_cache_alloc_bulk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "3122-3178",
    "snippet": "int kmem_cache_alloc_bulk(struct kmem_cache *s, gfp_t flags, size_t size,\n\t\t\t  void **p)\n{\n\tstruct kmem_cache_cpu *c;\n\tint i;\n\n\t/* memcg and kmem_cache debug support */\n\ts = slab_pre_alloc_hook(s, flags);\n\tif (unlikely(!s))\n\t\treturn false;\n\t/*\n\t * Drain objects in the per cpu slab, while disabling local\n\t * IRQs, which protects against PREEMPT and interrupts\n\t * handlers invoking normal fastpath.\n\t */\n\tlocal_irq_disable();\n\tc = this_cpu_ptr(s->cpu_slab);\n\n\tfor (i = 0; i < size; i++) {\n\t\tvoid *object = c->freelist;\n\n\t\tif (unlikely(!object)) {\n\t\t\t/*\n\t\t\t * Invoking slow path likely have side-effect\n\t\t\t * of re-populating per CPU c->freelist\n\t\t\t */\n\t\t\tp[i] = ___slab_alloc(s, flags, NUMA_NO_NODE,\n\t\t\t\t\t    _RET_IP_, c);\n\t\t\tif (unlikely(!p[i]))\n\t\t\t\tgoto error;\n\n\t\t\tc = this_cpu_ptr(s->cpu_slab);\n\t\t\tcontinue; /* goto for-loop */\n\t\t}\n\t\tc->freelist = get_freepointer(s, object);\n\t\tp[i] = object;\n\t}\n\tc->tid = next_tid(c->tid);\n\tlocal_irq_enable();\n\n\t/* Clear memory outside IRQ disabled fastpath loop */\n\tif (unlikely(flags & __GFP_ZERO)) {\n\t\tint j;\n\n\t\tfor (j = 0; j < i; j++)\n\t\t\tmemset(p[j], 0, s->object_size);\n\t}\n\n\t/* memcg and kmem_cache debug support */\n\tslab_post_alloc_hook(s, flags, size, p);\n\treturn i;\nerror:\n\tlocal_irq_enable();\n\tslab_post_alloc_hook(s, flags, i, p);\n\t__kmem_cache_free_bulk(s, i, p);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__kmem_cache_free_bulk",
          "args": [
            "s",
            "i",
            "p"
          ],
          "line": 3176
        },
        "resolved": true,
        "details": {
          "function_name": "__kmem_cache_free_bulk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "103-113",
          "snippet": "void __kmem_cache_free_bulk(struct kmem_cache *s, size_t nr, void **p)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tif (s)\n\t\t\tkmem_cache_free(s, p[i]);\n\t\telse\n\t\t\tkfree(p[i]);\n\t}\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nvoid __kmem_cache_free_bulk(struct kmem_cache *s, size_t nr, void **p)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tif (s)\n\t\t\tkmem_cache_free(s, p[i]);\n\t\telse\n\t\t\tkfree(p[i]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "slab_post_alloc_hook",
          "args": [
            "s",
            "flags",
            "i",
            "p"
          ],
          "line": 3175
        },
        "resolved": true,
        "details": {
          "function_name": "slab_post_alloc_hook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "433-449",
          "snippet": "static inline void slab_post_alloc_hook(struct kmem_cache *s, gfp_t flags,\n\t\t\t\t\tsize_t size, void **p)\n{\n\tsize_t i;\n\n\tflags &= gfp_allowed_mask;\n\tfor (i = 0; i < size; i++) {\n\t\tvoid *object = p[i];\n\n\t\tkmemleak_alloc_recursive(object, s->object_size, 1,\n\t\t\t\t\t s->flags, flags);\n\t\tkasan_slab_alloc(s, object, flags);\n\t}\n\n\tif (memcg_kmem_enabled())\n\t\tmemcg_kmem_put_cache(s);\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline void slab_post_alloc_hook(struct kmem_cache *s, gfp_t flags,\n\t\t\t\t\tsize_t size, void **p)\n{\n\tsize_t i;\n\n\tflags &= gfp_allowed_mask;\n\tfor (i = 0; i < size; i++) {\n\t\tvoid *object = p[i];\n\n\t\tkmemleak_alloc_recursive(object, s->object_size, 1,\n\t\t\t\t\t s->flags, flags);\n\t\tkasan_slab_alloc(s, object, flags);\n\t}\n\n\tif (memcg_kmem_enabled())\n\t\tmemcg_kmem_put_cache(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 3174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "p[j]",
            "0",
            "s->object_size"
          ],
          "line": 3167
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "flags & __GFP_ZERO"
          ],
          "line": 3163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 3160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_tid",
          "args": [
            "c->tid"
          ],
          "line": 3159
        },
        "resolved": true,
        "details": {
          "function_name": "next_tid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1972-1975",
          "snippet": "static inline unsigned long next_tid(unsigned long tid)\n{\n\treturn tid + TID_STEP;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define TID_STEP 1",
            "#define TID_STEP  roundup_pow_of_two(CONFIG_NR_CPUS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define TID_STEP 1\n#define TID_STEP  roundup_pow_of_two(CONFIG_NR_CPUS)\n\nstatic inline unsigned long next_tid(unsigned long tid)\n{\n\treturn tid + TID_STEP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_freepointer",
          "args": [
            "s",
            "object"
          ],
          "line": 3156
        },
        "resolved": true,
        "details": {
          "function_name": "get_freepointer_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "276-287",
          "snippet": "static inline void *get_freepointer_safe(struct kmem_cache *s, void *object)\n{\n\tunsigned long freepointer_addr;\n\tvoid *p;\n\n\tif (!debug_pagealloc_enabled())\n\t\treturn get_freepointer(s, object);\n\n\tfreepointer_addr = (unsigned long)object + s->offset;\n\tprobe_kernel_read(&p, (void **)freepointer_addr, sizeof(p));\n\treturn freelist_ptr(s, p, freepointer_addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void *get_freepointer_safe(struct kmem_cache *s, void *object)\n{\n\tunsigned long freepointer_addr;\n\tvoid *p;\n\n\tif (!debug_pagealloc_enabled())\n\t\treturn get_freepointer(s, object);\n\n\tfreepointer_addr = (unsigned long)object + s->offset;\n\tprobe_kernel_read(&p, (void **)freepointer_addr, sizeof(p));\n\treturn freelist_ptr(s, p, freepointer_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "s->cpu_slab"
          ],
          "line": 3153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!p[i]"
          ],
          "line": 3150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "___slab_alloc",
          "args": [
            "s",
            "flags",
            "NUMA_NO_NODE",
            "_RET_IP_",
            "c"
          ],
          "line": 3148
        },
        "resolved": true,
        "details": {
          "function_name": "___slab_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2538-2625",
          "snippet": "static void *___slab_alloc(struct kmem_cache *s, gfp_t gfpflags, int node,\n\t\t\t  unsigned long addr, struct kmem_cache_cpu *c)\n{\n\tvoid *freelist;\n\tstruct page *page;\n\n\tpage = c->page;\n\tif (!page)\n\t\tgoto new_slab;\nredo:\n\n\tif (unlikely(!node_match(page, node))) {\n\t\tint searchnode = node;\n\n\t\tif (node != NUMA_NO_NODE && !node_present_pages(node))\n\t\t\tsearchnode = node_to_mem_node(node);\n\n\t\tif (unlikely(!node_match(page, searchnode))) {\n\t\t\tstat(s, ALLOC_NODE_MISMATCH);\n\t\t\tdeactivate_slab(s, page, c->freelist, c);\n\t\t\tgoto new_slab;\n\t\t}\n\t}\n\n\t/*\n\t * By rights, we should be searching for a slab page that was\n\t * PFMEMALLOC but right now, we are losing the pfmemalloc\n\t * information when the page leaves the per-cpu allocator\n\t */\n\tif (unlikely(!pfmemalloc_match(page, gfpflags))) {\n\t\tdeactivate_slab(s, page, c->freelist, c);\n\t\tgoto new_slab;\n\t}\n\n\t/* must check again c->freelist in case of cpu migration or IRQ */\n\tfreelist = c->freelist;\n\tif (freelist)\n\t\tgoto load_freelist;\n\n\tfreelist = get_freelist(s, page);\n\n\tif (!freelist) {\n\t\tc->page = NULL;\n\t\tstat(s, DEACTIVATE_BYPASS);\n\t\tgoto new_slab;\n\t}\n\n\tstat(s, ALLOC_REFILL);\n\nload_freelist:\n\t/*\n\t * freelist is pointing to the list of objects to be used.\n\t * page is pointing to the page from which the objects are obtained.\n\t * That page must be frozen for per cpu allocations to work.\n\t */\n\tVM_BUG_ON(!c->page->frozen);\n\tc->freelist = get_freepointer(s, freelist);\n\tc->tid = next_tid(c->tid);\n\treturn freelist;\n\nnew_slab:\n\n\tif (slub_percpu_partial(c)) {\n\t\tpage = c->page = slub_percpu_partial(c);\n\t\tslub_set_percpu_partial(c, page);\n\t\tstat(s, CPU_PARTIAL_ALLOC);\n\t\tgoto redo;\n\t}\n\n\tfreelist = new_slab_objects(s, gfpflags, node, &c);\n\n\tif (unlikely(!freelist)) {\n\t\tslab_out_of_memory(s, gfpflags, node);\n\t\treturn NULL;\n\t}\n\n\tpage = c->page;\n\tif (likely(!kmem_cache_debug(s) && pfmemalloc_match(page, gfpflags)))\n\t\tgoto load_freelist;\n\n\t/* Only entered in the debug case */\n\tif (kmem_cache_debug(s) &&\n\t\t\t!alloc_debug_processing(s, page, freelist, addr))\n\t\tgoto new_slab;\t/* Slab failed checks. Next slab needed */\n\n\tdeactivate_slab(s, page, get_freepointer(s, freelist), c);\n\treturn freelist;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);\n\nstatic void *___slab_alloc(struct kmem_cache *s, gfp_t gfpflags, int node,\n\t\t\t  unsigned long addr, struct kmem_cache_cpu *c)\n{\n\tvoid *freelist;\n\tstruct page *page;\n\n\tpage = c->page;\n\tif (!page)\n\t\tgoto new_slab;\nredo:\n\n\tif (unlikely(!node_match(page, node))) {\n\t\tint searchnode = node;\n\n\t\tif (node != NUMA_NO_NODE && !node_present_pages(node))\n\t\t\tsearchnode = node_to_mem_node(node);\n\n\t\tif (unlikely(!node_match(page, searchnode))) {\n\t\t\tstat(s, ALLOC_NODE_MISMATCH);\n\t\t\tdeactivate_slab(s, page, c->freelist, c);\n\t\t\tgoto new_slab;\n\t\t}\n\t}\n\n\t/*\n\t * By rights, we should be searching for a slab page that was\n\t * PFMEMALLOC but right now, we are losing the pfmemalloc\n\t * information when the page leaves the per-cpu allocator\n\t */\n\tif (unlikely(!pfmemalloc_match(page, gfpflags))) {\n\t\tdeactivate_slab(s, page, c->freelist, c);\n\t\tgoto new_slab;\n\t}\n\n\t/* must check again c->freelist in case of cpu migration or IRQ */\n\tfreelist = c->freelist;\n\tif (freelist)\n\t\tgoto load_freelist;\n\n\tfreelist = get_freelist(s, page);\n\n\tif (!freelist) {\n\t\tc->page = NULL;\n\t\tstat(s, DEACTIVATE_BYPASS);\n\t\tgoto new_slab;\n\t}\n\n\tstat(s, ALLOC_REFILL);\n\nload_freelist:\n\t/*\n\t * freelist is pointing to the list of objects to be used.\n\t * page is pointing to the page from which the objects are obtained.\n\t * That page must be frozen for per cpu allocations to work.\n\t */\n\tVM_BUG_ON(!c->page->frozen);\n\tc->freelist = get_freepointer(s, freelist);\n\tc->tid = next_tid(c->tid);\n\treturn freelist;\n\nnew_slab:\n\n\tif (slub_percpu_partial(c)) {\n\t\tpage = c->page = slub_percpu_partial(c);\n\t\tslub_set_percpu_partial(c, page);\n\t\tstat(s, CPU_PARTIAL_ALLOC);\n\t\tgoto redo;\n\t}\n\n\tfreelist = new_slab_objects(s, gfpflags, node, &c);\n\n\tif (unlikely(!freelist)) {\n\t\tslab_out_of_memory(s, gfpflags, node);\n\t\treturn NULL;\n\t}\n\n\tpage = c->page;\n\tif (likely(!kmem_cache_debug(s) && pfmemalloc_match(page, gfpflags)))\n\t\tgoto load_freelist;\n\n\t/* Only entered in the debug case */\n\tif (kmem_cache_debug(s) &&\n\t\t\t!alloc_debug_processing(s, page, freelist, addr))\n\t\tgoto new_slab;\t/* Slab failed checks. Next slab needed */\n\n\tdeactivate_slab(s, page, get_freepointer(s, freelist), c);\n\treturn freelist;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!object"
          ],
          "line": 3143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "s->cpu_slab"
          ],
          "line": 3138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 3137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!s"
          ],
          "line": 3130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_pre_alloc_hook",
          "args": [
            "s",
            "flags"
          ],
          "line": 3129
        },
        "resolved": true,
        "details": {
          "function_name": "slab_pre_alloc_hook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "413-431",
          "snippet": "static inline struct kmem_cache *slab_pre_alloc_hook(struct kmem_cache *s,\n\t\t\t\t\t\t     gfp_t flags)\n{\n\tflags &= gfp_allowed_mask;\n\n\tfs_reclaim_acquire(flags);\n\tfs_reclaim_release(flags);\n\n\tmight_sleep_if(gfpflags_allow_blocking(flags));\n\n\tif (should_failslab(s, flags))\n\t\treturn NULL;\n\n\tif (memcg_kmem_enabled() &&\n\t    ((flags & __GFP_ACCOUNT) || (s->flags & SLAB_ACCOUNT)))\n\t\treturn memcg_kmem_get_cache(s);\n\n\treturn s;\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache *slab_pre_alloc_hook(struct kmem_cache *s,\n\t\t\t\t\t\t     gfp_t flags)\n{\n\tflags &= gfp_allowed_mask;\n\n\tfs_reclaim_acquire(flags);\n\tfs_reclaim_release(flags);\n\n\tmight_sleep_if(gfpflags_allow_blocking(flags));\n\n\tif (should_failslab(s, flags))\n\t\treturn NULL;\n\n\tif (memcg_kmem_enabled() &&\n\t    ((flags & __GFP_ACCOUNT) || (s->flags & SLAB_ACCOUNT)))\n\t\treturn memcg_kmem_get_cache(s);\n\n\treturn s;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nint kmem_cache_alloc_bulk(struct kmem_cache *s, gfp_t flags, size_t size,\n\t\t\t  void **p)\n{\n\tstruct kmem_cache_cpu *c;\n\tint i;\n\n\t/* memcg and kmem_cache debug support */\n\ts = slab_pre_alloc_hook(s, flags);\n\tif (unlikely(!s))\n\t\treturn false;\n\t/*\n\t * Drain objects in the per cpu slab, while disabling local\n\t * IRQs, which protects against PREEMPT and interrupts\n\t * handlers invoking normal fastpath.\n\t */\n\tlocal_irq_disable();\n\tc = this_cpu_ptr(s->cpu_slab);\n\n\tfor (i = 0; i < size; i++) {\n\t\tvoid *object = c->freelist;\n\n\t\tif (unlikely(!object)) {\n\t\t\t/*\n\t\t\t * Invoking slow path likely have side-effect\n\t\t\t * of re-populating per CPU c->freelist\n\t\t\t */\n\t\t\tp[i] = ___slab_alloc(s, flags, NUMA_NO_NODE,\n\t\t\t\t\t    _RET_IP_, c);\n\t\t\tif (unlikely(!p[i]))\n\t\t\t\tgoto error;\n\n\t\t\tc = this_cpu_ptr(s->cpu_slab);\n\t\t\tcontinue; /* goto for-loop */\n\t\t}\n\t\tc->freelist = get_freepointer(s, object);\n\t\tp[i] = object;\n\t}\n\tc->tid = next_tid(c->tid);\n\tlocal_irq_enable();\n\n\t/* Clear memory outside IRQ disabled fastpath loop */\n\tif (unlikely(flags & __GFP_ZERO)) {\n\t\tint j;\n\n\t\tfor (j = 0; j < i; j++)\n\t\t\tmemset(p[j], 0, s->object_size);\n\t}\n\n\t/* memcg and kmem_cache debug support */\n\tslab_post_alloc_hook(s, flags, size, p);\n\treturn i;\nerror:\n\tlocal_irq_enable();\n\tslab_post_alloc_hook(s, flags, i, p);\n\t__kmem_cache_free_bulk(s, i, p);\n\treturn 0;\n}"
  },
  {
    "function_name": "kmem_cache_free_bulk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "3104-3118",
    "snippet": "void kmem_cache_free_bulk(struct kmem_cache *s, size_t size, void **p)\n{\n\tif (WARN_ON(!size))\n\t\treturn;\n\n\tdo {\n\t\tstruct detached_freelist df;\n\n\t\tsize = build_detached_freelist(s, size, p, &df);\n\t\tif (!df.page)\n\t\t\tcontinue;\n\n\t\tslab_free(df.s, df.page, df.freelist, df.tail, df.cnt,_RET_IP_);\n\t} while (likely(size));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "size"
          ],
          "line": 3117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_free",
          "args": [
            "df.s",
            "df.page",
            "df.freelist",
            "df.tail",
            "df.cnt",
            "_RET_IP_"
          ],
          "line": 3116
        },
        "resolved": true,
        "details": {
          "function_name": "slab_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2983-2993",
          "snippet": "static __always_inline void slab_free(struct kmem_cache *s, struct page *page,\n\t\t\t\t      void *head, void *tail, int cnt,\n\t\t\t\t      unsigned long addr)\n{\n\t/*\n\t * With KASAN enabled slab_free_freelist_hook modifies the freelist\n\t * to remove objects, whose reuse must be delayed.\n\t */\n\tif (slab_free_freelist_hook(s, &head, &tail))\n\t\tdo_slab_free(s, page, head, tail, cnt, addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic __always_inline void slab_free(struct kmem_cache *s, struct page *page,\n\t\t\t\t      void *head, void *tail, int cnt,\n\t\t\t\t      unsigned long addr)\n{\n\t/*\n\t * With KASAN enabled slab_free_freelist_hook modifies the freelist\n\t * to remove objects, whose reuse must be delayed.\n\t */\n\tif (slab_free_freelist_hook(s, &head, &tail))\n\t\tdo_slab_free(s, page, head, tail, cnt, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_detached_freelist",
          "args": [
            "s",
            "size",
            "p",
            "&df"
          ],
          "line": 3112
        },
        "resolved": true,
        "details": {
          "function_name": "build_detached_freelist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "3032-3101",
          "snippet": "static inline\nint build_detached_freelist(struct kmem_cache *s, size_t size,\n\t\t\t    void **p, struct detached_freelist *df)\n{\n\tsize_t first_skipped_index = 0;\n\tint lookahead = 3;\n\tvoid *object;\n\tstruct page *page;\n\n\t/* Always re-init detached_freelist */\n\tdf->page = NULL;\n\n\tdo {\n\t\tobject = p[--size];\n\t\t/* Do we need !ZERO_OR_NULL_PTR(object) here? (for kfree) */\n\t} while (!object && size);\n\n\tif (!object)\n\t\treturn 0;\n\n\tpage = virt_to_head_page(object);\n\tif (!s) {\n\t\t/* Handle kalloc'ed objects */\n\t\tif (unlikely(!PageSlab(page))) {\n\t\t\tBUG_ON(!PageCompound(page));\n\t\t\tkfree_hook(object);\n\t\t\t__free_pages(page, compound_order(page));\n\t\t\tp[size] = NULL; /* mark object processed */\n\t\t\treturn size;\n\t\t}\n\t\t/* Derive kmem_cache from object */\n\t\tdf->s = page->slab_cache;\n\t} else {\n\t\tdf->s = cache_from_obj(s, object); /* Support for memcg */\n\t}\n\n\t/* Start new detached freelist */\n\tdf->page = page;\n\tset_freepointer(df->s, object, NULL);\n\tdf->tail = object;\n\tdf->freelist = object;\n\tp[size] = NULL; /* mark object processed */\n\tdf->cnt = 1;\n\n\twhile (size) {\n\t\tobject = p[--size];\n\t\tif (!object)\n\t\t\tcontinue; /* Skip processed objects */\n\n\t\t/* df->page is always set at this point */\n\t\tif (df->page == virt_to_head_page(object)) {\n\t\t\t/* Opportunity build freelist */\n\t\t\tset_freepointer(df->s, object, df->freelist);\n\t\t\tdf->freelist = object;\n\t\t\tdf->cnt++;\n\t\t\tp[size] = NULL; /* mark object processed */\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Limit look ahead search */\n\t\tif (!--lookahead)\n\t\t\tbreak;\n\n\t\tif (!first_skipped_index)\n\t\t\tfirst_skipped_index = size + 1;\n\t}\n\n\treturn first_skipped_index;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline\nint build_detached_freelist(struct kmem_cache *s, size_t size,\n\t\t\t    void **p, struct detached_freelist *df)\n{\n\tsize_t first_skipped_index = 0;\n\tint lookahead = 3;\n\tvoid *object;\n\tstruct page *page;\n\n\t/* Always re-init detached_freelist */\n\tdf->page = NULL;\n\n\tdo {\n\t\tobject = p[--size];\n\t\t/* Do we need !ZERO_OR_NULL_PTR(object) here? (for kfree) */\n\t} while (!object && size);\n\n\tif (!object)\n\t\treturn 0;\n\n\tpage = virt_to_head_page(object);\n\tif (!s) {\n\t\t/* Handle kalloc'ed objects */\n\t\tif (unlikely(!PageSlab(page))) {\n\t\t\tBUG_ON(!PageCompound(page));\n\t\t\tkfree_hook(object);\n\t\t\t__free_pages(page, compound_order(page));\n\t\t\tp[size] = NULL; /* mark object processed */\n\t\t\treturn size;\n\t\t}\n\t\t/* Derive kmem_cache from object */\n\t\tdf->s = page->slab_cache;\n\t} else {\n\t\tdf->s = cache_from_obj(s, object); /* Support for memcg */\n\t}\n\n\t/* Start new detached freelist */\n\tdf->page = page;\n\tset_freepointer(df->s, object, NULL);\n\tdf->tail = object;\n\tdf->freelist = object;\n\tp[size] = NULL; /* mark object processed */\n\tdf->cnt = 1;\n\n\twhile (size) {\n\t\tobject = p[--size];\n\t\tif (!object)\n\t\t\tcontinue; /* Skip processed objects */\n\n\t\t/* df->page is always set at this point */\n\t\tif (df->page == virt_to_head_page(object)) {\n\t\t\t/* Opportunity build freelist */\n\t\t\tset_freepointer(df->s, object, df->freelist);\n\t\t\tdf->freelist = object;\n\t\t\tdf->cnt++;\n\t\t\tp[size] = NULL; /* mark object processed */\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Limit look ahead search */\n\t\tif (!--lookahead)\n\t\t\tbreak;\n\n\t\tif (!first_skipped_index)\n\t\t\tfirst_skipped_index = size + 1;\n\t}\n\n\treturn first_skipped_index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!size"
          ],
          "line": 3106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid kmem_cache_free_bulk(struct kmem_cache *s, size_t size, void **p)\n{\n\tif (WARN_ON(!size))\n\t\treturn;\n\n\tdo {\n\t\tstruct detached_freelist df;\n\n\t\tsize = build_detached_freelist(s, size, p, &df);\n\t\tif (!df.page)\n\t\t\tcontinue;\n\n\t\tslab_free(df.s, df.page, df.freelist, df.tail, df.cnt,_RET_IP_);\n\t} while (likely(size));\n}"
  },
  {
    "function_name": "build_detached_freelist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "3032-3101",
    "snippet": "static inline\nint build_detached_freelist(struct kmem_cache *s, size_t size,\n\t\t\t    void **p, struct detached_freelist *df)\n{\n\tsize_t first_skipped_index = 0;\n\tint lookahead = 3;\n\tvoid *object;\n\tstruct page *page;\n\n\t/* Always re-init detached_freelist */\n\tdf->page = NULL;\n\n\tdo {\n\t\tobject = p[--size];\n\t\t/* Do we need !ZERO_OR_NULL_PTR(object) here? (for kfree) */\n\t} while (!object && size);\n\n\tif (!object)\n\t\treturn 0;\n\n\tpage = virt_to_head_page(object);\n\tif (!s) {\n\t\t/* Handle kalloc'ed objects */\n\t\tif (unlikely(!PageSlab(page))) {\n\t\t\tBUG_ON(!PageCompound(page));\n\t\t\tkfree_hook(object);\n\t\t\t__free_pages(page, compound_order(page));\n\t\t\tp[size] = NULL; /* mark object processed */\n\t\t\treturn size;\n\t\t}\n\t\t/* Derive kmem_cache from object */\n\t\tdf->s = page->slab_cache;\n\t} else {\n\t\tdf->s = cache_from_obj(s, object); /* Support for memcg */\n\t}\n\n\t/* Start new detached freelist */\n\tdf->page = page;\n\tset_freepointer(df->s, object, NULL);\n\tdf->tail = object;\n\tdf->freelist = object;\n\tp[size] = NULL; /* mark object processed */\n\tdf->cnt = 1;\n\n\twhile (size) {\n\t\tobject = p[--size];\n\t\tif (!object)\n\t\t\tcontinue; /* Skip processed objects */\n\n\t\t/* df->page is always set at this point */\n\t\tif (df->page == virt_to_head_page(object)) {\n\t\t\t/* Opportunity build freelist */\n\t\t\tset_freepointer(df->s, object, df->freelist);\n\t\t\tdf->freelist = object;\n\t\t\tdf->cnt++;\n\t\t\tp[size] = NULL; /* mark object processed */\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Limit look ahead search */\n\t\tif (!--lookahead)\n\t\t\tbreak;\n\n\t\tif (!first_skipped_index)\n\t\t\tfirst_skipped_index = size + 1;\n\t}\n\n\treturn first_skipped_index;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_freepointer",
          "args": [
            "df->s",
            "object",
            "df->freelist"
          ],
          "line": 3084
        },
        "resolved": true,
        "details": {
          "function_name": "set_freepointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "289-298",
          "snippet": "static inline void set_freepointer(struct kmem_cache *s, void *object, void *fp)\n{\n\tunsigned long freeptr_addr = (unsigned long)object + s->offset;\n\n#ifdef CONFIG_SLAB_FREELIST_HARDENED\n\tBUG_ON(object == fp); /* naive detection of double free or corruption */\n#endif\n\n\t*(void **)freeptr_addr = freelist_ptr(s, fp, freeptr_addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void set_freepointer(struct kmem_cache *s, void *object, void *fp)\n{\n\tunsigned long freeptr_addr = (unsigned long)object + s->offset;\n\n#ifdef CONFIG_SLAB_FREELIST_HARDENED\n\tBUG_ON(object == fp); /* naive detection of double free or corruption */\n#endif\n\n\t*(void **)freeptr_addr = freelist_ptr(s, fp, freeptr_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virt_to_head_page",
          "args": [
            "object"
          ],
          "line": 3082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_from_obj",
          "args": [
            "s",
            "object"
          ],
          "line": 3065
        },
        "resolved": true,
        "details": {
          "function_name": "cache_from_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "356-381",
          "snippet": "static inline struct kmem_cache *cache_from_obj(struct kmem_cache *s, void *x)\n{\n\tstruct kmem_cache *cachep;\n\tstruct page *page;\n\n\t/*\n\t * When kmemcg is not being used, both assignments should return the\n\t * same value. but we don't want to pay the assignment price in that\n\t * case. If it is not compiled in, the compiler should be smart enough\n\t * to not do even the assignment. In that case, slab_equal_or_root\n\t * will also be a constant.\n\t */\n\tif (!memcg_kmem_enabled() &&\n\t    !unlikely(s->flags & SLAB_CONSISTENCY_CHECKS))\n\t\treturn s;\n\n\tpage = virt_to_head_page(x);\n\tcachep = page->slab_cache;\n\tif (slab_equal_or_root(cachep, s))\n\t\treturn cachep;\n\n\tpr_err(\"%s: Wrong slab cache. %s but object is from %s\\n\",\n\t       __func__, s->name, cachep->name);\n\tWARN_ON_ONCE(1);\n\treturn s;\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache *cache_from_obj(struct kmem_cache *s, void *x)\n{\n\tstruct kmem_cache *cachep;\n\tstruct page *page;\n\n\t/*\n\t * When kmemcg is not being used, both assignments should return the\n\t * same value. but we don't want to pay the assignment price in that\n\t * case. If it is not compiled in, the compiler should be smart enough\n\t * to not do even the assignment. In that case, slab_equal_or_root\n\t * will also be a constant.\n\t */\n\tif (!memcg_kmem_enabled() &&\n\t    !unlikely(s->flags & SLAB_CONSISTENCY_CHECKS))\n\t\treturn s;\n\n\tpage = virt_to_head_page(x);\n\tcachep = page->slab_cache;\n\tif (slab_equal_or_root(cachep, s))\n\t\treturn cachep;\n\n\tpr_err(\"%s: Wrong slab cache. %s but object is from %s\\n\",\n\t       __func__, s->name, cachep->name);\n\tWARN_ON_ONCE(1);\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_pages",
          "args": [
            "page",
            "compound_order(page)"
          ],
          "line": 3058
        },
        "resolved": true,
        "details": {
          "function_name": "__free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4430-4438",
          "snippet": "void __free_pages(struct page *page, unsigned int order)\n{\n\tif (put_page_testzero(page)) {\n\t\tif (order == 0)\n\t\t\tfree_unref_page(page);\n\t\telse\n\t\t\t__free_pages_ok(page, order);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid __free_pages(struct page *page, unsigned int order)\n{\n\tif (put_page_testzero(page)) {\n\t\tif (order == 0)\n\t\t\tfree_unref_page(page);\n\t\telse\n\t\t\t__free_pages_ok(page, order);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "page"
          ],
          "line": 3058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree_hook",
          "args": [
            "object"
          ],
          "line": 3057
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_hook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1381-1385",
          "snippet": "static __always_inline void kfree_hook(void *x)\n{\n\tkmemleak_free(x);\n\tkasan_kfree_large(x, _RET_IP_);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic __always_inline void kfree_hook(void *x)\n{\n\tkmemleak_free(x);\n\tkasan_kfree_large(x, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageCompound(page)"
          ],
          "line": 3056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "page"
          ],
          "line": 3056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!PageSlab(page)"
          ],
          "line": 3055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSlab",
          "args": [
            "page"
          ],
          "line": 3055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_head_page",
          "args": [
            "object"
          ],
          "line": 3052
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline\nint build_detached_freelist(struct kmem_cache *s, size_t size,\n\t\t\t    void **p, struct detached_freelist *df)\n{\n\tsize_t first_skipped_index = 0;\n\tint lookahead = 3;\n\tvoid *object;\n\tstruct page *page;\n\n\t/* Always re-init detached_freelist */\n\tdf->page = NULL;\n\n\tdo {\n\t\tobject = p[--size];\n\t\t/* Do we need !ZERO_OR_NULL_PTR(object) here? (for kfree) */\n\t} while (!object && size);\n\n\tif (!object)\n\t\treturn 0;\n\n\tpage = virt_to_head_page(object);\n\tif (!s) {\n\t\t/* Handle kalloc'ed objects */\n\t\tif (unlikely(!PageSlab(page))) {\n\t\t\tBUG_ON(!PageCompound(page));\n\t\t\tkfree_hook(object);\n\t\t\t__free_pages(page, compound_order(page));\n\t\t\tp[size] = NULL; /* mark object processed */\n\t\t\treturn size;\n\t\t}\n\t\t/* Derive kmem_cache from object */\n\t\tdf->s = page->slab_cache;\n\t} else {\n\t\tdf->s = cache_from_obj(s, object); /* Support for memcg */\n\t}\n\n\t/* Start new detached freelist */\n\tdf->page = page;\n\tset_freepointer(df->s, object, NULL);\n\tdf->tail = object;\n\tdf->freelist = object;\n\tp[size] = NULL; /* mark object processed */\n\tdf->cnt = 1;\n\n\twhile (size) {\n\t\tobject = p[--size];\n\t\tif (!object)\n\t\t\tcontinue; /* Skip processed objects */\n\n\t\t/* df->page is always set at this point */\n\t\tif (df->page == virt_to_head_page(object)) {\n\t\t\t/* Opportunity build freelist */\n\t\t\tset_freepointer(df->s, object, df->freelist);\n\t\t\tdf->freelist = object;\n\t\t\tdf->cnt++;\n\t\t\tp[size] = NULL; /* mark object processed */\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Limit look ahead search */\n\t\tif (!--lookahead)\n\t\t\tbreak;\n\n\t\tif (!first_skipped_index)\n\t\t\tfirst_skipped_index = size + 1;\n\t}\n\n\treturn first_skipped_index;\n}"
  },
  {
    "function_name": "kmem_cache_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "3002-3009",
    "snippet": "void kmem_cache_free(struct kmem_cache *s, void *x)\n{\n\ts = cache_from_obj(s, x);\n\tif (!s)\n\t\treturn;\n\tslab_free(s, virt_to_head_page(x), x, NULL, 1, _RET_IP_);\n\ttrace_kmem_cache_free(_RET_IP_, x);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kmem_cache_free",
          "args": [
            "_RET_IP_",
            "x"
          ],
          "line": 3008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_free",
          "args": [
            "s",
            "virt_to_head_page(x)",
            "x",
            "NULL",
            "1",
            "_RET_IP_"
          ],
          "line": 3007
        },
        "resolved": true,
        "details": {
          "function_name": "slab_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2983-2993",
          "snippet": "static __always_inline void slab_free(struct kmem_cache *s, struct page *page,\n\t\t\t\t      void *head, void *tail, int cnt,\n\t\t\t\t      unsigned long addr)\n{\n\t/*\n\t * With KASAN enabled slab_free_freelist_hook modifies the freelist\n\t * to remove objects, whose reuse must be delayed.\n\t */\n\tif (slab_free_freelist_hook(s, &head, &tail))\n\t\tdo_slab_free(s, page, head, tail, cnt, addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic __always_inline void slab_free(struct kmem_cache *s, struct page *page,\n\t\t\t\t      void *head, void *tail, int cnt,\n\t\t\t\t      unsigned long addr)\n{\n\t/*\n\t * With KASAN enabled slab_free_freelist_hook modifies the freelist\n\t * to remove objects, whose reuse must be delayed.\n\t */\n\tif (slab_free_freelist_hook(s, &head, &tail))\n\t\tdo_slab_free(s, page, head, tail, cnt, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virt_to_head_page",
          "args": [
            "x"
          ],
          "line": 3007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_from_obj",
          "args": [
            "s",
            "x"
          ],
          "line": 3004
        },
        "resolved": true,
        "details": {
          "function_name": "cache_from_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "356-381",
          "snippet": "static inline struct kmem_cache *cache_from_obj(struct kmem_cache *s, void *x)\n{\n\tstruct kmem_cache *cachep;\n\tstruct page *page;\n\n\t/*\n\t * When kmemcg is not being used, both assignments should return the\n\t * same value. but we don't want to pay the assignment price in that\n\t * case. If it is not compiled in, the compiler should be smart enough\n\t * to not do even the assignment. In that case, slab_equal_or_root\n\t * will also be a constant.\n\t */\n\tif (!memcg_kmem_enabled() &&\n\t    !unlikely(s->flags & SLAB_CONSISTENCY_CHECKS))\n\t\treturn s;\n\n\tpage = virt_to_head_page(x);\n\tcachep = page->slab_cache;\n\tif (slab_equal_or_root(cachep, s))\n\t\treturn cachep;\n\n\tpr_err(\"%s: Wrong slab cache. %s but object is from %s\\n\",\n\t       __func__, s->name, cachep->name);\n\tWARN_ON_ONCE(1);\n\treturn s;\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache *cache_from_obj(struct kmem_cache *s, void *x)\n{\n\tstruct kmem_cache *cachep;\n\tstruct page *page;\n\n\t/*\n\t * When kmemcg is not being used, both assignments should return the\n\t * same value. but we don't want to pay the assignment price in that\n\t * case. If it is not compiled in, the compiler should be smart enough\n\t * to not do even the assignment. In that case, slab_equal_or_root\n\t * will also be a constant.\n\t */\n\tif (!memcg_kmem_enabled() &&\n\t    !unlikely(s->flags & SLAB_CONSISTENCY_CHECKS))\n\t\treturn s;\n\n\tpage = virt_to_head_page(x);\n\tcachep = page->slab_cache;\n\tif (slab_equal_or_root(cachep, s))\n\t\treturn cachep;\n\n\tpr_err(\"%s: Wrong slab cache. %s but object is from %s\\n\",\n\t       __func__, s->name, cachep->name);\n\tWARN_ON_ONCE(1);\n\treturn s;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid kmem_cache_free(struct kmem_cache *s, void *x)\n{\n\ts = cache_from_obj(s, x);\n\tif (!s)\n\t\treturn;\n\tslab_free(s, virt_to_head_page(x), x, NULL, 1, _RET_IP_);\n\ttrace_kmem_cache_free(_RET_IP_, x);\n}"
  },
  {
    "function_name": "___cache_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "2996-2999",
    "snippet": "void ___cache_free(struct kmem_cache *cache, void *x, unsigned long addr)\n{\n\tdo_slab_free(cache, virt_to_head_page(x), x, NULL, 1, addr);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_slab_free",
          "args": [
            "cache",
            "virt_to_head_page(x)",
            "x",
            "NULL",
            "1",
            "addr"
          ],
          "line": 2998
        },
        "resolved": true,
        "details": {
          "function_name": "do_slab_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2943-2981",
          "snippet": "static __always_inline void do_slab_free(struct kmem_cache *s,\n\t\t\t\tstruct page *page, void *head, void *tail,\n\t\t\t\tint cnt, unsigned long addr)\n{\n\tvoid *tail_obj = tail ? : head;\n\tstruct kmem_cache_cpu *c;\n\tunsigned long tid;\nredo:\n\t/*\n\t * Determine the currently cpus per cpu slab.\n\t * The cpu may change afterward. However that does not matter since\n\t * data is retrieved via this pointer. If we are on the same cpu\n\t * during the cmpxchg then the free will succeed.\n\t */\n\tdo {\n\t\ttid = this_cpu_read(s->cpu_slab->tid);\n\t\tc = raw_cpu_ptr(s->cpu_slab);\n\t} while (IS_ENABLED(CONFIG_PREEMPT) &&\n\t\t unlikely(tid != READ_ONCE(c->tid)));\n\n\t/* Same with comment on barrier() in slab_alloc_node() */\n\tbarrier();\n\n\tif (likely(page == c->page)) {\n\t\tset_freepointer(s, tail_obj, c->freelist);\n\n\t\tif (unlikely(!this_cpu_cmpxchg_double(\n\t\t\t\ts->cpu_slab->freelist, s->cpu_slab->tid,\n\t\t\t\tc->freelist, tid,\n\t\t\t\thead, next_tid(tid)))) {\n\n\t\t\tnote_cmpxchg_failure(\"slab_free\", s, tid);\n\t\t\tgoto redo;\n\t\t}\n\t\tstat(s, FREE_FASTPATH);\n\t} else\n\t\t__slab_free(s, page, head, tail_obj, cnt, addr);\n\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic __always_inline void do_slab_free(struct kmem_cache *s,\n\t\t\t\tstruct page *page, void *head, void *tail,\n\t\t\t\tint cnt, unsigned long addr)\n{\n\tvoid *tail_obj = tail ? : head;\n\tstruct kmem_cache_cpu *c;\n\tunsigned long tid;\nredo:\n\t/*\n\t * Determine the currently cpus per cpu slab.\n\t * The cpu may change afterward. However that does not matter since\n\t * data is retrieved via this pointer. If we are on the same cpu\n\t * during the cmpxchg then the free will succeed.\n\t */\n\tdo {\n\t\ttid = this_cpu_read(s->cpu_slab->tid);\n\t\tc = raw_cpu_ptr(s->cpu_slab);\n\t} while (IS_ENABLED(CONFIG_PREEMPT) &&\n\t\t unlikely(tid != READ_ONCE(c->tid)));\n\n\t/* Same with comment on barrier() in slab_alloc_node() */\n\tbarrier();\n\n\tif (likely(page == c->page)) {\n\t\tset_freepointer(s, tail_obj, c->freelist);\n\n\t\tif (unlikely(!this_cpu_cmpxchg_double(\n\t\t\t\ts->cpu_slab->freelist, s->cpu_slab->tid,\n\t\t\t\tc->freelist, tid,\n\t\t\t\thead, next_tid(tid)))) {\n\n\t\t\tnote_cmpxchg_failure(\"slab_free\", s, tid);\n\t\t\tgoto redo;\n\t\t}\n\t\tstat(s, FREE_FASTPATH);\n\t} else\n\t\t__slab_free(s, page, head, tail_obj, cnt, addr);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "virt_to_head_page",
          "args": [
            "x"
          ],
          "line": 2998
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid ___cache_free(struct kmem_cache *cache, void *x, unsigned long addr)\n{\n\tdo_slab_free(cache, virt_to_head_page(x), x, NULL, 1, addr);\n}"
  },
  {
    "function_name": "slab_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "2983-2993",
    "snippet": "static __always_inline void slab_free(struct kmem_cache *s, struct page *page,\n\t\t\t\t      void *head, void *tail, int cnt,\n\t\t\t\t      unsigned long addr)\n{\n\t/*\n\t * With KASAN enabled slab_free_freelist_hook modifies the freelist\n\t * to remove objects, whose reuse must be delayed.\n\t */\n\tif (slab_free_freelist_hook(s, &head, &tail))\n\t\tdo_slab_free(s, page, head, tail, cnt, addr);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_slab_free",
          "args": [
            "s",
            "page",
            "head",
            "tail",
            "cnt",
            "addr"
          ],
          "line": 2992
        },
        "resolved": true,
        "details": {
          "function_name": "do_slab_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2943-2981",
          "snippet": "static __always_inline void do_slab_free(struct kmem_cache *s,\n\t\t\t\tstruct page *page, void *head, void *tail,\n\t\t\t\tint cnt, unsigned long addr)\n{\n\tvoid *tail_obj = tail ? : head;\n\tstruct kmem_cache_cpu *c;\n\tunsigned long tid;\nredo:\n\t/*\n\t * Determine the currently cpus per cpu slab.\n\t * The cpu may change afterward. However that does not matter since\n\t * data is retrieved via this pointer. If we are on the same cpu\n\t * during the cmpxchg then the free will succeed.\n\t */\n\tdo {\n\t\ttid = this_cpu_read(s->cpu_slab->tid);\n\t\tc = raw_cpu_ptr(s->cpu_slab);\n\t} while (IS_ENABLED(CONFIG_PREEMPT) &&\n\t\t unlikely(tid != READ_ONCE(c->tid)));\n\n\t/* Same with comment on barrier() in slab_alloc_node() */\n\tbarrier();\n\n\tif (likely(page == c->page)) {\n\t\tset_freepointer(s, tail_obj, c->freelist);\n\n\t\tif (unlikely(!this_cpu_cmpxchg_double(\n\t\t\t\ts->cpu_slab->freelist, s->cpu_slab->tid,\n\t\t\t\tc->freelist, tid,\n\t\t\t\thead, next_tid(tid)))) {\n\n\t\t\tnote_cmpxchg_failure(\"slab_free\", s, tid);\n\t\t\tgoto redo;\n\t\t}\n\t\tstat(s, FREE_FASTPATH);\n\t} else\n\t\t__slab_free(s, page, head, tail_obj, cnt, addr);\n\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic __always_inline void do_slab_free(struct kmem_cache *s,\n\t\t\t\tstruct page *page, void *head, void *tail,\n\t\t\t\tint cnt, unsigned long addr)\n{\n\tvoid *tail_obj = tail ? : head;\n\tstruct kmem_cache_cpu *c;\n\tunsigned long tid;\nredo:\n\t/*\n\t * Determine the currently cpus per cpu slab.\n\t * The cpu may change afterward. However that does not matter since\n\t * data is retrieved via this pointer. If we are on the same cpu\n\t * during the cmpxchg then the free will succeed.\n\t */\n\tdo {\n\t\ttid = this_cpu_read(s->cpu_slab->tid);\n\t\tc = raw_cpu_ptr(s->cpu_slab);\n\t} while (IS_ENABLED(CONFIG_PREEMPT) &&\n\t\t unlikely(tid != READ_ONCE(c->tid)));\n\n\t/* Same with comment on barrier() in slab_alloc_node() */\n\tbarrier();\n\n\tif (likely(page == c->page)) {\n\t\tset_freepointer(s, tail_obj, c->freelist);\n\n\t\tif (unlikely(!this_cpu_cmpxchg_double(\n\t\t\t\ts->cpu_slab->freelist, s->cpu_slab->tid,\n\t\t\t\tc->freelist, tid,\n\t\t\t\thead, next_tid(tid)))) {\n\n\t\t\tnote_cmpxchg_failure(\"slab_free\", s, tid);\n\t\t\tgoto redo;\n\t\t}\n\t\tstat(s, FREE_FASTPATH);\n\t} else\n\t\t__slab_free(s, page, head, tail_obj, cnt, addr);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "slab_free_freelist_hook",
          "args": [
            "s",
            "&head",
            "&tail"
          ],
          "line": 2991
        },
        "resolved": true,
        "details": {
          "function_name": "slab_free_freelist_hook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1412-1452",
          "snippet": "static inline bool slab_free_freelist_hook(struct kmem_cache *s,\n\t\t\t\t\t   void **head, void **tail)\n{\n/*\n * Compiler cannot detect this function can be removed if slab_free_hook()\n * evaluates to nothing.  Thus, catch all relevant config debug options here.\n */\n#if defined(CONFIG_LOCKDEP)\t||\t\t\\\n\tdefined(CONFIG_DEBUG_KMEMLEAK) ||\t\\\n\tdefined(CONFIG_DEBUG_OBJECTS_FREE) ||\t\\\n\tdefined(CONFIG_KASAN)\n\n\tvoid *object;\n\tvoid *next = *head;\n\tvoid *old_tail = *tail ? *tail : *head;\n\n\t/* Head and tail of the reconstructed freelist */\n\t*head = NULL;\n\t*tail = NULL;\n\n\tdo {\n\t\tobject = next;\n\t\tnext = get_freepointer(s, object);\n\t\t/* If object's reuse doesn't have to be delayed */\n\t\tif (!slab_free_hook(s, object)) {\n\t\t\t/* Move object to the new freelist */\n\t\t\tset_freepointer(s, object, *head);\n\t\t\t*head = object;\n\t\t\tif (!*tail)\n\t\t\t\t*tail = object;\n\t\t}\n\t} while (object != old_tail);\n\n\tif (*head == *tail)\n\t\t*tail = NULL;\n\n\treturn *head != NULL;\n#else\n\treturn true;\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline bool slab_free_freelist_hook(struct kmem_cache *s,\n\t\t\t\t\t   void **head, void **tail)\n{\n/*\n * Compiler cannot detect this function can be removed if slab_free_hook()\n * evaluates to nothing.  Thus, catch all relevant config debug options here.\n */\n#if defined(CONFIG_LOCKDEP)\t||\t\t\\\n\tdefined(CONFIG_DEBUG_KMEMLEAK) ||\t\\\n\tdefined(CONFIG_DEBUG_OBJECTS_FREE) ||\t\\\n\tdefined(CONFIG_KASAN)\n\n\tvoid *object;\n\tvoid *next = *head;\n\tvoid *old_tail = *tail ? *tail : *head;\n\n\t/* Head and tail of the reconstructed freelist */\n\t*head = NULL;\n\t*tail = NULL;\n\n\tdo {\n\t\tobject = next;\n\t\tnext = get_freepointer(s, object);\n\t\t/* If object's reuse doesn't have to be delayed */\n\t\tif (!slab_free_hook(s, object)) {\n\t\t\t/* Move object to the new freelist */\n\t\t\tset_freepointer(s, object, *head);\n\t\t\t*head = object;\n\t\t\tif (!*tail)\n\t\t\t\t*tail = object;\n\t\t}\n\t} while (object != old_tail);\n\n\tif (*head == *tail)\n\t\t*tail = NULL;\n\n\treturn *head != NULL;\n#else\n\treturn true;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic __always_inline void slab_free(struct kmem_cache *s, struct page *page,\n\t\t\t\t      void *head, void *tail, int cnt,\n\t\t\t\t      unsigned long addr)\n{\n\t/*\n\t * With KASAN enabled slab_free_freelist_hook modifies the freelist\n\t * to remove objects, whose reuse must be delayed.\n\t */\n\tif (slab_free_freelist_hook(s, &head, &tail))\n\t\tdo_slab_free(s, page, head, tail, cnt, addr);\n}"
  },
  {
    "function_name": "do_slab_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "2943-2981",
    "snippet": "static __always_inline void do_slab_free(struct kmem_cache *s,\n\t\t\t\tstruct page *page, void *head, void *tail,\n\t\t\t\tint cnt, unsigned long addr)\n{\n\tvoid *tail_obj = tail ? : head;\n\tstruct kmem_cache_cpu *c;\n\tunsigned long tid;\nredo:\n\t/*\n\t * Determine the currently cpus per cpu slab.\n\t * The cpu may change afterward. However that does not matter since\n\t * data is retrieved via this pointer. If we are on the same cpu\n\t * during the cmpxchg then the free will succeed.\n\t */\n\tdo {\n\t\ttid = this_cpu_read(s->cpu_slab->tid);\n\t\tc = raw_cpu_ptr(s->cpu_slab);\n\t} while (IS_ENABLED(CONFIG_PREEMPT) &&\n\t\t unlikely(tid != READ_ONCE(c->tid)));\n\n\t/* Same with comment on barrier() in slab_alloc_node() */\n\tbarrier();\n\n\tif (likely(page == c->page)) {\n\t\tset_freepointer(s, tail_obj, c->freelist);\n\n\t\tif (unlikely(!this_cpu_cmpxchg_double(\n\t\t\t\ts->cpu_slab->freelist, s->cpu_slab->tid,\n\t\t\t\tc->freelist, tid,\n\t\t\t\thead, next_tid(tid)))) {\n\n\t\t\tnote_cmpxchg_failure(\"slab_free\", s, tid);\n\t\t\tgoto redo;\n\t\t}\n\t\tstat(s, FREE_FASTPATH);\n\t} else\n\t\t__slab_free(s, page, head, tail_obj, cnt, addr);\n\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__slab_free",
          "args": [
            "s",
            "page",
            "head",
            "tail_obj",
            "cnt",
            "addr"
          ],
          "line": 2979
        },
        "resolved": true,
        "details": {
          "function_name": "__slab_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2814-2926",
          "snippet": "static void __slab_free(struct kmem_cache *s, struct page *page,\n\t\t\tvoid *head, void *tail, int cnt,\n\t\t\tunsigned long addr)\n\n{\n\tvoid *prior;\n\tint was_frozen;\n\tstruct page new;\n\tunsigned long counters;\n\tstruct kmem_cache_node *n = NULL;\n\tunsigned long uninitialized_var(flags);\n\n\tstat(s, FREE_SLOWPATH);\n\n\tif (kmem_cache_debug(s) &&\n\t    !free_debug_processing(s, page, head, tail, cnt, addr))\n\t\treturn;\n\n\tdo {\n\t\tif (unlikely(n)) {\n\t\t\tspin_unlock_irqrestore(&n->list_lock, flags);\n\t\t\tn = NULL;\n\t\t}\n\t\tprior = page->freelist;\n\t\tcounters = page->counters;\n\t\tset_freepointer(s, tail, prior);\n\t\tnew.counters = counters;\n\t\twas_frozen = new.frozen;\n\t\tnew.inuse -= cnt;\n\t\tif ((!new.inuse || !prior) && !was_frozen) {\n\n\t\t\tif (kmem_cache_has_cpu_partial(s) && !prior) {\n\n\t\t\t\t/*\n\t\t\t\t * Slab was on no list before and will be\n\t\t\t\t * partially empty\n\t\t\t\t * We can defer the list move and instead\n\t\t\t\t * freeze it.\n\t\t\t\t */\n\t\t\t\tnew.frozen = 1;\n\n\t\t\t} else { /* Needs to be taken off a list */\n\n\t\t\t\tn = get_node(s, page_to_nid(page));\n\t\t\t\t/*\n\t\t\t\t * Speculatively acquire the list_lock.\n\t\t\t\t * If the cmpxchg does not succeed then we may\n\t\t\t\t * drop the list_lock without any processing.\n\t\t\t\t *\n\t\t\t\t * Otherwise the list_lock will synchronize with\n\t\t\t\t * other processors updating the list of slabs.\n\t\t\t\t */\n\t\t\t\tspin_lock_irqsave(&n->list_lock, flags);\n\n\t\t\t}\n\t\t}\n\n\t} while (!cmpxchg_double_slab(s, page,\n\t\tprior, counters,\n\t\thead, new.counters,\n\t\t\"__slab_free\"));\n\n\tif (likely(!n)) {\n\n\t\t/*\n\t\t * If we just froze the page then put it onto the\n\t\t * per cpu partial list.\n\t\t */\n\t\tif (new.frozen && !was_frozen) {\n\t\t\tput_cpu_partial(s, page, 1);\n\t\t\tstat(s, CPU_PARTIAL_FREE);\n\t\t}\n\t\t/*\n\t\t * The list lock was not taken therefore no list\n\t\t * activity can be necessary.\n\t\t */\n\t\tif (was_frozen)\n\t\t\tstat(s, FREE_FROZEN);\n\t\treturn;\n\t}\n\n\tif (unlikely(!new.inuse && n->nr_partial >= s->min_partial))\n\t\tgoto slab_empty;\n\n\t/*\n\t * Objects left in the slab. If it was not on the partial list before\n\t * then add it.\n\t */\n\tif (!kmem_cache_has_cpu_partial(s) && unlikely(!prior)) {\n\t\tif (kmem_cache_debug(s))\n\t\t\tremove_full(s, n, page);\n\t\tadd_partial(n, page, DEACTIVATE_TO_TAIL);\n\t\tstat(s, FREE_ADD_PARTIAL);\n\t}\n\tspin_unlock_irqrestore(&n->list_lock, flags);\n\treturn;\n\nslab_empty:\n\tif (prior) {\n\t\t/*\n\t\t * Slab on the partial list.\n\t\t */\n\t\tremove_partial(n, page);\n\t\tstat(s, FREE_REMOVE_PARTIAL);\n\t} else {\n\t\t/* Slab must be on the full list */\n\t\tremove_full(s, n, page);\n\t}\n\n\tspin_unlock_irqrestore(&n->list_lock, flags);\n\tstat(s, FREE_SLAB);\n\tdiscard_slab(s, page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic void __slab_free(struct kmem_cache *s, struct page *page,\n\t\t\tvoid *head, void *tail, int cnt,\n\t\t\tunsigned long addr)\n\n{\n\tvoid *prior;\n\tint was_frozen;\n\tstruct page new;\n\tunsigned long counters;\n\tstruct kmem_cache_node *n = NULL;\n\tunsigned long uninitialized_var(flags);\n\n\tstat(s, FREE_SLOWPATH);\n\n\tif (kmem_cache_debug(s) &&\n\t    !free_debug_processing(s, page, head, tail, cnt, addr))\n\t\treturn;\n\n\tdo {\n\t\tif (unlikely(n)) {\n\t\t\tspin_unlock_irqrestore(&n->list_lock, flags);\n\t\t\tn = NULL;\n\t\t}\n\t\tprior = page->freelist;\n\t\tcounters = page->counters;\n\t\tset_freepointer(s, tail, prior);\n\t\tnew.counters = counters;\n\t\twas_frozen = new.frozen;\n\t\tnew.inuse -= cnt;\n\t\tif ((!new.inuse || !prior) && !was_frozen) {\n\n\t\t\tif (kmem_cache_has_cpu_partial(s) && !prior) {\n\n\t\t\t\t/*\n\t\t\t\t * Slab was on no list before and will be\n\t\t\t\t * partially empty\n\t\t\t\t * We can defer the list move and instead\n\t\t\t\t * freeze it.\n\t\t\t\t */\n\t\t\t\tnew.frozen = 1;\n\n\t\t\t} else { /* Needs to be taken off a list */\n\n\t\t\t\tn = get_node(s, page_to_nid(page));\n\t\t\t\t/*\n\t\t\t\t * Speculatively acquire the list_lock.\n\t\t\t\t * If the cmpxchg does not succeed then we may\n\t\t\t\t * drop the list_lock without any processing.\n\t\t\t\t *\n\t\t\t\t * Otherwise the list_lock will synchronize with\n\t\t\t\t * other processors updating the list of slabs.\n\t\t\t\t */\n\t\t\t\tspin_lock_irqsave(&n->list_lock, flags);\n\n\t\t\t}\n\t\t}\n\n\t} while (!cmpxchg_double_slab(s, page,\n\t\tprior, counters,\n\t\thead, new.counters,\n\t\t\"__slab_free\"));\n\n\tif (likely(!n)) {\n\n\t\t/*\n\t\t * If we just froze the page then put it onto the\n\t\t * per cpu partial list.\n\t\t */\n\t\tif (new.frozen && !was_frozen) {\n\t\t\tput_cpu_partial(s, page, 1);\n\t\t\tstat(s, CPU_PARTIAL_FREE);\n\t\t}\n\t\t/*\n\t\t * The list lock was not taken therefore no list\n\t\t * activity can be necessary.\n\t\t */\n\t\tif (was_frozen)\n\t\t\tstat(s, FREE_FROZEN);\n\t\treturn;\n\t}\n\n\tif (unlikely(!new.inuse && n->nr_partial >= s->min_partial))\n\t\tgoto slab_empty;\n\n\t/*\n\t * Objects left in the slab. If it was not on the partial list before\n\t * then add it.\n\t */\n\tif (!kmem_cache_has_cpu_partial(s) && unlikely(!prior)) {\n\t\tif (kmem_cache_debug(s))\n\t\t\tremove_full(s, n, page);\n\t\tadd_partial(n, page, DEACTIVATE_TO_TAIL);\n\t\tstat(s, FREE_ADD_PARTIAL);\n\t}\n\tspin_unlock_irqrestore(&n->list_lock, flags);\n\treturn;\n\nslab_empty:\n\tif (prior) {\n\t\t/*\n\t\t * Slab on the partial list.\n\t\t */\n\t\tremove_partial(n, page);\n\t\tstat(s, FREE_REMOVE_PARTIAL);\n\t} else {\n\t\t/* Slab must be on the full list */\n\t\tremove_full(s, n, page);\n\t}\n\n\tspin_unlock_irqrestore(&n->list_lock, flags);\n\tstat(s, FREE_SLAB);\n\tdiscard_slab(s, page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "s",
            "FREE_FASTPATH"
          ],
          "line": 2977
        },
        "resolved": true,
        "details": {
          "function_name": "slabinfo_show_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "5900-5902",
          "snippet": "void slabinfo_show_stats(struct seq_file *m, struct kmem_cache *s)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid slabinfo_show_stats(struct seq_file *m, struct kmem_cache *s)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "note_cmpxchg_failure",
          "args": [
            "\"slab_free\"",
            "s",
            "tid"
          ],
          "line": 2974
        },
        "resolved": true,
        "details": {
          "function_name": "note_cmpxchg_failure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1992-2014",
          "snippet": "static inline void note_cmpxchg_failure(const char *n,\n\t\tconst struct kmem_cache *s, unsigned long tid)\n{\n#ifdef SLUB_DEBUG_CMPXCHG\n\tunsigned long actual_tid = __this_cpu_read(s->cpu_slab->tid);\n\n\tpr_info(\"%s %s: cmpxchg redo \", n, s->name);\n\n#ifdef CONFIG_PREEMPT\n\tif (tid_to_cpu(tid) != tid_to_cpu(actual_tid))\n\t\tpr_warn(\"due to cpu change %d -> %d\\n\",\n\t\t\ttid_to_cpu(tid), tid_to_cpu(actual_tid));\n\telse\n#endif\n\tif (tid_to_event(tid) != tid_to_event(actual_tid))\n\t\tpr_warn(\"due to cpu running other code. Event %ld->%ld\\n\",\n\t\t\ttid_to_event(tid), tid_to_event(actual_tid));\n\telse\n\t\tpr_warn(\"for unknown reason: actual=%lx was=%lx target=%lx\\n\",\n\t\t\tactual_tid, tid, next_tid(tid));\n#endif\n\tstat(s, CMPXCHG_DOUBLE_CPU_FAIL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void note_cmpxchg_failure(const char *n,\n\t\tconst struct kmem_cache *s, unsigned long tid)\n{\n#ifdef SLUB_DEBUG_CMPXCHG\n\tunsigned long actual_tid = __this_cpu_read(s->cpu_slab->tid);\n\n\tpr_info(\"%s %s: cmpxchg redo \", n, s->name);\n\n#ifdef CONFIG_PREEMPT\n\tif (tid_to_cpu(tid) != tid_to_cpu(actual_tid))\n\t\tpr_warn(\"due to cpu change %d -> %d\\n\",\n\t\t\ttid_to_cpu(tid), tid_to_cpu(actual_tid));\n\telse\n#endif\n\tif (tid_to_event(tid) != tid_to_event(actual_tid))\n\t\tpr_warn(\"due to cpu running other code. Event %ld->%ld\\n\",\n\t\t\ttid_to_event(tid), tid_to_event(actual_tid));\n\telse\n\t\tpr_warn(\"for unknown reason: actual=%lx was=%lx target=%lx\\n\",\n\t\t\tactual_tid, tid, next_tid(tid));\n#endif\n\tstat(s, CMPXCHG_DOUBLE_CPU_FAIL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!this_cpu_cmpxchg_double(\n\t\t\t\ts->cpu_slab->freelist, s->cpu_slab->tid,\n\t\t\t\tc->freelist, tid,\n\t\t\t\thead, next_tid(tid))"
          ],
          "line": 2969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_cmpxchg_double",
          "args": [
            "s->cpu_slab->freelist",
            "s->cpu_slab->tid",
            "c->freelist",
            "tid",
            "head",
            "next_tid(tid)"
          ],
          "line": 2969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_tid",
          "args": [
            "tid"
          ],
          "line": 2972
        },
        "resolved": true,
        "details": {
          "function_name": "next_tid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1972-1975",
          "snippet": "static inline unsigned long next_tid(unsigned long tid)\n{\n\treturn tid + TID_STEP;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define TID_STEP 1",
            "#define TID_STEP  roundup_pow_of_two(CONFIG_NR_CPUS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define TID_STEP 1\n#define TID_STEP  roundup_pow_of_two(CONFIG_NR_CPUS)\n\nstatic inline unsigned long next_tid(unsigned long tid)\n{\n\treturn tid + TID_STEP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_freepointer",
          "args": [
            "s",
            "tail_obj",
            "c->freelist"
          ],
          "line": 2967
        },
        "resolved": true,
        "details": {
          "function_name": "set_freepointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "289-298",
          "snippet": "static inline void set_freepointer(struct kmem_cache *s, void *object, void *fp)\n{\n\tunsigned long freeptr_addr = (unsigned long)object + s->offset;\n\n#ifdef CONFIG_SLAB_FREELIST_HARDENED\n\tBUG_ON(object == fp); /* naive detection of double free or corruption */\n#endif\n\n\t*(void **)freeptr_addr = freelist_ptr(s, fp, freeptr_addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void set_freepointer(struct kmem_cache *s, void *object, void *fp)\n{\n\tunsigned long freeptr_addr = (unsigned long)object + s->offset;\n\n#ifdef CONFIG_SLAB_FREELIST_HARDENED\n\tBUG_ON(object == fp); /* naive detection of double free or corruption */\n#endif\n\n\t*(void **)freeptr_addr = freelist_ptr(s, fp, freeptr_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "page == c->page"
          ],
          "line": 2966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 2964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "tid != READ_ONCE(c->tid)"
          ],
          "line": 2961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "c->tid"
          ],
          "line": 2961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PREEMPT"
          ],
          "line": 2960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_cpu_ptr",
          "args": [
            "s->cpu_slab"
          ],
          "line": 2959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_read",
          "args": [
            "s->cpu_slab->tid"
          ],
          "line": 2958
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic __always_inline void do_slab_free(struct kmem_cache *s,\n\t\t\t\tstruct page *page, void *head, void *tail,\n\t\t\t\tint cnt, unsigned long addr)\n{\n\tvoid *tail_obj = tail ? : head;\n\tstruct kmem_cache_cpu *c;\n\tunsigned long tid;\nredo:\n\t/*\n\t * Determine the currently cpus per cpu slab.\n\t * The cpu may change afterward. However that does not matter since\n\t * data is retrieved via this pointer. If we are on the same cpu\n\t * during the cmpxchg then the free will succeed.\n\t */\n\tdo {\n\t\ttid = this_cpu_read(s->cpu_slab->tid);\n\t\tc = raw_cpu_ptr(s->cpu_slab);\n\t} while (IS_ENABLED(CONFIG_PREEMPT) &&\n\t\t unlikely(tid != READ_ONCE(c->tid)));\n\n\t/* Same with comment on barrier() in slab_alloc_node() */\n\tbarrier();\n\n\tif (likely(page == c->page)) {\n\t\tset_freepointer(s, tail_obj, c->freelist);\n\n\t\tif (unlikely(!this_cpu_cmpxchg_double(\n\t\t\t\ts->cpu_slab->freelist, s->cpu_slab->tid,\n\t\t\t\tc->freelist, tid,\n\t\t\t\thead, next_tid(tid)))) {\n\n\t\t\tnote_cmpxchg_failure(\"slab_free\", s, tid);\n\t\t\tgoto redo;\n\t\t}\n\t\tstat(s, FREE_FASTPATH);\n\t} else\n\t\t__slab_free(s, page, head, tail_obj, cnt, addr);\n\n}"
  },
  {
    "function_name": "__slab_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "2814-2926",
    "snippet": "static void __slab_free(struct kmem_cache *s, struct page *page,\n\t\t\tvoid *head, void *tail, int cnt,\n\t\t\tunsigned long addr)\n\n{\n\tvoid *prior;\n\tint was_frozen;\n\tstruct page new;\n\tunsigned long counters;\n\tstruct kmem_cache_node *n = NULL;\n\tunsigned long uninitialized_var(flags);\n\n\tstat(s, FREE_SLOWPATH);\n\n\tif (kmem_cache_debug(s) &&\n\t    !free_debug_processing(s, page, head, tail, cnt, addr))\n\t\treturn;\n\n\tdo {\n\t\tif (unlikely(n)) {\n\t\t\tspin_unlock_irqrestore(&n->list_lock, flags);\n\t\t\tn = NULL;\n\t\t}\n\t\tprior = page->freelist;\n\t\tcounters = page->counters;\n\t\tset_freepointer(s, tail, prior);\n\t\tnew.counters = counters;\n\t\twas_frozen = new.frozen;\n\t\tnew.inuse -= cnt;\n\t\tif ((!new.inuse || !prior) && !was_frozen) {\n\n\t\t\tif (kmem_cache_has_cpu_partial(s) && !prior) {\n\n\t\t\t\t/*\n\t\t\t\t * Slab was on no list before and will be\n\t\t\t\t * partially empty\n\t\t\t\t * We can defer the list move and instead\n\t\t\t\t * freeze it.\n\t\t\t\t */\n\t\t\t\tnew.frozen = 1;\n\n\t\t\t} else { /* Needs to be taken off a list */\n\n\t\t\t\tn = get_node(s, page_to_nid(page));\n\t\t\t\t/*\n\t\t\t\t * Speculatively acquire the list_lock.\n\t\t\t\t * If the cmpxchg does not succeed then we may\n\t\t\t\t * drop the list_lock without any processing.\n\t\t\t\t *\n\t\t\t\t * Otherwise the list_lock will synchronize with\n\t\t\t\t * other processors updating the list of slabs.\n\t\t\t\t */\n\t\t\t\tspin_lock_irqsave(&n->list_lock, flags);\n\n\t\t\t}\n\t\t}\n\n\t} while (!cmpxchg_double_slab(s, page,\n\t\tprior, counters,\n\t\thead, new.counters,\n\t\t\"__slab_free\"));\n\n\tif (likely(!n)) {\n\n\t\t/*\n\t\t * If we just froze the page then put it onto the\n\t\t * per cpu partial list.\n\t\t */\n\t\tif (new.frozen && !was_frozen) {\n\t\t\tput_cpu_partial(s, page, 1);\n\t\t\tstat(s, CPU_PARTIAL_FREE);\n\t\t}\n\t\t/*\n\t\t * The list lock was not taken therefore no list\n\t\t * activity can be necessary.\n\t\t */\n\t\tif (was_frozen)\n\t\t\tstat(s, FREE_FROZEN);\n\t\treturn;\n\t}\n\n\tif (unlikely(!new.inuse && n->nr_partial >= s->min_partial))\n\t\tgoto slab_empty;\n\n\t/*\n\t * Objects left in the slab. If it was not on the partial list before\n\t * then add it.\n\t */\n\tif (!kmem_cache_has_cpu_partial(s) && unlikely(!prior)) {\n\t\tif (kmem_cache_debug(s))\n\t\t\tremove_full(s, n, page);\n\t\tadd_partial(n, page, DEACTIVATE_TO_TAIL);\n\t\tstat(s, FREE_ADD_PARTIAL);\n\t}\n\tspin_unlock_irqrestore(&n->list_lock, flags);\n\treturn;\n\nslab_empty:\n\tif (prior) {\n\t\t/*\n\t\t * Slab on the partial list.\n\t\t */\n\t\tremove_partial(n, page);\n\t\tstat(s, FREE_REMOVE_PARTIAL);\n\t} else {\n\t\t/* Slab must be on the full list */\n\t\tremove_full(s, n, page);\n\t}\n\n\tspin_unlock_irqrestore(&n->list_lock, flags);\n\tstat(s, FREE_SLAB);\n\tdiscard_slab(s, page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *kmem_cache_node;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "discard_slab",
          "args": [
            "s",
            "page"
          ],
          "line": 2925
        },
        "resolved": true,
        "details": {
          "function_name": "discard_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1740-1744",
          "snippet": "static void discard_slab(struct kmem_cache *s, struct page *page)\n{\n\tdec_slabs_node(s, page_to_nid(page), page->objects);\n\tfree_slab(s, page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void discard_slab(struct kmem_cache *s, struct page *page)\n{\n\tdec_slabs_node(s, page_to_nid(page), page->objects);\n\tfree_slab(s, page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "s",
            "FREE_SLAB"
          ],
          "line": 2924
        },
        "resolved": true,
        "details": {
          "function_name": "slabinfo_show_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "5900-5902",
          "snippet": "void slabinfo_show_stats(struct seq_file *m, struct kmem_cache *s)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid slabinfo_show_stats(struct seq_file *m, struct kmem_cache *s)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&n->list_lock",
            "flags"
          ],
          "line": 2923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_full",
          "args": [
            "s",
            "n",
            "page"
          ],
          "line": 2920
        },
        "resolved": true,
        "details": {
          "function_name": "remove_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1348-1349",
          "snippet": "static inline void remove_full(struct kmem_cache *s, struct kmem_cache_node *n,\n\t\t\t\t\tstruct page *page) {}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic inline void remove_full(struct kmem_cache *s, struct kmem_cache_node *n,\n\t\t\t\t\tstruct page *page) {}"
        }
      },
      {
        "call_info": {
          "callee": "remove_partial",
          "args": [
            "n",
            "page"
          ],
          "line": 2916
        },
        "resolved": true,
        "details": {
          "function_name": "remove_partial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1766-1772",
          "snippet": "static inline void remove_partial(struct kmem_cache_node *n,\n\t\t\t\t\tstruct page *page)\n{\n\tlockdep_assert_held(&n->list_lock);\n\tlist_del(&page->lru);\n\tn->nr_partial--;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic inline void remove_partial(struct kmem_cache_node *n,\n\t\t\t\t\tstruct page *page)\n{\n\tlockdep_assert_held(&n->list_lock);\n\tlist_del(&page->lru);\n\tn->nr_partial--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&n->list_lock",
            "flags"
          ],
          "line": 2908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_partial",
          "args": [
            "n",
            "page",
            "DEACTIVATE_TO_TAIL"
          ],
          "line": 2905
        },
        "resolved": true,
        "details": {
          "function_name": "add_partial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1759-1764",
          "snippet": "static inline void add_partial(struct kmem_cache_node *n,\n\t\t\t\tstruct page *page, int tail)\n{\n\tlockdep_assert_held(&n->list_lock);\n\t__add_partial(n, page, tail);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic inline void add_partial(struct kmem_cache_node *n,\n\t\t\t\tstruct page *page, int tail)\n{\n\tlockdep_assert_held(&n->list_lock);\n\t__add_partial(n, page, tail);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_debug",
          "args": [
            "s"
          ],
          "line": 2903
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "118-125",
          "snippet": "static inline int kmem_cache_debug(struct kmem_cache *s)\n{\n#ifdef CONFIG_SLUB_DEBUG\n\treturn unlikely(s->flags & SLAB_DEBUG_FLAGS);\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline int kmem_cache_debug(struct kmem_cache *s)\n{\n#ifdef CONFIG_SLUB_DEBUG\n\treturn unlikely(s->flags & SLAB_DEBUG_FLAGS);\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!prior"
          ],
          "line": 2902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_has_cpu_partial",
          "args": [
            "s"
          ],
          "line": 2902
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_has_cpu_partial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "135-142",
          "snippet": "static inline bool kmem_cache_has_cpu_partial(struct kmem_cache *s)\n{\n#ifdef CONFIG_SLUB_CPU_PARTIAL\n\treturn !kmem_cache_debug(s);\n#else\n\treturn false;\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline bool kmem_cache_has_cpu_partial(struct kmem_cache *s)\n{\n#ifdef CONFIG_SLUB_CPU_PARTIAL\n\treturn !kmem_cache_debug(s);\n#else\n\treturn false;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!new.inuse && n->nr_partial >= s->min_partial"
          ],
          "line": 2895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_cpu_partial",
          "args": [
            "s",
            "page",
            "1"
          ],
          "line": 2883
        },
        "resolved": true,
        "details": {
          "function_name": "put_cpu_partial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2247-2297",
          "snippet": "static void put_cpu_partial(struct kmem_cache *s, struct page *page, int drain)\n{\n#ifdef CONFIG_SLUB_CPU_PARTIAL\n\tstruct page *oldpage;\n\tint pages;\n\tint pobjects;\n\n\tpreempt_disable();\n\tdo {\n\t\tpages = 0;\n\t\tpobjects = 0;\n\t\toldpage = this_cpu_read(s->cpu_slab->partial);\n\n\t\tif (oldpage) {\n\t\t\tpobjects = oldpage->pobjects;\n\t\t\tpages = oldpage->pages;\n\t\t\tif (drain && pobjects > s->cpu_partial) {\n\t\t\t\tunsigned long flags;\n\t\t\t\t/*\n\t\t\t\t * partial array is full. Move the existing\n\t\t\t\t * set to the per node partial list.\n\t\t\t\t */\n\t\t\t\tlocal_irq_save(flags);\n\t\t\t\tunfreeze_partials(s, this_cpu_ptr(s->cpu_slab));\n\t\t\t\tlocal_irq_restore(flags);\n\t\t\t\toldpage = NULL;\n\t\t\t\tpobjects = 0;\n\t\t\t\tpages = 0;\n\t\t\t\tstat(s, CPU_PARTIAL_DRAIN);\n\t\t\t}\n\t\t}\n\n\t\tpages++;\n\t\tpobjects += page->objects - page->inuse;\n\n\t\tpage->pages = pages;\n\t\tpage->pobjects = pobjects;\n\t\tpage->next = oldpage;\n\n\t} while (this_cpu_cmpxchg(s->cpu_slab->partial, oldpage, page)\n\t\t\t\t\t\t\t\t!= oldpage);\n\tif (unlikely(!s->cpu_partial)) {\n\t\tunsigned long flags;\n\n\t\tlocal_irq_save(flags);\n\t\tunfreeze_partials(s, this_cpu_ptr(s->cpu_slab));\n\t\tlocal_irq_restore(flags);\n\t}\n\tpreempt_enable();\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void put_cpu_partial(struct kmem_cache *s, struct page *page, int drain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void put_cpu_partial(struct kmem_cache *s, struct page *page, int drain);\n\nstatic void put_cpu_partial(struct kmem_cache *s, struct page *page, int drain)\n{\n#ifdef CONFIG_SLUB_CPU_PARTIAL\n\tstruct page *oldpage;\n\tint pages;\n\tint pobjects;\n\n\tpreempt_disable();\n\tdo {\n\t\tpages = 0;\n\t\tpobjects = 0;\n\t\toldpage = this_cpu_read(s->cpu_slab->partial);\n\n\t\tif (oldpage) {\n\t\t\tpobjects = oldpage->pobjects;\n\t\t\tpages = oldpage->pages;\n\t\t\tif (drain && pobjects > s->cpu_partial) {\n\t\t\t\tunsigned long flags;\n\t\t\t\t/*\n\t\t\t\t * partial array is full. Move the existing\n\t\t\t\t * set to the per node partial list.\n\t\t\t\t */\n\t\t\t\tlocal_irq_save(flags);\n\t\t\t\tunfreeze_partials(s, this_cpu_ptr(s->cpu_slab));\n\t\t\t\tlocal_irq_restore(flags);\n\t\t\t\toldpage = NULL;\n\t\t\t\tpobjects = 0;\n\t\t\t\tpages = 0;\n\t\t\t\tstat(s, CPU_PARTIAL_DRAIN);\n\t\t\t}\n\t\t}\n\n\t\tpages++;\n\t\tpobjects += page->objects - page->inuse;\n\n\t\tpage->pages = pages;\n\t\tpage->pobjects = pobjects;\n\t\tpage->next = oldpage;\n\n\t} while (this_cpu_cmpxchg(s->cpu_slab->partial, oldpage, page)\n\t\t\t\t\t\t\t\t!= oldpage);\n\tif (unlikely(!s->cpu_partial)) {\n\t\tunsigned long flags;\n\n\t\tlocal_irq_save(flags);\n\t\tunfreeze_partials(s, this_cpu_ptr(s->cpu_slab));\n\t\tlocal_irq_restore(flags);\n\t}\n\tpreempt_enable();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!n"
          ],
          "line": 2876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg_double_slab",
          "args": [
            "s",
            "page",
            "prior",
            "counters",
            "head",
            "new.counters",
            "\"__slab_free\""
          ],
          "line": 2871
        },
        "resolved": true,
        "details": {
          "function_name": "cmpxchg_double_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "395-434",
          "snippet": "static inline bool cmpxchg_double_slab(struct kmem_cache *s, struct page *page,\n\t\tvoid *freelist_old, unsigned long counters_old,\n\t\tvoid *freelist_new, unsigned long counters_new,\n\t\tconst char *n)\n{\n#if defined(CONFIG_HAVE_CMPXCHG_DOUBLE) && \\\n    defined(CONFIG_HAVE_ALIGNED_STRUCT_PAGE)\n\tif (s->flags & __CMPXCHG_DOUBLE) {\n\t\tif (cmpxchg_double(&page->freelist, &page->counters,\n\t\t\t\t   freelist_old, counters_old,\n\t\t\t\t   freelist_new, counters_new))\n\t\t\treturn true;\n\t} else\n#endif\n\t{\n\t\tunsigned long flags;\n\n\t\tlocal_irq_save(flags);\n\t\tslab_lock(page);\n\t\tif (page->freelist == freelist_old &&\n\t\t\t\t\tpage->counters == counters_old) {\n\t\t\tpage->freelist = freelist_new;\n\t\t\tpage->counters = counters_new;\n\t\t\tslab_unlock(page);\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn true;\n\t\t}\n\t\tslab_unlock(page);\n\t\tlocal_irq_restore(flags);\n\t}\n\n\tcpu_relax();\n\tstat(s, CMPXCHG_DOUBLE_FAIL);\n\n#ifdef SLUB_DEBUG_CMPXCHG\n\tpr_info(\"%s %s: cmpxchg double redo \", n, s->name);\n#endif\n\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define __CMPXCHG_DOUBLE\t((slab_flags_t __force)0x40000000U)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define __CMPXCHG_DOUBLE\t((slab_flags_t __force)0x40000000U)\n\nstatic inline bool cmpxchg_double_slab(struct kmem_cache *s, struct page *page,\n\t\tvoid *freelist_old, unsigned long counters_old,\n\t\tvoid *freelist_new, unsigned long counters_new,\n\t\tconst char *n)\n{\n#if defined(CONFIG_HAVE_CMPXCHG_DOUBLE) && \\\n    defined(CONFIG_HAVE_ALIGNED_STRUCT_PAGE)\n\tif (s->flags & __CMPXCHG_DOUBLE) {\n\t\tif (cmpxchg_double(&page->freelist, &page->counters,\n\t\t\t\t   freelist_old, counters_old,\n\t\t\t\t   freelist_new, counters_new))\n\t\t\treturn true;\n\t} else\n#endif\n\t{\n\t\tunsigned long flags;\n\n\t\tlocal_irq_save(flags);\n\t\tslab_lock(page);\n\t\tif (page->freelist == freelist_old &&\n\t\t\t\t\tpage->counters == counters_old) {\n\t\t\tpage->freelist = freelist_new;\n\t\t\tpage->counters = counters_new;\n\t\t\tslab_unlock(page);\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn true;\n\t\t}\n\t\tslab_unlock(page);\n\t\tlocal_irq_restore(flags);\n\t}\n\n\tcpu_relax();\n\tstat(s, CMPXCHG_DOUBLE_FAIL);\n\n#ifdef SLUB_DEBUG_CMPXCHG\n\tpr_info(\"%s %s: cmpxchg double redo \", n, s->name);\n#endif\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&n->list_lock",
            "flags"
          ],
          "line": 2866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node",
          "args": [
            "s",
            "page_to_nid(page)"
          ],
          "line": 2857
        },
        "resolved": true,
        "details": {
          "function_name": "get_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "485-488",
          "snippet": "static inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 2857
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_freepointer",
          "args": [
            "s",
            "tail",
            "prior"
          ],
          "line": 2839
        },
        "resolved": true,
        "details": {
          "function_name": "set_freepointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "289-298",
          "snippet": "static inline void set_freepointer(struct kmem_cache *s, void *object, void *fp)\n{\n\tunsigned long freeptr_addr = (unsigned long)object + s->offset;\n\n#ifdef CONFIG_SLAB_FREELIST_HARDENED\n\tBUG_ON(object == fp); /* naive detection of double free or corruption */\n#endif\n\n\t*(void **)freeptr_addr = freelist_ptr(s, fp, freeptr_addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void set_freepointer(struct kmem_cache *s, void *object, void *fp)\n{\n\tunsigned long freeptr_addr = (unsigned long)object + s->offset;\n\n#ifdef CONFIG_SLAB_FREELIST_HARDENED\n\tBUG_ON(object == fp); /* naive detection of double free or corruption */\n#endif\n\n\t*(void **)freeptr_addr = freelist_ptr(s, fp, freeptr_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&n->list_lock",
            "flags"
          ],
          "line": 2834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "n"
          ],
          "line": 2833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_debug_processing",
          "args": [
            "s",
            "page",
            "head",
            "tail",
            "cnt",
            "addr"
          ],
          "line": 2829
        },
        "resolved": true,
        "details": {
          "function_name": "free_debug_processing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1337-1340",
          "snippet": "static inline int free_debug_processing(\n\tstruct kmem_cache *s, struct page *page,\n\tvoid *head, void *tail, int bulk_cnt,\n\tunsigned long addr) { return 0; }",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline int free_debug_processing(\n\tstruct kmem_cache *s, struct page *page,\n\tvoid *head, void *tail, int bulk_cnt,\n\tunsigned long addr) { return 0; }"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic void __slab_free(struct kmem_cache *s, struct page *page,\n\t\t\tvoid *head, void *tail, int cnt,\n\t\t\tunsigned long addr)\n\n{\n\tvoid *prior;\n\tint was_frozen;\n\tstruct page new;\n\tunsigned long counters;\n\tstruct kmem_cache_node *n = NULL;\n\tunsigned long uninitialized_var(flags);\n\n\tstat(s, FREE_SLOWPATH);\n\n\tif (kmem_cache_debug(s) &&\n\t    !free_debug_processing(s, page, head, tail, cnt, addr))\n\t\treturn;\n\n\tdo {\n\t\tif (unlikely(n)) {\n\t\t\tspin_unlock_irqrestore(&n->list_lock, flags);\n\t\t\tn = NULL;\n\t\t}\n\t\tprior = page->freelist;\n\t\tcounters = page->counters;\n\t\tset_freepointer(s, tail, prior);\n\t\tnew.counters = counters;\n\t\twas_frozen = new.frozen;\n\t\tnew.inuse -= cnt;\n\t\tif ((!new.inuse || !prior) && !was_frozen) {\n\n\t\t\tif (kmem_cache_has_cpu_partial(s) && !prior) {\n\n\t\t\t\t/*\n\t\t\t\t * Slab was on no list before and will be\n\t\t\t\t * partially empty\n\t\t\t\t * We can defer the list move and instead\n\t\t\t\t * freeze it.\n\t\t\t\t */\n\t\t\t\tnew.frozen = 1;\n\n\t\t\t} else { /* Needs to be taken off a list */\n\n\t\t\t\tn = get_node(s, page_to_nid(page));\n\t\t\t\t/*\n\t\t\t\t * Speculatively acquire the list_lock.\n\t\t\t\t * If the cmpxchg does not succeed then we may\n\t\t\t\t * drop the list_lock without any processing.\n\t\t\t\t *\n\t\t\t\t * Otherwise the list_lock will synchronize with\n\t\t\t\t * other processors updating the list of slabs.\n\t\t\t\t */\n\t\t\t\tspin_lock_irqsave(&n->list_lock, flags);\n\n\t\t\t}\n\t\t}\n\n\t} while (!cmpxchg_double_slab(s, page,\n\t\tprior, counters,\n\t\thead, new.counters,\n\t\t\"__slab_free\"));\n\n\tif (likely(!n)) {\n\n\t\t/*\n\t\t * If we just froze the page then put it onto the\n\t\t * per cpu partial list.\n\t\t */\n\t\tif (new.frozen && !was_frozen) {\n\t\t\tput_cpu_partial(s, page, 1);\n\t\t\tstat(s, CPU_PARTIAL_FREE);\n\t\t}\n\t\t/*\n\t\t * The list lock was not taken therefore no list\n\t\t * activity can be necessary.\n\t\t */\n\t\tif (was_frozen)\n\t\t\tstat(s, FREE_FROZEN);\n\t\treturn;\n\t}\n\n\tif (unlikely(!new.inuse && n->nr_partial >= s->min_partial))\n\t\tgoto slab_empty;\n\n\t/*\n\t * Objects left in the slab. If it was not on the partial list before\n\t * then add it.\n\t */\n\tif (!kmem_cache_has_cpu_partial(s) && unlikely(!prior)) {\n\t\tif (kmem_cache_debug(s))\n\t\t\tremove_full(s, n, page);\n\t\tadd_partial(n, page, DEACTIVATE_TO_TAIL);\n\t\tstat(s, FREE_ADD_PARTIAL);\n\t}\n\tspin_unlock_irqrestore(&n->list_lock, flags);\n\treturn;\n\nslab_empty:\n\tif (prior) {\n\t\t/*\n\t\t * Slab on the partial list.\n\t\t */\n\t\tremove_partial(n, page);\n\t\tstat(s, FREE_REMOVE_PARTIAL);\n\t} else {\n\t\t/* Slab must be on the full list */\n\t\tremove_full(s, n, page);\n\t}\n\n\tspin_unlock_irqrestore(&n->list_lock, flags);\n\tstat(s, FREE_SLAB);\n\tdiscard_slab(s, page);\n}"
  },
  {
    "function_name": "kmem_cache_alloc_node_trace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "2790-2801",
    "snippet": "void *kmem_cache_alloc_node_trace(struct kmem_cache *s,\n\t\t\t\t    gfp_t gfpflags,\n\t\t\t\t    int node, size_t size)\n{\n\tvoid *ret = slab_alloc_node(s, gfpflags, node, _RET_IP_);\n\n\ttrace_kmalloc_node(_RET_IP_, ret,\n\t\t\t   size, s->size, gfpflags, node);\n\n\tkasan_kmalloc(s, ret, size, gfpflags);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kasan_kmalloc",
          "args": [
            "s",
            "ret",
            "size",
            "gfpflags"
          ],
          "line": 2799
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "531-554",
          "snippet": "void kasan_kmalloc(struct kmem_cache *cache, const void *object, size_t size,\n\t\t   gfp_t flags)\n{\n\tunsigned long redzone_start;\n\tunsigned long redzone_end;\n\n\tif (gfpflags_allow_blocking(flags))\n\t\tquarantine_reduce();\n\n\tif (unlikely(object == NULL))\n\t\treturn;\n\n\tredzone_start = round_up((unsigned long)(object + size),\n\t\t\t\tKASAN_SHADOW_SCALE_SIZE);\n\tredzone_end = round_up((unsigned long)object + cache->object_size,\n\t\t\t\tKASAN_SHADOW_SCALE_SIZE);\n\n\tkasan_unpoison_shadow(object, size);\n\tkasan_poison_shadow((void *)redzone_start, redzone_end - redzone_start,\n\t\tKASAN_KMALLOC_REDZONE);\n\n\tif (cache->flags & SLAB_KASAN)\n\t\tset_track(&get_alloc_info(cache, object)->alloc_track, flags);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid kasan_kmalloc(struct kmem_cache *cache, const void *object, size_t size,\n\t\t   gfp_t flags)\n{\n\tunsigned long redzone_start;\n\tunsigned long redzone_end;\n\n\tif (gfpflags_allow_blocking(flags))\n\t\tquarantine_reduce();\n\n\tif (unlikely(object == NULL))\n\t\treturn;\n\n\tredzone_start = round_up((unsigned long)(object + size),\n\t\t\t\tKASAN_SHADOW_SCALE_SIZE);\n\tredzone_end = round_up((unsigned long)object + cache->object_size,\n\t\t\t\tKASAN_SHADOW_SCALE_SIZE);\n\n\tkasan_unpoison_shadow(object, size);\n\tkasan_poison_shadow((void *)redzone_start, redzone_end - redzone_start,\n\t\tKASAN_KMALLOC_REDZONE);\n\n\tif (cache->flags & SLAB_KASAN)\n\t\tset_track(&get_alloc_info(cache, object)->alloc_track, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kmalloc_node",
          "args": [
            "_RET_IP_",
            "ret",
            "size",
            "s->size",
            "gfpflags",
            "node"
          ],
          "line": 2796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_alloc_node",
          "args": [
            "s",
            "gfpflags",
            "node",
            "_RET_IP_"
          ],
          "line": 2794
        },
        "resolved": true,
        "details": {
          "function_name": "slab_alloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2662-2747",
          "snippet": "static __always_inline void *slab_alloc_node(struct kmem_cache *s,\n\t\tgfp_t gfpflags, int node, unsigned long addr)\n{\n\tvoid *object;\n\tstruct kmem_cache_cpu *c;\n\tstruct page *page;\n\tunsigned long tid;\n\n\ts = slab_pre_alloc_hook(s, gfpflags);\n\tif (!s)\n\t\treturn NULL;\nredo:\n\t/*\n\t * Must read kmem_cache cpu data via this cpu ptr. Preemption is\n\t * enabled. We may switch back and forth between cpus while\n\t * reading from one cpu area. That does not matter as long\n\t * as we end up on the original cpu again when doing the cmpxchg.\n\t *\n\t * We should guarantee that tid and kmem_cache are retrieved on\n\t * the same cpu. It could be different if CONFIG_PREEMPT so we need\n\t * to check if it is matched or not.\n\t */\n\tdo {\n\t\ttid = this_cpu_read(s->cpu_slab->tid);\n\t\tc = raw_cpu_ptr(s->cpu_slab);\n\t} while (IS_ENABLED(CONFIG_PREEMPT) &&\n\t\t unlikely(tid != READ_ONCE(c->tid)));\n\n\t/*\n\t * Irqless object alloc/free algorithm used here depends on sequence\n\t * of fetching cpu_slab's data. tid should be fetched before anything\n\t * on c to guarantee that object and page associated with previous tid\n\t * won't be used with current tid. If we fetch tid first, object and\n\t * page could be one associated with next tid and our alloc/free\n\t * request will be failed. In this case, we will retry. So, no problem.\n\t */\n\tbarrier();\n\n\t/*\n\t * The transaction ids are globally unique per cpu and per operation on\n\t * a per cpu queue. Thus they can be guarantee that the cmpxchg_double\n\t * occurs on the right processor and that there was no operation on the\n\t * linked list in between.\n\t */\n\n\tobject = c->freelist;\n\tpage = c->page;\n\tif (unlikely(!object || !node_match(page, node))) {\n\t\tobject = __slab_alloc(s, gfpflags, node, addr, c);\n\t\tstat(s, ALLOC_SLOWPATH);\n\t} else {\n\t\tvoid *next_object = get_freepointer_safe(s, object);\n\n\t\t/*\n\t\t * The cmpxchg will only match if there was no additional\n\t\t * operation and if we are on the right processor.\n\t\t *\n\t\t * The cmpxchg does the following atomically (without lock\n\t\t * semantics!)\n\t\t * 1. Relocate first pointer to the current per cpu area.\n\t\t * 2. Verify that tid and freelist have not been changed\n\t\t * 3. If they were not changed replace tid and freelist\n\t\t *\n\t\t * Since this is without lock semantics the protection is only\n\t\t * against code executing on this cpu *not* from access by\n\t\t * other cpus.\n\t\t */\n\t\tif (unlikely(!this_cpu_cmpxchg_double(\n\t\t\t\ts->cpu_slab->freelist, s->cpu_slab->tid,\n\t\t\t\tobject, tid,\n\t\t\t\tnext_object, next_tid(tid)))) {\n\n\t\t\tnote_cmpxchg_failure(\"slab_alloc\", s, tid);\n\t\t\tgoto redo;\n\t\t}\n\t\tprefetch_freepointer(s, next_object);\n\t\tstat(s, ALLOC_FASTPATH);\n\t}\n\n\tif (unlikely(gfpflags & __GFP_ZERO) && object)\n\t\tmemset(object, 0, s->object_size);\n\n\tslab_post_alloc_hook(s, gfpflags, 1, &object);\n\n\treturn object;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);\n\nstatic __always_inline void *slab_alloc_node(struct kmem_cache *s,\n\t\tgfp_t gfpflags, int node, unsigned long addr)\n{\n\tvoid *object;\n\tstruct kmem_cache_cpu *c;\n\tstruct page *page;\n\tunsigned long tid;\n\n\ts = slab_pre_alloc_hook(s, gfpflags);\n\tif (!s)\n\t\treturn NULL;\nredo:\n\t/*\n\t * Must read kmem_cache cpu data via this cpu ptr. Preemption is\n\t * enabled. We may switch back and forth between cpus while\n\t * reading from one cpu area. That does not matter as long\n\t * as we end up on the original cpu again when doing the cmpxchg.\n\t *\n\t * We should guarantee that tid and kmem_cache are retrieved on\n\t * the same cpu. It could be different if CONFIG_PREEMPT so we need\n\t * to check if it is matched or not.\n\t */\n\tdo {\n\t\ttid = this_cpu_read(s->cpu_slab->tid);\n\t\tc = raw_cpu_ptr(s->cpu_slab);\n\t} while (IS_ENABLED(CONFIG_PREEMPT) &&\n\t\t unlikely(tid != READ_ONCE(c->tid)));\n\n\t/*\n\t * Irqless object alloc/free algorithm used here depends on sequence\n\t * of fetching cpu_slab's data. tid should be fetched before anything\n\t * on c to guarantee that object and page associated with previous tid\n\t * won't be used with current tid. If we fetch tid first, object and\n\t * page could be one associated with next tid and our alloc/free\n\t * request will be failed. In this case, we will retry. So, no problem.\n\t */\n\tbarrier();\n\n\t/*\n\t * The transaction ids are globally unique per cpu and per operation on\n\t * a per cpu queue. Thus they can be guarantee that the cmpxchg_double\n\t * occurs on the right processor and that there was no operation on the\n\t * linked list in between.\n\t */\n\n\tobject = c->freelist;\n\tpage = c->page;\n\tif (unlikely(!object || !node_match(page, node))) {\n\t\tobject = __slab_alloc(s, gfpflags, node, addr, c);\n\t\tstat(s, ALLOC_SLOWPATH);\n\t} else {\n\t\tvoid *next_object = get_freepointer_safe(s, object);\n\n\t\t/*\n\t\t * The cmpxchg will only match if there was no additional\n\t\t * operation and if we are on the right processor.\n\t\t *\n\t\t * The cmpxchg does the following atomically (without lock\n\t\t * semantics!)\n\t\t * 1. Relocate first pointer to the current per cpu area.\n\t\t * 2. Verify that tid and freelist have not been changed\n\t\t * 3. If they were not changed replace tid and freelist\n\t\t *\n\t\t * Since this is without lock semantics the protection is only\n\t\t * against code executing on this cpu *not* from access by\n\t\t * other cpus.\n\t\t */\n\t\tif (unlikely(!this_cpu_cmpxchg_double(\n\t\t\t\ts->cpu_slab->freelist, s->cpu_slab->tid,\n\t\t\t\tobject, tid,\n\t\t\t\tnext_object, next_tid(tid)))) {\n\n\t\t\tnote_cmpxchg_failure(\"slab_alloc\", s, tid);\n\t\t\tgoto redo;\n\t\t}\n\t\tprefetch_freepointer(s, next_object);\n\t\tstat(s, ALLOC_FASTPATH);\n\t}\n\n\tif (unlikely(gfpflags & __GFP_ZERO) && object)\n\t\tmemset(object, 0, s->object_size);\n\n\tslab_post_alloc_hook(s, gfpflags, 1, &object);\n\n\treturn object;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);\n\nvoid *kmem_cache_alloc_node_trace(struct kmem_cache *s,\n\t\t\t\t    gfp_t gfpflags,\n\t\t\t\t    int node, size_t size)\n{\n\tvoid *ret = slab_alloc_node(s, gfpflags, node, _RET_IP_);\n\n\ttrace_kmalloc_node(_RET_IP_, ret,\n\t\t\t   size, s->size, gfpflags, node);\n\n\tkasan_kmalloc(s, ret, size, gfpflags);\n\treturn ret;\n}"
  },
  {
    "function_name": "kmem_cache_alloc_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "2778-2786",
    "snippet": "void *kmem_cache_alloc_node(struct kmem_cache *s, gfp_t gfpflags, int node)\n{\n\tvoid *ret = slab_alloc_node(s, gfpflags, node, _RET_IP_);\n\n\ttrace_kmem_cache_alloc_node(_RET_IP_, ret,\n\t\t\t\t    s->object_size, s->size, gfpflags, node);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kmem_cache_alloc_node",
          "args": [
            "_RET_IP_",
            "ret",
            "s->object_size",
            "s->size",
            "gfpflags",
            "node"
          ],
          "line": 2782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_alloc_node",
          "args": [
            "s",
            "gfpflags",
            "node",
            "_RET_IP_"
          ],
          "line": 2780
        },
        "resolved": true,
        "details": {
          "function_name": "slab_alloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2662-2747",
          "snippet": "static __always_inline void *slab_alloc_node(struct kmem_cache *s,\n\t\tgfp_t gfpflags, int node, unsigned long addr)\n{\n\tvoid *object;\n\tstruct kmem_cache_cpu *c;\n\tstruct page *page;\n\tunsigned long tid;\n\n\ts = slab_pre_alloc_hook(s, gfpflags);\n\tif (!s)\n\t\treturn NULL;\nredo:\n\t/*\n\t * Must read kmem_cache cpu data via this cpu ptr. Preemption is\n\t * enabled. We may switch back and forth between cpus while\n\t * reading from one cpu area. That does not matter as long\n\t * as we end up on the original cpu again when doing the cmpxchg.\n\t *\n\t * We should guarantee that tid and kmem_cache are retrieved on\n\t * the same cpu. It could be different if CONFIG_PREEMPT so we need\n\t * to check if it is matched or not.\n\t */\n\tdo {\n\t\ttid = this_cpu_read(s->cpu_slab->tid);\n\t\tc = raw_cpu_ptr(s->cpu_slab);\n\t} while (IS_ENABLED(CONFIG_PREEMPT) &&\n\t\t unlikely(tid != READ_ONCE(c->tid)));\n\n\t/*\n\t * Irqless object alloc/free algorithm used here depends on sequence\n\t * of fetching cpu_slab's data. tid should be fetched before anything\n\t * on c to guarantee that object and page associated with previous tid\n\t * won't be used with current tid. If we fetch tid first, object and\n\t * page could be one associated with next tid and our alloc/free\n\t * request will be failed. In this case, we will retry. So, no problem.\n\t */\n\tbarrier();\n\n\t/*\n\t * The transaction ids are globally unique per cpu and per operation on\n\t * a per cpu queue. Thus they can be guarantee that the cmpxchg_double\n\t * occurs on the right processor and that there was no operation on the\n\t * linked list in between.\n\t */\n\n\tobject = c->freelist;\n\tpage = c->page;\n\tif (unlikely(!object || !node_match(page, node))) {\n\t\tobject = __slab_alloc(s, gfpflags, node, addr, c);\n\t\tstat(s, ALLOC_SLOWPATH);\n\t} else {\n\t\tvoid *next_object = get_freepointer_safe(s, object);\n\n\t\t/*\n\t\t * The cmpxchg will only match if there was no additional\n\t\t * operation and if we are on the right processor.\n\t\t *\n\t\t * The cmpxchg does the following atomically (without lock\n\t\t * semantics!)\n\t\t * 1. Relocate first pointer to the current per cpu area.\n\t\t * 2. Verify that tid and freelist have not been changed\n\t\t * 3. If they were not changed replace tid and freelist\n\t\t *\n\t\t * Since this is without lock semantics the protection is only\n\t\t * against code executing on this cpu *not* from access by\n\t\t * other cpus.\n\t\t */\n\t\tif (unlikely(!this_cpu_cmpxchg_double(\n\t\t\t\ts->cpu_slab->freelist, s->cpu_slab->tid,\n\t\t\t\tobject, tid,\n\t\t\t\tnext_object, next_tid(tid)))) {\n\n\t\t\tnote_cmpxchg_failure(\"slab_alloc\", s, tid);\n\t\t\tgoto redo;\n\t\t}\n\t\tprefetch_freepointer(s, next_object);\n\t\tstat(s, ALLOC_FASTPATH);\n\t}\n\n\tif (unlikely(gfpflags & __GFP_ZERO) && object)\n\t\tmemset(object, 0, s->object_size);\n\n\tslab_post_alloc_hook(s, gfpflags, 1, &object);\n\n\treturn object;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);\n\nstatic __always_inline void *slab_alloc_node(struct kmem_cache *s,\n\t\tgfp_t gfpflags, int node, unsigned long addr)\n{\n\tvoid *object;\n\tstruct kmem_cache_cpu *c;\n\tstruct page *page;\n\tunsigned long tid;\n\n\ts = slab_pre_alloc_hook(s, gfpflags);\n\tif (!s)\n\t\treturn NULL;\nredo:\n\t/*\n\t * Must read kmem_cache cpu data via this cpu ptr. Preemption is\n\t * enabled. We may switch back and forth between cpus while\n\t * reading from one cpu area. That does not matter as long\n\t * as we end up on the original cpu again when doing the cmpxchg.\n\t *\n\t * We should guarantee that tid and kmem_cache are retrieved on\n\t * the same cpu. It could be different if CONFIG_PREEMPT so we need\n\t * to check if it is matched or not.\n\t */\n\tdo {\n\t\ttid = this_cpu_read(s->cpu_slab->tid);\n\t\tc = raw_cpu_ptr(s->cpu_slab);\n\t} while (IS_ENABLED(CONFIG_PREEMPT) &&\n\t\t unlikely(tid != READ_ONCE(c->tid)));\n\n\t/*\n\t * Irqless object alloc/free algorithm used here depends on sequence\n\t * of fetching cpu_slab's data. tid should be fetched before anything\n\t * on c to guarantee that object and page associated with previous tid\n\t * won't be used with current tid. If we fetch tid first, object and\n\t * page could be one associated with next tid and our alloc/free\n\t * request will be failed. In this case, we will retry. So, no problem.\n\t */\n\tbarrier();\n\n\t/*\n\t * The transaction ids are globally unique per cpu and per operation on\n\t * a per cpu queue. Thus they can be guarantee that the cmpxchg_double\n\t * occurs on the right processor and that there was no operation on the\n\t * linked list in between.\n\t */\n\n\tobject = c->freelist;\n\tpage = c->page;\n\tif (unlikely(!object || !node_match(page, node))) {\n\t\tobject = __slab_alloc(s, gfpflags, node, addr, c);\n\t\tstat(s, ALLOC_SLOWPATH);\n\t} else {\n\t\tvoid *next_object = get_freepointer_safe(s, object);\n\n\t\t/*\n\t\t * The cmpxchg will only match if there was no additional\n\t\t * operation and if we are on the right processor.\n\t\t *\n\t\t * The cmpxchg does the following atomically (without lock\n\t\t * semantics!)\n\t\t * 1. Relocate first pointer to the current per cpu area.\n\t\t * 2. Verify that tid and freelist have not been changed\n\t\t * 3. If they were not changed replace tid and freelist\n\t\t *\n\t\t * Since this is without lock semantics the protection is only\n\t\t * against code executing on this cpu *not* from access by\n\t\t * other cpus.\n\t\t */\n\t\tif (unlikely(!this_cpu_cmpxchg_double(\n\t\t\t\ts->cpu_slab->freelist, s->cpu_slab->tid,\n\t\t\t\tobject, tid,\n\t\t\t\tnext_object, next_tid(tid)))) {\n\n\t\t\tnote_cmpxchg_failure(\"slab_alloc\", s, tid);\n\t\t\tgoto redo;\n\t\t}\n\t\tprefetch_freepointer(s, next_object);\n\t\tstat(s, ALLOC_FASTPATH);\n\t}\n\n\tif (unlikely(gfpflags & __GFP_ZERO) && object)\n\t\tmemset(object, 0, s->object_size);\n\n\tslab_post_alloc_hook(s, gfpflags, 1, &object);\n\n\treturn object;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);\n\nvoid *kmem_cache_alloc_node(struct kmem_cache *s, gfp_t gfpflags, int node)\n{\n\tvoid *ret = slab_alloc_node(s, gfpflags, node, _RET_IP_);\n\n\ttrace_kmem_cache_alloc_node(_RET_IP_, ret,\n\t\t\t\t    s->object_size, s->size, gfpflags, node);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "kmem_cache_alloc_trace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "2767-2773",
    "snippet": "void *kmem_cache_alloc_trace(struct kmem_cache *s, gfp_t gfpflags, size_t size)\n{\n\tvoid *ret = slab_alloc(s, gfpflags, _RET_IP_);\n\ttrace_kmalloc(_RET_IP_, ret, size, s->size, gfpflags);\n\tkasan_kmalloc(s, ret, size, gfpflags);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kasan_kmalloc",
          "args": [
            "s",
            "ret",
            "size",
            "gfpflags"
          ],
          "line": 2771
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "531-554",
          "snippet": "void kasan_kmalloc(struct kmem_cache *cache, const void *object, size_t size,\n\t\t   gfp_t flags)\n{\n\tunsigned long redzone_start;\n\tunsigned long redzone_end;\n\n\tif (gfpflags_allow_blocking(flags))\n\t\tquarantine_reduce();\n\n\tif (unlikely(object == NULL))\n\t\treturn;\n\n\tredzone_start = round_up((unsigned long)(object + size),\n\t\t\t\tKASAN_SHADOW_SCALE_SIZE);\n\tredzone_end = round_up((unsigned long)object + cache->object_size,\n\t\t\t\tKASAN_SHADOW_SCALE_SIZE);\n\n\tkasan_unpoison_shadow(object, size);\n\tkasan_poison_shadow((void *)redzone_start, redzone_end - redzone_start,\n\t\tKASAN_KMALLOC_REDZONE);\n\n\tif (cache->flags & SLAB_KASAN)\n\t\tset_track(&get_alloc_info(cache, object)->alloc_track, flags);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid kasan_kmalloc(struct kmem_cache *cache, const void *object, size_t size,\n\t\t   gfp_t flags)\n{\n\tunsigned long redzone_start;\n\tunsigned long redzone_end;\n\n\tif (gfpflags_allow_blocking(flags))\n\t\tquarantine_reduce();\n\n\tif (unlikely(object == NULL))\n\t\treturn;\n\n\tredzone_start = round_up((unsigned long)(object + size),\n\t\t\t\tKASAN_SHADOW_SCALE_SIZE);\n\tredzone_end = round_up((unsigned long)object + cache->object_size,\n\t\t\t\tKASAN_SHADOW_SCALE_SIZE);\n\n\tkasan_unpoison_shadow(object, size);\n\tkasan_poison_shadow((void *)redzone_start, redzone_end - redzone_start,\n\t\tKASAN_KMALLOC_REDZONE);\n\n\tif (cache->flags & SLAB_KASAN)\n\t\tset_track(&get_alloc_info(cache, object)->alloc_track, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kmalloc",
          "args": [
            "_RET_IP_",
            "ret",
            "size",
            "s->size",
            "gfpflags"
          ],
          "line": 2770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_alloc",
          "args": [
            "s",
            "gfpflags",
            "_RET_IP_"
          ],
          "line": 2769
        },
        "resolved": true,
        "details": {
          "function_name": "slab_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2749-2753",
          "snippet": "static __always_inline void *slab_alloc(struct kmem_cache *s,\n\t\tgfp_t gfpflags, unsigned long addr)\n{\n\treturn slab_alloc_node(s, gfpflags, NUMA_NO_NODE, addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);\n\nstatic __always_inline void *slab_alloc(struct kmem_cache *s,\n\t\tgfp_t gfpflags, unsigned long addr)\n{\n\treturn slab_alloc_node(s, gfpflags, NUMA_NO_NODE, addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);\n\nvoid *kmem_cache_alloc_trace(struct kmem_cache *s, gfp_t gfpflags, size_t size)\n{\n\tvoid *ret = slab_alloc(s, gfpflags, _RET_IP_);\n\ttrace_kmalloc(_RET_IP_, ret, size, s->size, gfpflags);\n\tkasan_kmalloc(s, ret, size, gfpflags);\n\treturn ret;\n}"
  },
  {
    "function_name": "kmem_cache_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "2755-2763",
    "snippet": "void *kmem_cache_alloc(struct kmem_cache *s, gfp_t gfpflags)\n{\n\tvoid *ret = slab_alloc(s, gfpflags, _RET_IP_);\n\n\ttrace_kmem_cache_alloc(_RET_IP_, ret, s->object_size,\n\t\t\t\ts->size, gfpflags);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kmem_cache_alloc",
          "args": [
            "_RET_IP_",
            "ret",
            "s->object_size",
            "s->size",
            "gfpflags"
          ],
          "line": 2759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_alloc",
          "args": [
            "s",
            "gfpflags",
            "_RET_IP_"
          ],
          "line": 2757
        },
        "resolved": true,
        "details": {
          "function_name": "slab_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2749-2753",
          "snippet": "static __always_inline void *slab_alloc(struct kmem_cache *s,\n\t\tgfp_t gfpflags, unsigned long addr)\n{\n\treturn slab_alloc_node(s, gfpflags, NUMA_NO_NODE, addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);\n\nstatic __always_inline void *slab_alloc(struct kmem_cache *s,\n\t\tgfp_t gfpflags, unsigned long addr)\n{\n\treturn slab_alloc_node(s, gfpflags, NUMA_NO_NODE, addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);\n\nvoid *kmem_cache_alloc(struct kmem_cache *s, gfp_t gfpflags)\n{\n\tvoid *ret = slab_alloc(s, gfpflags, _RET_IP_);\n\n\ttrace_kmem_cache_alloc(_RET_IP_, ret, s->object_size,\n\t\t\t\ts->size, gfpflags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "slab_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "2749-2753",
    "snippet": "static __always_inline void *slab_alloc(struct kmem_cache *s,\n\t\tgfp_t gfpflags, unsigned long addr)\n{\n\treturn slab_alloc_node(s, gfpflags, NUMA_NO_NODE, addr);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slab_alloc_node",
          "args": [
            "s",
            "gfpflags",
            "NUMA_NO_NODE",
            "addr"
          ],
          "line": 2752
        },
        "resolved": true,
        "details": {
          "function_name": "slab_alloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2662-2747",
          "snippet": "static __always_inline void *slab_alloc_node(struct kmem_cache *s,\n\t\tgfp_t gfpflags, int node, unsigned long addr)\n{\n\tvoid *object;\n\tstruct kmem_cache_cpu *c;\n\tstruct page *page;\n\tunsigned long tid;\n\n\ts = slab_pre_alloc_hook(s, gfpflags);\n\tif (!s)\n\t\treturn NULL;\nredo:\n\t/*\n\t * Must read kmem_cache cpu data via this cpu ptr. Preemption is\n\t * enabled. We may switch back and forth between cpus while\n\t * reading from one cpu area. That does not matter as long\n\t * as we end up on the original cpu again when doing the cmpxchg.\n\t *\n\t * We should guarantee that tid and kmem_cache are retrieved on\n\t * the same cpu. It could be different if CONFIG_PREEMPT so we need\n\t * to check if it is matched or not.\n\t */\n\tdo {\n\t\ttid = this_cpu_read(s->cpu_slab->tid);\n\t\tc = raw_cpu_ptr(s->cpu_slab);\n\t} while (IS_ENABLED(CONFIG_PREEMPT) &&\n\t\t unlikely(tid != READ_ONCE(c->tid)));\n\n\t/*\n\t * Irqless object alloc/free algorithm used here depends on sequence\n\t * of fetching cpu_slab's data. tid should be fetched before anything\n\t * on c to guarantee that object and page associated with previous tid\n\t * won't be used with current tid. If we fetch tid first, object and\n\t * page could be one associated with next tid and our alloc/free\n\t * request will be failed. In this case, we will retry. So, no problem.\n\t */\n\tbarrier();\n\n\t/*\n\t * The transaction ids are globally unique per cpu and per operation on\n\t * a per cpu queue. Thus they can be guarantee that the cmpxchg_double\n\t * occurs on the right processor and that there was no operation on the\n\t * linked list in between.\n\t */\n\n\tobject = c->freelist;\n\tpage = c->page;\n\tif (unlikely(!object || !node_match(page, node))) {\n\t\tobject = __slab_alloc(s, gfpflags, node, addr, c);\n\t\tstat(s, ALLOC_SLOWPATH);\n\t} else {\n\t\tvoid *next_object = get_freepointer_safe(s, object);\n\n\t\t/*\n\t\t * The cmpxchg will only match if there was no additional\n\t\t * operation and if we are on the right processor.\n\t\t *\n\t\t * The cmpxchg does the following atomically (without lock\n\t\t * semantics!)\n\t\t * 1. Relocate first pointer to the current per cpu area.\n\t\t * 2. Verify that tid and freelist have not been changed\n\t\t * 3. If they were not changed replace tid and freelist\n\t\t *\n\t\t * Since this is without lock semantics the protection is only\n\t\t * against code executing on this cpu *not* from access by\n\t\t * other cpus.\n\t\t */\n\t\tif (unlikely(!this_cpu_cmpxchg_double(\n\t\t\t\ts->cpu_slab->freelist, s->cpu_slab->tid,\n\t\t\t\tobject, tid,\n\t\t\t\tnext_object, next_tid(tid)))) {\n\n\t\t\tnote_cmpxchg_failure(\"slab_alloc\", s, tid);\n\t\t\tgoto redo;\n\t\t}\n\t\tprefetch_freepointer(s, next_object);\n\t\tstat(s, ALLOC_FASTPATH);\n\t}\n\n\tif (unlikely(gfpflags & __GFP_ZERO) && object)\n\t\tmemset(object, 0, s->object_size);\n\n\tslab_post_alloc_hook(s, gfpflags, 1, &object);\n\n\treturn object;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);\n\nstatic __always_inline void *slab_alloc_node(struct kmem_cache *s,\n\t\tgfp_t gfpflags, int node, unsigned long addr)\n{\n\tvoid *object;\n\tstruct kmem_cache_cpu *c;\n\tstruct page *page;\n\tunsigned long tid;\n\n\ts = slab_pre_alloc_hook(s, gfpflags);\n\tif (!s)\n\t\treturn NULL;\nredo:\n\t/*\n\t * Must read kmem_cache cpu data via this cpu ptr. Preemption is\n\t * enabled. We may switch back and forth between cpus while\n\t * reading from one cpu area. That does not matter as long\n\t * as we end up on the original cpu again when doing the cmpxchg.\n\t *\n\t * We should guarantee that tid and kmem_cache are retrieved on\n\t * the same cpu. It could be different if CONFIG_PREEMPT so we need\n\t * to check if it is matched or not.\n\t */\n\tdo {\n\t\ttid = this_cpu_read(s->cpu_slab->tid);\n\t\tc = raw_cpu_ptr(s->cpu_slab);\n\t} while (IS_ENABLED(CONFIG_PREEMPT) &&\n\t\t unlikely(tid != READ_ONCE(c->tid)));\n\n\t/*\n\t * Irqless object alloc/free algorithm used here depends on sequence\n\t * of fetching cpu_slab's data. tid should be fetched before anything\n\t * on c to guarantee that object and page associated with previous tid\n\t * won't be used with current tid. If we fetch tid first, object and\n\t * page could be one associated with next tid and our alloc/free\n\t * request will be failed. In this case, we will retry. So, no problem.\n\t */\n\tbarrier();\n\n\t/*\n\t * The transaction ids are globally unique per cpu and per operation on\n\t * a per cpu queue. Thus they can be guarantee that the cmpxchg_double\n\t * occurs on the right processor and that there was no operation on the\n\t * linked list in between.\n\t */\n\n\tobject = c->freelist;\n\tpage = c->page;\n\tif (unlikely(!object || !node_match(page, node))) {\n\t\tobject = __slab_alloc(s, gfpflags, node, addr, c);\n\t\tstat(s, ALLOC_SLOWPATH);\n\t} else {\n\t\tvoid *next_object = get_freepointer_safe(s, object);\n\n\t\t/*\n\t\t * The cmpxchg will only match if there was no additional\n\t\t * operation and if we are on the right processor.\n\t\t *\n\t\t * The cmpxchg does the following atomically (without lock\n\t\t * semantics!)\n\t\t * 1. Relocate first pointer to the current per cpu area.\n\t\t * 2. Verify that tid and freelist have not been changed\n\t\t * 3. If they were not changed replace tid and freelist\n\t\t *\n\t\t * Since this is without lock semantics the protection is only\n\t\t * against code executing on this cpu *not* from access by\n\t\t * other cpus.\n\t\t */\n\t\tif (unlikely(!this_cpu_cmpxchg_double(\n\t\t\t\ts->cpu_slab->freelist, s->cpu_slab->tid,\n\t\t\t\tobject, tid,\n\t\t\t\tnext_object, next_tid(tid)))) {\n\n\t\t\tnote_cmpxchg_failure(\"slab_alloc\", s, tid);\n\t\t\tgoto redo;\n\t\t}\n\t\tprefetch_freepointer(s, next_object);\n\t\tstat(s, ALLOC_FASTPATH);\n\t}\n\n\tif (unlikely(gfpflags & __GFP_ZERO) && object)\n\t\tmemset(object, 0, s->object_size);\n\n\tslab_post_alloc_hook(s, gfpflags, 1, &object);\n\n\treturn object;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);\n\nstatic __always_inline void *slab_alloc(struct kmem_cache *s,\n\t\tgfp_t gfpflags, unsigned long addr)\n{\n\treturn slab_alloc_node(s, gfpflags, NUMA_NO_NODE, addr);\n}"
  },
  {
    "function_name": "slab_alloc_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "2662-2747",
    "snippet": "static __always_inline void *slab_alloc_node(struct kmem_cache *s,\n\t\tgfp_t gfpflags, int node, unsigned long addr)\n{\n\tvoid *object;\n\tstruct kmem_cache_cpu *c;\n\tstruct page *page;\n\tunsigned long tid;\n\n\ts = slab_pre_alloc_hook(s, gfpflags);\n\tif (!s)\n\t\treturn NULL;\nredo:\n\t/*\n\t * Must read kmem_cache cpu data via this cpu ptr. Preemption is\n\t * enabled. We may switch back and forth between cpus while\n\t * reading from one cpu area. That does not matter as long\n\t * as we end up on the original cpu again when doing the cmpxchg.\n\t *\n\t * We should guarantee that tid and kmem_cache are retrieved on\n\t * the same cpu. It could be different if CONFIG_PREEMPT so we need\n\t * to check if it is matched or not.\n\t */\n\tdo {\n\t\ttid = this_cpu_read(s->cpu_slab->tid);\n\t\tc = raw_cpu_ptr(s->cpu_slab);\n\t} while (IS_ENABLED(CONFIG_PREEMPT) &&\n\t\t unlikely(tid != READ_ONCE(c->tid)));\n\n\t/*\n\t * Irqless object alloc/free algorithm used here depends on sequence\n\t * of fetching cpu_slab's data. tid should be fetched before anything\n\t * on c to guarantee that object and page associated with previous tid\n\t * won't be used with current tid. If we fetch tid first, object and\n\t * page could be one associated with next tid and our alloc/free\n\t * request will be failed. In this case, we will retry. So, no problem.\n\t */\n\tbarrier();\n\n\t/*\n\t * The transaction ids are globally unique per cpu and per operation on\n\t * a per cpu queue. Thus they can be guarantee that the cmpxchg_double\n\t * occurs on the right processor and that there was no operation on the\n\t * linked list in between.\n\t */\n\n\tobject = c->freelist;\n\tpage = c->page;\n\tif (unlikely(!object || !node_match(page, node))) {\n\t\tobject = __slab_alloc(s, gfpflags, node, addr, c);\n\t\tstat(s, ALLOC_SLOWPATH);\n\t} else {\n\t\tvoid *next_object = get_freepointer_safe(s, object);\n\n\t\t/*\n\t\t * The cmpxchg will only match if there was no additional\n\t\t * operation and if we are on the right processor.\n\t\t *\n\t\t * The cmpxchg does the following atomically (without lock\n\t\t * semantics!)\n\t\t * 1. Relocate first pointer to the current per cpu area.\n\t\t * 2. Verify that tid and freelist have not been changed\n\t\t * 3. If they were not changed replace tid and freelist\n\t\t *\n\t\t * Since this is without lock semantics the protection is only\n\t\t * against code executing on this cpu *not* from access by\n\t\t * other cpus.\n\t\t */\n\t\tif (unlikely(!this_cpu_cmpxchg_double(\n\t\t\t\ts->cpu_slab->freelist, s->cpu_slab->tid,\n\t\t\t\tobject, tid,\n\t\t\t\tnext_object, next_tid(tid)))) {\n\n\t\t\tnote_cmpxchg_failure(\"slab_alloc\", s, tid);\n\t\t\tgoto redo;\n\t\t}\n\t\tprefetch_freepointer(s, next_object);\n\t\tstat(s, ALLOC_FASTPATH);\n\t}\n\n\tif (unlikely(gfpflags & __GFP_ZERO) && object)\n\t\tmemset(object, 0, s->object_size);\n\n\tslab_post_alloc_hook(s, gfpflags, 1, &object);\n\n\treturn object;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slab_post_alloc_hook",
          "args": [
            "s",
            "gfpflags",
            "1",
            "&object"
          ],
          "line": 2744
        },
        "resolved": true,
        "details": {
          "function_name": "slab_post_alloc_hook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "433-449",
          "snippet": "static inline void slab_post_alloc_hook(struct kmem_cache *s, gfp_t flags,\n\t\t\t\t\tsize_t size, void **p)\n{\n\tsize_t i;\n\n\tflags &= gfp_allowed_mask;\n\tfor (i = 0; i < size; i++) {\n\t\tvoid *object = p[i];\n\n\t\tkmemleak_alloc_recursive(object, s->object_size, 1,\n\t\t\t\t\t s->flags, flags);\n\t\tkasan_slab_alloc(s, object, flags);\n\t}\n\n\tif (memcg_kmem_enabled())\n\t\tmemcg_kmem_put_cache(s);\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline void slab_post_alloc_hook(struct kmem_cache *s, gfp_t flags,\n\t\t\t\t\tsize_t size, void **p)\n{\n\tsize_t i;\n\n\tflags &= gfp_allowed_mask;\n\tfor (i = 0; i < size; i++) {\n\t\tvoid *object = p[i];\n\n\t\tkmemleak_alloc_recursive(object, s->object_size, 1,\n\t\t\t\t\t s->flags, flags);\n\t\tkasan_slab_alloc(s, object, flags);\n\t}\n\n\tif (memcg_kmem_enabled())\n\t\tmemcg_kmem_put_cache(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "object",
            "0",
            "s->object_size"
          ],
          "line": 2742
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "gfpflags & __GFP_ZERO"
          ],
          "line": 2741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "s",
            "ALLOC_FASTPATH"
          ],
          "line": 2738
        },
        "resolved": true,
        "details": {
          "function_name": "slabinfo_show_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "5900-5902",
          "snippet": "void slabinfo_show_stats(struct seq_file *m, struct kmem_cache *s)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid slabinfo_show_stats(struct seq_file *m, struct kmem_cache *s)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "prefetch_freepointer",
          "args": [
            "s",
            "next_object"
          ],
          "line": 2737
        },
        "resolved": true,
        "details": {
          "function_name": "prefetch_freepointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "271-274",
          "snippet": "static void prefetch_freepointer(const struct kmem_cache *s, void *object)\n{\n\tprefetch(object + s->offset);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void prefetch_freepointer(const struct kmem_cache *s, void *object)\n{\n\tprefetch(object + s->offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "note_cmpxchg_failure",
          "args": [
            "\"slab_alloc\"",
            "s",
            "tid"
          ],
          "line": 2734
        },
        "resolved": true,
        "details": {
          "function_name": "note_cmpxchg_failure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1992-2014",
          "snippet": "static inline void note_cmpxchg_failure(const char *n,\n\t\tconst struct kmem_cache *s, unsigned long tid)\n{\n#ifdef SLUB_DEBUG_CMPXCHG\n\tunsigned long actual_tid = __this_cpu_read(s->cpu_slab->tid);\n\n\tpr_info(\"%s %s: cmpxchg redo \", n, s->name);\n\n#ifdef CONFIG_PREEMPT\n\tif (tid_to_cpu(tid) != tid_to_cpu(actual_tid))\n\t\tpr_warn(\"due to cpu change %d -> %d\\n\",\n\t\t\ttid_to_cpu(tid), tid_to_cpu(actual_tid));\n\telse\n#endif\n\tif (tid_to_event(tid) != tid_to_event(actual_tid))\n\t\tpr_warn(\"due to cpu running other code. Event %ld->%ld\\n\",\n\t\t\ttid_to_event(tid), tid_to_event(actual_tid));\n\telse\n\t\tpr_warn(\"for unknown reason: actual=%lx was=%lx target=%lx\\n\",\n\t\t\tactual_tid, tid, next_tid(tid));\n#endif\n\tstat(s, CMPXCHG_DOUBLE_CPU_FAIL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void note_cmpxchg_failure(const char *n,\n\t\tconst struct kmem_cache *s, unsigned long tid)\n{\n#ifdef SLUB_DEBUG_CMPXCHG\n\tunsigned long actual_tid = __this_cpu_read(s->cpu_slab->tid);\n\n\tpr_info(\"%s %s: cmpxchg redo \", n, s->name);\n\n#ifdef CONFIG_PREEMPT\n\tif (tid_to_cpu(tid) != tid_to_cpu(actual_tid))\n\t\tpr_warn(\"due to cpu change %d -> %d\\n\",\n\t\t\ttid_to_cpu(tid), tid_to_cpu(actual_tid));\n\telse\n#endif\n\tif (tid_to_event(tid) != tid_to_event(actual_tid))\n\t\tpr_warn(\"due to cpu running other code. Event %ld->%ld\\n\",\n\t\t\ttid_to_event(tid), tid_to_event(actual_tid));\n\telse\n\t\tpr_warn(\"for unknown reason: actual=%lx was=%lx target=%lx\\n\",\n\t\t\tactual_tid, tid, next_tid(tid));\n#endif\n\tstat(s, CMPXCHG_DOUBLE_CPU_FAIL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!this_cpu_cmpxchg_double(\n\t\t\t\ts->cpu_slab->freelist, s->cpu_slab->tid,\n\t\t\t\tobject, tid,\n\t\t\t\tnext_object, next_tid(tid))"
          ],
          "line": 2729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_cmpxchg_double",
          "args": [
            "s->cpu_slab->freelist",
            "s->cpu_slab->tid",
            "object",
            "tid",
            "next_object",
            "next_tid(tid)"
          ],
          "line": 2729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_tid",
          "args": [
            "tid"
          ],
          "line": 2732
        },
        "resolved": true,
        "details": {
          "function_name": "next_tid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1972-1975",
          "snippet": "static inline unsigned long next_tid(unsigned long tid)\n{\n\treturn tid + TID_STEP;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define TID_STEP 1",
            "#define TID_STEP  roundup_pow_of_two(CONFIG_NR_CPUS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define TID_STEP 1\n#define TID_STEP  roundup_pow_of_two(CONFIG_NR_CPUS)\n\nstatic inline unsigned long next_tid(unsigned long tid)\n{\n\treturn tid + TID_STEP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_freepointer_safe",
          "args": [
            "s",
            "object"
          ],
          "line": 2713
        },
        "resolved": true,
        "details": {
          "function_name": "get_freepointer_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "276-287",
          "snippet": "static inline void *get_freepointer_safe(struct kmem_cache *s, void *object)\n{\n\tunsigned long freepointer_addr;\n\tvoid *p;\n\n\tif (!debug_pagealloc_enabled())\n\t\treturn get_freepointer(s, object);\n\n\tfreepointer_addr = (unsigned long)object + s->offset;\n\tprobe_kernel_read(&p, (void **)freepointer_addr, sizeof(p));\n\treturn freelist_ptr(s, p, freepointer_addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void *get_freepointer_safe(struct kmem_cache *s, void *object)\n{\n\tunsigned long freepointer_addr;\n\tvoid *p;\n\n\tif (!debug_pagealloc_enabled())\n\t\treturn get_freepointer(s, object);\n\n\tfreepointer_addr = (unsigned long)object + s->offset;\n\tprobe_kernel_read(&p, (void **)freepointer_addr, sizeof(p));\n\treturn freelist_ptr(s, p, freepointer_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__slab_alloc",
          "args": [
            "s",
            "gfpflags",
            "node",
            "addr",
            "c"
          ],
          "line": 2710
        },
        "resolved": true,
        "details": {
          "function_name": "__slab_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2631-2650",
          "snippet": "static void *__slab_alloc(struct kmem_cache *s, gfp_t gfpflags, int node,\n\t\t\t  unsigned long addr, struct kmem_cache_cpu *c)\n{\n\tvoid *p;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n#ifdef CONFIG_PREEMPT\n\t/*\n\t * We may have been preempted and rescheduled on a different\n\t * cpu before disabling interrupts. Need to reload cpu area\n\t * pointer.\n\t */\n\tc = this_cpu_ptr(s->cpu_slab);\n#endif\n\n\tp = ___slab_alloc(s, gfpflags, node, addr, c);\n\tlocal_irq_restore(flags);\n\treturn p;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);\n\nstatic void *__slab_alloc(struct kmem_cache *s, gfp_t gfpflags, int node,\n\t\t\t  unsigned long addr, struct kmem_cache_cpu *c)\n{\n\tvoid *p;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n#ifdef CONFIG_PREEMPT\n\t/*\n\t * We may have been preempted and rescheduled on a different\n\t * cpu before disabling interrupts. Need to reload cpu area\n\t * pointer.\n\t */\n\tc = this_cpu_ptr(s->cpu_slab);\n#endif\n\n\tp = ___slab_alloc(s, gfpflags, node, addr, c);\n\tlocal_irq_restore(flags);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!object || !node_match(page, node)"
          ],
          "line": 2709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_match",
          "args": [
            "page",
            "node"
          ],
          "line": 2709
        },
        "resolved": true,
        "details": {
          "function_name": "node_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2367-2374",
          "snippet": "static inline int node_match(struct page *page, int node)\n{\n#ifdef CONFIG_NUMA\n\tif (!page || (node != NUMA_NO_NODE && page_to_nid(page) != node))\n\t\treturn 0;\n#endif\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline int node_match(struct page *page, int node)\n{\n#ifdef CONFIG_NUMA\n\tif (!page || (node != NUMA_NO_NODE && page_to_nid(page) != node))\n\t\treturn 0;\n#endif\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 2698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "tid != READ_ONCE(c->tid)"
          ],
          "line": 2688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "c->tid"
          ],
          "line": 2688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PREEMPT"
          ],
          "line": 2687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_cpu_ptr",
          "args": [
            "s->cpu_slab"
          ],
          "line": 2686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_read",
          "args": [
            "s->cpu_slab->tid"
          ],
          "line": 2685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_pre_alloc_hook",
          "args": [
            "s",
            "gfpflags"
          ],
          "line": 2670
        },
        "resolved": true,
        "details": {
          "function_name": "slab_pre_alloc_hook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "413-431",
          "snippet": "static inline struct kmem_cache *slab_pre_alloc_hook(struct kmem_cache *s,\n\t\t\t\t\t\t     gfp_t flags)\n{\n\tflags &= gfp_allowed_mask;\n\n\tfs_reclaim_acquire(flags);\n\tfs_reclaim_release(flags);\n\n\tmight_sleep_if(gfpflags_allow_blocking(flags));\n\n\tif (should_failslab(s, flags))\n\t\treturn NULL;\n\n\tif (memcg_kmem_enabled() &&\n\t    ((flags & __GFP_ACCOUNT) || (s->flags & SLAB_ACCOUNT)))\n\t\treturn memcg_kmem_get_cache(s);\n\n\treturn s;\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache *slab_pre_alloc_hook(struct kmem_cache *s,\n\t\t\t\t\t\t     gfp_t flags)\n{\n\tflags &= gfp_allowed_mask;\n\n\tfs_reclaim_acquire(flags);\n\tfs_reclaim_release(flags);\n\n\tmight_sleep_if(gfpflags_allow_blocking(flags));\n\n\tif (should_failslab(s, flags))\n\t\treturn NULL;\n\n\tif (memcg_kmem_enabled() &&\n\t    ((flags & __GFP_ACCOUNT) || (s->flags & SLAB_ACCOUNT)))\n\t\treturn memcg_kmem_get_cache(s);\n\n\treturn s;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);\n\nstatic __always_inline void *slab_alloc_node(struct kmem_cache *s,\n\t\tgfp_t gfpflags, int node, unsigned long addr)\n{\n\tvoid *object;\n\tstruct kmem_cache_cpu *c;\n\tstruct page *page;\n\tunsigned long tid;\n\n\ts = slab_pre_alloc_hook(s, gfpflags);\n\tif (!s)\n\t\treturn NULL;\nredo:\n\t/*\n\t * Must read kmem_cache cpu data via this cpu ptr. Preemption is\n\t * enabled. We may switch back and forth between cpus while\n\t * reading from one cpu area. That does not matter as long\n\t * as we end up on the original cpu again when doing the cmpxchg.\n\t *\n\t * We should guarantee that tid and kmem_cache are retrieved on\n\t * the same cpu. It could be different if CONFIG_PREEMPT so we need\n\t * to check if it is matched or not.\n\t */\n\tdo {\n\t\ttid = this_cpu_read(s->cpu_slab->tid);\n\t\tc = raw_cpu_ptr(s->cpu_slab);\n\t} while (IS_ENABLED(CONFIG_PREEMPT) &&\n\t\t unlikely(tid != READ_ONCE(c->tid)));\n\n\t/*\n\t * Irqless object alloc/free algorithm used here depends on sequence\n\t * of fetching cpu_slab's data. tid should be fetched before anything\n\t * on c to guarantee that object and page associated with previous tid\n\t * won't be used with current tid. If we fetch tid first, object and\n\t * page could be one associated with next tid and our alloc/free\n\t * request will be failed. In this case, we will retry. So, no problem.\n\t */\n\tbarrier();\n\n\t/*\n\t * The transaction ids are globally unique per cpu and per operation on\n\t * a per cpu queue. Thus they can be guarantee that the cmpxchg_double\n\t * occurs on the right processor and that there was no operation on the\n\t * linked list in between.\n\t */\n\n\tobject = c->freelist;\n\tpage = c->page;\n\tif (unlikely(!object || !node_match(page, node))) {\n\t\tobject = __slab_alloc(s, gfpflags, node, addr, c);\n\t\tstat(s, ALLOC_SLOWPATH);\n\t} else {\n\t\tvoid *next_object = get_freepointer_safe(s, object);\n\n\t\t/*\n\t\t * The cmpxchg will only match if there was no additional\n\t\t * operation and if we are on the right processor.\n\t\t *\n\t\t * The cmpxchg does the following atomically (without lock\n\t\t * semantics!)\n\t\t * 1. Relocate first pointer to the current per cpu area.\n\t\t * 2. Verify that tid and freelist have not been changed\n\t\t * 3. If they were not changed replace tid and freelist\n\t\t *\n\t\t * Since this is without lock semantics the protection is only\n\t\t * against code executing on this cpu *not* from access by\n\t\t * other cpus.\n\t\t */\n\t\tif (unlikely(!this_cpu_cmpxchg_double(\n\t\t\t\ts->cpu_slab->freelist, s->cpu_slab->tid,\n\t\t\t\tobject, tid,\n\t\t\t\tnext_object, next_tid(tid)))) {\n\n\t\t\tnote_cmpxchg_failure(\"slab_alloc\", s, tid);\n\t\t\tgoto redo;\n\t\t}\n\t\tprefetch_freepointer(s, next_object);\n\t\tstat(s, ALLOC_FASTPATH);\n\t}\n\n\tif (unlikely(gfpflags & __GFP_ZERO) && object)\n\t\tmemset(object, 0, s->object_size);\n\n\tslab_post_alloc_hook(s, gfpflags, 1, &object);\n\n\treturn object;\n}"
  },
  {
    "function_name": "__slab_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "2631-2650",
    "snippet": "static void *__slab_alloc(struct kmem_cache *s, gfp_t gfpflags, int node,\n\t\t\t  unsigned long addr, struct kmem_cache_cpu *c)\n{\n\tvoid *p;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n#ifdef CONFIG_PREEMPT\n\t/*\n\t * We may have been preempted and rescheduled on a different\n\t * cpu before disabling interrupts. Need to reload cpu area\n\t * pointer.\n\t */\n\tc = this_cpu_ptr(s->cpu_slab);\n#endif\n\n\tp = ___slab_alloc(s, gfpflags, node, addr, c);\n\tlocal_irq_restore(flags);\n\treturn p;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 2648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "___slab_alloc",
          "args": [
            "s",
            "gfpflags",
            "node",
            "addr",
            "c"
          ],
          "line": 2647
        },
        "resolved": true,
        "details": {
          "function_name": "___slab_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2538-2625",
          "snippet": "static void *___slab_alloc(struct kmem_cache *s, gfp_t gfpflags, int node,\n\t\t\t  unsigned long addr, struct kmem_cache_cpu *c)\n{\n\tvoid *freelist;\n\tstruct page *page;\n\n\tpage = c->page;\n\tif (!page)\n\t\tgoto new_slab;\nredo:\n\n\tif (unlikely(!node_match(page, node))) {\n\t\tint searchnode = node;\n\n\t\tif (node != NUMA_NO_NODE && !node_present_pages(node))\n\t\t\tsearchnode = node_to_mem_node(node);\n\n\t\tif (unlikely(!node_match(page, searchnode))) {\n\t\t\tstat(s, ALLOC_NODE_MISMATCH);\n\t\t\tdeactivate_slab(s, page, c->freelist, c);\n\t\t\tgoto new_slab;\n\t\t}\n\t}\n\n\t/*\n\t * By rights, we should be searching for a slab page that was\n\t * PFMEMALLOC but right now, we are losing the pfmemalloc\n\t * information when the page leaves the per-cpu allocator\n\t */\n\tif (unlikely(!pfmemalloc_match(page, gfpflags))) {\n\t\tdeactivate_slab(s, page, c->freelist, c);\n\t\tgoto new_slab;\n\t}\n\n\t/* must check again c->freelist in case of cpu migration or IRQ */\n\tfreelist = c->freelist;\n\tif (freelist)\n\t\tgoto load_freelist;\n\n\tfreelist = get_freelist(s, page);\n\n\tif (!freelist) {\n\t\tc->page = NULL;\n\t\tstat(s, DEACTIVATE_BYPASS);\n\t\tgoto new_slab;\n\t}\n\n\tstat(s, ALLOC_REFILL);\n\nload_freelist:\n\t/*\n\t * freelist is pointing to the list of objects to be used.\n\t * page is pointing to the page from which the objects are obtained.\n\t * That page must be frozen for per cpu allocations to work.\n\t */\n\tVM_BUG_ON(!c->page->frozen);\n\tc->freelist = get_freepointer(s, freelist);\n\tc->tid = next_tid(c->tid);\n\treturn freelist;\n\nnew_slab:\n\n\tif (slub_percpu_partial(c)) {\n\t\tpage = c->page = slub_percpu_partial(c);\n\t\tslub_set_percpu_partial(c, page);\n\t\tstat(s, CPU_PARTIAL_ALLOC);\n\t\tgoto redo;\n\t}\n\n\tfreelist = new_slab_objects(s, gfpflags, node, &c);\n\n\tif (unlikely(!freelist)) {\n\t\tslab_out_of_memory(s, gfpflags, node);\n\t\treturn NULL;\n\t}\n\n\tpage = c->page;\n\tif (likely(!kmem_cache_debug(s) && pfmemalloc_match(page, gfpflags)))\n\t\tgoto load_freelist;\n\n\t/* Only entered in the debug case */\n\tif (kmem_cache_debug(s) &&\n\t\t\t!alloc_debug_processing(s, page, freelist, addr))\n\t\tgoto new_slab;\t/* Slab failed checks. Next slab needed */\n\n\tdeactivate_slab(s, page, get_freepointer(s, freelist), c);\n\treturn freelist;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);\n\nstatic void *___slab_alloc(struct kmem_cache *s, gfp_t gfpflags, int node,\n\t\t\t  unsigned long addr, struct kmem_cache_cpu *c)\n{\n\tvoid *freelist;\n\tstruct page *page;\n\n\tpage = c->page;\n\tif (!page)\n\t\tgoto new_slab;\nredo:\n\n\tif (unlikely(!node_match(page, node))) {\n\t\tint searchnode = node;\n\n\t\tif (node != NUMA_NO_NODE && !node_present_pages(node))\n\t\t\tsearchnode = node_to_mem_node(node);\n\n\t\tif (unlikely(!node_match(page, searchnode))) {\n\t\t\tstat(s, ALLOC_NODE_MISMATCH);\n\t\t\tdeactivate_slab(s, page, c->freelist, c);\n\t\t\tgoto new_slab;\n\t\t}\n\t}\n\n\t/*\n\t * By rights, we should be searching for a slab page that was\n\t * PFMEMALLOC but right now, we are losing the pfmemalloc\n\t * information when the page leaves the per-cpu allocator\n\t */\n\tif (unlikely(!pfmemalloc_match(page, gfpflags))) {\n\t\tdeactivate_slab(s, page, c->freelist, c);\n\t\tgoto new_slab;\n\t}\n\n\t/* must check again c->freelist in case of cpu migration or IRQ */\n\tfreelist = c->freelist;\n\tif (freelist)\n\t\tgoto load_freelist;\n\n\tfreelist = get_freelist(s, page);\n\n\tif (!freelist) {\n\t\tc->page = NULL;\n\t\tstat(s, DEACTIVATE_BYPASS);\n\t\tgoto new_slab;\n\t}\n\n\tstat(s, ALLOC_REFILL);\n\nload_freelist:\n\t/*\n\t * freelist is pointing to the list of objects to be used.\n\t * page is pointing to the page from which the objects are obtained.\n\t * That page must be frozen for per cpu allocations to work.\n\t */\n\tVM_BUG_ON(!c->page->frozen);\n\tc->freelist = get_freepointer(s, freelist);\n\tc->tid = next_tid(c->tid);\n\treturn freelist;\n\nnew_slab:\n\n\tif (slub_percpu_partial(c)) {\n\t\tpage = c->page = slub_percpu_partial(c);\n\t\tslub_set_percpu_partial(c, page);\n\t\tstat(s, CPU_PARTIAL_ALLOC);\n\t\tgoto redo;\n\t}\n\n\tfreelist = new_slab_objects(s, gfpflags, node, &c);\n\n\tif (unlikely(!freelist)) {\n\t\tslab_out_of_memory(s, gfpflags, node);\n\t\treturn NULL;\n\t}\n\n\tpage = c->page;\n\tif (likely(!kmem_cache_debug(s) && pfmemalloc_match(page, gfpflags)))\n\t\tgoto load_freelist;\n\n\t/* Only entered in the debug case */\n\tif (kmem_cache_debug(s) &&\n\t\t\t!alloc_debug_processing(s, page, freelist, addr))\n\t\tgoto new_slab;\t/* Slab failed checks. Next slab needed */\n\n\tdeactivate_slab(s, page, get_freepointer(s, freelist), c);\n\treturn freelist;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "s->cpu_slab"
          ],
          "line": 2644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 2637
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);\n\nstatic void *__slab_alloc(struct kmem_cache *s, gfp_t gfpflags, int node,\n\t\t\t  unsigned long addr, struct kmem_cache_cpu *c)\n{\n\tvoid *p;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n#ifdef CONFIG_PREEMPT\n\t/*\n\t * We may have been preempted and rescheduled on a different\n\t * cpu before disabling interrupts. Need to reload cpu area\n\t * pointer.\n\t */\n\tc = this_cpu_ptr(s->cpu_slab);\n#endif\n\n\tp = ___slab_alloc(s, gfpflags, node, addr, c);\n\tlocal_irq_restore(flags);\n\treturn p;\n}"
  },
  {
    "function_name": "___slab_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "2538-2625",
    "snippet": "static void *___slab_alloc(struct kmem_cache *s, gfp_t gfpflags, int node,\n\t\t\t  unsigned long addr, struct kmem_cache_cpu *c)\n{\n\tvoid *freelist;\n\tstruct page *page;\n\n\tpage = c->page;\n\tif (!page)\n\t\tgoto new_slab;\nredo:\n\n\tif (unlikely(!node_match(page, node))) {\n\t\tint searchnode = node;\n\n\t\tif (node != NUMA_NO_NODE && !node_present_pages(node))\n\t\t\tsearchnode = node_to_mem_node(node);\n\n\t\tif (unlikely(!node_match(page, searchnode))) {\n\t\t\tstat(s, ALLOC_NODE_MISMATCH);\n\t\t\tdeactivate_slab(s, page, c->freelist, c);\n\t\t\tgoto new_slab;\n\t\t}\n\t}\n\n\t/*\n\t * By rights, we should be searching for a slab page that was\n\t * PFMEMALLOC but right now, we are losing the pfmemalloc\n\t * information when the page leaves the per-cpu allocator\n\t */\n\tif (unlikely(!pfmemalloc_match(page, gfpflags))) {\n\t\tdeactivate_slab(s, page, c->freelist, c);\n\t\tgoto new_slab;\n\t}\n\n\t/* must check again c->freelist in case of cpu migration or IRQ */\n\tfreelist = c->freelist;\n\tif (freelist)\n\t\tgoto load_freelist;\n\n\tfreelist = get_freelist(s, page);\n\n\tif (!freelist) {\n\t\tc->page = NULL;\n\t\tstat(s, DEACTIVATE_BYPASS);\n\t\tgoto new_slab;\n\t}\n\n\tstat(s, ALLOC_REFILL);\n\nload_freelist:\n\t/*\n\t * freelist is pointing to the list of objects to be used.\n\t * page is pointing to the page from which the objects are obtained.\n\t * That page must be frozen for per cpu allocations to work.\n\t */\n\tVM_BUG_ON(!c->page->frozen);\n\tc->freelist = get_freepointer(s, freelist);\n\tc->tid = next_tid(c->tid);\n\treturn freelist;\n\nnew_slab:\n\n\tif (slub_percpu_partial(c)) {\n\t\tpage = c->page = slub_percpu_partial(c);\n\t\tslub_set_percpu_partial(c, page);\n\t\tstat(s, CPU_PARTIAL_ALLOC);\n\t\tgoto redo;\n\t}\n\n\tfreelist = new_slab_objects(s, gfpflags, node, &c);\n\n\tif (unlikely(!freelist)) {\n\t\tslab_out_of_memory(s, gfpflags, node);\n\t\treturn NULL;\n\t}\n\n\tpage = c->page;\n\tif (likely(!kmem_cache_debug(s) && pfmemalloc_match(page, gfpflags)))\n\t\tgoto load_freelist;\n\n\t/* Only entered in the debug case */\n\tif (kmem_cache_debug(s) &&\n\t\t\t!alloc_debug_processing(s, page, freelist, addr))\n\t\tgoto new_slab;\t/* Slab failed checks. Next slab needed */\n\n\tdeactivate_slab(s, page, get_freepointer(s, freelist), c);\n\treturn freelist;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "deactivate_slab",
          "args": [
            "s",
            "page",
            "get_freepointer(s, freelist)",
            "c"
          ],
          "line": 2623
        },
        "resolved": true,
        "details": {
          "function_name": "deactivate_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2027-2170",
          "snippet": "static void deactivate_slab(struct kmem_cache *s, struct page *page,\n\t\t\t\tvoid *freelist, struct kmem_cache_cpu *c)\n{\n\tenum slab_modes { M_NONE, M_PARTIAL, M_FULL, M_FREE };\n\tstruct kmem_cache_node *n = get_node(s, page_to_nid(page));\n\tint lock = 0;\n\tenum slab_modes l = M_NONE, m = M_NONE;\n\tvoid *nextfree;\n\tint tail = DEACTIVATE_TO_HEAD;\n\tstruct page new;\n\tstruct page old;\n\n\tif (page->freelist) {\n\t\tstat(s, DEACTIVATE_REMOTE_FREES);\n\t\ttail = DEACTIVATE_TO_TAIL;\n\t}\n\n\t/*\n\t * Stage one: Free all available per cpu objects back\n\t * to the page freelist while it is still frozen. Leave the\n\t * last one.\n\t *\n\t * There is no need to take the list->lock because the page\n\t * is still frozen.\n\t */\n\twhile (freelist && (nextfree = get_freepointer(s, freelist))) {\n\t\tvoid *prior;\n\t\tunsigned long counters;\n\n\t\tdo {\n\t\t\tprior = page->freelist;\n\t\t\tcounters = page->counters;\n\t\t\tset_freepointer(s, freelist, prior);\n\t\t\tnew.counters = counters;\n\t\t\tnew.inuse--;\n\t\t\tVM_BUG_ON(!new.frozen);\n\n\t\t} while (!__cmpxchg_double_slab(s, page,\n\t\t\tprior, counters,\n\t\t\tfreelist, new.counters,\n\t\t\t\"drain percpu freelist\"));\n\n\t\tfreelist = nextfree;\n\t}\n\n\t/*\n\t * Stage two: Ensure that the page is unfrozen while the\n\t * list presence reflects the actual number of objects\n\t * during unfreeze.\n\t *\n\t * We setup the list membership and then perform a cmpxchg\n\t * with the count. If there is a mismatch then the page\n\t * is not unfrozen but the page is on the wrong list.\n\t *\n\t * Then we restart the process which may have to remove\n\t * the page from the list that we just put it on again\n\t * because the number of objects in the slab may have\n\t * changed.\n\t */\nredo:\n\n\told.freelist = page->freelist;\n\told.counters = page->counters;\n\tVM_BUG_ON(!old.frozen);\n\n\t/* Determine target state of the slab */\n\tnew.counters = old.counters;\n\tif (freelist) {\n\t\tnew.inuse--;\n\t\tset_freepointer(s, freelist, old.freelist);\n\t\tnew.freelist = freelist;\n\t} else\n\t\tnew.freelist = old.freelist;\n\n\tnew.frozen = 0;\n\n\tif (!new.inuse && n->nr_partial >= s->min_partial)\n\t\tm = M_FREE;\n\telse if (new.freelist) {\n\t\tm = M_PARTIAL;\n\t\tif (!lock) {\n\t\t\tlock = 1;\n\t\t\t/*\n\t\t\t * Taking the spinlock removes the possiblity\n\t\t\t * that acquire_slab() will see a slab page that\n\t\t\t * is frozen\n\t\t\t */\n\t\t\tspin_lock(&n->list_lock);\n\t\t}\n\t} else {\n\t\tm = M_FULL;\n\t\tif (kmem_cache_debug(s) && !lock) {\n\t\t\tlock = 1;\n\t\t\t/*\n\t\t\t * This also ensures that the scanning of full\n\t\t\t * slabs from diagnostic functions will not see\n\t\t\t * any frozen slabs.\n\t\t\t */\n\t\t\tspin_lock(&n->list_lock);\n\t\t}\n\t}\n\n\tif (l != m) {\n\n\t\tif (l == M_PARTIAL)\n\n\t\t\tremove_partial(n, page);\n\n\t\telse if (l == M_FULL)\n\n\t\t\tremove_full(s, n, page);\n\n\t\tif (m == M_PARTIAL) {\n\n\t\t\tadd_partial(n, page, tail);\n\t\t\tstat(s, tail);\n\n\t\t} else if (m == M_FULL) {\n\n\t\t\tstat(s, DEACTIVATE_FULL);\n\t\t\tadd_full(s, n, page);\n\n\t\t}\n\t}\n\n\tl = m;\n\tif (!__cmpxchg_double_slab(s, page,\n\t\t\t\told.freelist, old.counters,\n\t\t\t\tnew.freelist, new.counters,\n\t\t\t\t\"unfreezing slab\"))\n\t\tgoto redo;\n\n\tif (lock)\n\t\tspin_unlock(&n->list_lock);\n\n\tif (m == M_FREE) {\n\t\tstat(s, DEACTIVATE_EMPTY);\n\t\tdiscard_slab(s, page);\n\t\tstat(s, FREE_SLAB);\n\t}\n\n\tc->page = NULL;\n\tc->freelist = NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void put_cpu_partial(struct kmem_cache *s, struct page *page, int drain);",
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void put_cpu_partial(struct kmem_cache *s, struct page *page, int drain);\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic void deactivate_slab(struct kmem_cache *s, struct page *page,\n\t\t\t\tvoid *freelist, struct kmem_cache_cpu *c)\n{\n\tenum slab_modes { M_NONE, M_PARTIAL, M_FULL, M_FREE };\n\tstruct kmem_cache_node *n = get_node(s, page_to_nid(page));\n\tint lock = 0;\n\tenum slab_modes l = M_NONE, m = M_NONE;\n\tvoid *nextfree;\n\tint tail = DEACTIVATE_TO_HEAD;\n\tstruct page new;\n\tstruct page old;\n\n\tif (page->freelist) {\n\t\tstat(s, DEACTIVATE_REMOTE_FREES);\n\t\ttail = DEACTIVATE_TO_TAIL;\n\t}\n\n\t/*\n\t * Stage one: Free all available per cpu objects back\n\t * to the page freelist while it is still frozen. Leave the\n\t * last one.\n\t *\n\t * There is no need to take the list->lock because the page\n\t * is still frozen.\n\t */\n\twhile (freelist && (nextfree = get_freepointer(s, freelist))) {\n\t\tvoid *prior;\n\t\tunsigned long counters;\n\n\t\tdo {\n\t\t\tprior = page->freelist;\n\t\t\tcounters = page->counters;\n\t\t\tset_freepointer(s, freelist, prior);\n\t\t\tnew.counters = counters;\n\t\t\tnew.inuse--;\n\t\t\tVM_BUG_ON(!new.frozen);\n\n\t\t} while (!__cmpxchg_double_slab(s, page,\n\t\t\tprior, counters,\n\t\t\tfreelist, new.counters,\n\t\t\t\"drain percpu freelist\"));\n\n\t\tfreelist = nextfree;\n\t}\n\n\t/*\n\t * Stage two: Ensure that the page is unfrozen while the\n\t * list presence reflects the actual number of objects\n\t * during unfreeze.\n\t *\n\t * We setup the list membership and then perform a cmpxchg\n\t * with the count. If there is a mismatch then the page\n\t * is not unfrozen but the page is on the wrong list.\n\t *\n\t * Then we restart the process which may have to remove\n\t * the page from the list that we just put it on again\n\t * because the number of objects in the slab may have\n\t * changed.\n\t */\nredo:\n\n\told.freelist = page->freelist;\n\told.counters = page->counters;\n\tVM_BUG_ON(!old.frozen);\n\n\t/* Determine target state of the slab */\n\tnew.counters = old.counters;\n\tif (freelist) {\n\t\tnew.inuse--;\n\t\tset_freepointer(s, freelist, old.freelist);\n\t\tnew.freelist = freelist;\n\t} else\n\t\tnew.freelist = old.freelist;\n\n\tnew.frozen = 0;\n\n\tif (!new.inuse && n->nr_partial >= s->min_partial)\n\t\tm = M_FREE;\n\telse if (new.freelist) {\n\t\tm = M_PARTIAL;\n\t\tif (!lock) {\n\t\t\tlock = 1;\n\t\t\t/*\n\t\t\t * Taking the spinlock removes the possiblity\n\t\t\t * that acquire_slab() will see a slab page that\n\t\t\t * is frozen\n\t\t\t */\n\t\t\tspin_lock(&n->list_lock);\n\t\t}\n\t} else {\n\t\tm = M_FULL;\n\t\tif (kmem_cache_debug(s) && !lock) {\n\t\t\tlock = 1;\n\t\t\t/*\n\t\t\t * This also ensures that the scanning of full\n\t\t\t * slabs from diagnostic functions will not see\n\t\t\t * any frozen slabs.\n\t\t\t */\n\t\t\tspin_lock(&n->list_lock);\n\t\t}\n\t}\n\n\tif (l != m) {\n\n\t\tif (l == M_PARTIAL)\n\n\t\t\tremove_partial(n, page);\n\n\t\telse if (l == M_FULL)\n\n\t\t\tremove_full(s, n, page);\n\n\t\tif (m == M_PARTIAL) {\n\n\t\t\tadd_partial(n, page, tail);\n\t\t\tstat(s, tail);\n\n\t\t} else if (m == M_FULL) {\n\n\t\t\tstat(s, DEACTIVATE_FULL);\n\t\t\tadd_full(s, n, page);\n\n\t\t}\n\t}\n\n\tl = m;\n\tif (!__cmpxchg_double_slab(s, page,\n\t\t\t\told.freelist, old.counters,\n\t\t\t\tnew.freelist, new.counters,\n\t\t\t\t\"unfreezing slab\"))\n\t\tgoto redo;\n\n\tif (lock)\n\t\tspin_unlock(&n->list_lock);\n\n\tif (m == M_FREE) {\n\t\tstat(s, DEACTIVATE_EMPTY);\n\t\tdiscard_slab(s, page);\n\t\tstat(s, FREE_SLAB);\n\t}\n\n\tc->page = NULL;\n\tc->freelist = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_freepointer",
          "args": [
            "s",
            "freelist"
          ],
          "line": 2623
        },
        "resolved": true,
        "details": {
          "function_name": "get_freepointer_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "276-287",
          "snippet": "static inline void *get_freepointer_safe(struct kmem_cache *s, void *object)\n{\n\tunsigned long freepointer_addr;\n\tvoid *p;\n\n\tif (!debug_pagealloc_enabled())\n\t\treturn get_freepointer(s, object);\n\n\tfreepointer_addr = (unsigned long)object + s->offset;\n\tprobe_kernel_read(&p, (void **)freepointer_addr, sizeof(p));\n\treturn freelist_ptr(s, p, freepointer_addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void *get_freepointer_safe(struct kmem_cache *s, void *object)\n{\n\tunsigned long freepointer_addr;\n\tvoid *p;\n\n\tif (!debug_pagealloc_enabled())\n\t\treturn get_freepointer(s, object);\n\n\tfreepointer_addr = (unsigned long)object + s->offset;\n\tprobe_kernel_read(&p, (void **)freepointer_addr, sizeof(p));\n\treturn freelist_ptr(s, p, freepointer_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_debug_processing",
          "args": [
            "s",
            "page",
            "freelist",
            "addr"
          ],
          "line": 2620
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_debug_processing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1334-1335",
          "snippet": "static inline int alloc_debug_processing(struct kmem_cache *s,\n\tstruct page *page, void *object, unsigned long addr) { return 0; }",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline int alloc_debug_processing(struct kmem_cache *s,\n\tstruct page *page, void *object, unsigned long addr) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_debug",
          "args": [
            "s"
          ],
          "line": 2619
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "118-125",
          "snippet": "static inline int kmem_cache_debug(struct kmem_cache *s)\n{\n#ifdef CONFIG_SLUB_DEBUG\n\treturn unlikely(s->flags & SLAB_DEBUG_FLAGS);\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline int kmem_cache_debug(struct kmem_cache *s)\n{\n#ifdef CONFIG_SLUB_DEBUG\n\treturn unlikely(s->flags & SLAB_DEBUG_FLAGS);\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!kmem_cache_debug(s) && pfmemalloc_match(page, gfpflags)"
          ],
          "line": 2615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfmemalloc_match",
          "args": [
            "page",
            "gfpflags"
          ],
          "line": 2615
        },
        "resolved": true,
        "details": {
          "function_name": "pfmemalloc_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2477-2483",
          "snippet": "static inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags)\n{\n\tif (unlikely(PageSlabPfmemalloc(page)))\n\t\treturn gfp_pfmemalloc_allowed(gfpflags);\n\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);\n\nstatic inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags)\n{\n\tif (unlikely(PageSlabPfmemalloc(page)))\n\t\treturn gfp_pfmemalloc_allowed(gfpflags);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "slab_out_of_memory",
          "args": [
            "s",
            "gfpflags",
            "node"
          ],
          "line": 2610
        },
        "resolved": true,
        "details": {
          "function_name": "slab_out_of_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2404-2439",
          "snippet": "static noinline void\nslab_out_of_memory(struct kmem_cache *s, gfp_t gfpflags, int nid)\n{\n#ifdef CONFIG_SLUB_DEBUG\n\tstatic DEFINE_RATELIMIT_STATE(slub_oom_rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tif ((gfpflags & __GFP_NOWARN) || !__ratelimit(&slub_oom_rs))\n\t\treturn;\n\n\tpr_warn(\"SLUB: Unable to allocate memory on node %d, gfp=%#x(%pGg)\\n\",\n\t\tnid, gfpflags, &gfpflags);\n\tpr_warn(\"  cache: %s, object size: %u, buffer size: %u, default order: %u, min order: %u\\n\",\n\t\ts->name, s->object_size, s->size, oo_order(s->oo),\n\t\too_order(s->min));\n\n\tif (oo_order(s->min) > get_order(s->object_size))\n\t\tpr_warn(\"  %s debugging increased min order, use slub_debug=O to disable.\\n\",\n\t\t\ts->name);\n\n\tfor_each_kmem_cache_node(s, node, n) {\n\t\tunsigned long nr_slabs;\n\t\tunsigned long nr_objs;\n\t\tunsigned long nr_free;\n\n\t\tnr_free  = count_partial(n, count_free);\n\t\tnr_slabs = node_nr_slabs(n);\n\t\tnr_objs  = node_nr_objs(n);\n\n\t\tpr_warn(\"  node %d: slabs: %ld, objs: %ld, free: %ld\\n\",\n\t\t\tnode, nr_slabs, nr_objs, nr_free);\n\t}\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define slub_debug 0"
          ],
          "globals_used": [
            "static inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);",
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define slub_debug 0\n\nstatic inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic noinline void\nslab_out_of_memory(struct kmem_cache *s, gfp_t gfpflags, int nid)\n{\n#ifdef CONFIG_SLUB_DEBUG\n\tstatic DEFINE_RATELIMIT_STATE(slub_oom_rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tif ((gfpflags & __GFP_NOWARN) || !__ratelimit(&slub_oom_rs))\n\t\treturn;\n\n\tpr_warn(\"SLUB: Unable to allocate memory on node %d, gfp=%#x(%pGg)\\n\",\n\t\tnid, gfpflags, &gfpflags);\n\tpr_warn(\"  cache: %s, object size: %u, buffer size: %u, default order: %u, min order: %u\\n\",\n\t\ts->name, s->object_size, s->size, oo_order(s->oo),\n\t\too_order(s->min));\n\n\tif (oo_order(s->min) > get_order(s->object_size))\n\t\tpr_warn(\"  %s debugging increased min order, use slub_debug=O to disable.\\n\",\n\t\t\ts->name);\n\n\tfor_each_kmem_cache_node(s, node, n) {\n\t\tunsigned long nr_slabs;\n\t\tunsigned long nr_objs;\n\t\tunsigned long nr_free;\n\n\t\tnr_free  = count_partial(n, count_free);\n\t\tnr_slabs = node_nr_slabs(n);\n\t\tnr_objs  = node_nr_objs(n);\n\n\t\tpr_warn(\"  node %d: slabs: %ld, objs: %ld, free: %ld\\n\",\n\t\t\tnode, nr_slabs, nr_objs, nr_free);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!freelist"
          ],
          "line": 2609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_slab_objects",
          "args": [
            "s",
            "gfpflags",
            "node",
            "&c"
          ],
          "line": 2607
        },
        "resolved": true,
        "details": {
          "function_name": "new_slab_objects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2441-2475",
          "snippet": "static inline void *new_slab_objects(struct kmem_cache *s, gfp_t flags,\n\t\t\tint node, struct kmem_cache_cpu **pc)\n{\n\tvoid *freelist;\n\tstruct kmem_cache_cpu *c = *pc;\n\tstruct page *page;\n\n\tWARN_ON_ONCE(s->ctor && (flags & __GFP_ZERO));\n\n\tfreelist = get_partial(s, flags, node, c);\n\n\tif (freelist)\n\t\treturn freelist;\n\n\tpage = new_slab(s, flags, node);\n\tif (page) {\n\t\tc = raw_cpu_ptr(s->cpu_slab);\n\t\tif (c->page)\n\t\t\tflush_slab(s, c);\n\n\t\t/*\n\t\t * No other reference to the page yet so we can\n\t\t * muck around with it freely without cmpxchg\n\t\t */\n\t\tfreelist = page->freelist;\n\t\tpage->freelist = NULL;\n\n\t\tstat(s, ALLOC_SLAB);\n\t\tc->page = page;\n\t\t*pc = c;\n\t} else\n\t\tfreelist = NULL;\n\n\treturn freelist;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void *new_slab_objects(struct kmem_cache *s, gfp_t flags,\n\t\t\tint node, struct kmem_cache_cpu **pc)\n{\n\tvoid *freelist;\n\tstruct kmem_cache_cpu *c = *pc;\n\tstruct page *page;\n\n\tWARN_ON_ONCE(s->ctor && (flags & __GFP_ZERO));\n\n\tfreelist = get_partial(s, flags, node, c);\n\n\tif (freelist)\n\t\treturn freelist;\n\n\tpage = new_slab(s, flags, node);\n\tif (page) {\n\t\tc = raw_cpu_ptr(s->cpu_slab);\n\t\tif (c->page)\n\t\t\tflush_slab(s, c);\n\n\t\t/*\n\t\t * No other reference to the page yet so we can\n\t\t * muck around with it freely without cmpxchg\n\t\t */\n\t\tfreelist = page->freelist;\n\t\tpage->freelist = NULL;\n\n\t\tstat(s, ALLOC_SLAB);\n\t\tc->page = page;\n\t\t*pc = c;\n\t} else\n\t\tfreelist = NULL;\n\n\treturn freelist;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "s",
            "CPU_PARTIAL_ALLOC"
          ],
          "line": 2603
        },
        "resolved": true,
        "details": {
          "function_name": "slabinfo_show_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "5900-5902",
          "snippet": "void slabinfo_show_stats(struct seq_file *m, struct kmem_cache *s)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid slabinfo_show_stats(struct seq_file *m, struct kmem_cache *s)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "slub_set_percpu_partial",
          "args": [
            "c",
            "page"
          ],
          "line": 2602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slub_percpu_partial",
          "args": [
            "c"
          ],
          "line": 2601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slub_percpu_partial",
          "args": [
            "c"
          ],
          "line": 2600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_tid",
          "args": [
            "c->tid"
          ],
          "line": 2595
        },
        "resolved": true,
        "details": {
          "function_name": "next_tid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1972-1975",
          "snippet": "static inline unsigned long next_tid(unsigned long tid)\n{\n\treturn tid + TID_STEP;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define TID_STEP 1",
            "#define TID_STEP  roundup_pow_of_two(CONFIG_NR_CPUS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define TID_STEP 1\n#define TID_STEP  roundup_pow_of_two(CONFIG_NR_CPUS)\n\nstatic inline unsigned long next_tid(unsigned long tid)\n{\n\treturn tid + TID_STEP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!c->page->frozen"
          ],
          "line": 2593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_freelist",
          "args": [
            "s",
            "page"
          ],
          "line": 2577
        },
        "resolved": true,
        "details": {
          "function_name": "get_freelist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2495-2517",
          "snippet": "static inline void *get_freelist(struct kmem_cache *s, struct page *page)\n{\n\tstruct page new;\n\tunsigned long counters;\n\tvoid *freelist;\n\n\tdo {\n\t\tfreelist = page->freelist;\n\t\tcounters = page->counters;\n\n\t\tnew.counters = counters;\n\t\tVM_BUG_ON(!new.frozen);\n\n\t\tnew.inuse = page->objects;\n\t\tnew.frozen = freelist != NULL;\n\n\t} while (!__cmpxchg_double_slab(s, page,\n\t\tfreelist, counters,\n\t\tNULL, new.counters,\n\t\t\"get_freelist\"));\n\n\treturn freelist;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void *get_freelist(struct kmem_cache *s, struct page *page)\n{\n\tstruct page new;\n\tunsigned long counters;\n\tvoid *freelist;\n\n\tdo {\n\t\tfreelist = page->freelist;\n\t\tcounters = page->counters;\n\n\t\tnew.counters = counters;\n\t\tVM_BUG_ON(!new.frozen);\n\n\t\tnew.inuse = page->objects;\n\t\tnew.frozen = freelist != NULL;\n\n\t} while (!__cmpxchg_double_slab(s, page,\n\t\tfreelist, counters,\n\t\tNULL, new.counters,\n\t\t\"get_freelist\"));\n\n\treturn freelist;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pfmemalloc_match(page, gfpflags)"
          ],
          "line": 2567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!node_match(page, searchnode)"
          ],
          "line": 2555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_match",
          "args": [
            "page",
            "searchnode"
          ],
          "line": 2555
        },
        "resolved": true,
        "details": {
          "function_name": "node_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2367-2374",
          "snippet": "static inline int node_match(struct page *page, int node)\n{\n#ifdef CONFIG_NUMA\n\tif (!page || (node != NUMA_NO_NODE && page_to_nid(page) != node))\n\t\treturn 0;\n#endif\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline int node_match(struct page *page, int node)\n{\n#ifdef CONFIG_NUMA\n\tif (!page || (node != NUMA_NO_NODE && page_to_nid(page) != node))\n\t\treturn 0;\n#endif\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "node_to_mem_node",
          "args": [
            "node"
          ],
          "line": 2553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_present_pages",
          "args": [
            "node"
          ],
          "line": 2552
        },
        "resolved": true,
        "details": {
          "function_name": "reset_node_present_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "932-940",
          "snippet": "static void reset_node_present_pages(pg_data_t *pgdat)\n{\n\tstruct zone *z;\n\n\tfor (z = pgdat->node_zones; z < pgdat->node_zones + MAX_NR_ZONES; z++)\n\t\tz->present_pages = 0;\n\n\tpgdat->node_present_pages = 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void reset_node_present_pages(pg_data_t *pgdat)\n{\n\tstruct zone *z;\n\n\tfor (z = pgdat->node_zones; z < pgdat->node_zones + MAX_NR_ZONES; z++)\n\t\tz->present_pages = 0;\n\n\tpgdat->node_present_pages = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!node_match(page, node)"
          ],
          "line": 2549
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);\n\nstatic void *___slab_alloc(struct kmem_cache *s, gfp_t gfpflags, int node,\n\t\t\t  unsigned long addr, struct kmem_cache_cpu *c)\n{\n\tvoid *freelist;\n\tstruct page *page;\n\n\tpage = c->page;\n\tif (!page)\n\t\tgoto new_slab;\nredo:\n\n\tif (unlikely(!node_match(page, node))) {\n\t\tint searchnode = node;\n\n\t\tif (node != NUMA_NO_NODE && !node_present_pages(node))\n\t\t\tsearchnode = node_to_mem_node(node);\n\n\t\tif (unlikely(!node_match(page, searchnode))) {\n\t\t\tstat(s, ALLOC_NODE_MISMATCH);\n\t\t\tdeactivate_slab(s, page, c->freelist, c);\n\t\t\tgoto new_slab;\n\t\t}\n\t}\n\n\t/*\n\t * By rights, we should be searching for a slab page that was\n\t * PFMEMALLOC but right now, we are losing the pfmemalloc\n\t * information when the page leaves the per-cpu allocator\n\t */\n\tif (unlikely(!pfmemalloc_match(page, gfpflags))) {\n\t\tdeactivate_slab(s, page, c->freelist, c);\n\t\tgoto new_slab;\n\t}\n\n\t/* must check again c->freelist in case of cpu migration or IRQ */\n\tfreelist = c->freelist;\n\tif (freelist)\n\t\tgoto load_freelist;\n\n\tfreelist = get_freelist(s, page);\n\n\tif (!freelist) {\n\t\tc->page = NULL;\n\t\tstat(s, DEACTIVATE_BYPASS);\n\t\tgoto new_slab;\n\t}\n\n\tstat(s, ALLOC_REFILL);\n\nload_freelist:\n\t/*\n\t * freelist is pointing to the list of objects to be used.\n\t * page is pointing to the page from which the objects are obtained.\n\t * That page must be frozen for per cpu allocations to work.\n\t */\n\tVM_BUG_ON(!c->page->frozen);\n\tc->freelist = get_freepointer(s, freelist);\n\tc->tid = next_tid(c->tid);\n\treturn freelist;\n\nnew_slab:\n\n\tif (slub_percpu_partial(c)) {\n\t\tpage = c->page = slub_percpu_partial(c);\n\t\tslub_set_percpu_partial(c, page);\n\t\tstat(s, CPU_PARTIAL_ALLOC);\n\t\tgoto redo;\n\t}\n\n\tfreelist = new_slab_objects(s, gfpflags, node, &c);\n\n\tif (unlikely(!freelist)) {\n\t\tslab_out_of_memory(s, gfpflags, node);\n\t\treturn NULL;\n\t}\n\n\tpage = c->page;\n\tif (likely(!kmem_cache_debug(s) && pfmemalloc_match(page, gfpflags)))\n\t\tgoto load_freelist;\n\n\t/* Only entered in the debug case */\n\tif (kmem_cache_debug(s) &&\n\t\t\t!alloc_debug_processing(s, page, freelist, addr))\n\t\tgoto new_slab;\t/* Slab failed checks. Next slab needed */\n\n\tdeactivate_slab(s, page, get_freepointer(s, freelist), c);\n\treturn freelist;\n}"
  },
  {
    "function_name": "get_freelist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "2495-2517",
    "snippet": "static inline void *get_freelist(struct kmem_cache *s, struct page *page)\n{\n\tstruct page new;\n\tunsigned long counters;\n\tvoid *freelist;\n\n\tdo {\n\t\tfreelist = page->freelist;\n\t\tcounters = page->counters;\n\n\t\tnew.counters = counters;\n\t\tVM_BUG_ON(!new.frozen);\n\n\t\tnew.inuse = page->objects;\n\t\tnew.frozen = freelist != NULL;\n\n\t} while (!__cmpxchg_double_slab(s, page,\n\t\tfreelist, counters,\n\t\tNULL, new.counters,\n\t\t\"get_freelist\"));\n\n\treturn freelist;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cmpxchg_double_slab",
          "args": [
            "s",
            "page",
            "freelist",
            "counters",
            "NULL",
            "new.counters",
            "\"get_freelist\""
          ],
          "line": 2511
        },
        "resolved": true,
        "details": {
          "function_name": "__cmpxchg_double_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "358-393",
          "snippet": "static inline bool __cmpxchg_double_slab(struct kmem_cache *s, struct page *page,\n\t\tvoid *freelist_old, unsigned long counters_old,\n\t\tvoid *freelist_new, unsigned long counters_new,\n\t\tconst char *n)\n{\n\tVM_BUG_ON(!irqs_disabled());\n#if defined(CONFIG_HAVE_CMPXCHG_DOUBLE) && \\\n    defined(CONFIG_HAVE_ALIGNED_STRUCT_PAGE)\n\tif (s->flags & __CMPXCHG_DOUBLE) {\n\t\tif (cmpxchg_double(&page->freelist, &page->counters,\n\t\t\t\t   freelist_old, counters_old,\n\t\t\t\t   freelist_new, counters_new))\n\t\t\treturn true;\n\t} else\n#endif\n\t{\n\t\tslab_lock(page);\n\t\tif (page->freelist == freelist_old &&\n\t\t\t\t\tpage->counters == counters_old) {\n\t\t\tpage->freelist = freelist_new;\n\t\t\tpage->counters = counters_new;\n\t\t\tslab_unlock(page);\n\t\t\treturn true;\n\t\t}\n\t\tslab_unlock(page);\n\t}\n\n\tcpu_relax();\n\tstat(s, CMPXCHG_DOUBLE_FAIL);\n\n#ifdef SLUB_DEBUG_CMPXCHG\n\tpr_info(\"%s %s: cmpxchg double redo \", n, s->name);\n#endif\n\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define __CMPXCHG_DOUBLE\t((slab_flags_t __force)0x40000000U)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define __CMPXCHG_DOUBLE\t((slab_flags_t __force)0x40000000U)\n\nstatic inline bool __cmpxchg_double_slab(struct kmem_cache *s, struct page *page,\n\t\tvoid *freelist_old, unsigned long counters_old,\n\t\tvoid *freelist_new, unsigned long counters_new,\n\t\tconst char *n)\n{\n\tVM_BUG_ON(!irqs_disabled());\n#if defined(CONFIG_HAVE_CMPXCHG_DOUBLE) && \\\n    defined(CONFIG_HAVE_ALIGNED_STRUCT_PAGE)\n\tif (s->flags & __CMPXCHG_DOUBLE) {\n\t\tif (cmpxchg_double(&page->freelist, &page->counters,\n\t\t\t\t   freelist_old, counters_old,\n\t\t\t\t   freelist_new, counters_new))\n\t\t\treturn true;\n\t} else\n#endif\n\t{\n\t\tslab_lock(page);\n\t\tif (page->freelist == freelist_old &&\n\t\t\t\t\tpage->counters == counters_old) {\n\t\t\tpage->freelist = freelist_new;\n\t\t\tpage->counters = counters_new;\n\t\t\tslab_unlock(page);\n\t\t\treturn true;\n\t\t}\n\t\tslab_unlock(page);\n\t}\n\n\tcpu_relax();\n\tstat(s, CMPXCHG_DOUBLE_FAIL);\n\n#ifdef SLUB_DEBUG_CMPXCHG\n\tpr_info(\"%s %s: cmpxchg double redo \", n, s->name);\n#endif\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!new.frozen"
          ],
          "line": 2506
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void *get_freelist(struct kmem_cache *s, struct page *page)\n{\n\tstruct page new;\n\tunsigned long counters;\n\tvoid *freelist;\n\n\tdo {\n\t\tfreelist = page->freelist;\n\t\tcounters = page->counters;\n\n\t\tnew.counters = counters;\n\t\tVM_BUG_ON(!new.frozen);\n\n\t\tnew.inuse = page->objects;\n\t\tnew.frozen = freelist != NULL;\n\n\t} while (!__cmpxchg_double_slab(s, page,\n\t\tfreelist, counters,\n\t\tNULL, new.counters,\n\t\t\"get_freelist\"));\n\n\treturn freelist;\n}"
  },
  {
    "function_name": "pfmemalloc_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "2477-2483",
    "snippet": "static inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags)\n{\n\tif (unlikely(PageSlabPfmemalloc(page)))\n\t\treturn gfp_pfmemalloc_allowed(gfpflags);\n\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfp_pfmemalloc_allowed",
          "args": [
            "gfpflags"
          ],
          "line": 2480
        },
        "resolved": true,
        "details": {
          "function_name": "gfp_pfmemalloc_allowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3908-3911",
          "snippet": "bool gfp_pfmemalloc_allowed(gfp_t gfp_mask)\n{\n\treturn !!__gfp_pfmemalloc_flags(gfp_mask);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nbool gfp_pfmemalloc_allowed(gfp_t gfp_mask)\n{\n\treturn !!__gfp_pfmemalloc_flags(gfp_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "PageSlabPfmemalloc(page)"
          ],
          "line": 2479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSlabPfmemalloc",
          "args": [
            "page"
          ],
          "line": 2479
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);\n\nstatic inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags)\n{\n\tif (unlikely(PageSlabPfmemalloc(page)))\n\t\treturn gfp_pfmemalloc_allowed(gfpflags);\n\n\treturn true;\n}"
  },
  {
    "function_name": "new_slab_objects",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "2441-2475",
    "snippet": "static inline void *new_slab_objects(struct kmem_cache *s, gfp_t flags,\n\t\t\tint node, struct kmem_cache_cpu **pc)\n{\n\tvoid *freelist;\n\tstruct kmem_cache_cpu *c = *pc;\n\tstruct page *page;\n\n\tWARN_ON_ONCE(s->ctor && (flags & __GFP_ZERO));\n\n\tfreelist = get_partial(s, flags, node, c);\n\n\tif (freelist)\n\t\treturn freelist;\n\n\tpage = new_slab(s, flags, node);\n\tif (page) {\n\t\tc = raw_cpu_ptr(s->cpu_slab);\n\t\tif (c->page)\n\t\t\tflush_slab(s, c);\n\n\t\t/*\n\t\t * No other reference to the page yet so we can\n\t\t * muck around with it freely without cmpxchg\n\t\t */\n\t\tfreelist = page->freelist;\n\t\tpage->freelist = NULL;\n\n\t\tstat(s, ALLOC_SLAB);\n\t\tc->page = page;\n\t\t*pc = c;\n\t} else\n\t\tfreelist = NULL;\n\n\treturn freelist;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "s",
            "ALLOC_SLAB"
          ],
          "line": 2468
        },
        "resolved": true,
        "details": {
          "function_name": "slabinfo_show_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "5900-5902",
          "snippet": "void slabinfo_show_stats(struct seq_file *m, struct kmem_cache *s)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid slabinfo_show_stats(struct seq_file *m, struct kmem_cache *s)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_slab",
          "args": [
            "s",
            "c"
          ],
          "line": 2459
        },
        "resolved": true,
        "details": {
          "function_name": "flush_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2299-2305",
          "snippet": "static inline void flush_slab(struct kmem_cache *s, struct kmem_cache_cpu *c)\n{\n\tstat(s, CPUSLAB_FLUSH);\n\tdeactivate_slab(s, c->page, c->freelist, c);\n\n\tc->tid = next_tid(c->tid);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void flush_slab(struct kmem_cache *s, struct kmem_cache_cpu *c)\n{\n\tstat(s, CPUSLAB_FLUSH);\n\tdeactivate_slab(s, c->page, c->freelist, c);\n\n\tc->tid = next_tid(c->tid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_cpu_ptr",
          "args": [
            "s->cpu_slab"
          ],
          "line": 2457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_slab",
          "args": [
            "s",
            "flags",
            "node"
          ],
          "line": 2455
        },
        "resolved": true,
        "details": {
          "function_name": "new_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1682-1694",
          "snippet": "static struct page *new_slab(struct kmem_cache *s, gfp_t flags, int node)\n{\n\tif (unlikely(flags & GFP_SLAB_BUG_MASK)) {\n\t\tgfp_t invalid_mask = flags & GFP_SLAB_BUG_MASK;\n\t\tflags &= ~GFP_SLAB_BUG_MASK;\n\t\tpr_warn(\"Unexpected gfp: %#x (%pGg). Fixing up to gfp: %#x (%pGg). Fix your code!\\n\",\n\t\t\t\tinvalid_mask, &invalid_mask, flags, &flags);\n\t\tdump_stack();\n\t}\n\n\treturn allocate_slab(s,\n\t\tflags & (GFP_RECLAIM_MASK | GFP_CONSTRAINT_MASK), node);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct page *new_slab(struct kmem_cache *s, gfp_t flags, int node)\n{\n\tif (unlikely(flags & GFP_SLAB_BUG_MASK)) {\n\t\tgfp_t invalid_mask = flags & GFP_SLAB_BUG_MASK;\n\t\tflags &= ~GFP_SLAB_BUG_MASK;\n\t\tpr_warn(\"Unexpected gfp: %#x (%pGg). Fixing up to gfp: %#x (%pGg). Fix your code!\\n\",\n\t\t\t\tinvalid_mask, &invalid_mask, flags, &flags);\n\t\tdump_stack();\n\t}\n\n\treturn allocate_slab(s,\n\t\tflags & (GFP_RECLAIM_MASK | GFP_CONSTRAINT_MASK), node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_partial",
          "args": [
            "s",
            "flags",
            "node",
            "c"
          ],
          "line": 2450
        },
        "resolved": true,
        "details": {
          "function_name": "get_partial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1939-1955",
          "snippet": "static void *get_partial(struct kmem_cache *s, gfp_t flags, int node,\n\t\tstruct kmem_cache_cpu *c)\n{\n\tvoid *object;\n\tint searchnode = node;\n\n\tif (node == NUMA_NO_NODE)\n\t\tsearchnode = numa_mem_id();\n\telse if (!node_present_pages(node))\n\t\tsearchnode = node_to_mem_node(node);\n\n\tobject = get_partial_node(s, get_node(s, searchnode), c, flags);\n\tif (object || node != NUMA_NO_NODE)\n\t\treturn object;\n\n\treturn get_any_partial(s, flags, c);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void *get_partial(struct kmem_cache *s, gfp_t flags, int node,\n\t\tstruct kmem_cache_cpu *c)\n{\n\tvoid *object;\n\tint searchnode = node;\n\n\tif (node == NUMA_NO_NODE)\n\t\tsearchnode = numa_mem_id();\n\telse if (!node_present_pages(node))\n\t\tsearchnode = node_to_mem_node(node);\n\n\tobject = get_partial_node(s, get_node(s, searchnode), c, flags);\n\tif (object || node != NUMA_NO_NODE)\n\t\treturn object;\n\n\treturn get_any_partial(s, flags, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "s->ctor && (flags & __GFP_ZERO)"
          ],
          "line": 2448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void *new_slab_objects(struct kmem_cache *s, gfp_t flags,\n\t\t\tint node, struct kmem_cache_cpu **pc)\n{\n\tvoid *freelist;\n\tstruct kmem_cache_cpu *c = *pc;\n\tstruct page *page;\n\n\tWARN_ON_ONCE(s->ctor && (flags & __GFP_ZERO));\n\n\tfreelist = get_partial(s, flags, node, c);\n\n\tif (freelist)\n\t\treturn freelist;\n\n\tpage = new_slab(s, flags, node);\n\tif (page) {\n\t\tc = raw_cpu_ptr(s->cpu_slab);\n\t\tif (c->page)\n\t\t\tflush_slab(s, c);\n\n\t\t/*\n\t\t * No other reference to the page yet so we can\n\t\t * muck around with it freely without cmpxchg\n\t\t */\n\t\tfreelist = page->freelist;\n\t\tpage->freelist = NULL;\n\n\t\tstat(s, ALLOC_SLAB);\n\t\tc->page = page;\n\t\t*pc = c;\n\t} else\n\t\tfreelist = NULL;\n\n\treturn freelist;\n}"
  },
  {
    "function_name": "slab_out_of_memory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "2404-2439",
    "snippet": "static noinline void\nslab_out_of_memory(struct kmem_cache *s, gfp_t gfpflags, int nid)\n{\n#ifdef CONFIG_SLUB_DEBUG\n\tstatic DEFINE_RATELIMIT_STATE(slub_oom_rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tif ((gfpflags & __GFP_NOWARN) || !__ratelimit(&slub_oom_rs))\n\t\treturn;\n\n\tpr_warn(\"SLUB: Unable to allocate memory on node %d, gfp=%#x(%pGg)\\n\",\n\t\tnid, gfpflags, &gfpflags);\n\tpr_warn(\"  cache: %s, object size: %u, buffer size: %u, default order: %u, min order: %u\\n\",\n\t\ts->name, s->object_size, s->size, oo_order(s->oo),\n\t\too_order(s->min));\n\n\tif (oo_order(s->min) > get_order(s->object_size))\n\t\tpr_warn(\"  %s debugging increased min order, use slub_debug=O to disable.\\n\",\n\t\t\ts->name);\n\n\tfor_each_kmem_cache_node(s, node, n) {\n\t\tunsigned long nr_slabs;\n\t\tunsigned long nr_objs;\n\t\tunsigned long nr_free;\n\n\t\tnr_free  = count_partial(n, count_free);\n\t\tnr_slabs = node_nr_slabs(n);\n\t\tnr_objs  = node_nr_objs(n);\n\n\t\tpr_warn(\"  node %d: slabs: %ld, objs: %ld, free: %ld\\n\",\n\t\t\tnode, nr_slabs, nr_objs, nr_free);\n\t}\n#endif\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define slub_debug 0"
    ],
    "globals_used": [
      "static inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);",
      "static struct kmem_cache *kmem_cache_node;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"  node %d: slabs: %ld, objs: %ld, free: %ld\\n\"",
            "node",
            "nr_slabs",
            "nr_objs",
            "nr_free"
          ],
          "line": 2435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_nr_objs",
          "args": [
            "n"
          ],
          "line": 2433
        },
        "resolved": true,
        "details": {
          "function_name": "node_nr_objs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2382-2385",
          "snippet": "static inline unsigned long node_nr_objs(struct kmem_cache_node *n)\n{\n\treturn atomic_long_read(&n->total_objects);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic inline unsigned long node_nr_objs(struct kmem_cache_node *n)\n{\n\treturn atomic_long_read(&n->total_objects);\n}"
        }
      },
      {
        "call_info": {
          "callee": "node_nr_slabs",
          "args": [
            "n"
          ],
          "line": 2432
        },
        "resolved": true,
        "details": {
          "function_name": "node_nr_slabs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1362-1363",
          "snippet": "static inline unsigned long node_nr_slabs(struct kmem_cache_node *n)\n\t\t\t\t\t\t\t{ return 0; }",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic inline unsigned long node_nr_slabs(struct kmem_cache_node *n)\n\t\t\t\t\t\t\t{ return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "count_partial",
          "args": [
            "n",
            "count_free"
          ],
          "line": 2431
        },
        "resolved": true,
        "details": {
          "function_name": "count_partial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2389-2401",
          "snippet": "static unsigned long count_partial(struct kmem_cache_node *n,\n\t\t\t\t\tint (*get_count)(struct page *))\n{\n\tunsigned long flags;\n\tunsigned long x = 0;\n\tstruct page *page;\n\n\tspin_lock_irqsave(&n->list_lock, flags);\n\tlist_for_each_entry(page, &n->partial, lru)\n\t\tx += get_count(page);\n\tspin_unlock_irqrestore(&n->list_lock, flags);\n\treturn x;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic unsigned long count_partial(struct kmem_cache_node *n,\n\t\t\t\t\tint (*get_count)(struct page *))\n{\n\tunsigned long flags;\n\tunsigned long x = 0;\n\tstruct page *page;\n\n\tspin_lock_irqsave(&n->list_lock, flags);\n\tlist_for_each_entry(page, &n->partial, lru)\n\t\tx += get_count(page);\n\tspin_unlock_irqrestore(&n->list_lock, flags);\n\treturn x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_kmem_cache_node",
          "args": [
            "s",
            "node",
            "n"
          ],
          "line": 2426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"  %s debugging increased min order, use slub_debug=O to disable.\\n\"",
            "s->name"
          ],
          "line": 2423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "s->object_size"
          ],
          "line": 2422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oo_order",
          "args": [
            "s->min"
          ],
          "line": 2422
        },
        "resolved": true,
        "details": {
          "function_name": "oo_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "332-335",
          "snippet": "static inline unsigned int oo_order(struct kmem_cache_order_objects x)\n{\n\treturn x.x >> OO_SHIFT;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define OO_SHIFT\t16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define OO_SHIFT\t16\n\nstatic inline unsigned int oo_order(struct kmem_cache_order_objects x)\n{\n\treturn x.x >> OO_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"  cache: %s, object size: %u, buffer size: %u, default order: %u, min order: %u\\n\"",
            "s->name",
            "s->object_size",
            "s->size",
            "oo_order(s->oo)",
            "oo_order(s->min)"
          ],
          "line": 2418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"SLUB: Unable to allocate memory on node %d, gfp=%#x(%pGg)\\n\"",
            "nid",
            "gfpflags",
            "&gfpflags"
          ],
          "line": 2416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ratelimit",
          "args": [
            "&slub_oom_rs"
          ],
          "line": 2413
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define slub_debug 0\n\nstatic inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic noinline void\nslab_out_of_memory(struct kmem_cache *s, gfp_t gfpflags, int nid)\n{\n#ifdef CONFIG_SLUB_DEBUG\n\tstatic DEFINE_RATELIMIT_STATE(slub_oom_rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tif ((gfpflags & __GFP_NOWARN) || !__ratelimit(&slub_oom_rs))\n\t\treturn;\n\n\tpr_warn(\"SLUB: Unable to allocate memory on node %d, gfp=%#x(%pGg)\\n\",\n\t\tnid, gfpflags, &gfpflags);\n\tpr_warn(\"  cache: %s, object size: %u, buffer size: %u, default order: %u, min order: %u\\n\",\n\t\ts->name, s->object_size, s->size, oo_order(s->oo),\n\t\too_order(s->min));\n\n\tif (oo_order(s->min) > get_order(s->object_size))\n\t\tpr_warn(\"  %s debugging increased min order, use slub_debug=O to disable.\\n\",\n\t\t\ts->name);\n\n\tfor_each_kmem_cache_node(s, node, n) {\n\t\tunsigned long nr_slabs;\n\t\tunsigned long nr_objs;\n\t\tunsigned long nr_free;\n\n\t\tnr_free  = count_partial(n, count_free);\n\t\tnr_slabs = node_nr_slabs(n);\n\t\tnr_objs  = node_nr_objs(n);\n\n\t\tpr_warn(\"  node %d: slabs: %ld, objs: %ld, free: %ld\\n\",\n\t\t\tnode, nr_slabs, nr_objs, nr_free);\n\t}\n#endif\n}"
  },
  {
    "function_name": "count_partial",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "2389-2401",
    "snippet": "static unsigned long count_partial(struct kmem_cache_node *n,\n\t\t\t\t\tint (*get_count)(struct page *))\n{\n\tunsigned long flags;\n\tunsigned long x = 0;\n\tstruct page *page;\n\n\tspin_lock_irqsave(&n->list_lock, flags);\n\tlist_for_each_entry(page, &n->partial, lru)\n\t\tx += get_count(page);\n\tspin_unlock_irqrestore(&n->list_lock, flags);\n\treturn x;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *kmem_cache_node;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&n->list_lock",
            "flags"
          ],
          "line": 2399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_count",
          "args": [
            "page"
          ],
          "line": 2398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "page",
            "&n->partial",
            "lru"
          ],
          "line": 2397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&n->list_lock",
            "flags"
          ],
          "line": 2396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic unsigned long count_partial(struct kmem_cache_node *n,\n\t\t\t\t\tint (*get_count)(struct page *))\n{\n\tunsigned long flags;\n\tunsigned long x = 0;\n\tstruct page *page;\n\n\tspin_lock_irqsave(&n->list_lock, flags);\n\tlist_for_each_entry(page, &n->partial, lru)\n\t\tx += get_count(page);\n\tspin_unlock_irqrestore(&n->list_lock, flags);\n\treturn x;\n}"
  },
  {
    "function_name": "node_nr_objs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "2382-2385",
    "snippet": "static inline unsigned long node_nr_objs(struct kmem_cache_node *n)\n{\n\treturn atomic_long_read(&n->total_objects);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *kmem_cache_node;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&n->total_objects"
          ],
          "line": 2384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic inline unsigned long node_nr_objs(struct kmem_cache_node *n)\n{\n\treturn atomic_long_read(&n->total_objects);\n}"
  },
  {
    "function_name": "count_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "2377-2380",
    "snippet": "static int count_free(struct page *page)\n{\n\treturn page->objects - page->inuse;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic int count_free(struct page *page)\n{\n\treturn page->objects - page->inuse;\n}"
  },
  {
    "function_name": "node_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "2367-2374",
    "snippet": "static inline int node_match(struct page *page, int node)\n{\n#ifdef CONFIG_NUMA\n\tif (!page || (node != NUMA_NO_NODE && page_to_nid(page) != node))\n\t\treturn 0;\n#endif\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 2370
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline int node_match(struct page *page, int node)\n{\n#ifdef CONFIG_NUMA\n\tif (!page || (node != NUMA_NO_NODE && page_to_nid(page) != node))\n\t\treturn 0;\n#endif\n\treturn 1;\n}"
  },
  {
    "function_name": "slub_cpu_dead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "2348-2361",
    "snippet": "static int slub_cpu_dead(unsigned int cpu)\n{\n\tstruct kmem_cache *s;\n\tunsigned long flags;\n\n\tmutex_lock(&slab_mutex);\n\tlist_for_each_entry(s, &slab_caches, list) {\n\t\tlocal_irq_save(flags);\n\t\t__flush_cpu_slab(s, cpu);\n\t\tlocal_irq_restore(flags);\n\t}\n\tmutex_unlock(&slab_mutex);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&slab_mutex"
          ],
          "line": 2359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 2357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__flush_cpu_slab",
          "args": [
            "s",
            "cpu"
          ],
          "line": 2356
        },
        "resolved": true,
        "details": {
          "function_name": "__flush_cpu_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2312-2322",
          "snippet": "static inline void __flush_cpu_slab(struct kmem_cache *s, int cpu)\n{\n\tstruct kmem_cache_cpu *c = per_cpu_ptr(s->cpu_slab, cpu);\n\n\tif (likely(c)) {\n\t\tif (c->page)\n\t\t\tflush_slab(s, c);\n\n\t\tunfreeze_partials(s, c);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void __flush_cpu_slab(struct kmem_cache *s, int cpu)\n{\n\tstruct kmem_cache_cpu *c = per_cpu_ptr(s->cpu_slab, cpu);\n\n\tif (likely(c)) {\n\t\tif (c->page)\n\t\t\tflush_slab(s, c);\n\n\t\tunfreeze_partials(s, c);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 2355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "s",
            "&slab_caches",
            "list"
          ],
          "line": 2354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&slab_mutex"
          ],
          "line": 2353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic int slub_cpu_dead(unsigned int cpu)\n{\n\tstruct kmem_cache *s;\n\tunsigned long flags;\n\n\tmutex_lock(&slab_mutex);\n\tlist_for_each_entry(s, &slab_caches, list) {\n\t\tlocal_irq_save(flags);\n\t\t__flush_cpu_slab(s, cpu);\n\t\tlocal_irq_restore(flags);\n\t}\n\tmutex_unlock(&slab_mutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "flush_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "2339-2342",
    "snippet": "static void flush_all(struct kmem_cache *s)\n{\n\ton_each_cpu_cond(has_cpu_slab, flush_cpu_slab, s, 1, GFP_ATOMIC);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "on_each_cpu_cond",
          "args": [
            "has_cpu_slab",
            "flush_cpu_slab",
            "s",
            "1",
            "GFP_ATOMIC"
          ],
          "line": 2341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void flush_all(struct kmem_cache *s)\n{\n\ton_each_cpu_cond(has_cpu_slab, flush_cpu_slab, s, 1, GFP_ATOMIC);\n}"
  },
  {
    "function_name": "has_cpu_slab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "2331-2337",
    "snippet": "static bool has_cpu_slab(int cpu, void *info)\n{\n\tstruct kmem_cache *s = info;\n\tstruct kmem_cache_cpu *c = per_cpu_ptr(s->cpu_slab, cpu);\n\n\treturn c->page || slub_percpu_partial(c);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "slub_percpu_partial",
          "args": [
            "c"
          ],
          "line": 2336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "s->cpu_slab",
            "cpu"
          ],
          "line": 2334
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic bool has_cpu_slab(int cpu, void *info)\n{\n\tstruct kmem_cache *s = info;\n\tstruct kmem_cache_cpu *c = per_cpu_ptr(s->cpu_slab, cpu);\n\n\treturn c->page || slub_percpu_partial(c);\n}"
  },
  {
    "function_name": "flush_cpu_slab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "2324-2329",
    "snippet": "static void flush_cpu_slab(void *d)\n{\n\tstruct kmem_cache *s = d;\n\n\t__flush_cpu_slab(s, smp_processor_id());\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__flush_cpu_slab",
          "args": [
            "s",
            "smp_processor_id()"
          ],
          "line": 2328
        },
        "resolved": true,
        "details": {
          "function_name": "__flush_cpu_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2312-2322",
          "snippet": "static inline void __flush_cpu_slab(struct kmem_cache *s, int cpu)\n{\n\tstruct kmem_cache_cpu *c = per_cpu_ptr(s->cpu_slab, cpu);\n\n\tif (likely(c)) {\n\t\tif (c->page)\n\t\t\tflush_slab(s, c);\n\n\t\tunfreeze_partials(s, c);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void __flush_cpu_slab(struct kmem_cache *s, int cpu)\n{\n\tstruct kmem_cache_cpu *c = per_cpu_ptr(s->cpu_slab, cpu);\n\n\tif (likely(c)) {\n\t\tif (c->page)\n\t\t\tflush_slab(s, c);\n\n\t\tunfreeze_partials(s, c);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 2328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void flush_cpu_slab(void *d)\n{\n\tstruct kmem_cache *s = d;\n\n\t__flush_cpu_slab(s, smp_processor_id());\n}"
  },
  {
    "function_name": "__flush_cpu_slab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "2312-2322",
    "snippet": "static inline void __flush_cpu_slab(struct kmem_cache *s, int cpu)\n{\n\tstruct kmem_cache_cpu *c = per_cpu_ptr(s->cpu_slab, cpu);\n\n\tif (likely(c)) {\n\t\tif (c->page)\n\t\t\tflush_slab(s, c);\n\n\t\tunfreeze_partials(s, c);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unfreeze_partials",
          "args": [
            "s",
            "c"
          ],
          "line": 2320
        },
        "resolved": true,
        "details": {
          "function_name": "unfreeze_partials",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2179-2238",
          "snippet": "static void unfreeze_partials(struct kmem_cache *s,\n\t\tstruct kmem_cache_cpu *c)\n{\n#ifdef CONFIG_SLUB_CPU_PARTIAL\n\tstruct kmem_cache_node *n = NULL, *n2 = NULL;\n\tstruct page *page, *discard_page = NULL;\n\n\twhile ((page = c->partial)) {\n\t\tstruct page new;\n\t\tstruct page old;\n\n\t\tc->partial = page->next;\n\n\t\tn2 = get_node(s, page_to_nid(page));\n\t\tif (n != n2) {\n\t\t\tif (n)\n\t\t\t\tspin_unlock(&n->list_lock);\n\n\t\t\tn = n2;\n\t\t\tspin_lock(&n->list_lock);\n\t\t}\n\n\t\tdo {\n\n\t\t\told.freelist = page->freelist;\n\t\t\told.counters = page->counters;\n\t\t\tVM_BUG_ON(!old.frozen);\n\n\t\t\tnew.counters = old.counters;\n\t\t\tnew.freelist = old.freelist;\n\n\t\t\tnew.frozen = 0;\n\n\t\t} while (!__cmpxchg_double_slab(s, page,\n\t\t\t\told.freelist, old.counters,\n\t\t\t\tnew.freelist, new.counters,\n\t\t\t\t\"unfreezing slab\"));\n\n\t\tif (unlikely(!new.inuse && n->nr_partial >= s->min_partial)) {\n\t\t\tpage->next = discard_page;\n\t\t\tdiscard_page = page;\n\t\t} else {\n\t\t\tadd_partial(n, page, DEACTIVATE_TO_TAIL);\n\t\t\tstat(s, FREE_ADD_PARTIAL);\n\t\t}\n\t}\n\n\tif (n)\n\t\tspin_unlock(&n->list_lock);\n\n\twhile (discard_page) {\n\t\tpage = discard_page;\n\t\tdiscard_page = discard_page->next;\n\n\t\tstat(s, DEACTIVATE_EMPTY);\n\t\tdiscard_slab(s, page);\n\t\tstat(s, FREE_SLAB);\n\t}\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic void unfreeze_partials(struct kmem_cache *s,\n\t\tstruct kmem_cache_cpu *c)\n{\n#ifdef CONFIG_SLUB_CPU_PARTIAL\n\tstruct kmem_cache_node *n = NULL, *n2 = NULL;\n\tstruct page *page, *discard_page = NULL;\n\n\twhile ((page = c->partial)) {\n\t\tstruct page new;\n\t\tstruct page old;\n\n\t\tc->partial = page->next;\n\n\t\tn2 = get_node(s, page_to_nid(page));\n\t\tif (n != n2) {\n\t\t\tif (n)\n\t\t\t\tspin_unlock(&n->list_lock);\n\n\t\t\tn = n2;\n\t\t\tspin_lock(&n->list_lock);\n\t\t}\n\n\t\tdo {\n\n\t\t\told.freelist = page->freelist;\n\t\t\told.counters = page->counters;\n\t\t\tVM_BUG_ON(!old.frozen);\n\n\t\t\tnew.counters = old.counters;\n\t\t\tnew.freelist = old.freelist;\n\n\t\t\tnew.frozen = 0;\n\n\t\t} while (!__cmpxchg_double_slab(s, page,\n\t\t\t\told.freelist, old.counters,\n\t\t\t\tnew.freelist, new.counters,\n\t\t\t\t\"unfreezing slab\"));\n\n\t\tif (unlikely(!new.inuse && n->nr_partial >= s->min_partial)) {\n\t\t\tpage->next = discard_page;\n\t\t\tdiscard_page = page;\n\t\t} else {\n\t\t\tadd_partial(n, page, DEACTIVATE_TO_TAIL);\n\t\t\tstat(s, FREE_ADD_PARTIAL);\n\t\t}\n\t}\n\n\tif (n)\n\t\tspin_unlock(&n->list_lock);\n\n\twhile (discard_page) {\n\t\tpage = discard_page;\n\t\tdiscard_page = discard_page->next;\n\n\t\tstat(s, DEACTIVATE_EMPTY);\n\t\tdiscard_slab(s, page);\n\t\tstat(s, FREE_SLAB);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_slab",
          "args": [
            "s",
            "c"
          ],
          "line": 2318
        },
        "resolved": true,
        "details": {
          "function_name": "flush_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2299-2305",
          "snippet": "static inline void flush_slab(struct kmem_cache *s, struct kmem_cache_cpu *c)\n{\n\tstat(s, CPUSLAB_FLUSH);\n\tdeactivate_slab(s, c->page, c->freelist, c);\n\n\tc->tid = next_tid(c->tid);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void flush_slab(struct kmem_cache *s, struct kmem_cache_cpu *c)\n{\n\tstat(s, CPUSLAB_FLUSH);\n\tdeactivate_slab(s, c->page, c->freelist, c);\n\n\tc->tid = next_tid(c->tid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "c"
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "s->cpu_slab",
            "cpu"
          ],
          "line": 2314
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void __flush_cpu_slab(struct kmem_cache *s, int cpu)\n{\n\tstruct kmem_cache_cpu *c = per_cpu_ptr(s->cpu_slab, cpu);\n\n\tif (likely(c)) {\n\t\tif (c->page)\n\t\t\tflush_slab(s, c);\n\n\t\tunfreeze_partials(s, c);\n\t}\n}"
  },
  {
    "function_name": "flush_slab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "2299-2305",
    "snippet": "static inline void flush_slab(struct kmem_cache *s, struct kmem_cache_cpu *c)\n{\n\tstat(s, CPUSLAB_FLUSH);\n\tdeactivate_slab(s, c->page, c->freelist, c);\n\n\tc->tid = next_tid(c->tid);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "next_tid",
          "args": [
            "c->tid"
          ],
          "line": 2304
        },
        "resolved": true,
        "details": {
          "function_name": "next_tid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1972-1975",
          "snippet": "static inline unsigned long next_tid(unsigned long tid)\n{\n\treturn tid + TID_STEP;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define TID_STEP 1",
            "#define TID_STEP  roundup_pow_of_two(CONFIG_NR_CPUS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define TID_STEP 1\n#define TID_STEP  roundup_pow_of_two(CONFIG_NR_CPUS)\n\nstatic inline unsigned long next_tid(unsigned long tid)\n{\n\treturn tid + TID_STEP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "deactivate_slab",
          "args": [
            "s",
            "c->page",
            "c->freelist",
            "c"
          ],
          "line": 2302
        },
        "resolved": true,
        "details": {
          "function_name": "deactivate_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2027-2170",
          "snippet": "static void deactivate_slab(struct kmem_cache *s, struct page *page,\n\t\t\t\tvoid *freelist, struct kmem_cache_cpu *c)\n{\n\tenum slab_modes { M_NONE, M_PARTIAL, M_FULL, M_FREE };\n\tstruct kmem_cache_node *n = get_node(s, page_to_nid(page));\n\tint lock = 0;\n\tenum slab_modes l = M_NONE, m = M_NONE;\n\tvoid *nextfree;\n\tint tail = DEACTIVATE_TO_HEAD;\n\tstruct page new;\n\tstruct page old;\n\n\tif (page->freelist) {\n\t\tstat(s, DEACTIVATE_REMOTE_FREES);\n\t\ttail = DEACTIVATE_TO_TAIL;\n\t}\n\n\t/*\n\t * Stage one: Free all available per cpu objects back\n\t * to the page freelist while it is still frozen. Leave the\n\t * last one.\n\t *\n\t * There is no need to take the list->lock because the page\n\t * is still frozen.\n\t */\n\twhile (freelist && (nextfree = get_freepointer(s, freelist))) {\n\t\tvoid *prior;\n\t\tunsigned long counters;\n\n\t\tdo {\n\t\t\tprior = page->freelist;\n\t\t\tcounters = page->counters;\n\t\t\tset_freepointer(s, freelist, prior);\n\t\t\tnew.counters = counters;\n\t\t\tnew.inuse--;\n\t\t\tVM_BUG_ON(!new.frozen);\n\n\t\t} while (!__cmpxchg_double_slab(s, page,\n\t\t\tprior, counters,\n\t\t\tfreelist, new.counters,\n\t\t\t\"drain percpu freelist\"));\n\n\t\tfreelist = nextfree;\n\t}\n\n\t/*\n\t * Stage two: Ensure that the page is unfrozen while the\n\t * list presence reflects the actual number of objects\n\t * during unfreeze.\n\t *\n\t * We setup the list membership and then perform a cmpxchg\n\t * with the count. If there is a mismatch then the page\n\t * is not unfrozen but the page is on the wrong list.\n\t *\n\t * Then we restart the process which may have to remove\n\t * the page from the list that we just put it on again\n\t * because the number of objects in the slab may have\n\t * changed.\n\t */\nredo:\n\n\told.freelist = page->freelist;\n\told.counters = page->counters;\n\tVM_BUG_ON(!old.frozen);\n\n\t/* Determine target state of the slab */\n\tnew.counters = old.counters;\n\tif (freelist) {\n\t\tnew.inuse--;\n\t\tset_freepointer(s, freelist, old.freelist);\n\t\tnew.freelist = freelist;\n\t} else\n\t\tnew.freelist = old.freelist;\n\n\tnew.frozen = 0;\n\n\tif (!new.inuse && n->nr_partial >= s->min_partial)\n\t\tm = M_FREE;\n\telse if (new.freelist) {\n\t\tm = M_PARTIAL;\n\t\tif (!lock) {\n\t\t\tlock = 1;\n\t\t\t/*\n\t\t\t * Taking the spinlock removes the possiblity\n\t\t\t * that acquire_slab() will see a slab page that\n\t\t\t * is frozen\n\t\t\t */\n\t\t\tspin_lock(&n->list_lock);\n\t\t}\n\t} else {\n\t\tm = M_FULL;\n\t\tif (kmem_cache_debug(s) && !lock) {\n\t\t\tlock = 1;\n\t\t\t/*\n\t\t\t * This also ensures that the scanning of full\n\t\t\t * slabs from diagnostic functions will not see\n\t\t\t * any frozen slabs.\n\t\t\t */\n\t\t\tspin_lock(&n->list_lock);\n\t\t}\n\t}\n\n\tif (l != m) {\n\n\t\tif (l == M_PARTIAL)\n\n\t\t\tremove_partial(n, page);\n\n\t\telse if (l == M_FULL)\n\n\t\t\tremove_full(s, n, page);\n\n\t\tif (m == M_PARTIAL) {\n\n\t\t\tadd_partial(n, page, tail);\n\t\t\tstat(s, tail);\n\n\t\t} else if (m == M_FULL) {\n\n\t\t\tstat(s, DEACTIVATE_FULL);\n\t\t\tadd_full(s, n, page);\n\n\t\t}\n\t}\n\n\tl = m;\n\tif (!__cmpxchg_double_slab(s, page,\n\t\t\t\told.freelist, old.counters,\n\t\t\t\tnew.freelist, new.counters,\n\t\t\t\t\"unfreezing slab\"))\n\t\tgoto redo;\n\n\tif (lock)\n\t\tspin_unlock(&n->list_lock);\n\n\tif (m == M_FREE) {\n\t\tstat(s, DEACTIVATE_EMPTY);\n\t\tdiscard_slab(s, page);\n\t\tstat(s, FREE_SLAB);\n\t}\n\n\tc->page = NULL;\n\tc->freelist = NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void put_cpu_partial(struct kmem_cache *s, struct page *page, int drain);",
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void put_cpu_partial(struct kmem_cache *s, struct page *page, int drain);\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic void deactivate_slab(struct kmem_cache *s, struct page *page,\n\t\t\t\tvoid *freelist, struct kmem_cache_cpu *c)\n{\n\tenum slab_modes { M_NONE, M_PARTIAL, M_FULL, M_FREE };\n\tstruct kmem_cache_node *n = get_node(s, page_to_nid(page));\n\tint lock = 0;\n\tenum slab_modes l = M_NONE, m = M_NONE;\n\tvoid *nextfree;\n\tint tail = DEACTIVATE_TO_HEAD;\n\tstruct page new;\n\tstruct page old;\n\n\tif (page->freelist) {\n\t\tstat(s, DEACTIVATE_REMOTE_FREES);\n\t\ttail = DEACTIVATE_TO_TAIL;\n\t}\n\n\t/*\n\t * Stage one: Free all available per cpu objects back\n\t * to the page freelist while it is still frozen. Leave the\n\t * last one.\n\t *\n\t * There is no need to take the list->lock because the page\n\t * is still frozen.\n\t */\n\twhile (freelist && (nextfree = get_freepointer(s, freelist))) {\n\t\tvoid *prior;\n\t\tunsigned long counters;\n\n\t\tdo {\n\t\t\tprior = page->freelist;\n\t\t\tcounters = page->counters;\n\t\t\tset_freepointer(s, freelist, prior);\n\t\t\tnew.counters = counters;\n\t\t\tnew.inuse--;\n\t\t\tVM_BUG_ON(!new.frozen);\n\n\t\t} while (!__cmpxchg_double_slab(s, page,\n\t\t\tprior, counters,\n\t\t\tfreelist, new.counters,\n\t\t\t\"drain percpu freelist\"));\n\n\t\tfreelist = nextfree;\n\t}\n\n\t/*\n\t * Stage two: Ensure that the page is unfrozen while the\n\t * list presence reflects the actual number of objects\n\t * during unfreeze.\n\t *\n\t * We setup the list membership and then perform a cmpxchg\n\t * with the count. If there is a mismatch then the page\n\t * is not unfrozen but the page is on the wrong list.\n\t *\n\t * Then we restart the process which may have to remove\n\t * the page from the list that we just put it on again\n\t * because the number of objects in the slab may have\n\t * changed.\n\t */\nredo:\n\n\told.freelist = page->freelist;\n\told.counters = page->counters;\n\tVM_BUG_ON(!old.frozen);\n\n\t/* Determine target state of the slab */\n\tnew.counters = old.counters;\n\tif (freelist) {\n\t\tnew.inuse--;\n\t\tset_freepointer(s, freelist, old.freelist);\n\t\tnew.freelist = freelist;\n\t} else\n\t\tnew.freelist = old.freelist;\n\n\tnew.frozen = 0;\n\n\tif (!new.inuse && n->nr_partial >= s->min_partial)\n\t\tm = M_FREE;\n\telse if (new.freelist) {\n\t\tm = M_PARTIAL;\n\t\tif (!lock) {\n\t\t\tlock = 1;\n\t\t\t/*\n\t\t\t * Taking the spinlock removes the possiblity\n\t\t\t * that acquire_slab() will see a slab page that\n\t\t\t * is frozen\n\t\t\t */\n\t\t\tspin_lock(&n->list_lock);\n\t\t}\n\t} else {\n\t\tm = M_FULL;\n\t\tif (kmem_cache_debug(s) && !lock) {\n\t\t\tlock = 1;\n\t\t\t/*\n\t\t\t * This also ensures that the scanning of full\n\t\t\t * slabs from diagnostic functions will not see\n\t\t\t * any frozen slabs.\n\t\t\t */\n\t\t\tspin_lock(&n->list_lock);\n\t\t}\n\t}\n\n\tif (l != m) {\n\n\t\tif (l == M_PARTIAL)\n\n\t\t\tremove_partial(n, page);\n\n\t\telse if (l == M_FULL)\n\n\t\t\tremove_full(s, n, page);\n\n\t\tif (m == M_PARTIAL) {\n\n\t\t\tadd_partial(n, page, tail);\n\t\t\tstat(s, tail);\n\n\t\t} else if (m == M_FULL) {\n\n\t\t\tstat(s, DEACTIVATE_FULL);\n\t\t\tadd_full(s, n, page);\n\n\t\t}\n\t}\n\n\tl = m;\n\tif (!__cmpxchg_double_slab(s, page,\n\t\t\t\told.freelist, old.counters,\n\t\t\t\tnew.freelist, new.counters,\n\t\t\t\t\"unfreezing slab\"))\n\t\tgoto redo;\n\n\tif (lock)\n\t\tspin_unlock(&n->list_lock);\n\n\tif (m == M_FREE) {\n\t\tstat(s, DEACTIVATE_EMPTY);\n\t\tdiscard_slab(s, page);\n\t\tstat(s, FREE_SLAB);\n\t}\n\n\tc->page = NULL;\n\tc->freelist = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "s",
            "CPUSLAB_FLUSH"
          ],
          "line": 2301
        },
        "resolved": true,
        "details": {
          "function_name": "slabinfo_show_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "5900-5902",
          "snippet": "void slabinfo_show_stats(struct seq_file *m, struct kmem_cache *s)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid slabinfo_show_stats(struct seq_file *m, struct kmem_cache *s)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void flush_slab(struct kmem_cache *s, struct kmem_cache_cpu *c)\n{\n\tstat(s, CPUSLAB_FLUSH);\n\tdeactivate_slab(s, c->page, c->freelist, c);\n\n\tc->tid = next_tid(c->tid);\n}"
  },
  {
    "function_name": "put_cpu_partial",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "2247-2297",
    "snippet": "static void put_cpu_partial(struct kmem_cache *s, struct page *page, int drain)\n{\n#ifdef CONFIG_SLUB_CPU_PARTIAL\n\tstruct page *oldpage;\n\tint pages;\n\tint pobjects;\n\n\tpreempt_disable();\n\tdo {\n\t\tpages = 0;\n\t\tpobjects = 0;\n\t\toldpage = this_cpu_read(s->cpu_slab->partial);\n\n\t\tif (oldpage) {\n\t\t\tpobjects = oldpage->pobjects;\n\t\t\tpages = oldpage->pages;\n\t\t\tif (drain && pobjects > s->cpu_partial) {\n\t\t\t\tunsigned long flags;\n\t\t\t\t/*\n\t\t\t\t * partial array is full. Move the existing\n\t\t\t\t * set to the per node partial list.\n\t\t\t\t */\n\t\t\t\tlocal_irq_save(flags);\n\t\t\t\tunfreeze_partials(s, this_cpu_ptr(s->cpu_slab));\n\t\t\t\tlocal_irq_restore(flags);\n\t\t\t\toldpage = NULL;\n\t\t\t\tpobjects = 0;\n\t\t\t\tpages = 0;\n\t\t\t\tstat(s, CPU_PARTIAL_DRAIN);\n\t\t\t}\n\t\t}\n\n\t\tpages++;\n\t\tpobjects += page->objects - page->inuse;\n\n\t\tpage->pages = pages;\n\t\tpage->pobjects = pobjects;\n\t\tpage->next = oldpage;\n\n\t} while (this_cpu_cmpxchg(s->cpu_slab->partial, oldpage, page)\n\t\t\t\t\t\t\t\t!= oldpage);\n\tif (unlikely(!s->cpu_partial)) {\n\t\tunsigned long flags;\n\n\t\tlocal_irq_save(flags);\n\t\tunfreeze_partials(s, this_cpu_ptr(s->cpu_slab));\n\t\tlocal_irq_restore(flags);\n\t}\n\tpreempt_enable();\n#endif\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void put_cpu_partial(struct kmem_cache *s, struct page *page, int drain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 2295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 2293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unfreeze_partials",
          "args": [
            "s",
            "this_cpu_ptr(s->cpu_slab)"
          ],
          "line": 2292
        },
        "resolved": true,
        "details": {
          "function_name": "unfreeze_partials",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2179-2238",
          "snippet": "static void unfreeze_partials(struct kmem_cache *s,\n\t\tstruct kmem_cache_cpu *c)\n{\n#ifdef CONFIG_SLUB_CPU_PARTIAL\n\tstruct kmem_cache_node *n = NULL, *n2 = NULL;\n\tstruct page *page, *discard_page = NULL;\n\n\twhile ((page = c->partial)) {\n\t\tstruct page new;\n\t\tstruct page old;\n\n\t\tc->partial = page->next;\n\n\t\tn2 = get_node(s, page_to_nid(page));\n\t\tif (n != n2) {\n\t\t\tif (n)\n\t\t\t\tspin_unlock(&n->list_lock);\n\n\t\t\tn = n2;\n\t\t\tspin_lock(&n->list_lock);\n\t\t}\n\n\t\tdo {\n\n\t\t\told.freelist = page->freelist;\n\t\t\told.counters = page->counters;\n\t\t\tVM_BUG_ON(!old.frozen);\n\n\t\t\tnew.counters = old.counters;\n\t\t\tnew.freelist = old.freelist;\n\n\t\t\tnew.frozen = 0;\n\n\t\t} while (!__cmpxchg_double_slab(s, page,\n\t\t\t\told.freelist, old.counters,\n\t\t\t\tnew.freelist, new.counters,\n\t\t\t\t\"unfreezing slab\"));\n\n\t\tif (unlikely(!new.inuse && n->nr_partial >= s->min_partial)) {\n\t\t\tpage->next = discard_page;\n\t\t\tdiscard_page = page;\n\t\t} else {\n\t\t\tadd_partial(n, page, DEACTIVATE_TO_TAIL);\n\t\t\tstat(s, FREE_ADD_PARTIAL);\n\t\t}\n\t}\n\n\tif (n)\n\t\tspin_unlock(&n->list_lock);\n\n\twhile (discard_page) {\n\t\tpage = discard_page;\n\t\tdiscard_page = discard_page->next;\n\n\t\tstat(s, DEACTIVATE_EMPTY);\n\t\tdiscard_slab(s, page);\n\t\tstat(s, FREE_SLAB);\n\t}\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic void unfreeze_partials(struct kmem_cache *s,\n\t\tstruct kmem_cache_cpu *c)\n{\n#ifdef CONFIG_SLUB_CPU_PARTIAL\n\tstruct kmem_cache_node *n = NULL, *n2 = NULL;\n\tstruct page *page, *discard_page = NULL;\n\n\twhile ((page = c->partial)) {\n\t\tstruct page new;\n\t\tstruct page old;\n\n\t\tc->partial = page->next;\n\n\t\tn2 = get_node(s, page_to_nid(page));\n\t\tif (n != n2) {\n\t\t\tif (n)\n\t\t\t\tspin_unlock(&n->list_lock);\n\n\t\t\tn = n2;\n\t\t\tspin_lock(&n->list_lock);\n\t\t}\n\n\t\tdo {\n\n\t\t\told.freelist = page->freelist;\n\t\t\told.counters = page->counters;\n\t\t\tVM_BUG_ON(!old.frozen);\n\n\t\t\tnew.counters = old.counters;\n\t\t\tnew.freelist = old.freelist;\n\n\t\t\tnew.frozen = 0;\n\n\t\t} while (!__cmpxchg_double_slab(s, page,\n\t\t\t\told.freelist, old.counters,\n\t\t\t\tnew.freelist, new.counters,\n\t\t\t\t\"unfreezing slab\"));\n\n\t\tif (unlikely(!new.inuse && n->nr_partial >= s->min_partial)) {\n\t\t\tpage->next = discard_page;\n\t\t\tdiscard_page = page;\n\t\t} else {\n\t\t\tadd_partial(n, page, DEACTIVATE_TO_TAIL);\n\t\t\tstat(s, FREE_ADD_PARTIAL);\n\t\t}\n\t}\n\n\tif (n)\n\t\tspin_unlock(&n->list_lock);\n\n\twhile (discard_page) {\n\t\tpage = discard_page;\n\t\tdiscard_page = discard_page->next;\n\n\t\tstat(s, DEACTIVATE_EMPTY);\n\t\tdiscard_slab(s, page);\n\t\tstat(s, FREE_SLAB);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "s->cpu_slab"
          ],
          "line": 2292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 2291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!s->cpu_partial"
          ],
          "line": 2288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_cmpxchg",
          "args": [
            "s->cpu_slab->partial",
            "oldpage",
            "page"
          ],
          "line": 2286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "s",
            "CPU_PARTIAL_DRAIN"
          ],
          "line": 2275
        },
        "resolved": true,
        "details": {
          "function_name": "slabinfo_show_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "5900-5902",
          "snippet": "void slabinfo_show_stats(struct seq_file *m, struct kmem_cache *s)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid slabinfo_show_stats(struct seq_file *m, struct kmem_cache *s)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "s->cpu_slab"
          ],
          "line": 2270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 2269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_read",
          "args": [
            "s->cpu_slab->partial"
          ],
          "line": 2258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 2254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void put_cpu_partial(struct kmem_cache *s, struct page *page, int drain);\n\nstatic void put_cpu_partial(struct kmem_cache *s, struct page *page, int drain)\n{\n#ifdef CONFIG_SLUB_CPU_PARTIAL\n\tstruct page *oldpage;\n\tint pages;\n\tint pobjects;\n\n\tpreempt_disable();\n\tdo {\n\t\tpages = 0;\n\t\tpobjects = 0;\n\t\toldpage = this_cpu_read(s->cpu_slab->partial);\n\n\t\tif (oldpage) {\n\t\t\tpobjects = oldpage->pobjects;\n\t\t\tpages = oldpage->pages;\n\t\t\tif (drain && pobjects > s->cpu_partial) {\n\t\t\t\tunsigned long flags;\n\t\t\t\t/*\n\t\t\t\t * partial array is full. Move the existing\n\t\t\t\t * set to the per node partial list.\n\t\t\t\t */\n\t\t\t\tlocal_irq_save(flags);\n\t\t\t\tunfreeze_partials(s, this_cpu_ptr(s->cpu_slab));\n\t\t\t\tlocal_irq_restore(flags);\n\t\t\t\toldpage = NULL;\n\t\t\t\tpobjects = 0;\n\t\t\t\tpages = 0;\n\t\t\t\tstat(s, CPU_PARTIAL_DRAIN);\n\t\t\t}\n\t\t}\n\n\t\tpages++;\n\t\tpobjects += page->objects - page->inuse;\n\n\t\tpage->pages = pages;\n\t\tpage->pobjects = pobjects;\n\t\tpage->next = oldpage;\n\n\t} while (this_cpu_cmpxchg(s->cpu_slab->partial, oldpage, page)\n\t\t\t\t\t\t\t\t!= oldpage);\n\tif (unlikely(!s->cpu_partial)) {\n\t\tunsigned long flags;\n\n\t\tlocal_irq_save(flags);\n\t\tunfreeze_partials(s, this_cpu_ptr(s->cpu_slab));\n\t\tlocal_irq_restore(flags);\n\t}\n\tpreempt_enable();\n#endif\n}"
  },
  {
    "function_name": "unfreeze_partials",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "2179-2238",
    "snippet": "static void unfreeze_partials(struct kmem_cache *s,\n\t\tstruct kmem_cache_cpu *c)\n{\n#ifdef CONFIG_SLUB_CPU_PARTIAL\n\tstruct kmem_cache_node *n = NULL, *n2 = NULL;\n\tstruct page *page, *discard_page = NULL;\n\n\twhile ((page = c->partial)) {\n\t\tstruct page new;\n\t\tstruct page old;\n\n\t\tc->partial = page->next;\n\n\t\tn2 = get_node(s, page_to_nid(page));\n\t\tif (n != n2) {\n\t\t\tif (n)\n\t\t\t\tspin_unlock(&n->list_lock);\n\n\t\t\tn = n2;\n\t\t\tspin_lock(&n->list_lock);\n\t\t}\n\n\t\tdo {\n\n\t\t\told.freelist = page->freelist;\n\t\t\told.counters = page->counters;\n\t\t\tVM_BUG_ON(!old.frozen);\n\n\t\t\tnew.counters = old.counters;\n\t\t\tnew.freelist = old.freelist;\n\n\t\t\tnew.frozen = 0;\n\n\t\t} while (!__cmpxchg_double_slab(s, page,\n\t\t\t\told.freelist, old.counters,\n\t\t\t\tnew.freelist, new.counters,\n\t\t\t\t\"unfreezing slab\"));\n\n\t\tif (unlikely(!new.inuse && n->nr_partial >= s->min_partial)) {\n\t\t\tpage->next = discard_page;\n\t\t\tdiscard_page = page;\n\t\t} else {\n\t\t\tadd_partial(n, page, DEACTIVATE_TO_TAIL);\n\t\t\tstat(s, FREE_ADD_PARTIAL);\n\t\t}\n\t}\n\n\tif (n)\n\t\tspin_unlock(&n->list_lock);\n\n\twhile (discard_page) {\n\t\tpage = discard_page;\n\t\tdiscard_page = discard_page->next;\n\n\t\tstat(s, DEACTIVATE_EMPTY);\n\t\tdiscard_slab(s, page);\n\t\tstat(s, FREE_SLAB);\n\t}\n#endif\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *kmem_cache_node;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "s",
            "FREE_SLAB"
          ],
          "line": 2235
        },
        "resolved": true,
        "details": {
          "function_name": "slabinfo_show_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "5900-5902",
          "snippet": "void slabinfo_show_stats(struct seq_file *m, struct kmem_cache *s)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid slabinfo_show_stats(struct seq_file *m, struct kmem_cache *s)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "discard_slab",
          "args": [
            "s",
            "page"
          ],
          "line": 2234
        },
        "resolved": true,
        "details": {
          "function_name": "discard_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1740-1744",
          "snippet": "static void discard_slab(struct kmem_cache *s, struct page *page)\n{\n\tdec_slabs_node(s, page_to_nid(page), page->objects);\n\tfree_slab(s, page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void discard_slab(struct kmem_cache *s, struct page *page)\n{\n\tdec_slabs_node(s, page_to_nid(page), page->objects);\n\tfree_slab(s, page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&n->list_lock"
          ],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_partial",
          "args": [
            "n",
            "page",
            "DEACTIVATE_TO_TAIL"
          ],
          "line": 2221
        },
        "resolved": true,
        "details": {
          "function_name": "add_partial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1759-1764",
          "snippet": "static inline void add_partial(struct kmem_cache_node *n,\n\t\t\t\tstruct page *page, int tail)\n{\n\tlockdep_assert_held(&n->list_lock);\n\t__add_partial(n, page, tail);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic inline void add_partial(struct kmem_cache_node *n,\n\t\t\t\tstruct page *page, int tail)\n{\n\tlockdep_assert_held(&n->list_lock);\n\t__add_partial(n, page, tail);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!new.inuse && n->nr_partial >= s->min_partial"
          ],
          "line": 2217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cmpxchg_double_slab",
          "args": [
            "s",
            "page",
            "old.freelist",
            "old.counters",
            "new.freelist",
            "new.counters",
            "\"unfreezing slab\""
          ],
          "line": 2212
        },
        "resolved": true,
        "details": {
          "function_name": "__cmpxchg_double_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "358-393",
          "snippet": "static inline bool __cmpxchg_double_slab(struct kmem_cache *s, struct page *page,\n\t\tvoid *freelist_old, unsigned long counters_old,\n\t\tvoid *freelist_new, unsigned long counters_new,\n\t\tconst char *n)\n{\n\tVM_BUG_ON(!irqs_disabled());\n#if defined(CONFIG_HAVE_CMPXCHG_DOUBLE) && \\\n    defined(CONFIG_HAVE_ALIGNED_STRUCT_PAGE)\n\tif (s->flags & __CMPXCHG_DOUBLE) {\n\t\tif (cmpxchg_double(&page->freelist, &page->counters,\n\t\t\t\t   freelist_old, counters_old,\n\t\t\t\t   freelist_new, counters_new))\n\t\t\treturn true;\n\t} else\n#endif\n\t{\n\t\tslab_lock(page);\n\t\tif (page->freelist == freelist_old &&\n\t\t\t\t\tpage->counters == counters_old) {\n\t\t\tpage->freelist = freelist_new;\n\t\t\tpage->counters = counters_new;\n\t\t\tslab_unlock(page);\n\t\t\treturn true;\n\t\t}\n\t\tslab_unlock(page);\n\t}\n\n\tcpu_relax();\n\tstat(s, CMPXCHG_DOUBLE_FAIL);\n\n#ifdef SLUB_DEBUG_CMPXCHG\n\tpr_info(\"%s %s: cmpxchg double redo \", n, s->name);\n#endif\n\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define __CMPXCHG_DOUBLE\t((slab_flags_t __force)0x40000000U)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define __CMPXCHG_DOUBLE\t((slab_flags_t __force)0x40000000U)\n\nstatic inline bool __cmpxchg_double_slab(struct kmem_cache *s, struct page *page,\n\t\tvoid *freelist_old, unsigned long counters_old,\n\t\tvoid *freelist_new, unsigned long counters_new,\n\t\tconst char *n)\n{\n\tVM_BUG_ON(!irqs_disabled());\n#if defined(CONFIG_HAVE_CMPXCHG_DOUBLE) && \\\n    defined(CONFIG_HAVE_ALIGNED_STRUCT_PAGE)\n\tif (s->flags & __CMPXCHG_DOUBLE) {\n\t\tif (cmpxchg_double(&page->freelist, &page->counters,\n\t\t\t\t   freelist_old, counters_old,\n\t\t\t\t   freelist_new, counters_new))\n\t\t\treturn true;\n\t} else\n#endif\n\t{\n\t\tslab_lock(page);\n\t\tif (page->freelist == freelist_old &&\n\t\t\t\t\tpage->counters == counters_old) {\n\t\t\tpage->freelist = freelist_new;\n\t\t\tpage->counters = counters_new;\n\t\t\tslab_unlock(page);\n\t\t\treturn true;\n\t\t}\n\t\tslab_unlock(page);\n\t}\n\n\tcpu_relax();\n\tstat(s, CMPXCHG_DOUBLE_FAIL);\n\n#ifdef SLUB_DEBUG_CMPXCHG\n\tpr_info(\"%s %s: cmpxchg double redo \", n, s->name);\n#endif\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!old.frozen"
          ],
          "line": 2205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&n->list_lock"
          ],
          "line": 2198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&n->list_lock"
          ],
          "line": 2195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node",
          "args": [
            "s",
            "page_to_nid(page)"
          ],
          "line": 2192
        },
        "resolved": true,
        "details": {
          "function_name": "get_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "485-488",
          "snippet": "static inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 2192
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic void unfreeze_partials(struct kmem_cache *s,\n\t\tstruct kmem_cache_cpu *c)\n{\n#ifdef CONFIG_SLUB_CPU_PARTIAL\n\tstruct kmem_cache_node *n = NULL, *n2 = NULL;\n\tstruct page *page, *discard_page = NULL;\n\n\twhile ((page = c->partial)) {\n\t\tstruct page new;\n\t\tstruct page old;\n\n\t\tc->partial = page->next;\n\n\t\tn2 = get_node(s, page_to_nid(page));\n\t\tif (n != n2) {\n\t\t\tif (n)\n\t\t\t\tspin_unlock(&n->list_lock);\n\n\t\t\tn = n2;\n\t\t\tspin_lock(&n->list_lock);\n\t\t}\n\n\t\tdo {\n\n\t\t\told.freelist = page->freelist;\n\t\t\told.counters = page->counters;\n\t\t\tVM_BUG_ON(!old.frozen);\n\n\t\t\tnew.counters = old.counters;\n\t\t\tnew.freelist = old.freelist;\n\n\t\t\tnew.frozen = 0;\n\n\t\t} while (!__cmpxchg_double_slab(s, page,\n\t\t\t\told.freelist, old.counters,\n\t\t\t\tnew.freelist, new.counters,\n\t\t\t\t\"unfreezing slab\"));\n\n\t\tif (unlikely(!new.inuse && n->nr_partial >= s->min_partial)) {\n\t\t\tpage->next = discard_page;\n\t\t\tdiscard_page = page;\n\t\t} else {\n\t\t\tadd_partial(n, page, DEACTIVATE_TO_TAIL);\n\t\t\tstat(s, FREE_ADD_PARTIAL);\n\t\t}\n\t}\n\n\tif (n)\n\t\tspin_unlock(&n->list_lock);\n\n\twhile (discard_page) {\n\t\tpage = discard_page;\n\t\tdiscard_page = discard_page->next;\n\n\t\tstat(s, DEACTIVATE_EMPTY);\n\t\tdiscard_slab(s, page);\n\t\tstat(s, FREE_SLAB);\n\t}\n#endif\n}"
  },
  {
    "function_name": "deactivate_slab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "2027-2170",
    "snippet": "static void deactivate_slab(struct kmem_cache *s, struct page *page,\n\t\t\t\tvoid *freelist, struct kmem_cache_cpu *c)\n{\n\tenum slab_modes { M_NONE, M_PARTIAL, M_FULL, M_FREE };\n\tstruct kmem_cache_node *n = get_node(s, page_to_nid(page));\n\tint lock = 0;\n\tenum slab_modes l = M_NONE, m = M_NONE;\n\tvoid *nextfree;\n\tint tail = DEACTIVATE_TO_HEAD;\n\tstruct page new;\n\tstruct page old;\n\n\tif (page->freelist) {\n\t\tstat(s, DEACTIVATE_REMOTE_FREES);\n\t\ttail = DEACTIVATE_TO_TAIL;\n\t}\n\n\t/*\n\t * Stage one: Free all available per cpu objects back\n\t * to the page freelist while it is still frozen. Leave the\n\t * last one.\n\t *\n\t * There is no need to take the list->lock because the page\n\t * is still frozen.\n\t */\n\twhile (freelist && (nextfree = get_freepointer(s, freelist))) {\n\t\tvoid *prior;\n\t\tunsigned long counters;\n\n\t\tdo {\n\t\t\tprior = page->freelist;\n\t\t\tcounters = page->counters;\n\t\t\tset_freepointer(s, freelist, prior);\n\t\t\tnew.counters = counters;\n\t\t\tnew.inuse--;\n\t\t\tVM_BUG_ON(!new.frozen);\n\n\t\t} while (!__cmpxchg_double_slab(s, page,\n\t\t\tprior, counters,\n\t\t\tfreelist, new.counters,\n\t\t\t\"drain percpu freelist\"));\n\n\t\tfreelist = nextfree;\n\t}\n\n\t/*\n\t * Stage two: Ensure that the page is unfrozen while the\n\t * list presence reflects the actual number of objects\n\t * during unfreeze.\n\t *\n\t * We setup the list membership and then perform a cmpxchg\n\t * with the count. If there is a mismatch then the page\n\t * is not unfrozen but the page is on the wrong list.\n\t *\n\t * Then we restart the process which may have to remove\n\t * the page from the list that we just put it on again\n\t * because the number of objects in the slab may have\n\t * changed.\n\t */\nredo:\n\n\told.freelist = page->freelist;\n\told.counters = page->counters;\n\tVM_BUG_ON(!old.frozen);\n\n\t/* Determine target state of the slab */\n\tnew.counters = old.counters;\n\tif (freelist) {\n\t\tnew.inuse--;\n\t\tset_freepointer(s, freelist, old.freelist);\n\t\tnew.freelist = freelist;\n\t} else\n\t\tnew.freelist = old.freelist;\n\n\tnew.frozen = 0;\n\n\tif (!new.inuse && n->nr_partial >= s->min_partial)\n\t\tm = M_FREE;\n\telse if (new.freelist) {\n\t\tm = M_PARTIAL;\n\t\tif (!lock) {\n\t\t\tlock = 1;\n\t\t\t/*\n\t\t\t * Taking the spinlock removes the possiblity\n\t\t\t * that acquire_slab() will see a slab page that\n\t\t\t * is frozen\n\t\t\t */\n\t\t\tspin_lock(&n->list_lock);\n\t\t}\n\t} else {\n\t\tm = M_FULL;\n\t\tif (kmem_cache_debug(s) && !lock) {\n\t\t\tlock = 1;\n\t\t\t/*\n\t\t\t * This also ensures that the scanning of full\n\t\t\t * slabs from diagnostic functions will not see\n\t\t\t * any frozen slabs.\n\t\t\t */\n\t\t\tspin_lock(&n->list_lock);\n\t\t}\n\t}\n\n\tif (l != m) {\n\n\t\tif (l == M_PARTIAL)\n\n\t\t\tremove_partial(n, page);\n\n\t\telse if (l == M_FULL)\n\n\t\t\tremove_full(s, n, page);\n\n\t\tif (m == M_PARTIAL) {\n\n\t\t\tadd_partial(n, page, tail);\n\t\t\tstat(s, tail);\n\n\t\t} else if (m == M_FULL) {\n\n\t\t\tstat(s, DEACTIVATE_FULL);\n\t\t\tadd_full(s, n, page);\n\n\t\t}\n\t}\n\n\tl = m;\n\tif (!__cmpxchg_double_slab(s, page,\n\t\t\t\told.freelist, old.counters,\n\t\t\t\tnew.freelist, new.counters,\n\t\t\t\t\"unfreezing slab\"))\n\t\tgoto redo;\n\n\tif (lock)\n\t\tspin_unlock(&n->list_lock);\n\n\tif (m == M_FREE) {\n\t\tstat(s, DEACTIVATE_EMPTY);\n\t\tdiscard_slab(s, page);\n\t\tstat(s, FREE_SLAB);\n\t}\n\n\tc->page = NULL;\n\tc->freelist = NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void put_cpu_partial(struct kmem_cache *s, struct page *page, int drain);",
      "static struct kmem_cache *kmem_cache_node;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "s",
            "FREE_SLAB"
          ],
          "line": 2165
        },
        "resolved": true,
        "details": {
          "function_name": "slabinfo_show_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "5900-5902",
          "snippet": "void slabinfo_show_stats(struct seq_file *m, struct kmem_cache *s)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid slabinfo_show_stats(struct seq_file *m, struct kmem_cache *s)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "discard_slab",
          "args": [
            "s",
            "page"
          ],
          "line": 2164
        },
        "resolved": true,
        "details": {
          "function_name": "discard_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1740-1744",
          "snippet": "static void discard_slab(struct kmem_cache *s, struct page *page)\n{\n\tdec_slabs_node(s, page_to_nid(page), page->objects);\n\tfree_slab(s, page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void discard_slab(struct kmem_cache *s, struct page *page)\n{\n\tdec_slabs_node(s, page_to_nid(page), page->objects);\n\tfree_slab(s, page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&n->list_lock"
          ],
          "line": 2160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cmpxchg_double_slab",
          "args": [
            "s",
            "page",
            "old.freelist",
            "old.counters",
            "new.freelist",
            "new.counters",
            "\"unfreezing slab\""
          ],
          "line": 2153
        },
        "resolved": true,
        "details": {
          "function_name": "__cmpxchg_double_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "358-393",
          "snippet": "static inline bool __cmpxchg_double_slab(struct kmem_cache *s, struct page *page,\n\t\tvoid *freelist_old, unsigned long counters_old,\n\t\tvoid *freelist_new, unsigned long counters_new,\n\t\tconst char *n)\n{\n\tVM_BUG_ON(!irqs_disabled());\n#if defined(CONFIG_HAVE_CMPXCHG_DOUBLE) && \\\n    defined(CONFIG_HAVE_ALIGNED_STRUCT_PAGE)\n\tif (s->flags & __CMPXCHG_DOUBLE) {\n\t\tif (cmpxchg_double(&page->freelist, &page->counters,\n\t\t\t\t   freelist_old, counters_old,\n\t\t\t\t   freelist_new, counters_new))\n\t\t\treturn true;\n\t} else\n#endif\n\t{\n\t\tslab_lock(page);\n\t\tif (page->freelist == freelist_old &&\n\t\t\t\t\tpage->counters == counters_old) {\n\t\t\tpage->freelist = freelist_new;\n\t\t\tpage->counters = counters_new;\n\t\t\tslab_unlock(page);\n\t\t\treturn true;\n\t\t}\n\t\tslab_unlock(page);\n\t}\n\n\tcpu_relax();\n\tstat(s, CMPXCHG_DOUBLE_FAIL);\n\n#ifdef SLUB_DEBUG_CMPXCHG\n\tpr_info(\"%s %s: cmpxchg double redo \", n, s->name);\n#endif\n\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define __CMPXCHG_DOUBLE\t((slab_flags_t __force)0x40000000U)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define __CMPXCHG_DOUBLE\t((slab_flags_t __force)0x40000000U)\n\nstatic inline bool __cmpxchg_double_slab(struct kmem_cache *s, struct page *page,\n\t\tvoid *freelist_old, unsigned long counters_old,\n\t\tvoid *freelist_new, unsigned long counters_new,\n\t\tconst char *n)\n{\n\tVM_BUG_ON(!irqs_disabled());\n#if defined(CONFIG_HAVE_CMPXCHG_DOUBLE) && \\\n    defined(CONFIG_HAVE_ALIGNED_STRUCT_PAGE)\n\tif (s->flags & __CMPXCHG_DOUBLE) {\n\t\tif (cmpxchg_double(&page->freelist, &page->counters,\n\t\t\t\t   freelist_old, counters_old,\n\t\t\t\t   freelist_new, counters_new))\n\t\t\treturn true;\n\t} else\n#endif\n\t{\n\t\tslab_lock(page);\n\t\tif (page->freelist == freelist_old &&\n\t\t\t\t\tpage->counters == counters_old) {\n\t\t\tpage->freelist = freelist_new;\n\t\t\tpage->counters = counters_new;\n\t\t\tslab_unlock(page);\n\t\t\treturn true;\n\t\t}\n\t\tslab_unlock(page);\n\t}\n\n\tcpu_relax();\n\tstat(s, CMPXCHG_DOUBLE_FAIL);\n\n#ifdef SLUB_DEBUG_CMPXCHG\n\tpr_info(\"%s %s: cmpxchg double redo \", n, s->name);\n#endif\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_full",
          "args": [
            "s",
            "n",
            "page"
          ],
          "line": 2147
        },
        "resolved": true,
        "details": {
          "function_name": "add_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1346-1347",
          "snippet": "static inline void add_full(struct kmem_cache *s, struct kmem_cache_node *n,\n\t\t\t\t\tstruct page *page) {}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic inline void add_full(struct kmem_cache *s, struct kmem_cache_node *n,\n\t\t\t\t\tstruct page *page) {}"
        }
      },
      {
        "call_info": {
          "callee": "add_partial",
          "args": [
            "n",
            "page",
            "tail"
          ],
          "line": 2141
        },
        "resolved": true,
        "details": {
          "function_name": "add_partial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1759-1764",
          "snippet": "static inline void add_partial(struct kmem_cache_node *n,\n\t\t\t\tstruct page *page, int tail)\n{\n\tlockdep_assert_held(&n->list_lock);\n\t__add_partial(n, page, tail);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic inline void add_partial(struct kmem_cache_node *n,\n\t\t\t\tstruct page *page, int tail)\n{\n\tlockdep_assert_held(&n->list_lock);\n\t__add_partial(n, page, tail);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_full",
          "args": [
            "s",
            "n",
            "page"
          ],
          "line": 2137
        },
        "resolved": true,
        "details": {
          "function_name": "remove_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1348-1349",
          "snippet": "static inline void remove_full(struct kmem_cache *s, struct kmem_cache_node *n,\n\t\t\t\t\tstruct page *page) {}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic inline void remove_full(struct kmem_cache *s, struct kmem_cache_node *n,\n\t\t\t\t\tstruct page *page) {}"
        }
      },
      {
        "call_info": {
          "callee": "remove_partial",
          "args": [
            "n",
            "page"
          ],
          "line": 2133
        },
        "resolved": true,
        "details": {
          "function_name": "remove_partial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1766-1772",
          "snippet": "static inline void remove_partial(struct kmem_cache_node *n,\n\t\t\t\t\tstruct page *page)\n{\n\tlockdep_assert_held(&n->list_lock);\n\tlist_del(&page->lru);\n\tn->nr_partial--;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic inline void remove_partial(struct kmem_cache_node *n,\n\t\t\t\t\tstruct page *page)\n{\n\tlockdep_assert_held(&n->list_lock);\n\tlist_del(&page->lru);\n\tn->nr_partial--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&n->list_lock"
          ],
          "line": 2125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_debug",
          "args": [
            "s"
          ],
          "line": 2118
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "118-125",
          "snippet": "static inline int kmem_cache_debug(struct kmem_cache *s)\n{\n#ifdef CONFIG_SLUB_DEBUG\n\treturn unlikely(s->flags & SLAB_DEBUG_FLAGS);\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline int kmem_cache_debug(struct kmem_cache *s)\n{\n#ifdef CONFIG_SLUB_DEBUG\n\treturn unlikely(s->flags & SLAB_DEBUG_FLAGS);\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&n->list_lock"
          ],
          "line": 2114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_freepointer",
          "args": [
            "s",
            "freelist",
            "old.freelist"
          ],
          "line": 2096
        },
        "resolved": true,
        "details": {
          "function_name": "set_freepointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "289-298",
          "snippet": "static inline void set_freepointer(struct kmem_cache *s, void *object, void *fp)\n{\n\tunsigned long freeptr_addr = (unsigned long)object + s->offset;\n\n#ifdef CONFIG_SLAB_FREELIST_HARDENED\n\tBUG_ON(object == fp); /* naive detection of double free or corruption */\n#endif\n\n\t*(void **)freeptr_addr = freelist_ptr(s, fp, freeptr_addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void set_freepointer(struct kmem_cache *s, void *object, void *fp)\n{\n\tunsigned long freeptr_addr = (unsigned long)object + s->offset;\n\n#ifdef CONFIG_SLAB_FREELIST_HARDENED\n\tBUG_ON(object == fp); /* naive detection of double free or corruption */\n#endif\n\n\t*(void **)freeptr_addr = freelist_ptr(s, fp, freeptr_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!old.frozen"
          ],
          "line": 2090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!new.frozen"
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_freepointer",
          "args": [
            "s",
            "freelist"
          ],
          "line": 2052
        },
        "resolved": true,
        "details": {
          "function_name": "get_freepointer_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "276-287",
          "snippet": "static inline void *get_freepointer_safe(struct kmem_cache *s, void *object)\n{\n\tunsigned long freepointer_addr;\n\tvoid *p;\n\n\tif (!debug_pagealloc_enabled())\n\t\treturn get_freepointer(s, object);\n\n\tfreepointer_addr = (unsigned long)object + s->offset;\n\tprobe_kernel_read(&p, (void **)freepointer_addr, sizeof(p));\n\treturn freelist_ptr(s, p, freepointer_addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void *get_freepointer_safe(struct kmem_cache *s, void *object)\n{\n\tunsigned long freepointer_addr;\n\tvoid *p;\n\n\tif (!debug_pagealloc_enabled())\n\t\treturn get_freepointer(s, object);\n\n\tfreepointer_addr = (unsigned long)object + s->offset;\n\tprobe_kernel_read(&p, (void **)freepointer_addr, sizeof(p));\n\treturn freelist_ptr(s, p, freepointer_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node",
          "args": [
            "s",
            "page_to_nid(page)"
          ],
          "line": 2031
        },
        "resolved": true,
        "details": {
          "function_name": "get_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "485-488",
          "snippet": "static inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 2031
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void put_cpu_partial(struct kmem_cache *s, struct page *page, int drain);\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic void deactivate_slab(struct kmem_cache *s, struct page *page,\n\t\t\t\tvoid *freelist, struct kmem_cache_cpu *c)\n{\n\tenum slab_modes { M_NONE, M_PARTIAL, M_FULL, M_FREE };\n\tstruct kmem_cache_node *n = get_node(s, page_to_nid(page));\n\tint lock = 0;\n\tenum slab_modes l = M_NONE, m = M_NONE;\n\tvoid *nextfree;\n\tint tail = DEACTIVATE_TO_HEAD;\n\tstruct page new;\n\tstruct page old;\n\n\tif (page->freelist) {\n\t\tstat(s, DEACTIVATE_REMOTE_FREES);\n\t\ttail = DEACTIVATE_TO_TAIL;\n\t}\n\n\t/*\n\t * Stage one: Free all available per cpu objects back\n\t * to the page freelist while it is still frozen. Leave the\n\t * last one.\n\t *\n\t * There is no need to take the list->lock because the page\n\t * is still frozen.\n\t */\n\twhile (freelist && (nextfree = get_freepointer(s, freelist))) {\n\t\tvoid *prior;\n\t\tunsigned long counters;\n\n\t\tdo {\n\t\t\tprior = page->freelist;\n\t\t\tcounters = page->counters;\n\t\t\tset_freepointer(s, freelist, prior);\n\t\t\tnew.counters = counters;\n\t\t\tnew.inuse--;\n\t\t\tVM_BUG_ON(!new.frozen);\n\n\t\t} while (!__cmpxchg_double_slab(s, page,\n\t\t\tprior, counters,\n\t\t\tfreelist, new.counters,\n\t\t\t\"drain percpu freelist\"));\n\n\t\tfreelist = nextfree;\n\t}\n\n\t/*\n\t * Stage two: Ensure that the page is unfrozen while the\n\t * list presence reflects the actual number of objects\n\t * during unfreeze.\n\t *\n\t * We setup the list membership and then perform a cmpxchg\n\t * with the count. If there is a mismatch then the page\n\t * is not unfrozen but the page is on the wrong list.\n\t *\n\t * Then we restart the process which may have to remove\n\t * the page from the list that we just put it on again\n\t * because the number of objects in the slab may have\n\t * changed.\n\t */\nredo:\n\n\told.freelist = page->freelist;\n\told.counters = page->counters;\n\tVM_BUG_ON(!old.frozen);\n\n\t/* Determine target state of the slab */\n\tnew.counters = old.counters;\n\tif (freelist) {\n\t\tnew.inuse--;\n\t\tset_freepointer(s, freelist, old.freelist);\n\t\tnew.freelist = freelist;\n\t} else\n\t\tnew.freelist = old.freelist;\n\n\tnew.frozen = 0;\n\n\tif (!new.inuse && n->nr_partial >= s->min_partial)\n\t\tm = M_FREE;\n\telse if (new.freelist) {\n\t\tm = M_PARTIAL;\n\t\tif (!lock) {\n\t\t\tlock = 1;\n\t\t\t/*\n\t\t\t * Taking the spinlock removes the possiblity\n\t\t\t * that acquire_slab() will see a slab page that\n\t\t\t * is frozen\n\t\t\t */\n\t\t\tspin_lock(&n->list_lock);\n\t\t}\n\t} else {\n\t\tm = M_FULL;\n\t\tif (kmem_cache_debug(s) && !lock) {\n\t\t\tlock = 1;\n\t\t\t/*\n\t\t\t * This also ensures that the scanning of full\n\t\t\t * slabs from diagnostic functions will not see\n\t\t\t * any frozen slabs.\n\t\t\t */\n\t\t\tspin_lock(&n->list_lock);\n\t\t}\n\t}\n\n\tif (l != m) {\n\n\t\tif (l == M_PARTIAL)\n\n\t\t\tremove_partial(n, page);\n\n\t\telse if (l == M_FULL)\n\n\t\t\tremove_full(s, n, page);\n\n\t\tif (m == M_PARTIAL) {\n\n\t\t\tadd_partial(n, page, tail);\n\t\t\tstat(s, tail);\n\n\t\t} else if (m == M_FULL) {\n\n\t\t\tstat(s, DEACTIVATE_FULL);\n\t\t\tadd_full(s, n, page);\n\n\t\t}\n\t}\n\n\tl = m;\n\tif (!__cmpxchg_double_slab(s, page,\n\t\t\t\told.freelist, old.counters,\n\t\t\t\tnew.freelist, new.counters,\n\t\t\t\t\"unfreezing slab\"))\n\t\tgoto redo;\n\n\tif (lock)\n\t\tspin_unlock(&n->list_lock);\n\n\tif (m == M_FREE) {\n\t\tstat(s, DEACTIVATE_EMPTY);\n\t\tdiscard_slab(s, page);\n\t\tstat(s, FREE_SLAB);\n\t}\n\n\tc->page = NULL;\n\tc->freelist = NULL;\n}"
  },
  {
    "function_name": "init_kmem_cache_cpus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "2016-2022",
    "snippet": "static void init_kmem_cache_cpus(struct kmem_cache *s)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu_ptr(s->cpu_slab, cpu)->tid = init_tid(cpu);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_tid",
          "args": [
            "cpu"
          ],
          "line": 2021
        },
        "resolved": true,
        "details": {
          "function_name": "init_tid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1987-1990",
          "snippet": "static inline unsigned int init_tid(int cpu)\n{\n\treturn cpu;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline unsigned int init_tid(int cpu)\n{\n\treturn cpu;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void init_kmem_cache_cpus(struct kmem_cache *s)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu_ptr(s->cpu_slab, cpu)->tid = init_tid(cpu);\n}"
  },
  {
    "function_name": "note_cmpxchg_failure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1992-2014",
    "snippet": "static inline void note_cmpxchg_failure(const char *n,\n\t\tconst struct kmem_cache *s, unsigned long tid)\n{\n#ifdef SLUB_DEBUG_CMPXCHG\n\tunsigned long actual_tid = __this_cpu_read(s->cpu_slab->tid);\n\n\tpr_info(\"%s %s: cmpxchg redo \", n, s->name);\n\n#ifdef CONFIG_PREEMPT\n\tif (tid_to_cpu(tid) != tid_to_cpu(actual_tid))\n\t\tpr_warn(\"due to cpu change %d -> %d\\n\",\n\t\t\ttid_to_cpu(tid), tid_to_cpu(actual_tid));\n\telse\n#endif\n\tif (tid_to_event(tid) != tid_to_event(actual_tid))\n\t\tpr_warn(\"due to cpu running other code. Event %ld->%ld\\n\",\n\t\t\ttid_to_event(tid), tid_to_event(actual_tid));\n\telse\n\t\tpr_warn(\"for unknown reason: actual=%lx was=%lx target=%lx\\n\",\n\t\t\tactual_tid, tid, next_tid(tid));\n#endif\n\tstat(s, CMPXCHG_DOUBLE_CPU_FAIL);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "s",
            "CMPXCHG_DOUBLE_CPU_FAIL"
          ],
          "line": 2013
        },
        "resolved": true,
        "details": {
          "function_name": "slabinfo_show_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "5900-5902",
          "snippet": "void slabinfo_show_stats(struct seq_file *m, struct kmem_cache *s)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid slabinfo_show_stats(struct seq_file *m, struct kmem_cache *s)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"for unknown reason: actual=%lx was=%lx target=%lx\\n\"",
            "actual_tid",
            "tid",
            "next_tid(tid)"
          ],
          "line": 2010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_tid",
          "args": [
            "tid"
          ],
          "line": 2011
        },
        "resolved": true,
        "details": {
          "function_name": "next_tid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1972-1975",
          "snippet": "static inline unsigned long next_tid(unsigned long tid)\n{\n\treturn tid + TID_STEP;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define TID_STEP 1",
            "#define TID_STEP  roundup_pow_of_two(CONFIG_NR_CPUS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define TID_STEP 1\n#define TID_STEP  roundup_pow_of_two(CONFIG_NR_CPUS)\n\nstatic inline unsigned long next_tid(unsigned long tid)\n{\n\treturn tid + TID_STEP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"due to cpu running other code. Event %ld->%ld\\n\"",
            "tid_to_event(tid)",
            "tid_to_event(actual_tid)"
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tid_to_event",
          "args": [
            "actual_tid"
          ],
          "line": 2008
        },
        "resolved": true,
        "details": {
          "function_name": "tid_to_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1982-1985",
          "snippet": "static inline unsigned long tid_to_event(unsigned long tid)\n{\n\treturn tid / TID_STEP;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define TID_STEP 1",
            "#define TID_STEP  roundup_pow_of_two(CONFIG_NR_CPUS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define TID_STEP 1\n#define TID_STEP  roundup_pow_of_two(CONFIG_NR_CPUS)\n\nstatic inline unsigned long tid_to_event(unsigned long tid)\n{\n\treturn tid / TID_STEP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"due to cpu change %d -> %d\\n\"",
            "tid_to_cpu(tid)",
            "tid_to_cpu(actual_tid)"
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tid_to_cpu",
          "args": [
            "actual_tid"
          ],
          "line": 2003
        },
        "resolved": true,
        "details": {
          "function_name": "tid_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1977-1980",
          "snippet": "static inline unsigned int tid_to_cpu(unsigned long tid)\n{\n\treturn tid % TID_STEP;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define TID_STEP 1",
            "#define TID_STEP  roundup_pow_of_two(CONFIG_NR_CPUS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define TID_STEP 1\n#define TID_STEP  roundup_pow_of_two(CONFIG_NR_CPUS)\n\nstatic inline unsigned int tid_to_cpu(unsigned long tid)\n{\n\treturn tid % TID_STEP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s %s: cmpxchg redo \"",
            "n",
            "s->name"
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "s->cpu_slab->tid"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void note_cmpxchg_failure(const char *n,\n\t\tconst struct kmem_cache *s, unsigned long tid)\n{\n#ifdef SLUB_DEBUG_CMPXCHG\n\tunsigned long actual_tid = __this_cpu_read(s->cpu_slab->tid);\n\n\tpr_info(\"%s %s: cmpxchg redo \", n, s->name);\n\n#ifdef CONFIG_PREEMPT\n\tif (tid_to_cpu(tid) != tid_to_cpu(actual_tid))\n\t\tpr_warn(\"due to cpu change %d -> %d\\n\",\n\t\t\ttid_to_cpu(tid), tid_to_cpu(actual_tid));\n\telse\n#endif\n\tif (tid_to_event(tid) != tid_to_event(actual_tid))\n\t\tpr_warn(\"due to cpu running other code. Event %ld->%ld\\n\",\n\t\t\ttid_to_event(tid), tid_to_event(actual_tid));\n\telse\n\t\tpr_warn(\"for unknown reason: actual=%lx was=%lx target=%lx\\n\",\n\t\t\tactual_tid, tid, next_tid(tid));\n#endif\n\tstat(s, CMPXCHG_DOUBLE_CPU_FAIL);\n}"
  },
  {
    "function_name": "init_tid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1987-1990",
    "snippet": "static inline unsigned int init_tid(int cpu)\n{\n\treturn cpu;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline unsigned int init_tid(int cpu)\n{\n\treturn cpu;\n}"
  },
  {
    "function_name": "tid_to_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1982-1985",
    "snippet": "static inline unsigned long tid_to_event(unsigned long tid)\n{\n\treturn tid / TID_STEP;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define TID_STEP 1",
      "#define TID_STEP  roundup_pow_of_two(CONFIG_NR_CPUS)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define TID_STEP 1\n#define TID_STEP  roundup_pow_of_two(CONFIG_NR_CPUS)\n\nstatic inline unsigned long tid_to_event(unsigned long tid)\n{\n\treturn tid / TID_STEP;\n}"
  },
  {
    "function_name": "tid_to_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1977-1980",
    "snippet": "static inline unsigned int tid_to_cpu(unsigned long tid)\n{\n\treturn tid % TID_STEP;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define TID_STEP 1",
      "#define TID_STEP  roundup_pow_of_two(CONFIG_NR_CPUS)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define TID_STEP 1\n#define TID_STEP  roundup_pow_of_two(CONFIG_NR_CPUS)\n\nstatic inline unsigned int tid_to_cpu(unsigned long tid)\n{\n\treturn tid % TID_STEP;\n}"
  },
  {
    "function_name": "next_tid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1972-1975",
    "snippet": "static inline unsigned long next_tid(unsigned long tid)\n{\n\treturn tid + TID_STEP;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define TID_STEP 1",
      "#define TID_STEP  roundup_pow_of_two(CONFIG_NR_CPUS)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define TID_STEP 1\n#define TID_STEP  roundup_pow_of_two(CONFIG_NR_CPUS)\n\nstatic inline unsigned long next_tid(unsigned long tid)\n{\n\treturn tid + TID_STEP;\n}"
  },
  {
    "function_name": "get_partial",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1939-1955",
    "snippet": "static void *get_partial(struct kmem_cache *s, gfp_t flags, int node,\n\t\tstruct kmem_cache_cpu *c)\n{\n\tvoid *object;\n\tint searchnode = node;\n\n\tif (node == NUMA_NO_NODE)\n\t\tsearchnode = numa_mem_id();\n\telse if (!node_present_pages(node))\n\t\tsearchnode = node_to_mem_node(node);\n\n\tobject = get_partial_node(s, get_node(s, searchnode), c, flags);\n\tif (object || node != NUMA_NO_NODE)\n\t\treturn object;\n\n\treturn get_any_partial(s, flags, c);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_any_partial",
          "args": [
            "s",
            "flags",
            "c"
          ],
          "line": 1954
        },
        "resolved": true,
        "details": {
          "function_name": "get_any_partial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1875-1934",
          "snippet": "static void *get_any_partial(struct kmem_cache *s, gfp_t flags,\n\t\tstruct kmem_cache_cpu *c)\n{\n#ifdef CONFIG_NUMA\n\tstruct zonelist *zonelist;\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\tenum zone_type high_zoneidx = gfp_zone(flags);\n\tvoid *object;\n\tunsigned int cpuset_mems_cookie;\n\n\t/*\n\t * The defrag ratio allows a configuration of the tradeoffs between\n\t * inter node defragmentation and node local allocations. A lower\n\t * defrag_ratio increases the tendency to do local allocations\n\t * instead of attempting to obtain partial slabs from other nodes.\n\t *\n\t * If the defrag_ratio is set to 0 then kmalloc() always\n\t * returns node local objects. If the ratio is higher then kmalloc()\n\t * may return off node objects because partial slabs are obtained\n\t * from other nodes and filled up.\n\t *\n\t * If /sys/kernel/slab/xx/remote_node_defrag_ratio is set to 100\n\t * (which makes defrag_ratio = 1000) then every (well almost)\n\t * allocation will first attempt to defrag slab caches on other nodes.\n\t * This means scanning over all nodes to look for partial slabs which\n\t * may be expensive if we do it every time we are trying to find a slab\n\t * with available objects.\n\t */\n\tif (!s->remote_node_defrag_ratio ||\n\t\t\tget_cycles() % 1024 > s->remote_node_defrag_ratio)\n\t\treturn NULL;\n\n\tdo {\n\t\tcpuset_mems_cookie = read_mems_allowed_begin();\n\t\tzonelist = node_zonelist(mempolicy_slab_node(), flags);\n\t\tfor_each_zone_zonelist(zone, z, zonelist, high_zoneidx) {\n\t\t\tstruct kmem_cache_node *n;\n\n\t\t\tn = get_node(s, zone_to_nid(zone));\n\n\t\t\tif (n && cpuset_zone_allowed(zone, flags) &&\n\t\t\t\t\tn->nr_partial > s->min_partial) {\n\t\t\t\tobject = get_partial_node(s, n, c, flags);\n\t\t\t\tif (object) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Don't check read_mems_allowed_retry()\n\t\t\t\t\t * here - if mems_allowed was updated in\n\t\t\t\t\t * parallel, that was a harmless race\n\t\t\t\t\t * between allocation and the cpuset\n\t\t\t\t\t * update\n\t\t\t\t\t */\n\t\t\t\t\treturn object;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while (read_mems_allowed_retry(cpuset_mems_cookie));\n#endif\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic void *get_any_partial(struct kmem_cache *s, gfp_t flags,\n\t\tstruct kmem_cache_cpu *c)\n{\n#ifdef CONFIG_NUMA\n\tstruct zonelist *zonelist;\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\tenum zone_type high_zoneidx = gfp_zone(flags);\n\tvoid *object;\n\tunsigned int cpuset_mems_cookie;\n\n\t/*\n\t * The defrag ratio allows a configuration of the tradeoffs between\n\t * inter node defragmentation and node local allocations. A lower\n\t * defrag_ratio increases the tendency to do local allocations\n\t * instead of attempting to obtain partial slabs from other nodes.\n\t *\n\t * If the defrag_ratio is set to 0 then kmalloc() always\n\t * returns node local objects. If the ratio is higher then kmalloc()\n\t * may return off node objects because partial slabs are obtained\n\t * from other nodes and filled up.\n\t *\n\t * If /sys/kernel/slab/xx/remote_node_defrag_ratio is set to 100\n\t * (which makes defrag_ratio = 1000) then every (well almost)\n\t * allocation will first attempt to defrag slab caches on other nodes.\n\t * This means scanning over all nodes to look for partial slabs which\n\t * may be expensive if we do it every time we are trying to find a slab\n\t * with available objects.\n\t */\n\tif (!s->remote_node_defrag_ratio ||\n\t\t\tget_cycles() % 1024 > s->remote_node_defrag_ratio)\n\t\treturn NULL;\n\n\tdo {\n\t\tcpuset_mems_cookie = read_mems_allowed_begin();\n\t\tzonelist = node_zonelist(mempolicy_slab_node(), flags);\n\t\tfor_each_zone_zonelist(zone, z, zonelist, high_zoneidx) {\n\t\t\tstruct kmem_cache_node *n;\n\n\t\t\tn = get_node(s, zone_to_nid(zone));\n\n\t\t\tif (n && cpuset_zone_allowed(zone, flags) &&\n\t\t\t\t\tn->nr_partial > s->min_partial) {\n\t\t\t\tobject = get_partial_node(s, n, c, flags);\n\t\t\t\tif (object) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Don't check read_mems_allowed_retry()\n\t\t\t\t\t * here - if mems_allowed was updated in\n\t\t\t\t\t * parallel, that was a harmless race\n\t\t\t\t\t * between allocation and the cpuset\n\t\t\t\t\t * update\n\t\t\t\t\t */\n\t\t\t\t\treturn object;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while (read_mems_allowed_retry(cpuset_mems_cookie));\n#endif\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_partial_node",
          "args": [
            "s",
            "get_node(s, searchnode)",
            "c",
            "flags"
          ],
          "line": 1950
        },
        "resolved": true,
        "details": {
          "function_name": "get_partial_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1826-1870",
          "snippet": "static void *get_partial_node(struct kmem_cache *s, struct kmem_cache_node *n,\n\t\t\t\tstruct kmem_cache_cpu *c, gfp_t flags)\n{\n\tstruct page *page, *page2;\n\tvoid *object = NULL;\n\tunsigned int available = 0;\n\tint objects;\n\n\t/*\n\t * Racy check. If we mistakenly see no partial slabs then we\n\t * just allocate an empty slab. If we mistakenly try to get a\n\t * partial slab and there is none available then get_partials()\n\t * will return NULL.\n\t */\n\tif (!n || !n->nr_partial)\n\t\treturn NULL;\n\n\tspin_lock(&n->list_lock);\n\tlist_for_each_entry_safe(page, page2, &n->partial, lru) {\n\t\tvoid *t;\n\n\t\tif (!pfmemalloc_match(page, flags))\n\t\t\tcontinue;\n\n\t\tt = acquire_slab(s, n, page, object == NULL, &objects);\n\t\tif (!t)\n\t\t\tbreak;\n\n\t\tavailable += objects;\n\t\tif (!object) {\n\t\t\tc->page = page;\n\t\t\tstat(s, ALLOC_FROM_PARTIAL);\n\t\t\tobject = t;\n\t\t} else {\n\t\t\tput_cpu_partial(s, page, 0);\n\t\t\tstat(s, CPU_PARTIAL_NODE);\n\t\t}\n\t\tif (!kmem_cache_has_cpu_partial(s)\n\t\t\t|| available > slub_cpu_partial(s) / 2)\n\t\t\tbreak;\n\n\t}\n\tspin_unlock(&n->list_lock);\n\treturn object;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic void *get_partial_node(struct kmem_cache *s, struct kmem_cache_node *n,\n\t\t\t\tstruct kmem_cache_cpu *c, gfp_t flags)\n{\n\tstruct page *page, *page2;\n\tvoid *object = NULL;\n\tunsigned int available = 0;\n\tint objects;\n\n\t/*\n\t * Racy check. If we mistakenly see no partial slabs then we\n\t * just allocate an empty slab. If we mistakenly try to get a\n\t * partial slab and there is none available then get_partials()\n\t * will return NULL.\n\t */\n\tif (!n || !n->nr_partial)\n\t\treturn NULL;\n\n\tspin_lock(&n->list_lock);\n\tlist_for_each_entry_safe(page, page2, &n->partial, lru) {\n\t\tvoid *t;\n\n\t\tif (!pfmemalloc_match(page, flags))\n\t\t\tcontinue;\n\n\t\tt = acquire_slab(s, n, page, object == NULL, &objects);\n\t\tif (!t)\n\t\t\tbreak;\n\n\t\tavailable += objects;\n\t\tif (!object) {\n\t\t\tc->page = page;\n\t\t\tstat(s, ALLOC_FROM_PARTIAL);\n\t\t\tobject = t;\n\t\t} else {\n\t\t\tput_cpu_partial(s, page, 0);\n\t\t\tstat(s, CPU_PARTIAL_NODE);\n\t\t}\n\t\tif (!kmem_cache_has_cpu_partial(s)\n\t\t\t|| available > slub_cpu_partial(s) / 2)\n\t\t\tbreak;\n\n\t}\n\tspin_unlock(&n->list_lock);\n\treturn object;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node",
          "args": [
            "s",
            "searchnode"
          ],
          "line": 1950
        },
        "resolved": true,
        "details": {
          "function_name": "get_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "485-488",
          "snippet": "static inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}"
        }
      },
      {
        "call_info": {
          "callee": "node_to_mem_node",
          "args": [
            "node"
          ],
          "line": 1948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_present_pages",
          "args": [
            "node"
          ],
          "line": 1947
        },
        "resolved": true,
        "details": {
          "function_name": "reset_node_present_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "932-940",
          "snippet": "static void reset_node_present_pages(pg_data_t *pgdat)\n{\n\tstruct zone *z;\n\n\tfor (z = pgdat->node_zones; z < pgdat->node_zones + MAX_NR_ZONES; z++)\n\t\tz->present_pages = 0;\n\n\tpgdat->node_present_pages = 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void reset_node_present_pages(pg_data_t *pgdat)\n{\n\tstruct zone *z;\n\n\tfor (z = pgdat->node_zones; z < pgdat->node_zones + MAX_NR_ZONES; z++)\n\t\tz->present_pages = 0;\n\n\tpgdat->node_present_pages = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "numa_mem_id",
          "args": [],
          "line": 1946
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void *get_partial(struct kmem_cache *s, gfp_t flags, int node,\n\t\tstruct kmem_cache_cpu *c)\n{\n\tvoid *object;\n\tint searchnode = node;\n\n\tif (node == NUMA_NO_NODE)\n\t\tsearchnode = numa_mem_id();\n\telse if (!node_present_pages(node))\n\t\tsearchnode = node_to_mem_node(node);\n\n\tobject = get_partial_node(s, get_node(s, searchnode), c, flags);\n\tif (object || node != NUMA_NO_NODE)\n\t\treturn object;\n\n\treturn get_any_partial(s, flags, c);\n}"
  },
  {
    "function_name": "get_any_partial",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1875-1934",
    "snippet": "static void *get_any_partial(struct kmem_cache *s, gfp_t flags,\n\t\tstruct kmem_cache_cpu *c)\n{\n#ifdef CONFIG_NUMA\n\tstruct zonelist *zonelist;\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\tenum zone_type high_zoneidx = gfp_zone(flags);\n\tvoid *object;\n\tunsigned int cpuset_mems_cookie;\n\n\t/*\n\t * The defrag ratio allows a configuration of the tradeoffs between\n\t * inter node defragmentation and node local allocations. A lower\n\t * defrag_ratio increases the tendency to do local allocations\n\t * instead of attempting to obtain partial slabs from other nodes.\n\t *\n\t * If the defrag_ratio is set to 0 then kmalloc() always\n\t * returns node local objects. If the ratio is higher then kmalloc()\n\t * may return off node objects because partial slabs are obtained\n\t * from other nodes and filled up.\n\t *\n\t * If /sys/kernel/slab/xx/remote_node_defrag_ratio is set to 100\n\t * (which makes defrag_ratio = 1000) then every (well almost)\n\t * allocation will first attempt to defrag slab caches on other nodes.\n\t * This means scanning over all nodes to look for partial slabs which\n\t * may be expensive if we do it every time we are trying to find a slab\n\t * with available objects.\n\t */\n\tif (!s->remote_node_defrag_ratio ||\n\t\t\tget_cycles() % 1024 > s->remote_node_defrag_ratio)\n\t\treturn NULL;\n\n\tdo {\n\t\tcpuset_mems_cookie = read_mems_allowed_begin();\n\t\tzonelist = node_zonelist(mempolicy_slab_node(), flags);\n\t\tfor_each_zone_zonelist(zone, z, zonelist, high_zoneidx) {\n\t\t\tstruct kmem_cache_node *n;\n\n\t\t\tn = get_node(s, zone_to_nid(zone));\n\n\t\t\tif (n && cpuset_zone_allowed(zone, flags) &&\n\t\t\t\t\tn->nr_partial > s->min_partial) {\n\t\t\t\tobject = get_partial_node(s, n, c, flags);\n\t\t\t\tif (object) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Don't check read_mems_allowed_retry()\n\t\t\t\t\t * here - if mems_allowed was updated in\n\t\t\t\t\t * parallel, that was a harmless race\n\t\t\t\t\t * between allocation and the cpuset\n\t\t\t\t\t * update\n\t\t\t\t\t */\n\t\t\t\t\treturn object;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while (read_mems_allowed_retry(cpuset_mems_cookie));\n#endif\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *kmem_cache_node;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_mems_allowed_retry",
          "args": [
            "cpuset_mems_cookie"
          ],
          "line": 1931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_partial_node",
          "args": [
            "s",
            "n",
            "c",
            "flags"
          ],
          "line": 1918
        },
        "resolved": true,
        "details": {
          "function_name": "get_partial_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1826-1870",
          "snippet": "static void *get_partial_node(struct kmem_cache *s, struct kmem_cache_node *n,\n\t\t\t\tstruct kmem_cache_cpu *c, gfp_t flags)\n{\n\tstruct page *page, *page2;\n\tvoid *object = NULL;\n\tunsigned int available = 0;\n\tint objects;\n\n\t/*\n\t * Racy check. If we mistakenly see no partial slabs then we\n\t * just allocate an empty slab. If we mistakenly try to get a\n\t * partial slab and there is none available then get_partials()\n\t * will return NULL.\n\t */\n\tif (!n || !n->nr_partial)\n\t\treturn NULL;\n\n\tspin_lock(&n->list_lock);\n\tlist_for_each_entry_safe(page, page2, &n->partial, lru) {\n\t\tvoid *t;\n\n\t\tif (!pfmemalloc_match(page, flags))\n\t\t\tcontinue;\n\n\t\tt = acquire_slab(s, n, page, object == NULL, &objects);\n\t\tif (!t)\n\t\t\tbreak;\n\n\t\tavailable += objects;\n\t\tif (!object) {\n\t\t\tc->page = page;\n\t\t\tstat(s, ALLOC_FROM_PARTIAL);\n\t\t\tobject = t;\n\t\t} else {\n\t\t\tput_cpu_partial(s, page, 0);\n\t\t\tstat(s, CPU_PARTIAL_NODE);\n\t\t}\n\t\tif (!kmem_cache_has_cpu_partial(s)\n\t\t\t|| available > slub_cpu_partial(s) / 2)\n\t\t\tbreak;\n\n\t}\n\tspin_unlock(&n->list_lock);\n\treturn object;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic void *get_partial_node(struct kmem_cache *s, struct kmem_cache_node *n,\n\t\t\t\tstruct kmem_cache_cpu *c, gfp_t flags)\n{\n\tstruct page *page, *page2;\n\tvoid *object = NULL;\n\tunsigned int available = 0;\n\tint objects;\n\n\t/*\n\t * Racy check. If we mistakenly see no partial slabs then we\n\t * just allocate an empty slab. If we mistakenly try to get a\n\t * partial slab and there is none available then get_partials()\n\t * will return NULL.\n\t */\n\tif (!n || !n->nr_partial)\n\t\treturn NULL;\n\n\tspin_lock(&n->list_lock);\n\tlist_for_each_entry_safe(page, page2, &n->partial, lru) {\n\t\tvoid *t;\n\n\t\tif (!pfmemalloc_match(page, flags))\n\t\t\tcontinue;\n\n\t\tt = acquire_slab(s, n, page, object == NULL, &objects);\n\t\tif (!t)\n\t\t\tbreak;\n\n\t\tavailable += objects;\n\t\tif (!object) {\n\t\t\tc->page = page;\n\t\t\tstat(s, ALLOC_FROM_PARTIAL);\n\t\t\tobject = t;\n\t\t} else {\n\t\t\tput_cpu_partial(s, page, 0);\n\t\t\tstat(s, CPU_PARTIAL_NODE);\n\t\t}\n\t\tif (!kmem_cache_has_cpu_partial(s)\n\t\t\t|| available > slub_cpu_partial(s) / 2)\n\t\t\tbreak;\n\n\t}\n\tspin_unlock(&n->list_lock);\n\treturn object;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuset_zone_allowed",
          "args": [
            "zone",
            "flags"
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node",
          "args": [
            "s",
            "zone_to_nid(zone)"
          ],
          "line": 1914
        },
        "resolved": true,
        "details": {
          "function_name": "get_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "485-488",
          "snippet": "static inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}"
        }
      },
      {
        "call_info": {
          "callee": "zone_to_nid",
          "args": [
            "zone"
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_zone_zonelist",
          "args": [
            "zone",
            "z",
            "zonelist",
            "high_zoneidx"
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_zonelist",
          "args": [
            "mempolicy_slab_node()",
            "flags"
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mempolicy_slab_node",
          "args": [],
          "line": 1910
        },
        "resolved": true,
        "details": {
          "function_name": "mempolicy_slab_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1767-1807",
          "snippet": "unsigned int mempolicy_slab_node(void)\n{\n\tstruct mempolicy *policy;\n\tint node = numa_mem_id();\n\n\tif (in_interrupt())\n\t\treturn node;\n\n\tpolicy = current->mempolicy;\n\tif (!policy || policy->flags & MPOL_F_LOCAL)\n\t\treturn node;\n\n\tswitch (policy->mode) {\n\tcase MPOL_PREFERRED:\n\t\t/*\n\t\t * handled MPOL_F_LOCAL above\n\t\t */\n\t\treturn policy->v.preferred_node;\n\n\tcase MPOL_INTERLEAVE:\n\t\treturn interleave_nodes(policy);\n\n\tcase MPOL_BIND: {\n\t\tstruct zoneref *z;\n\n\t\t/*\n\t\t * Follow bind policy behavior and start allocation at the\n\t\t * first node.\n\t\t */\n\t\tstruct zonelist *zonelist;\n\t\tenum zone_type highest_zoneidx = gfp_zone(GFP_KERNEL);\n\t\tzonelist = &NODE_DATA(node)->node_zonelists[ZONELIST_FALLBACK];\n\t\tz = first_zones_zonelist(zonelist, highest_zoneidx,\n\t\t\t\t\t\t\t&policy->v.nodes);\n\t\treturn z->zone ? zone_to_nid(z->zone) : node;\n\t}\n\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nunsigned int mempolicy_slab_node(void)\n{\n\tstruct mempolicy *policy;\n\tint node = numa_mem_id();\n\n\tif (in_interrupt())\n\t\treturn node;\n\n\tpolicy = current->mempolicy;\n\tif (!policy || policy->flags & MPOL_F_LOCAL)\n\t\treturn node;\n\n\tswitch (policy->mode) {\n\tcase MPOL_PREFERRED:\n\t\t/*\n\t\t * handled MPOL_F_LOCAL above\n\t\t */\n\t\treturn policy->v.preferred_node;\n\n\tcase MPOL_INTERLEAVE:\n\t\treturn interleave_nodes(policy);\n\n\tcase MPOL_BIND: {\n\t\tstruct zoneref *z;\n\n\t\t/*\n\t\t * Follow bind policy behavior and start allocation at the\n\t\t * first node.\n\t\t */\n\t\tstruct zonelist *zonelist;\n\t\tenum zone_type highest_zoneidx = gfp_zone(GFP_KERNEL);\n\t\tzonelist = &NODE_DATA(node)->node_zonelists[ZONELIST_FALLBACK];\n\t\tz = first_zones_zonelist(zonelist, highest_zoneidx,\n\t\t\t\t\t\t\t&policy->v.nodes);\n\t\treturn z->zone ? zone_to_nid(z->zone) : node;\n\t}\n\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_mems_allowed_begin",
          "args": [],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cycles",
          "args": [],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfp_zone",
          "args": [
            "flags"
          ],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic void *get_any_partial(struct kmem_cache *s, gfp_t flags,\n\t\tstruct kmem_cache_cpu *c)\n{\n#ifdef CONFIG_NUMA\n\tstruct zonelist *zonelist;\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\tenum zone_type high_zoneidx = gfp_zone(flags);\n\tvoid *object;\n\tunsigned int cpuset_mems_cookie;\n\n\t/*\n\t * The defrag ratio allows a configuration of the tradeoffs between\n\t * inter node defragmentation and node local allocations. A lower\n\t * defrag_ratio increases the tendency to do local allocations\n\t * instead of attempting to obtain partial slabs from other nodes.\n\t *\n\t * If the defrag_ratio is set to 0 then kmalloc() always\n\t * returns node local objects. If the ratio is higher then kmalloc()\n\t * may return off node objects because partial slabs are obtained\n\t * from other nodes and filled up.\n\t *\n\t * If /sys/kernel/slab/xx/remote_node_defrag_ratio is set to 100\n\t * (which makes defrag_ratio = 1000) then every (well almost)\n\t * allocation will first attempt to defrag slab caches on other nodes.\n\t * This means scanning over all nodes to look for partial slabs which\n\t * may be expensive if we do it every time we are trying to find a slab\n\t * with available objects.\n\t */\n\tif (!s->remote_node_defrag_ratio ||\n\t\t\tget_cycles() % 1024 > s->remote_node_defrag_ratio)\n\t\treturn NULL;\n\n\tdo {\n\t\tcpuset_mems_cookie = read_mems_allowed_begin();\n\t\tzonelist = node_zonelist(mempolicy_slab_node(), flags);\n\t\tfor_each_zone_zonelist(zone, z, zonelist, high_zoneidx) {\n\t\t\tstruct kmem_cache_node *n;\n\n\t\t\tn = get_node(s, zone_to_nid(zone));\n\n\t\t\tif (n && cpuset_zone_allowed(zone, flags) &&\n\t\t\t\t\tn->nr_partial > s->min_partial) {\n\t\t\t\tobject = get_partial_node(s, n, c, flags);\n\t\t\t\tif (object) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Don't check read_mems_allowed_retry()\n\t\t\t\t\t * here - if mems_allowed was updated in\n\t\t\t\t\t * parallel, that was a harmless race\n\t\t\t\t\t * between allocation and the cpuset\n\t\t\t\t\t * update\n\t\t\t\t\t */\n\t\t\t\t\treturn object;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while (read_mems_allowed_retry(cpuset_mems_cookie));\n#endif\n\treturn NULL;\n}"
  },
  {
    "function_name": "get_partial_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1826-1870",
    "snippet": "static void *get_partial_node(struct kmem_cache *s, struct kmem_cache_node *n,\n\t\t\t\tstruct kmem_cache_cpu *c, gfp_t flags)\n{\n\tstruct page *page, *page2;\n\tvoid *object = NULL;\n\tunsigned int available = 0;\n\tint objects;\n\n\t/*\n\t * Racy check. If we mistakenly see no partial slabs then we\n\t * just allocate an empty slab. If we mistakenly try to get a\n\t * partial slab and there is none available then get_partials()\n\t * will return NULL.\n\t */\n\tif (!n || !n->nr_partial)\n\t\treturn NULL;\n\n\tspin_lock(&n->list_lock);\n\tlist_for_each_entry_safe(page, page2, &n->partial, lru) {\n\t\tvoid *t;\n\n\t\tif (!pfmemalloc_match(page, flags))\n\t\t\tcontinue;\n\n\t\tt = acquire_slab(s, n, page, object == NULL, &objects);\n\t\tif (!t)\n\t\t\tbreak;\n\n\t\tavailable += objects;\n\t\tif (!object) {\n\t\t\tc->page = page;\n\t\t\tstat(s, ALLOC_FROM_PARTIAL);\n\t\t\tobject = t;\n\t\t} else {\n\t\t\tput_cpu_partial(s, page, 0);\n\t\t\tstat(s, CPU_PARTIAL_NODE);\n\t\t}\n\t\tif (!kmem_cache_has_cpu_partial(s)\n\t\t\t|| available > slub_cpu_partial(s) / 2)\n\t\t\tbreak;\n\n\t}\n\tspin_unlock(&n->list_lock);\n\treturn object;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *kmem_cache_node;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&n->list_lock"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slub_cpu_partial",
          "args": [
            "s"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_has_cpu_partial",
          "args": [
            "s"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_has_cpu_partial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "135-142",
          "snippet": "static inline bool kmem_cache_has_cpu_partial(struct kmem_cache *s)\n{\n#ifdef CONFIG_SLUB_CPU_PARTIAL\n\treturn !kmem_cache_debug(s);\n#else\n\treturn false;\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline bool kmem_cache_has_cpu_partial(struct kmem_cache *s)\n{\n#ifdef CONFIG_SLUB_CPU_PARTIAL\n\treturn !kmem_cache_debug(s);\n#else\n\treturn false;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "s",
            "CPU_PARTIAL_NODE"
          ],
          "line": 1861
        },
        "resolved": true,
        "details": {
          "function_name": "slabinfo_show_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "5900-5902",
          "snippet": "void slabinfo_show_stats(struct seq_file *m, struct kmem_cache *s)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid slabinfo_show_stats(struct seq_file *m, struct kmem_cache *s)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_cpu_partial",
          "args": [
            "s",
            "page",
            "0"
          ],
          "line": 1860
        },
        "resolved": true,
        "details": {
          "function_name": "put_cpu_partial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2247-2297",
          "snippet": "static void put_cpu_partial(struct kmem_cache *s, struct page *page, int drain)\n{\n#ifdef CONFIG_SLUB_CPU_PARTIAL\n\tstruct page *oldpage;\n\tint pages;\n\tint pobjects;\n\n\tpreempt_disable();\n\tdo {\n\t\tpages = 0;\n\t\tpobjects = 0;\n\t\toldpage = this_cpu_read(s->cpu_slab->partial);\n\n\t\tif (oldpage) {\n\t\t\tpobjects = oldpage->pobjects;\n\t\t\tpages = oldpage->pages;\n\t\t\tif (drain && pobjects > s->cpu_partial) {\n\t\t\t\tunsigned long flags;\n\t\t\t\t/*\n\t\t\t\t * partial array is full. Move the existing\n\t\t\t\t * set to the per node partial list.\n\t\t\t\t */\n\t\t\t\tlocal_irq_save(flags);\n\t\t\t\tunfreeze_partials(s, this_cpu_ptr(s->cpu_slab));\n\t\t\t\tlocal_irq_restore(flags);\n\t\t\t\toldpage = NULL;\n\t\t\t\tpobjects = 0;\n\t\t\t\tpages = 0;\n\t\t\t\tstat(s, CPU_PARTIAL_DRAIN);\n\t\t\t}\n\t\t}\n\n\t\tpages++;\n\t\tpobjects += page->objects - page->inuse;\n\n\t\tpage->pages = pages;\n\t\tpage->pobjects = pobjects;\n\t\tpage->next = oldpage;\n\n\t} while (this_cpu_cmpxchg(s->cpu_slab->partial, oldpage, page)\n\t\t\t\t\t\t\t\t!= oldpage);\n\tif (unlikely(!s->cpu_partial)) {\n\t\tunsigned long flags;\n\n\t\tlocal_irq_save(flags);\n\t\tunfreeze_partials(s, this_cpu_ptr(s->cpu_slab));\n\t\tlocal_irq_restore(flags);\n\t}\n\tpreempt_enable();\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void put_cpu_partial(struct kmem_cache *s, struct page *page, int drain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void put_cpu_partial(struct kmem_cache *s, struct page *page, int drain);\n\nstatic void put_cpu_partial(struct kmem_cache *s, struct page *page, int drain)\n{\n#ifdef CONFIG_SLUB_CPU_PARTIAL\n\tstruct page *oldpage;\n\tint pages;\n\tint pobjects;\n\n\tpreempt_disable();\n\tdo {\n\t\tpages = 0;\n\t\tpobjects = 0;\n\t\toldpage = this_cpu_read(s->cpu_slab->partial);\n\n\t\tif (oldpage) {\n\t\t\tpobjects = oldpage->pobjects;\n\t\t\tpages = oldpage->pages;\n\t\t\tif (drain && pobjects > s->cpu_partial) {\n\t\t\t\tunsigned long flags;\n\t\t\t\t/*\n\t\t\t\t * partial array is full. Move the existing\n\t\t\t\t * set to the per node partial list.\n\t\t\t\t */\n\t\t\t\tlocal_irq_save(flags);\n\t\t\t\tunfreeze_partials(s, this_cpu_ptr(s->cpu_slab));\n\t\t\t\tlocal_irq_restore(flags);\n\t\t\t\toldpage = NULL;\n\t\t\t\tpobjects = 0;\n\t\t\t\tpages = 0;\n\t\t\t\tstat(s, CPU_PARTIAL_DRAIN);\n\t\t\t}\n\t\t}\n\n\t\tpages++;\n\t\tpobjects += page->objects - page->inuse;\n\n\t\tpage->pages = pages;\n\t\tpage->pobjects = pobjects;\n\t\tpage->next = oldpage;\n\n\t} while (this_cpu_cmpxchg(s->cpu_slab->partial, oldpage, page)\n\t\t\t\t\t\t\t\t!= oldpage);\n\tif (unlikely(!s->cpu_partial)) {\n\t\tunsigned long flags;\n\n\t\tlocal_irq_save(flags);\n\t\tunfreeze_partials(s, this_cpu_ptr(s->cpu_slab));\n\t\tlocal_irq_restore(flags);\n\t}\n\tpreempt_enable();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "acquire_slab",
          "args": [
            "s",
            "n",
            "page",
            "object == NULL",
            "&objects"
          ],
          "line": 1850
        },
        "resolved": true,
        "details": {
          "function_name": "acquire_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1780-1818",
          "snippet": "static inline void *acquire_slab(struct kmem_cache *s,\n\t\tstruct kmem_cache_node *n, struct page *page,\n\t\tint mode, int *objects)\n{\n\tvoid *freelist;\n\tunsigned long counters;\n\tstruct page new;\n\n\tlockdep_assert_held(&n->list_lock);\n\n\t/*\n\t * Zap the freelist and set the frozen bit.\n\t * The old freelist is the list of objects for the\n\t * per cpu allocation list.\n\t */\n\tfreelist = page->freelist;\n\tcounters = page->counters;\n\tnew.counters = counters;\n\t*objects = new.objects - new.inuse;\n\tif (mode) {\n\t\tnew.inuse = page->objects;\n\t\tnew.freelist = NULL;\n\t} else {\n\t\tnew.freelist = freelist;\n\t}\n\n\tVM_BUG_ON(new.frozen);\n\tnew.frozen = 1;\n\n\tif (!__cmpxchg_double_slab(s, page,\n\t\t\tfreelist, counters,\n\t\t\tnew.freelist, new.counters,\n\t\t\t\"acquire_slab\"))\n\t\treturn NULL;\n\n\tremove_partial(n, page);\n\tWARN_ON(!freelist);\n\treturn freelist;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic inline void *acquire_slab(struct kmem_cache *s,\n\t\tstruct kmem_cache_node *n, struct page *page,\n\t\tint mode, int *objects)\n{\n\tvoid *freelist;\n\tunsigned long counters;\n\tstruct page new;\n\n\tlockdep_assert_held(&n->list_lock);\n\n\t/*\n\t * Zap the freelist and set the frozen bit.\n\t * The old freelist is the list of objects for the\n\t * per cpu allocation list.\n\t */\n\tfreelist = page->freelist;\n\tcounters = page->counters;\n\tnew.counters = counters;\n\t*objects = new.objects - new.inuse;\n\tif (mode) {\n\t\tnew.inuse = page->objects;\n\t\tnew.freelist = NULL;\n\t} else {\n\t\tnew.freelist = freelist;\n\t}\n\n\tVM_BUG_ON(new.frozen);\n\tnew.frozen = 1;\n\n\tif (!__cmpxchg_double_slab(s, page,\n\t\t\tfreelist, counters,\n\t\t\tnew.freelist, new.counters,\n\t\t\t\"acquire_slab\"))\n\t\treturn NULL;\n\n\tremove_partial(n, page);\n\tWARN_ON(!freelist);\n\treturn freelist;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfmemalloc_match",
          "args": [
            "page",
            "flags"
          ],
          "line": 1847
        },
        "resolved": true,
        "details": {
          "function_name": "pfmemalloc_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2477-2483",
          "snippet": "static inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags)\n{\n\tif (unlikely(PageSlabPfmemalloc(page)))\n\t\treturn gfp_pfmemalloc_allowed(gfpflags);\n\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);\n\nstatic inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags)\n{\n\tif (unlikely(PageSlabPfmemalloc(page)))\n\t\treturn gfp_pfmemalloc_allowed(gfpflags);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "page",
            "page2",
            "&n->partial",
            "lru"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&n->list_lock"
          ],
          "line": 1843
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic void *get_partial_node(struct kmem_cache *s, struct kmem_cache_node *n,\n\t\t\t\tstruct kmem_cache_cpu *c, gfp_t flags)\n{\n\tstruct page *page, *page2;\n\tvoid *object = NULL;\n\tunsigned int available = 0;\n\tint objects;\n\n\t/*\n\t * Racy check. If we mistakenly see no partial slabs then we\n\t * just allocate an empty slab. If we mistakenly try to get a\n\t * partial slab and there is none available then get_partials()\n\t * will return NULL.\n\t */\n\tif (!n || !n->nr_partial)\n\t\treturn NULL;\n\n\tspin_lock(&n->list_lock);\n\tlist_for_each_entry_safe(page, page2, &n->partial, lru) {\n\t\tvoid *t;\n\n\t\tif (!pfmemalloc_match(page, flags))\n\t\t\tcontinue;\n\n\t\tt = acquire_slab(s, n, page, object == NULL, &objects);\n\t\tif (!t)\n\t\t\tbreak;\n\n\t\tavailable += objects;\n\t\tif (!object) {\n\t\t\tc->page = page;\n\t\t\tstat(s, ALLOC_FROM_PARTIAL);\n\t\t\tobject = t;\n\t\t} else {\n\t\t\tput_cpu_partial(s, page, 0);\n\t\t\tstat(s, CPU_PARTIAL_NODE);\n\t\t}\n\t\tif (!kmem_cache_has_cpu_partial(s)\n\t\t\t|| available > slub_cpu_partial(s) / 2)\n\t\t\tbreak;\n\n\t}\n\tspin_unlock(&n->list_lock);\n\treturn object;\n}"
  },
  {
    "function_name": "acquire_slab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1780-1818",
    "snippet": "static inline void *acquire_slab(struct kmem_cache *s,\n\t\tstruct kmem_cache_node *n, struct page *page,\n\t\tint mode, int *objects)\n{\n\tvoid *freelist;\n\tunsigned long counters;\n\tstruct page new;\n\n\tlockdep_assert_held(&n->list_lock);\n\n\t/*\n\t * Zap the freelist and set the frozen bit.\n\t * The old freelist is the list of objects for the\n\t * per cpu allocation list.\n\t */\n\tfreelist = page->freelist;\n\tcounters = page->counters;\n\tnew.counters = counters;\n\t*objects = new.objects - new.inuse;\n\tif (mode) {\n\t\tnew.inuse = page->objects;\n\t\tnew.freelist = NULL;\n\t} else {\n\t\tnew.freelist = freelist;\n\t}\n\n\tVM_BUG_ON(new.frozen);\n\tnew.frozen = 1;\n\n\tif (!__cmpxchg_double_slab(s, page,\n\t\t\tfreelist, counters,\n\t\t\tnew.freelist, new.counters,\n\t\t\t\"acquire_slab\"))\n\t\treturn NULL;\n\n\tremove_partial(n, page);\n\tWARN_ON(!freelist);\n\treturn freelist;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *kmem_cache_node;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!freelist"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_partial",
          "args": [
            "n",
            "page"
          ],
          "line": 1815
        },
        "resolved": true,
        "details": {
          "function_name": "remove_partial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1766-1772",
          "snippet": "static inline void remove_partial(struct kmem_cache_node *n,\n\t\t\t\t\tstruct page *page)\n{\n\tlockdep_assert_held(&n->list_lock);\n\tlist_del(&page->lru);\n\tn->nr_partial--;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic inline void remove_partial(struct kmem_cache_node *n,\n\t\t\t\t\tstruct page *page)\n{\n\tlockdep_assert_held(&n->list_lock);\n\tlist_del(&page->lru);\n\tn->nr_partial--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cmpxchg_double_slab",
          "args": [
            "s",
            "page",
            "freelist",
            "counters",
            "new.freelist",
            "new.counters",
            "\"acquire_slab\""
          ],
          "line": 1809
        },
        "resolved": true,
        "details": {
          "function_name": "__cmpxchg_double_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "358-393",
          "snippet": "static inline bool __cmpxchg_double_slab(struct kmem_cache *s, struct page *page,\n\t\tvoid *freelist_old, unsigned long counters_old,\n\t\tvoid *freelist_new, unsigned long counters_new,\n\t\tconst char *n)\n{\n\tVM_BUG_ON(!irqs_disabled());\n#if defined(CONFIG_HAVE_CMPXCHG_DOUBLE) && \\\n    defined(CONFIG_HAVE_ALIGNED_STRUCT_PAGE)\n\tif (s->flags & __CMPXCHG_DOUBLE) {\n\t\tif (cmpxchg_double(&page->freelist, &page->counters,\n\t\t\t\t   freelist_old, counters_old,\n\t\t\t\t   freelist_new, counters_new))\n\t\t\treturn true;\n\t} else\n#endif\n\t{\n\t\tslab_lock(page);\n\t\tif (page->freelist == freelist_old &&\n\t\t\t\t\tpage->counters == counters_old) {\n\t\t\tpage->freelist = freelist_new;\n\t\t\tpage->counters = counters_new;\n\t\t\tslab_unlock(page);\n\t\t\treturn true;\n\t\t}\n\t\tslab_unlock(page);\n\t}\n\n\tcpu_relax();\n\tstat(s, CMPXCHG_DOUBLE_FAIL);\n\n#ifdef SLUB_DEBUG_CMPXCHG\n\tpr_info(\"%s %s: cmpxchg double redo \", n, s->name);\n#endif\n\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define __CMPXCHG_DOUBLE\t((slab_flags_t __force)0x40000000U)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define __CMPXCHG_DOUBLE\t((slab_flags_t __force)0x40000000U)\n\nstatic inline bool __cmpxchg_double_slab(struct kmem_cache *s, struct page *page,\n\t\tvoid *freelist_old, unsigned long counters_old,\n\t\tvoid *freelist_new, unsigned long counters_new,\n\t\tconst char *n)\n{\n\tVM_BUG_ON(!irqs_disabled());\n#if defined(CONFIG_HAVE_CMPXCHG_DOUBLE) && \\\n    defined(CONFIG_HAVE_ALIGNED_STRUCT_PAGE)\n\tif (s->flags & __CMPXCHG_DOUBLE) {\n\t\tif (cmpxchg_double(&page->freelist, &page->counters,\n\t\t\t\t   freelist_old, counters_old,\n\t\t\t\t   freelist_new, counters_new))\n\t\t\treturn true;\n\t} else\n#endif\n\t{\n\t\tslab_lock(page);\n\t\tif (page->freelist == freelist_old &&\n\t\t\t\t\tpage->counters == counters_old) {\n\t\t\tpage->freelist = freelist_new;\n\t\t\tpage->counters = counters_new;\n\t\t\tslab_unlock(page);\n\t\t\treturn true;\n\t\t}\n\t\tslab_unlock(page);\n\t}\n\n\tcpu_relax();\n\tstat(s, CMPXCHG_DOUBLE_FAIL);\n\n#ifdef SLUB_DEBUG_CMPXCHG\n\tpr_info(\"%s %s: cmpxchg double redo \", n, s->name);\n#endif\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "new.frozen"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&n->list_lock"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic inline void *acquire_slab(struct kmem_cache *s,\n\t\tstruct kmem_cache_node *n, struct page *page,\n\t\tint mode, int *objects)\n{\n\tvoid *freelist;\n\tunsigned long counters;\n\tstruct page new;\n\n\tlockdep_assert_held(&n->list_lock);\n\n\t/*\n\t * Zap the freelist and set the frozen bit.\n\t * The old freelist is the list of objects for the\n\t * per cpu allocation list.\n\t */\n\tfreelist = page->freelist;\n\tcounters = page->counters;\n\tnew.counters = counters;\n\t*objects = new.objects - new.inuse;\n\tif (mode) {\n\t\tnew.inuse = page->objects;\n\t\tnew.freelist = NULL;\n\t} else {\n\t\tnew.freelist = freelist;\n\t}\n\n\tVM_BUG_ON(new.frozen);\n\tnew.frozen = 1;\n\n\tif (!__cmpxchg_double_slab(s, page,\n\t\t\tfreelist, counters,\n\t\t\tnew.freelist, new.counters,\n\t\t\t\"acquire_slab\"))\n\t\treturn NULL;\n\n\tremove_partial(n, page);\n\tWARN_ON(!freelist);\n\treturn freelist;\n}"
  },
  {
    "function_name": "remove_partial",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1766-1772",
    "snippet": "static inline void remove_partial(struct kmem_cache_node *n,\n\t\t\t\t\tstruct page *page)\n{\n\tlockdep_assert_held(&n->list_lock);\n\tlist_del(&page->lru);\n\tn->nr_partial--;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *kmem_cache_node;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&n->list_lock"
          ],
          "line": 1769
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic inline void remove_partial(struct kmem_cache_node *n,\n\t\t\t\t\tstruct page *page)\n{\n\tlockdep_assert_held(&n->list_lock);\n\tlist_del(&page->lru);\n\tn->nr_partial--;\n}"
  },
  {
    "function_name": "add_partial",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1759-1764",
    "snippet": "static inline void add_partial(struct kmem_cache_node *n,\n\t\t\t\tstruct page *page, int tail)\n{\n\tlockdep_assert_held(&n->list_lock);\n\t__add_partial(n, page, tail);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *kmem_cache_node;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__add_partial",
          "args": [
            "n",
            "page",
            "tail"
          ],
          "line": 1763
        },
        "resolved": true,
        "details": {
          "function_name": "__add_partial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1749-1757",
          "snippet": "static inline void\n__add_partial(struct kmem_cache_node *n, struct page *page, int tail)\n{\n\tn->nr_partial++;\n\tif (tail == DEACTIVATE_TO_TAIL)\n\t\tlist_add_tail(&page->lru, &n->partial);\n\telse\n\t\tlist_add(&page->lru, &n->partial);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *kmem_cache_node;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic inline void\n__add_partial(struct kmem_cache_node *n, struct page *page, int tail)\n{\n\tn->nr_partial++;\n\tif (tail == DEACTIVATE_TO_TAIL)\n\t\tlist_add_tail(&page->lru, &n->partial);\n\telse\n\t\tlist_add(&page->lru, &n->partial);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&n->list_lock"
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic inline void add_partial(struct kmem_cache_node *n,\n\t\t\t\tstruct page *page, int tail)\n{\n\tlockdep_assert_held(&n->list_lock);\n\t__add_partial(n, page, tail);\n}"
  },
  {
    "function_name": "__add_partial",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1749-1757",
    "snippet": "static inline void\n__add_partial(struct kmem_cache_node *n, struct page *page, int tail)\n{\n\tn->nr_partial++;\n\tif (tail == DEACTIVATE_TO_TAIL)\n\t\tlist_add_tail(&page->lru, &n->partial);\n\telse\n\t\tlist_add(&page->lru, &n->partial);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *kmem_cache_node;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&page->lru",
            "&n->partial"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&page->lru",
            "&n->partial"
          ],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic inline void\n__add_partial(struct kmem_cache_node *n, struct page *page, int tail)\n{\n\tn->nr_partial++;\n\tif (tail == DEACTIVATE_TO_TAIL)\n\t\tlist_add_tail(&page->lru, &n->partial);\n\telse\n\t\tlist_add(&page->lru, &n->partial);\n}"
  },
  {
    "function_name": "discard_slab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1740-1744",
    "snippet": "static void discard_slab(struct kmem_cache *s, struct page *page)\n{\n\tdec_slabs_node(s, page_to_nid(page), page->objects);\n\tfree_slab(s, page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_slab",
          "args": [
            "s",
            "page"
          ],
          "line": 1743
        },
        "resolved": true,
        "details": {
          "function_name": "free_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1732-1738",
          "snippet": "static void free_slab(struct kmem_cache *s, struct page *page)\n{\n\tif (unlikely(s->flags & SLAB_TYPESAFE_BY_RCU)) {\n\t\tcall_rcu(&page->rcu_head, rcu_free_slab);\n\t} else\n\t\t__free_slab(s, page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void free_slab(struct kmem_cache *s, struct page *page)\n{\n\tif (unlikely(s->flags & SLAB_TYPESAFE_BY_RCU)) {\n\t\tcall_rcu(&page->rcu_head, rcu_free_slab);\n\t} else\n\t\t__free_slab(s, page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dec_slabs_node",
          "args": [
            "s",
            "page_to_nid(page)",
            "page->objects"
          ],
          "line": 1742
        },
        "resolved": true,
        "details": {
          "function_name": "dec_slabs_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1366-1367",
          "snippet": "static inline void dec_slabs_node(struct kmem_cache *s, int node,\n\t\t\t\t\t\t\tint objects) {}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void dec_slabs_node(struct kmem_cache *s, int node,\n\t\t\t\t\t\t\tint objects) {}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 1742
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void discard_slab(struct kmem_cache *s, struct page *page)\n{\n\tdec_slabs_node(s, page_to_nid(page), page->objects);\n\tfree_slab(s, page);\n}"
  },
  {
    "function_name": "free_slab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1732-1738",
    "snippet": "static void free_slab(struct kmem_cache *s, struct page *page)\n{\n\tif (unlikely(s->flags & SLAB_TYPESAFE_BY_RCU)) {\n\t\tcall_rcu(&page->rcu_head, rcu_free_slab);\n\t} else\n\t\t__free_slab(s, page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_slab",
          "args": [
            "s",
            "page"
          ],
          "line": 1737
        },
        "resolved": true,
        "details": {
          "function_name": "__free_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1696-1723",
          "snippet": "static void __free_slab(struct kmem_cache *s, struct page *page)\n{\n\tint order = compound_order(page);\n\tint pages = 1 << order;\n\n\tif (s->flags & SLAB_CONSISTENCY_CHECKS) {\n\t\tvoid *p;\n\n\t\tslab_pad_check(s, page);\n\t\tfor_each_object(p, s, page_address(page),\n\t\t\t\t\t\tpage->objects)\n\t\t\tcheck_object(s, page, p, SLUB_RED_INACTIVE);\n\t}\n\n\tmod_lruvec_page_state(page,\n\t\t(s->flags & SLAB_RECLAIM_ACCOUNT) ?\n\t\tNR_SLAB_RECLAIMABLE : NR_SLAB_UNRECLAIMABLE,\n\t\t-pages);\n\n\t__ClearPageSlabPfmemalloc(page);\n\t__ClearPageSlab(page);\n\n\tpage->mapping = NULL;\n\tif (current->reclaim_state)\n\t\tcurrent->reclaim_state->reclaimed_slab += pages;\n\tmemcg_uncharge_slab(page, order, s);\n\t__free_pages(page, order);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void __free_slab(struct kmem_cache *s, struct page *page)\n{\n\tint order = compound_order(page);\n\tint pages = 1 << order;\n\n\tif (s->flags & SLAB_CONSISTENCY_CHECKS) {\n\t\tvoid *p;\n\n\t\tslab_pad_check(s, page);\n\t\tfor_each_object(p, s, page_address(page),\n\t\t\t\t\t\tpage->objects)\n\t\t\tcheck_object(s, page, p, SLUB_RED_INACTIVE);\n\t}\n\n\tmod_lruvec_page_state(page,\n\t\t(s->flags & SLAB_RECLAIM_ACCOUNT) ?\n\t\tNR_SLAB_RECLAIMABLE : NR_SLAB_UNRECLAIMABLE,\n\t\t-pages);\n\n\t__ClearPageSlabPfmemalloc(page);\n\t__ClearPageSlab(page);\n\n\tpage->mapping = NULL;\n\tif (current->reclaim_state)\n\t\tcurrent->reclaim_state->reclaimed_slab += pages;\n\tmemcg_uncharge_slab(page, order, s);\n\t__free_pages(page, order);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&page->rcu_head",
            "rcu_free_slab"
          ],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "s->flags & SLAB_TYPESAFE_BY_RCU"
          ],
          "line": 1734
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void free_slab(struct kmem_cache *s, struct page *page)\n{\n\tif (unlikely(s->flags & SLAB_TYPESAFE_BY_RCU)) {\n\t\tcall_rcu(&page->rcu_head, rcu_free_slab);\n\t} else\n\t\t__free_slab(s, page);\n}"
  },
  {
    "function_name": "rcu_free_slab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1725-1730",
    "snippet": "static void rcu_free_slab(struct rcu_head *h)\n{\n\tstruct page *page = container_of(h, struct page, rcu_head);\n\n\t__free_slab(page->slab_cache, page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_slab",
          "args": [
            "page->slab_cache",
            "page"
          ],
          "line": 1729
        },
        "resolved": true,
        "details": {
          "function_name": "__free_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1696-1723",
          "snippet": "static void __free_slab(struct kmem_cache *s, struct page *page)\n{\n\tint order = compound_order(page);\n\tint pages = 1 << order;\n\n\tif (s->flags & SLAB_CONSISTENCY_CHECKS) {\n\t\tvoid *p;\n\n\t\tslab_pad_check(s, page);\n\t\tfor_each_object(p, s, page_address(page),\n\t\t\t\t\t\tpage->objects)\n\t\t\tcheck_object(s, page, p, SLUB_RED_INACTIVE);\n\t}\n\n\tmod_lruvec_page_state(page,\n\t\t(s->flags & SLAB_RECLAIM_ACCOUNT) ?\n\t\tNR_SLAB_RECLAIMABLE : NR_SLAB_UNRECLAIMABLE,\n\t\t-pages);\n\n\t__ClearPageSlabPfmemalloc(page);\n\t__ClearPageSlab(page);\n\n\tpage->mapping = NULL;\n\tif (current->reclaim_state)\n\t\tcurrent->reclaim_state->reclaimed_slab += pages;\n\tmemcg_uncharge_slab(page, order, s);\n\t__free_pages(page, order);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void __free_slab(struct kmem_cache *s, struct page *page)\n{\n\tint order = compound_order(page);\n\tint pages = 1 << order;\n\n\tif (s->flags & SLAB_CONSISTENCY_CHECKS) {\n\t\tvoid *p;\n\n\t\tslab_pad_check(s, page);\n\t\tfor_each_object(p, s, page_address(page),\n\t\t\t\t\t\tpage->objects)\n\t\t\tcheck_object(s, page, p, SLUB_RED_INACTIVE);\n\t}\n\n\tmod_lruvec_page_state(page,\n\t\t(s->flags & SLAB_RECLAIM_ACCOUNT) ?\n\t\tNR_SLAB_RECLAIMABLE : NR_SLAB_UNRECLAIMABLE,\n\t\t-pages);\n\n\t__ClearPageSlabPfmemalloc(page);\n\t__ClearPageSlab(page);\n\n\tpage->mapping = NULL;\n\tif (current->reclaim_state)\n\t\tcurrent->reclaim_state->reclaimed_slab += pages;\n\tmemcg_uncharge_slab(page, order, s);\n\t__free_pages(page, order);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "h",
            "structpage",
            "rcu_head"
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void rcu_free_slab(struct rcu_head *h)\n{\n\tstruct page *page = container_of(h, struct page, rcu_head);\n\n\t__free_slab(page->slab_cache, page);\n}"
  },
  {
    "function_name": "__free_slab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1696-1723",
    "snippet": "static void __free_slab(struct kmem_cache *s, struct page *page)\n{\n\tint order = compound_order(page);\n\tint pages = 1 << order;\n\n\tif (s->flags & SLAB_CONSISTENCY_CHECKS) {\n\t\tvoid *p;\n\n\t\tslab_pad_check(s, page);\n\t\tfor_each_object(p, s, page_address(page),\n\t\t\t\t\t\tpage->objects)\n\t\t\tcheck_object(s, page, p, SLUB_RED_INACTIVE);\n\t}\n\n\tmod_lruvec_page_state(page,\n\t\t(s->flags & SLAB_RECLAIM_ACCOUNT) ?\n\t\tNR_SLAB_RECLAIMABLE : NR_SLAB_UNRECLAIMABLE,\n\t\t-pages);\n\n\t__ClearPageSlabPfmemalloc(page);\n\t__ClearPageSlab(page);\n\n\tpage->mapping = NULL;\n\tif (current->reclaim_state)\n\t\tcurrent->reclaim_state->reclaimed_slab += pages;\n\tmemcg_uncharge_slab(page, order, s);\n\t__free_pages(page, order);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_pages",
          "args": [
            "page",
            "order"
          ],
          "line": 1722
        },
        "resolved": true,
        "details": {
          "function_name": "__free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4430-4438",
          "snippet": "void __free_pages(struct page *page, unsigned int order)\n{\n\tif (put_page_testzero(page)) {\n\t\tif (order == 0)\n\t\t\tfree_unref_page(page);\n\t\telse\n\t\t\t__free_pages_ok(page, order);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid __free_pages(struct page *page, unsigned int order)\n{\n\tif (put_page_testzero(page)) {\n\t\tif (order == 0)\n\t\t\tfree_unref_page(page);\n\t\telse\n\t\t\t__free_pages_ok(page, order);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_uncharge_slab",
          "args": [
            "page",
            "order",
            "s"
          ],
          "line": 1721
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_uncharge_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "341-344",
          "snippet": "static inline void memcg_uncharge_slab(struct page *page, int order,\n\t\t\t\t       struct kmem_cache *s)\n{\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline void memcg_uncharge_slab(struct page *page, int order,\n\t\t\t\t       struct kmem_cache *s)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ClearPageSlab",
          "args": [
            "page"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ClearPageSlabPfmemalloc",
          "args": [
            "page"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mod_lruvec_page_state",
          "args": [
            "page",
            "(s->flags & SLAB_RECLAIM_ACCOUNT) ?\n\t\tNR_SLAB_RECLAIMABLE : NR_SLAB_UNRECLAIMABLE",
            "-pages"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_object",
          "args": [
            "s",
            "page",
            "p",
            "SLUB_RED_INACTIVE"
          ],
          "line": 1707
        },
        "resolved": true,
        "details": {
          "function_name": "check_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1344-1345",
          "snippet": "static inline int check_object(struct kmem_cache *s, struct page *page,\n\t\t\tvoid *object, u8 val) { return 1; }",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline int check_object(struct kmem_cache *s, struct page *page,\n\t\t\tvoid *object, u8 val) { return 1; }"
        }
      },
      {
        "call_info": {
          "callee": "for_each_object",
          "args": [
            "p",
            "s",
            "page_address(page)",
            "page->objects"
          ],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 1705
        },
        "resolved": true,
        "details": {
          "function_name": "page_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "409-434",
          "snippet": "void *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "slab_pad_check",
          "args": [
            "s",
            "page"
          ],
          "line": 1704
        },
        "resolved": true,
        "details": {
          "function_name": "slab_pad_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1342-1343",
          "snippet": "static inline int slab_pad_check(struct kmem_cache *s, struct page *page)\n\t\t\t{ return 1; }",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline int slab_pad_check(struct kmem_cache *s, struct page *page)\n\t\t\t{ return 1; }"
        }
      },
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "page"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void __free_slab(struct kmem_cache *s, struct page *page)\n{\n\tint order = compound_order(page);\n\tint pages = 1 << order;\n\n\tif (s->flags & SLAB_CONSISTENCY_CHECKS) {\n\t\tvoid *p;\n\n\t\tslab_pad_check(s, page);\n\t\tfor_each_object(p, s, page_address(page),\n\t\t\t\t\t\tpage->objects)\n\t\t\tcheck_object(s, page, p, SLUB_RED_INACTIVE);\n\t}\n\n\tmod_lruvec_page_state(page,\n\t\t(s->flags & SLAB_RECLAIM_ACCOUNT) ?\n\t\tNR_SLAB_RECLAIMABLE : NR_SLAB_UNRECLAIMABLE,\n\t\t-pages);\n\n\t__ClearPageSlabPfmemalloc(page);\n\t__ClearPageSlab(page);\n\n\tpage->mapping = NULL;\n\tif (current->reclaim_state)\n\t\tcurrent->reclaim_state->reclaimed_slab += pages;\n\tmemcg_uncharge_slab(page, order, s);\n\t__free_pages(page, order);\n}"
  },
  {
    "function_name": "new_slab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1682-1694",
    "snippet": "static struct page *new_slab(struct kmem_cache *s, gfp_t flags, int node)\n{\n\tif (unlikely(flags & GFP_SLAB_BUG_MASK)) {\n\t\tgfp_t invalid_mask = flags & GFP_SLAB_BUG_MASK;\n\t\tflags &= ~GFP_SLAB_BUG_MASK;\n\t\tpr_warn(\"Unexpected gfp: %#x (%pGg). Fixing up to gfp: %#x (%pGg). Fix your code!\\n\",\n\t\t\t\tinvalid_mask, &invalid_mask, flags, &flags);\n\t\tdump_stack();\n\t}\n\n\treturn allocate_slab(s,\n\t\tflags & (GFP_RECLAIM_MASK | GFP_CONSTRAINT_MASK), node);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "allocate_slab",
          "args": [
            "s",
            "flags & (GFP_RECLAIM_MASK | GFP_CONSTRAINT_MASK)",
            "node"
          ],
          "line": 1692
        },
        "resolved": true,
        "details": {
          "function_name": "allocate_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1597-1680",
          "snippet": "static struct page *allocate_slab(struct kmem_cache *s, gfp_t flags, int node)\n{\n\tstruct page *page;\n\tstruct kmem_cache_order_objects oo = s->oo;\n\tgfp_t alloc_gfp;\n\tvoid *start, *p;\n\tint idx, order;\n\tbool shuffle;\n\n\tflags &= gfp_allowed_mask;\n\n\tif (gfpflags_allow_blocking(flags))\n\t\tlocal_irq_enable();\n\n\tflags |= s->allocflags;\n\n\t/*\n\t * Let the initial higher-order allocation fail under memory pressure\n\t * so we fall-back to the minimum order allocation.\n\t */\n\talloc_gfp = (flags | __GFP_NOWARN | __GFP_NORETRY) & ~__GFP_NOFAIL;\n\tif ((alloc_gfp & __GFP_DIRECT_RECLAIM) && oo_order(oo) > oo_order(s->min))\n\t\talloc_gfp = (alloc_gfp | __GFP_NOMEMALLOC) & ~(__GFP_RECLAIM|__GFP_NOFAIL);\n\n\tpage = alloc_slab_page(s, alloc_gfp, node, oo);\n\tif (unlikely(!page)) {\n\t\too = s->min;\n\t\talloc_gfp = flags;\n\t\t/*\n\t\t * Allocation may have failed due to fragmentation.\n\t\t * Try a lower order alloc if possible\n\t\t */\n\t\tpage = alloc_slab_page(s, alloc_gfp, node, oo);\n\t\tif (unlikely(!page))\n\t\t\tgoto out;\n\t\tstat(s, ORDER_FALLBACK);\n\t}\n\n\tpage->objects = oo_objects(oo);\n\n\torder = compound_order(page);\n\tpage->slab_cache = s;\n\t__SetPageSlab(page);\n\tif (page_is_pfmemalloc(page))\n\t\tSetPageSlabPfmemalloc(page);\n\n\tstart = page_address(page);\n\n\tif (unlikely(s->flags & SLAB_POISON))\n\t\tmemset(start, POISON_INUSE, PAGE_SIZE << order);\n\n\tkasan_poison_slab(page);\n\n\tshuffle = shuffle_freelist(s, page);\n\n\tif (!shuffle) {\n\t\tfor_each_object_idx(p, idx, s, start, page->objects) {\n\t\t\tsetup_object(s, page, p);\n\t\t\tif (likely(idx < page->objects))\n\t\t\t\tset_freepointer(s, p, p + s->size);\n\t\t\telse\n\t\t\t\tset_freepointer(s, p, NULL);\n\t\t}\n\t\tpage->freelist = fixup_red_left(s, start);\n\t}\n\n\tpage->inuse = page->objects;\n\tpage->frozen = 1;\n\nout:\n\tif (gfpflags_allow_blocking(flags))\n\t\tlocal_irq_disable();\n\tif (!page)\n\t\treturn NULL;\n\n\tmod_lruvec_page_state(page,\n\t\t(s->flags & SLAB_RECLAIM_ACCOUNT) ?\n\t\tNR_SLAB_RECLAIMABLE : NR_SLAB_UNRECLAIMABLE,\n\t\t1 << oo_order(oo));\n\n\tinc_slabs_node(s, page_to_nid(page), page->objects);\n\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct page *allocate_slab(struct kmem_cache *s, gfp_t flags, int node)\n{\n\tstruct page *page;\n\tstruct kmem_cache_order_objects oo = s->oo;\n\tgfp_t alloc_gfp;\n\tvoid *start, *p;\n\tint idx, order;\n\tbool shuffle;\n\n\tflags &= gfp_allowed_mask;\n\n\tif (gfpflags_allow_blocking(flags))\n\t\tlocal_irq_enable();\n\n\tflags |= s->allocflags;\n\n\t/*\n\t * Let the initial higher-order allocation fail under memory pressure\n\t * so we fall-back to the minimum order allocation.\n\t */\n\talloc_gfp = (flags | __GFP_NOWARN | __GFP_NORETRY) & ~__GFP_NOFAIL;\n\tif ((alloc_gfp & __GFP_DIRECT_RECLAIM) && oo_order(oo) > oo_order(s->min))\n\t\talloc_gfp = (alloc_gfp | __GFP_NOMEMALLOC) & ~(__GFP_RECLAIM|__GFP_NOFAIL);\n\n\tpage = alloc_slab_page(s, alloc_gfp, node, oo);\n\tif (unlikely(!page)) {\n\t\too = s->min;\n\t\talloc_gfp = flags;\n\t\t/*\n\t\t * Allocation may have failed due to fragmentation.\n\t\t * Try a lower order alloc if possible\n\t\t */\n\t\tpage = alloc_slab_page(s, alloc_gfp, node, oo);\n\t\tif (unlikely(!page))\n\t\t\tgoto out;\n\t\tstat(s, ORDER_FALLBACK);\n\t}\n\n\tpage->objects = oo_objects(oo);\n\n\torder = compound_order(page);\n\tpage->slab_cache = s;\n\t__SetPageSlab(page);\n\tif (page_is_pfmemalloc(page))\n\t\tSetPageSlabPfmemalloc(page);\n\n\tstart = page_address(page);\n\n\tif (unlikely(s->flags & SLAB_POISON))\n\t\tmemset(start, POISON_INUSE, PAGE_SIZE << order);\n\n\tkasan_poison_slab(page);\n\n\tshuffle = shuffle_freelist(s, page);\n\n\tif (!shuffle) {\n\t\tfor_each_object_idx(p, idx, s, start, page->objects) {\n\t\t\tsetup_object(s, page, p);\n\t\t\tif (likely(idx < page->objects))\n\t\t\t\tset_freepointer(s, p, p + s->size);\n\t\t\telse\n\t\t\t\tset_freepointer(s, p, NULL);\n\t\t}\n\t\tpage->freelist = fixup_red_left(s, start);\n\t}\n\n\tpage->inuse = page->objects;\n\tpage->frozen = 1;\n\nout:\n\tif (gfpflags_allow_blocking(flags))\n\t\tlocal_irq_disable();\n\tif (!page)\n\t\treturn NULL;\n\n\tmod_lruvec_page_state(page,\n\t\t(s->flags & SLAB_RECLAIM_ACCOUNT) ?\n\t\tNR_SLAB_RECLAIMABLE : NR_SLAB_UNRECLAIMABLE,\n\t\t1 << oo_order(oo));\n\n\tinc_slabs_node(s, page_to_nid(page), page->objects);\n\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Unexpected gfp: %#x (%pGg). Fixing up to gfp: %#x (%pGg). Fix your code!\\n\"",
            "invalid_mask",
            "&invalid_mask",
            "flags",
            "&flags"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "flags & GFP_SLAB_BUG_MASK"
          ],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct page *new_slab(struct kmem_cache *s, gfp_t flags, int node)\n{\n\tif (unlikely(flags & GFP_SLAB_BUG_MASK)) {\n\t\tgfp_t invalid_mask = flags & GFP_SLAB_BUG_MASK;\n\t\tflags &= ~GFP_SLAB_BUG_MASK;\n\t\tpr_warn(\"Unexpected gfp: %#x (%pGg). Fixing up to gfp: %#x (%pGg). Fix your code!\\n\",\n\t\t\t\tinvalid_mask, &invalid_mask, flags, &flags);\n\t\tdump_stack();\n\t}\n\n\treturn allocate_slab(s,\n\t\tflags & (GFP_RECLAIM_MASK | GFP_CONSTRAINT_MASK), node);\n}"
  },
  {
    "function_name": "allocate_slab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1597-1680",
    "snippet": "static struct page *allocate_slab(struct kmem_cache *s, gfp_t flags, int node)\n{\n\tstruct page *page;\n\tstruct kmem_cache_order_objects oo = s->oo;\n\tgfp_t alloc_gfp;\n\tvoid *start, *p;\n\tint idx, order;\n\tbool shuffle;\n\n\tflags &= gfp_allowed_mask;\n\n\tif (gfpflags_allow_blocking(flags))\n\t\tlocal_irq_enable();\n\n\tflags |= s->allocflags;\n\n\t/*\n\t * Let the initial higher-order allocation fail under memory pressure\n\t * so we fall-back to the minimum order allocation.\n\t */\n\talloc_gfp = (flags | __GFP_NOWARN | __GFP_NORETRY) & ~__GFP_NOFAIL;\n\tif ((alloc_gfp & __GFP_DIRECT_RECLAIM) && oo_order(oo) > oo_order(s->min))\n\t\talloc_gfp = (alloc_gfp | __GFP_NOMEMALLOC) & ~(__GFP_RECLAIM|__GFP_NOFAIL);\n\n\tpage = alloc_slab_page(s, alloc_gfp, node, oo);\n\tif (unlikely(!page)) {\n\t\too = s->min;\n\t\talloc_gfp = flags;\n\t\t/*\n\t\t * Allocation may have failed due to fragmentation.\n\t\t * Try a lower order alloc if possible\n\t\t */\n\t\tpage = alloc_slab_page(s, alloc_gfp, node, oo);\n\t\tif (unlikely(!page))\n\t\t\tgoto out;\n\t\tstat(s, ORDER_FALLBACK);\n\t}\n\n\tpage->objects = oo_objects(oo);\n\n\torder = compound_order(page);\n\tpage->slab_cache = s;\n\t__SetPageSlab(page);\n\tif (page_is_pfmemalloc(page))\n\t\tSetPageSlabPfmemalloc(page);\n\n\tstart = page_address(page);\n\n\tif (unlikely(s->flags & SLAB_POISON))\n\t\tmemset(start, POISON_INUSE, PAGE_SIZE << order);\n\n\tkasan_poison_slab(page);\n\n\tshuffle = shuffle_freelist(s, page);\n\n\tif (!shuffle) {\n\t\tfor_each_object_idx(p, idx, s, start, page->objects) {\n\t\t\tsetup_object(s, page, p);\n\t\t\tif (likely(idx < page->objects))\n\t\t\t\tset_freepointer(s, p, p + s->size);\n\t\t\telse\n\t\t\t\tset_freepointer(s, p, NULL);\n\t\t}\n\t\tpage->freelist = fixup_red_left(s, start);\n\t}\n\n\tpage->inuse = page->objects;\n\tpage->frozen = 1;\n\nout:\n\tif (gfpflags_allow_blocking(flags))\n\t\tlocal_irq_disable();\n\tif (!page)\n\t\treturn NULL;\n\n\tmod_lruvec_page_state(page,\n\t\t(s->flags & SLAB_RECLAIM_ACCOUNT) ?\n\t\tNR_SLAB_RECLAIMABLE : NR_SLAB_UNRECLAIMABLE,\n\t\t1 << oo_order(oo));\n\n\tinc_slabs_node(s, page_to_nid(page), page->objects);\n\n\treturn page;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_slabs_node",
          "args": [
            "s",
            "page_to_nid(page)",
            "page->objects"
          ],
          "line": 1677
        },
        "resolved": true,
        "details": {
          "function_name": "inc_slabs_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1364-1365",
          "snippet": "static inline void inc_slabs_node(struct kmem_cache *s, int node,\n\t\t\t\t\t\t\tint objects) {}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void inc_slabs_node(struct kmem_cache *s, int node,\n\t\t\t\t\t\t\tint objects) {}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 1677
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "mod_lruvec_page_state",
          "args": [
            "page",
            "(s->flags & SLAB_RECLAIM_ACCOUNT) ?\n\t\tNR_SLAB_RECLAIMABLE : NR_SLAB_UNRECLAIMABLE",
            "1 << oo_order(oo)"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oo_order",
          "args": [
            "oo"
          ],
          "line": 1675
        },
        "resolved": true,
        "details": {
          "function_name": "oo_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "332-335",
          "snippet": "static inline unsigned int oo_order(struct kmem_cache_order_objects x)\n{\n\treturn x.x >> OO_SHIFT;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define OO_SHIFT\t16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define OO_SHIFT\t16\n\nstatic inline unsigned int oo_order(struct kmem_cache_order_objects x)\n{\n\treturn x.x >> OO_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfpflags_allow_blocking",
          "args": [
            "flags"
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fixup_red_left",
          "args": [
            "s",
            "start"
          ],
          "line": 1660
        },
        "resolved": true,
        "details": {
          "function_name": "fixup_red_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "127-133",
          "snippet": "void *fixup_red_left(struct kmem_cache *s, void *p)\n{\n\tif (kmem_cache_debug(s) && s->flags & SLAB_RED_ZONE)\n\t\tp += s->red_left_pad;\n\n\treturn p;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid *fixup_red_left(struct kmem_cache *s, void *p)\n{\n\tif (kmem_cache_debug(s) && s->flags & SLAB_RED_ZONE)\n\t\tp += s->red_left_pad;\n\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_freepointer",
          "args": [
            "s",
            "p",
            "NULL"
          ],
          "line": 1658
        },
        "resolved": true,
        "details": {
          "function_name": "set_freepointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "289-298",
          "snippet": "static inline void set_freepointer(struct kmem_cache *s, void *object, void *fp)\n{\n\tunsigned long freeptr_addr = (unsigned long)object + s->offset;\n\n#ifdef CONFIG_SLAB_FREELIST_HARDENED\n\tBUG_ON(object == fp); /* naive detection of double free or corruption */\n#endif\n\n\t*(void **)freeptr_addr = freelist_ptr(s, fp, freeptr_addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void set_freepointer(struct kmem_cache *s, void *object, void *fp)\n{\n\tunsigned long freeptr_addr = (unsigned long)object + s->offset;\n\n#ifdef CONFIG_SLAB_FREELIST_HARDENED\n\tBUG_ON(object == fp); /* naive detection of double free or corruption */\n#endif\n\n\t*(void **)freeptr_addr = freelist_ptr(s, fp, freeptr_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "idx < page->objects"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_object",
          "args": [
            "s",
            "page",
            "p"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "setup_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1454-1464",
          "snippet": "static void setup_object(struct kmem_cache *s, struct page *page,\n\t\t\t\tvoid *object)\n{\n\tsetup_object_debug(s, page, object);\n\tkasan_init_slab_obj(s, object);\n\tif (unlikely(s->ctor)) {\n\t\tkasan_unpoison_object_data(s, object);\n\t\ts->ctor(object);\n\t\tkasan_poison_object_data(s, object);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void setup_object(struct kmem_cache *s, struct page *page,\n\t\t\t\tvoid *object)\n{\n\tsetup_object_debug(s, page, object);\n\tkasan_init_slab_obj(s, object);\n\tif (unlikely(s->ctor)) {\n\t\tkasan_unpoison_object_data(s, object);\n\t\ts->ctor(object);\n\t\tkasan_poison_object_data(s, object);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_object_idx",
          "args": [
            "p",
            "idx",
            "s",
            "start",
            "page->objects"
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shuffle_freelist",
          "args": [
            "s",
            "page"
          ],
          "line": 1650
        },
        "resolved": true,
        "details": {
          "function_name": "shuffle_freelist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1591-1594",
          "snippet": "static inline bool shuffle_freelist(struct kmem_cache *s, struct page *page)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline bool shuffle_freelist(struct kmem_cache *s, struct page *page)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kasan_poison_slab",
          "args": [
            "page"
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_poison_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "397-402",
          "snippet": "void kasan_poison_slab(struct page *page)\n{\n\tkasan_poison_shadow(page_address(page),\n\t\t\tPAGE_SIZE << compound_order(page),\n\t\t\tKASAN_KMALLOC_REDZONE);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\nvoid kasan_poison_slab(struct page *page)\n{\n\tkasan_poison_shadow(page_address(page),\n\t\t\tPAGE_SIZE << compound_order(page),\n\t\t\tKASAN_KMALLOC_REDZONE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "start",
            "POISON_INUSE",
            "PAGE_SIZE << order"
          ],
          "line": 1646
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "s->flags & SLAB_POISON"
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 1643
        },
        "resolved": true,
        "details": {
          "function_name": "page_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "409-434",
          "snippet": "void *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageSlabPfmemalloc",
          "args": [
            "page"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_is_pfmemalloc",
          "args": [
            "page"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__SetPageSlab",
          "args": [
            "page"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "page"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oo_objects",
          "args": [
            "oo"
          ],
          "line": 1635
        },
        "resolved": true,
        "details": {
          "function_name": "oo_objects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "337-340",
          "snippet": "static inline unsigned int oo_objects(struct kmem_cache_order_objects x)\n{\n\treturn x.x & OO_MASK;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define OO_MASK\t\t((1 << OO_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define OO_MASK\t\t((1 << OO_SHIFT) - 1)\n\nstatic inline unsigned int oo_objects(struct kmem_cache_order_objects x)\n{\n\treturn x.x & OO_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "s",
            "ORDER_FALLBACK"
          ],
          "line": 1632
        },
        "resolved": true,
        "details": {
          "function_name": "slabinfo_show_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "5900-5902",
          "snippet": "void slabinfo_show_stats(struct seq_file *m, struct kmem_cache *s)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid slabinfo_show_stats(struct seq_file *m, struct kmem_cache *s)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page"
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_slab_page",
          "args": [
            "s",
            "alloc_gfp",
            "node",
            "oo"
          ],
          "line": 1629
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_slab_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1469-1486",
          "snippet": "static inline struct page *alloc_slab_page(struct kmem_cache *s,\n\t\tgfp_t flags, int node, struct kmem_cache_order_objects oo)\n{\n\tstruct page *page;\n\tunsigned int order = oo_order(oo);\n\n\tif (node == NUMA_NO_NODE)\n\t\tpage = alloc_pages(flags, order);\n\telse\n\t\tpage = __alloc_pages_node(node, flags, order);\n\n\tif (page && memcg_charge_slab(page, flags, order, s)) {\n\t\t__free_pages(page, order);\n\t\tpage = NULL;\n\t}\n\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline struct page *alloc_slab_page(struct kmem_cache *s,\n\t\tgfp_t flags, int node, struct kmem_cache_order_objects oo)\n{\n\tstruct page *page;\n\tunsigned int order = oo_order(oo);\n\n\tif (node == NUMA_NO_NODE)\n\t\tpage = alloc_pages(flags, order);\n\telse\n\t\tpage = __alloc_pages_node(node, flags, order);\n\n\tif (page && memcg_charge_slab(page, flags, order, s)) {\n\t\t__free_pages(page, order);\n\t\tpage = NULL;\n\t}\n\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfpflags_allow_blocking",
          "args": [
            "flags"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct page *allocate_slab(struct kmem_cache *s, gfp_t flags, int node)\n{\n\tstruct page *page;\n\tstruct kmem_cache_order_objects oo = s->oo;\n\tgfp_t alloc_gfp;\n\tvoid *start, *p;\n\tint idx, order;\n\tbool shuffle;\n\n\tflags &= gfp_allowed_mask;\n\n\tif (gfpflags_allow_blocking(flags))\n\t\tlocal_irq_enable();\n\n\tflags |= s->allocflags;\n\n\t/*\n\t * Let the initial higher-order allocation fail under memory pressure\n\t * so we fall-back to the minimum order allocation.\n\t */\n\talloc_gfp = (flags | __GFP_NOWARN | __GFP_NORETRY) & ~__GFP_NOFAIL;\n\tif ((alloc_gfp & __GFP_DIRECT_RECLAIM) && oo_order(oo) > oo_order(s->min))\n\t\talloc_gfp = (alloc_gfp | __GFP_NOMEMALLOC) & ~(__GFP_RECLAIM|__GFP_NOFAIL);\n\n\tpage = alloc_slab_page(s, alloc_gfp, node, oo);\n\tif (unlikely(!page)) {\n\t\too = s->min;\n\t\talloc_gfp = flags;\n\t\t/*\n\t\t * Allocation may have failed due to fragmentation.\n\t\t * Try a lower order alloc if possible\n\t\t */\n\t\tpage = alloc_slab_page(s, alloc_gfp, node, oo);\n\t\tif (unlikely(!page))\n\t\t\tgoto out;\n\t\tstat(s, ORDER_FALLBACK);\n\t}\n\n\tpage->objects = oo_objects(oo);\n\n\torder = compound_order(page);\n\tpage->slab_cache = s;\n\t__SetPageSlab(page);\n\tif (page_is_pfmemalloc(page))\n\t\tSetPageSlabPfmemalloc(page);\n\n\tstart = page_address(page);\n\n\tif (unlikely(s->flags & SLAB_POISON))\n\t\tmemset(start, POISON_INUSE, PAGE_SIZE << order);\n\n\tkasan_poison_slab(page);\n\n\tshuffle = shuffle_freelist(s, page);\n\n\tif (!shuffle) {\n\t\tfor_each_object_idx(p, idx, s, start, page->objects) {\n\t\t\tsetup_object(s, page, p);\n\t\t\tif (likely(idx < page->objects))\n\t\t\t\tset_freepointer(s, p, p + s->size);\n\t\t\telse\n\t\t\t\tset_freepointer(s, p, NULL);\n\t\t}\n\t\tpage->freelist = fixup_red_left(s, start);\n\t}\n\n\tpage->inuse = page->objects;\n\tpage->frozen = 1;\n\nout:\n\tif (gfpflags_allow_blocking(flags))\n\t\tlocal_irq_disable();\n\tif (!page)\n\t\treturn NULL;\n\n\tmod_lruvec_page_state(page,\n\t\t(s->flags & SLAB_RECLAIM_ACCOUNT) ?\n\t\tNR_SLAB_RECLAIMABLE : NR_SLAB_UNRECLAIMABLE,\n\t\t1 << oo_order(oo));\n\n\tinc_slabs_node(s, page_to_nid(page), page->objects);\n\n\treturn page;\n}"
  },
  {
    "function_name": "shuffle_freelist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1591-1594",
    "snippet": "static inline bool shuffle_freelist(struct kmem_cache *s, struct page *page)\n{\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline bool shuffle_freelist(struct kmem_cache *s, struct page *page)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "init_freelist_randomization",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1590-1590",
    "snippet": "static inline void init_freelist_randomization(void) { }",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void init_freelist_randomization(void) { }"
  },
  {
    "function_name": "init_cache_random_seq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1586-1589",
    "snippet": "static inline int init_cache_random_seq(struct kmem_cache *s)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline int init_cache_random_seq(struct kmem_cache *s)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "shuffle_freelist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1552-1584",
    "snippet": "static bool shuffle_freelist(struct kmem_cache *s, struct page *page)\n{\n\tvoid *start;\n\tvoid *cur;\n\tvoid *next;\n\tunsigned long idx, pos, page_limit, freelist_count;\n\n\tif (page->objects < 2 || !s->random_seq)\n\t\treturn false;\n\n\tfreelist_count = oo_objects(s->oo);\n\tpos = get_random_int() % freelist_count;\n\n\tpage_limit = page->objects * s->size;\n\tstart = fixup_red_left(s, page_address(page));\n\n\t/* First entry is used as the base of the freelist */\n\tcur = next_freelist_entry(s, page, &pos, start, page_limit,\n\t\t\t\tfreelist_count);\n\tpage->freelist = cur;\n\n\tfor (idx = 1; idx < page->objects; idx++) {\n\t\tsetup_object(s, page, cur);\n\t\tnext = next_freelist_entry(s, page, &pos, start, page_limit,\n\t\t\tfreelist_count);\n\t\tset_freepointer(s, cur, next);\n\t\tcur = next;\n\t}\n\tsetup_object(s, page, cur);\n\tset_freepointer(s, cur, NULL);\n\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_freepointer",
          "args": [
            "s",
            "cur",
            "NULL"
          ],
          "line": 1581
        },
        "resolved": true,
        "details": {
          "function_name": "set_freepointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "289-298",
          "snippet": "static inline void set_freepointer(struct kmem_cache *s, void *object, void *fp)\n{\n\tunsigned long freeptr_addr = (unsigned long)object + s->offset;\n\n#ifdef CONFIG_SLAB_FREELIST_HARDENED\n\tBUG_ON(object == fp); /* naive detection of double free or corruption */\n#endif\n\n\t*(void **)freeptr_addr = freelist_ptr(s, fp, freeptr_addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void set_freepointer(struct kmem_cache *s, void *object, void *fp)\n{\n\tunsigned long freeptr_addr = (unsigned long)object + s->offset;\n\n#ifdef CONFIG_SLAB_FREELIST_HARDENED\n\tBUG_ON(object == fp); /* naive detection of double free or corruption */\n#endif\n\n\t*(void **)freeptr_addr = freelist_ptr(s, fp, freeptr_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_object",
          "args": [
            "s",
            "page",
            "cur"
          ],
          "line": 1580
        },
        "resolved": true,
        "details": {
          "function_name": "setup_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1454-1464",
          "snippet": "static void setup_object(struct kmem_cache *s, struct page *page,\n\t\t\t\tvoid *object)\n{\n\tsetup_object_debug(s, page, object);\n\tkasan_init_slab_obj(s, object);\n\tif (unlikely(s->ctor)) {\n\t\tkasan_unpoison_object_data(s, object);\n\t\ts->ctor(object);\n\t\tkasan_poison_object_data(s, object);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void setup_object(struct kmem_cache *s, struct page *page,\n\t\t\t\tvoid *object)\n{\n\tsetup_object_debug(s, page, object);\n\tkasan_init_slab_obj(s, object);\n\tif (unlikely(s->ctor)) {\n\t\tkasan_unpoison_object_data(s, object);\n\t\ts->ctor(object);\n\t\tkasan_poison_object_data(s, object);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "next_freelist_entry",
          "args": [
            "s",
            "page",
            "&pos",
            "start",
            "page_limit",
            "freelist_count"
          ],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "next_freelist_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1530-1549",
          "snippet": "static void *next_freelist_entry(struct kmem_cache *s, struct page *page,\n\t\t\t\tunsigned long *pos, void *start,\n\t\t\t\tunsigned long page_limit,\n\t\t\t\tunsigned long freelist_count)\n{\n\tunsigned int idx;\n\n\t/*\n\t * If the target page allocation failed, the number of objects on the\n\t * page might be smaller than the usual size defined by the cache.\n\t */\n\tdo {\n\t\tidx = s->random_seq[*pos];\n\t\t*pos += 1;\n\t\tif (*pos >= freelist_count)\n\t\t\t*pos = 0;\n\t} while (unlikely(idx >= page_limit));\n\n\treturn (char *)start + idx;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void *next_freelist_entry(struct kmem_cache *s, struct page *page,\n\t\t\t\tunsigned long *pos, void *start,\n\t\t\t\tunsigned long page_limit,\n\t\t\t\tunsigned long freelist_count)\n{\n\tunsigned int idx;\n\n\t/*\n\t * If the target page allocation failed, the number of objects on the\n\t * page might be smaller than the usual size defined by the cache.\n\t */\n\tdo {\n\t\tidx = s->random_seq[*pos];\n\t\t*pos += 1;\n\t\tif (*pos >= freelist_count)\n\t\t\t*pos = 0;\n\t} while (unlikely(idx >= page_limit));\n\n\treturn (char *)start + idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fixup_red_left",
          "args": [
            "s",
            "page_address(page)"
          ],
          "line": 1566
        },
        "resolved": true,
        "details": {
          "function_name": "fixup_red_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "127-133",
          "snippet": "void *fixup_red_left(struct kmem_cache *s, void *p)\n{\n\tif (kmem_cache_debug(s) && s->flags & SLAB_RED_ZONE)\n\t\tp += s->red_left_pad;\n\n\treturn p;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid *fixup_red_left(struct kmem_cache *s, void *p)\n{\n\tif (kmem_cache_debug(s) && s->flags & SLAB_RED_ZONE)\n\t\tp += s->red_left_pad;\n\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 1566
        },
        "resolved": true,
        "details": {
          "function_name": "page_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "409-434",
          "snippet": "void *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_random_int",
          "args": [],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oo_objects",
          "args": [
            "s->oo"
          ],
          "line": 1562
        },
        "resolved": true,
        "details": {
          "function_name": "oo_objects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "337-340",
          "snippet": "static inline unsigned int oo_objects(struct kmem_cache_order_objects x)\n{\n\treturn x.x & OO_MASK;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define OO_MASK\t\t((1 << OO_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define OO_MASK\t\t((1 << OO_SHIFT) - 1)\n\nstatic inline unsigned int oo_objects(struct kmem_cache_order_objects x)\n{\n\treturn x.x & OO_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic bool shuffle_freelist(struct kmem_cache *s, struct page *page)\n{\n\tvoid *start;\n\tvoid *cur;\n\tvoid *next;\n\tunsigned long idx, pos, page_limit, freelist_count;\n\n\tif (page->objects < 2 || !s->random_seq)\n\t\treturn false;\n\n\tfreelist_count = oo_objects(s->oo);\n\tpos = get_random_int() % freelist_count;\n\n\tpage_limit = page->objects * s->size;\n\tstart = fixup_red_left(s, page_address(page));\n\n\t/* First entry is used as the base of the freelist */\n\tcur = next_freelist_entry(s, page, &pos, start, page_limit,\n\t\t\t\tfreelist_count);\n\tpage->freelist = cur;\n\n\tfor (idx = 1; idx < page->objects; idx++) {\n\t\tsetup_object(s, page, cur);\n\t\tnext = next_freelist_entry(s, page, &pos, start, page_limit,\n\t\t\tfreelist_count);\n\t\tset_freepointer(s, cur, next);\n\t\tcur = next;\n\t}\n\tsetup_object(s, page, cur);\n\tset_freepointer(s, cur, NULL);\n\n\treturn true;\n}"
  },
  {
    "function_name": "next_freelist_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1530-1549",
    "snippet": "static void *next_freelist_entry(struct kmem_cache *s, struct page *page,\n\t\t\t\tunsigned long *pos, void *start,\n\t\t\t\tunsigned long page_limit,\n\t\t\t\tunsigned long freelist_count)\n{\n\tunsigned int idx;\n\n\t/*\n\t * If the target page allocation failed, the number of objects on the\n\t * page might be smaller than the usual size defined by the cache.\n\t */\n\tdo {\n\t\tidx = s->random_seq[*pos];\n\t\t*pos += 1;\n\t\tif (*pos >= freelist_count)\n\t\t\t*pos = 0;\n\t} while (unlikely(idx >= page_limit));\n\n\treturn (char *)start + idx;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "idx >= page_limit"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void *next_freelist_entry(struct kmem_cache *s, struct page *page,\n\t\t\t\tunsigned long *pos, void *start,\n\t\t\t\tunsigned long page_limit,\n\t\t\t\tunsigned long freelist_count)\n{\n\tunsigned int idx;\n\n\t/*\n\t * If the target page allocation failed, the number of objects on the\n\t * page might be smaller than the usual size defined by the cache.\n\t */\n\tdo {\n\t\tidx = s->random_seq[*pos];\n\t\t*pos += 1;\n\t\tif (*pos >= freelist_count)\n\t\t\t*pos = 0;\n\t} while (unlikely(idx >= page_limit));\n\n\treturn (char *)start + idx;\n}"
  },
  {
    "function_name": "init_freelist_randomization",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1517-1527",
    "snippet": "static void __init init_freelist_randomization(void)\n{\n\tstruct kmem_cache *s;\n\n\tmutex_lock(&slab_mutex);\n\n\tlist_for_each_entry(s, &slab_caches, list)\n\t\tinit_cache_random_seq(s);\n\n\tmutex_unlock(&slab_mutex);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&slab_mutex"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_cache_random_seq",
          "args": [
            "s"
          ],
          "line": 1524
        },
        "resolved": true,
        "details": {
          "function_name": "init_cache_random_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1586-1589",
          "snippet": "static inline int init_cache_random_seq(struct kmem_cache *s)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline int init_cache_random_seq(struct kmem_cache *s)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "s",
            "&slab_caches",
            "list"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&slab_mutex"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void __init init_freelist_randomization(void)\n{\n\tstruct kmem_cache *s;\n\n\tmutex_lock(&slab_mutex);\n\n\tlist_for_each_entry(s, &slab_caches, list)\n\t\tinit_cache_random_seq(s);\n\n\tmutex_unlock(&slab_mutex);\n}"
  },
  {
    "function_name": "init_cache_random_seq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1490-1514",
    "snippet": "static int init_cache_random_seq(struct kmem_cache *s)\n{\n\tunsigned int count = oo_objects(s->oo);\n\tint err;\n\n\t/* Bailout if already initialised */\n\tif (s->random_seq)\n\t\treturn 0;\n\n\terr = cache_random_seq_create(s, count, GFP_KERNEL);\n\tif (err) {\n\t\tpr_err(\"SLUB: Unable to initialize free list for %s\\n\",\n\t\t\ts->name);\n\t\treturn err;\n\t}\n\n\t/* Transform to an offset on the set of pages */\n\tif (s->random_seq) {\n\t\tunsigned int i;\n\n\t\tfor (i = 0; i < count; i++)\n\t\t\ts->random_seq[i] *= s->size;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"SLUB: Unable to initialize free list for %s\\n\"",
            "s->name"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_random_seq_create",
          "args": [
            "s",
            "count",
            "GFP_KERNEL"
          ],
          "line": 1499
        },
        "resolved": true,
        "details": {
          "function_name": "cache_random_seq_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "523-527",
          "snippet": "static inline int cache_random_seq_create(struct kmem_cache *cachep,\n\t\t\t\t\tunsigned int count, gfp_t gfp)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline int cache_random_seq_create(struct kmem_cache *cachep,\n\t\t\t\t\tunsigned int count, gfp_t gfp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "oo_objects",
          "args": [
            "s->oo"
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "oo_objects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "337-340",
          "snippet": "static inline unsigned int oo_objects(struct kmem_cache_order_objects x)\n{\n\treturn x.x & OO_MASK;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define OO_MASK\t\t((1 << OO_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define OO_MASK\t\t((1 << OO_SHIFT) - 1)\n\nstatic inline unsigned int oo_objects(struct kmem_cache_order_objects x)\n{\n\treturn x.x & OO_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic int init_cache_random_seq(struct kmem_cache *s)\n{\n\tunsigned int count = oo_objects(s->oo);\n\tint err;\n\n\t/* Bailout if already initialised */\n\tif (s->random_seq)\n\t\treturn 0;\n\n\terr = cache_random_seq_create(s, count, GFP_KERNEL);\n\tif (err) {\n\t\tpr_err(\"SLUB: Unable to initialize free list for %s\\n\",\n\t\t\ts->name);\n\t\treturn err;\n\t}\n\n\t/* Transform to an offset on the set of pages */\n\tif (s->random_seq) {\n\t\tunsigned int i;\n\n\t\tfor (i = 0; i < count; i++)\n\t\t\ts->random_seq[i] *= s->size;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "alloc_slab_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1469-1486",
    "snippet": "static inline struct page *alloc_slab_page(struct kmem_cache *s,\n\t\tgfp_t flags, int node, struct kmem_cache_order_objects oo)\n{\n\tstruct page *page;\n\tunsigned int order = oo_order(oo);\n\n\tif (node == NUMA_NO_NODE)\n\t\tpage = alloc_pages(flags, order);\n\telse\n\t\tpage = __alloc_pages_node(node, flags, order);\n\n\tif (page && memcg_charge_slab(page, flags, order, s)) {\n\t\t__free_pages(page, order);\n\t\tpage = NULL;\n\t}\n\n\treturn page;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_pages",
          "args": [
            "page",
            "order"
          ],
          "line": 1481
        },
        "resolved": true,
        "details": {
          "function_name": "__free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4430-4438",
          "snippet": "void __free_pages(struct page *page, unsigned int order)\n{\n\tif (put_page_testzero(page)) {\n\t\tif (order == 0)\n\t\t\tfree_unref_page(page);\n\t\telse\n\t\t\t__free_pages_ok(page, order);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid __free_pages(struct page *page, unsigned int order)\n{\n\tif (put_page_testzero(page)) {\n\t\tif (order == 0)\n\t\t\tfree_unref_page(page);\n\t\telse\n\t\t\t__free_pages_ok(page, order);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_charge_slab",
          "args": [
            "page",
            "flags",
            "order",
            "s"
          ],
          "line": 1480
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_charge_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "335-339",
          "snippet": "static inline int memcg_charge_slab(struct page *page, gfp_t gfp, int order,\n\t\t\t\t    struct kmem_cache *s)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline int memcg_charge_slab(struct page *page, gfp_t gfp, int order,\n\t\t\t\t    struct kmem_cache *s)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__alloc_pages_node",
          "args": [
            "node",
            "flags",
            "order"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_pages",
          "args": [
            "flags",
            "order"
          ],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_pages_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4594-4601",
          "snippet": "void *alloc_pages_exact(size_t size, gfp_t gfp_mask)\n{\n\tunsigned int order = get_order(size);\n\tunsigned long addr;\n\n\taddr = __get_free_pages(gfp_mask, order);\n\treturn make_alloc_exact(addr, order, size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\n\nvoid *alloc_pages_exact(size_t size, gfp_t gfp_mask)\n{\n\tunsigned int order = get_order(size);\n\tunsigned long addr;\n\n\taddr = __get_free_pages(gfp_mask, order);\n\treturn make_alloc_exact(addr, order, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "oo_order",
          "args": [
            "oo"
          ],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "oo_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "332-335",
          "snippet": "static inline unsigned int oo_order(struct kmem_cache_order_objects x)\n{\n\treturn x.x >> OO_SHIFT;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define OO_SHIFT\t16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define OO_SHIFT\t16\n\nstatic inline unsigned int oo_order(struct kmem_cache_order_objects x)\n{\n\treturn x.x >> OO_SHIFT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline struct page *alloc_slab_page(struct kmem_cache *s,\n\t\tgfp_t flags, int node, struct kmem_cache_order_objects oo)\n{\n\tstruct page *page;\n\tunsigned int order = oo_order(oo);\n\n\tif (node == NUMA_NO_NODE)\n\t\tpage = alloc_pages(flags, order);\n\telse\n\t\tpage = __alloc_pages_node(node, flags, order);\n\n\tif (page && memcg_charge_slab(page, flags, order, s)) {\n\t\t__free_pages(page, order);\n\t\tpage = NULL;\n\t}\n\n\treturn page;\n}"
  },
  {
    "function_name": "setup_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1454-1464",
    "snippet": "static void setup_object(struct kmem_cache *s, struct page *page,\n\t\t\t\tvoid *object)\n{\n\tsetup_object_debug(s, page, object);\n\tkasan_init_slab_obj(s, object);\n\tif (unlikely(s->ctor)) {\n\t\tkasan_unpoison_object_data(s, object);\n\t\ts->ctor(object);\n\t\tkasan_poison_object_data(s, object);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kasan_poison_object_data",
          "args": [
            "s",
            "object"
          ],
          "line": 1462
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_poison_object_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "409-414",
          "snippet": "void kasan_poison_object_data(struct kmem_cache *cache, void *object)\n{\n\tkasan_poison_shadow(object,\n\t\t\tround_up(cache->object_size, KASAN_SHADOW_SCALE_SIZE),\n\t\t\tKASAN_KMALLOC_REDZONE);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\nvoid kasan_poison_object_data(struct kmem_cache *cache, void *object)\n{\n\tkasan_poison_shadow(object,\n\t\t\tround_up(cache->object_size, KASAN_SHADOW_SCALE_SIZE),\n\t\t\tKASAN_KMALLOC_REDZONE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "s->ctor",
          "args": [
            "object"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasan_unpoison_object_data",
          "args": [
            "s",
            "object"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_unpoison_object_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "404-407",
          "snippet": "void kasan_unpoison_object_data(struct kmem_cache *cache, void *object)\n{\n\tkasan_unpoison_shadow(object, cache->object_size);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\nvoid kasan_unpoison_object_data(struct kmem_cache *cache, void *object)\n{\n\tkasan_unpoison_shadow(object, cache->object_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "s->ctor"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasan_init_slab_obj",
          "args": [
            "s",
            "object"
          ],
          "line": 1458
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_init_slab_obj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "477-486",
          "snippet": "void kasan_init_slab_obj(struct kmem_cache *cache, const void *object)\n{\n\tstruct kasan_alloc_meta *alloc_info;\n\n\tif (!(cache->flags & SLAB_KASAN))\n\t\treturn;\n\n\talloc_info = get_alloc_info(cache, object);\n\t__memset(alloc_info, 0, sizeof(*alloc_info));\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\nvoid kasan_init_slab_obj(struct kmem_cache *cache, const void *object)\n{\n\tstruct kasan_alloc_meta *alloc_info;\n\n\tif (!(cache->flags & SLAB_KASAN))\n\t\treturn;\n\n\talloc_info = get_alloc_info(cache, object);\n\t__memset(alloc_info, 0, sizeof(*alloc_info));\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_object_debug",
          "args": [
            "s",
            "page",
            "object"
          ],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "setup_object_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1331-1332",
          "snippet": "static inline void setup_object_debug(struct kmem_cache *s,\n\t\t\tstruct page *page, void *object) {}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void setup_object_debug(struct kmem_cache *s,\n\t\t\tstruct page *page, void *object) {}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void setup_object(struct kmem_cache *s, struct page *page,\n\t\t\t\tvoid *object)\n{\n\tsetup_object_debug(s, page, object);\n\tkasan_init_slab_obj(s, object);\n\tif (unlikely(s->ctor)) {\n\t\tkasan_unpoison_object_data(s, object);\n\t\ts->ctor(object);\n\t\tkasan_poison_object_data(s, object);\n\t}\n}"
  },
  {
    "function_name": "slab_free_freelist_hook",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1412-1452",
    "snippet": "static inline bool slab_free_freelist_hook(struct kmem_cache *s,\n\t\t\t\t\t   void **head, void **tail)\n{\n/*\n * Compiler cannot detect this function can be removed if slab_free_hook()\n * evaluates to nothing.  Thus, catch all relevant config debug options here.\n */\n#if defined(CONFIG_LOCKDEP)\t||\t\t\\\n\tdefined(CONFIG_DEBUG_KMEMLEAK) ||\t\\\n\tdefined(CONFIG_DEBUG_OBJECTS_FREE) ||\t\\\n\tdefined(CONFIG_KASAN)\n\n\tvoid *object;\n\tvoid *next = *head;\n\tvoid *old_tail = *tail ? *tail : *head;\n\n\t/* Head and tail of the reconstructed freelist */\n\t*head = NULL;\n\t*tail = NULL;\n\n\tdo {\n\t\tobject = next;\n\t\tnext = get_freepointer(s, object);\n\t\t/* If object's reuse doesn't have to be delayed */\n\t\tif (!slab_free_hook(s, object)) {\n\t\t\t/* Move object to the new freelist */\n\t\t\tset_freepointer(s, object, *head);\n\t\t\t*head = object;\n\t\t\tif (!*tail)\n\t\t\t\t*tail = object;\n\t\t}\n\t} while (object != old_tail);\n\n\tif (*head == *tail)\n\t\t*tail = NULL;\n\n\treturn *head != NULL;\n#else\n\treturn true;\n#endif\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_freepointer",
          "args": [
            "s",
            "object",
            "*head"
          ],
          "line": 1438
        },
        "resolved": true,
        "details": {
          "function_name": "set_freepointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "289-298",
          "snippet": "static inline void set_freepointer(struct kmem_cache *s, void *object, void *fp)\n{\n\tunsigned long freeptr_addr = (unsigned long)object + s->offset;\n\n#ifdef CONFIG_SLAB_FREELIST_HARDENED\n\tBUG_ON(object == fp); /* naive detection of double free or corruption */\n#endif\n\n\t*(void **)freeptr_addr = freelist_ptr(s, fp, freeptr_addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void set_freepointer(struct kmem_cache *s, void *object, void *fp)\n{\n\tunsigned long freeptr_addr = (unsigned long)object + s->offset;\n\n#ifdef CONFIG_SLAB_FREELIST_HARDENED\n\tBUG_ON(object == fp); /* naive detection of double free or corruption */\n#endif\n\n\t*(void **)freeptr_addr = freelist_ptr(s, fp, freeptr_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "slab_free_hook",
          "args": [
            "s",
            "object"
          ],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "slab_free_hook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1387-1410",
          "snippet": "static __always_inline bool slab_free_hook(struct kmem_cache *s, void *x)\n{\n\tkmemleak_free_recursive(x, s->flags);\n\n\t/*\n\t * Trouble is that we may no longer disable interrupts in the fast path\n\t * So in order to make the debug calls that expect irqs to be\n\t * disabled we need to disable interrupts temporarily.\n\t */\n#ifdef CONFIG_LOCKDEP\n\t{\n\t\tunsigned long flags;\n\n\t\tlocal_irq_save(flags);\n\t\tdebug_check_no_locks_freed(x, s->object_size);\n\t\tlocal_irq_restore(flags);\n\t}\n#endif\n\tif (!(s->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(x, s->object_size);\n\n\t/* KASAN might put x into memory quarantine, delaying its reuse */\n\treturn kasan_slab_free(s, x, _RET_IP_);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic __always_inline bool slab_free_hook(struct kmem_cache *s, void *x)\n{\n\tkmemleak_free_recursive(x, s->flags);\n\n\t/*\n\t * Trouble is that we may no longer disable interrupts in the fast path\n\t * So in order to make the debug calls that expect irqs to be\n\t * disabled we need to disable interrupts temporarily.\n\t */\n#ifdef CONFIG_LOCKDEP\n\t{\n\t\tunsigned long flags;\n\n\t\tlocal_irq_save(flags);\n\t\tdebug_check_no_locks_freed(x, s->object_size);\n\t\tlocal_irq_restore(flags);\n\t}\n#endif\n\tif (!(s->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(x, s->object_size);\n\n\t/* KASAN might put x into memory quarantine, delaying its reuse */\n\treturn kasan_slab_free(s, x, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_freepointer",
          "args": [
            "s",
            "object"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "get_freepointer_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "276-287",
          "snippet": "static inline void *get_freepointer_safe(struct kmem_cache *s, void *object)\n{\n\tunsigned long freepointer_addr;\n\tvoid *p;\n\n\tif (!debug_pagealloc_enabled())\n\t\treturn get_freepointer(s, object);\n\n\tfreepointer_addr = (unsigned long)object + s->offset;\n\tprobe_kernel_read(&p, (void **)freepointer_addr, sizeof(p));\n\treturn freelist_ptr(s, p, freepointer_addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void *get_freepointer_safe(struct kmem_cache *s, void *object)\n{\n\tunsigned long freepointer_addr;\n\tvoid *p;\n\n\tif (!debug_pagealloc_enabled())\n\t\treturn get_freepointer(s, object);\n\n\tfreepointer_addr = (unsigned long)object + s->offset;\n\tprobe_kernel_read(&p, (void **)freepointer_addr, sizeof(p));\n\treturn freelist_ptr(s, p, freepointer_addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline bool slab_free_freelist_hook(struct kmem_cache *s,\n\t\t\t\t\t   void **head, void **tail)\n{\n/*\n * Compiler cannot detect this function can be removed if slab_free_hook()\n * evaluates to nothing.  Thus, catch all relevant config debug options here.\n */\n#if defined(CONFIG_LOCKDEP)\t||\t\t\\\n\tdefined(CONFIG_DEBUG_KMEMLEAK) ||\t\\\n\tdefined(CONFIG_DEBUG_OBJECTS_FREE) ||\t\\\n\tdefined(CONFIG_KASAN)\n\n\tvoid *object;\n\tvoid *next = *head;\n\tvoid *old_tail = *tail ? *tail : *head;\n\n\t/* Head and tail of the reconstructed freelist */\n\t*head = NULL;\n\t*tail = NULL;\n\n\tdo {\n\t\tobject = next;\n\t\tnext = get_freepointer(s, object);\n\t\t/* If object's reuse doesn't have to be delayed */\n\t\tif (!slab_free_hook(s, object)) {\n\t\t\t/* Move object to the new freelist */\n\t\t\tset_freepointer(s, object, *head);\n\t\t\t*head = object;\n\t\t\tif (!*tail)\n\t\t\t\t*tail = object;\n\t\t}\n\t} while (object != old_tail);\n\n\tif (*head == *tail)\n\t\t*tail = NULL;\n\n\treturn *head != NULL;\n#else\n\treturn true;\n#endif\n}"
  },
  {
    "function_name": "slab_free_hook",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1387-1410",
    "snippet": "static __always_inline bool slab_free_hook(struct kmem_cache *s, void *x)\n{\n\tkmemleak_free_recursive(x, s->flags);\n\n\t/*\n\t * Trouble is that we may no longer disable interrupts in the fast path\n\t * So in order to make the debug calls that expect irqs to be\n\t * disabled we need to disable interrupts temporarily.\n\t */\n#ifdef CONFIG_LOCKDEP\n\t{\n\t\tunsigned long flags;\n\n\t\tlocal_irq_save(flags);\n\t\tdebug_check_no_locks_freed(x, s->object_size);\n\t\tlocal_irq_restore(flags);\n\t}\n#endif\n\tif (!(s->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(x, s->object_size);\n\n\t/* KASAN might put x into memory quarantine, delaying its reuse */\n\treturn kasan_slab_free(s, x, _RET_IP_);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kasan_slab_free",
          "args": [
            "s",
            "x",
            "_RET_IP_"
          ],
          "line": 1409
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_slab_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "526-529",
          "snippet": "bool kasan_slab_free(struct kmem_cache *cache, void *object, unsigned long ip)\n{\n\treturn __kasan_slab_free(cache, object, ip, true);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\nbool kasan_slab_free(struct kmem_cache *cache, void *object, unsigned long ip)\n{\n\treturn __kasan_slab_free(cache, object, ip, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_check_no_obj_freed",
          "args": [
            "x",
            "s->object_size"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_check_no_locks_freed",
          "args": [
            "x",
            "s->object_size"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemleak_free_recursive",
          "args": [
            "x",
            "s->flags"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic __always_inline bool slab_free_hook(struct kmem_cache *s, void *x)\n{\n\tkmemleak_free_recursive(x, s->flags);\n\n\t/*\n\t * Trouble is that we may no longer disable interrupts in the fast path\n\t * So in order to make the debug calls that expect irqs to be\n\t * disabled we need to disable interrupts temporarily.\n\t */\n#ifdef CONFIG_LOCKDEP\n\t{\n\t\tunsigned long flags;\n\n\t\tlocal_irq_save(flags);\n\t\tdebug_check_no_locks_freed(x, s->object_size);\n\t\tlocal_irq_restore(flags);\n\t}\n#endif\n\tif (!(s->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(x, s->object_size);\n\n\t/* KASAN might put x into memory quarantine, delaying its reuse */\n\treturn kasan_slab_free(s, x, _RET_IP_);\n}"
  },
  {
    "function_name": "kfree_hook",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1381-1385",
    "snippet": "static __always_inline void kfree_hook(void *x)\n{\n\tkmemleak_free(x);\n\tkasan_kfree_large(x, _RET_IP_);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kasan_kfree_large",
          "args": [
            "x",
            "_RET_IP_"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_kfree_large",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "612-617",
          "snippet": "void kasan_kfree_large(void *ptr, unsigned long ip)\n{\n\tif (ptr != page_address(virt_to_head_page(ptr)))\n\t\tkasan_report_invalid_free(ptr, ip);\n\t/* The object will be poisoned by page_alloc. */\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\nvoid kasan_kfree_large(void *ptr, unsigned long ip)\n{\n\tif (ptr != page_address(virt_to_head_page(ptr)))\n\t\tkasan_report_invalid_free(ptr, ip);\n\t/* The object will be poisoned by page_alloc. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemleak_free",
          "args": [
            "x"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_free_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1082-1094",
          "snippet": "void __ref kmemleak_free_percpu(const void __percpu *ptr)\n{\n\tunsigned int cpu;\n\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (kmemleak_free_enabled && ptr && !IS_ERR(ptr))\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tdelete_object_full((unsigned long)per_cpu_ptr(ptr,\n\t\t\t\t\t\t\t\t      cpu));\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_FREE_PERCPU, ptr, 0, 0);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kmemleak_free_enabled;",
            "static int kmemleak_early_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_free_enabled;\nstatic int kmemleak_early_log = 1;\n\nvoid __ref kmemleak_free_percpu(const void __percpu *ptr)\n{\n\tunsigned int cpu;\n\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (kmemleak_free_enabled && ptr && !IS_ERR(ptr))\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tdelete_object_full((unsigned long)per_cpu_ptr(ptr,\n\t\t\t\t\t\t\t\t      cpu));\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_FREE_PERCPU, ptr, 0, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic __always_inline void kfree_hook(void *x)\n{\n\tkmemleak_free(x);\n\tkasan_kfree_large(x, _RET_IP_);\n}"
  },
  {
    "function_name": "kmalloc_large_node_hook",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1375-1379",
    "snippet": "static inline void kmalloc_large_node_hook(void *ptr, size_t size, gfp_t flags)\n{\n\tkmemleak_alloc(ptr, size, 1, flags);\n\tkasan_kmalloc_large(ptr, size, flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kasan_kmalloc_large",
          "args": [
            "ptr",
            "size",
            "flags"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_kmalloc_large",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "557-577",
          "snippet": "void kasan_kmalloc_large(const void *ptr, size_t size, gfp_t flags)\n{\n\tstruct page *page;\n\tunsigned long redzone_start;\n\tunsigned long redzone_end;\n\n\tif (gfpflags_allow_blocking(flags))\n\t\tquarantine_reduce();\n\n\tif (unlikely(ptr == NULL))\n\t\treturn;\n\n\tpage = virt_to_page(ptr);\n\tredzone_start = round_up((unsigned long)(ptr + size),\n\t\t\t\tKASAN_SHADOW_SCALE_SIZE);\n\tredzone_end = (unsigned long)ptr + (PAGE_SIZE << compound_order(page));\n\n\tkasan_unpoison_shadow(ptr, size);\n\tkasan_poison_shadow((void *)redzone_start, redzone_end - redzone_start,\n\t\tKASAN_PAGE_REDZONE);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid kasan_kmalloc_large(const void *ptr, size_t size, gfp_t flags)\n{\n\tstruct page *page;\n\tunsigned long redzone_start;\n\tunsigned long redzone_end;\n\n\tif (gfpflags_allow_blocking(flags))\n\t\tquarantine_reduce();\n\n\tif (unlikely(ptr == NULL))\n\t\treturn;\n\n\tpage = virt_to_page(ptr);\n\tredzone_start = round_up((unsigned long)(ptr + size),\n\t\t\t\tKASAN_SHADOW_SCALE_SIZE);\n\tredzone_end = (unsigned long)ptr + (PAGE_SIZE << compound_order(page));\n\n\tkasan_unpoison_shadow(ptr, size);\n\tkasan_poison_shadow((void *)redzone_start, redzone_end - redzone_start,\n\t\tKASAN_PAGE_REDZONE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemleak_alloc",
          "args": [
            "ptr",
            "size",
            "1",
            "flags"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_alloc_phys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1220-1225",
          "snippet": "void __ref kmemleak_alloc_phys(phys_addr_t phys, size_t size, int min_count,\n\t\t\t       gfp_t gfp)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_alloc(__va(phys), size, min_count, gfp);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nvoid __ref kmemleak_alloc_phys(phys_addr_t phys, size_t size, int min_count,\n\t\t\t       gfp_t gfp)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_alloc(__va(phys), size, min_count, gfp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void kmalloc_large_node_hook(void *ptr, size_t size, gfp_t flags)\n{\n\tkmemleak_alloc(ptr, size, 1, flags);\n\tkasan_kmalloc_large(ptr, size, flags);\n}"
  },
  {
    "function_name": "dec_slabs_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1366-1367",
    "snippet": "static inline void dec_slabs_node(struct kmem_cache *s, int node,\n\t\t\t\t\t\t\tint objects) {}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void dec_slabs_node(struct kmem_cache *s, int node,\n\t\t\t\t\t\t\tint objects) {}"
  },
  {
    "function_name": "inc_slabs_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1364-1365",
    "snippet": "static inline void inc_slabs_node(struct kmem_cache *s, int node,\n\t\t\t\t\t\t\tint objects) {}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void inc_slabs_node(struct kmem_cache *s, int node,\n\t\t\t\t\t\t\tint objects) {}"
  },
  {
    "function_name": "node_nr_slabs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1362-1363",
    "snippet": "static inline unsigned long node_nr_slabs(struct kmem_cache_node *n)\n\t\t\t\t\t\t\t{ return 0; }",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *kmem_cache_node;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic inline unsigned long node_nr_slabs(struct kmem_cache_node *n)\n\t\t\t\t\t\t\t{ return 0; }"
  },
  {
    "function_name": "slabs_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1360-1361",
    "snippet": "static inline unsigned long slabs_node(struct kmem_cache *s, int node)\n\t\t\t\t\t\t\t{ return 0; }",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline unsigned long slabs_node(struct kmem_cache *s, int node)\n\t\t\t\t\t\t\t{ return 0; }"
  },
  {
    "function_name": "kmem_cache_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1350-1355",
    "snippet": "slab_flags_t kmem_cache_flags(unsigned int object_size,\n\tslab_flags_t flags, const char *name,\n\tvoid (*ctor)(void *))\n{\n\treturn flags;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nslab_flags_t kmem_cache_flags(unsigned int object_size,\n\tslab_flags_t flags, const char *name,\n\tvoid (*ctor)(void *))\n{\n\treturn flags;\n}"
  },
  {
    "function_name": "remove_full",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1348-1349",
    "snippet": "static inline void remove_full(struct kmem_cache *s, struct kmem_cache_node *n,\n\t\t\t\t\tstruct page *page) {}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *kmem_cache_node;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic inline void remove_full(struct kmem_cache *s, struct kmem_cache_node *n,\n\t\t\t\t\tstruct page *page) {}"
  },
  {
    "function_name": "add_full",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1346-1347",
    "snippet": "static inline void add_full(struct kmem_cache *s, struct kmem_cache_node *n,\n\t\t\t\t\tstruct page *page) {}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *kmem_cache_node;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic inline void add_full(struct kmem_cache *s, struct kmem_cache_node *n,\n\t\t\t\t\tstruct page *page) {}"
  },
  {
    "function_name": "check_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1344-1345",
    "snippet": "static inline int check_object(struct kmem_cache *s, struct page *page,\n\t\t\tvoid *object, u8 val) { return 1; }",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline int check_object(struct kmem_cache *s, struct page *page,\n\t\t\tvoid *object, u8 val) { return 1; }"
  },
  {
    "function_name": "slab_pad_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1342-1343",
    "snippet": "static inline int slab_pad_check(struct kmem_cache *s, struct page *page)\n\t\t\t{ return 1; }",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline int slab_pad_check(struct kmem_cache *s, struct page *page)\n\t\t\t{ return 1; }"
  },
  {
    "function_name": "free_debug_processing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1337-1340",
    "snippet": "static inline int free_debug_processing(\n\tstruct kmem_cache *s, struct page *page,\n\tvoid *head, void *tail, int bulk_cnt,\n\tunsigned long addr) { return 0; }",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline int free_debug_processing(\n\tstruct kmem_cache *s, struct page *page,\n\tvoid *head, void *tail, int bulk_cnt,\n\tunsigned long addr) { return 0; }"
  },
  {
    "function_name": "alloc_debug_processing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1334-1335",
    "snippet": "static inline int alloc_debug_processing(struct kmem_cache *s,\n\tstruct page *page, void *object, unsigned long addr) { return 0; }",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline int alloc_debug_processing(struct kmem_cache *s,\n\tstruct page *page, void *object, unsigned long addr) { return 0; }"
  },
  {
    "function_name": "setup_object_debug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1331-1332",
    "snippet": "static inline void setup_object_debug(struct kmem_cache *s,\n\t\t\tstruct page *page, void *object) {}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void setup_object_debug(struct kmem_cache *s,\n\t\t\tstruct page *page, void *object) {}"
  },
  {
    "function_name": "kmem_cache_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1291-1329",
    "snippet": "slab_flags_t kmem_cache_flags(unsigned int object_size,\n\tslab_flags_t flags, const char *name,\n\tvoid (*ctor)(void *))\n{\n\tchar *iter;\n\tsize_t len;\n\n\t/* If slub_debug = 0, it folds into the if conditional. */\n\tif (!slub_debug_slabs)\n\t\treturn flags | slub_debug;\n\n\tlen = strlen(name);\n\titer = slub_debug_slabs;\n\twhile (*iter) {\n\t\tchar *end, *glob;\n\t\tsize_t cmplen;\n\n\t\tend = strchr(iter, ',');\n\t\tif (!end)\n\t\t\tend = iter + strlen(iter);\n\n\t\tglob = strnchr(iter, end - iter, '*');\n\t\tif (glob)\n\t\t\tcmplen = glob - iter;\n\t\telse\n\t\t\tcmplen = max_t(size_t, len, (end - iter));\n\n\t\tif (!strncmp(name, iter, cmplen)) {\n\t\t\tflags |= slub_debug;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!*end)\n\t\t\tbreak;\n\t\titer = end + 1;\n\t}\n\n\treturn flags;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define slub_debug 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "iter",
            "cmplen"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "size_t",
            "len",
            "(end - iter)"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnchr",
          "args": [
            "iter",
            "end - iter",
            "'*'"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "iter"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "iter",
            "','"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define slub_debug 0\n\nslab_flags_t kmem_cache_flags(unsigned int object_size,\n\tslab_flags_t flags, const char *name,\n\tvoid (*ctor)(void *))\n{\n\tchar *iter;\n\tsize_t len;\n\n\t/* If slub_debug = 0, it folds into the if conditional. */\n\tif (!slub_debug_slabs)\n\t\treturn flags | slub_debug;\n\n\tlen = strlen(name);\n\titer = slub_debug_slabs;\n\twhile (*iter) {\n\t\tchar *end, *glob;\n\t\tsize_t cmplen;\n\n\t\tend = strchr(iter, ',');\n\t\tif (!end)\n\t\t\tend = iter + strlen(iter);\n\n\t\tglob = strnchr(iter, end - iter, '*');\n\t\tif (glob)\n\t\t\tcmplen = glob - iter;\n\t\telse\n\t\t\tcmplen = max_t(size_t, len, (end - iter));\n\n\t\tif (!strncmp(name, iter, cmplen)) {\n\t\t\tflags |= slub_debug;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!*end)\n\t\t\tbreak;\n\t\titer = end + 1;\n\t}\n\n\treturn flags;\n}"
  },
  {
    "function_name": "setup_slub_debug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1211-1275",
    "snippet": "static int __init setup_slub_debug(char *str)\n{\n\tslub_debug = DEBUG_DEFAULT_FLAGS;\n\tif (*str++ != '=' || !*str)\n\t\t/*\n\t\t * No options specified. Switch on full debugging.\n\t\t */\n\t\tgoto out;\n\n\tif (*str == ',')\n\t\t/*\n\t\t * No options but restriction on slabs. This means full\n\t\t * debugging for slabs matching a pattern.\n\t\t */\n\t\tgoto check_slabs;\n\n\tslub_debug = 0;\n\tif (*str == '-')\n\t\t/*\n\t\t * Switch off all debugging measures.\n\t\t */\n\t\tgoto out;\n\n\t/*\n\t * Determine which debug features should be switched on\n\t */\n\tfor (; *str && *str != ','; str++) {\n\t\tswitch (tolower(*str)) {\n\t\tcase 'f':\n\t\t\tslub_debug |= SLAB_CONSISTENCY_CHECKS;\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\tslub_debug |= SLAB_RED_ZONE;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tslub_debug |= SLAB_POISON;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tslub_debug |= SLAB_STORE_USER;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tslub_debug |= SLAB_TRACE;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tslub_debug |= SLAB_FAILSLAB;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\t/*\n\t\t\t * Avoid enabling debugging on caches if its minimum\n\t\t\t * order would increase as a result.\n\t\t\t */\n\t\t\tdisable_higher_order_debug = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"slub_debug option '%c' unknown. skipped\\n\",\n\t\t\t       *str);\n\t\t}\n\t}\n\ncheck_slabs:\n\tif (*str == ',')\n\t\tslub_debug_slabs = str + 1;\nout:\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define disable_higher_order_debug 0",
      "#define slub_debug 0",
      "#define DEBUG_DEFAULT_FLAGS (SLAB_CONSISTENCY_CHECKS | SLAB_RED_ZONE | \\\n\t\t\t\tSLAB_POISON | SLAB_STORE_USER)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"slub_debug option '%c' unknown. skipped\\n\"",
            "*str"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tolower",
          "args": [
            "*str"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define disable_higher_order_debug 0\n#define slub_debug 0\n#define DEBUG_DEFAULT_FLAGS (SLAB_CONSISTENCY_CHECKS | SLAB_RED_ZONE | \\\n\t\t\t\tSLAB_POISON | SLAB_STORE_USER)\n\nstatic int __init setup_slub_debug(char *str)\n{\n\tslub_debug = DEBUG_DEFAULT_FLAGS;\n\tif (*str++ != '=' || !*str)\n\t\t/*\n\t\t * No options specified. Switch on full debugging.\n\t\t */\n\t\tgoto out;\n\n\tif (*str == ',')\n\t\t/*\n\t\t * No options but restriction on slabs. This means full\n\t\t * debugging for slabs matching a pattern.\n\t\t */\n\t\tgoto check_slabs;\n\n\tslub_debug = 0;\n\tif (*str == '-')\n\t\t/*\n\t\t * Switch off all debugging measures.\n\t\t */\n\t\tgoto out;\n\n\t/*\n\t * Determine which debug features should be switched on\n\t */\n\tfor (; *str && *str != ','; str++) {\n\t\tswitch (tolower(*str)) {\n\t\tcase 'f':\n\t\t\tslub_debug |= SLAB_CONSISTENCY_CHECKS;\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\tslub_debug |= SLAB_RED_ZONE;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tslub_debug |= SLAB_POISON;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tslub_debug |= SLAB_STORE_USER;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tslub_debug |= SLAB_TRACE;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tslub_debug |= SLAB_FAILSLAB;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\t/*\n\t\t\t * Avoid enabling debugging on caches if its minimum\n\t\t\t * order would increase as a result.\n\t\t\t */\n\t\t\tdisable_higher_order_debug = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"slub_debug option '%c' unknown. skipped\\n\",\n\t\t\t       *str);\n\t\t}\n\t}\n\ncheck_slabs:\n\tif (*str == ',')\n\t\tslub_debug_slabs = str + 1;\nout:\n\treturn 1;\n}"
  },
  {
    "function_name": "free_debug_processing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1159-1209",
    "snippet": "static noinline int free_debug_processing(\n\tstruct kmem_cache *s, struct page *page,\n\tvoid *head, void *tail, int bulk_cnt,\n\tunsigned long addr)\n{\n\tstruct kmem_cache_node *n = get_node(s, page_to_nid(page));\n\tvoid *object = head;\n\tint cnt = 0;\n\tunsigned long uninitialized_var(flags);\n\tint ret = 0;\n\n\tspin_lock_irqsave(&n->list_lock, flags);\n\tslab_lock(page);\n\n\tif (s->flags & SLAB_CONSISTENCY_CHECKS) {\n\t\tif (!check_slab(s, page))\n\t\t\tgoto out;\n\t}\n\nnext_object:\n\tcnt++;\n\n\tif (s->flags & SLAB_CONSISTENCY_CHECKS) {\n\t\tif (!free_consistency_checks(s, page, object, addr))\n\t\t\tgoto out;\n\t}\n\n\tif (s->flags & SLAB_STORE_USER)\n\t\tset_track(s, object, TRACK_FREE, addr);\n\ttrace(s, page, object, 0);\n\t/* Freepointer not overwritten by init_object(), SLAB_POISON moved it */\n\tinit_object(s, object, SLUB_RED_INACTIVE);\n\n\t/* Reached end of constructed freelist yet? */\n\tif (object != tail) {\n\t\tobject = get_freepointer(s, object);\n\t\tgoto next_object;\n\t}\n\tret = 1;\n\nout:\n\tif (cnt != bulk_cnt)\n\t\tslab_err(s, page, \"Bulk freelist count(%d) invalid(%d)\\n\",\n\t\t\t bulk_cnt, cnt);\n\n\tslab_unlock(page);\n\tspin_unlock_irqrestore(&n->list_lock, flags);\n\tif (!ret)\n\t\tslab_fix(s, \"Object at 0x%p not freed\", object);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *kmem_cache_node;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slab_fix",
          "args": [
            "s",
            "\"Object at 0x%p not freed\"",
            "object"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "slab_fix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "636-646",
          "snippet": "static void slab_fix(struct kmem_cache *s, char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_err(\"FIX %s: %pV\\n\", s->name, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void slab_fix(struct kmem_cache *s, char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_err(\"FIX %s: %pV\\n\", s->name, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&n->list_lock",
            "flags"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_unlock",
          "args": [
            "page"
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "slab_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "351-355",
          "snippet": "static __always_inline void slab_unlock(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\t__bit_spin_unlock(PG_locked, &page->flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic __always_inline void slab_unlock(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\t__bit_spin_unlock(PG_locked, &page->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "slab_err",
          "args": [
            "s",
            "page",
            "\"Bulk freelist count(%d) invalid(%d)\\n\"",
            "bulk_cnt",
            "cnt"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_freepointer",
          "args": [
            "s",
            "object"
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "get_freepointer_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "276-287",
          "snippet": "static inline void *get_freepointer_safe(struct kmem_cache *s, void *object)\n{\n\tunsigned long freepointer_addr;\n\tvoid *p;\n\n\tif (!debug_pagealloc_enabled())\n\t\treturn get_freepointer(s, object);\n\n\tfreepointer_addr = (unsigned long)object + s->offset;\n\tprobe_kernel_read(&p, (void **)freepointer_addr, sizeof(p));\n\treturn freelist_ptr(s, p, freepointer_addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void *get_freepointer_safe(struct kmem_cache *s, void *object)\n{\n\tunsigned long freepointer_addr;\n\tvoid *p;\n\n\tif (!debug_pagealloc_enabled())\n\t\treturn get_freepointer(s, object);\n\n\tfreepointer_addr = (unsigned long)object + s->offset;\n\tprobe_kernel_read(&p, (void **)freepointer_addr, sizeof(p));\n\treturn freelist_ptr(s, p, freepointer_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_object",
          "args": [
            "s",
            "object",
            "SLUB_RED_INACTIVE"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "init_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "711-725",
          "snippet": "static void init_object(struct kmem_cache *s, void *object, u8 val)\n{\n\tu8 *p = object;\n\n\tif (s->flags & SLAB_RED_ZONE)\n\t\tmemset(p - s->red_left_pad, val, s->red_left_pad);\n\n\tif (s->flags & __OBJECT_POISON) {\n\t\tmemset(p, POISON_FREE, s->object_size - 1);\n\t\tp[s->object_size - 1] = POISON_END;\n\t}\n\n\tif (s->flags & SLAB_RED_ZONE)\n\t\tmemset(p + s->object_size, val, s->inuse - s->object_size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define __OBJECT_POISON\t\t((slab_flags_t __force)0x80000000U)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define __OBJECT_POISON\t\t((slab_flags_t __force)0x80000000U)\n\nstatic void init_object(struct kmem_cache *s, void *object, u8 val)\n{\n\tu8 *p = object;\n\n\tif (s->flags & SLAB_RED_ZONE)\n\t\tmemset(p - s->red_left_pad, val, s->red_left_pad);\n\n\tif (s->flags & __OBJECT_POISON) {\n\t\tmemset(p, POISON_FREE, s->object_size - 1);\n\t\tp[s->object_size - 1] = POISON_END;\n\t}\n\n\tif (s->flags & SLAB_RED_ZONE)\n\t\tmemset(p + s->object_size, val, s->inuse - s->object_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace",
          "args": [
            "s",
            "page",
            "object",
            "0"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_alloc_node_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2790-2801",
          "snippet": "void *kmem_cache_alloc_node_trace(struct kmem_cache *s,\n\t\t\t\t    gfp_t gfpflags,\n\t\t\t\t    int node, size_t size)\n{\n\tvoid *ret = slab_alloc_node(s, gfpflags, node, _RET_IP_);\n\n\ttrace_kmalloc_node(_RET_IP_, ret,\n\t\t\t   size, s->size, gfpflags, node);\n\n\tkasan_kmalloc(s, ret, size, gfpflags);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);\n\nvoid *kmem_cache_alloc_node_trace(struct kmem_cache *s,\n\t\t\t\t    gfp_t gfpflags,\n\t\t\t\t    int node, size_t size)\n{\n\tvoid *ret = slab_alloc_node(s, gfpflags, node, _RET_IP_);\n\n\ttrace_kmalloc_node(_RET_IP_, ret,\n\t\t\t   size, s->size, gfpflags, node);\n\n\tkasan_kmalloc(s, ret, size, gfpflags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_track",
          "args": [
            "s",
            "object",
            "TRACK_FREE",
            "addr"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "set_track",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "541-573",
          "snippet": "static void set_track(struct kmem_cache *s, void *object,\n\t\t\tenum track_item alloc, unsigned long addr)\n{\n\tstruct track *p = get_track(s, object, alloc);\n\n\tif (addr) {\n#ifdef CONFIG_STACKTRACE\n\t\tstruct stack_trace trace;\n\t\tint i;\n\n\t\ttrace.nr_entries = 0;\n\t\ttrace.max_entries = TRACK_ADDRS_COUNT;\n\t\ttrace.entries = p->addrs;\n\t\ttrace.skip = 3;\n\t\tmetadata_access_enable();\n\t\tsave_stack_trace(&trace);\n\t\tmetadata_access_disable();\n\n\t\t/* See rant in lockdep.c */\n\t\tif (trace.nr_entries != 0 &&\n\t\t    trace.entries[trace.nr_entries - 1] == ULONG_MAX)\n\t\t\ttrace.nr_entries--;\n\n\t\tfor (i = trace.nr_entries; i < TRACK_ADDRS_COUNT; i++)\n\t\t\tp->addrs[i] = 0;\n#endif\n\t\tp->addr = addr;\n\t\tp->cpu = smp_processor_id();\n\t\tp->pid = current->pid;\n\t\tp->when = jiffies;\n\t} else\n\t\tmemset(p, 0, sizeof(struct track));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define TRACK_ADDRS_COUNT 16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define TRACK_ADDRS_COUNT 16\n\nstatic void set_track(struct kmem_cache *s, void *object,\n\t\t\tenum track_item alloc, unsigned long addr)\n{\n\tstruct track *p = get_track(s, object, alloc);\n\n\tif (addr) {\n#ifdef CONFIG_STACKTRACE\n\t\tstruct stack_trace trace;\n\t\tint i;\n\n\t\ttrace.nr_entries = 0;\n\t\ttrace.max_entries = TRACK_ADDRS_COUNT;\n\t\ttrace.entries = p->addrs;\n\t\ttrace.skip = 3;\n\t\tmetadata_access_enable();\n\t\tsave_stack_trace(&trace);\n\t\tmetadata_access_disable();\n\n\t\t/* See rant in lockdep.c */\n\t\tif (trace.nr_entries != 0 &&\n\t\t    trace.entries[trace.nr_entries - 1] == ULONG_MAX)\n\t\t\ttrace.nr_entries--;\n\n\t\tfor (i = trace.nr_entries; i < TRACK_ADDRS_COUNT; i++)\n\t\t\tp->addrs[i] = 0;\n#endif\n\t\tp->addr = addr;\n\t\tp->cpu = smp_processor_id();\n\t\tp->pid = current->pid;\n\t\tp->when = jiffies;\n\t} else\n\t\tmemset(p, 0, sizeof(struct track));\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_consistency_checks",
          "args": [
            "s",
            "page",
            "object",
            "addr"
          ],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "free_consistency_checks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1126-1156",
          "snippet": "static inline int free_consistency_checks(struct kmem_cache *s,\n\t\tstruct page *page, void *object, unsigned long addr)\n{\n\tif (!check_valid_pointer(s, page, object)) {\n\t\tslab_err(s, page, \"Invalid object pointer 0x%p\", object);\n\t\treturn 0;\n\t}\n\n\tif (on_freelist(s, page, object)) {\n\t\tobject_err(s, page, object, \"Object already free\");\n\t\treturn 0;\n\t}\n\n\tif (!check_object(s, page, object, SLUB_RED_ACTIVE))\n\t\treturn 0;\n\n\tif (unlikely(s != page->slab_cache)) {\n\t\tif (!PageSlab(page)) {\n\t\t\tslab_err(s, page, \"Attempt to free object(0x%p) outside of slab\",\n\t\t\t\t object);\n\t\t} else if (!page->slab_cache) {\n\t\t\tpr_err(\"SLUB <none>: no slab for object 0x%p.\\n\",\n\t\t\t       object);\n\t\t\tdump_stack();\n\t\t} else\n\t\t\tobject_err(s, page, object,\n\t\t\t\t\t\"page slab pointer corrupt.\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline int free_consistency_checks(struct kmem_cache *s,\n\t\tstruct page *page, void *object, unsigned long addr)\n{\n\tif (!check_valid_pointer(s, page, object)) {\n\t\tslab_err(s, page, \"Invalid object pointer 0x%p\", object);\n\t\treturn 0;\n\t}\n\n\tif (on_freelist(s, page, object)) {\n\t\tobject_err(s, page, object, \"Object already free\");\n\t\treturn 0;\n\t}\n\n\tif (!check_object(s, page, object, SLUB_RED_ACTIVE))\n\t\treturn 0;\n\n\tif (unlikely(s != page->slab_cache)) {\n\t\tif (!PageSlab(page)) {\n\t\t\tslab_err(s, page, \"Attempt to free object(0x%p) outside of slab\",\n\t\t\t\t object);\n\t\t} else if (!page->slab_cache) {\n\t\t\tpr_err(\"SLUB <none>: no slab for object 0x%p.\\n\",\n\t\t\t       object);\n\t\t\tdump_stack();\n\t\t} else\n\t\t\tobject_err(s, page, object,\n\t\t\t\t\t\"page slab pointer corrupt.\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_slab",
          "args": [
            "s",
            "page"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "check_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "911-936",
          "snippet": "static int check_slab(struct kmem_cache *s, struct page *page)\n{\n\tint maxobj;\n\n\tVM_BUG_ON(!irqs_disabled());\n\n\tif (!PageSlab(page)) {\n\t\tslab_err(s, page, \"Not a valid slab page\");\n\t\treturn 0;\n\t}\n\n\tmaxobj = order_objects(compound_order(page), s->size);\n\tif (page->objects > maxobj) {\n\t\tslab_err(s, page, \"objects %u > max %u\",\n\t\t\tpage->objects, maxobj);\n\t\treturn 0;\n\t}\n\tif (page->inuse > page->objects) {\n\t\tslab_err(s, page, \"inuse %u > max %u\",\n\t\t\tpage->inuse, page->objects);\n\t\treturn 0;\n\t}\n\t/* Slab_pad_check fixes things up after itself */\n\tslab_pad_check(s, page);\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic int check_slab(struct kmem_cache *s, struct page *page)\n{\n\tint maxobj;\n\n\tVM_BUG_ON(!irqs_disabled());\n\n\tif (!PageSlab(page)) {\n\t\tslab_err(s, page, \"Not a valid slab page\");\n\t\treturn 0;\n\t}\n\n\tmaxobj = order_objects(compound_order(page), s->size);\n\tif (page->objects > maxobj) {\n\t\tslab_err(s, page, \"objects %u > max %u\",\n\t\t\tpage->objects, maxobj);\n\t\treturn 0;\n\t}\n\tif (page->inuse > page->objects) {\n\t\tslab_err(s, page, \"inuse %u > max %u\",\n\t\t\tpage->inuse, page->objects);\n\t\treturn 0;\n\t}\n\t/* Slab_pad_check fixes things up after itself */\n\tslab_pad_check(s, page);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "slab_lock",
          "args": [
            "page"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "slab_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "345-349",
          "snippet": "static __always_inline void slab_lock(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tbit_spin_lock(PG_locked, &page->flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic __always_inline void slab_lock(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tbit_spin_lock(PG_locked, &page->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&n->list_lock",
            "flags"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node",
          "args": [
            "s",
            "page_to_nid(page)"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "get_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "485-488",
          "snippet": "static inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic noinline int free_debug_processing(\n\tstruct kmem_cache *s, struct page *page,\n\tvoid *head, void *tail, int bulk_cnt,\n\tunsigned long addr)\n{\n\tstruct kmem_cache_node *n = get_node(s, page_to_nid(page));\n\tvoid *object = head;\n\tint cnt = 0;\n\tunsigned long uninitialized_var(flags);\n\tint ret = 0;\n\n\tspin_lock_irqsave(&n->list_lock, flags);\n\tslab_lock(page);\n\n\tif (s->flags & SLAB_CONSISTENCY_CHECKS) {\n\t\tif (!check_slab(s, page))\n\t\t\tgoto out;\n\t}\n\nnext_object:\n\tcnt++;\n\n\tif (s->flags & SLAB_CONSISTENCY_CHECKS) {\n\t\tif (!free_consistency_checks(s, page, object, addr))\n\t\t\tgoto out;\n\t}\n\n\tif (s->flags & SLAB_STORE_USER)\n\t\tset_track(s, object, TRACK_FREE, addr);\n\ttrace(s, page, object, 0);\n\t/* Freepointer not overwritten by init_object(), SLAB_POISON moved it */\n\tinit_object(s, object, SLUB_RED_INACTIVE);\n\n\t/* Reached end of constructed freelist yet? */\n\tif (object != tail) {\n\t\tobject = get_freepointer(s, object);\n\t\tgoto next_object;\n\t}\n\tret = 1;\n\nout:\n\tif (cnt != bulk_cnt)\n\t\tslab_err(s, page, \"Bulk freelist count(%d) invalid(%d)\\n\",\n\t\t\t bulk_cnt, cnt);\n\n\tslab_unlock(page);\n\tspin_unlock_irqrestore(&n->list_lock, flags);\n\tif (!ret)\n\t\tslab_fix(s, \"Object at 0x%p not freed\", object);\n\treturn ret;\n}"
  },
  {
    "function_name": "free_consistency_checks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1126-1156",
    "snippet": "static inline int free_consistency_checks(struct kmem_cache *s,\n\t\tstruct page *page, void *object, unsigned long addr)\n{\n\tif (!check_valid_pointer(s, page, object)) {\n\t\tslab_err(s, page, \"Invalid object pointer 0x%p\", object);\n\t\treturn 0;\n\t}\n\n\tif (on_freelist(s, page, object)) {\n\t\tobject_err(s, page, object, \"Object already free\");\n\t\treturn 0;\n\t}\n\n\tif (!check_object(s, page, object, SLUB_RED_ACTIVE))\n\t\treturn 0;\n\n\tif (unlikely(s != page->slab_cache)) {\n\t\tif (!PageSlab(page)) {\n\t\t\tslab_err(s, page, \"Attempt to free object(0x%p) outside of slab\",\n\t\t\t\t object);\n\t\t} else if (!page->slab_cache) {\n\t\t\tpr_err(\"SLUB <none>: no slab for object 0x%p.\\n\",\n\t\t\t       object);\n\t\t\tdump_stack();\n\t\t} else\n\t\t\tobject_err(s, page, object,\n\t\t\t\t\t\"page slab pointer corrupt.\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "object_err",
          "args": [
            "s",
            "page",
            "object",
            "\"page slab pointer corrupt.\""
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "object_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "690-695",
          "snippet": "void object_err(struct kmem_cache *s, struct page *page,\n\t\t\tu8 *object, char *reason)\n{\n\tslab_bug(s, \"%s\", reason);\n\tprint_trailer(s, page, object);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid object_err(struct kmem_cache *s, struct page *page,\n\t\t\tu8 *object, char *reason)\n{\n\tslab_bug(s, \"%s\", reason);\n\tprint_trailer(s, page, object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"SLUB <none>: no slab for object 0x%p.\\n\"",
            "object"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_err",
          "args": [
            "s",
            "page",
            "\"Attempt to free object(0x%p) outside of slab\"",
            "object"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSlab",
          "args": [
            "page"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "s != page->slab_cache"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_object",
          "args": [
            "s",
            "page",
            "object",
            "SLUB_RED_ACTIVE"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "check_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1344-1345",
          "snippet": "static inline int check_object(struct kmem_cache *s, struct page *page,\n\t\t\tvoid *object, u8 val) { return 1; }",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline int check_object(struct kmem_cache *s, struct page *page,\n\t\t\tvoid *object, u8 val) { return 1; }"
        }
      },
      {
        "call_info": {
          "callee": "on_freelist",
          "args": [
            "s",
            "page",
            "object"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "on_freelist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "942-989",
          "snippet": "static int on_freelist(struct kmem_cache *s, struct page *page, void *search)\n{\n\tint nr = 0;\n\tvoid *fp;\n\tvoid *object = NULL;\n\tint max_objects;\n\n\tfp = page->freelist;\n\twhile (fp && nr <= page->objects) {\n\t\tif (fp == search)\n\t\t\treturn 1;\n\t\tif (!check_valid_pointer(s, page, fp)) {\n\t\t\tif (object) {\n\t\t\t\tobject_err(s, page, object,\n\t\t\t\t\t\"Freechain corrupt\");\n\t\t\t\tset_freepointer(s, object, NULL);\n\t\t\t} else {\n\t\t\t\tslab_err(s, page, \"Freepointer corrupt\");\n\t\t\t\tpage->freelist = NULL;\n\t\t\t\tpage->inuse = page->objects;\n\t\t\t\tslab_fix(s, \"Freelist cleared\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tobject = fp;\n\t\tfp = get_freepointer(s, object);\n\t\tnr++;\n\t}\n\n\tmax_objects = order_objects(compound_order(page), s->size);\n\tif (max_objects > MAX_OBJS_PER_PAGE)\n\t\tmax_objects = MAX_OBJS_PER_PAGE;\n\n\tif (page->objects != max_objects) {\n\t\tslab_err(s, page, \"Wrong number of objects. Found %d but should be %d\",\n\t\t\t page->objects, max_objects);\n\t\tpage->objects = max_objects;\n\t\tslab_fix(s, \"Number of objects adjusted.\");\n\t}\n\tif (page->inuse != page->objects - nr) {\n\t\tslab_err(s, page, \"Wrong object count. Counter is %d but counted were %d\",\n\t\t\t page->inuse, page->objects - nr);\n\t\tpage->inuse = page->objects - nr;\n\t\tslab_fix(s, \"Object count adjusted.\");\n\t}\n\treturn search == NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define MAX_OBJS_PER_PAGE\t32767 /* since page.objects is u15 */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define MAX_OBJS_PER_PAGE\t32767 /* since page.objects is u15 */\n\nstatic int on_freelist(struct kmem_cache *s, struct page *page, void *search)\n{\n\tint nr = 0;\n\tvoid *fp;\n\tvoid *object = NULL;\n\tint max_objects;\n\n\tfp = page->freelist;\n\twhile (fp && nr <= page->objects) {\n\t\tif (fp == search)\n\t\t\treturn 1;\n\t\tif (!check_valid_pointer(s, page, fp)) {\n\t\t\tif (object) {\n\t\t\t\tobject_err(s, page, object,\n\t\t\t\t\t\"Freechain corrupt\");\n\t\t\t\tset_freepointer(s, object, NULL);\n\t\t\t} else {\n\t\t\t\tslab_err(s, page, \"Freepointer corrupt\");\n\t\t\t\tpage->freelist = NULL;\n\t\t\t\tpage->inuse = page->objects;\n\t\t\t\tslab_fix(s, \"Freelist cleared\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tobject = fp;\n\t\tfp = get_freepointer(s, object);\n\t\tnr++;\n\t}\n\n\tmax_objects = order_objects(compound_order(page), s->size);\n\tif (max_objects > MAX_OBJS_PER_PAGE)\n\t\tmax_objects = MAX_OBJS_PER_PAGE;\n\n\tif (page->objects != max_objects) {\n\t\tslab_err(s, page, \"Wrong number of objects. Found %d but should be %d\",\n\t\t\t page->objects, max_objects);\n\t\tpage->objects = max_objects;\n\t\tslab_fix(s, \"Number of objects adjusted.\");\n\t}\n\tif (page->inuse != page->objects - nr) {\n\t\tslab_err(s, page, \"Wrong object count. Counter is %d but counted were %d\",\n\t\t\t page->inuse, page->objects - nr);\n\t\tpage->inuse = page->objects - nr;\n\t\tslab_fix(s, \"Object count adjusted.\");\n\t}\n\treturn search == NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "slab_err",
          "args": [
            "s",
            "page",
            "\"Invalid object pointer 0x%p\"",
            "object"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_valid_pointer",
          "args": [
            "s",
            "page",
            "object"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "check_valid_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "501-517",
          "snippet": "static inline int check_valid_pointer(struct kmem_cache *s,\n\t\t\t\tstruct page *page, void *object)\n{\n\tvoid *base;\n\n\tif (!object)\n\t\treturn 1;\n\n\tbase = page_address(page);\n\tobject = restore_red_left(s, object);\n\tif (object < base || object >= base + page->objects * s->size ||\n\t\t(object - base) % s->size) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline int check_valid_pointer(struct kmem_cache *s,\n\t\t\t\tstruct page *page, void *object)\n{\n\tvoid *base;\n\n\tif (!object)\n\t\treturn 1;\n\n\tbase = page_address(page);\n\tobject = restore_red_left(s, object);\n\tif (object < base || object >= base + page->objects * s->size ||\n\t\t(object - base) % s->size) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline int free_consistency_checks(struct kmem_cache *s,\n\t\tstruct page *page, void *object, unsigned long addr)\n{\n\tif (!check_valid_pointer(s, page, object)) {\n\t\tslab_err(s, page, \"Invalid object pointer 0x%p\", object);\n\t\treturn 0;\n\t}\n\n\tif (on_freelist(s, page, object)) {\n\t\tobject_err(s, page, object, \"Object already free\");\n\t\treturn 0;\n\t}\n\n\tif (!check_object(s, page, object, SLUB_RED_ACTIVE))\n\t\treturn 0;\n\n\tif (unlikely(s != page->slab_cache)) {\n\t\tif (!PageSlab(page)) {\n\t\t\tslab_err(s, page, \"Attempt to free object(0x%p) outside of slab\",\n\t\t\t\t object);\n\t\t} else if (!page->slab_cache) {\n\t\t\tpr_err(\"SLUB <none>: no slab for object 0x%p.\\n\",\n\t\t\t       object);\n\t\t\tdump_stack();\n\t\t} else\n\t\t\tobject_err(s, page, object,\n\t\t\t\t\t\"page slab pointer corrupt.\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "alloc_debug_processing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1096-1124",
    "snippet": "static noinline int alloc_debug_processing(struct kmem_cache *s,\n\t\t\t\t\tstruct page *page,\n\t\t\t\t\tvoid *object, unsigned long addr)\n{\n\tif (s->flags & SLAB_CONSISTENCY_CHECKS) {\n\t\tif (!alloc_consistency_checks(s, page, object, addr))\n\t\t\tgoto bad;\n\t}\n\n\t/* Success perform special debug activities for allocs */\n\tif (s->flags & SLAB_STORE_USER)\n\t\tset_track(s, object, TRACK_ALLOC, addr);\n\ttrace(s, page, object, 1);\n\tinit_object(s, object, SLUB_RED_ACTIVE);\n\treturn 1;\n\nbad:\n\tif (PageSlab(page)) {\n\t\t/*\n\t\t * If this is a slab page then lets do the best we can\n\t\t * to avoid issues in the future. Marking all objects\n\t\t * as used avoids touching the remaining objects.\n\t\t */\n\t\tslab_fix(s, \"Marking all objects used\");\n\t\tpage->inuse = page->objects;\n\t\tpage->freelist = NULL;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "slab_fix",
          "args": [
            "s",
            "\"Marking all objects used\""
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "slab_fix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "636-646",
          "snippet": "static void slab_fix(struct kmem_cache *s, char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_err(\"FIX %s: %pV\\n\", s->name, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void slab_fix(struct kmem_cache *s, char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_err(\"FIX %s: %pV\\n\", s->name, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageSlab",
          "args": [
            "page"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_object",
          "args": [
            "s",
            "object",
            "SLUB_RED_ACTIVE"
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "init_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "711-725",
          "snippet": "static void init_object(struct kmem_cache *s, void *object, u8 val)\n{\n\tu8 *p = object;\n\n\tif (s->flags & SLAB_RED_ZONE)\n\t\tmemset(p - s->red_left_pad, val, s->red_left_pad);\n\n\tif (s->flags & __OBJECT_POISON) {\n\t\tmemset(p, POISON_FREE, s->object_size - 1);\n\t\tp[s->object_size - 1] = POISON_END;\n\t}\n\n\tif (s->flags & SLAB_RED_ZONE)\n\t\tmemset(p + s->object_size, val, s->inuse - s->object_size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define __OBJECT_POISON\t\t((slab_flags_t __force)0x80000000U)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define __OBJECT_POISON\t\t((slab_flags_t __force)0x80000000U)\n\nstatic void init_object(struct kmem_cache *s, void *object, u8 val)\n{\n\tu8 *p = object;\n\n\tif (s->flags & SLAB_RED_ZONE)\n\t\tmemset(p - s->red_left_pad, val, s->red_left_pad);\n\n\tif (s->flags & __OBJECT_POISON) {\n\t\tmemset(p, POISON_FREE, s->object_size - 1);\n\t\tp[s->object_size - 1] = POISON_END;\n\t}\n\n\tif (s->flags & SLAB_RED_ZONE)\n\t\tmemset(p + s->object_size, val, s->inuse - s->object_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace",
          "args": [
            "s",
            "page",
            "object",
            "1"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_alloc_node_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "2790-2801",
          "snippet": "void *kmem_cache_alloc_node_trace(struct kmem_cache *s,\n\t\t\t\t    gfp_t gfpflags,\n\t\t\t\t    int node, size_t size)\n{\n\tvoid *ret = slab_alloc_node(s, gfpflags, node, _RET_IP_);\n\n\ttrace_kmalloc_node(_RET_IP_, ret,\n\t\t\t   size, s->size, gfpflags, node);\n\n\tkasan_kmalloc(s, ret, size, gfpflags);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline bool pfmemalloc_match(struct page *page, gfp_t gfpflags);\n\nvoid *kmem_cache_alloc_node_trace(struct kmem_cache *s,\n\t\t\t\t    gfp_t gfpflags,\n\t\t\t\t    int node, size_t size)\n{\n\tvoid *ret = slab_alloc_node(s, gfpflags, node, _RET_IP_);\n\n\ttrace_kmalloc_node(_RET_IP_, ret,\n\t\t\t   size, s->size, gfpflags, node);\n\n\tkasan_kmalloc(s, ret, size, gfpflags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_track",
          "args": [
            "s",
            "object",
            "TRACK_ALLOC",
            "addr"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "set_track",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "541-573",
          "snippet": "static void set_track(struct kmem_cache *s, void *object,\n\t\t\tenum track_item alloc, unsigned long addr)\n{\n\tstruct track *p = get_track(s, object, alloc);\n\n\tif (addr) {\n#ifdef CONFIG_STACKTRACE\n\t\tstruct stack_trace trace;\n\t\tint i;\n\n\t\ttrace.nr_entries = 0;\n\t\ttrace.max_entries = TRACK_ADDRS_COUNT;\n\t\ttrace.entries = p->addrs;\n\t\ttrace.skip = 3;\n\t\tmetadata_access_enable();\n\t\tsave_stack_trace(&trace);\n\t\tmetadata_access_disable();\n\n\t\t/* See rant in lockdep.c */\n\t\tif (trace.nr_entries != 0 &&\n\t\t    trace.entries[trace.nr_entries - 1] == ULONG_MAX)\n\t\t\ttrace.nr_entries--;\n\n\t\tfor (i = trace.nr_entries; i < TRACK_ADDRS_COUNT; i++)\n\t\t\tp->addrs[i] = 0;\n#endif\n\t\tp->addr = addr;\n\t\tp->cpu = smp_processor_id();\n\t\tp->pid = current->pid;\n\t\tp->when = jiffies;\n\t} else\n\t\tmemset(p, 0, sizeof(struct track));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define TRACK_ADDRS_COUNT 16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define TRACK_ADDRS_COUNT 16\n\nstatic void set_track(struct kmem_cache *s, void *object,\n\t\t\tenum track_item alloc, unsigned long addr)\n{\n\tstruct track *p = get_track(s, object, alloc);\n\n\tif (addr) {\n#ifdef CONFIG_STACKTRACE\n\t\tstruct stack_trace trace;\n\t\tint i;\n\n\t\ttrace.nr_entries = 0;\n\t\ttrace.max_entries = TRACK_ADDRS_COUNT;\n\t\ttrace.entries = p->addrs;\n\t\ttrace.skip = 3;\n\t\tmetadata_access_enable();\n\t\tsave_stack_trace(&trace);\n\t\tmetadata_access_disable();\n\n\t\t/* See rant in lockdep.c */\n\t\tif (trace.nr_entries != 0 &&\n\t\t    trace.entries[trace.nr_entries - 1] == ULONG_MAX)\n\t\t\ttrace.nr_entries--;\n\n\t\tfor (i = trace.nr_entries; i < TRACK_ADDRS_COUNT; i++)\n\t\t\tp->addrs[i] = 0;\n#endif\n\t\tp->addr = addr;\n\t\tp->cpu = smp_processor_id();\n\t\tp->pid = current->pid;\n\t\tp->when = jiffies;\n\t} else\n\t\tmemset(p, 0, sizeof(struct track));\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_consistency_checks",
          "args": [
            "s",
            "page",
            "object",
            "addr"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_consistency_checks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1078-1094",
          "snippet": "static inline int alloc_consistency_checks(struct kmem_cache *s,\n\t\t\t\t\tstruct page *page,\n\t\t\t\t\tvoid *object, unsigned long addr)\n{\n\tif (!check_slab(s, page))\n\t\treturn 0;\n\n\tif (!check_valid_pointer(s, page, object)) {\n\t\tobject_err(s, page, object, \"Freelist Pointer check fails\");\n\t\treturn 0;\n\t}\n\n\tif (!check_object(s, page, object, SLUB_RED_INACTIVE))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline int alloc_consistency_checks(struct kmem_cache *s,\n\t\t\t\t\tstruct page *page,\n\t\t\t\t\tvoid *object, unsigned long addr)\n{\n\tif (!check_slab(s, page))\n\t\treturn 0;\n\n\tif (!check_valid_pointer(s, page, object)) {\n\t\tobject_err(s, page, object, \"Freelist Pointer check fails\");\n\t\treturn 0;\n\t}\n\n\tif (!check_object(s, page, object, SLUB_RED_INACTIVE))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic noinline int alloc_debug_processing(struct kmem_cache *s,\n\t\t\t\t\tstruct page *page,\n\t\t\t\t\tvoid *object, unsigned long addr)\n{\n\tif (s->flags & SLAB_CONSISTENCY_CHECKS) {\n\t\tif (!alloc_consistency_checks(s, page, object, addr))\n\t\t\tgoto bad;\n\t}\n\n\t/* Success perform special debug activities for allocs */\n\tif (s->flags & SLAB_STORE_USER)\n\t\tset_track(s, object, TRACK_ALLOC, addr);\n\ttrace(s, page, object, 1);\n\tinit_object(s, object, SLUB_RED_ACTIVE);\n\treturn 1;\n\nbad:\n\tif (PageSlab(page)) {\n\t\t/*\n\t\t * If this is a slab page then lets do the best we can\n\t\t * to avoid issues in the future. Marking all objects\n\t\t * as used avoids touching the remaining objects.\n\t\t */\n\t\tslab_fix(s, \"Marking all objects used\");\n\t\tpage->inuse = page->objects;\n\t\tpage->freelist = NULL;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "alloc_consistency_checks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1078-1094",
    "snippet": "static inline int alloc_consistency_checks(struct kmem_cache *s,\n\t\t\t\t\tstruct page *page,\n\t\t\t\t\tvoid *object, unsigned long addr)\n{\n\tif (!check_slab(s, page))\n\t\treturn 0;\n\n\tif (!check_valid_pointer(s, page, object)) {\n\t\tobject_err(s, page, object, \"Freelist Pointer check fails\");\n\t\treturn 0;\n\t}\n\n\tif (!check_object(s, page, object, SLUB_RED_INACTIVE))\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_object",
          "args": [
            "s",
            "page",
            "object",
            "SLUB_RED_INACTIVE"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "check_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1344-1345",
          "snippet": "static inline int check_object(struct kmem_cache *s, struct page *page,\n\t\t\tvoid *object, u8 val) { return 1; }",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline int check_object(struct kmem_cache *s, struct page *page,\n\t\t\tvoid *object, u8 val) { return 1; }"
        }
      },
      {
        "call_info": {
          "callee": "object_err",
          "args": [
            "s",
            "page",
            "object",
            "\"Freelist Pointer check fails\""
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "object_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "690-695",
          "snippet": "void object_err(struct kmem_cache *s, struct page *page,\n\t\t\tu8 *object, char *reason)\n{\n\tslab_bug(s, \"%s\", reason);\n\tprint_trailer(s, page, object);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid object_err(struct kmem_cache *s, struct page *page,\n\t\t\tu8 *object, char *reason)\n{\n\tslab_bug(s, \"%s\", reason);\n\tprint_trailer(s, page, object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_valid_pointer",
          "args": [
            "s",
            "page",
            "object"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "check_valid_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "501-517",
          "snippet": "static inline int check_valid_pointer(struct kmem_cache *s,\n\t\t\t\tstruct page *page, void *object)\n{\n\tvoid *base;\n\n\tif (!object)\n\t\treturn 1;\n\n\tbase = page_address(page);\n\tobject = restore_red_left(s, object);\n\tif (object < base || object >= base + page->objects * s->size ||\n\t\t(object - base) % s->size) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline int check_valid_pointer(struct kmem_cache *s,\n\t\t\t\tstruct page *page, void *object)\n{\n\tvoid *base;\n\n\tif (!object)\n\t\treturn 1;\n\n\tbase = page_address(page);\n\tobject = restore_red_left(s, object);\n\tif (object < base || object >= base + page->objects * s->size ||\n\t\t(object - base) % s->size) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_slab",
          "args": [
            "s",
            "page"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "check_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "911-936",
          "snippet": "static int check_slab(struct kmem_cache *s, struct page *page)\n{\n\tint maxobj;\n\n\tVM_BUG_ON(!irqs_disabled());\n\n\tif (!PageSlab(page)) {\n\t\tslab_err(s, page, \"Not a valid slab page\");\n\t\treturn 0;\n\t}\n\n\tmaxobj = order_objects(compound_order(page), s->size);\n\tif (page->objects > maxobj) {\n\t\tslab_err(s, page, \"objects %u > max %u\",\n\t\t\tpage->objects, maxobj);\n\t\treturn 0;\n\t}\n\tif (page->inuse > page->objects) {\n\t\tslab_err(s, page, \"inuse %u > max %u\",\n\t\t\tpage->inuse, page->objects);\n\t\treturn 0;\n\t}\n\t/* Slab_pad_check fixes things up after itself */\n\tslab_pad_check(s, page);\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic int check_slab(struct kmem_cache *s, struct page *page)\n{\n\tint maxobj;\n\n\tVM_BUG_ON(!irqs_disabled());\n\n\tif (!PageSlab(page)) {\n\t\tslab_err(s, page, \"Not a valid slab page\");\n\t\treturn 0;\n\t}\n\n\tmaxobj = order_objects(compound_order(page), s->size);\n\tif (page->objects > maxobj) {\n\t\tslab_err(s, page, \"objects %u > max %u\",\n\t\t\tpage->objects, maxobj);\n\t\treturn 0;\n\t}\n\tif (page->inuse > page->objects) {\n\t\tslab_err(s, page, \"inuse %u > max %u\",\n\t\t\tpage->inuse, page->objects);\n\t\treturn 0;\n\t}\n\t/* Slab_pad_check fixes things up after itself */\n\tslab_pad_check(s, page);\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline int alloc_consistency_checks(struct kmem_cache *s,\n\t\t\t\t\tstruct page *page,\n\t\t\t\t\tvoid *object, unsigned long addr)\n{\n\tif (!check_slab(s, page))\n\t\treturn 0;\n\n\tif (!check_valid_pointer(s, page, object)) {\n\t\tobject_err(s, page, object, \"Freelist Pointer check fails\");\n\t\treturn 0;\n\t}\n\n\tif (!check_object(s, page, object, SLUB_RED_INACTIVE))\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "setup_object_debug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1068-1076",
    "snippet": "static void setup_object_debug(struct kmem_cache *s, struct page *page,\n\t\t\t\t\t\t\t\tvoid *object)\n{\n\tif (!(s->flags & (SLAB_STORE_USER|SLAB_RED_ZONE|__OBJECT_POISON)))\n\t\treturn;\n\n\tinit_object(s, object, SLUB_RED_INACTIVE);\n\tinit_tracking(s, object);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define __OBJECT_POISON\t\t((slab_flags_t __force)0x80000000U)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_tracking",
          "args": [
            "s",
            "object"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "init_tracking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "575-582",
          "snippet": "static void init_tracking(struct kmem_cache *s, void *object)\n{\n\tif (!(s->flags & SLAB_STORE_USER))\n\t\treturn;\n\n\tset_track(s, object, TRACK_FREE, 0UL);\n\tset_track(s, object, TRACK_ALLOC, 0UL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void init_tracking(struct kmem_cache *s, void *object)\n{\n\tif (!(s->flags & SLAB_STORE_USER))\n\t\treturn;\n\n\tset_track(s, object, TRACK_FREE, 0UL);\n\tset_track(s, object, TRACK_ALLOC, 0UL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_object",
          "args": [
            "s",
            "object",
            "SLUB_RED_INACTIVE"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "init_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "711-725",
          "snippet": "static void init_object(struct kmem_cache *s, void *object, u8 val)\n{\n\tu8 *p = object;\n\n\tif (s->flags & SLAB_RED_ZONE)\n\t\tmemset(p - s->red_left_pad, val, s->red_left_pad);\n\n\tif (s->flags & __OBJECT_POISON) {\n\t\tmemset(p, POISON_FREE, s->object_size - 1);\n\t\tp[s->object_size - 1] = POISON_END;\n\t}\n\n\tif (s->flags & SLAB_RED_ZONE)\n\t\tmemset(p + s->object_size, val, s->inuse - s->object_size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define __OBJECT_POISON\t\t((slab_flags_t __force)0x80000000U)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define __OBJECT_POISON\t\t((slab_flags_t __force)0x80000000U)\n\nstatic void init_object(struct kmem_cache *s, void *object, u8 val)\n{\n\tu8 *p = object;\n\n\tif (s->flags & SLAB_RED_ZONE)\n\t\tmemset(p - s->red_left_pad, val, s->red_left_pad);\n\n\tif (s->flags & __OBJECT_POISON) {\n\t\tmemset(p, POISON_FREE, s->object_size - 1);\n\t\tp[s->object_size - 1] = POISON_END;\n\t}\n\n\tif (s->flags & SLAB_RED_ZONE)\n\t\tmemset(p + s->object_size, val, s->inuse - s->object_size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define __OBJECT_POISON\t\t((slab_flags_t __force)0x80000000U)\n\nstatic void setup_object_debug(struct kmem_cache *s, struct page *page,\n\t\t\t\t\t\t\t\tvoid *object)\n{\n\tif (!(s->flags & (SLAB_STORE_USER|SLAB_RED_ZONE|__OBJECT_POISON)))\n\t\treturn;\n\n\tinit_object(s, object, SLUB_RED_INACTIVE);\n\tinit_tracking(s, object);\n}"
  },
  {
    "function_name": "dec_slabs_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1059-1065",
    "snippet": "static inline void dec_slabs_node(struct kmem_cache *s, int node, int objects)\n{\n\tstruct kmem_cache_node *n = get_node(s, node);\n\n\tatomic_long_dec(&n->nr_slabs);\n\tatomic_long_sub(objects, &n->total_objects);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *kmem_cache_node;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_sub",
          "args": [
            "objects",
            "&n->total_objects"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_dec",
          "args": [
            "&n->nr_slabs"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node",
          "args": [
            "s",
            "node"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "get_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "485-488",
          "snippet": "static inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic inline void dec_slabs_node(struct kmem_cache *s, int node, int objects)\n{\n\tstruct kmem_cache_node *n = get_node(s, node);\n\n\tatomic_long_dec(&n->nr_slabs);\n\tatomic_long_sub(objects, &n->total_objects);\n}"
  },
  {
    "function_name": "inc_slabs_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1044-1058",
    "snippet": "static inline void inc_slabs_node(struct kmem_cache *s, int node, int objects)\n{\n\tstruct kmem_cache_node *n = get_node(s, node);\n\n\t/*\n\t * May be called early in order to allocate a slab for the\n\t * kmem_cache_node structure. Solve the chicken-egg\n\t * dilemma by deferring the increment of the count during\n\t * bootstrap (see early_kmem_cache_node_alloc).\n\t */\n\tif (likely(n)) {\n\t\tatomic_long_inc(&n->nr_slabs);\n\t\tatomic_long_add(objects, &n->total_objects);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *kmem_cache_node;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_add",
          "args": [
            "objects",
            "&n->total_objects"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_inc",
          "args": [
            "&n->nr_slabs"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "n"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node",
          "args": [
            "s",
            "node"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "get_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "485-488",
          "snippet": "static inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic inline void inc_slabs_node(struct kmem_cache *s, int node, int objects)\n{\n\tstruct kmem_cache_node *n = get_node(s, node);\n\n\t/*\n\t * May be called early in order to allocate a slab for the\n\t * kmem_cache_node structure. Solve the chicken-egg\n\t * dilemma by deferring the increment of the count during\n\t * bootstrap (see early_kmem_cache_node_alloc).\n\t */\n\tif (likely(n)) {\n\t\tatomic_long_inc(&n->nr_slabs);\n\t\tatomic_long_add(objects, &n->total_objects);\n\t}\n}"
  },
  {
    "function_name": "node_nr_slabs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1039-1042",
    "snippet": "static inline unsigned long node_nr_slabs(struct kmem_cache_node *n)\n{\n\treturn atomic_long_read(&n->nr_slabs);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *kmem_cache_node;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&n->nr_slabs"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic inline unsigned long node_nr_slabs(struct kmem_cache_node *n)\n{\n\treturn atomic_long_read(&n->nr_slabs);\n}"
  },
  {
    "function_name": "slabs_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1032-1037",
    "snippet": "static inline unsigned long slabs_node(struct kmem_cache *s, int node)\n{\n\tstruct kmem_cache_node *n = get_node(s, node);\n\n\treturn atomic_long_read(&n->nr_slabs);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *kmem_cache_node;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&n->nr_slabs"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node",
          "args": [
            "s",
            "node"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "get_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "485-488",
          "snippet": "static inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n\treturn s->node[node];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic inline unsigned long slabs_node(struct kmem_cache *s, int node)\n{\n\tstruct kmem_cache_node *n = get_node(s, node);\n\n\treturn atomic_long_read(&n->nr_slabs);\n}"
  },
  {
    "function_name": "remove_full",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1022-1029",
    "snippet": "static void remove_full(struct kmem_cache *s, struct kmem_cache_node *n, struct page *page)\n{\n\tif (!(s->flags & SLAB_STORE_USER))\n\t\treturn;\n\n\tlockdep_assert_held(&n->list_lock);\n\tlist_del(&page->lru);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *kmem_cache_node;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&n->list_lock"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic void remove_full(struct kmem_cache *s, struct kmem_cache_node *n, struct page *page)\n{\n\tif (!(s->flags & SLAB_STORE_USER))\n\t\treturn;\n\n\tlockdep_assert_held(&n->list_lock);\n\tlist_del(&page->lru);\n}"
  },
  {
    "function_name": "add_full",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "1012-1020",
    "snippet": "static void add_full(struct kmem_cache *s,\n\tstruct kmem_cache_node *n, struct page *page)\n{\n\tif (!(s->flags & SLAB_STORE_USER))\n\t\treturn;\n\n\tlockdep_assert_held(&n->list_lock);\n\tlist_add(&page->lru, &n->full);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *kmem_cache_node;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&page->lru",
            "&n->full"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&n->list_lock"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct kmem_cache *kmem_cache_node;\n\nstatic void add_full(struct kmem_cache *s,\n\tstruct kmem_cache_node *n, struct page *page)\n{\n\tif (!(s->flags & SLAB_STORE_USER))\n\t\treturn;\n\n\tlockdep_assert_held(&n->list_lock);\n\tlist_add(&page->lru, &n->full);\n}"
  },
  {
    "function_name": "trace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "991-1007",
    "snippet": "static void trace(struct kmem_cache *s, struct page *page, void *object,\n\t\t\t\t\t\t\t\tint alloc)\n{\n\tif (s->flags & SLAB_TRACE) {\n\t\tpr_info(\"TRACE %s %s 0x%p inuse=%d fp=0x%p\\n\",\n\t\t\ts->name,\n\t\t\talloc ? \"alloc\" : \"free\",\n\t\t\tobject, page->inuse,\n\t\t\tpage->freelist);\n\n\t\tif (!alloc)\n\t\t\tprint_section(KERN_INFO, \"Object \", (void *)object,\n\t\t\t\t\ts->object_size);\n\n\t\tdump_stack();\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_section",
          "args": [
            "KERN_INFO",
            "\"Object \"",
            "(void *)object",
            "s->object_size"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "print_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "519-526",
          "snippet": "static void print_section(char *level, char *text, u8 *addr,\n\t\t\t  unsigned int length)\n{\n\tmetadata_access_enable();\n\tprint_hex_dump(level, text, DUMP_PREFIX_ADDRESS, 16, 1, addr,\n\t\t\tlength, 1);\n\tmetadata_access_disable();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void print_section(char *level, char *text, u8 *addr,\n\t\t\t  unsigned int length)\n{\n\tmetadata_access_enable();\n\tprint_hex_dump(level, text, DUMP_PREFIX_ADDRESS, 16, 1, addr,\n\t\t\tlength, 1);\n\tmetadata_access_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"TRACE %s %s 0x%p inuse=%d fp=0x%p\\n\"",
            "s->name",
            "alloc ? \"alloc\" : \"free\"",
            "object",
            "page->inuse",
            "page->freelist"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void trace(struct kmem_cache *s, struct page *page, void *object,\n\t\t\t\t\t\t\t\tint alloc)\n{\n\tif (s->flags & SLAB_TRACE) {\n\t\tpr_info(\"TRACE %s %s 0x%p inuse=%d fp=0x%p\\n\",\n\t\t\ts->name,\n\t\t\talloc ? \"alloc\" : \"free\",\n\t\t\tobject, page->inuse,\n\t\t\tpage->freelist);\n\n\t\tif (!alloc)\n\t\t\tprint_section(KERN_INFO, \"Object \", (void *)object,\n\t\t\t\t\ts->object_size);\n\n\t\tdump_stack();\n\t}\n}"
  },
  {
    "function_name": "on_freelist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "942-989",
    "snippet": "static int on_freelist(struct kmem_cache *s, struct page *page, void *search)\n{\n\tint nr = 0;\n\tvoid *fp;\n\tvoid *object = NULL;\n\tint max_objects;\n\n\tfp = page->freelist;\n\twhile (fp && nr <= page->objects) {\n\t\tif (fp == search)\n\t\t\treturn 1;\n\t\tif (!check_valid_pointer(s, page, fp)) {\n\t\t\tif (object) {\n\t\t\t\tobject_err(s, page, object,\n\t\t\t\t\t\"Freechain corrupt\");\n\t\t\t\tset_freepointer(s, object, NULL);\n\t\t\t} else {\n\t\t\t\tslab_err(s, page, \"Freepointer corrupt\");\n\t\t\t\tpage->freelist = NULL;\n\t\t\t\tpage->inuse = page->objects;\n\t\t\t\tslab_fix(s, \"Freelist cleared\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tobject = fp;\n\t\tfp = get_freepointer(s, object);\n\t\tnr++;\n\t}\n\n\tmax_objects = order_objects(compound_order(page), s->size);\n\tif (max_objects > MAX_OBJS_PER_PAGE)\n\t\tmax_objects = MAX_OBJS_PER_PAGE;\n\n\tif (page->objects != max_objects) {\n\t\tslab_err(s, page, \"Wrong number of objects. Found %d but should be %d\",\n\t\t\t page->objects, max_objects);\n\t\tpage->objects = max_objects;\n\t\tslab_fix(s, \"Number of objects adjusted.\");\n\t}\n\tif (page->inuse != page->objects - nr) {\n\t\tslab_err(s, page, \"Wrong object count. Counter is %d but counted were %d\",\n\t\t\t page->inuse, page->objects - nr);\n\t\tpage->inuse = page->objects - nr;\n\t\tslab_fix(s, \"Object count adjusted.\");\n\t}\n\treturn search == NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define MAX_OBJS_PER_PAGE\t32767 /* since page.objects is u15 */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "slab_fix",
          "args": [
            "s",
            "\"Object count adjusted.\""
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "slab_fix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "636-646",
          "snippet": "static void slab_fix(struct kmem_cache *s, char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_err(\"FIX %s: %pV\\n\", s->name, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void slab_fix(struct kmem_cache *s, char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_err(\"FIX %s: %pV\\n\", s->name, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "slab_err",
          "args": [
            "s",
            "page",
            "\"Wrong object count. Counter is %d but counted were %d\"",
            "page->inuse",
            "page->objects - nr"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_err",
          "args": [
            "s",
            "page",
            "\"Wrong number of objects. Found %d but should be %d\"",
            "page->objects",
            "max_objects"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "order_objects",
          "args": [
            "compound_order(page)",
            "s->size"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "order_objects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "317-320",
          "snippet": "static inline unsigned int order_objects(unsigned int order, unsigned int size)\n{\n\treturn ((unsigned int)PAGE_SIZE << order) / size;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline unsigned int order_objects(unsigned int order, unsigned int size)\n{\n\treturn ((unsigned int)PAGE_SIZE << order) / size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "page"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_freepointer",
          "args": [
            "s",
            "object"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "get_freepointer_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "276-287",
          "snippet": "static inline void *get_freepointer_safe(struct kmem_cache *s, void *object)\n{\n\tunsigned long freepointer_addr;\n\tvoid *p;\n\n\tif (!debug_pagealloc_enabled())\n\t\treturn get_freepointer(s, object);\n\n\tfreepointer_addr = (unsigned long)object + s->offset;\n\tprobe_kernel_read(&p, (void **)freepointer_addr, sizeof(p));\n\treturn freelist_ptr(s, p, freepointer_addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void *get_freepointer_safe(struct kmem_cache *s, void *object)\n{\n\tunsigned long freepointer_addr;\n\tvoid *p;\n\n\tif (!debug_pagealloc_enabled())\n\t\treturn get_freepointer(s, object);\n\n\tfreepointer_addr = (unsigned long)object + s->offset;\n\tprobe_kernel_read(&p, (void **)freepointer_addr, sizeof(p));\n\treturn freelist_ptr(s, p, freepointer_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "slab_err",
          "args": [
            "s",
            "page",
            "\"Freepointer corrupt\""
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "__slab_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "480-487",
          "snippet": "static void __slab_error(const char *function, struct kmem_cache *cachep,\n\t\t\tchar *msg)\n{\n\tpr_err(\"slab error in %s(): cache `%s': %s\\n\",\n\t       function, cachep->name, msg);\n\tdump_stack();\n\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void __slab_error(const char *function, struct kmem_cache *cachep,\n\t\t\tchar *msg)\n{\n\tpr_err(\"slab error in %s(): cache `%s': %s\\n\",\n\t       function, cachep->name, msg);\n\tdump_stack();\n\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_freepointer",
          "args": [
            "s",
            "object",
            "NULL"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "set_freepointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "289-298",
          "snippet": "static inline void set_freepointer(struct kmem_cache *s, void *object, void *fp)\n{\n\tunsigned long freeptr_addr = (unsigned long)object + s->offset;\n\n#ifdef CONFIG_SLAB_FREELIST_HARDENED\n\tBUG_ON(object == fp); /* naive detection of double free or corruption */\n#endif\n\n\t*(void **)freeptr_addr = freelist_ptr(s, fp, freeptr_addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void set_freepointer(struct kmem_cache *s, void *object, void *fp)\n{\n\tunsigned long freeptr_addr = (unsigned long)object + s->offset;\n\n#ifdef CONFIG_SLAB_FREELIST_HARDENED\n\tBUG_ON(object == fp); /* naive detection of double free or corruption */\n#endif\n\n\t*(void **)freeptr_addr = freelist_ptr(s, fp, freeptr_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "object_err",
          "args": [
            "s",
            "page",
            "object",
            "\"Freechain corrupt\""
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "object_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "690-695",
          "snippet": "void object_err(struct kmem_cache *s, struct page *page,\n\t\t\tu8 *object, char *reason)\n{\n\tslab_bug(s, \"%s\", reason);\n\tprint_trailer(s, page, object);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid object_err(struct kmem_cache *s, struct page *page,\n\t\t\tu8 *object, char *reason)\n{\n\tslab_bug(s, \"%s\", reason);\n\tprint_trailer(s, page, object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_valid_pointer",
          "args": [
            "s",
            "page",
            "fp"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "check_valid_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "501-517",
          "snippet": "static inline int check_valid_pointer(struct kmem_cache *s,\n\t\t\t\tstruct page *page, void *object)\n{\n\tvoid *base;\n\n\tif (!object)\n\t\treturn 1;\n\n\tbase = page_address(page);\n\tobject = restore_red_left(s, object);\n\tif (object < base || object >= base + page->objects * s->size ||\n\t\t(object - base) % s->size) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline int check_valid_pointer(struct kmem_cache *s,\n\t\t\t\tstruct page *page, void *object)\n{\n\tvoid *base;\n\n\tif (!object)\n\t\treturn 1;\n\n\tbase = page_address(page);\n\tobject = restore_red_left(s, object);\n\tif (object < base || object >= base + page->objects * s->size ||\n\t\t(object - base) % s->size) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define MAX_OBJS_PER_PAGE\t32767 /* since page.objects is u15 */\n\nstatic int on_freelist(struct kmem_cache *s, struct page *page, void *search)\n{\n\tint nr = 0;\n\tvoid *fp;\n\tvoid *object = NULL;\n\tint max_objects;\n\n\tfp = page->freelist;\n\twhile (fp && nr <= page->objects) {\n\t\tif (fp == search)\n\t\t\treturn 1;\n\t\tif (!check_valid_pointer(s, page, fp)) {\n\t\t\tif (object) {\n\t\t\t\tobject_err(s, page, object,\n\t\t\t\t\t\"Freechain corrupt\");\n\t\t\t\tset_freepointer(s, object, NULL);\n\t\t\t} else {\n\t\t\t\tslab_err(s, page, \"Freepointer corrupt\");\n\t\t\t\tpage->freelist = NULL;\n\t\t\t\tpage->inuse = page->objects;\n\t\t\t\tslab_fix(s, \"Freelist cleared\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tobject = fp;\n\t\tfp = get_freepointer(s, object);\n\t\tnr++;\n\t}\n\n\tmax_objects = order_objects(compound_order(page), s->size);\n\tif (max_objects > MAX_OBJS_PER_PAGE)\n\t\tmax_objects = MAX_OBJS_PER_PAGE;\n\n\tif (page->objects != max_objects) {\n\t\tslab_err(s, page, \"Wrong number of objects. Found %d but should be %d\",\n\t\t\t page->objects, max_objects);\n\t\tpage->objects = max_objects;\n\t\tslab_fix(s, \"Number of objects adjusted.\");\n\t}\n\tif (page->inuse != page->objects - nr) {\n\t\tslab_err(s, page, \"Wrong object count. Counter is %d but counted were %d\",\n\t\t\t page->inuse, page->objects - nr);\n\t\tpage->inuse = page->objects - nr;\n\t\tslab_fix(s, \"Object count adjusted.\");\n\t}\n\treturn search == NULL;\n}"
  },
  {
    "function_name": "check_slab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "911-936",
    "snippet": "static int check_slab(struct kmem_cache *s, struct page *page)\n{\n\tint maxobj;\n\n\tVM_BUG_ON(!irqs_disabled());\n\n\tif (!PageSlab(page)) {\n\t\tslab_err(s, page, \"Not a valid slab page\");\n\t\treturn 0;\n\t}\n\n\tmaxobj = order_objects(compound_order(page), s->size);\n\tif (page->objects > maxobj) {\n\t\tslab_err(s, page, \"objects %u > max %u\",\n\t\t\tpage->objects, maxobj);\n\t\treturn 0;\n\t}\n\tif (page->inuse > page->objects) {\n\t\tslab_err(s, page, \"inuse %u > max %u\",\n\t\t\tpage->inuse, page->objects);\n\t\treturn 0;\n\t}\n\t/* Slab_pad_check fixes things up after itself */\n\tslab_pad_check(s, page);\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "slab_pad_check",
          "args": [
            "s",
            "page"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "slab_pad_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1342-1343",
          "snippet": "static inline int slab_pad_check(struct kmem_cache *s, struct page *page)\n\t\t\t{ return 1; }",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline int slab_pad_check(struct kmem_cache *s, struct page *page)\n\t\t\t{ return 1; }"
        }
      },
      {
        "call_info": {
          "callee": "slab_err",
          "args": [
            "s",
            "page",
            "\"inuse %u > max %u\"",
            "page->inuse",
            "page->objects"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_err",
          "args": [
            "s",
            "page",
            "\"objects %u > max %u\"",
            "page->objects",
            "maxobj"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "order_objects",
          "args": [
            "compound_order(page)",
            "s->size"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "order_objects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "317-320",
          "snippet": "static inline unsigned int order_objects(unsigned int order, unsigned int size)\n{\n\treturn ((unsigned int)PAGE_SIZE << order) / size;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline unsigned int order_objects(unsigned int order, unsigned int size)\n{\n\treturn ((unsigned int)PAGE_SIZE << order) / size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "page"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_err",
          "args": [
            "s",
            "page",
            "\"Not a valid slab page\""
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "__slab_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "480-487",
          "snippet": "static void __slab_error(const char *function, struct kmem_cache *cachep,\n\t\t\tchar *msg)\n{\n\tpr_err(\"slab error in %s(): cache `%s': %s\\n\",\n\t       function, cachep->name, msg);\n\tdump_stack();\n\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstatic void __slab_error(const char *function, struct kmem_cache *cachep,\n\t\t\tchar *msg)\n{\n\tpr_err(\"slab error in %s(): cache `%s': %s\\n\",\n\t       function, cachep->name, msg);\n\tdump_stack();\n\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageSlab",
          "args": [
            "page"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!irqs_disabled()"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic int check_slab(struct kmem_cache *s, struct page *page)\n{\n\tint maxobj;\n\n\tVM_BUG_ON(!irqs_disabled());\n\n\tif (!PageSlab(page)) {\n\t\tslab_err(s, page, \"Not a valid slab page\");\n\t\treturn 0;\n\t}\n\n\tmaxobj = order_objects(compound_order(page), s->size);\n\tif (page->objects > maxobj) {\n\t\tslab_err(s, page, \"objects %u > max %u\",\n\t\t\tpage->objects, maxobj);\n\t\treturn 0;\n\t}\n\tif (page->inuse > page->objects) {\n\t\tslab_err(s, page, \"inuse %u > max %u\",\n\t\t\tpage->inuse, page->objects);\n\t\treturn 0;\n\t}\n\t/* Slab_pad_check fixes things up after itself */\n\tslab_pad_check(s, page);\n\treturn 1;\n}"
  },
  {
    "function_name": "check_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "855-909",
    "snippet": "static int check_object(struct kmem_cache *s, struct page *page,\n\t\t\t\t\tvoid *object, u8 val)\n{\n\tu8 *p = object;\n\tu8 *endobject = object + s->object_size;\n\n\tif (s->flags & SLAB_RED_ZONE) {\n\t\tif (!check_bytes_and_report(s, page, object, \"Redzone\",\n\t\t\tobject - s->red_left_pad, val, s->red_left_pad))\n\t\t\treturn 0;\n\n\t\tif (!check_bytes_and_report(s, page, object, \"Redzone\",\n\t\t\tendobject, val, s->inuse - s->object_size))\n\t\t\treturn 0;\n\t} else {\n\t\tif ((s->flags & SLAB_POISON) && s->object_size < s->inuse) {\n\t\t\tcheck_bytes_and_report(s, page, p, \"Alignment padding\",\n\t\t\t\tendobject, POISON_INUSE,\n\t\t\t\ts->inuse - s->object_size);\n\t\t}\n\t}\n\n\tif (s->flags & SLAB_POISON) {\n\t\tif (val != SLUB_RED_ACTIVE && (s->flags & __OBJECT_POISON) &&\n\t\t\t(!check_bytes_and_report(s, page, p, \"Poison\", p,\n\t\t\t\t\tPOISON_FREE, s->object_size - 1) ||\n\t\t\t !check_bytes_and_report(s, page, p, \"Poison\",\n\t\t\t\tp + s->object_size - 1, POISON_END, 1)))\n\t\t\treturn 0;\n\t\t/*\n\t\t * check_pad_bytes cleans up on its own.\n\t\t */\n\t\tcheck_pad_bytes(s, page, p);\n\t}\n\n\tif (!s->offset && val == SLUB_RED_ACTIVE)\n\t\t/*\n\t\t * Object and freepointer overlap. Cannot check\n\t\t * freepointer while object is allocated.\n\t\t */\n\t\treturn 1;\n\n\t/* Check free pointer validity */\n\tif (!check_valid_pointer(s, page, get_freepointer(s, p))) {\n\t\tobject_err(s, page, p, \"Freepointer corrupt\");\n\t\t/*\n\t\t * No choice but to zap it and thus lose the remainder\n\t\t * of the free objects in this slab. May cause\n\t\t * another error because the object count is now wrong.\n\t\t */\n\t\tset_freepointer(s, p, NULL);\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define __OBJECT_POISON\t\t((slab_flags_t __force)0x80000000U)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_freepointer",
          "args": [
            "s",
            "p",
            "NULL"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "set_freepointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "289-298",
          "snippet": "static inline void set_freepointer(struct kmem_cache *s, void *object, void *fp)\n{\n\tunsigned long freeptr_addr = (unsigned long)object + s->offset;\n\n#ifdef CONFIG_SLAB_FREELIST_HARDENED\n\tBUG_ON(object == fp); /* naive detection of double free or corruption */\n#endif\n\n\t*(void **)freeptr_addr = freelist_ptr(s, fp, freeptr_addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void set_freepointer(struct kmem_cache *s, void *object, void *fp)\n{\n\tunsigned long freeptr_addr = (unsigned long)object + s->offset;\n\n#ifdef CONFIG_SLAB_FREELIST_HARDENED\n\tBUG_ON(object == fp); /* naive detection of double free or corruption */\n#endif\n\n\t*(void **)freeptr_addr = freelist_ptr(s, fp, freeptr_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "object_err",
          "args": [
            "s",
            "page",
            "p",
            "\"Freepointer corrupt\""
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "object_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "690-695",
          "snippet": "void object_err(struct kmem_cache *s, struct page *page,\n\t\t\tu8 *object, char *reason)\n{\n\tslab_bug(s, \"%s\", reason);\n\tprint_trailer(s, page, object);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid object_err(struct kmem_cache *s, struct page *page,\n\t\t\tu8 *object, char *reason)\n{\n\tslab_bug(s, \"%s\", reason);\n\tprint_trailer(s, page, object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_valid_pointer",
          "args": [
            "s",
            "page",
            "get_freepointer(s, p)"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "check_valid_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "501-517",
          "snippet": "static inline int check_valid_pointer(struct kmem_cache *s,\n\t\t\t\tstruct page *page, void *object)\n{\n\tvoid *base;\n\n\tif (!object)\n\t\treturn 1;\n\n\tbase = page_address(page);\n\tobject = restore_red_left(s, object);\n\tif (object < base || object >= base + page->objects * s->size ||\n\t\t(object - base) % s->size) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline int check_valid_pointer(struct kmem_cache *s,\n\t\t\t\tstruct page *page, void *object)\n{\n\tvoid *base;\n\n\tif (!object)\n\t\treturn 1;\n\n\tbase = page_address(page);\n\tobject = restore_red_left(s, object);\n\tif (object < base || object >= base + page->objects * s->size ||\n\t\t(object - base) % s->size) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_freepointer",
          "args": [
            "s",
            "p"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "get_freepointer_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "276-287",
          "snippet": "static inline void *get_freepointer_safe(struct kmem_cache *s, void *object)\n{\n\tunsigned long freepointer_addr;\n\tvoid *p;\n\n\tif (!debug_pagealloc_enabled())\n\t\treturn get_freepointer(s, object);\n\n\tfreepointer_addr = (unsigned long)object + s->offset;\n\tprobe_kernel_read(&p, (void **)freepointer_addr, sizeof(p));\n\treturn freelist_ptr(s, p, freepointer_addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void *get_freepointer_safe(struct kmem_cache *s, void *object)\n{\n\tunsigned long freepointer_addr;\n\tvoid *p;\n\n\tif (!debug_pagealloc_enabled())\n\t\treturn get_freepointer(s, object);\n\n\tfreepointer_addr = (unsigned long)object + s->offset;\n\tprobe_kernel_read(&p, (void **)freepointer_addr, sizeof(p));\n\treturn freelist_ptr(s, p, freepointer_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_pad_bytes",
          "args": [
            "s",
            "page",
            "p"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "check_pad_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "798-817",
          "snippet": "static int check_pad_bytes(struct kmem_cache *s, struct page *page, u8 *p)\n{\n\tunsigned long off = s->inuse;\t/* The end of info */\n\n\tif (s->offset)\n\t\t/* Freepointer is placed after the object. */\n\t\toff += sizeof(void *);\n\n\tif (s->flags & SLAB_STORE_USER)\n\t\t/* We also have user information there */\n\t\toff += 2 * sizeof(struct track);\n\n\toff += kasan_metadata_size(s);\n\n\tif (size_from_object(s) == off)\n\t\treturn 1;\n\n\treturn check_bytes_and_report(s, page, p, \"Object padding\",\n\t\t\tp + off, POISON_INUSE, size_from_object(s) - off);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic int check_pad_bytes(struct kmem_cache *s, struct page *page, u8 *p)\n{\n\tunsigned long off = s->inuse;\t/* The end of info */\n\n\tif (s->offset)\n\t\t/* Freepointer is placed after the object. */\n\t\toff += sizeof(void *);\n\n\tif (s->flags & SLAB_STORE_USER)\n\t\t/* We also have user information there */\n\t\toff += 2 * sizeof(struct track);\n\n\toff += kasan_metadata_size(s);\n\n\tif (size_from_object(s) == off)\n\t\treturn 1;\n\n\treturn check_bytes_and_report(s, page, p, \"Object padding\",\n\t\t\tp + off, POISON_INUSE, size_from_object(s) - off);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_bytes_and_report",
          "args": [
            "s",
            "page",
            "p",
            "\"Poison\"",
            "p + s->object_size - 1",
            "POISON_END",
            "1"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "check_bytes_and_report",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "734-758",
          "snippet": "static int check_bytes_and_report(struct kmem_cache *s, struct page *page,\n\t\t\tu8 *object, char *what,\n\t\t\tu8 *start, unsigned int value, unsigned int bytes)\n{\n\tu8 *fault;\n\tu8 *end;\n\n\tmetadata_access_enable();\n\tfault = memchr_inv(start, value, bytes);\n\tmetadata_access_disable();\n\tif (!fault)\n\t\treturn 1;\n\n\tend = start + bytes;\n\twhile (end > fault && end[-1] == value)\n\t\tend--;\n\n\tslab_bug(s, \"%s overwritten\", what);\n\tpr_err(\"INFO: 0x%p-0x%p. First byte 0x%x instead of 0x%x\\n\",\n\t\t\t\t\tfault, end - 1, fault[0], value);\n\tprint_trailer(s, page, object);\n\n\trestore_bytes(s, what, value, fault, end);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic int check_bytes_and_report(struct kmem_cache *s, struct page *page,\n\t\t\tu8 *object, char *what,\n\t\t\tu8 *start, unsigned int value, unsigned int bytes)\n{\n\tu8 *fault;\n\tu8 *end;\n\n\tmetadata_access_enable();\n\tfault = memchr_inv(start, value, bytes);\n\tmetadata_access_disable();\n\tif (!fault)\n\t\treturn 1;\n\n\tend = start + bytes;\n\twhile (end > fault && end[-1] == value)\n\t\tend--;\n\n\tslab_bug(s, \"%s overwritten\", what);\n\tpr_err(\"INFO: 0x%p-0x%p. First byte 0x%x instead of 0x%x\\n\",\n\t\t\t\t\tfault, end - 1, fault[0], value);\n\tprint_trailer(s, page, object);\n\n\trestore_bytes(s, what, value, fault, end);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define __OBJECT_POISON\t\t((slab_flags_t __force)0x80000000U)\n\nstatic int check_object(struct kmem_cache *s, struct page *page,\n\t\t\t\t\tvoid *object, u8 val)\n{\n\tu8 *p = object;\n\tu8 *endobject = object + s->object_size;\n\n\tif (s->flags & SLAB_RED_ZONE) {\n\t\tif (!check_bytes_and_report(s, page, object, \"Redzone\",\n\t\t\tobject - s->red_left_pad, val, s->red_left_pad))\n\t\t\treturn 0;\n\n\t\tif (!check_bytes_and_report(s, page, object, \"Redzone\",\n\t\t\tendobject, val, s->inuse - s->object_size))\n\t\t\treturn 0;\n\t} else {\n\t\tif ((s->flags & SLAB_POISON) && s->object_size < s->inuse) {\n\t\t\tcheck_bytes_and_report(s, page, p, \"Alignment padding\",\n\t\t\t\tendobject, POISON_INUSE,\n\t\t\t\ts->inuse - s->object_size);\n\t\t}\n\t}\n\n\tif (s->flags & SLAB_POISON) {\n\t\tif (val != SLUB_RED_ACTIVE && (s->flags & __OBJECT_POISON) &&\n\t\t\t(!check_bytes_and_report(s, page, p, \"Poison\", p,\n\t\t\t\t\tPOISON_FREE, s->object_size - 1) ||\n\t\t\t !check_bytes_and_report(s, page, p, \"Poison\",\n\t\t\t\tp + s->object_size - 1, POISON_END, 1)))\n\t\t\treturn 0;\n\t\t/*\n\t\t * check_pad_bytes cleans up on its own.\n\t\t */\n\t\tcheck_pad_bytes(s, page, p);\n\t}\n\n\tif (!s->offset && val == SLUB_RED_ACTIVE)\n\t\t/*\n\t\t * Object and freepointer overlap. Cannot check\n\t\t * freepointer while object is allocated.\n\t\t */\n\t\treturn 1;\n\n\t/* Check free pointer validity */\n\tif (!check_valid_pointer(s, page, get_freepointer(s, p))) {\n\t\tobject_err(s, page, p, \"Freepointer corrupt\");\n\t\t/*\n\t\t * No choice but to zap it and thus lose the remainder\n\t\t * of the free objects in this slab. May cause\n\t\t * another error because the object count is now wrong.\n\t\t */\n\t\tset_freepointer(s, p, NULL);\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "slab_pad_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "820-853",
    "snippet": "static int slab_pad_check(struct kmem_cache *s, struct page *page)\n{\n\tu8 *start;\n\tu8 *fault;\n\tu8 *end;\n\tu8 *pad;\n\tint length;\n\tint remainder;\n\n\tif (!(s->flags & SLAB_POISON))\n\t\treturn 1;\n\n\tstart = page_address(page);\n\tlength = PAGE_SIZE << compound_order(page);\n\tend = start + length;\n\tremainder = length % s->size;\n\tif (!remainder)\n\t\treturn 1;\n\n\tpad = end - remainder;\n\tmetadata_access_enable();\n\tfault = memchr_inv(pad, POISON_INUSE, remainder);\n\tmetadata_access_disable();\n\tif (!fault)\n\t\treturn 1;\n\twhile (end > fault && end[-1] == POISON_INUSE)\n\t\tend--;\n\n\tslab_err(s, page, \"Padding overwritten. 0x%p-0x%p\", fault, end - 1);\n\tprint_section(KERN_ERR, \"Padding \", pad, remainder);\n\n\trestore_bytes(s, \"slab padding\", POISON_INUSE, fault, end);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "restore_bytes",
          "args": [
            "s",
            "\"slab padding\"",
            "POISON_INUSE",
            "fault",
            "end"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "restore_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "727-732",
          "snippet": "static void restore_bytes(struct kmem_cache *s, char *message, u8 data,\n\t\t\t\t\t\tvoid *from, void *to)\n{\n\tslab_fix(s, \"Restoring 0x%p-0x%p=0x%x\\n\", from, to - 1, data);\n\tmemset(from, data, to - from);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void restore_bytes(struct kmem_cache *s, char *message, u8 data,\n\t\t\t\t\t\tvoid *from, void *to)\n{\n\tslab_fix(s, \"Restoring 0x%p-0x%p=0x%x\\n\", from, to - 1, data);\n\tmemset(from, data, to - from);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_section",
          "args": [
            "KERN_ERR",
            "\"Padding \"",
            "pad",
            "remainder"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "print_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "519-526",
          "snippet": "static void print_section(char *level, char *text, u8 *addr,\n\t\t\t  unsigned int length)\n{\n\tmetadata_access_enable();\n\tprint_hex_dump(level, text, DUMP_PREFIX_ADDRESS, 16, 1, addr,\n\t\t\tlength, 1);\n\tmetadata_access_disable();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void print_section(char *level, char *text, u8 *addr,\n\t\t\t  unsigned int length)\n{\n\tmetadata_access_enable();\n\tprint_hex_dump(level, text, DUMP_PREFIX_ADDRESS, 16, 1, addr,\n\t\t\tlength, 1);\n\tmetadata_access_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "slab_err",
          "args": [
            "s",
            "page",
            "\"Padding overwritten. 0x%p-0x%p\"",
            "fault",
            "end - 1"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_access_disable",
          "args": [],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "metadata_access_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "491-494",
          "snippet": "static inline void metadata_access_disable(void)\n{\n\tkasan_enable_current();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void metadata_access_disable(void)\n{\n\tkasan_enable_current();\n}"
        }
      },
      {
        "call_info": {
          "callee": "memchr_inv",
          "args": [
            "pad",
            "POISON_INUSE",
            "remainder"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_access_enable",
          "args": [],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "metadata_access_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "486-489",
          "snippet": "static inline void metadata_access_enable(void)\n{\n\tkasan_disable_current();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void metadata_access_enable(void)\n{\n\tkasan_disable_current();\n}"
        }
      },
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "page"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "page_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "409-434",
          "snippet": "void *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic int slab_pad_check(struct kmem_cache *s, struct page *page)\n{\n\tu8 *start;\n\tu8 *fault;\n\tu8 *end;\n\tu8 *pad;\n\tint length;\n\tint remainder;\n\n\tif (!(s->flags & SLAB_POISON))\n\t\treturn 1;\n\n\tstart = page_address(page);\n\tlength = PAGE_SIZE << compound_order(page);\n\tend = start + length;\n\tremainder = length % s->size;\n\tif (!remainder)\n\t\treturn 1;\n\n\tpad = end - remainder;\n\tmetadata_access_enable();\n\tfault = memchr_inv(pad, POISON_INUSE, remainder);\n\tmetadata_access_disable();\n\tif (!fault)\n\t\treturn 1;\n\twhile (end > fault && end[-1] == POISON_INUSE)\n\t\tend--;\n\n\tslab_err(s, page, \"Padding overwritten. 0x%p-0x%p\", fault, end - 1);\n\tprint_section(KERN_ERR, \"Padding \", pad, remainder);\n\n\trestore_bytes(s, \"slab padding\", POISON_INUSE, fault, end);\n\treturn 0;\n}"
  },
  {
    "function_name": "check_pad_bytes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "798-817",
    "snippet": "static int check_pad_bytes(struct kmem_cache *s, struct page *page, u8 *p)\n{\n\tunsigned long off = s->inuse;\t/* The end of info */\n\n\tif (s->offset)\n\t\t/* Freepointer is placed after the object. */\n\t\toff += sizeof(void *);\n\n\tif (s->flags & SLAB_STORE_USER)\n\t\t/* We also have user information there */\n\t\toff += 2 * sizeof(struct track);\n\n\toff += kasan_metadata_size(s);\n\n\tif (size_from_object(s) == off)\n\t\treturn 1;\n\n\treturn check_bytes_and_report(s, page, p, \"Object padding\",\n\t\t\tp + off, POISON_INUSE, size_from_object(s) - off);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_bytes_and_report",
          "args": [
            "s",
            "page",
            "p",
            "\"Object padding\"",
            "p + off",
            "POISON_INUSE",
            "size_from_object(s) - off"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "check_bytes_and_report",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "734-758",
          "snippet": "static int check_bytes_and_report(struct kmem_cache *s, struct page *page,\n\t\t\tu8 *object, char *what,\n\t\t\tu8 *start, unsigned int value, unsigned int bytes)\n{\n\tu8 *fault;\n\tu8 *end;\n\n\tmetadata_access_enable();\n\tfault = memchr_inv(start, value, bytes);\n\tmetadata_access_disable();\n\tif (!fault)\n\t\treturn 1;\n\n\tend = start + bytes;\n\twhile (end > fault && end[-1] == value)\n\t\tend--;\n\n\tslab_bug(s, \"%s overwritten\", what);\n\tpr_err(\"INFO: 0x%p-0x%p. First byte 0x%x instead of 0x%x\\n\",\n\t\t\t\t\tfault, end - 1, fault[0], value);\n\tprint_trailer(s, page, object);\n\n\trestore_bytes(s, what, value, fault, end);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic int check_bytes_and_report(struct kmem_cache *s, struct page *page,\n\t\t\tu8 *object, char *what,\n\t\t\tu8 *start, unsigned int value, unsigned int bytes)\n{\n\tu8 *fault;\n\tu8 *end;\n\n\tmetadata_access_enable();\n\tfault = memchr_inv(start, value, bytes);\n\tmetadata_access_disable();\n\tif (!fault)\n\t\treturn 1;\n\n\tend = start + bytes;\n\twhile (end > fault && end[-1] == value)\n\t\tend--;\n\n\tslab_bug(s, \"%s overwritten\", what);\n\tpr_err(\"INFO: 0x%p-0x%p. First byte 0x%x instead of 0x%x\\n\",\n\t\t\t\t\tfault, end - 1, fault[0], value);\n\tprint_trailer(s, page, object);\n\n\trestore_bytes(s, what, value, fault, end);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "size_from_object",
          "args": [
            "s"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "size_from_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "452-458",
          "snippet": "static inline unsigned int size_from_object(struct kmem_cache *s)\n{\n\tif (s->flags & SLAB_RED_ZONE)\n\t\treturn s->size - s->red_left_pad;\n\n\treturn s->size;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline unsigned int size_from_object(struct kmem_cache *s)\n{\n\tif (s->flags & SLAB_RED_ZONE)\n\t\treturn s->size - s->red_left_pad;\n\n\treturn s->size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kasan_metadata_size",
          "args": [
            "s"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_metadata_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "389-395",
          "snippet": "size_t kasan_metadata_size(struct kmem_cache *cache)\n{\n\treturn (cache->kasan_info.alloc_meta_offset ?\n\t\tsizeof(struct kasan_alloc_meta) : 0) +\n\t\t(cache->kasan_info.free_meta_offset ?\n\t\tsizeof(struct kasan_free_meta) : 0);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nsize_t kasan_metadata_size(struct kmem_cache *cache)\n{\n\treturn (cache->kasan_info.alloc_meta_offset ?\n\t\tsizeof(struct kasan_alloc_meta) : 0) +\n\t\t(cache->kasan_info.free_meta_offset ?\n\t\tsizeof(struct kasan_free_meta) : 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic int check_pad_bytes(struct kmem_cache *s, struct page *page, u8 *p)\n{\n\tunsigned long off = s->inuse;\t/* The end of info */\n\n\tif (s->offset)\n\t\t/* Freepointer is placed after the object. */\n\t\toff += sizeof(void *);\n\n\tif (s->flags & SLAB_STORE_USER)\n\t\t/* We also have user information there */\n\t\toff += 2 * sizeof(struct track);\n\n\toff += kasan_metadata_size(s);\n\n\tif (size_from_object(s) == off)\n\t\treturn 1;\n\n\treturn check_bytes_and_report(s, page, p, \"Object padding\",\n\t\t\tp + off, POISON_INUSE, size_from_object(s) - off);\n}"
  },
  {
    "function_name": "check_bytes_and_report",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "734-758",
    "snippet": "static int check_bytes_and_report(struct kmem_cache *s, struct page *page,\n\t\t\tu8 *object, char *what,\n\t\t\tu8 *start, unsigned int value, unsigned int bytes)\n{\n\tu8 *fault;\n\tu8 *end;\n\n\tmetadata_access_enable();\n\tfault = memchr_inv(start, value, bytes);\n\tmetadata_access_disable();\n\tif (!fault)\n\t\treturn 1;\n\n\tend = start + bytes;\n\twhile (end > fault && end[-1] == value)\n\t\tend--;\n\n\tslab_bug(s, \"%s overwritten\", what);\n\tpr_err(\"INFO: 0x%p-0x%p. First byte 0x%x instead of 0x%x\\n\",\n\t\t\t\t\tfault, end - 1, fault[0], value);\n\tprint_trailer(s, page, object);\n\n\trestore_bytes(s, what, value, fault, end);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "restore_bytes",
          "args": [
            "s",
            "what",
            "value",
            "fault",
            "end"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "restore_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "727-732",
          "snippet": "static void restore_bytes(struct kmem_cache *s, char *message, u8 data,\n\t\t\t\t\t\tvoid *from, void *to)\n{\n\tslab_fix(s, \"Restoring 0x%p-0x%p=0x%x\\n\", from, to - 1, data);\n\tmemset(from, data, to - from);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void restore_bytes(struct kmem_cache *s, char *message, u8 data,\n\t\t\t\t\t\tvoid *from, void *to)\n{\n\tslab_fix(s, \"Restoring 0x%p-0x%p=0x%x\\n\", from, to - 1, data);\n\tmemset(from, data, to - from);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_trailer",
          "args": [
            "s",
            "page",
            "object"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "print_trailer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "648-688",
          "snippet": "static void print_trailer(struct kmem_cache *s, struct page *page, u8 *p)\n{\n\tunsigned int off;\t/* Offset of last byte */\n\tu8 *addr = page_address(page);\n\n\tprint_tracking(s, p);\n\n\tprint_page_info(page);\n\n\tpr_err(\"INFO: Object 0x%p @offset=%tu fp=0x%p\\n\\n\",\n\t       p, p - addr, get_freepointer(s, p));\n\n\tif (s->flags & SLAB_RED_ZONE)\n\t\tprint_section(KERN_ERR, \"Redzone \", p - s->red_left_pad,\n\t\t\t      s->red_left_pad);\n\telse if (p > addr + 16)\n\t\tprint_section(KERN_ERR, \"Bytes b4 \", p - 16, 16);\n\n\tprint_section(KERN_ERR, \"Object \", p,\n\t\t      min_t(unsigned int, s->object_size, PAGE_SIZE));\n\tif (s->flags & SLAB_RED_ZONE)\n\t\tprint_section(KERN_ERR, \"Redzone \", p + s->object_size,\n\t\t\ts->inuse - s->object_size);\n\n\tif (s->offset)\n\t\toff = s->offset + sizeof(void *);\n\telse\n\t\toff = s->inuse;\n\n\tif (s->flags & SLAB_STORE_USER)\n\t\toff += 2 * sizeof(struct track);\n\n\toff += kasan_metadata_size(s);\n\n\tif (off != size_from_object(s))\n\t\t/* Beginning of the filler is the free pointer */\n\t\tprint_section(KERN_ERR, \"Padding \", p + off,\n\t\t\t      size_from_object(s) - off);\n\n\tdump_stack();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void print_trailer(struct kmem_cache *s, struct page *page, u8 *p)\n{\n\tunsigned int off;\t/* Offset of last byte */\n\tu8 *addr = page_address(page);\n\n\tprint_tracking(s, p);\n\n\tprint_page_info(page);\n\n\tpr_err(\"INFO: Object 0x%p @offset=%tu fp=0x%p\\n\\n\",\n\t       p, p - addr, get_freepointer(s, p));\n\n\tif (s->flags & SLAB_RED_ZONE)\n\t\tprint_section(KERN_ERR, \"Redzone \", p - s->red_left_pad,\n\t\t\t      s->red_left_pad);\n\telse if (p > addr + 16)\n\t\tprint_section(KERN_ERR, \"Bytes b4 \", p - 16, 16);\n\n\tprint_section(KERN_ERR, \"Object \", p,\n\t\t      min_t(unsigned int, s->object_size, PAGE_SIZE));\n\tif (s->flags & SLAB_RED_ZONE)\n\t\tprint_section(KERN_ERR, \"Redzone \", p + s->object_size,\n\t\t\ts->inuse - s->object_size);\n\n\tif (s->offset)\n\t\toff = s->offset + sizeof(void *);\n\telse\n\t\toff = s->inuse;\n\n\tif (s->flags & SLAB_STORE_USER)\n\t\toff += 2 * sizeof(struct track);\n\n\toff += kasan_metadata_size(s);\n\n\tif (off != size_from_object(s))\n\t\t/* Beginning of the filler is the free pointer */\n\t\tprint_section(KERN_ERR, \"Padding \", p + off,\n\t\t\t      size_from_object(s) - off);\n\n\tdump_stack();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"INFO: 0x%p-0x%p. First byte 0x%x instead of 0x%x\\n\"",
            "fault",
            "end - 1",
            "fault[0]",
            "value"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_bug",
          "args": [
            "s",
            "\"%s overwritten\"",
            "what"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "slab_bug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "620-634",
          "snippet": "static void slab_bug(struct kmem_cache *s, char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_err(\"=============================================================================\\n\");\n\tpr_err(\"BUG %s (%s): %pV\\n\", s->name, print_tainted(), &vaf);\n\tpr_err(\"-----------------------------------------------------------------------------\\n\\n\");\n\n\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n\tva_end(args);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void slab_bug(struct kmem_cache *s, char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_err(\"=============================================================================\\n\");\n\tpr_err(\"BUG %s (%s): %pV\\n\", s->name, print_tainted(), &vaf);\n\tpr_err(\"-----------------------------------------------------------------------------\\n\\n\");\n\n\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "metadata_access_disable",
          "args": [],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "metadata_access_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "491-494",
          "snippet": "static inline void metadata_access_disable(void)\n{\n\tkasan_enable_current();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void metadata_access_disable(void)\n{\n\tkasan_enable_current();\n}"
        }
      },
      {
        "call_info": {
          "callee": "memchr_inv",
          "args": [
            "start",
            "value",
            "bytes"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_access_enable",
          "args": [],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "metadata_access_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "486-489",
          "snippet": "static inline void metadata_access_enable(void)\n{\n\tkasan_disable_current();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void metadata_access_enable(void)\n{\n\tkasan_disable_current();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic int check_bytes_and_report(struct kmem_cache *s, struct page *page,\n\t\t\tu8 *object, char *what,\n\t\t\tu8 *start, unsigned int value, unsigned int bytes)\n{\n\tu8 *fault;\n\tu8 *end;\n\n\tmetadata_access_enable();\n\tfault = memchr_inv(start, value, bytes);\n\tmetadata_access_disable();\n\tif (!fault)\n\t\treturn 1;\n\n\tend = start + bytes;\n\twhile (end > fault && end[-1] == value)\n\t\tend--;\n\n\tslab_bug(s, \"%s overwritten\", what);\n\tpr_err(\"INFO: 0x%p-0x%p. First byte 0x%x instead of 0x%x\\n\",\n\t\t\t\t\tfault, end - 1, fault[0], value);\n\tprint_trailer(s, page, object);\n\n\trestore_bytes(s, what, value, fault, end);\n\treturn 0;\n}"
  },
  {
    "function_name": "restore_bytes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "727-732",
    "snippet": "static void restore_bytes(struct kmem_cache *s, char *message, u8 data,\n\t\t\t\t\t\tvoid *from, void *to)\n{\n\tslab_fix(s, \"Restoring 0x%p-0x%p=0x%x\\n\", from, to - 1, data);\n\tmemset(from, data, to - from);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "from",
            "data",
            "to - from"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "slab_fix",
          "args": [
            "s",
            "\"Restoring 0x%p-0x%p=0x%x\\n\"",
            "from",
            "to - 1",
            "data"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "slab_fix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "636-646",
          "snippet": "static void slab_fix(struct kmem_cache *s, char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_err(\"FIX %s: %pV\\n\", s->name, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void slab_fix(struct kmem_cache *s, char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_err(\"FIX %s: %pV\\n\", s->name, &vaf);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void restore_bytes(struct kmem_cache *s, char *message, u8 data,\n\t\t\t\t\t\tvoid *from, void *to)\n{\n\tslab_fix(s, \"Restoring 0x%p-0x%p=0x%x\\n\", from, to - 1, data);\n\tmemset(from, data, to - from);\n}"
  },
  {
    "function_name": "init_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "711-725",
    "snippet": "static void init_object(struct kmem_cache *s, void *object, u8 val)\n{\n\tu8 *p = object;\n\n\tif (s->flags & SLAB_RED_ZONE)\n\t\tmemset(p - s->red_left_pad, val, s->red_left_pad);\n\n\tif (s->flags & __OBJECT_POISON) {\n\t\tmemset(p, POISON_FREE, s->object_size - 1);\n\t\tp[s->object_size - 1] = POISON_END;\n\t}\n\n\tif (s->flags & SLAB_RED_ZONE)\n\t\tmemset(p + s->object_size, val, s->inuse - s->object_size);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define __OBJECT_POISON\t\t((slab_flags_t __force)0x80000000U)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "p + s->object_size",
            "val",
            "s->inuse - s->object_size"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define __OBJECT_POISON\t\t((slab_flags_t __force)0x80000000U)\n\nstatic void init_object(struct kmem_cache *s, void *object, u8 val)\n{\n\tu8 *p = object;\n\n\tif (s->flags & SLAB_RED_ZONE)\n\t\tmemset(p - s->red_left_pad, val, s->red_left_pad);\n\n\tif (s->flags & __OBJECT_POISON) {\n\t\tmemset(p, POISON_FREE, s->object_size - 1);\n\t\tp[s->object_size - 1] = POISON_END;\n\t}\n\n\tif (s->flags & SLAB_RED_ZONE)\n\t\tmemset(p + s->object_size, val, s->inuse - s->object_size);\n}"
  },
  {
    "function_name": "object_err",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "690-695",
    "snippet": "void object_err(struct kmem_cache *s, struct page *page,\n\t\t\tu8 *object, char *reason)\n{\n\tslab_bug(s, \"%s\", reason);\n\tprint_trailer(s, page, object);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_trailer",
          "args": [
            "s",
            "page",
            "object"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "print_trailer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "648-688",
          "snippet": "static void print_trailer(struct kmem_cache *s, struct page *page, u8 *p)\n{\n\tunsigned int off;\t/* Offset of last byte */\n\tu8 *addr = page_address(page);\n\n\tprint_tracking(s, p);\n\n\tprint_page_info(page);\n\n\tpr_err(\"INFO: Object 0x%p @offset=%tu fp=0x%p\\n\\n\",\n\t       p, p - addr, get_freepointer(s, p));\n\n\tif (s->flags & SLAB_RED_ZONE)\n\t\tprint_section(KERN_ERR, \"Redzone \", p - s->red_left_pad,\n\t\t\t      s->red_left_pad);\n\telse if (p > addr + 16)\n\t\tprint_section(KERN_ERR, \"Bytes b4 \", p - 16, 16);\n\n\tprint_section(KERN_ERR, \"Object \", p,\n\t\t      min_t(unsigned int, s->object_size, PAGE_SIZE));\n\tif (s->flags & SLAB_RED_ZONE)\n\t\tprint_section(KERN_ERR, \"Redzone \", p + s->object_size,\n\t\t\ts->inuse - s->object_size);\n\n\tif (s->offset)\n\t\toff = s->offset + sizeof(void *);\n\telse\n\t\toff = s->inuse;\n\n\tif (s->flags & SLAB_STORE_USER)\n\t\toff += 2 * sizeof(struct track);\n\n\toff += kasan_metadata_size(s);\n\n\tif (off != size_from_object(s))\n\t\t/* Beginning of the filler is the free pointer */\n\t\tprint_section(KERN_ERR, \"Padding \", p + off,\n\t\t\t      size_from_object(s) - off);\n\n\tdump_stack();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void print_trailer(struct kmem_cache *s, struct page *page, u8 *p)\n{\n\tunsigned int off;\t/* Offset of last byte */\n\tu8 *addr = page_address(page);\n\n\tprint_tracking(s, p);\n\n\tprint_page_info(page);\n\n\tpr_err(\"INFO: Object 0x%p @offset=%tu fp=0x%p\\n\\n\",\n\t       p, p - addr, get_freepointer(s, p));\n\n\tif (s->flags & SLAB_RED_ZONE)\n\t\tprint_section(KERN_ERR, \"Redzone \", p - s->red_left_pad,\n\t\t\t      s->red_left_pad);\n\telse if (p > addr + 16)\n\t\tprint_section(KERN_ERR, \"Bytes b4 \", p - 16, 16);\n\n\tprint_section(KERN_ERR, \"Object \", p,\n\t\t      min_t(unsigned int, s->object_size, PAGE_SIZE));\n\tif (s->flags & SLAB_RED_ZONE)\n\t\tprint_section(KERN_ERR, \"Redzone \", p + s->object_size,\n\t\t\ts->inuse - s->object_size);\n\n\tif (s->offset)\n\t\toff = s->offset + sizeof(void *);\n\telse\n\t\toff = s->inuse;\n\n\tif (s->flags & SLAB_STORE_USER)\n\t\toff += 2 * sizeof(struct track);\n\n\toff += kasan_metadata_size(s);\n\n\tif (off != size_from_object(s))\n\t\t/* Beginning of the filler is the free pointer */\n\t\tprint_section(KERN_ERR, \"Padding \", p + off,\n\t\t\t      size_from_object(s) - off);\n\n\tdump_stack();\n}"
        }
      },
      {
        "call_info": {
          "callee": "slab_bug",
          "args": [
            "s",
            "\"%s\"",
            "reason"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "slab_bug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "620-634",
          "snippet": "static void slab_bug(struct kmem_cache *s, char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_err(\"=============================================================================\\n\");\n\tpr_err(\"BUG %s (%s): %pV\\n\", s->name, print_tainted(), &vaf);\n\tpr_err(\"-----------------------------------------------------------------------------\\n\\n\");\n\n\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n\tva_end(args);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void slab_bug(struct kmem_cache *s, char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_err(\"=============================================================================\\n\");\n\tpr_err(\"BUG %s (%s): %pV\\n\", s->name, print_tainted(), &vaf);\n\tpr_err(\"-----------------------------------------------------------------------------\\n\\n\");\n\n\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid object_err(struct kmem_cache *s, struct page *page,\n\t\t\tu8 *object, char *reason)\n{\n\tslab_bug(s, \"%s\", reason);\n\tprint_trailer(s, page, object);\n}"
  },
  {
    "function_name": "print_trailer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "648-688",
    "snippet": "static void print_trailer(struct kmem_cache *s, struct page *page, u8 *p)\n{\n\tunsigned int off;\t/* Offset of last byte */\n\tu8 *addr = page_address(page);\n\n\tprint_tracking(s, p);\n\n\tprint_page_info(page);\n\n\tpr_err(\"INFO: Object 0x%p @offset=%tu fp=0x%p\\n\\n\",\n\t       p, p - addr, get_freepointer(s, p));\n\n\tif (s->flags & SLAB_RED_ZONE)\n\t\tprint_section(KERN_ERR, \"Redzone \", p - s->red_left_pad,\n\t\t\t      s->red_left_pad);\n\telse if (p > addr + 16)\n\t\tprint_section(KERN_ERR, \"Bytes b4 \", p - 16, 16);\n\n\tprint_section(KERN_ERR, \"Object \", p,\n\t\t      min_t(unsigned int, s->object_size, PAGE_SIZE));\n\tif (s->flags & SLAB_RED_ZONE)\n\t\tprint_section(KERN_ERR, \"Redzone \", p + s->object_size,\n\t\t\ts->inuse - s->object_size);\n\n\tif (s->offset)\n\t\toff = s->offset + sizeof(void *);\n\telse\n\t\toff = s->inuse;\n\n\tif (s->flags & SLAB_STORE_USER)\n\t\toff += 2 * sizeof(struct track);\n\n\toff += kasan_metadata_size(s);\n\n\tif (off != size_from_object(s))\n\t\t/* Beginning of the filler is the free pointer */\n\t\tprint_section(KERN_ERR, \"Padding \", p + off,\n\t\t\t      size_from_object(s) - off);\n\n\tdump_stack();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_section",
          "args": [
            "KERN_ERR",
            "\"Padding \"",
            "p + off",
            "size_from_object(s) - off"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "print_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "519-526",
          "snippet": "static void print_section(char *level, char *text, u8 *addr,\n\t\t\t  unsigned int length)\n{\n\tmetadata_access_enable();\n\tprint_hex_dump(level, text, DUMP_PREFIX_ADDRESS, 16, 1, addr,\n\t\t\tlength, 1);\n\tmetadata_access_disable();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void print_section(char *level, char *text, u8 *addr,\n\t\t\t  unsigned int length)\n{\n\tmetadata_access_enable();\n\tprint_hex_dump(level, text, DUMP_PREFIX_ADDRESS, 16, 1, addr,\n\t\t\tlength, 1);\n\tmetadata_access_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "size_from_object",
          "args": [
            "s"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "size_from_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "452-458",
          "snippet": "static inline unsigned int size_from_object(struct kmem_cache *s)\n{\n\tif (s->flags & SLAB_RED_ZONE)\n\t\treturn s->size - s->red_left_pad;\n\n\treturn s->size;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline unsigned int size_from_object(struct kmem_cache *s)\n{\n\tif (s->flags & SLAB_RED_ZONE)\n\t\treturn s->size - s->red_left_pad;\n\n\treturn s->size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kasan_metadata_size",
          "args": [
            "s"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_metadata_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "389-395",
          "snippet": "size_t kasan_metadata_size(struct kmem_cache *cache)\n{\n\treturn (cache->kasan_info.alloc_meta_offset ?\n\t\tsizeof(struct kasan_alloc_meta) : 0) +\n\t\t(cache->kasan_info.free_meta_offset ?\n\t\tsizeof(struct kasan_free_meta) : 0);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nsize_t kasan_metadata_size(struct kmem_cache *cache)\n{\n\treturn (cache->kasan_info.alloc_meta_offset ?\n\t\tsizeof(struct kasan_alloc_meta) : 0) +\n\t\t(cache->kasan_info.free_meta_offset ?\n\t\tsizeof(struct kasan_free_meta) : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "s->object_size",
            "PAGE_SIZE"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"INFO: Object 0x%p @offset=%tu fp=0x%p\\n\\n\"",
            "p",
            "p - addr",
            "get_freepointer(s, p)"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_freepointer",
          "args": [
            "s",
            "p"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "get_freepointer_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "276-287",
          "snippet": "static inline void *get_freepointer_safe(struct kmem_cache *s, void *object)\n{\n\tunsigned long freepointer_addr;\n\tvoid *p;\n\n\tif (!debug_pagealloc_enabled())\n\t\treturn get_freepointer(s, object);\n\n\tfreepointer_addr = (unsigned long)object + s->offset;\n\tprobe_kernel_read(&p, (void **)freepointer_addr, sizeof(p));\n\treturn freelist_ptr(s, p, freepointer_addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void *get_freepointer_safe(struct kmem_cache *s, void *object)\n{\n\tunsigned long freepointer_addr;\n\tvoid *p;\n\n\tif (!debug_pagealloc_enabled())\n\t\treturn get_freepointer(s, object);\n\n\tfreepointer_addr = (unsigned long)object + s->offset;\n\tprobe_kernel_read(&p, (void **)freepointer_addr, sizeof(p));\n\treturn freelist_ptr(s, p, freepointer_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_page_info",
          "args": [
            "page"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "print_page_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "613-618",
          "snippet": "static void print_page_info(struct page *page)\n{\n\tpr_err(\"INFO: Slab 0x%p objects=%u used=%u fp=0x%p flags=0x%04lx\\n\",\n\t       page, page->objects, page->inuse, page->freelist, page->flags);\n\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void print_page_info(struct page *page)\n{\n\tpr_err(\"INFO: Slab 0x%p objects=%u used=%u fp=0x%p flags=0x%04lx\\n\",\n\t       page, page->objects, page->inuse, page->freelist, page->flags);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_tracking",
          "args": [
            "s",
            "p"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "print_tracking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "603-611",
          "snippet": "static void print_tracking(struct kmem_cache *s, void *object)\n{\n\tunsigned long pr_time = jiffies;\n\tif (!(s->flags & SLAB_STORE_USER))\n\t\treturn;\n\n\tprint_track(\"Allocated\", get_track(s, object, TRACK_ALLOC), pr_time);\n\tprint_track(\"Freed\", get_track(s, object, TRACK_FREE), pr_time);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void print_tracking(struct kmem_cache *s, void *object)\n{\n\tunsigned long pr_time = jiffies;\n\tif (!(s->flags & SLAB_STORE_USER))\n\t\treturn;\n\n\tprint_track(\"Allocated\", get_track(s, object, TRACK_ALLOC), pr_time);\n\tprint_track(\"Freed\", get_track(s, object, TRACK_FREE), pr_time);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "page_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "409-434",
          "snippet": "void *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void print_trailer(struct kmem_cache *s, struct page *page, u8 *p)\n{\n\tunsigned int off;\t/* Offset of last byte */\n\tu8 *addr = page_address(page);\n\n\tprint_tracking(s, p);\n\n\tprint_page_info(page);\n\n\tpr_err(\"INFO: Object 0x%p @offset=%tu fp=0x%p\\n\\n\",\n\t       p, p - addr, get_freepointer(s, p));\n\n\tif (s->flags & SLAB_RED_ZONE)\n\t\tprint_section(KERN_ERR, \"Redzone \", p - s->red_left_pad,\n\t\t\t      s->red_left_pad);\n\telse if (p > addr + 16)\n\t\tprint_section(KERN_ERR, \"Bytes b4 \", p - 16, 16);\n\n\tprint_section(KERN_ERR, \"Object \", p,\n\t\t      min_t(unsigned int, s->object_size, PAGE_SIZE));\n\tif (s->flags & SLAB_RED_ZONE)\n\t\tprint_section(KERN_ERR, \"Redzone \", p + s->object_size,\n\t\t\ts->inuse - s->object_size);\n\n\tif (s->offset)\n\t\toff = s->offset + sizeof(void *);\n\telse\n\t\toff = s->inuse;\n\n\tif (s->flags & SLAB_STORE_USER)\n\t\toff += 2 * sizeof(struct track);\n\n\toff += kasan_metadata_size(s);\n\n\tif (off != size_from_object(s))\n\t\t/* Beginning of the filler is the free pointer */\n\t\tprint_section(KERN_ERR, \"Padding \", p + off,\n\t\t\t      size_from_object(s) - off);\n\n\tdump_stack();\n}"
  },
  {
    "function_name": "slab_fix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "636-646",
    "snippet": "static void slab_fix(struct kmem_cache *s, char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_err(\"FIX %s: %pV\\n\", s->name, &vaf);\n\tva_end(args);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"FIX %s: %pV\\n\"",
            "s->name",
            "&vaf"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void slab_fix(struct kmem_cache *s, char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_err(\"FIX %s: %pV\\n\", s->name, &vaf);\n\tva_end(args);\n}"
  },
  {
    "function_name": "slab_bug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "620-634",
    "snippet": "static void slab_bug(struct kmem_cache *s, char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_err(\"=============================================================================\\n\");\n\tpr_err(\"BUG %s (%s): %pV\\n\", s->name, print_tainted(), &vaf);\n\tpr_err(\"-----------------------------------------------------------------------------\\n\\n\");\n\n\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n\tva_end(args);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_taint",
          "args": [
            "TAINT_BAD_PAGE",
            "LOCKDEP_NOW_UNRELIABLE"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"-----------------------------------------------------------------------------\\n\\n\""
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"BUG %s (%s): %pV\\n\"",
            "s->name",
            "print_tainted()",
            "&vaf"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_tainted",
          "args": [],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"=============================================================================\\n\""
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void slab_bug(struct kmem_cache *s, char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_err(\"=============================================================================\\n\");\n\tpr_err(\"BUG %s (%s): %pV\\n\", s->name, print_tainted(), &vaf);\n\tpr_err(\"-----------------------------------------------------------------------------\\n\\n\");\n\n\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n\tva_end(args);\n}"
  },
  {
    "function_name": "print_page_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "613-618",
    "snippet": "static void print_page_info(struct page *page)\n{\n\tpr_err(\"INFO: Slab 0x%p objects=%u used=%u fp=0x%p flags=0x%04lx\\n\",\n\t       page, page->objects, page->inuse, page->freelist, page->flags);\n\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"INFO: Slab 0x%p objects=%u used=%u fp=0x%p flags=0x%04lx\\n\"",
            "page",
            "page->objects",
            "page->inuse",
            "page->freelist",
            "page->flags"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void print_page_info(struct page *page)\n{\n\tpr_err(\"INFO: Slab 0x%p objects=%u used=%u fp=0x%p flags=0x%04lx\\n\",\n\t       page, page->objects, page->inuse, page->freelist, page->flags);\n\n}"
  },
  {
    "function_name": "print_tracking",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "603-611",
    "snippet": "static void print_tracking(struct kmem_cache *s, void *object)\n{\n\tunsigned long pr_time = jiffies;\n\tif (!(s->flags & SLAB_STORE_USER))\n\t\treturn;\n\n\tprint_track(\"Allocated\", get_track(s, object, TRACK_ALLOC), pr_time);\n\tprint_track(\"Freed\", get_track(s, object, TRACK_FREE), pr_time);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_track",
          "args": [
            "\"Freed\"",
            "get_track(s, object, TRACK_FREE)",
            "pr_time"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "print_track",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "584-601",
          "snippet": "static void print_track(const char *s, struct track *t, unsigned long pr_time)\n{\n\tif (!t->addr)\n\t\treturn;\n\n\tpr_err(\"INFO: %s in %pS age=%lu cpu=%u pid=%d\\n\",\n\t       s, (void *)t->addr, pr_time - t->when, t->cpu, t->pid);\n#ifdef CONFIG_STACKTRACE\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < TRACK_ADDRS_COUNT; i++)\n\t\t\tif (t->addrs[i])\n\t\t\t\tpr_err(\"\\t%pS\\n\", (void *)t->addrs[i]);\n\t\t\telse\n\t\t\t\tbreak;\n\t}\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define TRACK_ADDRS_COUNT 16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define TRACK_ADDRS_COUNT 16\n\nstatic void print_track(const char *s, struct track *t, unsigned long pr_time)\n{\n\tif (!t->addr)\n\t\treturn;\n\n\tpr_err(\"INFO: %s in %pS age=%lu cpu=%u pid=%d\\n\",\n\t       s, (void *)t->addr, pr_time - t->when, t->cpu, t->pid);\n#ifdef CONFIG_STACKTRACE\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < TRACK_ADDRS_COUNT; i++)\n\t\t\tif (t->addrs[i])\n\t\t\t\tpr_err(\"\\t%pS\\n\", (void *)t->addrs[i]);\n\t\t\telse\n\t\t\t\tbreak;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_track",
          "args": [
            "s",
            "object",
            "TRACK_FREE"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "get_track",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "528-539",
          "snippet": "static struct track *get_track(struct kmem_cache *s, void *object,\n\tenum track_item alloc)\n{\n\tstruct track *p;\n\n\tif (s->offset)\n\t\tp = object + s->offset + sizeof(void *);\n\telse\n\t\tp = object + s->inuse;\n\n\treturn p + alloc;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct track *get_track(struct kmem_cache *s, void *object,\n\tenum track_item alloc)\n{\n\tstruct track *p;\n\n\tif (s->offset)\n\t\tp = object + s->offset + sizeof(void *);\n\telse\n\t\tp = object + s->inuse;\n\n\treturn p + alloc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void print_tracking(struct kmem_cache *s, void *object)\n{\n\tunsigned long pr_time = jiffies;\n\tif (!(s->flags & SLAB_STORE_USER))\n\t\treturn;\n\n\tprint_track(\"Allocated\", get_track(s, object, TRACK_ALLOC), pr_time);\n\tprint_track(\"Freed\", get_track(s, object, TRACK_FREE), pr_time);\n}"
  },
  {
    "function_name": "print_track",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "584-601",
    "snippet": "static void print_track(const char *s, struct track *t, unsigned long pr_time)\n{\n\tif (!t->addr)\n\t\treturn;\n\n\tpr_err(\"INFO: %s in %pS age=%lu cpu=%u pid=%d\\n\",\n\t       s, (void *)t->addr, pr_time - t->when, t->cpu, t->pid);\n#ifdef CONFIG_STACKTRACE\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < TRACK_ADDRS_COUNT; i++)\n\t\t\tif (t->addrs[i])\n\t\t\t\tpr_err(\"\\t%pS\\n\", (void *)t->addrs[i]);\n\t\t\telse\n\t\t\t\tbreak;\n\t}\n#endif\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define TRACK_ADDRS_COUNT 16"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"\\t%pS\\n\"",
            "(void *)t->addrs[i]"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"INFO: %s in %pS age=%lu cpu=%u pid=%d\\n\"",
            "s",
            "(void *)t->addr",
            "pr_time - t->when",
            "t->cpu",
            "t->pid"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define TRACK_ADDRS_COUNT 16\n\nstatic void print_track(const char *s, struct track *t, unsigned long pr_time)\n{\n\tif (!t->addr)\n\t\treturn;\n\n\tpr_err(\"INFO: %s in %pS age=%lu cpu=%u pid=%d\\n\",\n\t       s, (void *)t->addr, pr_time - t->when, t->cpu, t->pid);\n#ifdef CONFIG_STACKTRACE\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < TRACK_ADDRS_COUNT; i++)\n\t\t\tif (t->addrs[i])\n\t\t\t\tpr_err(\"\\t%pS\\n\", (void *)t->addrs[i]);\n\t\t\telse\n\t\t\t\tbreak;\n\t}\n#endif\n}"
  },
  {
    "function_name": "init_tracking",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "575-582",
    "snippet": "static void init_tracking(struct kmem_cache *s, void *object)\n{\n\tif (!(s->flags & SLAB_STORE_USER))\n\t\treturn;\n\n\tset_track(s, object, TRACK_FREE, 0UL);\n\tset_track(s, object, TRACK_ALLOC, 0UL);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_track",
          "args": [
            "s",
            "object",
            "TRACK_ALLOC",
            "0UL"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "set_track",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "541-573",
          "snippet": "static void set_track(struct kmem_cache *s, void *object,\n\t\t\tenum track_item alloc, unsigned long addr)\n{\n\tstruct track *p = get_track(s, object, alloc);\n\n\tif (addr) {\n#ifdef CONFIG_STACKTRACE\n\t\tstruct stack_trace trace;\n\t\tint i;\n\n\t\ttrace.nr_entries = 0;\n\t\ttrace.max_entries = TRACK_ADDRS_COUNT;\n\t\ttrace.entries = p->addrs;\n\t\ttrace.skip = 3;\n\t\tmetadata_access_enable();\n\t\tsave_stack_trace(&trace);\n\t\tmetadata_access_disable();\n\n\t\t/* See rant in lockdep.c */\n\t\tif (trace.nr_entries != 0 &&\n\t\t    trace.entries[trace.nr_entries - 1] == ULONG_MAX)\n\t\t\ttrace.nr_entries--;\n\n\t\tfor (i = trace.nr_entries; i < TRACK_ADDRS_COUNT; i++)\n\t\t\tp->addrs[i] = 0;\n#endif\n\t\tp->addr = addr;\n\t\tp->cpu = smp_processor_id();\n\t\tp->pid = current->pid;\n\t\tp->when = jiffies;\n\t} else\n\t\tmemset(p, 0, sizeof(struct track));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define TRACK_ADDRS_COUNT 16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define TRACK_ADDRS_COUNT 16\n\nstatic void set_track(struct kmem_cache *s, void *object,\n\t\t\tenum track_item alloc, unsigned long addr)\n{\n\tstruct track *p = get_track(s, object, alloc);\n\n\tif (addr) {\n#ifdef CONFIG_STACKTRACE\n\t\tstruct stack_trace trace;\n\t\tint i;\n\n\t\ttrace.nr_entries = 0;\n\t\ttrace.max_entries = TRACK_ADDRS_COUNT;\n\t\ttrace.entries = p->addrs;\n\t\ttrace.skip = 3;\n\t\tmetadata_access_enable();\n\t\tsave_stack_trace(&trace);\n\t\tmetadata_access_disable();\n\n\t\t/* See rant in lockdep.c */\n\t\tif (trace.nr_entries != 0 &&\n\t\t    trace.entries[trace.nr_entries - 1] == ULONG_MAX)\n\t\t\ttrace.nr_entries--;\n\n\t\tfor (i = trace.nr_entries; i < TRACK_ADDRS_COUNT; i++)\n\t\t\tp->addrs[i] = 0;\n#endif\n\t\tp->addr = addr;\n\t\tp->cpu = smp_processor_id();\n\t\tp->pid = current->pid;\n\t\tp->when = jiffies;\n\t} else\n\t\tmemset(p, 0, sizeof(struct track));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void init_tracking(struct kmem_cache *s, void *object)\n{\n\tif (!(s->flags & SLAB_STORE_USER))\n\t\treturn;\n\n\tset_track(s, object, TRACK_FREE, 0UL);\n\tset_track(s, object, TRACK_ALLOC, 0UL);\n}"
  },
  {
    "function_name": "set_track",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "541-573",
    "snippet": "static void set_track(struct kmem_cache *s, void *object,\n\t\t\tenum track_item alloc, unsigned long addr)\n{\n\tstruct track *p = get_track(s, object, alloc);\n\n\tif (addr) {\n#ifdef CONFIG_STACKTRACE\n\t\tstruct stack_trace trace;\n\t\tint i;\n\n\t\ttrace.nr_entries = 0;\n\t\ttrace.max_entries = TRACK_ADDRS_COUNT;\n\t\ttrace.entries = p->addrs;\n\t\ttrace.skip = 3;\n\t\tmetadata_access_enable();\n\t\tsave_stack_trace(&trace);\n\t\tmetadata_access_disable();\n\n\t\t/* See rant in lockdep.c */\n\t\tif (trace.nr_entries != 0 &&\n\t\t    trace.entries[trace.nr_entries - 1] == ULONG_MAX)\n\t\t\ttrace.nr_entries--;\n\n\t\tfor (i = trace.nr_entries; i < TRACK_ADDRS_COUNT; i++)\n\t\t\tp->addrs[i] = 0;\n#endif\n\t\tp->addr = addr;\n\t\tp->cpu = smp_processor_id();\n\t\tp->pid = current->pid;\n\t\tp->when = jiffies;\n\t} else\n\t\tmemset(p, 0, sizeof(struct track));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define TRACK_ADDRS_COUNT 16"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "p",
            "0",
            "sizeof(struct track)"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_access_disable",
          "args": [],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "metadata_access_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "491-494",
          "snippet": "static inline void metadata_access_disable(void)\n{\n\tkasan_enable_current();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void metadata_access_disable(void)\n{\n\tkasan_enable_current();\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_stack_trace",
          "args": [
            "&trace"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "__save_stack_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "554-565",
          "snippet": "static int __save_stack_trace(unsigned long *trace)\n{\n\tstruct stack_trace stack_trace;\n\n\tstack_trace.max_entries = MAX_TRACE;\n\tstack_trace.nr_entries = 0;\n\tstack_trace.entries = trace;\n\tstack_trace.skip = 2;\n\tsave_stack_trace(&stack_trace);\n\n\treturn stack_trace.nr_entries;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define MAX_TRACE\t\t16\t/* stack trace length */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define MAX_TRACE\t\t16\t/* stack trace length */\n\nstatic int __save_stack_trace(unsigned long *trace)\n{\n\tstruct stack_trace stack_trace;\n\n\tstack_trace.max_entries = MAX_TRACE;\n\tstack_trace.nr_entries = 0;\n\tstack_trace.entries = trace;\n\tstack_trace.skip = 2;\n\tsave_stack_trace(&stack_trace);\n\n\treturn stack_trace.nr_entries;\n}"
        }
      },
      {
        "call_info": {
          "callee": "metadata_access_enable",
          "args": [],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "metadata_access_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "486-489",
          "snippet": "static inline void metadata_access_enable(void)\n{\n\tkasan_disable_current();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void metadata_access_enable(void)\n{\n\tkasan_disable_current();\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_track",
          "args": [
            "s",
            "object",
            "alloc"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "get_track",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "528-539",
          "snippet": "static struct track *get_track(struct kmem_cache *s, void *object,\n\tenum track_item alloc)\n{\n\tstruct track *p;\n\n\tif (s->offset)\n\t\tp = object + s->offset + sizeof(void *);\n\telse\n\t\tp = object + s->inuse;\n\n\treturn p + alloc;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct track *get_track(struct kmem_cache *s, void *object,\n\tenum track_item alloc)\n{\n\tstruct track *p;\n\n\tif (s->offset)\n\t\tp = object + s->offset + sizeof(void *);\n\telse\n\t\tp = object + s->inuse;\n\n\treturn p + alloc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define TRACK_ADDRS_COUNT 16\n\nstatic void set_track(struct kmem_cache *s, void *object,\n\t\t\tenum track_item alloc, unsigned long addr)\n{\n\tstruct track *p = get_track(s, object, alloc);\n\n\tif (addr) {\n#ifdef CONFIG_STACKTRACE\n\t\tstruct stack_trace trace;\n\t\tint i;\n\n\t\ttrace.nr_entries = 0;\n\t\ttrace.max_entries = TRACK_ADDRS_COUNT;\n\t\ttrace.entries = p->addrs;\n\t\ttrace.skip = 3;\n\t\tmetadata_access_enable();\n\t\tsave_stack_trace(&trace);\n\t\tmetadata_access_disable();\n\n\t\t/* See rant in lockdep.c */\n\t\tif (trace.nr_entries != 0 &&\n\t\t    trace.entries[trace.nr_entries - 1] == ULONG_MAX)\n\t\t\ttrace.nr_entries--;\n\n\t\tfor (i = trace.nr_entries; i < TRACK_ADDRS_COUNT; i++)\n\t\t\tp->addrs[i] = 0;\n#endif\n\t\tp->addr = addr;\n\t\tp->cpu = smp_processor_id();\n\t\tp->pid = current->pid;\n\t\tp->when = jiffies;\n\t} else\n\t\tmemset(p, 0, sizeof(struct track));\n}"
  },
  {
    "function_name": "get_track",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "528-539",
    "snippet": "static struct track *get_track(struct kmem_cache *s, void *object,\n\tenum track_item alloc)\n{\n\tstruct track *p;\n\n\tif (s->offset)\n\t\tp = object + s->offset + sizeof(void *);\n\telse\n\t\tp = object + s->inuse;\n\n\treturn p + alloc;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic struct track *get_track(struct kmem_cache *s, void *object,\n\tenum track_item alloc)\n{\n\tstruct track *p;\n\n\tif (s->offset)\n\t\tp = object + s->offset + sizeof(void *);\n\telse\n\t\tp = object + s->inuse;\n\n\treturn p + alloc;\n}"
  },
  {
    "function_name": "print_section",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "519-526",
    "snippet": "static void print_section(char *level, char *text, u8 *addr,\n\t\t\t  unsigned int length)\n{\n\tmetadata_access_enable();\n\tprint_hex_dump(level, text, DUMP_PREFIX_ADDRESS, 16, 1, addr,\n\t\t\tlength, 1);\n\tmetadata_access_disable();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "metadata_access_disable",
          "args": [],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "metadata_access_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "491-494",
          "snippet": "static inline void metadata_access_disable(void)\n{\n\tkasan_enable_current();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void metadata_access_disable(void)\n{\n\tkasan_enable_current();\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_hex_dump",
          "args": [
            "level",
            "text",
            "DUMP_PREFIX_ADDRESS",
            "16",
            "1",
            "addr",
            "length",
            "1"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_access_enable",
          "args": [],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "metadata_access_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "486-489",
          "snippet": "static inline void metadata_access_enable(void)\n{\n\tkasan_disable_current();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void metadata_access_enable(void)\n{\n\tkasan_disable_current();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void print_section(char *level, char *text, u8 *addr,\n\t\t\t  unsigned int length)\n{\n\tmetadata_access_enable();\n\tprint_hex_dump(level, text, DUMP_PREFIX_ADDRESS, 16, 1, addr,\n\t\t\tlength, 1);\n\tmetadata_access_disable();\n}"
  },
  {
    "function_name": "check_valid_pointer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "501-517",
    "snippet": "static inline int check_valid_pointer(struct kmem_cache *s,\n\t\t\t\tstruct page *page, void *object)\n{\n\tvoid *base;\n\n\tif (!object)\n\t\treturn 1;\n\n\tbase = page_address(page);\n\tobject = restore_red_left(s, object);\n\tif (object < base || object >= base + page->objects * s->size ||\n\t\t(object - base) % s->size) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "restore_red_left",
          "args": [
            "s",
            "object"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "restore_red_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "460-466",
          "snippet": "static inline void *restore_red_left(struct kmem_cache *s, void *p)\n{\n\tif (s->flags & SLAB_RED_ZONE)\n\t\tp -= s->red_left_pad;\n\n\treturn p;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void *restore_red_left(struct kmem_cache *s, void *p)\n{\n\tif (s->flags & SLAB_RED_ZONE)\n\t\tp -= s->red_left_pad;\n\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "page_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "409-434",
          "snippet": "void *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline int check_valid_pointer(struct kmem_cache *s,\n\t\t\t\tstruct page *page, void *object)\n{\n\tvoid *base;\n\n\tif (!object)\n\t\treturn 1;\n\n\tbase = page_address(page);\n\tobject = restore_red_left(s, object);\n\tif (object < base || object >= base + page->objects * s->size ||\n\t\t(object - base) % s->size) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "metadata_access_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "491-494",
    "snippet": "static inline void metadata_access_disable(void)\n{\n\tkasan_enable_current();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kasan_enable_current",
          "args": [],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_enable_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "43-46",
          "snippet": "void kasan_enable_current(void)\n{\n\tcurrent->kasan_depth++;\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\nvoid kasan_enable_current(void)\n{\n\tcurrent->kasan_depth++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void metadata_access_disable(void)\n{\n\tkasan_enable_current();\n}"
  },
  {
    "function_name": "metadata_access_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "486-489",
    "snippet": "static inline void metadata_access_enable(void)\n{\n\tkasan_disable_current();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kasan_disable_current",
          "args": [],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_disable_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "48-51",
          "snippet": "void kasan_disable_current(void)\n{\n\tcurrent->kasan_depth--;\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\nvoid kasan_disable_current(void)\n{\n\tcurrent->kasan_depth--;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void metadata_access_enable(void)\n{\n\tkasan_disable_current();\n}"
  },
  {
    "function_name": "restore_red_left",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "460-466",
    "snippet": "static inline void *restore_red_left(struct kmem_cache *s, void *p)\n{\n\tif (s->flags & SLAB_RED_ZONE)\n\t\tp -= s->red_left_pad;\n\n\treturn p;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void *restore_red_left(struct kmem_cache *s, void *p)\n{\n\tif (s->flags & SLAB_RED_ZONE)\n\t\tp -= s->red_left_pad;\n\n\treturn p;\n}"
  },
  {
    "function_name": "size_from_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "452-458",
    "snippet": "static inline unsigned int size_from_object(struct kmem_cache *s)\n{\n\tif (s->flags & SLAB_RED_ZONE)\n\t\treturn s->size - s->red_left_pad;\n\n\treturn s->size;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline unsigned int size_from_object(struct kmem_cache *s)\n{\n\tif (s->flags & SLAB_RED_ZONE)\n\t\treturn s->size - s->red_left_pad;\n\n\treturn s->size;\n}"
  },
  {
    "function_name": "get_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "443-450",
    "snippet": "static void get_map(struct kmem_cache *s, struct page *page, unsigned long *map)\n{\n\tvoid *p;\n\tvoid *addr = page_address(page);\n\n\tfor (p = page->freelist; p; p = get_freepointer(s, p))\n\t\tset_bit(slab_index(p, s, addr), map);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "slab_index(p, s, addr)",
            "map"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_index",
          "args": [
            "p",
            "s",
            "addr"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "slab_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "312-315",
          "snippet": "static inline unsigned int slab_index(void *p, struct kmem_cache *s, void *addr)\n{\n\treturn (p - addr) / s->size;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline unsigned int slab_index(void *p, struct kmem_cache *s, void *addr)\n{\n\treturn (p - addr) / s->size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_freepointer",
          "args": [
            "s",
            "p"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "get_freepointer_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "276-287",
          "snippet": "static inline void *get_freepointer_safe(struct kmem_cache *s, void *object)\n{\n\tunsigned long freepointer_addr;\n\tvoid *p;\n\n\tif (!debug_pagealloc_enabled())\n\t\treturn get_freepointer(s, object);\n\n\tfreepointer_addr = (unsigned long)object + s->offset;\n\tprobe_kernel_read(&p, (void **)freepointer_addr, sizeof(p));\n\treturn freelist_ptr(s, p, freepointer_addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void *get_freepointer_safe(struct kmem_cache *s, void *object)\n{\n\tunsigned long freepointer_addr;\n\tvoid *p;\n\n\tif (!debug_pagealloc_enabled())\n\t\treturn get_freepointer(s, object);\n\n\tfreepointer_addr = (unsigned long)object + s->offset;\n\tprobe_kernel_read(&p, (void **)freepointer_addr, sizeof(p));\n\treturn freelist_ptr(s, p, freepointer_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "page_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "409-434",
          "snippet": "void *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void get_map(struct kmem_cache *s, struct page *page, unsigned long *map)\n{\n\tvoid *p;\n\tvoid *addr = page_address(page);\n\n\tfor (p = page->freelist; p; p = get_freepointer(s, p))\n\t\tset_bit(slab_index(p, s, addr), map);\n}"
  },
  {
    "function_name": "cmpxchg_double_slab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "395-434",
    "snippet": "static inline bool cmpxchg_double_slab(struct kmem_cache *s, struct page *page,\n\t\tvoid *freelist_old, unsigned long counters_old,\n\t\tvoid *freelist_new, unsigned long counters_new,\n\t\tconst char *n)\n{\n#if defined(CONFIG_HAVE_CMPXCHG_DOUBLE) && \\\n    defined(CONFIG_HAVE_ALIGNED_STRUCT_PAGE)\n\tif (s->flags & __CMPXCHG_DOUBLE) {\n\t\tif (cmpxchg_double(&page->freelist, &page->counters,\n\t\t\t\t   freelist_old, counters_old,\n\t\t\t\t   freelist_new, counters_new))\n\t\t\treturn true;\n\t} else\n#endif\n\t{\n\t\tunsigned long flags;\n\n\t\tlocal_irq_save(flags);\n\t\tslab_lock(page);\n\t\tif (page->freelist == freelist_old &&\n\t\t\t\t\tpage->counters == counters_old) {\n\t\t\tpage->freelist = freelist_new;\n\t\t\tpage->counters = counters_new;\n\t\t\tslab_unlock(page);\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn true;\n\t\t}\n\t\tslab_unlock(page);\n\t\tlocal_irq_restore(flags);\n\t}\n\n\tcpu_relax();\n\tstat(s, CMPXCHG_DOUBLE_FAIL);\n\n#ifdef SLUB_DEBUG_CMPXCHG\n\tpr_info(\"%s %s: cmpxchg double redo \", n, s->name);\n#endif\n\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define __CMPXCHG_DOUBLE\t((slab_flags_t __force)0x40000000U)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s %s: cmpxchg double redo \"",
            "n",
            "s->name"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "s",
            "CMPXCHG_DOUBLE_FAIL"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "slabinfo_show_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "5900-5902",
          "snippet": "void slabinfo_show_stats(struct seq_file *m, struct kmem_cache *s)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid slabinfo_show_stats(struct seq_file *m, struct kmem_cache *s)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_unlock",
          "args": [
            "page"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "slab_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "351-355",
          "snippet": "static __always_inline void slab_unlock(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\t__bit_spin_unlock(PG_locked, &page->flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic __always_inline void slab_unlock(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\t__bit_spin_unlock(PG_locked, &page->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_lock",
          "args": [
            "page"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "slab_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "345-349",
          "snippet": "static __always_inline void slab_lock(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tbit_spin_lock(PG_locked, &page->flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic __always_inline void slab_lock(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tbit_spin_lock(PG_locked, &page->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg_double",
          "args": [
            "&page->freelist",
            "&page->counters",
            "freelist_old",
            "counters_old",
            "freelist_new",
            "counters_new"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define __CMPXCHG_DOUBLE\t((slab_flags_t __force)0x40000000U)\n\nstatic inline bool cmpxchg_double_slab(struct kmem_cache *s, struct page *page,\n\t\tvoid *freelist_old, unsigned long counters_old,\n\t\tvoid *freelist_new, unsigned long counters_new,\n\t\tconst char *n)\n{\n#if defined(CONFIG_HAVE_CMPXCHG_DOUBLE) && \\\n    defined(CONFIG_HAVE_ALIGNED_STRUCT_PAGE)\n\tif (s->flags & __CMPXCHG_DOUBLE) {\n\t\tif (cmpxchg_double(&page->freelist, &page->counters,\n\t\t\t\t   freelist_old, counters_old,\n\t\t\t\t   freelist_new, counters_new))\n\t\t\treturn true;\n\t} else\n#endif\n\t{\n\t\tunsigned long flags;\n\n\t\tlocal_irq_save(flags);\n\t\tslab_lock(page);\n\t\tif (page->freelist == freelist_old &&\n\t\t\t\t\tpage->counters == counters_old) {\n\t\t\tpage->freelist = freelist_new;\n\t\t\tpage->counters = counters_new;\n\t\t\tslab_unlock(page);\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn true;\n\t\t}\n\t\tslab_unlock(page);\n\t\tlocal_irq_restore(flags);\n\t}\n\n\tcpu_relax();\n\tstat(s, CMPXCHG_DOUBLE_FAIL);\n\n#ifdef SLUB_DEBUG_CMPXCHG\n\tpr_info(\"%s %s: cmpxchg double redo \", n, s->name);\n#endif\n\n\treturn false;\n}"
  },
  {
    "function_name": "__cmpxchg_double_slab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "358-393",
    "snippet": "static inline bool __cmpxchg_double_slab(struct kmem_cache *s, struct page *page,\n\t\tvoid *freelist_old, unsigned long counters_old,\n\t\tvoid *freelist_new, unsigned long counters_new,\n\t\tconst char *n)\n{\n\tVM_BUG_ON(!irqs_disabled());\n#if defined(CONFIG_HAVE_CMPXCHG_DOUBLE) && \\\n    defined(CONFIG_HAVE_ALIGNED_STRUCT_PAGE)\n\tif (s->flags & __CMPXCHG_DOUBLE) {\n\t\tif (cmpxchg_double(&page->freelist, &page->counters,\n\t\t\t\t   freelist_old, counters_old,\n\t\t\t\t   freelist_new, counters_new))\n\t\t\treturn true;\n\t} else\n#endif\n\t{\n\t\tslab_lock(page);\n\t\tif (page->freelist == freelist_old &&\n\t\t\t\t\tpage->counters == counters_old) {\n\t\t\tpage->freelist = freelist_new;\n\t\t\tpage->counters = counters_new;\n\t\t\tslab_unlock(page);\n\t\t\treturn true;\n\t\t}\n\t\tslab_unlock(page);\n\t}\n\n\tcpu_relax();\n\tstat(s, CMPXCHG_DOUBLE_FAIL);\n\n#ifdef SLUB_DEBUG_CMPXCHG\n\tpr_info(\"%s %s: cmpxchg double redo \", n, s->name);\n#endif\n\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define __CMPXCHG_DOUBLE\t((slab_flags_t __force)0x40000000U)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s %s: cmpxchg double redo \"",
            "n",
            "s->name"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "s",
            "CMPXCHG_DOUBLE_FAIL"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "slabinfo_show_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "5900-5902",
          "snippet": "void slabinfo_show_stats(struct seq_file *m, struct kmem_cache *s)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid slabinfo_show_stats(struct seq_file *m, struct kmem_cache *s)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_unlock",
          "args": [
            "page"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "slab_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "351-355",
          "snippet": "static __always_inline void slab_unlock(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\t__bit_spin_unlock(PG_locked, &page->flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic __always_inline void slab_unlock(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\t__bit_spin_unlock(PG_locked, &page->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "slab_lock",
          "args": [
            "page"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "slab_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "345-349",
          "snippet": "static __always_inline void slab_lock(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tbit_spin_lock(PG_locked, &page->flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic __always_inline void slab_lock(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tbit_spin_lock(PG_locked, &page->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmpxchg_double",
          "args": [
            "&page->freelist",
            "&page->counters",
            "freelist_old",
            "counters_old",
            "freelist_new",
            "counters_new"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!irqs_disabled()"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define __CMPXCHG_DOUBLE\t((slab_flags_t __force)0x40000000U)\n\nstatic inline bool __cmpxchg_double_slab(struct kmem_cache *s, struct page *page,\n\t\tvoid *freelist_old, unsigned long counters_old,\n\t\tvoid *freelist_new, unsigned long counters_new,\n\t\tconst char *n)\n{\n\tVM_BUG_ON(!irqs_disabled());\n#if defined(CONFIG_HAVE_CMPXCHG_DOUBLE) && \\\n    defined(CONFIG_HAVE_ALIGNED_STRUCT_PAGE)\n\tif (s->flags & __CMPXCHG_DOUBLE) {\n\t\tif (cmpxchg_double(&page->freelist, &page->counters,\n\t\t\t\t   freelist_old, counters_old,\n\t\t\t\t   freelist_new, counters_new))\n\t\t\treturn true;\n\t} else\n#endif\n\t{\n\t\tslab_lock(page);\n\t\tif (page->freelist == freelist_old &&\n\t\t\t\t\tpage->counters == counters_old) {\n\t\t\tpage->freelist = freelist_new;\n\t\t\tpage->counters = counters_new;\n\t\t\tslab_unlock(page);\n\t\t\treturn true;\n\t\t}\n\t\tslab_unlock(page);\n\t}\n\n\tcpu_relax();\n\tstat(s, CMPXCHG_DOUBLE_FAIL);\n\n#ifdef SLUB_DEBUG_CMPXCHG\n\tpr_info(\"%s %s: cmpxchg double redo \", n, s->name);\n#endif\n\n\treturn false;\n}"
  },
  {
    "function_name": "slab_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "351-355",
    "snippet": "static __always_inline void slab_unlock(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\t__bit_spin_unlock(PG_locked, &page->flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bit_spin_unlock",
          "args": [
            "PG_locked",
            "&page->flags"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageTail(page)",
            "page"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTail",
          "args": [
            "page"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic __always_inline void slab_unlock(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\t__bit_spin_unlock(PG_locked, &page->flags);\n}"
  },
  {
    "function_name": "slab_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "345-349",
    "snippet": "static __always_inline void slab_lock(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tbit_spin_lock(PG_locked, &page->flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bit_spin_lock",
          "args": [
            "PG_locked",
            "&page->flags"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageTail(page)",
            "page"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTail",
          "args": [
            "page"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic __always_inline void slab_lock(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tbit_spin_lock(PG_locked, &page->flags);\n}"
  },
  {
    "function_name": "oo_objects",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "337-340",
    "snippet": "static inline unsigned int oo_objects(struct kmem_cache_order_objects x)\n{\n\treturn x.x & OO_MASK;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define OO_MASK\t\t((1 << OO_SHIFT) - 1)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define OO_MASK\t\t((1 << OO_SHIFT) - 1)\n\nstatic inline unsigned int oo_objects(struct kmem_cache_order_objects x)\n{\n\treturn x.x & OO_MASK;\n}"
  },
  {
    "function_name": "oo_order",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "332-335",
    "snippet": "static inline unsigned int oo_order(struct kmem_cache_order_objects x)\n{\n\treturn x.x >> OO_SHIFT;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define OO_SHIFT\t16"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define OO_SHIFT\t16\n\nstatic inline unsigned int oo_order(struct kmem_cache_order_objects x)\n{\n\treturn x.x >> OO_SHIFT;\n}"
  },
  {
    "function_name": "oo_make",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "322-330",
    "snippet": "static inline struct kmem_cache_order_objects oo_make(unsigned int order,\n\t\tunsigned int size)\n{\n\tstruct kmem_cache_order_objects x = {\n\t\t(order << OO_SHIFT) + order_objects(order, size)\n\t};\n\n\treturn x;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define OO_SHIFT\t16"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "order_objects",
          "args": [
            "order",
            "size"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "order_objects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "317-320",
          "snippet": "static inline unsigned int order_objects(unsigned int order, unsigned int size)\n{\n\treturn ((unsigned int)PAGE_SIZE << order) / size;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline unsigned int order_objects(unsigned int order, unsigned int size)\n{\n\treturn ((unsigned int)PAGE_SIZE << order) / size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\n#define OO_SHIFT\t16\n\nstatic inline struct kmem_cache_order_objects oo_make(unsigned int order,\n\t\tunsigned int size)\n{\n\tstruct kmem_cache_order_objects x = {\n\t\t(order << OO_SHIFT) + order_objects(order, size)\n\t};\n\n\treturn x;\n}"
  },
  {
    "function_name": "order_objects",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "317-320",
    "snippet": "static inline unsigned int order_objects(unsigned int order, unsigned int size)\n{\n\treturn ((unsigned int)PAGE_SIZE << order) / size;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline unsigned int order_objects(unsigned int order, unsigned int size)\n{\n\treturn ((unsigned int)PAGE_SIZE << order) / size;\n}"
  },
  {
    "function_name": "slab_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "312-315",
    "snippet": "static inline unsigned int slab_index(void *p, struct kmem_cache *s, void *addr)\n{\n\treturn (p - addr) / s->size;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline unsigned int slab_index(void *p, struct kmem_cache *s, void *addr)\n{\n\treturn (p - addr) / s->size;\n}"
  },
  {
    "function_name": "set_freepointer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "289-298",
    "snippet": "static inline void set_freepointer(struct kmem_cache *s, void *object, void *fp)\n{\n\tunsigned long freeptr_addr = (unsigned long)object + s->offset;\n\n#ifdef CONFIG_SLAB_FREELIST_HARDENED\n\tBUG_ON(object == fp); /* naive detection of double free or corruption */\n#endif\n\n\t*(void **)freeptr_addr = freelist_ptr(s, fp, freeptr_addr);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "freelist_ptr",
          "args": [
            "s",
            "fp",
            "freeptr_addr"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "freelist_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "248-256",
          "snippet": "static inline void *freelist_ptr(const struct kmem_cache *s, void *ptr,\n\t\t\t\t unsigned long ptr_addr)\n{\n#ifdef CONFIG_SLAB_FREELIST_HARDENED\n\treturn (void *)((unsigned long)ptr ^ s->random ^ ptr_addr);\n#else\n\treturn ptr;\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void *freelist_ptr(const struct kmem_cache *s, void *ptr,\n\t\t\t\t unsigned long ptr_addr)\n{\n#ifdef CONFIG_SLAB_FREELIST_HARDENED\n\treturn (void *)((unsigned long)ptr ^ s->random ^ ptr_addr);\n#else\n\treturn ptr;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "object == fp"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void set_freepointer(struct kmem_cache *s, void *object, void *fp)\n{\n\tunsigned long freeptr_addr = (unsigned long)object + s->offset;\n\n#ifdef CONFIG_SLAB_FREELIST_HARDENED\n\tBUG_ON(object == fp); /* naive detection of double free or corruption */\n#endif\n\n\t*(void **)freeptr_addr = freelist_ptr(s, fp, freeptr_addr);\n}"
  },
  {
    "function_name": "get_freepointer_safe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "276-287",
    "snippet": "static inline void *get_freepointer_safe(struct kmem_cache *s, void *object)\n{\n\tunsigned long freepointer_addr;\n\tvoid *p;\n\n\tif (!debug_pagealloc_enabled())\n\t\treturn get_freepointer(s, object);\n\n\tfreepointer_addr = (unsigned long)object + s->offset;\n\tprobe_kernel_read(&p, (void **)freepointer_addr, sizeof(p));\n\treturn freelist_ptr(s, p, freepointer_addr);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "freelist_ptr",
          "args": [
            "s",
            "p",
            "freepointer_addr"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "freelist_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "248-256",
          "snippet": "static inline void *freelist_ptr(const struct kmem_cache *s, void *ptr,\n\t\t\t\t unsigned long ptr_addr)\n{\n#ifdef CONFIG_SLAB_FREELIST_HARDENED\n\treturn (void *)((unsigned long)ptr ^ s->random ^ ptr_addr);\n#else\n\treturn ptr;\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void *freelist_ptr(const struct kmem_cache *s, void *ptr,\n\t\t\t\t unsigned long ptr_addr)\n{\n#ifdef CONFIG_SLAB_FREELIST_HARDENED\n\treturn (void *)((unsigned long)ptr ^ s->random ^ ptr_addr);\n#else\n\treturn ptr;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "probe_kernel_read",
          "args": [
            "&p",
            "(void **)freepointer_addr",
            "sizeof(p)"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "__probe_kernel_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/maccess.c",
          "lines": "26-41",
          "snippet": "long __probe_kernel_read(void *dst, const void *src, size_t size)\n{\n\tlong ret;\n\tmm_segment_t old_fs = get_fs();\n\n\tset_fs(KERNEL_DS);\n\tpagefault_disable();\n\tcurrent->kernel_uaccess_faults_ok++;\n\tret = __copy_from_user_inatomic(dst,\n\t\t\t(__force const void __user *)src, size);\n\tcurrent->kernel_uaccess_faults_ok--;\n\tpagefault_enable();\n\tset_fs(old_fs);\n\n\treturn ret ? -EFAULT : 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long __weak probe_kernel_read(void *dst, const void *src, size_t size)\n    __attribute__((alias(\"__probe_kernel_read\")));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nlong __weak probe_kernel_read(void *dst, const void *src, size_t size)\n    __attribute__((alias(\"__probe_kernel_read\")));\n\nlong __probe_kernel_read(void *dst, const void *src, size_t size)\n{\n\tlong ret;\n\tmm_segment_t old_fs = get_fs();\n\n\tset_fs(KERNEL_DS);\n\tpagefault_disable();\n\tcurrent->kernel_uaccess_faults_ok++;\n\tret = __copy_from_user_inatomic(dst,\n\t\t\t(__force const void __user *)src, size);\n\tcurrent->kernel_uaccess_faults_ok--;\n\tpagefault_enable();\n\tset_fs(old_fs);\n\n\treturn ret ? -EFAULT : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_freepointer",
          "args": [
            "s",
            "object"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "get_freepointer_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "276-287",
          "snippet": "static inline void *get_freepointer_safe(struct kmem_cache *s, void *object)\n{\n\tunsigned long freepointer_addr;\n\tvoid *p;\n\n\tif (!debug_pagealloc_enabled())\n\t\treturn get_freepointer(s, object);\n\n\tfreepointer_addr = (unsigned long)object + s->offset;\n\tprobe_kernel_read(&p, (void **)freepointer_addr, sizeof(p));\n\treturn freelist_ptr(s, p, freepointer_addr);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "debug_pagealloc_enabled",
          "args": [],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void *get_freepointer_safe(struct kmem_cache *s, void *object)\n{\n\tunsigned long freepointer_addr;\n\tvoid *p;\n\n\tif (!debug_pagealloc_enabled())\n\t\treturn get_freepointer(s, object);\n\n\tfreepointer_addr = (unsigned long)object + s->offset;\n\tprobe_kernel_read(&p, (void **)freepointer_addr, sizeof(p));\n\treturn freelist_ptr(s, p, freepointer_addr);\n}"
  },
  {
    "function_name": "prefetch_freepointer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "271-274",
    "snippet": "static void prefetch_freepointer(const struct kmem_cache *s, void *object)\n{\n\tprefetch(object + s->offset);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "prefetch",
          "args": [
            "object + s->offset"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "prefetch_buddy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1067-1074",
          "snippet": "static inline void prefetch_buddy(struct page *page)\n{\n\tunsigned long pfn = page_to_pfn(page);\n\tunsigned long buddy_pfn = __find_buddy_pfn(pfn, 0);\n\tstruct page *buddy = page + (buddy_pfn - pfn);\n\n\tprefetch(buddy);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline void prefetch_buddy(struct page *page)\n{\n\tunsigned long pfn = page_to_pfn(page);\n\tunsigned long buddy_pfn = __find_buddy_pfn(pfn, 0);\n\tstruct page *buddy = page + (buddy_pfn - pfn);\n\n\tprefetch(buddy);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic void prefetch_freepointer(const struct kmem_cache *s, void *object)\n{\n\tprefetch(object + s->offset);\n}"
  },
  {
    "function_name": "get_freepointer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "266-269",
    "snippet": "static inline void *get_freepointer(struct kmem_cache *s, void *object)\n{\n\treturn freelist_dereference(s, object + s->offset);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "freelist_dereference",
          "args": [
            "s",
            "object + s->offset"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "freelist_dereference",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "259-264",
          "snippet": "static inline void *freelist_dereference(const struct kmem_cache *s,\n\t\t\t\t\t void *ptr_addr)\n{\n\treturn freelist_ptr(s, (void *)*(unsigned long *)(ptr_addr),\n\t\t\t    (unsigned long)ptr_addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void *freelist_dereference(const struct kmem_cache *s,\n\t\t\t\t\t void *ptr_addr)\n{\n\treturn freelist_ptr(s, (void *)*(unsigned long *)(ptr_addr),\n\t\t\t    (unsigned long)ptr_addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void *get_freepointer(struct kmem_cache *s, void *object)\n{\n\treturn freelist_dereference(s, object + s->offset);\n}"
  },
  {
    "function_name": "freelist_dereference",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "259-264",
    "snippet": "static inline void *freelist_dereference(const struct kmem_cache *s,\n\t\t\t\t\t void *ptr_addr)\n{\n\treturn freelist_ptr(s, (void *)*(unsigned long *)(ptr_addr),\n\t\t\t    (unsigned long)ptr_addr);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "freelist_ptr",
          "args": [
            "s",
            "(void *)*(unsigned long *)(ptr_addr)",
            "(unsigned long)ptr_addr"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "freelist_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "248-256",
          "snippet": "static inline void *freelist_ptr(const struct kmem_cache *s, void *ptr,\n\t\t\t\t unsigned long ptr_addr)\n{\n#ifdef CONFIG_SLAB_FREELIST_HARDENED\n\treturn (void *)((unsigned long)ptr ^ s->random ^ ptr_addr);\n#else\n\treturn ptr;\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void *freelist_ptr(const struct kmem_cache *s, void *ptr,\n\t\t\t\t unsigned long ptr_addr)\n{\n#ifdef CONFIG_SLAB_FREELIST_HARDENED\n\treturn (void *)((unsigned long)ptr ^ s->random ^ ptr_addr);\n#else\n\treturn ptr;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void *freelist_dereference(const struct kmem_cache *s,\n\t\t\t\t\t void *ptr_addr)\n{\n\treturn freelist_ptr(s, (void *)*(unsigned long *)(ptr_addr),\n\t\t\t    (unsigned long)ptr_addr);\n}"
  },
  {
    "function_name": "freelist_ptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "248-256",
    "snippet": "static inline void *freelist_ptr(const struct kmem_cache *s, void *ptr,\n\t\t\t\t unsigned long ptr_addr)\n{\n#ifdef CONFIG_SLAB_FREELIST_HARDENED\n\treturn (void *)((unsigned long)ptr ^ s->random ^ ptr_addr);\n#else\n\treturn ptr;\n#endif\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void *freelist_ptr(const struct kmem_cache *s, void *ptr,\n\t\t\t\t unsigned long ptr_addr)\n{\n#ifdef CONFIG_SLAB_FREELIST_HARDENED\n\treturn (void *)((unsigned long)ptr ^ s->random ^ ptr_addr);\n#else\n\treturn ptr;\n#endif\n}"
  },
  {
    "function_name": "stat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "228-237",
    "snippet": "static inline void stat(const struct kmem_cache *s, enum stat_item si)\n{\n#ifdef CONFIG_SLUB_STATS\n\t/*\n\t * The rmw is racy on a preemptible kernel but this is acceptable, so\n\t * avoid this_cpu_add()'s irq-disable overhead.\n\t */\n\traw_cpu_inc(s->cpu_slab->stat[si]);\n#endif\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_cpu_inc",
          "args": [
            "s->cpu_slab->stat[si]"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void stat(const struct kmem_cache *s, enum stat_item si)\n{\n#ifdef CONFIG_SLUB_STATS\n\t/*\n\t * The rmw is racy on a preemptible kernel but this is acceptable, so\n\t * avoid this_cpu_add()'s irq-disable overhead.\n\t */\n\traw_cpu_inc(s->cpu_slab->stat[si]);\n#endif\n}"
  },
  {
    "function_name": "sysfs_slab_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "225-225",
    "snippet": "static inline void sysfs_slab_remove(struct kmem_cache *s) { }",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void sysfs_slab_remove(struct kmem_cache *s) { }"
  },
  {
    "function_name": "memcg_propagate_slab_attrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "224-224",
    "snippet": "static inline void memcg_propagate_slab_attrs(struct kmem_cache *s) { }",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void memcg_propagate_slab_attrs(struct kmem_cache *s) { }"
  },
  {
    "function_name": "sysfs_slab_alias",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "222-223",
    "snippet": "static inline int sysfs_slab_alias(struct kmem_cache *s, const char *p)\n\t\t\t\t\t\t\t{ return 0; }",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline int sysfs_slab_alias(struct kmem_cache *s, const char *p)\n\t\t\t\t\t\t\t{ return 0; }"
  },
  {
    "function_name": "sysfs_slab_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "221-221",
    "snippet": "static inline int sysfs_slab_add(struct kmem_cache *s) { return 0; }",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline int sysfs_slab_add(struct kmem_cache *s) { return 0; }"
  },
  {
    "function_name": "kmem_cache_has_cpu_partial",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "135-142",
    "snippet": "static inline bool kmem_cache_has_cpu_partial(struct kmem_cache *s)\n{\n#ifdef CONFIG_SLUB_CPU_PARTIAL\n\treturn !kmem_cache_debug(s);\n#else\n\treturn false;\n#endif\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_debug",
          "args": [
            "s"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "118-125",
          "snippet": "static inline int kmem_cache_debug(struct kmem_cache *s)\n{\n#ifdef CONFIG_SLUB_DEBUG\n\treturn unlikely(s->flags & SLAB_DEBUG_FLAGS);\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline int kmem_cache_debug(struct kmem_cache *s)\n{\n#ifdef CONFIG_SLUB_DEBUG\n\treturn unlikely(s->flags & SLAB_DEBUG_FLAGS);\n#else\n\treturn 0;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline bool kmem_cache_has_cpu_partial(struct kmem_cache *s)\n{\n#ifdef CONFIG_SLUB_CPU_PARTIAL\n\treturn !kmem_cache_debug(s);\n#else\n\treturn false;\n#endif\n}"
  },
  {
    "function_name": "fixup_red_left",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "127-133",
    "snippet": "void *fixup_red_left(struct kmem_cache *s, void *p)\n{\n\tif (kmem_cache_debug(s) && s->flags & SLAB_RED_ZONE)\n\t\tp += s->red_left_pad;\n\n\treturn p;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_debug",
          "args": [
            "s"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "118-125",
          "snippet": "static inline int kmem_cache_debug(struct kmem_cache *s)\n{\n#ifdef CONFIG_SLUB_DEBUG\n\treturn unlikely(s->flags & SLAB_DEBUG_FLAGS);\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline int kmem_cache_debug(struct kmem_cache *s)\n{\n#ifdef CONFIG_SLUB_DEBUG\n\treturn unlikely(s->flags & SLAB_DEBUG_FLAGS);\n#else\n\treturn 0;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid *fixup_red_left(struct kmem_cache *s, void *p)\n{\n\tif (kmem_cache_debug(s) && s->flags & SLAB_RED_ZONE)\n\t\tp += s->red_left_pad;\n\n\treturn p;\n}"
  },
  {
    "function_name": "kmem_cache_debug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
    "lines": "118-125",
    "snippet": "static inline int kmem_cache_debug(struct kmem_cache *s)\n{\n#ifdef CONFIG_SLUB_DEBUG\n\treturn unlikely(s->flags & SLAB_DEBUG_FLAGS);\n#else\n\treturn 0;\n#endif\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/random.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/math64.h>",
      "#include <linux/memory.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/ctype.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/kasan.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include \"slab.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "s->flags & SLAB_DEBUG_FLAGS"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline int kmem_cache_debug(struct kmem_cache *s)\n{\n#ifdef CONFIG_SLUB_DEBUG\n\treturn unlikely(s->flags & SLAB_DEBUG_FLAGS);\n#else\n\treturn 0;\n#endif\n}"
  }
]