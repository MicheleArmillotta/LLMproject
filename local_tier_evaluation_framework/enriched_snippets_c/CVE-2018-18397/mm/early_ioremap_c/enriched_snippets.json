[
  {
    "function_name": "early_memunmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/early_ioremap.c",
    "lines": "300-303",
    "snippet": "void __init early_memunmap(void *addr, unsigned long size)\n{\n\tearly_iounmap((__force void __iomem *)addr, size);\n}",
    "includes": [
      "#include <asm/early_ioremap.h>",
      "#include <asm/fixmap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/early_ioremap.h>\n#include <asm/fixmap.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nvoid __init early_memunmap(void *addr, unsigned long size)\n{\n\tearly_iounmap((__force void __iomem *)addr, size);\n}"
  },
  {
    "function_name": "early_iounmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/early_ioremap.c",
    "lines": "293-295",
    "snippet": "void __init early_iounmap(void __iomem *addr, unsigned long size)\n{\n}",
    "includes": [
      "#include <asm/early_ioremap.h>",
      "#include <asm/fixmap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/early_ioremap.h>\n#include <asm/fixmap.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nvoid __init early_iounmap(void __iomem *addr, unsigned long size)\n{\n}"
  },
  {
    "function_name": "early_memremap_ro",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/early_ioremap.c",
    "lines": "287-291",
    "snippet": "void __init *\nearly_memremap_ro(resource_size_t phys_addr, unsigned long size)\n{\n\treturn (void *)phys_addr;\n}",
    "includes": [
      "#include <asm/early_ioremap.h>",
      "#include <asm/fixmap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/early_ioremap.h>\n#include <asm/fixmap.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nvoid __init *\nearly_memremap_ro(resource_size_t phys_addr, unsigned long size)\n{\n\treturn (void *)phys_addr;\n}"
  },
  {
    "function_name": "early_memremap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/early_ioremap.c",
    "lines": "282-286",
    "snippet": "void __init *\nearly_memremap(resource_size_t phys_addr, unsigned long size)\n{\n\treturn (void *)phys_addr;\n}",
    "includes": [
      "#include <asm/early_ioremap.h>",
      "#include <asm/fixmap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/early_ioremap.h>\n#include <asm/fixmap.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nvoid __init *\nearly_memremap(resource_size_t phys_addr, unsigned long size)\n{\n\treturn (void *)phys_addr;\n}"
  },
  {
    "function_name": "early_ioremap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/early_ioremap.c",
    "lines": "275-279",
    "snippet": "__iomem *\nearly_ioremap(resource_size_t phys_addr, unsigned long size)\n{\n\treturn (__force void __iomem *)phys_addr;\n}",
    "includes": [
      "#include <asm/early_ioremap.h>",
      "#include <asm/fixmap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/early_ioremap.h>\n#include <asm/fixmap.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\n__iomem *\nearly_ioremap(resource_size_t phys_addr, unsigned long size)\n{\n\treturn (__force void __iomem *)phys_addr;\n}"
  },
  {
    "function_name": "copy_from_early_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/early_ioremap.c",
    "lines": "254-271",
    "snippet": "void __init copy_from_early_mem(void *dest, phys_addr_t src, unsigned long size)\n{\n\tunsigned long slop, clen;\n\tchar *p;\n\n\twhile (size) {\n\t\tslop = offset_in_page(src);\n\t\tclen = size;\n\t\tif (clen > MAX_MAP_CHUNK - slop)\n\t\t\tclen = MAX_MAP_CHUNK - slop;\n\t\tp = early_memremap(src & PAGE_MASK, clen + slop);\n\t\tmemcpy(dest, p + slop, clen);\n\t\tearly_memunmap(p, clen + slop);\n\t\tdest += clen;\n\t\tsrc += clen;\n\t\tsize -= clen;\n\t}\n}",
    "includes": [
      "#include <asm/early_ioremap.h>",
      "#include <asm/fixmap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define MAX_MAP_CHUNK\t(NR_FIX_BTMAPS << PAGE_SHIFT)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "early_memunmap",
          "args": [
            "p",
            "clen + slop"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "early_memunmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/early_ioremap.c",
          "lines": "300-303",
          "snippet": "void __init early_memunmap(void *addr, unsigned long size)\n{\n\tearly_iounmap((__force void __iomem *)addr, size);\n}",
          "includes": [
            "#include <asm/early_ioremap.h>",
            "#include <asm/fixmap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/early_ioremap.h>\n#include <asm/fixmap.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nvoid __init early_memunmap(void *addr, unsigned long size)\n{\n\tearly_iounmap((__force void __iomem *)addr, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dest",
            "p + slop",
            "clen"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "300-306",
          "snippet": "void *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "early_memremap",
          "args": [
            "src & PAGE_MASK",
            "clen + slop"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "early_memremap_ro",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/early_ioremap.c",
          "lines": "287-291",
          "snippet": "void __init *\nearly_memremap_ro(resource_size_t phys_addr, unsigned long size)\n{\n\treturn (void *)phys_addr;\n}",
          "includes": [
            "#include <asm/early_ioremap.h>",
            "#include <asm/fixmap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/early_ioremap.h>\n#include <asm/fixmap.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nvoid __init *\nearly_memremap_ro(resource_size_t phys_addr, unsigned long size)\n{\n\treturn (void *)phys_addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "src"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/early_ioremap.h>\n#include <asm/fixmap.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\n#define MAX_MAP_CHUNK\t(NR_FIX_BTMAPS << PAGE_SHIFT)\n\nvoid __init copy_from_early_mem(void *dest, phys_addr_t src, unsigned long size)\n{\n\tunsigned long slop, clen;\n\tchar *p;\n\n\twhile (size) {\n\t\tslop = offset_in_page(src);\n\t\tclen = size;\n\t\tif (clen > MAX_MAP_CHUNK - slop)\n\t\t\tclen = MAX_MAP_CHUNK - slop;\n\t\tp = early_memremap(src & PAGE_MASK, clen + slop);\n\t\tmemcpy(dest, p + slop, clen);\n\t\tearly_memunmap(p, clen + slop);\n\t\tdest += clen;\n\t\tsrc += clen;\n\t\tsize -= clen;\n\t}\n}"
  },
  {
    "function_name": "early_memremap_prot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/early_ioremap.c",
    "lines": "243-249",
    "snippet": "void __init *\nearly_memremap_prot(resource_size_t phys_addr, unsigned long size,\n\t\t    unsigned long prot_val)\n{\n\treturn (__force void *)__early_ioremap(phys_addr, size,\n\t\t\t\t\t       __pgprot(prot_val));\n}",
    "includes": [
      "#include <asm/early_ioremap.h>",
      "#include <asm/fixmap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__early_ioremap",
          "args": [
            "phys_addr",
            "size",
            "__pgprot(prot_val)"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "__early_ioremap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/early_ioremap.c",
          "lines": "105-166",
          "snippet": "__iomem *\n__early_ioremap(resource_size_t phys_addr, unsigned long size, pgprot_t prot)\n{\n\tunsigned long offset;\n\tresource_size_t last_addr;\n\tunsigned int nrpages;\n\tenum fixed_addresses idx;\n\tint i, slot;\n\n\tWARN_ON(system_state >= SYSTEM_RUNNING);\n\n\tslot = -1;\n\tfor (i = 0; i < FIX_BTMAPS_SLOTS; i++) {\n\t\tif (!prev_map[i]) {\n\t\t\tslot = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (WARN(slot < 0, \"%s(%08llx, %08lx) not found slot\\n\",\n\t\t __func__, (u64)phys_addr, size))\n\t\treturn NULL;\n\n\t/* Don't allow wraparound or zero size */\n\tlast_addr = phys_addr + size - 1;\n\tif (WARN_ON(!size || last_addr < phys_addr))\n\t\treturn NULL;\n\n\tprev_size[slot] = size;\n\t/*\n\t * Mappings have to be page-aligned\n\t */\n\toffset = offset_in_page(phys_addr);\n\tphys_addr &= PAGE_MASK;\n\tsize = PAGE_ALIGN(last_addr + 1) - phys_addr;\n\n\t/*\n\t * Mappings have to fit in the FIX_BTMAP area.\n\t */\n\tnrpages = size >> PAGE_SHIFT;\n\tif (WARN_ON(nrpages > NR_FIX_BTMAPS))\n\t\treturn NULL;\n\n\t/*\n\t * Ok, go for it..\n\t */\n\tidx = FIX_BTMAP_BEGIN - NR_FIX_BTMAPS*slot;\n\twhile (nrpages > 0) {\n\t\tif (after_paging_init)\n\t\t\t__late_set_fixmap(idx, phys_addr, prot);\n\t\telse\n\t\t\t__early_set_fixmap(idx, phys_addr, prot);\n\t\tphys_addr += PAGE_SIZE;\n\t\t--idx;\n\t\t--nrpages;\n\t}\n\tWARN(early_ioremap_debug, \"%s(%08llx, %08lx) [%d] => %08lx + %08lx\\n\",\n\t     __func__, (u64)phys_addr, size, slot, offset, slot_virt[slot]);\n\n\tprev_map[slot] = (void __iomem *)(offset + slot_virt[slot]);\n\treturn prev_map[slot];\n}",
          "includes": [
            "#include <asm/early_ioremap.h>",
            "#include <asm/fixmap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/early_ioremap.h>\n#include <asm/fixmap.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\n__iomem *\n__early_ioremap(resource_size_t phys_addr, unsigned long size, pgprot_t prot)\n{\n\tunsigned long offset;\n\tresource_size_t last_addr;\n\tunsigned int nrpages;\n\tenum fixed_addresses idx;\n\tint i, slot;\n\n\tWARN_ON(system_state >= SYSTEM_RUNNING);\n\n\tslot = -1;\n\tfor (i = 0; i < FIX_BTMAPS_SLOTS; i++) {\n\t\tif (!prev_map[i]) {\n\t\t\tslot = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (WARN(slot < 0, \"%s(%08llx, %08lx) not found slot\\n\",\n\t\t __func__, (u64)phys_addr, size))\n\t\treturn NULL;\n\n\t/* Don't allow wraparound or zero size */\n\tlast_addr = phys_addr + size - 1;\n\tif (WARN_ON(!size || last_addr < phys_addr))\n\t\treturn NULL;\n\n\tprev_size[slot] = size;\n\t/*\n\t * Mappings have to be page-aligned\n\t */\n\toffset = offset_in_page(phys_addr);\n\tphys_addr &= PAGE_MASK;\n\tsize = PAGE_ALIGN(last_addr + 1) - phys_addr;\n\n\t/*\n\t * Mappings have to fit in the FIX_BTMAP area.\n\t */\n\tnrpages = size >> PAGE_SHIFT;\n\tif (WARN_ON(nrpages > NR_FIX_BTMAPS))\n\t\treturn NULL;\n\n\t/*\n\t * Ok, go for it..\n\t */\n\tidx = FIX_BTMAP_BEGIN - NR_FIX_BTMAPS*slot;\n\twhile (nrpages > 0) {\n\t\tif (after_paging_init)\n\t\t\t__late_set_fixmap(idx, phys_addr, prot);\n\t\telse\n\t\t\t__early_set_fixmap(idx, phys_addr, prot);\n\t\tphys_addr += PAGE_SIZE;\n\t\t--idx;\n\t\t--nrpages;\n\t}\n\tWARN(early_ioremap_debug, \"%s(%08llx, %08lx) [%d] => %08lx + %08lx\\n\",\n\t     __func__, (u64)phys_addr, size, slot, offset, slot_virt[slot]);\n\n\tprev_map[slot] = (void __iomem *)(offset + slot_virt[slot]);\n\treturn prev_map[slot];\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pgprot",
          "args": [
            "prot_val"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/early_ioremap.h>\n#include <asm/fixmap.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nvoid __init *\nearly_memremap_prot(resource_size_t phys_addr, unsigned long size,\n\t\t    unsigned long prot_val)\n{\n\treturn (__force void *)__early_ioremap(phys_addr, size,\n\t\t\t\t\t       __pgprot(prot_val));\n}"
  },
  {
    "function_name": "early_memremap_ro",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/early_ioremap.c",
    "lines": "232-239",
    "snippet": "void __init *\nearly_memremap_ro(resource_size_t phys_addr, unsigned long size)\n{\n\tpgprot_t prot = early_memremap_pgprot_adjust(phys_addr, size,\n\t\t\t\t\t\t     FIXMAP_PAGE_RO);\n\n\treturn (__force void *)__early_ioremap(phys_addr, size, prot);\n}",
    "includes": [
      "#include <asm/early_ioremap.h>",
      "#include <asm/fixmap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__early_ioremap",
          "args": [
            "phys_addr",
            "size",
            "prot"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "__early_ioremap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/early_ioremap.c",
          "lines": "105-166",
          "snippet": "__iomem *\n__early_ioremap(resource_size_t phys_addr, unsigned long size, pgprot_t prot)\n{\n\tunsigned long offset;\n\tresource_size_t last_addr;\n\tunsigned int nrpages;\n\tenum fixed_addresses idx;\n\tint i, slot;\n\n\tWARN_ON(system_state >= SYSTEM_RUNNING);\n\n\tslot = -1;\n\tfor (i = 0; i < FIX_BTMAPS_SLOTS; i++) {\n\t\tif (!prev_map[i]) {\n\t\t\tslot = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (WARN(slot < 0, \"%s(%08llx, %08lx) not found slot\\n\",\n\t\t __func__, (u64)phys_addr, size))\n\t\treturn NULL;\n\n\t/* Don't allow wraparound or zero size */\n\tlast_addr = phys_addr + size - 1;\n\tif (WARN_ON(!size || last_addr < phys_addr))\n\t\treturn NULL;\n\n\tprev_size[slot] = size;\n\t/*\n\t * Mappings have to be page-aligned\n\t */\n\toffset = offset_in_page(phys_addr);\n\tphys_addr &= PAGE_MASK;\n\tsize = PAGE_ALIGN(last_addr + 1) - phys_addr;\n\n\t/*\n\t * Mappings have to fit in the FIX_BTMAP area.\n\t */\n\tnrpages = size >> PAGE_SHIFT;\n\tif (WARN_ON(nrpages > NR_FIX_BTMAPS))\n\t\treturn NULL;\n\n\t/*\n\t * Ok, go for it..\n\t */\n\tidx = FIX_BTMAP_BEGIN - NR_FIX_BTMAPS*slot;\n\twhile (nrpages > 0) {\n\t\tif (after_paging_init)\n\t\t\t__late_set_fixmap(idx, phys_addr, prot);\n\t\telse\n\t\t\t__early_set_fixmap(idx, phys_addr, prot);\n\t\tphys_addr += PAGE_SIZE;\n\t\t--idx;\n\t\t--nrpages;\n\t}\n\tWARN(early_ioremap_debug, \"%s(%08llx, %08lx) [%d] => %08lx + %08lx\\n\",\n\t     __func__, (u64)phys_addr, size, slot, offset, slot_virt[slot]);\n\n\tprev_map[slot] = (void __iomem *)(offset + slot_virt[slot]);\n\treturn prev_map[slot];\n}",
          "includes": [
            "#include <asm/early_ioremap.h>",
            "#include <asm/fixmap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/early_ioremap.h>\n#include <asm/fixmap.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\n__iomem *\n__early_ioremap(resource_size_t phys_addr, unsigned long size, pgprot_t prot)\n{\n\tunsigned long offset;\n\tresource_size_t last_addr;\n\tunsigned int nrpages;\n\tenum fixed_addresses idx;\n\tint i, slot;\n\n\tWARN_ON(system_state >= SYSTEM_RUNNING);\n\n\tslot = -1;\n\tfor (i = 0; i < FIX_BTMAPS_SLOTS; i++) {\n\t\tif (!prev_map[i]) {\n\t\t\tslot = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (WARN(slot < 0, \"%s(%08llx, %08lx) not found slot\\n\",\n\t\t __func__, (u64)phys_addr, size))\n\t\treturn NULL;\n\n\t/* Don't allow wraparound or zero size */\n\tlast_addr = phys_addr + size - 1;\n\tif (WARN_ON(!size || last_addr < phys_addr))\n\t\treturn NULL;\n\n\tprev_size[slot] = size;\n\t/*\n\t * Mappings have to be page-aligned\n\t */\n\toffset = offset_in_page(phys_addr);\n\tphys_addr &= PAGE_MASK;\n\tsize = PAGE_ALIGN(last_addr + 1) - phys_addr;\n\n\t/*\n\t * Mappings have to fit in the FIX_BTMAP area.\n\t */\n\tnrpages = size >> PAGE_SHIFT;\n\tif (WARN_ON(nrpages > NR_FIX_BTMAPS))\n\t\treturn NULL;\n\n\t/*\n\t * Ok, go for it..\n\t */\n\tidx = FIX_BTMAP_BEGIN - NR_FIX_BTMAPS*slot;\n\twhile (nrpages > 0) {\n\t\tif (after_paging_init)\n\t\t\t__late_set_fixmap(idx, phys_addr, prot);\n\t\telse\n\t\t\t__early_set_fixmap(idx, phys_addr, prot);\n\t\tphys_addr += PAGE_SIZE;\n\t\t--idx;\n\t\t--nrpages;\n\t}\n\tWARN(early_ioremap_debug, \"%s(%08llx, %08lx) [%d] => %08lx + %08lx\\n\",\n\t     __func__, (u64)phys_addr, size, slot, offset, slot_virt[slot]);\n\n\tprev_map[slot] = (void __iomem *)(offset + slot_virt[slot]);\n\treturn prev_map[slot];\n}"
        }
      },
      {
        "call_info": {
          "callee": "early_memremap_pgprot_adjust",
          "args": [
            "phys_addr",
            "size",
            "FIXMAP_PAGE_RO"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "early_memremap_pgprot_adjust",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/early_ioremap.c",
          "lines": "34-39",
          "snippet": "__weak early_memremap_pgprot_adjust(resource_size_t phys_addr,\n\t\t\t\t\t\t    unsigned long size,\n\t\t\t\t\t\t    pgprot_t prot)\n{\n\treturn prot;\n}",
          "includes": [
            "#include <asm/early_ioremap.h>",
            "#include <asm/fixmap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/early_ioremap.h>\n#include <asm/fixmap.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\n__weak early_memremap_pgprot_adjust(resource_size_t phys_addr,\n\t\t\t\t\t\t    unsigned long size,\n\t\t\t\t\t\t    pgprot_t prot)\n{\n\treturn prot;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/early_ioremap.h>\n#include <asm/fixmap.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nvoid __init *\nearly_memremap_ro(resource_size_t phys_addr, unsigned long size)\n{\n\tpgprot_t prot = early_memremap_pgprot_adjust(phys_addr, size,\n\t\t\t\t\t\t     FIXMAP_PAGE_RO);\n\n\treturn (__force void *)__early_ioremap(phys_addr, size, prot);\n}"
  },
  {
    "function_name": "early_memremap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/early_ioremap.c",
    "lines": "223-230",
    "snippet": "void __init *\nearly_memremap(resource_size_t phys_addr, unsigned long size)\n{\n\tpgprot_t prot = early_memremap_pgprot_adjust(phys_addr, size,\n\t\t\t\t\t\t     FIXMAP_PAGE_NORMAL);\n\n\treturn (__force void *)__early_ioremap(phys_addr, size, prot);\n}",
    "includes": [
      "#include <asm/early_ioremap.h>",
      "#include <asm/fixmap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__early_ioremap",
          "args": [
            "phys_addr",
            "size",
            "prot"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "__early_ioremap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/early_ioremap.c",
          "lines": "105-166",
          "snippet": "__iomem *\n__early_ioremap(resource_size_t phys_addr, unsigned long size, pgprot_t prot)\n{\n\tunsigned long offset;\n\tresource_size_t last_addr;\n\tunsigned int nrpages;\n\tenum fixed_addresses idx;\n\tint i, slot;\n\n\tWARN_ON(system_state >= SYSTEM_RUNNING);\n\n\tslot = -1;\n\tfor (i = 0; i < FIX_BTMAPS_SLOTS; i++) {\n\t\tif (!prev_map[i]) {\n\t\t\tslot = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (WARN(slot < 0, \"%s(%08llx, %08lx) not found slot\\n\",\n\t\t __func__, (u64)phys_addr, size))\n\t\treturn NULL;\n\n\t/* Don't allow wraparound or zero size */\n\tlast_addr = phys_addr + size - 1;\n\tif (WARN_ON(!size || last_addr < phys_addr))\n\t\treturn NULL;\n\n\tprev_size[slot] = size;\n\t/*\n\t * Mappings have to be page-aligned\n\t */\n\toffset = offset_in_page(phys_addr);\n\tphys_addr &= PAGE_MASK;\n\tsize = PAGE_ALIGN(last_addr + 1) - phys_addr;\n\n\t/*\n\t * Mappings have to fit in the FIX_BTMAP area.\n\t */\n\tnrpages = size >> PAGE_SHIFT;\n\tif (WARN_ON(nrpages > NR_FIX_BTMAPS))\n\t\treturn NULL;\n\n\t/*\n\t * Ok, go for it..\n\t */\n\tidx = FIX_BTMAP_BEGIN - NR_FIX_BTMAPS*slot;\n\twhile (nrpages > 0) {\n\t\tif (after_paging_init)\n\t\t\t__late_set_fixmap(idx, phys_addr, prot);\n\t\telse\n\t\t\t__early_set_fixmap(idx, phys_addr, prot);\n\t\tphys_addr += PAGE_SIZE;\n\t\t--idx;\n\t\t--nrpages;\n\t}\n\tWARN(early_ioremap_debug, \"%s(%08llx, %08lx) [%d] => %08lx + %08lx\\n\",\n\t     __func__, (u64)phys_addr, size, slot, offset, slot_virt[slot]);\n\n\tprev_map[slot] = (void __iomem *)(offset + slot_virt[slot]);\n\treturn prev_map[slot];\n}",
          "includes": [
            "#include <asm/early_ioremap.h>",
            "#include <asm/fixmap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/early_ioremap.h>\n#include <asm/fixmap.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\n__iomem *\n__early_ioremap(resource_size_t phys_addr, unsigned long size, pgprot_t prot)\n{\n\tunsigned long offset;\n\tresource_size_t last_addr;\n\tunsigned int nrpages;\n\tenum fixed_addresses idx;\n\tint i, slot;\n\n\tWARN_ON(system_state >= SYSTEM_RUNNING);\n\n\tslot = -1;\n\tfor (i = 0; i < FIX_BTMAPS_SLOTS; i++) {\n\t\tif (!prev_map[i]) {\n\t\t\tslot = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (WARN(slot < 0, \"%s(%08llx, %08lx) not found slot\\n\",\n\t\t __func__, (u64)phys_addr, size))\n\t\treturn NULL;\n\n\t/* Don't allow wraparound or zero size */\n\tlast_addr = phys_addr + size - 1;\n\tif (WARN_ON(!size || last_addr < phys_addr))\n\t\treturn NULL;\n\n\tprev_size[slot] = size;\n\t/*\n\t * Mappings have to be page-aligned\n\t */\n\toffset = offset_in_page(phys_addr);\n\tphys_addr &= PAGE_MASK;\n\tsize = PAGE_ALIGN(last_addr + 1) - phys_addr;\n\n\t/*\n\t * Mappings have to fit in the FIX_BTMAP area.\n\t */\n\tnrpages = size >> PAGE_SHIFT;\n\tif (WARN_ON(nrpages > NR_FIX_BTMAPS))\n\t\treturn NULL;\n\n\t/*\n\t * Ok, go for it..\n\t */\n\tidx = FIX_BTMAP_BEGIN - NR_FIX_BTMAPS*slot;\n\twhile (nrpages > 0) {\n\t\tif (after_paging_init)\n\t\t\t__late_set_fixmap(idx, phys_addr, prot);\n\t\telse\n\t\t\t__early_set_fixmap(idx, phys_addr, prot);\n\t\tphys_addr += PAGE_SIZE;\n\t\t--idx;\n\t\t--nrpages;\n\t}\n\tWARN(early_ioremap_debug, \"%s(%08llx, %08lx) [%d] => %08lx + %08lx\\n\",\n\t     __func__, (u64)phys_addr, size, slot, offset, slot_virt[slot]);\n\n\tprev_map[slot] = (void __iomem *)(offset + slot_virt[slot]);\n\treturn prev_map[slot];\n}"
        }
      },
      {
        "call_info": {
          "callee": "early_memremap_pgprot_adjust",
          "args": [
            "phys_addr",
            "size",
            "FIXMAP_PAGE_NORMAL"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "early_memremap_pgprot_adjust",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/early_ioremap.c",
          "lines": "34-39",
          "snippet": "__weak early_memremap_pgprot_adjust(resource_size_t phys_addr,\n\t\t\t\t\t\t    unsigned long size,\n\t\t\t\t\t\t    pgprot_t prot)\n{\n\treturn prot;\n}",
          "includes": [
            "#include <asm/early_ioremap.h>",
            "#include <asm/fixmap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/early_ioremap.h>\n#include <asm/fixmap.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\n__weak early_memremap_pgprot_adjust(resource_size_t phys_addr,\n\t\t\t\t\t\t    unsigned long size,\n\t\t\t\t\t\t    pgprot_t prot)\n{\n\treturn prot;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/early_ioremap.h>\n#include <asm/fixmap.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nvoid __init *\nearly_memremap(resource_size_t phys_addr, unsigned long size)\n{\n\tpgprot_t prot = early_memremap_pgprot_adjust(phys_addr, size,\n\t\t\t\t\t\t     FIXMAP_PAGE_NORMAL);\n\n\treturn (__force void *)__early_ioremap(phys_addr, size, prot);\n}"
  },
  {
    "function_name": "early_ioremap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/early_ioremap.c",
    "lines": "216-220",
    "snippet": "__iomem *\nearly_ioremap(resource_size_t phys_addr, unsigned long size)\n{\n\treturn __early_ioremap(phys_addr, size, FIXMAP_PAGE_IO);\n}",
    "includes": [
      "#include <asm/early_ioremap.h>",
      "#include <asm/fixmap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__early_ioremap",
          "args": [
            "phys_addr",
            "size",
            "FIXMAP_PAGE_IO"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "__early_ioremap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/early_ioremap.c",
          "lines": "105-166",
          "snippet": "__iomem *\n__early_ioremap(resource_size_t phys_addr, unsigned long size, pgprot_t prot)\n{\n\tunsigned long offset;\n\tresource_size_t last_addr;\n\tunsigned int nrpages;\n\tenum fixed_addresses idx;\n\tint i, slot;\n\n\tWARN_ON(system_state >= SYSTEM_RUNNING);\n\n\tslot = -1;\n\tfor (i = 0; i < FIX_BTMAPS_SLOTS; i++) {\n\t\tif (!prev_map[i]) {\n\t\t\tslot = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (WARN(slot < 0, \"%s(%08llx, %08lx) not found slot\\n\",\n\t\t __func__, (u64)phys_addr, size))\n\t\treturn NULL;\n\n\t/* Don't allow wraparound or zero size */\n\tlast_addr = phys_addr + size - 1;\n\tif (WARN_ON(!size || last_addr < phys_addr))\n\t\treturn NULL;\n\n\tprev_size[slot] = size;\n\t/*\n\t * Mappings have to be page-aligned\n\t */\n\toffset = offset_in_page(phys_addr);\n\tphys_addr &= PAGE_MASK;\n\tsize = PAGE_ALIGN(last_addr + 1) - phys_addr;\n\n\t/*\n\t * Mappings have to fit in the FIX_BTMAP area.\n\t */\n\tnrpages = size >> PAGE_SHIFT;\n\tif (WARN_ON(nrpages > NR_FIX_BTMAPS))\n\t\treturn NULL;\n\n\t/*\n\t * Ok, go for it..\n\t */\n\tidx = FIX_BTMAP_BEGIN - NR_FIX_BTMAPS*slot;\n\twhile (nrpages > 0) {\n\t\tif (after_paging_init)\n\t\t\t__late_set_fixmap(idx, phys_addr, prot);\n\t\telse\n\t\t\t__early_set_fixmap(idx, phys_addr, prot);\n\t\tphys_addr += PAGE_SIZE;\n\t\t--idx;\n\t\t--nrpages;\n\t}\n\tWARN(early_ioremap_debug, \"%s(%08llx, %08lx) [%d] => %08lx + %08lx\\n\",\n\t     __func__, (u64)phys_addr, size, slot, offset, slot_virt[slot]);\n\n\tprev_map[slot] = (void __iomem *)(offset + slot_virt[slot]);\n\treturn prev_map[slot];\n}",
          "includes": [
            "#include <asm/early_ioremap.h>",
            "#include <asm/fixmap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/early_ioremap.h>\n#include <asm/fixmap.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\n__iomem *\n__early_ioremap(resource_size_t phys_addr, unsigned long size, pgprot_t prot)\n{\n\tunsigned long offset;\n\tresource_size_t last_addr;\n\tunsigned int nrpages;\n\tenum fixed_addresses idx;\n\tint i, slot;\n\n\tWARN_ON(system_state >= SYSTEM_RUNNING);\n\n\tslot = -1;\n\tfor (i = 0; i < FIX_BTMAPS_SLOTS; i++) {\n\t\tif (!prev_map[i]) {\n\t\t\tslot = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (WARN(slot < 0, \"%s(%08llx, %08lx) not found slot\\n\",\n\t\t __func__, (u64)phys_addr, size))\n\t\treturn NULL;\n\n\t/* Don't allow wraparound or zero size */\n\tlast_addr = phys_addr + size - 1;\n\tif (WARN_ON(!size || last_addr < phys_addr))\n\t\treturn NULL;\n\n\tprev_size[slot] = size;\n\t/*\n\t * Mappings have to be page-aligned\n\t */\n\toffset = offset_in_page(phys_addr);\n\tphys_addr &= PAGE_MASK;\n\tsize = PAGE_ALIGN(last_addr + 1) - phys_addr;\n\n\t/*\n\t * Mappings have to fit in the FIX_BTMAP area.\n\t */\n\tnrpages = size >> PAGE_SHIFT;\n\tif (WARN_ON(nrpages > NR_FIX_BTMAPS))\n\t\treturn NULL;\n\n\t/*\n\t * Ok, go for it..\n\t */\n\tidx = FIX_BTMAP_BEGIN - NR_FIX_BTMAPS*slot;\n\twhile (nrpages > 0) {\n\t\tif (after_paging_init)\n\t\t\t__late_set_fixmap(idx, phys_addr, prot);\n\t\telse\n\t\t\t__early_set_fixmap(idx, phys_addr, prot);\n\t\tphys_addr += PAGE_SIZE;\n\t\t--idx;\n\t\t--nrpages;\n\t}\n\tWARN(early_ioremap_debug, \"%s(%08llx, %08lx) [%d] => %08lx + %08lx\\n\",\n\t     __func__, (u64)phys_addr, size, slot, offset, slot_virt[slot]);\n\n\tprev_map[slot] = (void __iomem *)(offset + slot_virt[slot]);\n\treturn prev_map[slot];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/early_ioremap.h>\n#include <asm/fixmap.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\n__iomem *\nearly_ioremap(resource_size_t phys_addr, unsigned long size)\n{\n\treturn __early_ioremap(phys_addr, size, FIXMAP_PAGE_IO);\n}"
  },
  {
    "function_name": "early_iounmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/early_ioremap.c",
    "lines": "168-213",
    "snippet": "void __init early_iounmap(void __iomem *addr, unsigned long size)\n{\n\tunsigned long virt_addr;\n\tunsigned long offset;\n\tunsigned int nrpages;\n\tenum fixed_addresses idx;\n\tint i, slot;\n\n\tslot = -1;\n\tfor (i = 0; i < FIX_BTMAPS_SLOTS; i++) {\n\t\tif (prev_map[i] == addr) {\n\t\t\tslot = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (WARN(slot < 0, \"early_iounmap(%p, %08lx) not found slot\\n\",\n\t\t addr, size))\n\t\treturn;\n\n\tif (WARN(prev_size[slot] != size,\n\t\t \"early_iounmap(%p, %08lx) [%d] size not consistent %08lx\\n\",\n\t\t addr, size, slot, prev_size[slot]))\n\t\treturn;\n\n\tWARN(early_ioremap_debug, \"early_iounmap(%p, %08lx) [%d]\\n\",\n\t     addr, size, slot);\n\n\tvirt_addr = (unsigned long)addr;\n\tif (WARN_ON(virt_addr < fix_to_virt(FIX_BTMAP_BEGIN)))\n\t\treturn;\n\n\toffset = offset_in_page(virt_addr);\n\tnrpages = PAGE_ALIGN(offset + size) >> PAGE_SHIFT;\n\n\tidx = FIX_BTMAP_BEGIN - NR_FIX_BTMAPS*slot;\n\twhile (nrpages > 0) {\n\t\tif (after_paging_init)\n\t\t\t__late_clear_fixmap(idx);\n\t\telse\n\t\t\t__early_set_fixmap(idx, 0, FIXMAP_PAGE_CLEAR);\n\t\t--idx;\n\t\t--nrpages;\n\t}\n\tprev_map[slot] = NULL;\n}",
    "includes": [
      "#include <asm/early_ioremap.h>",
      "#include <asm/fixmap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__early_set_fixmap",
          "args": [
            "idx",
            "0",
            "FIXMAP_PAGE_CLEAR"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__late_clear_fixmap",
          "args": [
            "idx"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "__late_clear_fixmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/early_ioremap.c",
          "lines": "65-68",
          "snippet": "static inline void __init __late_clear_fixmap(enum fixed_addresses idx)\n{\n\tBUG();\n}",
          "includes": [
            "#include <asm/early_ioremap.h>",
            "#include <asm/fixmap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/early_ioremap.h>\n#include <asm/fixmap.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic inline void __init __late_clear_fixmap(enum fixed_addresses idx)\n{\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "offset + size"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "virt_addr"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "virt_addr < fix_to_virt(FIX_BTMAP_BEGIN)"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fix_to_virt",
          "args": [
            "FIX_BTMAP_BEGIN"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "early_ioremap_debug",
            "\"early_iounmap(%p, %08lx) [%d]\\n\"",
            "addr",
            "size",
            "slot"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "prev_size[slot] != size",
            "\"early_iounmap(%p, %08lx) [%d] size not consistent %08lx\\n\"",
            "addr",
            "size",
            "slot",
            "prev_size[slot]"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "slot < 0",
            "\"early_iounmap(%p, %08lx) not found slot\\n\"",
            "addr",
            "size"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/early_ioremap.h>\n#include <asm/fixmap.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nvoid __init early_iounmap(void __iomem *addr, unsigned long size)\n{\n\tunsigned long virt_addr;\n\tunsigned long offset;\n\tunsigned int nrpages;\n\tenum fixed_addresses idx;\n\tint i, slot;\n\n\tslot = -1;\n\tfor (i = 0; i < FIX_BTMAPS_SLOTS; i++) {\n\t\tif (prev_map[i] == addr) {\n\t\t\tslot = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (WARN(slot < 0, \"early_iounmap(%p, %08lx) not found slot\\n\",\n\t\t addr, size))\n\t\treturn;\n\n\tif (WARN(prev_size[slot] != size,\n\t\t \"early_iounmap(%p, %08lx) [%d] size not consistent %08lx\\n\",\n\t\t addr, size, slot, prev_size[slot]))\n\t\treturn;\n\n\tWARN(early_ioremap_debug, \"early_iounmap(%p, %08lx) [%d]\\n\",\n\t     addr, size, slot);\n\n\tvirt_addr = (unsigned long)addr;\n\tif (WARN_ON(virt_addr < fix_to_virt(FIX_BTMAP_BEGIN)))\n\t\treturn;\n\n\toffset = offset_in_page(virt_addr);\n\tnrpages = PAGE_ALIGN(offset + size) >> PAGE_SHIFT;\n\n\tidx = FIX_BTMAP_BEGIN - NR_FIX_BTMAPS*slot;\n\twhile (nrpages > 0) {\n\t\tif (after_paging_init)\n\t\t\t__late_clear_fixmap(idx);\n\t\telse\n\t\t\t__early_set_fixmap(idx, 0, FIXMAP_PAGE_CLEAR);\n\t\t--idx;\n\t\t--nrpages;\n\t}\n\tprev_map[slot] = NULL;\n}"
  },
  {
    "function_name": "__early_ioremap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/early_ioremap.c",
    "lines": "105-166",
    "snippet": "__iomem *\n__early_ioremap(resource_size_t phys_addr, unsigned long size, pgprot_t prot)\n{\n\tunsigned long offset;\n\tresource_size_t last_addr;\n\tunsigned int nrpages;\n\tenum fixed_addresses idx;\n\tint i, slot;\n\n\tWARN_ON(system_state >= SYSTEM_RUNNING);\n\n\tslot = -1;\n\tfor (i = 0; i < FIX_BTMAPS_SLOTS; i++) {\n\t\tif (!prev_map[i]) {\n\t\t\tslot = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (WARN(slot < 0, \"%s(%08llx, %08lx) not found slot\\n\",\n\t\t __func__, (u64)phys_addr, size))\n\t\treturn NULL;\n\n\t/* Don't allow wraparound or zero size */\n\tlast_addr = phys_addr + size - 1;\n\tif (WARN_ON(!size || last_addr < phys_addr))\n\t\treturn NULL;\n\n\tprev_size[slot] = size;\n\t/*\n\t * Mappings have to be page-aligned\n\t */\n\toffset = offset_in_page(phys_addr);\n\tphys_addr &= PAGE_MASK;\n\tsize = PAGE_ALIGN(last_addr + 1) - phys_addr;\n\n\t/*\n\t * Mappings have to fit in the FIX_BTMAP area.\n\t */\n\tnrpages = size >> PAGE_SHIFT;\n\tif (WARN_ON(nrpages > NR_FIX_BTMAPS))\n\t\treturn NULL;\n\n\t/*\n\t * Ok, go for it..\n\t */\n\tidx = FIX_BTMAP_BEGIN - NR_FIX_BTMAPS*slot;\n\twhile (nrpages > 0) {\n\t\tif (after_paging_init)\n\t\t\t__late_set_fixmap(idx, phys_addr, prot);\n\t\telse\n\t\t\t__early_set_fixmap(idx, phys_addr, prot);\n\t\tphys_addr += PAGE_SIZE;\n\t\t--idx;\n\t\t--nrpages;\n\t}\n\tWARN(early_ioremap_debug, \"%s(%08llx, %08lx) [%d] => %08lx + %08lx\\n\",\n\t     __func__, (u64)phys_addr, size, slot, offset, slot_virt[slot]);\n\n\tprev_map[slot] = (void __iomem *)(offset + slot_virt[slot]);\n\treturn prev_map[slot];\n}",
    "includes": [
      "#include <asm/early_ioremap.h>",
      "#include <asm/fixmap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "early_ioremap_debug",
            "\"%s(%08llx, %08lx) [%d] => %08lx + %08lx\\n\"",
            "__func__",
            "(u64)phys_addr",
            "size",
            "slot",
            "offset",
            "slot_virt[slot]"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__early_set_fixmap",
          "args": [
            "idx",
            "phys_addr",
            "prot"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__late_set_fixmap",
          "args": [
            "idx",
            "phys_addr",
            "prot"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "__late_set_fixmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/early_ioremap.c",
          "lines": "57-61",
          "snippet": "static inline void __init __late_set_fixmap(enum fixed_addresses idx,\n\t\t\t\t\t    phys_addr_t phys, pgprot_t prot)\n{\n\tBUG();\n}",
          "includes": [
            "#include <asm/early_ioremap.h>",
            "#include <asm/fixmap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/early_ioremap.h>\n#include <asm/fixmap.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic inline void __init __late_set_fixmap(enum fixed_addresses idx,\n\t\t\t\t\t    phys_addr_t phys, pgprot_t prot)\n{\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "nrpages > NR_FIX_BTMAPS"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "last_addr + 1"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "phys_addr"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!size || last_addr < phys_addr"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "slot < 0",
            "\"%s(%08llx, %08lx) not found slot\\n\"",
            "__func__",
            "(u64)phys_addr",
            "size"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "system_state >= SYSTEM_RUNNING"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/early_ioremap.h>\n#include <asm/fixmap.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\n__iomem *\n__early_ioremap(resource_size_t phys_addr, unsigned long size, pgprot_t prot)\n{\n\tunsigned long offset;\n\tresource_size_t last_addr;\n\tunsigned int nrpages;\n\tenum fixed_addresses idx;\n\tint i, slot;\n\n\tWARN_ON(system_state >= SYSTEM_RUNNING);\n\n\tslot = -1;\n\tfor (i = 0; i < FIX_BTMAPS_SLOTS; i++) {\n\t\tif (!prev_map[i]) {\n\t\t\tslot = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (WARN(slot < 0, \"%s(%08llx, %08lx) not found slot\\n\",\n\t\t __func__, (u64)phys_addr, size))\n\t\treturn NULL;\n\n\t/* Don't allow wraparound or zero size */\n\tlast_addr = phys_addr + size - 1;\n\tif (WARN_ON(!size || last_addr < phys_addr))\n\t\treturn NULL;\n\n\tprev_size[slot] = size;\n\t/*\n\t * Mappings have to be page-aligned\n\t */\n\toffset = offset_in_page(phys_addr);\n\tphys_addr &= PAGE_MASK;\n\tsize = PAGE_ALIGN(last_addr + 1) - phys_addr;\n\n\t/*\n\t * Mappings have to fit in the FIX_BTMAP area.\n\t */\n\tnrpages = size >> PAGE_SHIFT;\n\tif (WARN_ON(nrpages > NR_FIX_BTMAPS))\n\t\treturn NULL;\n\n\t/*\n\t * Ok, go for it..\n\t */\n\tidx = FIX_BTMAP_BEGIN - NR_FIX_BTMAPS*slot;\n\twhile (nrpages > 0) {\n\t\tif (after_paging_init)\n\t\t\t__late_set_fixmap(idx, phys_addr, prot);\n\t\telse\n\t\t\t__early_set_fixmap(idx, phys_addr, prot);\n\t\tphys_addr += PAGE_SIZE;\n\t\t--idx;\n\t\t--nrpages;\n\t}\n\tWARN(early_ioremap_debug, \"%s(%08llx, %08lx) [%d] => %08lx + %08lx\\n\",\n\t     __func__, (u64)phys_addr, size, slot, offset, slot_virt[slot]);\n\n\tprev_map[slot] = (void __iomem *)(offset + slot_virt[slot]);\n\treturn prev_map[slot];\n}"
  },
  {
    "function_name": "check_early_ioremap_leak",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/early_ioremap.c",
    "lines": "87-102",
    "snippet": "static int __init check_early_ioremap_leak(void)\n{\n\tint count = 0;\n\tint i;\n\n\tfor (i = 0; i < FIX_BTMAPS_SLOTS; i++)\n\t\tif (prev_map[i])\n\t\t\tcount++;\n\n\tif (WARN(count, KERN_WARNING\n\t\t \"Debug warning: early ioremap leak of %d areas detected.\\n\"\n\t\t \"please boot with early_ioremap_debug and report the dmesg.\\n\",\n\t\t count))\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/early_ioremap.h>",
      "#include <asm/fixmap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "count",
            "KERN_WARNING\n\t\t \"Debug warning: early ioremap leak of %d areas detected.\\n\"\n\t\t \"please boot with early_ioremap_debug and report the dmesg.\\n\"",
            "count"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/early_ioremap.h>\n#include <asm/fixmap.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic int __init check_early_ioremap_leak(void)\n{\n\tint count = 0;\n\tint i;\n\n\tfor (i = 0; i < FIX_BTMAPS_SLOTS; i++)\n\t\tif (prev_map[i])\n\t\t\tcount++;\n\n\tif (WARN(count, KERN_WARNING\n\t\t \"Debug warning: early ioremap leak of %d areas detected.\\n\"\n\t\t \"please boot with early_ioremap_debug and report the dmesg.\\n\",\n\t\t count))\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "early_ioremap_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/early_ioremap.c",
    "lines": "75-85",
    "snippet": "void __init early_ioremap_setup(void)\n{\n\tint i;\n\n\tfor (i = 0; i < FIX_BTMAPS_SLOTS; i++)\n\t\tif (WARN_ON(prev_map[i]))\n\t\t\tbreak;\n\n\tfor (i = 0; i < FIX_BTMAPS_SLOTS; i++)\n\t\tslot_virt[i] = __fix_to_virt(FIX_BTMAP_BEGIN - NR_FIX_BTMAPS*i);\n}",
    "includes": [
      "#include <asm/early_ioremap.h>",
      "#include <asm/fixmap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__fix_to_virt",
          "args": [
            "FIX_BTMAP_BEGIN - NR_FIX_BTMAPS*i"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "prev_map[i]"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/early_ioremap.h>\n#include <asm/fixmap.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nvoid __init early_ioremap_setup(void)\n{\n\tint i;\n\n\tfor (i = 0; i < FIX_BTMAPS_SLOTS; i++)\n\t\tif (WARN_ON(prev_map[i]))\n\t\t\tbreak;\n\n\tfor (i = 0; i < FIX_BTMAPS_SLOTS; i++)\n\t\tslot_virt[i] = __fix_to_virt(FIX_BTMAP_BEGIN - NR_FIX_BTMAPS*i);\n}"
  },
  {
    "function_name": "__late_clear_fixmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/early_ioremap.c",
    "lines": "65-68",
    "snippet": "static inline void __init __late_clear_fixmap(enum fixed_addresses idx)\n{\n\tBUG();\n}",
    "includes": [
      "#include <asm/early_ioremap.h>",
      "#include <asm/fixmap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/early_ioremap.h>\n#include <asm/fixmap.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic inline void __init __late_clear_fixmap(enum fixed_addresses idx)\n{\n\tBUG();\n}"
  },
  {
    "function_name": "__late_set_fixmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/early_ioremap.c",
    "lines": "57-61",
    "snippet": "static inline void __init __late_set_fixmap(enum fixed_addresses idx,\n\t\t\t\t\t    phys_addr_t phys, pgprot_t prot)\n{\n\tBUG();\n}",
    "includes": [
      "#include <asm/early_ioremap.h>",
      "#include <asm/fixmap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/early_ioremap.h>\n#include <asm/fixmap.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic inline void __init __late_set_fixmap(enum fixed_addresses idx,\n\t\t\t\t\t    phys_addr_t phys, pgprot_t prot)\n{\n\tBUG();\n}"
  },
  {
    "function_name": "early_ioremap_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/early_ioremap.c",
    "lines": "45-49",
    "snippet": "void __init early_ioremap_reset(void)\n{\n\tearly_ioremap_shutdown();\n\tafter_paging_init = 1;\n}",
    "includes": [
      "#include <asm/early_ioremap.h>",
      "#include <asm/fixmap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "early_ioremap_shutdown",
          "args": [],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "early_ioremap_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/early_ioremap.c",
          "lines": "41-43",
          "snippet": "__weak early_ioremap_shutdown(void)\n{\n}",
          "includes": [
            "#include <asm/early_ioremap.h>",
            "#include <asm/fixmap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/early_ioremap.h>\n#include <asm/fixmap.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\n__weak early_ioremap_shutdown(void)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/early_ioremap.h>\n#include <asm/fixmap.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nvoid __init early_ioremap_reset(void)\n{\n\tearly_ioremap_shutdown();\n\tafter_paging_init = 1;\n}"
  },
  {
    "function_name": "early_ioremap_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/early_ioremap.c",
    "lines": "41-43",
    "snippet": "__weak early_ioremap_shutdown(void)\n{\n}",
    "includes": [
      "#include <asm/early_ioremap.h>",
      "#include <asm/fixmap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/early_ioremap.h>\n#include <asm/fixmap.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\n__weak early_ioremap_shutdown(void)\n{\n}"
  },
  {
    "function_name": "early_memremap_pgprot_adjust",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/early_ioremap.c",
    "lines": "34-39",
    "snippet": "__weak early_memremap_pgprot_adjust(resource_size_t phys_addr,\n\t\t\t\t\t\t    unsigned long size,\n\t\t\t\t\t\t    pgprot_t prot)\n{\n\treturn prot;\n}",
    "includes": [
      "#include <asm/early_ioremap.h>",
      "#include <asm/fixmap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/early_ioremap.h>\n#include <asm/fixmap.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\n__weak early_memremap_pgprot_adjust(resource_size_t phys_addr,\n\t\t\t\t\t\t    unsigned long size,\n\t\t\t\t\t\t    pgprot_t prot)\n{\n\treturn prot;\n}"
  },
  {
    "function_name": "early_ioremap_debug_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/early_ioremap.c",
    "lines": "24-29",
    "snippet": "static int __init early_ioremap_debug_setup(char *str)\n{\n\tearly_ioremap_debug = 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/early_ioremap.h>",
      "#include <asm/fixmap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/early_ioremap.h>\n#include <asm/fixmap.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic int __init early_ioremap_debug_setup(char *str)\n{\n\tearly_ioremap_debug = 1;\n\n\treturn 0;\n}"
  }
]