[
  {
    "function_name": "page_address_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
    "lines": "475-483",
    "snippet": "void __init page_address_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(page_address_htable); i++) {\n\t\tINIT_LIST_HEAD(&page_address_htable[i].lh);\n\t\tspin_lock_init(&page_address_htable[i].lock);\n\t}\n}",
    "includes": [
      "#include <asm/tlbflush.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/bio.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&page_address_htable[i].lock"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&page_address_htable[i].lh"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "page_address_htable"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid __init page_address_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(page_address_htable); i++) {\n\t\tINIT_LIST_HEAD(&page_address_htable[i].lh);\n\t\tspin_lock_init(&page_address_htable[i].lock);\n\t}\n}"
  },
  {
    "function_name": "set_page_address",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
    "lines": "443-473",
    "snippet": "void set_page_address(struct page *page, void *virtual)\n{\n\tunsigned long flags;\n\tstruct page_address_slot *pas;\n\tstruct page_address_map *pam;\n\n\tBUG_ON(!PageHighMem(page));\n\n\tpas = page_slot(page);\n\tif (virtual) {\t\t/* Add */\n\t\tpam = &page_address_maps[PKMAP_NR((unsigned long)virtual)];\n\t\tpam->page = page;\n\t\tpam->virtual = virtual;\n\n\t\tspin_lock_irqsave(&pas->lock, flags);\n\t\tlist_add_tail(&pam->list, &pas->lh);\n\t\tspin_unlock_irqrestore(&pas->lock, flags);\n\t} else {\t\t/* Remove */\n\t\tspin_lock_irqsave(&pas->lock, flags);\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tlist_del(&pam->list);\n\t\t\t\tspin_unlock_irqrestore(&pas->lock, flags);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&pas->lock, flags);\n\t}\ndone:\n\treturn;\n}",
    "includes": [
      "#include <asm/tlbflush.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/bio.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pas->lock",
            "flags"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pas->lock",
            "flags"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&pam->list"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "pam",
            "&pas->lh",
            "list"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&pas->lock",
            "flags"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pas->lock",
            "flags"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&pam->list",
            "&pas->lh"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&pas->lock",
            "flags"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PKMAP_NR",
          "args": [
            "(unsigned long)virtual"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_slot",
          "args": [
            "page"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "page_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "398-401",
          "snippet": "static struct page_address_slot *page_slot(const struct page *page)\n{\n\treturn &page_address_htable[hash_ptr(page, PA_HASH_ORDER)];\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define PA_HASH_ORDER\t7"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\n#define PA_HASH_ORDER\t7\n\nstatic struct page_address_slot *page_slot(const struct page *page)\n{\n\treturn &page_address_htable[hash_ptr(page, PA_HASH_ORDER)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageHighMem(page)"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHighMem",
          "args": [
            "page"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid set_page_address(struct page *page, void *virtual)\n{\n\tunsigned long flags;\n\tstruct page_address_slot *pas;\n\tstruct page_address_map *pam;\n\n\tBUG_ON(!PageHighMem(page));\n\n\tpas = page_slot(page);\n\tif (virtual) {\t\t/* Add */\n\t\tpam = &page_address_maps[PKMAP_NR((unsigned long)virtual)];\n\t\tpam->page = page;\n\t\tpam->virtual = virtual;\n\n\t\tspin_lock_irqsave(&pas->lock, flags);\n\t\tlist_add_tail(&pam->list, &pas->lh);\n\t\tspin_unlock_irqrestore(&pas->lock, flags);\n\t} else {\t\t/* Remove */\n\t\tspin_lock_irqsave(&pas->lock, flags);\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tlist_del(&pam->list);\n\t\t\t\tspin_unlock_irqrestore(&pas->lock, flags);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&pas->lock, flags);\n\t}\ndone:\n\treturn;\n}"
  },
  {
    "function_name": "page_address",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
    "lines": "409-434",
    "snippet": "void *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/tlbflush.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/bio.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pas->lock",
            "flags"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "pam",
            "&pas->lh",
            "list"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pas->lh"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&pas->lock",
            "flags"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_slot",
          "args": [
            "page"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "page_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "398-401",
          "snippet": "static struct page_address_slot *page_slot(const struct page *page)\n{\n\treturn &page_address_htable[hash_ptr(page, PA_HASH_ORDER)];\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define PA_HASH_ORDER\t7"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\n#define PA_HASH_ORDER\t7\n\nstatic struct page_address_slot *page_slot(const struct page *page)\n{\n\treturn &page_address_htable[hash_ptr(page, PA_HASH_ORDER)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "lowmem_page_address",
          "args": [
            "page"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHighMem",
          "args": [
            "page"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "page_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
    "lines": "398-401",
    "snippet": "static struct page_address_slot *page_slot(const struct page *page)\n{\n\treturn &page_address_htable[hash_ptr(page, PA_HASH_ORDER)];\n}",
    "includes": [
      "#include <asm/tlbflush.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/bio.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define PA_HASH_ORDER\t7"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_ptr",
          "args": [
            "page",
            "PA_HASH_ORDER"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\n#define PA_HASH_ORDER\t7\n\nstatic struct page_address_slot *page_slot(const struct page *page)\n{\n\treturn &page_address_htable[hash_ptr(page, PA_HASH_ORDER)];\n}"
  },
  {
    "function_name": "kunmap_high",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
    "lines": "329-370",
    "snippet": "void kunmap_high(struct page *page)\n{\n\tunsigned long vaddr;\n\tunsigned long nr;\n\tunsigned long flags;\n\tint need_wakeup;\n\tunsigned int color = get_pkmap_color(page);\n\twait_queue_head_t *pkmap_map_wait;\n\n\tlock_kmap_any(flags);\n\tvaddr = (unsigned long)page_address(page);\n\tBUG_ON(!vaddr);\n\tnr = PKMAP_NR(vaddr);\n\n\t/*\n\t * A count must never go down to zero\n\t * without a TLB flush!\n\t */\n\tneed_wakeup = 0;\n\tswitch (--pkmap_count[nr]) {\n\tcase 0:\n\t\tBUG();\n\tcase 1:\n\t\t/*\n\t\t * Avoid an unnecessary wake_up() function call.\n\t\t * The common case is pkmap_count[] == 1, but\n\t\t * no waiters.\n\t\t * The tasks queued in the wait-queue are guarded\n\t\t * by both the lock in the wait-queue-head and by\n\t\t * the kmap_lock.  As the kmap_lock is held here,\n\t\t * no need for the wait-queue-head's lock.  Simply\n\t\t * test if the queue is empty.\n\t\t */\n\t\tpkmap_map_wait = get_pkmap_wait_queue_head(color);\n\t\tneed_wakeup = waitqueue_active(pkmap_map_wait);\n\t}\n\tunlock_kmap_any(flags);\n\n\t/* do wake-up, if needed, race-free outside of the spin lock */\n\tif (need_wakeup)\n\t\twake_up(pkmap_map_wait);\n}",
    "includes": [
      "#include <asm/tlbflush.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/bio.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define get_pkmap_color get_pkmap_color"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "pkmap_map_wait"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_kmap_any",
          "args": [
            "flags"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "pkmap_map_wait"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pkmap_wait_queue_head",
          "args": [
            "color"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "get_pkmap_wait_queue_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "100-105",
          "snippet": "static inline wait_queue_head_t *get_pkmap_wait_queue_head(unsigned int color)\n{\n\tstatic DECLARE_WAIT_QUEUE_HEAD(pkmap_map_wait);\n\n\treturn &pkmap_map_wait;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstatic inline wait_queue_head_t *get_pkmap_wait_queue_head(unsigned int color)\n{\n\tstatic DECLARE_WAIT_QUEUE_HEAD(pkmap_map_wait);\n\n\treturn &pkmap_map_wait;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PKMAP_NR",
          "args": [
            "vaddr"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!vaddr"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "page_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "409-434",
          "snippet": "void *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_kmap_any",
          "args": [
            "flags"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pkmap_color",
          "args": [
            "page"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "get_pkmap_color",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "58-61",
          "snippet": "static inline unsigned int get_pkmap_color(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define get_pkmap_color get_pkmap_color"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\n#define get_pkmap_color get_pkmap_color\n\nstatic inline unsigned int get_pkmap_color(struct page *page)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\n#define get_pkmap_color get_pkmap_color\n\nvoid kunmap_high(struct page *page)\n{\n\tunsigned long vaddr;\n\tunsigned long nr;\n\tunsigned long flags;\n\tint need_wakeup;\n\tunsigned int color = get_pkmap_color(page);\n\twait_queue_head_t *pkmap_map_wait;\n\n\tlock_kmap_any(flags);\n\tvaddr = (unsigned long)page_address(page);\n\tBUG_ON(!vaddr);\n\tnr = PKMAP_NR(vaddr);\n\n\t/*\n\t * A count must never go down to zero\n\t * without a TLB flush!\n\t */\n\tneed_wakeup = 0;\n\tswitch (--pkmap_count[nr]) {\n\tcase 0:\n\t\tBUG();\n\tcase 1:\n\t\t/*\n\t\t * Avoid an unnecessary wake_up() function call.\n\t\t * The common case is pkmap_count[] == 1, but\n\t\t * no waiters.\n\t\t * The tasks queued in the wait-queue are guarded\n\t\t * by both the lock in the wait-queue-head and by\n\t\t * the kmap_lock.  As the kmap_lock is held here,\n\t\t * no need for the wait-queue-head's lock.  Simply\n\t\t * test if the queue is empty.\n\t\t */\n\t\tpkmap_map_wait = get_pkmap_wait_queue_head(color);\n\t\tneed_wakeup = waitqueue_active(pkmap_map_wait);\n\t}\n\tunlock_kmap_any(flags);\n\n\t/* do wake-up, if needed, race-free outside of the spin lock */\n\tif (need_wakeup)\n\t\twake_up(pkmap_map_wait);\n}"
  },
  {
    "function_name": "kmap_high_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
    "lines": "307-319",
    "snippet": "void *kmap_high_get(struct page *page)\n{\n\tunsigned long vaddr, flags;\n\n\tlock_kmap_any(flags);\n\tvaddr = (unsigned long)page_address(page);\n\tif (vaddr) {\n\t\tBUG_ON(pkmap_count[PKMAP_NR(vaddr)] < 1);\n\t\tpkmap_count[PKMAP_NR(vaddr)]++;\n\t}\n\tunlock_kmap_any(flags);\n\treturn (void*) vaddr;\n}",
    "includes": [
      "#include <asm/tlbflush.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/bio.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_kmap_any",
          "args": [
            "flags"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PKMAP_NR",
          "args": [
            "vaddr"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pkmap_count[PKMAP_NR(vaddr)] < 1"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PKMAP_NR",
          "args": [
            "vaddr"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "page_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "409-434",
          "snippet": "void *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_kmap_any",
          "args": [
            "flags"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid *kmap_high_get(struct page *page)\n{\n\tunsigned long vaddr, flags;\n\n\tlock_kmap_any(flags);\n\tvaddr = (unsigned long)page_address(page);\n\tif (vaddr) {\n\t\tBUG_ON(pkmap_count[PKMAP_NR(vaddr)] < 1);\n\t\tpkmap_count[PKMAP_NR(vaddr)]++;\n\t}\n\tunlock_kmap_any(flags);\n\treturn (void*) vaddr;\n}"
  },
  {
    "function_name": "kmap_high",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
    "lines": "276-292",
    "snippet": "void *kmap_high(struct page *page)\n{\n\tunsigned long vaddr;\n\n\t/*\n\t * For highmem pages, we can't trust \"virtual\" until\n\t * after we have the lock.\n\t */\n\tlock_kmap();\n\tvaddr = (unsigned long)page_address(page);\n\tif (!vaddr)\n\t\tvaddr = map_new_virtual(page);\n\tpkmap_count[PKMAP_NR(vaddr)]++;\n\tBUG_ON(pkmap_count[PKMAP_NR(vaddr)] < 2);\n\tunlock_kmap();\n\treturn (void*) vaddr;\n}",
    "includes": [
      "#include <asm/tlbflush.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/bio.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_kmap",
          "args": [],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pkmap_count[PKMAP_NR(vaddr)] < 2"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PKMAP_NR",
          "args": [
            "vaddr"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PKMAP_NR",
          "args": [
            "vaddr"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_new_virtual",
          "args": [
            "page"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "map_new_virtual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "214-266",
          "snippet": "static inline unsigned long map_new_virtual(struct page *page)\n{\n\tunsigned long vaddr;\n\tint count;\n\tunsigned int last_pkmap_nr;\n\tunsigned int color = get_pkmap_color(page);\n\nstart:\n\tcount = get_pkmap_entries_count(color);\n\t/* Find an empty entry */\n\tfor (;;) {\n\t\tlast_pkmap_nr = get_next_pkmap_nr(color);\n\t\tif (no_more_pkmaps(last_pkmap_nr, color)) {\n\t\t\tflush_all_zero_pkmaps();\n\t\t\tcount = get_pkmap_entries_count(color);\n\t\t}\n\t\tif (!pkmap_count[last_pkmap_nr])\n\t\t\tbreak;\t/* Found a usable entry */\n\t\tif (--count)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Sleep for somebody else to unmap their entries\n\t\t */\n\t\t{\n\t\t\tDECLARE_WAITQUEUE(wait, current);\n\t\t\twait_queue_head_t *pkmap_map_wait =\n\t\t\t\tget_pkmap_wait_queue_head(color);\n\n\t\t\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tadd_wait_queue(pkmap_map_wait, &wait);\n\t\t\tunlock_kmap();\n\t\t\tschedule();\n\t\t\tremove_wait_queue(pkmap_map_wait, &wait);\n\t\t\tlock_kmap();\n\n\t\t\t/* Somebody else might have mapped it while we slept */\n\t\t\tif (page_address(page))\n\t\t\t\treturn (unsigned long)page_address(page);\n\n\t\t\t/* Re-start */\n\t\t\tgoto start;\n\t\t}\n\t}\n\tvaddr = PKMAP_ADDR(last_pkmap_nr);\n\tset_pte_at(&init_mm, vaddr,\n\t\t   &(pkmap_page_table[last_pkmap_nr]), mk_pte(page, kmap_prot));\n\n\tpkmap_count[last_pkmap_nr] = 1;\n\tset_page_address(page, (void *)vaddr);\n\n\treturn vaddr;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define get_pkmap_color get_pkmap_color"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\n#define get_pkmap_color get_pkmap_color\n\nstatic inline unsigned long map_new_virtual(struct page *page)\n{\n\tunsigned long vaddr;\n\tint count;\n\tunsigned int last_pkmap_nr;\n\tunsigned int color = get_pkmap_color(page);\n\nstart:\n\tcount = get_pkmap_entries_count(color);\n\t/* Find an empty entry */\n\tfor (;;) {\n\t\tlast_pkmap_nr = get_next_pkmap_nr(color);\n\t\tif (no_more_pkmaps(last_pkmap_nr, color)) {\n\t\t\tflush_all_zero_pkmaps();\n\t\t\tcount = get_pkmap_entries_count(color);\n\t\t}\n\t\tif (!pkmap_count[last_pkmap_nr])\n\t\t\tbreak;\t/* Found a usable entry */\n\t\tif (--count)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Sleep for somebody else to unmap their entries\n\t\t */\n\t\t{\n\t\t\tDECLARE_WAITQUEUE(wait, current);\n\t\t\twait_queue_head_t *pkmap_map_wait =\n\t\t\t\tget_pkmap_wait_queue_head(color);\n\n\t\t\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tadd_wait_queue(pkmap_map_wait, &wait);\n\t\t\tunlock_kmap();\n\t\t\tschedule();\n\t\t\tremove_wait_queue(pkmap_map_wait, &wait);\n\t\t\tlock_kmap();\n\n\t\t\t/* Somebody else might have mapped it while we slept */\n\t\t\tif (page_address(page))\n\t\t\t\treturn (unsigned long)page_address(page);\n\n\t\t\t/* Re-start */\n\t\t\tgoto start;\n\t\t}\n\t}\n\tvaddr = PKMAP_ADDR(last_pkmap_nr);\n\tset_pte_at(&init_mm, vaddr,\n\t\t   &(pkmap_page_table[last_pkmap_nr]), mk_pte(page, kmap_prot));\n\n\tpkmap_count[last_pkmap_nr] = 1;\n\tset_page_address(page, (void *)vaddr);\n\n\treturn vaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "page_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "409-434",
          "snippet": "void *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_kmap",
          "args": [],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid *kmap_high(struct page *page)\n{\n\tunsigned long vaddr;\n\n\t/*\n\t * For highmem pages, we can't trust \"virtual\" until\n\t * after we have the lock.\n\t */\n\tlock_kmap();\n\tvaddr = (unsigned long)page_address(page);\n\tif (!vaddr)\n\t\tvaddr = map_new_virtual(page);\n\tpkmap_count[PKMAP_NR(vaddr)]++;\n\tBUG_ON(pkmap_count[PKMAP_NR(vaddr)] < 2);\n\tunlock_kmap();\n\treturn (void*) vaddr;\n}"
  },
  {
    "function_name": "map_new_virtual",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
    "lines": "214-266",
    "snippet": "static inline unsigned long map_new_virtual(struct page *page)\n{\n\tunsigned long vaddr;\n\tint count;\n\tunsigned int last_pkmap_nr;\n\tunsigned int color = get_pkmap_color(page);\n\nstart:\n\tcount = get_pkmap_entries_count(color);\n\t/* Find an empty entry */\n\tfor (;;) {\n\t\tlast_pkmap_nr = get_next_pkmap_nr(color);\n\t\tif (no_more_pkmaps(last_pkmap_nr, color)) {\n\t\t\tflush_all_zero_pkmaps();\n\t\t\tcount = get_pkmap_entries_count(color);\n\t\t}\n\t\tif (!pkmap_count[last_pkmap_nr])\n\t\t\tbreak;\t/* Found a usable entry */\n\t\tif (--count)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Sleep for somebody else to unmap their entries\n\t\t */\n\t\t{\n\t\t\tDECLARE_WAITQUEUE(wait, current);\n\t\t\twait_queue_head_t *pkmap_map_wait =\n\t\t\t\tget_pkmap_wait_queue_head(color);\n\n\t\t\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tadd_wait_queue(pkmap_map_wait, &wait);\n\t\t\tunlock_kmap();\n\t\t\tschedule();\n\t\t\tremove_wait_queue(pkmap_map_wait, &wait);\n\t\t\tlock_kmap();\n\n\t\t\t/* Somebody else might have mapped it while we slept */\n\t\t\tif (page_address(page))\n\t\t\t\treturn (unsigned long)page_address(page);\n\n\t\t\t/* Re-start */\n\t\t\tgoto start;\n\t\t}\n\t}\n\tvaddr = PKMAP_ADDR(last_pkmap_nr);\n\tset_pte_at(&init_mm, vaddr,\n\t\t   &(pkmap_page_table[last_pkmap_nr]), mk_pte(page, kmap_prot));\n\n\tpkmap_count[last_pkmap_nr] = 1;\n\tset_page_address(page, (void *)vaddr);\n\n\treturn vaddr;\n}",
    "includes": [
      "#include <asm/tlbflush.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/bio.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define get_pkmap_color get_pkmap_color"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_page_address",
          "args": [
            "page",
            "(void *)vaddr"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "443-473",
          "snippet": "void set_page_address(struct page *page, void *virtual)\n{\n\tunsigned long flags;\n\tstruct page_address_slot *pas;\n\tstruct page_address_map *pam;\n\n\tBUG_ON(!PageHighMem(page));\n\n\tpas = page_slot(page);\n\tif (virtual) {\t\t/* Add */\n\t\tpam = &page_address_maps[PKMAP_NR((unsigned long)virtual)];\n\t\tpam->page = page;\n\t\tpam->virtual = virtual;\n\n\t\tspin_lock_irqsave(&pas->lock, flags);\n\t\tlist_add_tail(&pam->list, &pas->lh);\n\t\tspin_unlock_irqrestore(&pas->lock, flags);\n\t} else {\t\t/* Remove */\n\t\tspin_lock_irqsave(&pas->lock, flags);\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tlist_del(&pam->list);\n\t\t\t\tspin_unlock_irqrestore(&pas->lock, flags);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&pas->lock, flags);\n\t}\ndone:\n\treturn;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid set_page_address(struct page *page, void *virtual)\n{\n\tunsigned long flags;\n\tstruct page_address_slot *pas;\n\tstruct page_address_map *pam;\n\n\tBUG_ON(!PageHighMem(page));\n\n\tpas = page_slot(page);\n\tif (virtual) {\t\t/* Add */\n\t\tpam = &page_address_maps[PKMAP_NR((unsigned long)virtual)];\n\t\tpam->page = page;\n\t\tpam->virtual = virtual;\n\n\t\tspin_lock_irqsave(&pas->lock, flags);\n\t\tlist_add_tail(&pam->list, &pas->lh);\n\t\tspin_unlock_irqrestore(&pas->lock, flags);\n\t} else {\t\t/* Remove */\n\t\tspin_lock_irqsave(&pas->lock, flags);\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tlist_del(&pam->list);\n\t\t\t\tspin_unlock_irqrestore(&pas->lock, flags);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&pas->lock, flags);\n\t}\ndone:\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_pte_at",
          "args": [
            "&init_mm",
            "vaddr",
            "&(pkmap_page_table[last_pkmap_nr])",
            "mk_pte(page, kmap_prot)"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mk_pte",
          "args": [
            "page",
            "kmap_prot"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PKMAP_ADDR",
          "args": [
            "last_pkmap_nr"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "page_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "409-434",
          "snippet": "void *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_kmap",
          "args": [],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_wait_queue",
          "args": [
            "pkmap_map_wait",
            "&wait"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_schedule_balance_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "191-195",
          "snippet": "static void pcpu_schedule_balance_work(void)\n{\n\tif (pcpu_async_enabled)\n\t\tschedule_work(&pcpu_balance_work);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool pcpu_async_enabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic bool pcpu_async_enabled;\n\nstatic void pcpu_schedule_balance_work(void)\n{\n\tif (pcpu_async_enabled)\n\t\tschedule_work(&pcpu_balance_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_kmap",
          "args": [],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wait_queue",
          "args": [
            "pkmap_map_wait",
            "&wait"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pkmap_wait_queue_head",
          "args": [
            "color"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "get_pkmap_wait_queue_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "100-105",
          "snippet": "static inline wait_queue_head_t *get_pkmap_wait_queue_head(unsigned int color)\n{\n\tstatic DECLARE_WAIT_QUEUE_HEAD(pkmap_map_wait);\n\n\treturn &pkmap_map_wait;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstatic inline wait_queue_head_t *get_pkmap_wait_queue_head(unsigned int color)\n{\n\tstatic DECLARE_WAIT_QUEUE_HEAD(pkmap_map_wait);\n\n\treturn &pkmap_map_wait;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DECLARE_WAITQUEUE",
          "args": [
            "wait",
            "current"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pkmap_entries_count",
          "args": [
            "color"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "get_pkmap_entries_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "90-93",
          "snippet": "static inline int get_pkmap_entries_count(unsigned int color)\n{\n\treturn LAST_PKMAP;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstatic inline int get_pkmap_entries_count(unsigned int color)\n{\n\treturn LAST_PKMAP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_all_zero_pkmaps",
          "args": [],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "flush_all_zero_pkmaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "164-202",
          "snippet": "static void flush_all_zero_pkmaps(void)\n{\n\tint i;\n\tint need_flush = 0;\n\n\tflush_cache_kmaps();\n\n\tfor (i = 0; i < LAST_PKMAP; i++) {\n\t\tstruct page *page;\n\n\t\t/*\n\t\t * zero means we don't have anything to do,\n\t\t * >1 means that it is still in use. Only\n\t\t * a count of 1 means that it is free but\n\t\t * needs to be unmapped\n\t\t */\n\t\tif (pkmap_count[i] != 1)\n\t\t\tcontinue;\n\t\tpkmap_count[i] = 0;\n\n\t\t/* sanity check */\n\t\tBUG_ON(pte_none(pkmap_page_table[i]));\n\n\t\t/*\n\t\t * Don't need an atomic fetch-and-clear op here;\n\t\t * no-one has the page mapped, and cannot get at\n\t\t * its virtual address (and hence PTE) without first\n\t\t * getting the kmap_lock (which is held here).\n\t\t * So no dangers, even with speculative execution.\n\t\t */\n\t\tpage = pte_page(pkmap_page_table[i]);\n\t\tpte_clear(&init_mm, PKMAP_ADDR(i), &pkmap_page_table[i]);\n\n\t\tset_page_address(page, NULL);\n\t\tneed_flush = 1;\n\t}\n\tif (need_flush)\n\t\tflush_tlb_kernel_range(PKMAP_ADDR(0), PKMAP_ADDR(LAST_PKMAP));\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstatic void flush_all_zero_pkmaps(void)\n{\n\tint i;\n\tint need_flush = 0;\n\n\tflush_cache_kmaps();\n\n\tfor (i = 0; i < LAST_PKMAP; i++) {\n\t\tstruct page *page;\n\n\t\t/*\n\t\t * zero means we don't have anything to do,\n\t\t * >1 means that it is still in use. Only\n\t\t * a count of 1 means that it is free but\n\t\t * needs to be unmapped\n\t\t */\n\t\tif (pkmap_count[i] != 1)\n\t\t\tcontinue;\n\t\tpkmap_count[i] = 0;\n\n\t\t/* sanity check */\n\t\tBUG_ON(pte_none(pkmap_page_table[i]));\n\n\t\t/*\n\t\t * Don't need an atomic fetch-and-clear op here;\n\t\t * no-one has the page mapped, and cannot get at\n\t\t * its virtual address (and hence PTE) without first\n\t\t * getting the kmap_lock (which is held here).\n\t\t * So no dangers, even with speculative execution.\n\t\t */\n\t\tpage = pte_page(pkmap_page_table[i]);\n\t\tpte_clear(&init_mm, PKMAP_ADDR(i), &pkmap_page_table[i]);\n\n\t\tset_page_address(page, NULL);\n\t\tneed_flush = 1;\n\t}\n\tif (need_flush)\n\t\tflush_tlb_kernel_range(PKMAP_ADDR(0), PKMAP_ADDR(LAST_PKMAP));\n}"
        }
      },
      {
        "call_info": {
          "callee": "no_more_pkmaps",
          "args": [
            "last_pkmap_nr",
            "color"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "no_more_pkmaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "80-83",
          "snippet": "static inline int no_more_pkmaps(unsigned int pkmap_nr, unsigned int color)\n{\n\treturn pkmap_nr == 0;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstatic inline int no_more_pkmaps(unsigned int pkmap_nr, unsigned int color)\n{\n\treturn pkmap_nr == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_next_pkmap_nr",
          "args": [
            "color"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "get_next_pkmap_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "67-73",
          "snippet": "static inline unsigned int get_next_pkmap_nr(unsigned int color)\n{\n\tstatic unsigned int last_pkmap_nr;\n\n\tlast_pkmap_nr = (last_pkmap_nr + 1) & LAST_PKMAP_MASK;\n\treturn last_pkmap_nr;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstatic inline unsigned int get_next_pkmap_nr(unsigned int color)\n{\n\tstatic unsigned int last_pkmap_nr;\n\n\tlast_pkmap_nr = (last_pkmap_nr + 1) & LAST_PKMAP_MASK;\n\treturn last_pkmap_nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pkmap_color",
          "args": [
            "page"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "get_pkmap_color",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "58-61",
          "snippet": "static inline unsigned int get_pkmap_color(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define get_pkmap_color get_pkmap_color"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\n#define get_pkmap_color get_pkmap_color\n\nstatic inline unsigned int get_pkmap_color(struct page *page)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\n#define get_pkmap_color get_pkmap_color\n\nstatic inline unsigned long map_new_virtual(struct page *page)\n{\n\tunsigned long vaddr;\n\tint count;\n\tunsigned int last_pkmap_nr;\n\tunsigned int color = get_pkmap_color(page);\n\nstart:\n\tcount = get_pkmap_entries_count(color);\n\t/* Find an empty entry */\n\tfor (;;) {\n\t\tlast_pkmap_nr = get_next_pkmap_nr(color);\n\t\tif (no_more_pkmaps(last_pkmap_nr, color)) {\n\t\t\tflush_all_zero_pkmaps();\n\t\t\tcount = get_pkmap_entries_count(color);\n\t\t}\n\t\tif (!pkmap_count[last_pkmap_nr])\n\t\t\tbreak;\t/* Found a usable entry */\n\t\tif (--count)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Sleep for somebody else to unmap their entries\n\t\t */\n\t\t{\n\t\t\tDECLARE_WAITQUEUE(wait, current);\n\t\t\twait_queue_head_t *pkmap_map_wait =\n\t\t\t\tget_pkmap_wait_queue_head(color);\n\n\t\t\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tadd_wait_queue(pkmap_map_wait, &wait);\n\t\t\tunlock_kmap();\n\t\t\tschedule();\n\t\t\tremove_wait_queue(pkmap_map_wait, &wait);\n\t\t\tlock_kmap();\n\n\t\t\t/* Somebody else might have mapped it while we slept */\n\t\t\tif (page_address(page))\n\t\t\t\treturn (unsigned long)page_address(page);\n\n\t\t\t/* Re-start */\n\t\t\tgoto start;\n\t\t}\n\t}\n\tvaddr = PKMAP_ADDR(last_pkmap_nr);\n\tset_pte_at(&init_mm, vaddr,\n\t\t   &(pkmap_page_table[last_pkmap_nr]), mk_pte(page, kmap_prot));\n\n\tpkmap_count[last_pkmap_nr] = 1;\n\tset_page_address(page, (void *)vaddr);\n\n\treturn vaddr;\n}"
  },
  {
    "function_name": "kmap_flush_unused",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
    "lines": "207-212",
    "snippet": "void kmap_flush_unused(void)\n{\n\tlock_kmap();\n\tflush_all_zero_pkmaps();\n\tunlock_kmap();\n}",
    "includes": [
      "#include <asm/tlbflush.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/bio.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_kmap",
          "args": [],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_all_zero_pkmaps",
          "args": [],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "flush_all_zero_pkmaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "164-202",
          "snippet": "static void flush_all_zero_pkmaps(void)\n{\n\tint i;\n\tint need_flush = 0;\n\n\tflush_cache_kmaps();\n\n\tfor (i = 0; i < LAST_PKMAP; i++) {\n\t\tstruct page *page;\n\n\t\t/*\n\t\t * zero means we don't have anything to do,\n\t\t * >1 means that it is still in use. Only\n\t\t * a count of 1 means that it is free but\n\t\t * needs to be unmapped\n\t\t */\n\t\tif (pkmap_count[i] != 1)\n\t\t\tcontinue;\n\t\tpkmap_count[i] = 0;\n\n\t\t/* sanity check */\n\t\tBUG_ON(pte_none(pkmap_page_table[i]));\n\n\t\t/*\n\t\t * Don't need an atomic fetch-and-clear op here;\n\t\t * no-one has the page mapped, and cannot get at\n\t\t * its virtual address (and hence PTE) without first\n\t\t * getting the kmap_lock (which is held here).\n\t\t * So no dangers, even with speculative execution.\n\t\t */\n\t\tpage = pte_page(pkmap_page_table[i]);\n\t\tpte_clear(&init_mm, PKMAP_ADDR(i), &pkmap_page_table[i]);\n\n\t\tset_page_address(page, NULL);\n\t\tneed_flush = 1;\n\t}\n\tif (need_flush)\n\t\tflush_tlb_kernel_range(PKMAP_ADDR(0), PKMAP_ADDR(LAST_PKMAP));\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstatic void flush_all_zero_pkmaps(void)\n{\n\tint i;\n\tint need_flush = 0;\n\n\tflush_cache_kmaps();\n\n\tfor (i = 0; i < LAST_PKMAP; i++) {\n\t\tstruct page *page;\n\n\t\t/*\n\t\t * zero means we don't have anything to do,\n\t\t * >1 means that it is still in use. Only\n\t\t * a count of 1 means that it is free but\n\t\t * needs to be unmapped\n\t\t */\n\t\tif (pkmap_count[i] != 1)\n\t\t\tcontinue;\n\t\tpkmap_count[i] = 0;\n\n\t\t/* sanity check */\n\t\tBUG_ON(pte_none(pkmap_page_table[i]));\n\n\t\t/*\n\t\t * Don't need an atomic fetch-and-clear op here;\n\t\t * no-one has the page mapped, and cannot get at\n\t\t * its virtual address (and hence PTE) without first\n\t\t * getting the kmap_lock (which is held here).\n\t\t * So no dangers, even with speculative execution.\n\t\t */\n\t\tpage = pte_page(pkmap_page_table[i]);\n\t\tpte_clear(&init_mm, PKMAP_ADDR(i), &pkmap_page_table[i]);\n\n\t\tset_page_address(page, NULL);\n\t\tneed_flush = 1;\n\t}\n\tif (need_flush)\n\t\tflush_tlb_kernel_range(PKMAP_ADDR(0), PKMAP_ADDR(LAST_PKMAP));\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_kmap",
          "args": [],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid kmap_flush_unused(void)\n{\n\tlock_kmap();\n\tflush_all_zero_pkmaps();\n\tunlock_kmap();\n}"
  },
  {
    "function_name": "flush_all_zero_pkmaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
    "lines": "164-202",
    "snippet": "static void flush_all_zero_pkmaps(void)\n{\n\tint i;\n\tint need_flush = 0;\n\n\tflush_cache_kmaps();\n\n\tfor (i = 0; i < LAST_PKMAP; i++) {\n\t\tstruct page *page;\n\n\t\t/*\n\t\t * zero means we don't have anything to do,\n\t\t * >1 means that it is still in use. Only\n\t\t * a count of 1 means that it is free but\n\t\t * needs to be unmapped\n\t\t */\n\t\tif (pkmap_count[i] != 1)\n\t\t\tcontinue;\n\t\tpkmap_count[i] = 0;\n\n\t\t/* sanity check */\n\t\tBUG_ON(pte_none(pkmap_page_table[i]));\n\n\t\t/*\n\t\t * Don't need an atomic fetch-and-clear op here;\n\t\t * no-one has the page mapped, and cannot get at\n\t\t * its virtual address (and hence PTE) without first\n\t\t * getting the kmap_lock (which is held here).\n\t\t * So no dangers, even with speculative execution.\n\t\t */\n\t\tpage = pte_page(pkmap_page_table[i]);\n\t\tpte_clear(&init_mm, PKMAP_ADDR(i), &pkmap_page_table[i]);\n\n\t\tset_page_address(page, NULL);\n\t\tneed_flush = 1;\n\t}\n\tif (need_flush)\n\t\tflush_tlb_kernel_range(PKMAP_ADDR(0), PKMAP_ADDR(LAST_PKMAP));\n}",
    "includes": [
      "#include <asm/tlbflush.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/bio.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_tlb_kernel_range",
          "args": [
            "PKMAP_ADDR(0)",
            "PKMAP_ADDR(LAST_PKMAP)"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PKMAP_ADDR",
          "args": [
            "LAST_PKMAP"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PKMAP_ADDR",
          "args": [
            "0"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_address",
          "args": [
            "page",
            "NULL"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "443-473",
          "snippet": "void set_page_address(struct page *page, void *virtual)\n{\n\tunsigned long flags;\n\tstruct page_address_slot *pas;\n\tstruct page_address_map *pam;\n\n\tBUG_ON(!PageHighMem(page));\n\n\tpas = page_slot(page);\n\tif (virtual) {\t\t/* Add */\n\t\tpam = &page_address_maps[PKMAP_NR((unsigned long)virtual)];\n\t\tpam->page = page;\n\t\tpam->virtual = virtual;\n\n\t\tspin_lock_irqsave(&pas->lock, flags);\n\t\tlist_add_tail(&pam->list, &pas->lh);\n\t\tspin_unlock_irqrestore(&pas->lock, flags);\n\t} else {\t\t/* Remove */\n\t\tspin_lock_irqsave(&pas->lock, flags);\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tlist_del(&pam->list);\n\t\t\t\tspin_unlock_irqrestore(&pas->lock, flags);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&pas->lock, flags);\n\t}\ndone:\n\treturn;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid set_page_address(struct page *page, void *virtual)\n{\n\tunsigned long flags;\n\tstruct page_address_slot *pas;\n\tstruct page_address_map *pam;\n\n\tBUG_ON(!PageHighMem(page));\n\n\tpas = page_slot(page);\n\tif (virtual) {\t\t/* Add */\n\t\tpam = &page_address_maps[PKMAP_NR((unsigned long)virtual)];\n\t\tpam->page = page;\n\t\tpam->virtual = virtual;\n\n\t\tspin_lock_irqsave(&pas->lock, flags);\n\t\tlist_add_tail(&pam->list, &pas->lh);\n\t\tspin_unlock_irqrestore(&pas->lock, flags);\n\t} else {\t\t/* Remove */\n\t\tspin_lock_irqsave(&pas->lock, flags);\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tlist_del(&pam->list);\n\t\t\t\tspin_unlock_irqrestore(&pas->lock, flags);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&pas->lock, flags);\n\t}\ndone:\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_clear",
          "args": [
            "&init_mm",
            "PKMAP_ADDR(i)",
            "&pkmap_page_table[i]"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PKMAP_ADDR",
          "args": [
            "i"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_page",
          "args": [
            "pkmap_page_table[i]"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "release_pte_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "504-509",
          "snippet": "static void release_pte_page(struct page *page)\n{\n\tdec_node_page_state(page, NR_ISOLATED_ANON + page_is_file_cache(page));\n\tunlock_page(page);\n\tputback_lru_page(page);\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void release_pte_page(struct page *page)\n{\n\tdec_node_page_state(page, NR_ISOLATED_ANON + page_is_file_cache(page));\n\tunlock_page(page);\n\tputback_lru_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pte_none(pkmap_page_table[i])"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_none",
          "args": [
            "pkmap_page_table[i]"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_cache_kmaps",
          "args": [],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstatic void flush_all_zero_pkmaps(void)\n{\n\tint i;\n\tint need_flush = 0;\n\n\tflush_cache_kmaps();\n\n\tfor (i = 0; i < LAST_PKMAP; i++) {\n\t\tstruct page *page;\n\n\t\t/*\n\t\t * zero means we don't have anything to do,\n\t\t * >1 means that it is still in use. Only\n\t\t * a count of 1 means that it is free but\n\t\t * needs to be unmapped\n\t\t */\n\t\tif (pkmap_count[i] != 1)\n\t\t\tcontinue;\n\t\tpkmap_count[i] = 0;\n\n\t\t/* sanity check */\n\t\tBUG_ON(pte_none(pkmap_page_table[i]));\n\n\t\t/*\n\t\t * Don't need an atomic fetch-and-clear op here;\n\t\t * no-one has the page mapped, and cannot get at\n\t\t * its virtual address (and hence PTE) without first\n\t\t * getting the kmap_lock (which is held here).\n\t\t * So no dangers, even with speculative execution.\n\t\t */\n\t\tpage = pte_page(pkmap_page_table[i]);\n\t\tpte_clear(&init_mm, PKMAP_ADDR(i), &pkmap_page_table[i]);\n\n\t\tset_page_address(page, NULL);\n\t\tneed_flush = 1;\n\t}\n\tif (need_flush)\n\t\tflush_tlb_kernel_range(PKMAP_ADDR(0), PKMAP_ADDR(LAST_PKMAP));\n}"
  },
  {
    "function_name": "kmap_to_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
    "lines": "151-161",
    "snippet": "struct page *kmap_to_page(void *vaddr)\n{\n\tunsigned long addr = (unsigned long)vaddr;\n\n\tif (addr >= PKMAP_ADDR(0) && addr < PKMAP_ADDR(LAST_PKMAP)) {\n\t\tint i = PKMAP_NR(addr);\n\t\treturn pte_page(pkmap_page_table[i]);\n\t}\n\n\treturn virt_to_page(addr);\n}",
    "includes": [
      "#include <asm/tlbflush.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/bio.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "addr"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_page",
          "args": [
            "pkmap_page_table[i]"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "release_pte_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "504-509",
          "snippet": "static void release_pte_page(struct page *page)\n{\n\tdec_node_page_state(page, NR_ISOLATED_ANON + page_is_file_cache(page));\n\tunlock_page(page);\n\tputback_lru_page(page);\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void release_pte_page(struct page *page)\n{\n\tdec_node_page_state(page, NR_ISOLATED_ANON + page_is_file_cache(page));\n\tunlock_page(page);\n\tputback_lru_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PKMAP_NR",
          "args": [
            "addr"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PKMAP_ADDR",
          "args": [
            "LAST_PKMAP"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PKMAP_ADDR",
          "args": [
            "0"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct page *kmap_to_page(void *vaddr)\n{\n\tunsigned long addr = (unsigned long)vaddr;\n\n\tif (addr >= PKMAP_ADDR(0) && addr < PKMAP_ADDR(LAST_PKMAP)) {\n\t\tint i = PKMAP_NR(addr);\n\t\treturn pte_page(pkmap_page_table[i]);\n\t}\n\n\treturn virt_to_page(addr);\n}"
  },
  {
    "function_name": "nr_free_highpages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
    "lines": "114-125",
    "snippet": "unsigned int nr_free_highpages (void)\n{\n\tstruct zone *zone;\n\tunsigned int pages = 0;\n\n\tfor_each_populated_zone(zone) {\n\t\tif (is_highmem(zone))\n\t\t\tpages += zone_page_state(zone, NR_FREE_PAGES);\n\t}\n\n\treturn pages;\n}",
    "includes": [
      "#include <asm/tlbflush.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/bio.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zone_page_state",
          "args": [
            "zone",
            "NR_FREE_PAGES"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "dec_zone_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "624-631",
          "snippet": "void dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_zone_page_state(page, item);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_zone_page_state(page, item);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_highmem",
          "args": [
            "zone"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nunsigned int nr_free_highpages (void)\n{\n\tstruct zone *zone;\n\tunsigned int pages = 0;\n\n\tfor_each_populated_zone(zone) {\n\t\tif (is_highmem(zone))\n\t\t\tpages += zone_page_state(zone, NR_FREE_PAGES);\n\t}\n\n\treturn pages;\n}"
  },
  {
    "function_name": "get_pkmap_wait_queue_head",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
    "lines": "100-105",
    "snippet": "static inline wait_queue_head_t *get_pkmap_wait_queue_head(unsigned int color)\n{\n\tstatic DECLARE_WAIT_QUEUE_HEAD(pkmap_map_wait);\n\n\treturn &pkmap_map_wait;\n}",
    "includes": [
      "#include <asm/tlbflush.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/bio.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstatic inline wait_queue_head_t *get_pkmap_wait_queue_head(unsigned int color)\n{\n\tstatic DECLARE_WAIT_QUEUE_HEAD(pkmap_map_wait);\n\n\treturn &pkmap_map_wait;\n}"
  },
  {
    "function_name": "get_pkmap_entries_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
    "lines": "90-93",
    "snippet": "static inline int get_pkmap_entries_count(unsigned int color)\n{\n\treturn LAST_PKMAP;\n}",
    "includes": [
      "#include <asm/tlbflush.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/bio.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstatic inline int get_pkmap_entries_count(unsigned int color)\n{\n\treturn LAST_PKMAP;\n}"
  },
  {
    "function_name": "no_more_pkmaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
    "lines": "80-83",
    "snippet": "static inline int no_more_pkmaps(unsigned int pkmap_nr, unsigned int color)\n{\n\treturn pkmap_nr == 0;\n}",
    "includes": [
      "#include <asm/tlbflush.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/bio.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstatic inline int no_more_pkmaps(unsigned int pkmap_nr, unsigned int color)\n{\n\treturn pkmap_nr == 0;\n}"
  },
  {
    "function_name": "get_next_pkmap_nr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
    "lines": "67-73",
    "snippet": "static inline unsigned int get_next_pkmap_nr(unsigned int color)\n{\n\tstatic unsigned int last_pkmap_nr;\n\n\tlast_pkmap_nr = (last_pkmap_nr + 1) & LAST_PKMAP_MASK;\n\treturn last_pkmap_nr;\n}",
    "includes": [
      "#include <asm/tlbflush.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/bio.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstatic inline unsigned int get_next_pkmap_nr(unsigned int color)\n{\n\tstatic unsigned int last_pkmap_nr;\n\n\tlast_pkmap_nr = (last_pkmap_nr + 1) & LAST_PKMAP_MASK;\n\treturn last_pkmap_nr;\n}"
  },
  {
    "function_name": "get_pkmap_color",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
    "lines": "58-61",
    "snippet": "static inline unsigned int get_pkmap_color(struct page *page)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <asm/tlbflush.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/highmem.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/mempool.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/bio.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define get_pkmap_color get_pkmap_color"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\n#define get_pkmap_color get_pkmap_color\n\nstatic inline unsigned int get_pkmap_color(struct page *page)\n{\n\treturn 0;\n}"
  }
]