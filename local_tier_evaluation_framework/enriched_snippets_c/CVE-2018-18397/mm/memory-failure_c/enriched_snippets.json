[
  {
    "function_name": "soft_offline_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "1895-1925",
    "snippet": "int soft_offline_page(struct page *page, int flags)\n{\n\tint ret;\n\tunsigned long pfn = page_to_pfn(page);\n\n\tif (is_zone_device_page(page)) {\n\t\tpr_debug_ratelimited(\"soft_offline: %#lx page is device page\\n\",\n\t\t\t\tpfn);\n\t\tif (flags & MF_COUNT_INCREASED)\n\t\t\tput_page(page);\n\t\treturn -EIO;\n\t}\n\n\tif (PageHWPoison(page)) {\n\t\tpr_info(\"soft offline: %#lx page already poisoned\\n\", pfn);\n\t\tif (flags & MF_COUNT_INCREASED)\n\t\t\tput_hwpoison_page(page);\n\t\treturn -EBUSY;\n\t}\n\n\tget_online_mems();\n\tret = get_any_page(page, pfn, flags);\n\tput_online_mems();\n\n\tif (ret > 0)\n\t\tret = soft_offline_in_use_page(page, flags);\n\telse if (ret == 0)\n\t\tret = soft_offline_free_page(page);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "soft_offline_free_page",
          "args": [
            "page"
          ],
          "line": 1922
        },
        "resolved": true,
        "details": {
          "function_name": "soft_offline_free_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "1857-1871",
          "snippet": "static int soft_offline_free_page(struct page *page)\n{\n\tint rc = 0;\n\tstruct page *head = compound_head(page);\n\n\tif (PageHuge(head))\n\t\trc = dissolve_free_huge_page(page);\n\tif (!rc) {\n\t\tif (set_hwpoison_free_buddy_page(page))\n\t\t\tnum_poisoned_pages_inc();\n\t\telse\n\t\t\trc = -EBUSY;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define head\t\t(1UL << PG_head)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define head\t\t(1UL << PG_head)\n\nstatic int soft_offline_free_page(struct page *page)\n{\n\tint rc = 0;\n\tstruct page *head = compound_head(page);\n\n\tif (PageHuge(head))\n\t\trc = dissolve_free_huge_page(page);\n\tif (!rc) {\n\t\tif (set_hwpoison_free_buddy_page(page))\n\t\t\tnum_poisoned_pages_inc();\n\t\telse\n\t\t\trc = -EBUSY;\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "soft_offline_in_use_page",
          "args": [
            "page",
            "flags"
          ],
          "line": 1920
        },
        "resolved": true,
        "details": {
          "function_name": "soft_offline_in_use_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "1818-1855",
          "snippet": "static int soft_offline_in_use_page(struct page *page, int flags)\n{\n\tint ret;\n\tint mt;\n\tstruct page *hpage = compound_head(page);\n\n\tif (!PageHuge(page) && PageTransHuge(hpage)) {\n\t\tlock_page(hpage);\n\t\tif (!PageAnon(hpage) || unlikely(split_huge_page(hpage))) {\n\t\t\tunlock_page(hpage);\n\t\t\tif (!PageAnon(hpage))\n\t\t\t\tpr_info(\"soft offline: %#lx: non anonymous thp\\n\", page_to_pfn(page));\n\t\t\telse\n\t\t\t\tpr_info(\"soft offline: %#lx: thp split failed\\n\", page_to_pfn(page));\n\t\t\tput_hwpoison_page(hpage);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tunlock_page(hpage);\n\t\tget_hwpoison_page(page);\n\t\tput_hwpoison_page(hpage);\n\t}\n\n\t/*\n\t * Setting MIGRATE_ISOLATE here ensures that the page will be linked\n\t * to free list immediately (not via pcplist) when released after\n\t * successful page migration. Otherwise we can't guarantee that the\n\t * page is really free after put_page() returns, so\n\t * set_hwpoison_free_buddy_page() highly likely fails.\n\t */\n\tmt = get_pageblock_migratetype(page);\n\tset_pageblock_migratetype(page, MIGRATE_ISOLATE);\n\tif (PageHuge(page))\n\t\tret = soft_offline_huge_page(page, flags);\n\telse\n\t\tret = __soft_offline_page(page, flags);\n\tset_pageblock_migratetype(page, mt);\n\treturn ret;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int soft_offline_in_use_page(struct page *page, int flags)\n{\n\tint ret;\n\tint mt;\n\tstruct page *hpage = compound_head(page);\n\n\tif (!PageHuge(page) && PageTransHuge(hpage)) {\n\t\tlock_page(hpage);\n\t\tif (!PageAnon(hpage) || unlikely(split_huge_page(hpage))) {\n\t\t\tunlock_page(hpage);\n\t\t\tif (!PageAnon(hpage))\n\t\t\t\tpr_info(\"soft offline: %#lx: non anonymous thp\\n\", page_to_pfn(page));\n\t\t\telse\n\t\t\t\tpr_info(\"soft offline: %#lx: thp split failed\\n\", page_to_pfn(page));\n\t\t\tput_hwpoison_page(hpage);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tunlock_page(hpage);\n\t\tget_hwpoison_page(page);\n\t\tput_hwpoison_page(hpage);\n\t}\n\n\t/*\n\t * Setting MIGRATE_ISOLATE here ensures that the page will be linked\n\t * to free list immediately (not via pcplist) when released after\n\t * successful page migration. Otherwise we can't guarantee that the\n\t * page is really free after put_page() returns, so\n\t * set_hwpoison_free_buddy_page() highly likely fails.\n\t */\n\tmt = get_pageblock_migratetype(page);\n\tset_pageblock_migratetype(page, MIGRATE_ISOLATE);\n\tif (PageHuge(page))\n\t\tret = soft_offline_huge_page(page, flags);\n\telse\n\t\tret = __soft_offline_page(page, flags);\n\tset_pageblock_migratetype(page, mt);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_online_mems",
          "args": [],
          "line": 1917
        },
        "resolved": true,
        "details": {
          "function_name": "put_online_mems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "61-64",
          "snippet": "void put_online_mems(void)\n{\n\tpercpu_up_read(&mem_hotplug_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid put_online_mems(void)\n{\n\tpercpu_up_read(&mem_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_any_page",
          "args": [
            "page",
            "pfn",
            "flags"
          ],
          "line": 1916
        },
        "resolved": true,
        "details": {
          "function_name": "get_any_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "1654-1679",
          "snippet": "static int get_any_page(struct page *page, unsigned long pfn, int flags)\n{\n\tint ret = __get_any_page(page, pfn, flags);\n\n\tif (ret == 1 && !PageHuge(page) &&\n\t    !PageLRU(page) && !__PageMovable(page)) {\n\t\t/*\n\t\t * Try to free it.\n\t\t */\n\t\tput_hwpoison_page(page);\n\t\tshake_page(page, 1);\n\n\t\t/*\n\t\t * Did it turn free?\n\t\t */\n\t\tret = __get_any_page(page, pfn, 0);\n\t\tif (ret == 1 && !PageLRU(page)) {\n\t\t\t/* Drop page reference which is from __get_any_page() */\n\t\t\tput_hwpoison_page(page);\n\t\t\tpr_info(\"soft_offline: %#lx: unknown non LRU page type %lx (%pGp)\\n\",\n\t\t\t\tpfn, page->flags, &page->flags);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int get_any_page(struct page *page, unsigned long pfn, int flags)\n{\n\tint ret = __get_any_page(page, pfn, flags);\n\n\tif (ret == 1 && !PageHuge(page) &&\n\t    !PageLRU(page) && !__PageMovable(page)) {\n\t\t/*\n\t\t * Try to free it.\n\t\t */\n\t\tput_hwpoison_page(page);\n\t\tshake_page(page, 1);\n\n\t\t/*\n\t\t * Did it turn free?\n\t\t */\n\t\tret = __get_any_page(page, pfn, 0);\n\t\tif (ret == 1 && !PageLRU(page)) {\n\t\t\t/* Drop page reference which is from __get_any_page() */\n\t\t\tput_hwpoison_page(page);\n\t\t\tpr_info(\"soft_offline: %#lx: unknown non LRU page type %lx (%pGp)\\n\",\n\t\t\t\tpfn, page->flags, &page->flags);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_online_mems",
          "args": [],
          "line": 1915
        },
        "resolved": true,
        "details": {
          "function_name": "get_online_mems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "56-59",
          "snippet": "void get_online_mems(void)\n{\n\tpercpu_down_read(&mem_hotplug_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid get_online_mems(void)\n{\n\tpercpu_down_read(&mem_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_hwpoison_page",
          "args": [
            "page"
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"soft offline: %#lx page already poisoned\\n\"",
            "pfn"
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHWPoison",
          "args": [
            "page"
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 1904
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug_ratelimited",
          "args": [
            "\"soft_offline: %#lx page is device page\\n\"",
            "pfn"
          ],
          "line": 1901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_zone_device_page",
          "args": [
            "page"
          ],
          "line": 1900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 1898
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint soft_offline_page(struct page *page, int flags)\n{\n\tint ret;\n\tunsigned long pfn = page_to_pfn(page);\n\n\tif (is_zone_device_page(page)) {\n\t\tpr_debug_ratelimited(\"soft_offline: %#lx page is device page\\n\",\n\t\t\t\tpfn);\n\t\tif (flags & MF_COUNT_INCREASED)\n\t\t\tput_page(page);\n\t\treturn -EIO;\n\t}\n\n\tif (PageHWPoison(page)) {\n\t\tpr_info(\"soft offline: %#lx page already poisoned\\n\", pfn);\n\t\tif (flags & MF_COUNT_INCREASED)\n\t\t\tput_hwpoison_page(page);\n\t\treturn -EBUSY;\n\t}\n\n\tget_online_mems();\n\tret = get_any_page(page, pfn, flags);\n\tput_online_mems();\n\n\tif (ret > 0)\n\t\tret = soft_offline_in_use_page(page, flags);\n\telse if (ret == 0)\n\t\tret = soft_offline_free_page(page);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "soft_offline_free_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "1857-1871",
    "snippet": "static int soft_offline_free_page(struct page *page)\n{\n\tint rc = 0;\n\tstruct page *head = compound_head(page);\n\n\tif (PageHuge(head))\n\t\trc = dissolve_free_huge_page(page);\n\tif (!rc) {\n\t\tif (set_hwpoison_free_buddy_page(page))\n\t\t\tnum_poisoned_pages_inc();\n\t\telse\n\t\t\trc = -EBUSY;\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define head\t\t(1UL << PG_head)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "num_poisoned_pages_inc",
          "args": [],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_hwpoison_free_buddy_page",
          "args": [
            "page"
          ],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dissolve_free_huge_page",
          "args": [
            "page"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "dissolve_free_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1485-1514",
          "snippet": "int dissolve_free_huge_page(struct page *page)\n{\n\tint rc = -EBUSY;\n\n\tspin_lock(&hugetlb_lock);\n\tif (PageHuge(page) && !page_count(page)) {\n\t\tstruct page *head = compound_head(page);\n\t\tstruct hstate *h = page_hstate(head);\n\t\tint nid = page_to_nid(head);\n\t\tif (h->free_huge_pages - h->resv_huge_pages == 0)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Move PageHWPoison flag from head page to the raw error page,\n\t\t * which makes any subpages rather than the error page reusable.\n\t\t */\n\t\tif (PageHWPoison(head) && page != head) {\n\t\t\tSetPageHWPoison(page);\n\t\t\tClearPageHWPoison(head);\n\t\t}\n\t\tlist_del(&head->lru);\n\t\th->free_huge_pages--;\n\t\th->free_huge_pages_node[nid]--;\n\t\th->max_huge_pages--;\n\t\tupdate_and_free_page(h, head);\n\t\trc = 0;\n\t}\nout:\n\tspin_unlock(&hugetlb_lock);\n\treturn rc;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint dissolve_free_huge_page(struct page *page)\n{\n\tint rc = -EBUSY;\n\n\tspin_lock(&hugetlb_lock);\n\tif (PageHuge(page) && !page_count(page)) {\n\t\tstruct page *head = compound_head(page);\n\t\tstruct hstate *h = page_hstate(head);\n\t\tint nid = page_to_nid(head);\n\t\tif (h->free_huge_pages - h->resv_huge_pages == 0)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Move PageHWPoison flag from head page to the raw error page,\n\t\t * which makes any subpages rather than the error page reusable.\n\t\t */\n\t\tif (PageHWPoison(head) && page != head) {\n\t\t\tSetPageHWPoison(page);\n\t\t\tClearPageHWPoison(head);\n\t\t}\n\t\tlist_del(&head->lru);\n\t\th->free_huge_pages--;\n\t\th->free_huge_pages_node[nid]--;\n\t\th->max_huge_pages--;\n\t\tupdate_and_free_page(h, head);\n\t\trc = 0;\n\t}\nout:\n\tspin_unlock(&hugetlb_lock);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "head"
          ],
          "line": 1862
        },
        "resolved": true,
        "details": {
          "function_name": "PageHugeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "225-228",
          "snippet": "static int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define head\t\t(1UL << PG_head)\n\nstatic int soft_offline_free_page(struct page *page)\n{\n\tint rc = 0;\n\tstruct page *head = compound_head(page);\n\n\tif (PageHuge(head))\n\t\trc = dissolve_free_huge_page(page);\n\tif (!rc) {\n\t\tif (set_hwpoison_free_buddy_page(page))\n\t\t\tnum_poisoned_pages_inc();\n\t\telse\n\t\t\trc = -EBUSY;\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "soft_offline_in_use_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "1818-1855",
    "snippet": "static int soft_offline_in_use_page(struct page *page, int flags)\n{\n\tint ret;\n\tint mt;\n\tstruct page *hpage = compound_head(page);\n\n\tif (!PageHuge(page) && PageTransHuge(hpage)) {\n\t\tlock_page(hpage);\n\t\tif (!PageAnon(hpage) || unlikely(split_huge_page(hpage))) {\n\t\t\tunlock_page(hpage);\n\t\t\tif (!PageAnon(hpage))\n\t\t\t\tpr_info(\"soft offline: %#lx: non anonymous thp\\n\", page_to_pfn(page));\n\t\t\telse\n\t\t\t\tpr_info(\"soft offline: %#lx: thp split failed\\n\", page_to_pfn(page));\n\t\t\tput_hwpoison_page(hpage);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tunlock_page(hpage);\n\t\tget_hwpoison_page(page);\n\t\tput_hwpoison_page(hpage);\n\t}\n\n\t/*\n\t * Setting MIGRATE_ISOLATE here ensures that the page will be linked\n\t * to free list immediately (not via pcplist) when released after\n\t * successful page migration. Otherwise we can't guarantee that the\n\t * page is really free after put_page() returns, so\n\t * set_hwpoison_free_buddy_page() highly likely fails.\n\t */\n\tmt = get_pageblock_migratetype(page);\n\tset_pageblock_migratetype(page, MIGRATE_ISOLATE);\n\tif (PageHuge(page))\n\t\tret = soft_offline_huge_page(page, flags);\n\telse\n\t\tret = __soft_offline_page(page, flags);\n\tset_pageblock_migratetype(page, mt);\n\treturn ret;\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_pageblock_migratetype",
          "args": [
            "page",
            "mt"
          ],
          "line": 1853
        },
        "resolved": true,
        "details": {
          "function_name": "set_pageblock_migratetype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "450-458",
          "snippet": "void set_pageblock_migratetype(struct page *page, int migratetype)\n{\n\tif (unlikely(page_group_by_mobility_disabled &&\n\t\t     migratetype < MIGRATE_PCPTYPES))\n\t\tmigratetype = MIGRATE_UNMOVABLE;\n\n\tset_pageblock_flags_group(page, (unsigned long)migratetype,\n\t\t\t\t\tPB_migrate, PB_migrate_end);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int page_group_by_mobility_disabled",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint page_group_by_mobility_disabled;\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid set_pageblock_migratetype(struct page *page, int migratetype)\n{\n\tif (unlikely(page_group_by_mobility_disabled &&\n\t\t     migratetype < MIGRATE_PCPTYPES))\n\t\tmigratetype = MIGRATE_UNMOVABLE;\n\n\tset_pageblock_flags_group(page, (unsigned long)migratetype,\n\t\t\t\t\tPB_migrate, PB_migrate_end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__soft_offline_page",
          "args": [
            "page",
            "flags"
          ],
          "line": 1852
        },
        "resolved": true,
        "details": {
          "function_name": "__soft_offline_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "1738-1816",
          "snippet": "static int __soft_offline_page(struct page *page, int flags)\n{\n\tint ret;\n\tunsigned long pfn = page_to_pfn(page);\n\n\t/*\n\t * Check PageHWPoison again inside page lock because PageHWPoison\n\t * is set by memory_failure() outside page lock. Note that\n\t * memory_failure() also double-checks PageHWPoison inside page lock,\n\t * so there's no race between soft_offline_page() and memory_failure().\n\t */\n\tlock_page(page);\n\twait_on_page_writeback(page);\n\tif (PageHWPoison(page)) {\n\t\tunlock_page(page);\n\t\tput_hwpoison_page(page);\n\t\tpr_info(\"soft offline: %#lx page already poisoned\\n\", pfn);\n\t\treturn -EBUSY;\n\t}\n\t/*\n\t * Try to invalidate first. This should work for\n\t * non dirty unmapped page cache pages.\n\t */\n\tret = invalidate_inode_page(page);\n\tunlock_page(page);\n\t/*\n\t * RED-PEN would be better to keep it isolated here, but we\n\t * would need to fix isolation locking first.\n\t */\n\tif (ret == 1) {\n\t\tput_hwpoison_page(page);\n\t\tpr_info(\"soft_offline: %#lx: invalidated\\n\", pfn);\n\t\tSetPageHWPoison(page);\n\t\tnum_poisoned_pages_inc();\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Simple invalidation didn't work.\n\t * Try to migrate to a new page instead. migrate.c\n\t * handles a large number of cases for us.\n\t */\n\tif (PageLRU(page))\n\t\tret = isolate_lru_page(page);\n\telse\n\t\tret = isolate_movable_page(page, ISOLATE_UNEVICTABLE);\n\t/*\n\t * Drop page reference which is came from get_any_page()\n\t * successful isolate_lru_page() already took another one.\n\t */\n\tput_hwpoison_page(page);\n\tif (!ret) {\n\t\tLIST_HEAD(pagelist);\n\t\t/*\n\t\t * After isolated lru page, the PageLRU will be cleared,\n\t\t * so use !__PageMovable instead for LRU page's mapping\n\t\t * cannot have PAGE_MAPPING_MOVABLE.\n\t\t */\n\t\tif (!__PageMovable(page))\n\t\t\tinc_node_page_state(page, NR_ISOLATED_ANON +\n\t\t\t\t\t\tpage_is_file_cache(page));\n\t\tlist_add(&page->lru, &pagelist);\n\t\tret = migrate_pages(&pagelist, new_page, NULL, MPOL_MF_MOVE_ALL,\n\t\t\t\t\tMIGRATE_SYNC, MR_MEMORY_FAILURE);\n\t\tif (ret) {\n\t\t\tif (!list_empty(&pagelist))\n\t\t\t\tputback_movable_pages(&pagelist);\n\n\t\t\tpr_info(\"soft offline: %#lx: migration failed %d, type %lx (%pGp)\\n\",\n\t\t\t\tpfn, ret, page->flags, &page->flags);\n\t\t\tif (ret > 0)\n\t\t\t\tret = -EIO;\n\t\t}\n\t} else {\n\t\tpr_info(\"soft offline: %#lx: isolation failed: %d, page count %d, type %lx (%pGp)\\n\",\n\t\t\tpfn, ret, page_count(page), page->flags, &page->flags);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define lru\t\t(1UL << PG_lru)",
            "#define dirty\t\t(1UL << PG_dirty)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define lru\t\t(1UL << PG_lru)\n#define dirty\t\t(1UL << PG_dirty)\n\nstatic int __soft_offline_page(struct page *page, int flags)\n{\n\tint ret;\n\tunsigned long pfn = page_to_pfn(page);\n\n\t/*\n\t * Check PageHWPoison again inside page lock because PageHWPoison\n\t * is set by memory_failure() outside page lock. Note that\n\t * memory_failure() also double-checks PageHWPoison inside page lock,\n\t * so there's no race between soft_offline_page() and memory_failure().\n\t */\n\tlock_page(page);\n\twait_on_page_writeback(page);\n\tif (PageHWPoison(page)) {\n\t\tunlock_page(page);\n\t\tput_hwpoison_page(page);\n\t\tpr_info(\"soft offline: %#lx page already poisoned\\n\", pfn);\n\t\treturn -EBUSY;\n\t}\n\t/*\n\t * Try to invalidate first. This should work for\n\t * non dirty unmapped page cache pages.\n\t */\n\tret = invalidate_inode_page(page);\n\tunlock_page(page);\n\t/*\n\t * RED-PEN would be better to keep it isolated here, but we\n\t * would need to fix isolation locking first.\n\t */\n\tif (ret == 1) {\n\t\tput_hwpoison_page(page);\n\t\tpr_info(\"soft_offline: %#lx: invalidated\\n\", pfn);\n\t\tSetPageHWPoison(page);\n\t\tnum_poisoned_pages_inc();\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Simple invalidation didn't work.\n\t * Try to migrate to a new page instead. migrate.c\n\t * handles a large number of cases for us.\n\t */\n\tif (PageLRU(page))\n\t\tret = isolate_lru_page(page);\n\telse\n\t\tret = isolate_movable_page(page, ISOLATE_UNEVICTABLE);\n\t/*\n\t * Drop page reference which is came from get_any_page()\n\t * successful isolate_lru_page() already took another one.\n\t */\n\tput_hwpoison_page(page);\n\tif (!ret) {\n\t\tLIST_HEAD(pagelist);\n\t\t/*\n\t\t * After isolated lru page, the PageLRU will be cleared,\n\t\t * so use !__PageMovable instead for LRU page's mapping\n\t\t * cannot have PAGE_MAPPING_MOVABLE.\n\t\t */\n\t\tif (!__PageMovable(page))\n\t\t\tinc_node_page_state(page, NR_ISOLATED_ANON +\n\t\t\t\t\t\tpage_is_file_cache(page));\n\t\tlist_add(&page->lru, &pagelist);\n\t\tret = migrate_pages(&pagelist, new_page, NULL, MPOL_MF_MOVE_ALL,\n\t\t\t\t\tMIGRATE_SYNC, MR_MEMORY_FAILURE);\n\t\tif (ret) {\n\t\t\tif (!list_empty(&pagelist))\n\t\t\t\tputback_movable_pages(&pagelist);\n\n\t\t\tpr_info(\"soft offline: %#lx: migration failed %d, type %lx (%pGp)\\n\",\n\t\t\t\tpfn, ret, page->flags, &page->flags);\n\t\t\tif (ret > 0)\n\t\t\t\tret = -EIO;\n\t\t}\n\t} else {\n\t\tpr_info(\"soft offline: %#lx: isolation failed: %d, page count %d, type %lx (%pGp)\\n\",\n\t\t\tpfn, ret, page_count(page), page->flags, &page->flags);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "soft_offline_huge_page",
          "args": [
            "page",
            "flags"
          ],
          "line": 1850
        },
        "resolved": true,
        "details": {
          "function_name": "soft_offline_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "1681-1736",
          "snippet": "static int soft_offline_huge_page(struct page *page, int flags)\n{\n\tint ret;\n\tunsigned long pfn = page_to_pfn(page);\n\tstruct page *hpage = compound_head(page);\n\tLIST_HEAD(pagelist);\n\n\t/*\n\t * This double-check of PageHWPoison is to avoid the race with\n\t * memory_failure(). See also comment in __soft_offline_page().\n\t */\n\tlock_page(hpage);\n\tif (PageHWPoison(hpage)) {\n\t\tunlock_page(hpage);\n\t\tput_hwpoison_page(hpage);\n\t\tpr_info(\"soft offline: %#lx hugepage already poisoned\\n\", pfn);\n\t\treturn -EBUSY;\n\t}\n\tunlock_page(hpage);\n\n\tret = isolate_huge_page(hpage, &pagelist);\n\t/*\n\t * get_any_page() and isolate_huge_page() takes a refcount each,\n\t * so need to drop one here.\n\t */\n\tput_hwpoison_page(hpage);\n\tif (!ret) {\n\t\tpr_info(\"soft offline: %#lx hugepage failed to isolate\\n\", pfn);\n\t\treturn -EBUSY;\n\t}\n\n\tret = migrate_pages(&pagelist, new_page, NULL, MPOL_MF_MOVE_ALL,\n\t\t\t\tMIGRATE_SYNC, MR_MEMORY_FAILURE);\n\tif (ret) {\n\t\tpr_info(\"soft offline: %#lx: hugepage migration failed %d, type %lx (%pGp)\\n\",\n\t\t\tpfn, ret, page->flags, &page->flags);\n\t\tif (!list_empty(&pagelist))\n\t\t\tputback_movable_pages(&pagelist);\n\t\tif (ret > 0)\n\t\t\tret = -EIO;\n\t} else {\n\t\t/*\n\t\t * We set PG_hwpoison only when the migration source hugepage\n\t\t * was successfully dissolved, because otherwise hwpoisoned\n\t\t * hugepage remains on free hugepage list, then userspace will\n\t\t * find it as SIGBUS by allocation failure. That's not expected\n\t\t * in soft-offlining.\n\t\t */\n\t\tret = dissolve_free_huge_page(page);\n\t\tif (!ret) {\n\t\t\tif (set_hwpoison_free_buddy_page(page))\n\t\t\t\tnum_poisoned_pages_inc();\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int soft_offline_huge_page(struct page *page, int flags)\n{\n\tint ret;\n\tunsigned long pfn = page_to_pfn(page);\n\tstruct page *hpage = compound_head(page);\n\tLIST_HEAD(pagelist);\n\n\t/*\n\t * This double-check of PageHWPoison is to avoid the race with\n\t * memory_failure(). See also comment in __soft_offline_page().\n\t */\n\tlock_page(hpage);\n\tif (PageHWPoison(hpage)) {\n\t\tunlock_page(hpage);\n\t\tput_hwpoison_page(hpage);\n\t\tpr_info(\"soft offline: %#lx hugepage already poisoned\\n\", pfn);\n\t\treturn -EBUSY;\n\t}\n\tunlock_page(hpage);\n\n\tret = isolate_huge_page(hpage, &pagelist);\n\t/*\n\t * get_any_page() and isolate_huge_page() takes a refcount each,\n\t * so need to drop one here.\n\t */\n\tput_hwpoison_page(hpage);\n\tif (!ret) {\n\t\tpr_info(\"soft offline: %#lx hugepage failed to isolate\\n\", pfn);\n\t\treturn -EBUSY;\n\t}\n\n\tret = migrate_pages(&pagelist, new_page, NULL, MPOL_MF_MOVE_ALL,\n\t\t\t\tMIGRATE_SYNC, MR_MEMORY_FAILURE);\n\tif (ret) {\n\t\tpr_info(\"soft offline: %#lx: hugepage migration failed %d, type %lx (%pGp)\\n\",\n\t\t\tpfn, ret, page->flags, &page->flags);\n\t\tif (!list_empty(&pagelist))\n\t\t\tputback_movable_pages(&pagelist);\n\t\tif (ret > 0)\n\t\t\tret = -EIO;\n\t} else {\n\t\t/*\n\t\t * We set PG_hwpoison only when the migration source hugepage\n\t\t * was successfully dissolved, because otherwise hwpoisoned\n\t\t * hugepage remains on free hugepage list, then userspace will\n\t\t * find it as SIGBUS by allocation failure. That's not expected\n\t\t * in soft-offlining.\n\t\t */\n\t\tret = dissolve_free_huge_page(page);\n\t\tif (!ret) {\n\t\t\tif (set_hwpoison_free_buddy_page(page))\n\t\t\t\tnum_poisoned_pages_inc();\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "page"
          ],
          "line": 1849
        },
        "resolved": true,
        "details": {
          "function_name": "PageHugeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "225-228",
          "snippet": "static int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pageblock_migratetype",
          "args": [
            "page"
          ],
          "line": 1847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_hwpoison_page",
          "args": [
            "hpage"
          ],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_hwpoison_page",
          "args": [
            "page"
          ],
          "line": 1836
        },
        "resolved": true,
        "details": {
          "function_name": "get_hwpoison_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "928-956",
          "snippet": "int get_hwpoison_page(struct page *page)\n{\n\tstruct page *head = compound_head(page);\n\n\tif (!PageHuge(head) && PageTransHuge(head)) {\n\t\t/*\n\t\t * Non anonymous thp exists only in allocation/free time. We\n\t\t * can't handle such a case correctly, so let's give it up.\n\t\t * This should be better than triggering BUG_ON when kernel\n\t\t * tries to touch the \"partially handled\" page.\n\t\t */\n\t\tif (!PageAnon(head)) {\n\t\t\tpr_err(\"Memory failure: %#lx: non anonymous thp\\n\",\n\t\t\t\tpage_to_pfn(page));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (get_page_unless_zero(head)) {\n\t\tif (head == compound_head(page))\n\t\t\treturn 1;\n\n\t\tpr_info(\"Memory failure: %#lx cannot catch tail\\n\",\n\t\t\tpage_to_pfn(page));\n\t\tput_page(head);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define head\t\t(1UL << PG_head)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define head\t\t(1UL << PG_head)\n\nint get_hwpoison_page(struct page *page)\n{\n\tstruct page *head = compound_head(page);\n\n\tif (!PageHuge(head) && PageTransHuge(head)) {\n\t\t/*\n\t\t * Non anonymous thp exists only in allocation/free time. We\n\t\t * can't handle such a case correctly, so let's give it up.\n\t\t * This should be better than triggering BUG_ON when kernel\n\t\t * tries to touch the \"partially handled\" page.\n\t\t */\n\t\tif (!PageAnon(head)) {\n\t\t\tpr_err(\"Memory failure: %#lx: non anonymous thp\\n\",\n\t\t\t\tpage_to_pfn(page));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (get_page_unless_zero(head)) {\n\t\tif (head == compound_head(page))\n\t\t\treturn 1;\n\n\t\tpr_info(\"Memory failure: %#lx cannot catch tail\\n\",\n\t\t\tpage_to_pfn(page));\n\t\tput_page(head);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "hpage"
          ],
          "line": 1835
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_hwpoison_page",
          "args": [
            "hpage"
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"soft offline: %#lx: thp split failed\\n\"",
            "page_to_pfn(page)"
          ],
          "line": 1831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 1831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"soft offline: %#lx: non anonymous thp\\n\"",
            "page_to_pfn(page)"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "hpage"
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "split_huge_page(hpage)"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "split_huge_page",
          "args": [
            "hpage"
          ],
          "line": 1826
        },
        "resolved": true,
        "details": {
          "function_name": "deferred_split_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "2760-2774",
          "snippet": "void deferred_split_huge_page(struct page *page)\n{\n\tstruct pglist_data *pgdata = NODE_DATA(page_to_nid(page));\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\n\tspin_lock_irqsave(&pgdata->split_queue_lock, flags);\n\tif (list_empty(page_deferred_list(page))) {\n\t\tcount_vm_event(THP_DEFERRED_SPLIT_PAGE);\n\t\tlist_add_tail(page_deferred_list(page), &pgdata->split_queue);\n\t\tpgdata->split_queue_len++;\n\t}\n\tspin_unlock_irqrestore(&pgdata->split_queue_lock, flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid deferred_split_huge_page(struct page *page)\n{\n\tstruct pglist_data *pgdata = NODE_DATA(page_to_nid(page));\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\n\tspin_lock_irqsave(&pgdata->split_queue_lock, flags);\n\tif (list_empty(page_deferred_list(page))) {\n\t\tcount_vm_event(THP_DEFERRED_SPLIT_PAGE);\n\t\tlist_add_tail(page_deferred_list(page), &pgdata->split_queue);\n\t\tpgdata->split_queue_len++;\n\t}\n\tspin_unlock_irqrestore(&pgdata->split_queue_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "hpage"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "hpage"
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int soft_offline_in_use_page(struct page *page, int flags)\n{\n\tint ret;\n\tint mt;\n\tstruct page *hpage = compound_head(page);\n\n\tif (!PageHuge(page) && PageTransHuge(hpage)) {\n\t\tlock_page(hpage);\n\t\tif (!PageAnon(hpage) || unlikely(split_huge_page(hpage))) {\n\t\t\tunlock_page(hpage);\n\t\t\tif (!PageAnon(hpage))\n\t\t\t\tpr_info(\"soft offline: %#lx: non anonymous thp\\n\", page_to_pfn(page));\n\t\t\telse\n\t\t\t\tpr_info(\"soft offline: %#lx: thp split failed\\n\", page_to_pfn(page));\n\t\t\tput_hwpoison_page(hpage);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tunlock_page(hpage);\n\t\tget_hwpoison_page(page);\n\t\tput_hwpoison_page(hpage);\n\t}\n\n\t/*\n\t * Setting MIGRATE_ISOLATE here ensures that the page will be linked\n\t * to free list immediately (not via pcplist) when released after\n\t * successful page migration. Otherwise we can't guarantee that the\n\t * page is really free after put_page() returns, so\n\t * set_hwpoison_free_buddy_page() highly likely fails.\n\t */\n\tmt = get_pageblock_migratetype(page);\n\tset_pageblock_migratetype(page, MIGRATE_ISOLATE);\n\tif (PageHuge(page))\n\t\tret = soft_offline_huge_page(page, flags);\n\telse\n\t\tret = __soft_offline_page(page, flags);\n\tset_pageblock_migratetype(page, mt);\n\treturn ret;\n}"
  },
  {
    "function_name": "__soft_offline_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "1738-1816",
    "snippet": "static int __soft_offline_page(struct page *page, int flags)\n{\n\tint ret;\n\tunsigned long pfn = page_to_pfn(page);\n\n\t/*\n\t * Check PageHWPoison again inside page lock because PageHWPoison\n\t * is set by memory_failure() outside page lock. Note that\n\t * memory_failure() also double-checks PageHWPoison inside page lock,\n\t * so there's no race between soft_offline_page() and memory_failure().\n\t */\n\tlock_page(page);\n\twait_on_page_writeback(page);\n\tif (PageHWPoison(page)) {\n\t\tunlock_page(page);\n\t\tput_hwpoison_page(page);\n\t\tpr_info(\"soft offline: %#lx page already poisoned\\n\", pfn);\n\t\treturn -EBUSY;\n\t}\n\t/*\n\t * Try to invalidate first. This should work for\n\t * non dirty unmapped page cache pages.\n\t */\n\tret = invalidate_inode_page(page);\n\tunlock_page(page);\n\t/*\n\t * RED-PEN would be better to keep it isolated here, but we\n\t * would need to fix isolation locking first.\n\t */\n\tif (ret == 1) {\n\t\tput_hwpoison_page(page);\n\t\tpr_info(\"soft_offline: %#lx: invalidated\\n\", pfn);\n\t\tSetPageHWPoison(page);\n\t\tnum_poisoned_pages_inc();\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Simple invalidation didn't work.\n\t * Try to migrate to a new page instead. migrate.c\n\t * handles a large number of cases for us.\n\t */\n\tif (PageLRU(page))\n\t\tret = isolate_lru_page(page);\n\telse\n\t\tret = isolate_movable_page(page, ISOLATE_UNEVICTABLE);\n\t/*\n\t * Drop page reference which is came from get_any_page()\n\t * successful isolate_lru_page() already took another one.\n\t */\n\tput_hwpoison_page(page);\n\tif (!ret) {\n\t\tLIST_HEAD(pagelist);\n\t\t/*\n\t\t * After isolated lru page, the PageLRU will be cleared,\n\t\t * so use !__PageMovable instead for LRU page's mapping\n\t\t * cannot have PAGE_MAPPING_MOVABLE.\n\t\t */\n\t\tif (!__PageMovable(page))\n\t\t\tinc_node_page_state(page, NR_ISOLATED_ANON +\n\t\t\t\t\t\tpage_is_file_cache(page));\n\t\tlist_add(&page->lru, &pagelist);\n\t\tret = migrate_pages(&pagelist, new_page, NULL, MPOL_MF_MOVE_ALL,\n\t\t\t\t\tMIGRATE_SYNC, MR_MEMORY_FAILURE);\n\t\tif (ret) {\n\t\t\tif (!list_empty(&pagelist))\n\t\t\t\tputback_movable_pages(&pagelist);\n\n\t\t\tpr_info(\"soft offline: %#lx: migration failed %d, type %lx (%pGp)\\n\",\n\t\t\t\tpfn, ret, page->flags, &page->flags);\n\t\t\tif (ret > 0)\n\t\t\t\tret = -EIO;\n\t\t}\n\t} else {\n\t\tpr_info(\"soft offline: %#lx: isolation failed: %d, page count %d, type %lx (%pGp)\\n\",\n\t\t\tpfn, ret, page_count(page), page->flags, &page->flags);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define lru\t\t(1UL << PG_lru)",
      "#define dirty\t\t(1UL << PG_dirty)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"soft offline: %#lx: isolation failed: %d, page count %d, type %lx (%pGp)\\n\"",
            "pfn",
            "ret",
            "page_count(page)",
            "page->flags",
            "&page->flags"
          ],
          "line": 1812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"soft offline: %#lx: migration failed %d, type %lx (%pGp)\\n\"",
            "pfn",
            "ret",
            "page->flags",
            "&page->flags"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "putback_movable_pages",
          "args": [
            "&pagelist"
          ],
          "line": 1804
        },
        "resolved": true,
        "details": {
          "function_name": "putback_movable_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "167-198",
          "snippet": "void putback_movable_pages(struct list_head *l)\n{\n\tstruct page *page;\n\tstruct page *page2;\n\n\tlist_for_each_entry_safe(page, page2, l, lru) {\n\t\tif (unlikely(PageHuge(page))) {\n\t\t\tputback_active_hugepage(page);\n\t\t\tcontinue;\n\t\t}\n\t\tlist_del(&page->lru);\n\t\t/*\n\t\t * We isolated non-lru movable page so here we can use\n\t\t * __PageMovable because LRU page's mapping cannot have\n\t\t * PAGE_MAPPING_MOVABLE.\n\t\t */\n\t\tif (unlikely(__PageMovable(page))) {\n\t\t\tVM_BUG_ON_PAGE(!PageIsolated(page), page);\n\t\t\tlock_page(page);\n\t\t\tif (PageMovable(page))\n\t\t\t\tputback_movable_page(page);\n\t\t\telse\n\t\t\t\t__ClearPageIsolated(page);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t} else {\n\t\t\tmod_node_page_state(page_pgdat(page), NR_ISOLATED_ANON +\n\t\t\t\t\tpage_is_file_cache(page), -hpage_nr_pages(page));\n\t\t\tputback_lru_page(page);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nvoid putback_movable_pages(struct list_head *l)\n{\n\tstruct page *page;\n\tstruct page *page2;\n\n\tlist_for_each_entry_safe(page, page2, l, lru) {\n\t\tif (unlikely(PageHuge(page))) {\n\t\t\tputback_active_hugepage(page);\n\t\t\tcontinue;\n\t\t}\n\t\tlist_del(&page->lru);\n\t\t/*\n\t\t * We isolated non-lru movable page so here we can use\n\t\t * __PageMovable because LRU page's mapping cannot have\n\t\t * PAGE_MAPPING_MOVABLE.\n\t\t */\n\t\tif (unlikely(__PageMovable(page))) {\n\t\t\tVM_BUG_ON_PAGE(!PageIsolated(page), page);\n\t\t\tlock_page(page);\n\t\t\tif (PageMovable(page))\n\t\t\t\tputback_movable_page(page);\n\t\t\telse\n\t\t\t\t__ClearPageIsolated(page);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t} else {\n\t\t\tmod_node_page_state(page_pgdat(page), NR_ISOLATED_ANON +\n\t\t\t\t\tpage_is_file_cache(page), -hpage_nr_pages(page));\n\t\t\tputback_lru_page(page);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pagelist"
          ],
          "line": 1803
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "migrate_pages",
          "args": [
            "&pagelist",
            "new_page",
            "NULL",
            "MPOL_MF_MOVE_ALL",
            "MIGRATE_SYNC",
            "MR_MEMORY_FAILURE"
          ],
          "line": 1800
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "1362-1449",
          "snippet": "int migrate_pages(struct list_head *from, new_page_t get_new_page,\n\t\tfree_page_t put_new_page, unsigned long private,\n\t\tenum migrate_mode mode, int reason)\n{\n\tint retry = 1;\n\tint nr_failed = 0;\n\tint nr_succeeded = 0;\n\tint pass = 0;\n\tstruct page *page;\n\tstruct page *page2;\n\tint swapwrite = current->flags & PF_SWAPWRITE;\n\tint rc;\n\n\tif (!swapwrite)\n\t\tcurrent->flags |= PF_SWAPWRITE;\n\n\tfor(pass = 0; pass < 10 && retry; pass++) {\n\t\tretry = 0;\n\n\t\tlist_for_each_entry_safe(page, page2, from, lru) {\nretry:\n\t\t\tcond_resched();\n\n\t\t\tif (PageHuge(page))\n\t\t\t\trc = unmap_and_move_huge_page(get_new_page,\n\t\t\t\t\t\tput_new_page, private, page,\n\t\t\t\t\t\tpass > 2, mode, reason);\n\t\t\telse\n\t\t\t\trc = unmap_and_move(get_new_page, put_new_page,\n\t\t\t\t\t\tprivate, page, pass > 2, mode,\n\t\t\t\t\t\treason);\n\n\t\t\tswitch(rc) {\n\t\t\tcase -ENOMEM:\n\t\t\t\t/*\n\t\t\t\t * THP migration might be unsupported or the\n\t\t\t\t * allocation could've failed so we should\n\t\t\t\t * retry on the same page with the THP split\n\t\t\t\t * to base pages.\n\t\t\t\t *\n\t\t\t\t * Head page is retried immediately and tail\n\t\t\t\t * pages are added to the tail of the list so\n\t\t\t\t * we encounter them after the rest of the list\n\t\t\t\t * is processed.\n\t\t\t\t */\n\t\t\t\tif (PageTransHuge(page) && !PageHuge(page)) {\n\t\t\t\t\tlock_page(page);\n\t\t\t\t\trc = split_huge_page_to_list(page, from);\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tif (!rc) {\n\t\t\t\t\t\tlist_safe_reset_next(page, page2, lru);\n\t\t\t\t\t\tgoto retry;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnr_failed++;\n\t\t\t\tgoto out;\n\t\t\tcase -EAGAIN:\n\t\t\t\tretry++;\n\t\t\t\tbreak;\n\t\t\tcase MIGRATEPAGE_SUCCESS:\n\t\t\t\tnr_succeeded++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t * Permanent failure (-EBUSY, -ENOSYS, etc.):\n\t\t\t\t * unlike -EAGAIN case, the failed page is\n\t\t\t\t * removed from migration page list and not\n\t\t\t\t * retried in the next outer loop.\n\t\t\t\t */\n\t\t\t\tnr_failed++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tnr_failed += retry;\n\trc = nr_failed;\nout:\n\tif (nr_succeeded)\n\t\tcount_vm_events(PGMIGRATE_SUCCESS, nr_succeeded);\n\tif (nr_failed)\n\t\tcount_vm_events(PGMIGRATE_FAIL, nr_failed);\n\ttrace_mm_migrate_pages(nr_succeeded, nr_failed, mode, reason);\n\n\tif (!swapwrite)\n\t\tcurrent->flags &= ~PF_SWAPWRITE;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nint migrate_pages(struct list_head *from, new_page_t get_new_page,\n\t\tfree_page_t put_new_page, unsigned long private,\n\t\tenum migrate_mode mode, int reason)\n{\n\tint retry = 1;\n\tint nr_failed = 0;\n\tint nr_succeeded = 0;\n\tint pass = 0;\n\tstruct page *page;\n\tstruct page *page2;\n\tint swapwrite = current->flags & PF_SWAPWRITE;\n\tint rc;\n\n\tif (!swapwrite)\n\t\tcurrent->flags |= PF_SWAPWRITE;\n\n\tfor(pass = 0; pass < 10 && retry; pass++) {\n\t\tretry = 0;\n\n\t\tlist_for_each_entry_safe(page, page2, from, lru) {\nretry:\n\t\t\tcond_resched();\n\n\t\t\tif (PageHuge(page))\n\t\t\t\trc = unmap_and_move_huge_page(get_new_page,\n\t\t\t\t\t\tput_new_page, private, page,\n\t\t\t\t\t\tpass > 2, mode, reason);\n\t\t\telse\n\t\t\t\trc = unmap_and_move(get_new_page, put_new_page,\n\t\t\t\t\t\tprivate, page, pass > 2, mode,\n\t\t\t\t\t\treason);\n\n\t\t\tswitch(rc) {\n\t\t\tcase -ENOMEM:\n\t\t\t\t/*\n\t\t\t\t * THP migration might be unsupported or the\n\t\t\t\t * allocation could've failed so we should\n\t\t\t\t * retry on the same page with the THP split\n\t\t\t\t * to base pages.\n\t\t\t\t *\n\t\t\t\t * Head page is retried immediately and tail\n\t\t\t\t * pages are added to the tail of the list so\n\t\t\t\t * we encounter them after the rest of the list\n\t\t\t\t * is processed.\n\t\t\t\t */\n\t\t\t\tif (PageTransHuge(page) && !PageHuge(page)) {\n\t\t\t\t\tlock_page(page);\n\t\t\t\t\trc = split_huge_page_to_list(page, from);\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tif (!rc) {\n\t\t\t\t\t\tlist_safe_reset_next(page, page2, lru);\n\t\t\t\t\t\tgoto retry;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnr_failed++;\n\t\t\t\tgoto out;\n\t\t\tcase -EAGAIN:\n\t\t\t\tretry++;\n\t\t\t\tbreak;\n\t\t\tcase MIGRATEPAGE_SUCCESS:\n\t\t\t\tnr_succeeded++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t * Permanent failure (-EBUSY, -ENOSYS, etc.):\n\t\t\t\t * unlike -EAGAIN case, the failed page is\n\t\t\t\t * removed from migration page list and not\n\t\t\t\t * retried in the next outer loop.\n\t\t\t\t */\n\t\t\t\tnr_failed++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tnr_failed += retry;\n\trc = nr_failed;\nout:\n\tif (nr_succeeded)\n\t\tcount_vm_events(PGMIGRATE_SUCCESS, nr_succeeded);\n\tif (nr_failed)\n\t\tcount_vm_events(PGMIGRATE_FAIL, nr_failed);\n\ttrace_mm_migrate_pages(nr_succeeded, nr_failed, mode, reason);\n\n\tif (!swapwrite)\n\t\tcurrent->flags &= ~PF_SWAPWRITE;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&page->lru",
            "&pagelist"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_node_page_state",
          "args": [
            "page",
            "NR_ISOLATED_ANON +\n\t\t\t\t\t\tpage_is_file_cache(page)"
          ],
          "line": 1797
        },
        "resolved": true,
        "details": {
          "function_name": "inc_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "655-664",
          "snippet": "void inc_node_page_state(struct page *page, enum node_stat_item item)\n{\n\tunsigned long flags;\n\tstruct pglist_data *pgdat;\n\n\tpgdat = page_pgdat(page);\n\tlocal_irq_save(flags);\n\t__inc_node_state(pgdat, item);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid inc_node_page_state(struct page *page, enum node_stat_item item)\n{\n\tunsigned long flags;\n\tstruct pglist_data *pgdat;\n\n\tpgdat = page_pgdat(page);\n\tlocal_irq_save(flags);\n\t__inc_node_state(pgdat, item);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_is_file_cache",
          "args": [
            "page"
          ],
          "line": 1798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__PageMovable",
          "args": [
            "page"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "pagelist"
          ],
          "line": 1790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_hwpoison_page",
          "args": [
            "page"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isolate_movable_page",
          "args": [
            "page",
            "ISOLATE_UNEVICTABLE"
          ],
          "line": 1783
        },
        "resolved": true,
        "details": {
          "function_name": "isolate_movable_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "84-143",
          "snippet": "int isolate_movable_page(struct page *page, isolate_mode_t mode)\n{\n\tstruct address_space *mapping;\n\n\t/*\n\t * Avoid burning cycles with pages that are yet under __free_pages(),\n\t * or just got freed under us.\n\t *\n\t * In case we 'win' a race for a movable page being freed under us and\n\t * raise its refcount preventing __free_pages() from doing its job\n\t * the put_page() at the end of this block will take care of\n\t * release this page, thus avoiding a nasty leakage.\n\t */\n\tif (unlikely(!get_page_unless_zero(page)))\n\t\tgoto out;\n\n\t/*\n\t * Check PageMovable before holding a PG_lock because page's owner\n\t * assumes anybody doesn't touch PG_lock of newly allocated page\n\t * so unconditionally grapping the lock ruins page's owner side.\n\t */\n\tif (unlikely(!__PageMovable(page)))\n\t\tgoto out_putpage;\n\t/*\n\t * As movable pages are not isolated from LRU lists, concurrent\n\t * compaction threads can race against page migration functions\n\t * as well as race against the releasing a page.\n\t *\n\t * In order to avoid having an already isolated movable page\n\t * being (wrongly) re-isolated while it is under migration,\n\t * or to avoid attempting to isolate pages being released,\n\t * lets be sure we have the page lock\n\t * before proceeding with the movable page isolation steps.\n\t */\n\tif (unlikely(!trylock_page(page)))\n\t\tgoto out_putpage;\n\n\tif (!PageMovable(page) || PageIsolated(page))\n\t\tgoto out_no_isolated;\n\n\tmapping = page_mapping(page);\n\tVM_BUG_ON_PAGE(!mapping, page);\n\n\tif (!mapping->a_ops->isolate_page(page, mode))\n\t\tgoto out_no_isolated;\n\n\t/* Driver shouldn't use PG_isolated bit of page->flags */\n\tWARN_ON_ONCE(PageIsolated(page));\n\t__SetPageIsolated(page);\n\tunlock_page(page);\n\n\treturn 0;\n\nout_no_isolated:\n\tunlock_page(page);\nout_putpage:\n\tput_page(page);\nout:\n\treturn -EBUSY;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nint isolate_movable_page(struct page *page, isolate_mode_t mode)\n{\n\tstruct address_space *mapping;\n\n\t/*\n\t * Avoid burning cycles with pages that are yet under __free_pages(),\n\t * or just got freed under us.\n\t *\n\t * In case we 'win' a race for a movable page being freed under us and\n\t * raise its refcount preventing __free_pages() from doing its job\n\t * the put_page() at the end of this block will take care of\n\t * release this page, thus avoiding a nasty leakage.\n\t */\n\tif (unlikely(!get_page_unless_zero(page)))\n\t\tgoto out;\n\n\t/*\n\t * Check PageMovable before holding a PG_lock because page's owner\n\t * assumes anybody doesn't touch PG_lock of newly allocated page\n\t * so unconditionally grapping the lock ruins page's owner side.\n\t */\n\tif (unlikely(!__PageMovable(page)))\n\t\tgoto out_putpage;\n\t/*\n\t * As movable pages are not isolated from LRU lists, concurrent\n\t * compaction threads can race against page migration functions\n\t * as well as race against the releasing a page.\n\t *\n\t * In order to avoid having an already isolated movable page\n\t * being (wrongly) re-isolated while it is under migration,\n\t * or to avoid attempting to isolate pages being released,\n\t * lets be sure we have the page lock\n\t * before proceeding with the movable page isolation steps.\n\t */\n\tif (unlikely(!trylock_page(page)))\n\t\tgoto out_putpage;\n\n\tif (!PageMovable(page) || PageIsolated(page))\n\t\tgoto out_no_isolated;\n\n\tmapping = page_mapping(page);\n\tVM_BUG_ON_PAGE(!mapping, page);\n\n\tif (!mapping->a_ops->isolate_page(page, mode))\n\t\tgoto out_no_isolated;\n\n\t/* Driver shouldn't use PG_isolated bit of page->flags */\n\tWARN_ON_ONCE(PageIsolated(page));\n\t__SetPageIsolated(page);\n\tunlock_page(page);\n\n\treturn 0;\n\nout_no_isolated:\n\tunlock_page(page);\nout_putpage:\n\tput_page(page);\nout:\n\treturn -EBUSY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isolate_lru_page",
          "args": [
            "page"
          ],
          "line": 1781
        },
        "resolved": true,
        "details": {
          "function_name": "isolate_lru_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1772-1795",
          "snippet": "int isolate_lru_page(struct page *page)\n{\n\tint ret = -EBUSY;\n\n\tVM_BUG_ON_PAGE(!page_count(page), page);\n\tWARN_RATELIMIT(PageTail(page), \"trying to isolate tail page\");\n\n\tif (PageLRU(page)) {\n\t\tstruct zone *zone = page_zone(page);\n\t\tstruct lruvec *lruvec;\n\n\t\tspin_lock_irq(zone_lru_lock(zone));\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\t\tif (PageLRU(page)) {\n\t\t\tint lru = page_lru(page);\n\t\t\tget_page(page);\n\t\t\tClearPageLRU(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, lru);\n\t\t\tret = 0;\n\t\t}\n\t\tspin_unlock_irq(zone_lru_lock(zone));\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint isolate_lru_page(struct page *page)\n{\n\tint ret = -EBUSY;\n\n\tVM_BUG_ON_PAGE(!page_count(page), page);\n\tWARN_RATELIMIT(PageTail(page), \"trying to isolate tail page\");\n\n\tif (PageLRU(page)) {\n\t\tstruct zone *zone = page_zone(page);\n\t\tstruct lruvec *lruvec;\n\n\t\tspin_lock_irq(zone_lru_lock(zone));\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\t\tif (PageLRU(page)) {\n\t\t\tint lru = page_lru(page);\n\t\t\tget_page(page);\n\t\t\tClearPageLRU(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, lru);\n\t\t\tret = 0;\n\t\t}\n\t\tspin_unlock_irq(zone_lru_lock(zone));\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_poisoned_pages_inc",
          "args": [],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageHWPoison",
          "args": [
            "page"
          ],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"soft_offline: %#lx: invalidated\\n\"",
            "pfn"
          ],
          "line": 1769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_hwpoison_page",
          "args": [
            "page"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1762
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_inode_page",
          "args": [
            "page"
          ],
          "line": 1761
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_inode_pages2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
          "lines": "766-769",
          "snippet": "int invalidate_inode_pages2(struct address_space *mapping)\n{\n\treturn invalidate_inode_pages2_range(mapping, 0, -1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/rmap.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nint invalidate_inode_pages2(struct address_space *mapping)\n{\n\treturn invalidate_inode_pages2_range(mapping, 0, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"soft offline: %#lx page already poisoned\\n\"",
            "pfn"
          ],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_hwpoison_page",
          "args": [
            "page"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHWPoison",
          "args": [
            "page"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_page_writeback",
          "args": [
            "page"
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define lru\t\t(1UL << PG_lru)\n#define dirty\t\t(1UL << PG_dirty)\n\nstatic int __soft_offline_page(struct page *page, int flags)\n{\n\tint ret;\n\tunsigned long pfn = page_to_pfn(page);\n\n\t/*\n\t * Check PageHWPoison again inside page lock because PageHWPoison\n\t * is set by memory_failure() outside page lock. Note that\n\t * memory_failure() also double-checks PageHWPoison inside page lock,\n\t * so there's no race between soft_offline_page() and memory_failure().\n\t */\n\tlock_page(page);\n\twait_on_page_writeback(page);\n\tif (PageHWPoison(page)) {\n\t\tunlock_page(page);\n\t\tput_hwpoison_page(page);\n\t\tpr_info(\"soft offline: %#lx page already poisoned\\n\", pfn);\n\t\treturn -EBUSY;\n\t}\n\t/*\n\t * Try to invalidate first. This should work for\n\t * non dirty unmapped page cache pages.\n\t */\n\tret = invalidate_inode_page(page);\n\tunlock_page(page);\n\t/*\n\t * RED-PEN would be better to keep it isolated here, but we\n\t * would need to fix isolation locking first.\n\t */\n\tif (ret == 1) {\n\t\tput_hwpoison_page(page);\n\t\tpr_info(\"soft_offline: %#lx: invalidated\\n\", pfn);\n\t\tSetPageHWPoison(page);\n\t\tnum_poisoned_pages_inc();\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Simple invalidation didn't work.\n\t * Try to migrate to a new page instead. migrate.c\n\t * handles a large number of cases for us.\n\t */\n\tif (PageLRU(page))\n\t\tret = isolate_lru_page(page);\n\telse\n\t\tret = isolate_movable_page(page, ISOLATE_UNEVICTABLE);\n\t/*\n\t * Drop page reference which is came from get_any_page()\n\t * successful isolate_lru_page() already took another one.\n\t */\n\tput_hwpoison_page(page);\n\tif (!ret) {\n\t\tLIST_HEAD(pagelist);\n\t\t/*\n\t\t * After isolated lru page, the PageLRU will be cleared,\n\t\t * so use !__PageMovable instead for LRU page's mapping\n\t\t * cannot have PAGE_MAPPING_MOVABLE.\n\t\t */\n\t\tif (!__PageMovable(page))\n\t\t\tinc_node_page_state(page, NR_ISOLATED_ANON +\n\t\t\t\t\t\tpage_is_file_cache(page));\n\t\tlist_add(&page->lru, &pagelist);\n\t\tret = migrate_pages(&pagelist, new_page, NULL, MPOL_MF_MOVE_ALL,\n\t\t\t\t\tMIGRATE_SYNC, MR_MEMORY_FAILURE);\n\t\tif (ret) {\n\t\t\tif (!list_empty(&pagelist))\n\t\t\t\tputback_movable_pages(&pagelist);\n\n\t\t\tpr_info(\"soft offline: %#lx: migration failed %d, type %lx (%pGp)\\n\",\n\t\t\t\tpfn, ret, page->flags, &page->flags);\n\t\t\tif (ret > 0)\n\t\t\t\tret = -EIO;\n\t\t}\n\t} else {\n\t\tpr_info(\"soft offline: %#lx: isolation failed: %d, page count %d, type %lx (%pGp)\\n\",\n\t\t\tpfn, ret, page_count(page), page->flags, &page->flags);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "soft_offline_huge_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "1681-1736",
    "snippet": "static int soft_offline_huge_page(struct page *page, int flags)\n{\n\tint ret;\n\tunsigned long pfn = page_to_pfn(page);\n\tstruct page *hpage = compound_head(page);\n\tLIST_HEAD(pagelist);\n\n\t/*\n\t * This double-check of PageHWPoison is to avoid the race with\n\t * memory_failure(). See also comment in __soft_offline_page().\n\t */\n\tlock_page(hpage);\n\tif (PageHWPoison(hpage)) {\n\t\tunlock_page(hpage);\n\t\tput_hwpoison_page(hpage);\n\t\tpr_info(\"soft offline: %#lx hugepage already poisoned\\n\", pfn);\n\t\treturn -EBUSY;\n\t}\n\tunlock_page(hpage);\n\n\tret = isolate_huge_page(hpage, &pagelist);\n\t/*\n\t * get_any_page() and isolate_huge_page() takes a refcount each,\n\t * so need to drop one here.\n\t */\n\tput_hwpoison_page(hpage);\n\tif (!ret) {\n\t\tpr_info(\"soft offline: %#lx hugepage failed to isolate\\n\", pfn);\n\t\treturn -EBUSY;\n\t}\n\n\tret = migrate_pages(&pagelist, new_page, NULL, MPOL_MF_MOVE_ALL,\n\t\t\t\tMIGRATE_SYNC, MR_MEMORY_FAILURE);\n\tif (ret) {\n\t\tpr_info(\"soft offline: %#lx: hugepage migration failed %d, type %lx (%pGp)\\n\",\n\t\t\tpfn, ret, page->flags, &page->flags);\n\t\tif (!list_empty(&pagelist))\n\t\t\tputback_movable_pages(&pagelist);\n\t\tif (ret > 0)\n\t\t\tret = -EIO;\n\t} else {\n\t\t/*\n\t\t * We set PG_hwpoison only when the migration source hugepage\n\t\t * was successfully dissolved, because otherwise hwpoisoned\n\t\t * hugepage remains on free hugepage list, then userspace will\n\t\t * find it as SIGBUS by allocation failure. That's not expected\n\t\t * in soft-offlining.\n\t\t */\n\t\tret = dissolve_free_huge_page(page);\n\t\tif (!ret) {\n\t\t\tif (set_hwpoison_free_buddy_page(page))\n\t\t\t\tnum_poisoned_pages_inc();\n\t\t}\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "num_poisoned_pages_inc",
          "args": [],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_hwpoison_free_buddy_page",
          "args": [
            "page"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dissolve_free_huge_page",
          "args": [
            "page"
          ],
          "line": 1729
        },
        "resolved": true,
        "details": {
          "function_name": "dissolve_free_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1485-1514",
          "snippet": "int dissolve_free_huge_page(struct page *page)\n{\n\tint rc = -EBUSY;\n\n\tspin_lock(&hugetlb_lock);\n\tif (PageHuge(page) && !page_count(page)) {\n\t\tstruct page *head = compound_head(page);\n\t\tstruct hstate *h = page_hstate(head);\n\t\tint nid = page_to_nid(head);\n\t\tif (h->free_huge_pages - h->resv_huge_pages == 0)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Move PageHWPoison flag from head page to the raw error page,\n\t\t * which makes any subpages rather than the error page reusable.\n\t\t */\n\t\tif (PageHWPoison(head) && page != head) {\n\t\t\tSetPageHWPoison(page);\n\t\t\tClearPageHWPoison(head);\n\t\t}\n\t\tlist_del(&head->lru);\n\t\th->free_huge_pages--;\n\t\th->free_huge_pages_node[nid]--;\n\t\th->max_huge_pages--;\n\t\tupdate_and_free_page(h, head);\n\t\trc = 0;\n\t}\nout:\n\tspin_unlock(&hugetlb_lock);\n\treturn rc;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint dissolve_free_huge_page(struct page *page)\n{\n\tint rc = -EBUSY;\n\n\tspin_lock(&hugetlb_lock);\n\tif (PageHuge(page) && !page_count(page)) {\n\t\tstruct page *head = compound_head(page);\n\t\tstruct hstate *h = page_hstate(head);\n\t\tint nid = page_to_nid(head);\n\t\tif (h->free_huge_pages - h->resv_huge_pages == 0)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Move PageHWPoison flag from head page to the raw error page,\n\t\t * which makes any subpages rather than the error page reusable.\n\t\t */\n\t\tif (PageHWPoison(head) && page != head) {\n\t\t\tSetPageHWPoison(page);\n\t\t\tClearPageHWPoison(head);\n\t\t}\n\t\tlist_del(&head->lru);\n\t\th->free_huge_pages--;\n\t\th->free_huge_pages_node[nid]--;\n\t\th->max_huge_pages--;\n\t\tupdate_and_free_page(h, head);\n\t\trc = 0;\n\t}\nout:\n\tspin_unlock(&hugetlb_lock);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "putback_movable_pages",
          "args": [
            "&pagelist"
          ],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "putback_movable_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "167-198",
          "snippet": "void putback_movable_pages(struct list_head *l)\n{\n\tstruct page *page;\n\tstruct page *page2;\n\n\tlist_for_each_entry_safe(page, page2, l, lru) {\n\t\tif (unlikely(PageHuge(page))) {\n\t\t\tputback_active_hugepage(page);\n\t\t\tcontinue;\n\t\t}\n\t\tlist_del(&page->lru);\n\t\t/*\n\t\t * We isolated non-lru movable page so here we can use\n\t\t * __PageMovable because LRU page's mapping cannot have\n\t\t * PAGE_MAPPING_MOVABLE.\n\t\t */\n\t\tif (unlikely(__PageMovable(page))) {\n\t\t\tVM_BUG_ON_PAGE(!PageIsolated(page), page);\n\t\t\tlock_page(page);\n\t\t\tif (PageMovable(page))\n\t\t\t\tputback_movable_page(page);\n\t\t\telse\n\t\t\t\t__ClearPageIsolated(page);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t} else {\n\t\t\tmod_node_page_state(page_pgdat(page), NR_ISOLATED_ANON +\n\t\t\t\t\tpage_is_file_cache(page), -hpage_nr_pages(page));\n\t\t\tputback_lru_page(page);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nvoid putback_movable_pages(struct list_head *l)\n{\n\tstruct page *page;\n\tstruct page *page2;\n\n\tlist_for_each_entry_safe(page, page2, l, lru) {\n\t\tif (unlikely(PageHuge(page))) {\n\t\t\tputback_active_hugepage(page);\n\t\t\tcontinue;\n\t\t}\n\t\tlist_del(&page->lru);\n\t\t/*\n\t\t * We isolated non-lru movable page so here we can use\n\t\t * __PageMovable because LRU page's mapping cannot have\n\t\t * PAGE_MAPPING_MOVABLE.\n\t\t */\n\t\tif (unlikely(__PageMovable(page))) {\n\t\t\tVM_BUG_ON_PAGE(!PageIsolated(page), page);\n\t\t\tlock_page(page);\n\t\t\tif (PageMovable(page))\n\t\t\t\tputback_movable_page(page);\n\t\t\telse\n\t\t\t\t__ClearPageIsolated(page);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t} else {\n\t\t\tmod_node_page_state(page_pgdat(page), NR_ISOLATED_ANON +\n\t\t\t\t\tpage_is_file_cache(page), -hpage_nr_pages(page));\n\t\t\tputback_lru_page(page);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pagelist"
          ],
          "line": 1717
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"soft offline: %#lx: hugepage migration failed %d, type %lx (%pGp)\\n\"",
            "pfn",
            "ret",
            "page->flags",
            "&page->flags"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_pages",
          "args": [
            "&pagelist",
            "new_page",
            "NULL",
            "MPOL_MF_MOVE_ALL",
            "MIGRATE_SYNC",
            "MR_MEMORY_FAILURE"
          ],
          "line": 1712
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "1362-1449",
          "snippet": "int migrate_pages(struct list_head *from, new_page_t get_new_page,\n\t\tfree_page_t put_new_page, unsigned long private,\n\t\tenum migrate_mode mode, int reason)\n{\n\tint retry = 1;\n\tint nr_failed = 0;\n\tint nr_succeeded = 0;\n\tint pass = 0;\n\tstruct page *page;\n\tstruct page *page2;\n\tint swapwrite = current->flags & PF_SWAPWRITE;\n\tint rc;\n\n\tif (!swapwrite)\n\t\tcurrent->flags |= PF_SWAPWRITE;\n\n\tfor(pass = 0; pass < 10 && retry; pass++) {\n\t\tretry = 0;\n\n\t\tlist_for_each_entry_safe(page, page2, from, lru) {\nretry:\n\t\t\tcond_resched();\n\n\t\t\tif (PageHuge(page))\n\t\t\t\trc = unmap_and_move_huge_page(get_new_page,\n\t\t\t\t\t\tput_new_page, private, page,\n\t\t\t\t\t\tpass > 2, mode, reason);\n\t\t\telse\n\t\t\t\trc = unmap_and_move(get_new_page, put_new_page,\n\t\t\t\t\t\tprivate, page, pass > 2, mode,\n\t\t\t\t\t\treason);\n\n\t\t\tswitch(rc) {\n\t\t\tcase -ENOMEM:\n\t\t\t\t/*\n\t\t\t\t * THP migration might be unsupported or the\n\t\t\t\t * allocation could've failed so we should\n\t\t\t\t * retry on the same page with the THP split\n\t\t\t\t * to base pages.\n\t\t\t\t *\n\t\t\t\t * Head page is retried immediately and tail\n\t\t\t\t * pages are added to the tail of the list so\n\t\t\t\t * we encounter them after the rest of the list\n\t\t\t\t * is processed.\n\t\t\t\t */\n\t\t\t\tif (PageTransHuge(page) && !PageHuge(page)) {\n\t\t\t\t\tlock_page(page);\n\t\t\t\t\trc = split_huge_page_to_list(page, from);\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tif (!rc) {\n\t\t\t\t\t\tlist_safe_reset_next(page, page2, lru);\n\t\t\t\t\t\tgoto retry;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnr_failed++;\n\t\t\t\tgoto out;\n\t\t\tcase -EAGAIN:\n\t\t\t\tretry++;\n\t\t\t\tbreak;\n\t\t\tcase MIGRATEPAGE_SUCCESS:\n\t\t\t\tnr_succeeded++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t * Permanent failure (-EBUSY, -ENOSYS, etc.):\n\t\t\t\t * unlike -EAGAIN case, the failed page is\n\t\t\t\t * removed from migration page list and not\n\t\t\t\t * retried in the next outer loop.\n\t\t\t\t */\n\t\t\t\tnr_failed++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tnr_failed += retry;\n\trc = nr_failed;\nout:\n\tif (nr_succeeded)\n\t\tcount_vm_events(PGMIGRATE_SUCCESS, nr_succeeded);\n\tif (nr_failed)\n\t\tcount_vm_events(PGMIGRATE_FAIL, nr_failed);\n\ttrace_mm_migrate_pages(nr_succeeded, nr_failed, mode, reason);\n\n\tif (!swapwrite)\n\t\tcurrent->flags &= ~PF_SWAPWRITE;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nint migrate_pages(struct list_head *from, new_page_t get_new_page,\n\t\tfree_page_t put_new_page, unsigned long private,\n\t\tenum migrate_mode mode, int reason)\n{\n\tint retry = 1;\n\tint nr_failed = 0;\n\tint nr_succeeded = 0;\n\tint pass = 0;\n\tstruct page *page;\n\tstruct page *page2;\n\tint swapwrite = current->flags & PF_SWAPWRITE;\n\tint rc;\n\n\tif (!swapwrite)\n\t\tcurrent->flags |= PF_SWAPWRITE;\n\n\tfor(pass = 0; pass < 10 && retry; pass++) {\n\t\tretry = 0;\n\n\t\tlist_for_each_entry_safe(page, page2, from, lru) {\nretry:\n\t\t\tcond_resched();\n\n\t\t\tif (PageHuge(page))\n\t\t\t\trc = unmap_and_move_huge_page(get_new_page,\n\t\t\t\t\t\tput_new_page, private, page,\n\t\t\t\t\t\tpass > 2, mode, reason);\n\t\t\telse\n\t\t\t\trc = unmap_and_move(get_new_page, put_new_page,\n\t\t\t\t\t\tprivate, page, pass > 2, mode,\n\t\t\t\t\t\treason);\n\n\t\t\tswitch(rc) {\n\t\t\tcase -ENOMEM:\n\t\t\t\t/*\n\t\t\t\t * THP migration might be unsupported or the\n\t\t\t\t * allocation could've failed so we should\n\t\t\t\t * retry on the same page with the THP split\n\t\t\t\t * to base pages.\n\t\t\t\t *\n\t\t\t\t * Head page is retried immediately and tail\n\t\t\t\t * pages are added to the tail of the list so\n\t\t\t\t * we encounter them after the rest of the list\n\t\t\t\t * is processed.\n\t\t\t\t */\n\t\t\t\tif (PageTransHuge(page) && !PageHuge(page)) {\n\t\t\t\t\tlock_page(page);\n\t\t\t\t\trc = split_huge_page_to_list(page, from);\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tif (!rc) {\n\t\t\t\t\t\tlist_safe_reset_next(page, page2, lru);\n\t\t\t\t\t\tgoto retry;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnr_failed++;\n\t\t\t\tgoto out;\n\t\t\tcase -EAGAIN:\n\t\t\t\tretry++;\n\t\t\t\tbreak;\n\t\t\tcase MIGRATEPAGE_SUCCESS:\n\t\t\t\tnr_succeeded++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t * Permanent failure (-EBUSY, -ENOSYS, etc.):\n\t\t\t\t * unlike -EAGAIN case, the failed page is\n\t\t\t\t * removed from migration page list and not\n\t\t\t\t * retried in the next outer loop.\n\t\t\t\t */\n\t\t\t\tnr_failed++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tnr_failed += retry;\n\trc = nr_failed;\nout:\n\tif (nr_succeeded)\n\t\tcount_vm_events(PGMIGRATE_SUCCESS, nr_succeeded);\n\tif (nr_failed)\n\t\tcount_vm_events(PGMIGRATE_FAIL, nr_failed);\n\ttrace_mm_migrate_pages(nr_succeeded, nr_failed, mode, reason);\n\n\tif (!swapwrite)\n\t\tcurrent->flags &= ~PF_SWAPWRITE;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"soft offline: %#lx hugepage failed to isolate\\n\"",
            "pfn"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_hwpoison_page",
          "args": [
            "hpage"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isolate_huge_page",
          "args": [
            "hpage",
            "&pagelist"
          ],
          "line": 1701
        },
        "resolved": true,
        "details": {
          "function_name": "isolate_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "4891-4906",
          "snippet": "bool isolate_huge_page(struct page *page, struct list_head *list)\n{\n\tbool ret = true;\n\n\tVM_BUG_ON_PAGE(!PageHead(page), page);\n\tspin_lock(&hugetlb_lock);\n\tif (!page_huge_active(page) || !get_page_unless_zero(page)) {\n\t\tret = false;\n\t\tgoto unlock;\n\t}\n\tclear_page_huge_active(page);\n\tlist_move_tail(&page->lru, list);\nunlock:\n\tspin_unlock(&hugetlb_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nbool isolate_huge_page(struct page *page, struct list_head *list)\n{\n\tbool ret = true;\n\n\tVM_BUG_ON_PAGE(!PageHead(page), page);\n\tspin_lock(&hugetlb_lock);\n\tif (!page_huge_active(page) || !get_page_unless_zero(page)) {\n\t\tret = false;\n\t\tgoto unlock;\n\t}\n\tclear_page_huge_active(page);\n\tlist_move_tail(&page->lru, list);\nunlock:\n\tspin_unlock(&hugetlb_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "hpage"
          ],
          "line": 1699
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"soft offline: %#lx hugepage already poisoned\\n\"",
            "pfn"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_hwpoison_page",
          "args": [
            "hpage"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHWPoison",
          "args": [
            "hpage"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "pagelist"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int soft_offline_huge_page(struct page *page, int flags)\n{\n\tint ret;\n\tunsigned long pfn = page_to_pfn(page);\n\tstruct page *hpage = compound_head(page);\n\tLIST_HEAD(pagelist);\n\n\t/*\n\t * This double-check of PageHWPoison is to avoid the race with\n\t * memory_failure(). See also comment in __soft_offline_page().\n\t */\n\tlock_page(hpage);\n\tif (PageHWPoison(hpage)) {\n\t\tunlock_page(hpage);\n\t\tput_hwpoison_page(hpage);\n\t\tpr_info(\"soft offline: %#lx hugepage already poisoned\\n\", pfn);\n\t\treturn -EBUSY;\n\t}\n\tunlock_page(hpage);\n\n\tret = isolate_huge_page(hpage, &pagelist);\n\t/*\n\t * get_any_page() and isolate_huge_page() takes a refcount each,\n\t * so need to drop one here.\n\t */\n\tput_hwpoison_page(hpage);\n\tif (!ret) {\n\t\tpr_info(\"soft offline: %#lx hugepage failed to isolate\\n\", pfn);\n\t\treturn -EBUSY;\n\t}\n\n\tret = migrate_pages(&pagelist, new_page, NULL, MPOL_MF_MOVE_ALL,\n\t\t\t\tMIGRATE_SYNC, MR_MEMORY_FAILURE);\n\tif (ret) {\n\t\tpr_info(\"soft offline: %#lx: hugepage migration failed %d, type %lx (%pGp)\\n\",\n\t\t\tpfn, ret, page->flags, &page->flags);\n\t\tif (!list_empty(&pagelist))\n\t\t\tputback_movable_pages(&pagelist);\n\t\tif (ret > 0)\n\t\t\tret = -EIO;\n\t} else {\n\t\t/*\n\t\t * We set PG_hwpoison only when the migration source hugepage\n\t\t * was successfully dissolved, because otherwise hwpoisoned\n\t\t * hugepage remains on free hugepage list, then userspace will\n\t\t * find it as SIGBUS by allocation failure. That's not expected\n\t\t * in soft-offlining.\n\t\t */\n\t\tret = dissolve_free_huge_page(page);\n\t\tif (!ret) {\n\t\t\tif (set_hwpoison_free_buddy_page(page))\n\t\t\t\tnum_poisoned_pages_inc();\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "get_any_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "1654-1679",
    "snippet": "static int get_any_page(struct page *page, unsigned long pfn, int flags)\n{\n\tint ret = __get_any_page(page, pfn, flags);\n\n\tif (ret == 1 && !PageHuge(page) &&\n\t    !PageLRU(page) && !__PageMovable(page)) {\n\t\t/*\n\t\t * Try to free it.\n\t\t */\n\t\tput_hwpoison_page(page);\n\t\tshake_page(page, 1);\n\n\t\t/*\n\t\t * Did it turn free?\n\t\t */\n\t\tret = __get_any_page(page, pfn, 0);\n\t\tif (ret == 1 && !PageLRU(page)) {\n\t\t\t/* Drop page reference which is from __get_any_page() */\n\t\t\tput_hwpoison_page(page);\n\t\t\tpr_info(\"soft_offline: %#lx: unknown non LRU page type %lx (%pGp)\\n\",\n\t\t\t\tpfn, page->flags, &page->flags);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"soft_offline: %#lx: unknown non LRU page type %lx (%pGp)\\n\"",
            "pfn",
            "page->flags",
            "&page->flags"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_hwpoison_page",
          "args": [
            "page"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_any_page",
          "args": [
            "page",
            "pfn",
            "0"
          ],
          "line": 1669
        },
        "resolved": true,
        "details": {
          "function_name": "__get_any_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "1624-1652",
          "snippet": "static int __get_any_page(struct page *p, unsigned long pfn, int flags)\n{\n\tint ret;\n\n\tif (flags & MF_COUNT_INCREASED)\n\t\treturn 1;\n\n\t/*\n\t * When the target page is a free hugepage, just remove it\n\t * from free hugepage list.\n\t */\n\tif (!get_hwpoison_page(p)) {\n\t\tif (PageHuge(p)) {\n\t\t\tpr_info(\"%s: %#lx free huge page\\n\", __func__, pfn);\n\t\t\tret = 0;\n\t\t} else if (is_free_buddy_page(p)) {\n\t\t\tpr_info(\"%s: %#lx free buddy page\\n\", __func__, pfn);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\tpr_info(\"%s: %#lx: unknown zero refcount page type %lx\\n\",\n\t\t\t\t__func__, pfn, p->flags);\n\t\t\tret = -EIO;\n\t\t}\n\t} else {\n\t\t/* Not a free page */\n\t\tret = 1;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int __get_any_page(struct page *p, unsigned long pfn, int flags)\n{\n\tint ret;\n\n\tif (flags & MF_COUNT_INCREASED)\n\t\treturn 1;\n\n\t/*\n\t * When the target page is a free hugepage, just remove it\n\t * from free hugepage list.\n\t */\n\tif (!get_hwpoison_page(p)) {\n\t\tif (PageHuge(p)) {\n\t\t\tpr_info(\"%s: %#lx free huge page\\n\", __func__, pfn);\n\t\t\tret = 0;\n\t\t} else if (is_free_buddy_page(p)) {\n\t\t\tpr_info(\"%s: %#lx free buddy page\\n\", __func__, pfn);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\tpr_info(\"%s: %#lx: unknown zero refcount page type %lx\\n\",\n\t\t\t\t__func__, pfn, p->flags);\n\t\t\tret = -EIO;\n\t\t}\n\t} else {\n\t\t/* Not a free page */\n\t\tret = 1;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "shake_page",
          "args": [
            "page",
            "1"
          ],
          "line": 1664
        },
        "resolved": true,
        "details": {
          "function_name": "shake_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "245-265",
          "snippet": "void shake_page(struct page *p, int access)\n{\n\tif (PageHuge(p))\n\t\treturn;\n\n\tif (!PageSlab(p)) {\n\t\tlru_add_drain_all();\n\t\tif (PageLRU(p))\n\t\t\treturn;\n\t\tdrain_all_pages(page_zone(p));\n\t\tif (PageLRU(p) || is_free_buddy_page(p))\n\t\t\treturn;\n\t}\n\n\t/*\n\t * Only call shrink_node_slabs here (which would also shrink\n\t * other caches) if access is not potentially fatal.\n\t */\n\tif (access)\n\t\tdrop_slab_node(page_to_nid(p));\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nvoid shake_page(struct page *p, int access)\n{\n\tif (PageHuge(p))\n\t\treturn;\n\n\tif (!PageSlab(p)) {\n\t\tlru_add_drain_all();\n\t\tif (PageLRU(p))\n\t\t\treturn;\n\t\tdrain_all_pages(page_zone(p));\n\t\tif (PageLRU(p) || is_free_buddy_page(p))\n\t\t\treturn;\n\t}\n\n\t/*\n\t * Only call shrink_node_slabs here (which would also shrink\n\t * other caches) if access is not potentially fatal.\n\t */\n\tif (access)\n\t\tdrop_slab_node(page_to_nid(p));\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_hwpoison_page",
          "args": [
            "page"
          ],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__PageMovable",
          "args": [
            "page"
          ],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "page"
          ],
          "line": 1658
        },
        "resolved": true,
        "details": {
          "function_name": "PageHugeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "225-228",
          "snippet": "static int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int get_any_page(struct page *page, unsigned long pfn, int flags)\n{\n\tint ret = __get_any_page(page, pfn, flags);\n\n\tif (ret == 1 && !PageHuge(page) &&\n\t    !PageLRU(page) && !__PageMovable(page)) {\n\t\t/*\n\t\t * Try to free it.\n\t\t */\n\t\tput_hwpoison_page(page);\n\t\tshake_page(page, 1);\n\n\t\t/*\n\t\t * Did it turn free?\n\t\t */\n\t\tret = __get_any_page(page, pfn, 0);\n\t\tif (ret == 1 && !PageLRU(page)) {\n\t\t\t/* Drop page reference which is from __get_any_page() */\n\t\t\tput_hwpoison_page(page);\n\t\t\tpr_info(\"soft_offline: %#lx: unknown non LRU page type %lx (%pGp)\\n\",\n\t\t\t\tpfn, page->flags, &page->flags);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "__get_any_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "1624-1652",
    "snippet": "static int __get_any_page(struct page *p, unsigned long pfn, int flags)\n{\n\tint ret;\n\n\tif (flags & MF_COUNT_INCREASED)\n\t\treturn 1;\n\n\t/*\n\t * When the target page is a free hugepage, just remove it\n\t * from free hugepage list.\n\t */\n\tif (!get_hwpoison_page(p)) {\n\t\tif (PageHuge(p)) {\n\t\t\tpr_info(\"%s: %#lx free huge page\\n\", __func__, pfn);\n\t\t\tret = 0;\n\t\t} else if (is_free_buddy_page(p)) {\n\t\t\tpr_info(\"%s: %#lx free buddy page\\n\", __func__, pfn);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\tpr_info(\"%s: %#lx: unknown zero refcount page type %lx\\n\",\n\t\t\t\t__func__, pfn, p->flags);\n\t\t\tret = -EIO;\n\t\t}\n\t} else {\n\t\t/* Not a free page */\n\t\tret = 1;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s: %#lx: unknown zero refcount page type %lx\\n\"",
            "__func__",
            "pfn",
            "p->flags"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s: %#lx free buddy page\\n\"",
            "__func__",
            "pfn"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_free_buddy_page",
          "args": [
            "p"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s: %#lx free huge page\\n\"",
            "__func__",
            "pfn"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "p"
          ],
          "line": 1636
        },
        "resolved": true,
        "details": {
          "function_name": "PageHugeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "225-228",
          "snippet": "static int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_hwpoison_page",
          "args": [
            "p"
          ],
          "line": 1635
        },
        "resolved": true,
        "details": {
          "function_name": "get_hwpoison_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "928-956",
          "snippet": "int get_hwpoison_page(struct page *page)\n{\n\tstruct page *head = compound_head(page);\n\n\tif (!PageHuge(head) && PageTransHuge(head)) {\n\t\t/*\n\t\t * Non anonymous thp exists only in allocation/free time. We\n\t\t * can't handle such a case correctly, so let's give it up.\n\t\t * This should be better than triggering BUG_ON when kernel\n\t\t * tries to touch the \"partially handled\" page.\n\t\t */\n\t\tif (!PageAnon(head)) {\n\t\t\tpr_err(\"Memory failure: %#lx: non anonymous thp\\n\",\n\t\t\t\tpage_to_pfn(page));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (get_page_unless_zero(head)) {\n\t\tif (head == compound_head(page))\n\t\t\treturn 1;\n\n\t\tpr_info(\"Memory failure: %#lx cannot catch tail\\n\",\n\t\t\tpage_to_pfn(page));\n\t\tput_page(head);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define head\t\t(1UL << PG_head)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define head\t\t(1UL << PG_head)\n\nint get_hwpoison_page(struct page *page)\n{\n\tstruct page *head = compound_head(page);\n\n\tif (!PageHuge(head) && PageTransHuge(head)) {\n\t\t/*\n\t\t * Non anonymous thp exists only in allocation/free time. We\n\t\t * can't handle such a case correctly, so let's give it up.\n\t\t * This should be better than triggering BUG_ON when kernel\n\t\t * tries to touch the \"partially handled\" page.\n\t\t */\n\t\tif (!PageAnon(head)) {\n\t\t\tpr_err(\"Memory failure: %#lx: non anonymous thp\\n\",\n\t\t\t\tpage_to_pfn(page));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (get_page_unless_zero(head)) {\n\t\tif (head == compound_head(page))\n\t\t\treturn 1;\n\n\t\tpr_info(\"Memory failure: %#lx cannot catch tail\\n\",\n\t\t\tpage_to_pfn(page));\n\t\tput_page(head);\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int __get_any_page(struct page *p, unsigned long pfn, int flags)\n{\n\tint ret;\n\n\tif (flags & MF_COUNT_INCREASED)\n\t\treturn 1;\n\n\t/*\n\t * When the target page is a free hugepage, just remove it\n\t * from free hugepage list.\n\t */\n\tif (!get_hwpoison_page(p)) {\n\t\tif (PageHuge(p)) {\n\t\t\tpr_info(\"%s: %#lx free huge page\\n\", __func__, pfn);\n\t\t\tret = 0;\n\t\t} else if (is_free_buddy_page(p)) {\n\t\t\tpr_info(\"%s: %#lx free buddy page\\n\", __func__, pfn);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\tpr_info(\"%s: %#lx: unknown zero refcount page type %lx\\n\",\n\t\t\t\t__func__, pfn, p->flags);\n\t\t\tret = -EIO;\n\t\t}\n\t} else {\n\t\t/* Not a free page */\n\t\tret = 1;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "new_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "1611-1616",
    "snippet": "static struct page *new_page(struct page *p, unsigned long private)\n{\n\tint nid = page_to_nid(p);\n\n\treturn new_page_nodemask(p, nid, &node_states[N_MEMORY]);\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "new_page_nodemask",
          "args": [
            "p",
            "nid",
            "&node_states[N_MEMORY]"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "p"
          ],
          "line": 1613
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic struct page *new_page(struct page *p, unsigned long private)\n{\n\tint nid = page_to_nid(p);\n\n\treturn new_page_nodemask(p, nid, &node_states[N_MEMORY]);\n}"
  },
  {
    "function_name": "unpoison_memory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "1531-1608",
    "snippet": "int unpoison_memory(unsigned long pfn)\n{\n\tstruct page *page;\n\tstruct page *p;\n\tint freeit = 0;\n\tstatic DEFINE_RATELIMIT_STATE(unpoison_rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t\tDEFAULT_RATELIMIT_BURST);\n\n\tif (!pfn_valid(pfn))\n\t\treturn -ENXIO;\n\n\tp = pfn_to_page(pfn);\n\tpage = compound_head(p);\n\n\tif (!PageHWPoison(p)) {\n\t\tunpoison_pr_info(\"Unpoison: Page was already unpoisoned %#lx\\n\",\n\t\t\t\t pfn, &unpoison_rs);\n\t\treturn 0;\n\t}\n\n\tif (page_count(page) > 1) {\n\t\tunpoison_pr_info(\"Unpoison: Someone grabs the hwpoison page %#lx\\n\",\n\t\t\t\t pfn, &unpoison_rs);\n\t\treturn 0;\n\t}\n\n\tif (page_mapped(page)) {\n\t\tunpoison_pr_info(\"Unpoison: Someone maps the hwpoison page %#lx\\n\",\n\t\t\t\t pfn, &unpoison_rs);\n\t\treturn 0;\n\t}\n\n\tif (page_mapping(page)) {\n\t\tunpoison_pr_info(\"Unpoison: the hwpoison page has non-NULL mapping %#lx\\n\",\n\t\t\t\t pfn, &unpoison_rs);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * unpoison_memory() can encounter thp only when the thp is being\n\t * worked by memory_failure() and the page lock is not held yet.\n\t * In such case, we yield to memory_failure() and make unpoison fail.\n\t */\n\tif (!PageHuge(page) && PageTransHuge(page)) {\n\t\tunpoison_pr_info(\"Unpoison: Memory failure is now running on %#lx\\n\",\n\t\t\t\t pfn, &unpoison_rs);\n\t\treturn 0;\n\t}\n\n\tif (!get_hwpoison_page(p)) {\n\t\tif (TestClearPageHWPoison(p))\n\t\t\tnum_poisoned_pages_dec();\n\t\tunpoison_pr_info(\"Unpoison: Software-unpoisoned free page %#lx\\n\",\n\t\t\t\t pfn, &unpoison_rs);\n\t\treturn 0;\n\t}\n\n\tlock_page(page);\n\t/*\n\t * This test is racy because PG_hwpoison is set outside of page lock.\n\t * That's acceptable because that won't trigger kernel panic. Instead,\n\t * the PG_hwpoison page will be caught and isolated on the entrance to\n\t * the free buddy page pool.\n\t */\n\tif (TestClearPageHWPoison(page)) {\n\t\tunpoison_pr_info(\"Unpoison: Software-unpoisoned page %#lx\\n\",\n\t\t\t\t pfn, &unpoison_rs);\n\t\tnum_poisoned_pages_dec();\n\t\tfreeit = 1;\n\t}\n\tunlock_page(page);\n\n\tput_hwpoison_page(page);\n\tif (freeit && !(pfn == my_zero_pfn(0) && page_count(p) == 1))\n\t\tput_hwpoison_page(page);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_hwpoison_page",
          "args": [
            "page"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "p"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "my_zero_pfn",
          "args": [
            "0"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_hwpoison_page",
          "args": [
            "page"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1601
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_poisoned_pages_dec",
          "args": [],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unpoison_pr_info",
          "args": [
            "\"Unpoison: Software-unpoisoned page %#lx\\n\"",
            "pfn",
            "&unpoison_rs"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestClearPageHWPoison",
          "args": [
            "page"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unpoison_pr_info",
          "args": [
            "\"Unpoison: Software-unpoisoned free page %#lx\\n\"",
            "pfn",
            "&unpoison_rs"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_poisoned_pages_dec",
          "args": [],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestClearPageHWPoison",
          "args": [
            "p"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_hwpoison_page",
          "args": [
            "p"
          ],
          "line": 1580
        },
        "resolved": true,
        "details": {
          "function_name": "get_hwpoison_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "928-956",
          "snippet": "int get_hwpoison_page(struct page *page)\n{\n\tstruct page *head = compound_head(page);\n\n\tif (!PageHuge(head) && PageTransHuge(head)) {\n\t\t/*\n\t\t * Non anonymous thp exists only in allocation/free time. We\n\t\t * can't handle such a case correctly, so let's give it up.\n\t\t * This should be better than triggering BUG_ON when kernel\n\t\t * tries to touch the \"partially handled\" page.\n\t\t */\n\t\tif (!PageAnon(head)) {\n\t\t\tpr_err(\"Memory failure: %#lx: non anonymous thp\\n\",\n\t\t\t\tpage_to_pfn(page));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (get_page_unless_zero(head)) {\n\t\tif (head == compound_head(page))\n\t\t\treturn 1;\n\n\t\tpr_info(\"Memory failure: %#lx cannot catch tail\\n\",\n\t\t\tpage_to_pfn(page));\n\t\tput_page(head);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define head\t\t(1UL << PG_head)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define head\t\t(1UL << PG_head)\n\nint get_hwpoison_page(struct page *page)\n{\n\tstruct page *head = compound_head(page);\n\n\tif (!PageHuge(head) && PageTransHuge(head)) {\n\t\t/*\n\t\t * Non anonymous thp exists only in allocation/free time. We\n\t\t * can't handle such a case correctly, so let's give it up.\n\t\t * This should be better than triggering BUG_ON when kernel\n\t\t * tries to touch the \"partially handled\" page.\n\t\t */\n\t\tif (!PageAnon(head)) {\n\t\t\tpr_err(\"Memory failure: %#lx: non anonymous thp\\n\",\n\t\t\t\tpage_to_pfn(page));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (get_page_unless_zero(head)) {\n\t\tif (head == compound_head(page))\n\t\t\treturn 1;\n\n\t\tpr_info(\"Memory failure: %#lx cannot catch tail\\n\",\n\t\t\tpage_to_pfn(page));\n\t\tput_page(head);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unpoison_pr_info",
          "args": [
            "\"Unpoison: Memory failure is now running on %#lx\\n\"",
            "pfn",
            "&unpoison_rs"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "page"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "page"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "PageHugeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "225-228",
          "snippet": "static int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unpoison_pr_info",
          "args": [
            "\"Unpoison: the hwpoison page has non-NULL mapping %#lx\\n\"",
            "pfn",
            "&unpoison_rs"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "page"
          ],
          "line": 1563
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapping_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "528-533",
          "snippet": "struct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unpoison_pr_info",
          "args": [
            "\"Unpoison: Someone maps the hwpoison page %#lx\\n\"",
            "pfn",
            "&unpoison_rs"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapped",
          "args": [
            "page"
          ],
          "line": 1557
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "470-486",
          "snippet": "bool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nbool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unpoison_pr_info",
          "args": [
            "\"Unpoison: Someone grabs the hwpoison page %#lx\\n\"",
            "pfn",
            "&unpoison_rs"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unpoison_pr_info",
          "args": [
            "\"Unpoison: Page was already unpoisoned %#lx\\n\"",
            "pfn",
            "&unpoison_rs"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHWPoison",
          "args": [
            "p"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "p"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "pfn"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint unpoison_memory(unsigned long pfn)\n{\n\tstruct page *page;\n\tstruct page *p;\n\tint freeit = 0;\n\tstatic DEFINE_RATELIMIT_STATE(unpoison_rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t\tDEFAULT_RATELIMIT_BURST);\n\n\tif (!pfn_valid(pfn))\n\t\treturn -ENXIO;\n\n\tp = pfn_to_page(pfn);\n\tpage = compound_head(p);\n\n\tif (!PageHWPoison(p)) {\n\t\tunpoison_pr_info(\"Unpoison: Page was already unpoisoned %#lx\\n\",\n\t\t\t\t pfn, &unpoison_rs);\n\t\treturn 0;\n\t}\n\n\tif (page_count(page) > 1) {\n\t\tunpoison_pr_info(\"Unpoison: Someone grabs the hwpoison page %#lx\\n\",\n\t\t\t\t pfn, &unpoison_rs);\n\t\treturn 0;\n\t}\n\n\tif (page_mapped(page)) {\n\t\tunpoison_pr_info(\"Unpoison: Someone maps the hwpoison page %#lx\\n\",\n\t\t\t\t pfn, &unpoison_rs);\n\t\treturn 0;\n\t}\n\n\tif (page_mapping(page)) {\n\t\tunpoison_pr_info(\"Unpoison: the hwpoison page has non-NULL mapping %#lx\\n\",\n\t\t\t\t pfn, &unpoison_rs);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * unpoison_memory() can encounter thp only when the thp is being\n\t * worked by memory_failure() and the page lock is not held yet.\n\t * In such case, we yield to memory_failure() and make unpoison fail.\n\t */\n\tif (!PageHuge(page) && PageTransHuge(page)) {\n\t\tunpoison_pr_info(\"Unpoison: Memory failure is now running on %#lx\\n\",\n\t\t\t\t pfn, &unpoison_rs);\n\t\treturn 0;\n\t}\n\n\tif (!get_hwpoison_page(p)) {\n\t\tif (TestClearPageHWPoison(p))\n\t\t\tnum_poisoned_pages_dec();\n\t\tunpoison_pr_info(\"Unpoison: Software-unpoisoned free page %#lx\\n\",\n\t\t\t\t pfn, &unpoison_rs);\n\t\treturn 0;\n\t}\n\n\tlock_page(page);\n\t/*\n\t * This test is racy because PG_hwpoison is set outside of page lock.\n\t * That's acceptable because that won't trigger kernel panic. Instead,\n\t * the PG_hwpoison page will be caught and isolated on the entrance to\n\t * the free buddy page pool.\n\t */\n\tif (TestClearPageHWPoison(page)) {\n\t\tunpoison_pr_info(\"Unpoison: Software-unpoisoned page %#lx\\n\",\n\t\t\t\t pfn, &unpoison_rs);\n\t\tnum_poisoned_pages_dec();\n\t\tfreeit = 1;\n\t}\n\tunlock_page(page);\n\n\tput_hwpoison_page(page);\n\tif (freeit && !(pfn == my_zero_pfn(0) && page_count(p) == 1))\n\t\tput_hwpoison_page(page);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "memory_failure_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "1497-1510",
    "snippet": "static int __init memory_failure_init(void)\n{\n\tstruct memory_failure_cpu *mf_cpu;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tmf_cpu = &per_cpu(memory_failure_cpu, cpu);\n\t\tspin_lock_init(&mf_cpu->lock);\n\t\tINIT_KFIFO(mf_cpu->fifo);\n\t\tINIT_WORK(&mf_cpu->work, memory_failure_work_func);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct memory_failure_cpu, memory_failure_cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&mf_cpu->work",
            "memory_failure_work_func"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_KFIFO",
          "args": [
            "mf_cpu->fifo"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&mf_cpu->lock"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "memory_failure_cpu",
            "cpu"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_PER_CPU(struct memory_failure_cpu, memory_failure_cpu);\n\nstatic int __init memory_failure_init(void)\n{\n\tstruct memory_failure_cpu *mf_cpu;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tmf_cpu = &per_cpu(memory_failure_cpu, cpu);\n\t\tspin_lock_init(&mf_cpu->lock);\n\t\tINIT_KFIFO(mf_cpu->fifo);\n\t\tINIT_WORK(&mf_cpu->work, memory_failure_work_func);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "memory_failure_work_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "1476-1495",
    "snippet": "static void memory_failure_work_func(struct work_struct *work)\n{\n\tstruct memory_failure_cpu *mf_cpu;\n\tstruct memory_failure_entry entry = { 0, };\n\tunsigned long proc_flags;\n\tint gotten;\n\n\tmf_cpu = this_cpu_ptr(&memory_failure_cpu);\n\tfor (;;) {\n\t\tspin_lock_irqsave(&mf_cpu->lock, proc_flags);\n\t\tgotten = kfifo_get(&mf_cpu->fifo, &entry);\n\t\tspin_unlock_irqrestore(&mf_cpu->lock, proc_flags);\n\t\tif (!gotten)\n\t\t\tbreak;\n\t\tif (entry.flags & MF_SOFT_OFFLINE)\n\t\t\tsoft_offline_page(pfn_to_page(entry.pfn), entry.flags);\n\t\telse\n\t\t\tmemory_failure(entry.pfn, entry.flags);\n\t}\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct memory_failure_cpu, memory_failure_cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memory_failure",
          "args": [
            "entry.pfn",
            "entry.flags"
          ],
          "line": 1493
        },
        "resolved": true,
        "details": {
          "function_name": "memory_failure_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "1455-1473",
          "snippet": "void memory_failure_queue(unsigned long pfn, int flags)\n{\n\tstruct memory_failure_cpu *mf_cpu;\n\tunsigned long proc_flags;\n\tstruct memory_failure_entry entry = {\n\t\t.pfn =\t\tpfn,\n\t\t.flags =\tflags,\n\t};\n\n\tmf_cpu = &get_cpu_var(memory_failure_cpu);\n\tspin_lock_irqsave(&mf_cpu->lock, proc_flags);\n\tif (kfifo_put(&mf_cpu->fifo, entry))\n\t\tschedule_work_on(smp_processor_id(), &mf_cpu->work);\n\telse\n\t\tpr_err(\"Memory failure: buffer overflow when queuing memory failure at %#lx\\n\",\n\t\t       pfn);\n\tspin_unlock_irqrestore(&mf_cpu->lock, proc_flags);\n\tput_cpu_var(memory_failure_cpu);\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct memory_failure_cpu, memory_failure_cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_PER_CPU(struct memory_failure_cpu, memory_failure_cpu);\n\nvoid memory_failure_queue(unsigned long pfn, int flags)\n{\n\tstruct memory_failure_cpu *mf_cpu;\n\tunsigned long proc_flags;\n\tstruct memory_failure_entry entry = {\n\t\t.pfn =\t\tpfn,\n\t\t.flags =\tflags,\n\t};\n\n\tmf_cpu = &get_cpu_var(memory_failure_cpu);\n\tspin_lock_irqsave(&mf_cpu->lock, proc_flags);\n\tif (kfifo_put(&mf_cpu->fifo, entry))\n\t\tschedule_work_on(smp_processor_id(), &mf_cpu->work);\n\telse\n\t\tpr_err(\"Memory failure: buffer overflow when queuing memory failure at %#lx\\n\",\n\t\t       pfn);\n\tspin_unlock_irqrestore(&mf_cpu->lock, proc_flags);\n\tput_cpu_var(memory_failure_cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "soft_offline_page",
          "args": [
            "pfn_to_page(entry.pfn)",
            "entry.flags"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "soft_offline_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "1895-1925",
          "snippet": "int soft_offline_page(struct page *page, int flags)\n{\n\tint ret;\n\tunsigned long pfn = page_to_pfn(page);\n\n\tif (is_zone_device_page(page)) {\n\t\tpr_debug_ratelimited(\"soft_offline: %#lx page is device page\\n\",\n\t\t\t\tpfn);\n\t\tif (flags & MF_COUNT_INCREASED)\n\t\t\tput_page(page);\n\t\treturn -EIO;\n\t}\n\n\tif (PageHWPoison(page)) {\n\t\tpr_info(\"soft offline: %#lx page already poisoned\\n\", pfn);\n\t\tif (flags & MF_COUNT_INCREASED)\n\t\t\tput_hwpoison_page(page);\n\t\treturn -EBUSY;\n\t}\n\n\tget_online_mems();\n\tret = get_any_page(page, pfn, flags);\n\tput_online_mems();\n\n\tif (ret > 0)\n\t\tret = soft_offline_in_use_page(page, flags);\n\telse if (ret == 0)\n\t\tret = soft_offline_free_page(page);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint soft_offline_page(struct page *page, int flags)\n{\n\tint ret;\n\tunsigned long pfn = page_to_pfn(page);\n\n\tif (is_zone_device_page(page)) {\n\t\tpr_debug_ratelimited(\"soft_offline: %#lx page is device page\\n\",\n\t\t\t\tpfn);\n\t\tif (flags & MF_COUNT_INCREASED)\n\t\t\tput_page(page);\n\t\treturn -EIO;\n\t}\n\n\tif (PageHWPoison(page)) {\n\t\tpr_info(\"soft offline: %#lx page already poisoned\\n\", pfn);\n\t\tif (flags & MF_COUNT_INCREASED)\n\t\t\tput_hwpoison_page(page);\n\t\treturn -EBUSY;\n\t}\n\n\tget_online_mems();\n\tret = get_any_page(page, pfn, flags);\n\tput_online_mems();\n\n\tif (ret > 0)\n\t\tret = soft_offline_in_use_page(page, flags);\n\telse if (ret == 0)\n\t\tret = soft_offline_free_page(page);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "entry.pfn"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&mf_cpu->lock",
            "proc_flags"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfifo_get",
          "args": [
            "&mf_cpu->fifo",
            "&entry"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&mf_cpu->lock",
            "proc_flags"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&memory_failure_cpu"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_PER_CPU(struct memory_failure_cpu, memory_failure_cpu);\n\nstatic void memory_failure_work_func(struct work_struct *work)\n{\n\tstruct memory_failure_cpu *mf_cpu;\n\tstruct memory_failure_entry entry = { 0, };\n\tunsigned long proc_flags;\n\tint gotten;\n\n\tmf_cpu = this_cpu_ptr(&memory_failure_cpu);\n\tfor (;;) {\n\t\tspin_lock_irqsave(&mf_cpu->lock, proc_flags);\n\t\tgotten = kfifo_get(&mf_cpu->fifo, &entry);\n\t\tspin_unlock_irqrestore(&mf_cpu->lock, proc_flags);\n\t\tif (!gotten)\n\t\t\tbreak;\n\t\tif (entry.flags & MF_SOFT_OFFLINE)\n\t\t\tsoft_offline_page(pfn_to_page(entry.pfn), entry.flags);\n\t\telse\n\t\t\tmemory_failure(entry.pfn, entry.flags);\n\t}\n}"
  },
  {
    "function_name": "memory_failure_queue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "1455-1473",
    "snippet": "void memory_failure_queue(unsigned long pfn, int flags)\n{\n\tstruct memory_failure_cpu *mf_cpu;\n\tunsigned long proc_flags;\n\tstruct memory_failure_entry entry = {\n\t\t.pfn =\t\tpfn,\n\t\t.flags =\tflags,\n\t};\n\n\tmf_cpu = &get_cpu_var(memory_failure_cpu);\n\tspin_lock_irqsave(&mf_cpu->lock, proc_flags);\n\tif (kfifo_put(&mf_cpu->fifo, entry))\n\t\tschedule_work_on(smp_processor_id(), &mf_cpu->work);\n\telse\n\t\tpr_err(\"Memory failure: buffer overflow when queuing memory failure at %#lx\\n\",\n\t\t       pfn);\n\tspin_unlock_irqrestore(&mf_cpu->lock, proc_flags);\n\tput_cpu_var(memory_failure_cpu);\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct memory_failure_cpu, memory_failure_cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cpu_var",
          "args": [
            "memory_failure_cpu"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&mf_cpu->lock",
            "proc_flags"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Memory failure: buffer overflow when queuing memory failure at %#lx\\n\"",
            "pfn"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_work_on",
          "args": [
            "smp_processor_id()",
            "&mf_cpu->work"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfifo_put",
          "args": [
            "&mf_cpu->fifo",
            "entry"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&mf_cpu->lock",
            "proc_flags"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu_var",
          "args": [
            "memory_failure_cpu"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_PER_CPU(struct memory_failure_cpu, memory_failure_cpu);\n\nvoid memory_failure_queue(unsigned long pfn, int flags)\n{\n\tstruct memory_failure_cpu *mf_cpu;\n\tunsigned long proc_flags;\n\tstruct memory_failure_entry entry = {\n\t\t.pfn =\t\tpfn,\n\t\t.flags =\tflags,\n\t};\n\n\tmf_cpu = &get_cpu_var(memory_failure_cpu);\n\tspin_lock_irqsave(&mf_cpu->lock, proc_flags);\n\tif (kfifo_put(&mf_cpu->fifo, entry))\n\t\tschedule_work_on(smp_processor_id(), &mf_cpu->work);\n\telse\n\t\tpr_err(\"Memory failure: buffer overflow when queuing memory failure at %#lx\\n\",\n\t\t       pfn);\n\tspin_unlock_irqrestore(&mf_cpu->lock, proc_flags);\n\tput_cpu_var(memory_failure_cpu);\n}"
  },
  {
    "function_name": "memory_failure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "1248-1419",
    "snippet": "int memory_failure(unsigned long pfn, int flags)\n{\n\tstruct page *p;\n\tstruct page *hpage;\n\tstruct page *orig_head;\n\tstruct dev_pagemap *pgmap;\n\tint res;\n\tunsigned long page_flags;\n\n\tif (!sysctl_memory_failure_recovery)\n\t\tpanic(\"Memory failure on page %lx\", pfn);\n\n\tif (!pfn_valid(pfn)) {\n\t\tpr_err(\"Memory failure: %#lx: memory outside kernel control\\n\",\n\t\t\tpfn);\n\t\treturn -ENXIO;\n\t}\n\n\tpgmap = get_dev_pagemap(pfn, NULL);\n\tif (pgmap)\n\t\treturn memory_failure_dev_pagemap(pfn, flags, pgmap);\n\n\tp = pfn_to_page(pfn);\n\tif (PageHuge(p))\n\t\treturn memory_failure_hugetlb(pfn, flags);\n\tif (TestSetPageHWPoison(p)) {\n\t\tpr_err(\"Memory failure: %#lx: already hardware poisoned\\n\",\n\t\t\tpfn);\n\t\treturn 0;\n\t}\n\n\torig_head = hpage = compound_head(p);\n\tnum_poisoned_pages_inc();\n\n\t/*\n\t * We need/can do nothing about count=0 pages.\n\t * 1) it's a free page, and therefore in safe hand:\n\t *    prep_new_page() will be the gate keeper.\n\t * 2) it's part of a non-compound high order page.\n\t *    Implies some kernel user: cannot stop them from\n\t *    R/W the page; let's pray that the page has been\n\t *    used and will be freed some time later.\n\t * In fact it's dangerous to directly bump up page count from 0,\n\t * that may make page_ref_freeze()/page_ref_unfreeze() mismatch.\n\t */\n\tif (!(flags & MF_COUNT_INCREASED) && !get_hwpoison_page(p)) {\n\t\tif (is_free_buddy_page(p)) {\n\t\t\taction_result(pfn, MF_MSG_BUDDY, MF_DELAYED);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\taction_result(pfn, MF_MSG_KERNEL_HIGH_ORDER, MF_IGNORED);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tif (PageTransHuge(hpage)) {\n\t\tlock_page(p);\n\t\tif (!PageAnon(p) || unlikely(split_huge_page(p))) {\n\t\t\tunlock_page(p);\n\t\t\tif (!PageAnon(p))\n\t\t\t\tpr_err(\"Memory failure: %#lx: non anonymous thp\\n\",\n\t\t\t\t\tpfn);\n\t\t\telse\n\t\t\t\tpr_err(\"Memory failure: %#lx: thp split failed\\n\",\n\t\t\t\t\tpfn);\n\t\t\tif (TestClearPageHWPoison(p))\n\t\t\t\tnum_poisoned_pages_dec();\n\t\t\tput_hwpoison_page(p);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tunlock_page(p);\n\t\tVM_BUG_ON_PAGE(!page_count(p), p);\n\t\thpage = compound_head(p);\n\t}\n\n\t/*\n\t * We ignore non-LRU pages for good reasons.\n\t * - PG_locked is only well defined for LRU pages and a few others\n\t * - to avoid races with __SetPageLocked()\n\t * - to avoid races with __SetPageSlab*() (and more non-atomic ops)\n\t * The check (unnecessarily) ignores LRU pages being isolated and\n\t * walked by the page reclaim code, however that's not a big loss.\n\t */\n\tshake_page(p, 0);\n\t/* shake_page could have turned it free. */\n\tif (!PageLRU(p) && is_free_buddy_page(p)) {\n\t\tif (flags & MF_COUNT_INCREASED)\n\t\t\taction_result(pfn, MF_MSG_BUDDY, MF_DELAYED);\n\t\telse\n\t\t\taction_result(pfn, MF_MSG_BUDDY_2ND, MF_DELAYED);\n\t\treturn 0;\n\t}\n\n\tlock_page(p);\n\n\t/*\n\t * The page could have changed compound pages during the locking.\n\t * If this happens just bail out.\n\t */\n\tif (PageCompound(p) && compound_head(p) != orig_head) {\n\t\taction_result(pfn, MF_MSG_DIFFERENT_COMPOUND, MF_IGNORED);\n\t\tres = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We use page flags to determine what action should be taken, but\n\t * the flags can be modified by the error containment action.  One\n\t * example is an mlocked page, where PG_mlocked is cleared by\n\t * page_remove_rmap() in try_to_unmap_one(). So to determine page status\n\t * correctly, we save a copy of the page flags at this time.\n\t */\n\tif (PageHuge(p))\n\t\tpage_flags = hpage->flags;\n\telse\n\t\tpage_flags = p->flags;\n\n\t/*\n\t * unpoison always clear PG_hwpoison inside page lock\n\t */\n\tif (!PageHWPoison(p)) {\n\t\tpr_err(\"Memory failure: %#lx: just unpoisoned\\n\", pfn);\n\t\tnum_poisoned_pages_dec();\n\t\tunlock_page(p);\n\t\tput_hwpoison_page(p);\n\t\treturn 0;\n\t}\n\tif (hwpoison_filter(p)) {\n\t\tif (TestClearPageHWPoison(p))\n\t\t\tnum_poisoned_pages_dec();\n\t\tunlock_page(p);\n\t\tput_hwpoison_page(p);\n\t\treturn 0;\n\t}\n\n\tif (!PageTransTail(p) && !PageLRU(p))\n\t\tgoto identify_page_state;\n\n\t/*\n\t * It's very difficult to mess with pages currently under IO\n\t * and in many cases impossible, so we just avoid it here.\n\t */\n\twait_on_page_writeback(p);\n\n\t/*\n\t * Now take care of user space mappings.\n\t * Abort on fail: __delete_from_page_cache() assumes unmapped page.\n\t *\n\t * When the raw error page is thp tail page, hpage points to the raw\n\t * page after thp split.\n\t */\n\tif (!hwpoison_user_mappings(p, pfn, flags, &hpage)) {\n\t\taction_result(pfn, MF_MSG_UNMAP_FAILED, MF_IGNORED);\n\t\tres = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Torn down by someone else?\n\t */\n\tif (PageLRU(p) && !PageSwapCache(p) && p->mapping == NULL) {\n\t\taction_result(pfn, MF_MSG_TRUNCATED_LRU, MF_IGNORED);\n\t\tres = -EBUSY;\n\t\tgoto out;\n\t}\n\nidentify_page_state:\n\tres = identify_page_state(pfn, p, page_flags);\nout:\n\tunlock_page(p);\n\treturn res;\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int sysctl_memory_failure_recovery"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "p"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "identify_page_state",
          "args": [
            "pfn",
            "p",
            "page_flags"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "identify_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "1059-1080",
          "snippet": "static int identify_page_state(unsigned long pfn, struct page *p,\n\t\t\t\tunsigned long page_flags)\n{\n\tstruct page_state *ps;\n\n\t/*\n\t * The first check uses the current page flags which may not have any\n\t * relevant information. The second check with the saved page flags is\n\t * carried out only if the first check can't determine the page status.\n\t */\n\tfor (ps = error_states;; ps++)\n\t\tif ((p->flags & ps->mask) == ps->res)\n\t\t\tbreak;\n\n\tpage_flags |= (p->flags & (1UL << PG_dirty));\n\n\tif (!ps->mask)\n\t\tfor (ps = error_states;; ps++)\n\t\t\tif ((page_flags & ps->mask) == ps->res)\n\t\t\t\tbreak;\n\treturn page_action(ps, p, pfn);\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct page_state {\n\tunsigned long mask;\n\tunsigned long res;\n\tenum mf_action_page_type type;\n\tint (*action)(struct page *p, unsigned long pfn);\n} error_states[] = {\n\t{ reserved,\treserved,\tMF_MSG_KERNEL,\tme_kernel },\n\t/*\n\t * free pages are specially detected outside this table:\n\t * PG_buddy pages only make a small fraction of all free pages.\n\t */\n\n\t/*\n\t * Could in theory check if slab page is free or if we can drop\n\t * currently unused objects without touching them. But just\n\t * treat it as standard kernel for now.\n\t */\n\t{ slab,\t\tslab,\t\tMF_MSG_SLAB,\tme_kernel },\n\n\t{ head,\t\thead,\t\tMF_MSG_HUGE,\t\tme_huge_page },\n\n\t{ sc|dirty,\tsc|dirty,\tMF_MSG_DIRTY_SWAPCACHE,\tme_swapcache_dirty },\n\t{ sc|dirty,\tsc,\t\tMF_MSG_CLEAN_SWAPCACHE,\tme_swapcache_clean },\n\n\t{ mlock|dirty,\tmlock|dirty,\tMF_MSG_DIRTY_MLOCKED_LRU,\tme_pagecache_dirty },\n\t{ mlock|dirty,\tmlock,\t\tMF_MSG_CLEAN_MLOCKED_LRU,\tme_pagecache_clean },\n\n\t{ unevict|dirty, unevict|dirty,\tMF_MSG_DIRTY_UNEVICTABLE_LRU,\tme_pagecache_dirty },\n\t{ unevict|dirty, unevict,\tMF_MSG_CLEAN_UNEVICTABLE_LRU,\tme_pagecache_clean },\n\n\t{ lru|dirty,\tlru|dirty,\tMF_MSG_DIRTY_LRU,\tme_pagecache_dirty },\n\t{ lru|dirty,\tlru,\t\tMF_MSG_CLEAN_LRU,\tme_pagecache_clean },\n\n\t/*\n\t * Catchall entry: must be at end.\n\t */\n\t{ 0,\t\t0,\t\tMF_MSG_UNKNOWN,\tme_unknown },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic struct page_state {\n\tunsigned long mask;\n\tunsigned long res;\n\tenum mf_action_page_type type;\n\tint (*action)(struct page *p, unsigned long pfn);\n} error_states[] = {\n\t{ reserved,\treserved,\tMF_MSG_KERNEL,\tme_kernel },\n\t/*\n\t * free pages are specially detected outside this table:\n\t * PG_buddy pages only make a small fraction of all free pages.\n\t */\n\n\t/*\n\t * Could in theory check if slab page is free or if we can drop\n\t * currently unused objects without touching them. But just\n\t * treat it as standard kernel for now.\n\t */\n\t{ slab,\t\tslab,\t\tMF_MSG_SLAB,\tme_kernel },\n\n\t{ head,\t\thead,\t\tMF_MSG_HUGE,\t\tme_huge_page },\n\n\t{ sc|dirty,\tsc|dirty,\tMF_MSG_DIRTY_SWAPCACHE,\tme_swapcache_dirty },\n\t{ sc|dirty,\tsc,\t\tMF_MSG_CLEAN_SWAPCACHE,\tme_swapcache_clean },\n\n\t{ mlock|dirty,\tmlock|dirty,\tMF_MSG_DIRTY_MLOCKED_LRU,\tme_pagecache_dirty },\n\t{ mlock|dirty,\tmlock,\t\tMF_MSG_CLEAN_MLOCKED_LRU,\tme_pagecache_clean },\n\n\t{ unevict|dirty, unevict|dirty,\tMF_MSG_DIRTY_UNEVICTABLE_LRU,\tme_pagecache_dirty },\n\t{ unevict|dirty, unevict,\tMF_MSG_CLEAN_UNEVICTABLE_LRU,\tme_pagecache_clean },\n\n\t{ lru|dirty,\tlru|dirty,\tMF_MSG_DIRTY_LRU,\tme_pagecache_dirty },\n\t{ lru|dirty,\tlru,\t\tMF_MSG_CLEAN_LRU,\tme_pagecache_clean },\n\n\t/*\n\t * Catchall entry: must be at end.\n\t */\n\t{ 0,\t\t0,\t\tMF_MSG_UNKNOWN,\tme_unknown },\n};\n\nstatic int identify_page_state(unsigned long pfn, struct page *p,\n\t\t\t\tunsigned long page_flags)\n{\n\tstruct page_state *ps;\n\n\t/*\n\t * The first check uses the current page flags which may not have any\n\t * relevant information. The second check with the saved page flags is\n\t * carried out only if the first check can't determine the page status.\n\t */\n\tfor (ps = error_states;; ps++)\n\t\tif ((p->flags & ps->mask) == ps->res)\n\t\t\tbreak;\n\n\tpage_flags |= (p->flags & (1UL << PG_dirty));\n\n\tif (!ps->mask)\n\t\tfor (ps = error_states;; ps++)\n\t\t\tif ((page_flags & ps->mask) == ps->res)\n\t\t\t\tbreak;\n\treturn page_action(ps, p, pfn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "action_result",
          "args": [
            "pfn",
            "MF_MSG_TRUNCATED_LRU",
            "MF_IGNORED"
          ],
          "line": 1409
        },
        "resolved": true,
        "details": {
          "function_name": "action_result",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "886-893",
          "snippet": "static void action_result(unsigned long pfn, enum mf_action_page_type type,\n\t\t\t  enum mf_result result)\n{\n\ttrace_memory_failure_event(pfn, type, result);\n\n\tpr_err(\"Memory failure: %#lx: recovery action for %s: %s\\n\",\n\t\tpfn, action_page_types[type], action_name[result]);\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *action_name[] = {\n\t[MF_IGNORED] = \"Ignored\",\n\t[MF_FAILED] = \"Failed\",\n\t[MF_DELAYED] = \"Delayed\",\n\t[MF_RECOVERED] = \"Recovered\",\n};",
            "static const char * const action_page_types[] = {\n\t[MF_MSG_KERNEL]\t\t\t= \"reserved kernel page\",\n\t[MF_MSG_KERNEL_HIGH_ORDER]\t= \"high-order kernel page\",\n\t[MF_MSG_SLAB]\t\t\t= \"kernel slab page\",\n\t[MF_MSG_DIFFERENT_COMPOUND]\t= \"different compound page after locking\",\n\t[MF_MSG_POISONED_HUGE]\t\t= \"huge page already hardware poisoned\",\n\t[MF_MSG_HUGE]\t\t\t= \"huge page\",\n\t[MF_MSG_FREE_HUGE]\t\t= \"free huge page\",\n\t[MF_MSG_NON_PMD_HUGE]\t\t= \"non-pmd-sized huge page\",\n\t[MF_MSG_UNMAP_FAILED]\t\t= \"unmapping failed page\",\n\t[MF_MSG_DIRTY_SWAPCACHE]\t= \"dirty swapcache page\",\n\t[MF_MSG_CLEAN_SWAPCACHE]\t= \"clean swapcache page\",\n\t[MF_MSG_DIRTY_MLOCKED_LRU]\t= \"dirty mlocked LRU page\",\n\t[MF_MSG_CLEAN_MLOCKED_LRU]\t= \"clean mlocked LRU page\",\n\t[MF_MSG_DIRTY_UNEVICTABLE_LRU]\t= \"dirty unevictable LRU page\",\n\t[MF_MSG_CLEAN_UNEVICTABLE_LRU]\t= \"clean unevictable LRU page\",\n\t[MF_MSG_DIRTY_LRU]\t\t= \"dirty LRU page\",\n\t[MF_MSG_CLEAN_LRU]\t\t= \"clean LRU page\",\n\t[MF_MSG_TRUNCATED_LRU]\t\t= \"already truncated LRU page\",\n\t[MF_MSG_BUDDY]\t\t\t= \"free buddy page\",\n\t[MF_MSG_BUDDY_2ND]\t\t= \"free buddy page (2nd try)\",\n\t[MF_MSG_DAX]\t\t\t= \"dax page\",\n\t[MF_MSG_UNKNOWN]\t\t= \"unknown page\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic const char *action_name[] = {\n\t[MF_IGNORED] = \"Ignored\",\n\t[MF_FAILED] = \"Failed\",\n\t[MF_DELAYED] = \"Delayed\",\n\t[MF_RECOVERED] = \"Recovered\",\n};\nstatic const char * const action_page_types[] = {\n\t[MF_MSG_KERNEL]\t\t\t= \"reserved kernel page\",\n\t[MF_MSG_KERNEL_HIGH_ORDER]\t= \"high-order kernel page\",\n\t[MF_MSG_SLAB]\t\t\t= \"kernel slab page\",\n\t[MF_MSG_DIFFERENT_COMPOUND]\t= \"different compound page after locking\",\n\t[MF_MSG_POISONED_HUGE]\t\t= \"huge page already hardware poisoned\",\n\t[MF_MSG_HUGE]\t\t\t= \"huge page\",\n\t[MF_MSG_FREE_HUGE]\t\t= \"free huge page\",\n\t[MF_MSG_NON_PMD_HUGE]\t\t= \"non-pmd-sized huge page\",\n\t[MF_MSG_UNMAP_FAILED]\t\t= \"unmapping failed page\",\n\t[MF_MSG_DIRTY_SWAPCACHE]\t= \"dirty swapcache page\",\n\t[MF_MSG_CLEAN_SWAPCACHE]\t= \"clean swapcache page\",\n\t[MF_MSG_DIRTY_MLOCKED_LRU]\t= \"dirty mlocked LRU page\",\n\t[MF_MSG_CLEAN_MLOCKED_LRU]\t= \"clean mlocked LRU page\",\n\t[MF_MSG_DIRTY_UNEVICTABLE_LRU]\t= \"dirty unevictable LRU page\",\n\t[MF_MSG_CLEAN_UNEVICTABLE_LRU]\t= \"clean unevictable LRU page\",\n\t[MF_MSG_DIRTY_LRU]\t\t= \"dirty LRU page\",\n\t[MF_MSG_CLEAN_LRU]\t\t= \"clean LRU page\",\n\t[MF_MSG_TRUNCATED_LRU]\t\t= \"already truncated LRU page\",\n\t[MF_MSG_BUDDY]\t\t\t= \"free buddy page\",\n\t[MF_MSG_BUDDY_2ND]\t\t= \"free buddy page (2nd try)\",\n\t[MF_MSG_DAX]\t\t\t= \"dax page\",\n\t[MF_MSG_UNKNOWN]\t\t= \"unknown page\",\n};\n\nstatic void action_result(unsigned long pfn, enum mf_action_page_type type,\n\t\t\t  enum mf_result result)\n{\n\ttrace_memory_failure_event(pfn, type, result);\n\n\tpr_err(\"Memory failure: %#lx: recovery action for %s: %s\\n\",\n\t\tpfn, action_page_types[type], action_name[result]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "p"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "p"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hwpoison_user_mappings",
          "args": [
            "p",
            "pfn",
            "flags",
            "&hpage"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "hwpoison_user_mappings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "963-1057",
          "snippet": "static bool hwpoison_user_mappings(struct page *p, unsigned long pfn,\n\t\t\t\t  int flags, struct page **hpagep)\n{\n\tenum ttu_flags ttu = TTU_IGNORE_MLOCK | TTU_IGNORE_ACCESS;\n\tstruct address_space *mapping;\n\tLIST_HEAD(tokill);\n\tbool unmap_success;\n\tint kill = 1, forcekill;\n\tstruct page *hpage = *hpagep;\n\tbool mlocked = PageMlocked(hpage);\n\n\t/*\n\t * Here we are interested only in user-mapped pages, so skip any\n\t * other types of pages.\n\t */\n\tif (PageReserved(p) || PageSlab(p))\n\t\treturn true;\n\tif (!(PageLRU(hpage) || PageHuge(p)))\n\t\treturn true;\n\n\t/*\n\t * This check implies we don't kill processes if their pages\n\t * are in the swap cache early. Those are always late kills.\n\t */\n\tif (!page_mapped(hpage))\n\t\treturn true;\n\n\tif (PageKsm(p)) {\n\t\tpr_err(\"Memory failure: %#lx: can't handle KSM pages.\\n\", pfn);\n\t\treturn false;\n\t}\n\n\tif (PageSwapCache(p)) {\n\t\tpr_err(\"Memory failure: %#lx: keeping poisoned page in swap cache\\n\",\n\t\t\tpfn);\n\t\tttu |= TTU_IGNORE_HWPOISON;\n\t}\n\n\t/*\n\t * Propagate the dirty bit from PTEs to struct page first, because we\n\t * need this to decide if we should kill or just drop the page.\n\t * XXX: the dirty test could be racy: set_page_dirty() may not always\n\t * be called inside page lock (it's recommended but not enforced).\n\t */\n\tmapping = page_mapping(hpage);\n\tif (!(flags & MF_MUST_KILL) && !PageDirty(hpage) && mapping &&\n\t    mapping_cap_writeback_dirty(mapping)) {\n\t\tif (page_mkclean(hpage)) {\n\t\t\tSetPageDirty(hpage);\n\t\t} else {\n\t\t\tkill = 0;\n\t\t\tttu |= TTU_IGNORE_HWPOISON;\n\t\t\tpr_info(\"Memory failure: %#lx: corrupted page was clean: dropped without side effects\\n\",\n\t\t\t\tpfn);\n\t\t}\n\t}\n\n\t/*\n\t * First collect all the processes that have the page\n\t * mapped in dirty form.  This has to be done before try_to_unmap,\n\t * because ttu takes the rmap data structures down.\n\t *\n\t * Error handling: We ignore errors here because\n\t * there's nothing that can be done.\n\t */\n\tif (kill)\n\t\tcollect_procs(hpage, &tokill, flags & MF_ACTION_REQUIRED);\n\n\tunmap_success = try_to_unmap(hpage, ttu);\n\tif (!unmap_success)\n\t\tpr_err(\"Memory failure: %#lx: failed to unmap page (mapcount=%d)\\n\",\n\t\t       pfn, page_mapcount(hpage));\n\n\t/*\n\t * try_to_unmap() might put mlocked page in lru cache, so call\n\t * shake_page() again to ensure that it's flushed.\n\t */\n\tif (mlocked)\n\t\tshake_page(hpage, 0);\n\n\t/*\n\t * Now that the dirty bit has been propagated to the\n\t * struct page and all unmaps done we can decide if\n\t * killing is needed or not.  Only kill when the page\n\t * was dirty or the process is not restartable,\n\t * otherwise the tokill list is merely\n\t * freed.  When there was a problem unmapping earlier\n\t * use a more force-full uncatchable kill to prevent\n\t * any accesses to the poisoned memory.\n\t */\n\tforcekill = PageDirty(hpage) || (flags & MF_MUST_KILL);\n\tkill_procs(&tokill, forcekill, !unmap_success, pfn, flags);\n\n\treturn unmap_success;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define lru\t\t(1UL << PG_lru)",
            "#define dirty\t\t(1UL << PG_dirty)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define lru\t\t(1UL << PG_lru)\n#define dirty\t\t(1UL << PG_dirty)\n\nstatic bool hwpoison_user_mappings(struct page *p, unsigned long pfn,\n\t\t\t\t  int flags, struct page **hpagep)\n{\n\tenum ttu_flags ttu = TTU_IGNORE_MLOCK | TTU_IGNORE_ACCESS;\n\tstruct address_space *mapping;\n\tLIST_HEAD(tokill);\n\tbool unmap_success;\n\tint kill = 1, forcekill;\n\tstruct page *hpage = *hpagep;\n\tbool mlocked = PageMlocked(hpage);\n\n\t/*\n\t * Here we are interested only in user-mapped pages, so skip any\n\t * other types of pages.\n\t */\n\tif (PageReserved(p) || PageSlab(p))\n\t\treturn true;\n\tif (!(PageLRU(hpage) || PageHuge(p)))\n\t\treturn true;\n\n\t/*\n\t * This check implies we don't kill processes if their pages\n\t * are in the swap cache early. Those are always late kills.\n\t */\n\tif (!page_mapped(hpage))\n\t\treturn true;\n\n\tif (PageKsm(p)) {\n\t\tpr_err(\"Memory failure: %#lx: can't handle KSM pages.\\n\", pfn);\n\t\treturn false;\n\t}\n\n\tif (PageSwapCache(p)) {\n\t\tpr_err(\"Memory failure: %#lx: keeping poisoned page in swap cache\\n\",\n\t\t\tpfn);\n\t\tttu |= TTU_IGNORE_HWPOISON;\n\t}\n\n\t/*\n\t * Propagate the dirty bit from PTEs to struct page first, because we\n\t * need this to decide if we should kill or just drop the page.\n\t * XXX: the dirty test could be racy: set_page_dirty() may not always\n\t * be called inside page lock (it's recommended but not enforced).\n\t */\n\tmapping = page_mapping(hpage);\n\tif (!(flags & MF_MUST_KILL) && !PageDirty(hpage) && mapping &&\n\t    mapping_cap_writeback_dirty(mapping)) {\n\t\tif (page_mkclean(hpage)) {\n\t\t\tSetPageDirty(hpage);\n\t\t} else {\n\t\t\tkill = 0;\n\t\t\tttu |= TTU_IGNORE_HWPOISON;\n\t\t\tpr_info(\"Memory failure: %#lx: corrupted page was clean: dropped without side effects\\n\",\n\t\t\t\tpfn);\n\t\t}\n\t}\n\n\t/*\n\t * First collect all the processes that have the page\n\t * mapped in dirty form.  This has to be done before try_to_unmap,\n\t * because ttu takes the rmap data structures down.\n\t *\n\t * Error handling: We ignore errors here because\n\t * there's nothing that can be done.\n\t */\n\tif (kill)\n\t\tcollect_procs(hpage, &tokill, flags & MF_ACTION_REQUIRED);\n\n\tunmap_success = try_to_unmap(hpage, ttu);\n\tif (!unmap_success)\n\t\tpr_err(\"Memory failure: %#lx: failed to unmap page (mapcount=%d)\\n\",\n\t\t       pfn, page_mapcount(hpage));\n\n\t/*\n\t * try_to_unmap() might put mlocked page in lru cache, so call\n\t * shake_page() again to ensure that it's flushed.\n\t */\n\tif (mlocked)\n\t\tshake_page(hpage, 0);\n\n\t/*\n\t * Now that the dirty bit has been propagated to the\n\t * struct page and all unmaps done we can decide if\n\t * killing is needed or not.  Only kill when the page\n\t * was dirty or the process is not restartable,\n\t * otherwise the tokill list is merely\n\t * freed.  When there was a problem unmapping earlier\n\t * use a more force-full uncatchable kill to prevent\n\t * any accesses to the poisoned memory.\n\t */\n\tforcekill = PageDirty(hpage) || (flags & MF_MUST_KILL);\n\tkill_procs(&tokill, forcekill, !unmap_success, pfn, flags);\n\n\treturn unmap_success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_page_writeback",
          "args": [
            "p"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "p"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransTail",
          "args": [
            "p"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_hwpoison_page",
          "args": [
            "p"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_poisoned_pages_dec",
          "args": [],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestClearPageHWPoison",
          "args": [
            "p"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hwpoison_filter",
          "args": [
            "p"
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "hwpoison_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "170-173",
          "snippet": "int hwpoison_filter(struct page *p)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint hwpoison_filter(struct page *p)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_hwpoison_page",
          "args": [
            "p"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_poisoned_pages_dec",
          "args": [],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Memory failure: %#lx: just unpoisoned\\n\"",
            "pfn"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHWPoison",
          "args": [
            "p"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "p"
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "PageHugeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "225-228",
          "snippet": "static int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "p"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "p"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_free_buddy_page",
          "args": [
            "p"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "p"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shake_page",
          "args": [
            "p",
            "0"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "shake_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "245-265",
          "snippet": "void shake_page(struct page *p, int access)\n{\n\tif (PageHuge(p))\n\t\treturn;\n\n\tif (!PageSlab(p)) {\n\t\tlru_add_drain_all();\n\t\tif (PageLRU(p))\n\t\t\treturn;\n\t\tdrain_all_pages(page_zone(p));\n\t\tif (PageLRU(p) || is_free_buddy_page(p))\n\t\t\treturn;\n\t}\n\n\t/*\n\t * Only call shrink_node_slabs here (which would also shrink\n\t * other caches) if access is not potentially fatal.\n\t */\n\tif (access)\n\t\tdrop_slab_node(page_to_nid(p));\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nvoid shake_page(struct page *p, int access)\n{\n\tif (PageHuge(p))\n\t\treturn;\n\n\tif (!PageSlab(p)) {\n\t\tlru_add_drain_all();\n\t\tif (PageLRU(p))\n\t\t\treturn;\n\t\tdrain_all_pages(page_zone(p));\n\t\tif (PageLRU(p) || is_free_buddy_page(p))\n\t\t\treturn;\n\t}\n\n\t/*\n\t * Only call shrink_node_slabs here (which would also shrink\n\t * other caches) if access is not potentially fatal.\n\t */\n\tif (access)\n\t\tdrop_slab_node(page_to_nid(p));\n}"
        }
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "p"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!page_count(p)",
            "p"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "p"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_hwpoison_page",
          "args": [
            "p"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_poisoned_pages_dec",
          "args": [],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestClearPageHWPoison",
          "args": [
            "p"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Memory failure: %#lx: thp split failed\\n\"",
            "pfn"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Memory failure: %#lx: non anonymous thp\\n\"",
            "pfn"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "p"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "split_huge_page(p)"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "split_huge_page",
          "args": [
            "p"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "deferred_split_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "2760-2774",
          "snippet": "void deferred_split_huge_page(struct page *page)\n{\n\tstruct pglist_data *pgdata = NODE_DATA(page_to_nid(page));\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\n\tspin_lock_irqsave(&pgdata->split_queue_lock, flags);\n\tif (list_empty(page_deferred_list(page))) {\n\t\tcount_vm_event(THP_DEFERRED_SPLIT_PAGE);\n\t\tlist_add_tail(page_deferred_list(page), &pgdata->split_queue);\n\t\tpgdata->split_queue_len++;\n\t}\n\tspin_unlock_irqrestore(&pgdata->split_queue_lock, flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid deferred_split_huge_page(struct page *page)\n{\n\tstruct pglist_data *pgdata = NODE_DATA(page_to_nid(page));\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\n\tspin_lock_irqsave(&pgdata->split_queue_lock, flags);\n\tif (list_empty(page_deferred_list(page))) {\n\t\tcount_vm_event(THP_DEFERRED_SPLIT_PAGE);\n\t\tlist_add_tail(page_deferred_list(page), &pgdata->split_queue);\n\t\tpgdata->split_queue_len++;\n\t}\n\tspin_unlock_irqrestore(&pgdata->split_queue_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "p"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "hpage"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_free_buddy_page",
          "args": [
            "p"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_hwpoison_page",
          "args": [
            "p"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "get_hwpoison_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "928-956",
          "snippet": "int get_hwpoison_page(struct page *page)\n{\n\tstruct page *head = compound_head(page);\n\n\tif (!PageHuge(head) && PageTransHuge(head)) {\n\t\t/*\n\t\t * Non anonymous thp exists only in allocation/free time. We\n\t\t * can't handle such a case correctly, so let's give it up.\n\t\t * This should be better than triggering BUG_ON when kernel\n\t\t * tries to touch the \"partially handled\" page.\n\t\t */\n\t\tif (!PageAnon(head)) {\n\t\t\tpr_err(\"Memory failure: %#lx: non anonymous thp\\n\",\n\t\t\t\tpage_to_pfn(page));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (get_page_unless_zero(head)) {\n\t\tif (head == compound_head(page))\n\t\t\treturn 1;\n\n\t\tpr_info(\"Memory failure: %#lx cannot catch tail\\n\",\n\t\t\tpage_to_pfn(page));\n\t\tput_page(head);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define head\t\t(1UL << PG_head)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define head\t\t(1UL << PG_head)\n\nint get_hwpoison_page(struct page *page)\n{\n\tstruct page *head = compound_head(page);\n\n\tif (!PageHuge(head) && PageTransHuge(head)) {\n\t\t/*\n\t\t * Non anonymous thp exists only in allocation/free time. We\n\t\t * can't handle such a case correctly, so let's give it up.\n\t\t * This should be better than triggering BUG_ON when kernel\n\t\t * tries to touch the \"partially handled\" page.\n\t\t */\n\t\tif (!PageAnon(head)) {\n\t\t\tpr_err(\"Memory failure: %#lx: non anonymous thp\\n\",\n\t\t\t\tpage_to_pfn(page));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (get_page_unless_zero(head)) {\n\t\tif (head == compound_head(page))\n\t\t\treturn 1;\n\n\t\tpr_info(\"Memory failure: %#lx cannot catch tail\\n\",\n\t\t\tpage_to_pfn(page));\n\t\tput_page(head);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_poisoned_pages_inc",
          "args": [],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "p"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Memory failure: %#lx: already hardware poisoned\\n\"",
            "pfn"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestSetPageHWPoison",
          "args": [
            "p"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memory_failure_hugetlb",
          "args": [
            "pfn",
            "flags"
          ],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "memory_failure_hugetlb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "1082-1152",
          "snippet": "static int memory_failure_hugetlb(unsigned long pfn, int flags)\n{\n\tstruct page *p = pfn_to_page(pfn);\n\tstruct page *head = compound_head(p);\n\tint res;\n\tunsigned long page_flags;\n\n\tif (TestSetPageHWPoison(head)) {\n\t\tpr_err(\"Memory failure: %#lx: already hardware poisoned\\n\",\n\t\t       pfn);\n\t\treturn 0;\n\t}\n\n\tnum_poisoned_pages_inc();\n\n\tif (!(flags & MF_COUNT_INCREASED) && !get_hwpoison_page(p)) {\n\t\t/*\n\t\t * Check \"filter hit\" and \"race with other subpage.\"\n\t\t */\n\t\tlock_page(head);\n\t\tif (PageHWPoison(head)) {\n\t\t\tif ((hwpoison_filter(p) && TestClearPageHWPoison(p))\n\t\t\t    || (p != head && TestSetPageHWPoison(head))) {\n\t\t\t\tnum_poisoned_pages_dec();\n\t\t\t\tunlock_page(head);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tunlock_page(head);\n\t\tdissolve_free_huge_page(p);\n\t\taction_result(pfn, MF_MSG_FREE_HUGE, MF_DELAYED);\n\t\treturn 0;\n\t}\n\n\tlock_page(head);\n\tpage_flags = head->flags;\n\n\tif (!PageHWPoison(head)) {\n\t\tpr_err(\"Memory failure: %#lx: just unpoisoned\\n\", pfn);\n\t\tnum_poisoned_pages_dec();\n\t\tunlock_page(head);\n\t\tput_hwpoison_page(head);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * TODO: hwpoison for pud-sized hugetlb doesn't work right now, so\n\t * simply disable it. In order to make it work properly, we need\n\t * make sure that:\n\t *  - conversion of a pud that maps an error hugetlb into hwpoison\n\t *    entry properly works, and\n\t *  - other mm code walking over page table is aware of pud-aligned\n\t *    hwpoison entries.\n\t */\n\tif (huge_page_size(page_hstate(head)) > PMD_SIZE) {\n\t\taction_result(pfn, MF_MSG_NON_PMD_HUGE, MF_IGNORED);\n\t\tres = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (!hwpoison_user_mappings(p, pfn, flags, &head)) {\n\t\taction_result(pfn, MF_MSG_UNMAP_FAILED, MF_IGNORED);\n\t\tres = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tres = identify_page_state(pfn, p, page_flags);\nout:\n\tunlock_page(head);\n\treturn res;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define head\t\t(1UL << PG_head)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define head\t\t(1UL << PG_head)\n\nstatic int memory_failure_hugetlb(unsigned long pfn, int flags)\n{\n\tstruct page *p = pfn_to_page(pfn);\n\tstruct page *head = compound_head(p);\n\tint res;\n\tunsigned long page_flags;\n\n\tif (TestSetPageHWPoison(head)) {\n\t\tpr_err(\"Memory failure: %#lx: already hardware poisoned\\n\",\n\t\t       pfn);\n\t\treturn 0;\n\t}\n\n\tnum_poisoned_pages_inc();\n\n\tif (!(flags & MF_COUNT_INCREASED) && !get_hwpoison_page(p)) {\n\t\t/*\n\t\t * Check \"filter hit\" and \"race with other subpage.\"\n\t\t */\n\t\tlock_page(head);\n\t\tif (PageHWPoison(head)) {\n\t\t\tif ((hwpoison_filter(p) && TestClearPageHWPoison(p))\n\t\t\t    || (p != head && TestSetPageHWPoison(head))) {\n\t\t\t\tnum_poisoned_pages_dec();\n\t\t\t\tunlock_page(head);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tunlock_page(head);\n\t\tdissolve_free_huge_page(p);\n\t\taction_result(pfn, MF_MSG_FREE_HUGE, MF_DELAYED);\n\t\treturn 0;\n\t}\n\n\tlock_page(head);\n\tpage_flags = head->flags;\n\n\tif (!PageHWPoison(head)) {\n\t\tpr_err(\"Memory failure: %#lx: just unpoisoned\\n\", pfn);\n\t\tnum_poisoned_pages_dec();\n\t\tunlock_page(head);\n\t\tput_hwpoison_page(head);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * TODO: hwpoison for pud-sized hugetlb doesn't work right now, so\n\t * simply disable it. In order to make it work properly, we need\n\t * make sure that:\n\t *  - conversion of a pud that maps an error hugetlb into hwpoison\n\t *    entry properly works, and\n\t *  - other mm code walking over page table is aware of pud-aligned\n\t *    hwpoison entries.\n\t */\n\tif (huge_page_size(page_hstate(head)) > PMD_SIZE) {\n\t\taction_result(pfn, MF_MSG_NON_PMD_HUGE, MF_IGNORED);\n\t\tres = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (!hwpoison_user_mappings(p, pfn, flags, &head)) {\n\t\taction_result(pfn, MF_MSG_UNMAP_FAILED, MF_IGNORED);\n\t\tres = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tres = identify_page_state(pfn, p, page_flags);\nout:\n\tunlock_page(head);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memory_failure_dev_pagemap",
          "args": [
            "pfn",
            "flags",
            "pgmap"
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "memory_failure_dev_pagemap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "1154-1229",
          "snippet": "static int memory_failure_dev_pagemap(unsigned long pfn, int flags,\n\t\tstruct dev_pagemap *pgmap)\n{\n\tstruct page *page = pfn_to_page(pfn);\n\tconst bool unmap_success = true;\n\tunsigned long size = 0;\n\tstruct to_kill *tk;\n\tLIST_HEAD(tokill);\n\tint rc = -EBUSY;\n\tloff_t start;\n\n\t/*\n\t * Prevent the inode from being freed while we are interrogating\n\t * the address_space, typically this would be handled by\n\t * lock_page(), but dax pages do not use the page lock. This\n\t * also prevents changes to the mapping of this pfn until\n\t * poison signaling is complete.\n\t */\n\tif (!dax_lock_mapping_entry(page))\n\t\tgoto out;\n\n\tif (hwpoison_filter(page)) {\n\t\trc = 0;\n\t\tgoto unlock;\n\t}\n\n\tswitch (pgmap->type) {\n\tcase MEMORY_DEVICE_PRIVATE:\n\tcase MEMORY_DEVICE_PUBLIC:\n\t\t/*\n\t\t * TODO: Handle HMM pages which may need coordination\n\t\t * with device-side memory.\n\t\t */\n\t\tgoto unlock;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/*\n\t * Use this flag as an indication that the dax page has been\n\t * remapped UC to prevent speculative consumption of poison.\n\t */\n\tSetPageHWPoison(page);\n\n\t/*\n\t * Unlike System-RAM there is no possibility to swap in a\n\t * different physical page at a given virtual address, so all\n\t * userspace consumption of ZONE_DEVICE memory necessitates\n\t * SIGBUS (i.e. MF_MUST_KILL)\n\t */\n\tflags |= MF_ACTION_REQUIRED | MF_MUST_KILL;\n\tcollect_procs(page, &tokill, flags & MF_ACTION_REQUIRED);\n\n\tlist_for_each_entry(tk, &tokill, nd)\n\t\tif (tk->size_shift)\n\t\t\tsize = max(size, 1UL << tk->size_shift);\n\tif (size) {\n\t\t/*\n\t\t * Unmap the largest mapping to avoid breaking up\n\t\t * device-dax mappings which are constant size. The\n\t\t * actual size of the mapping being torn down is\n\t\t * communicated in siginfo, see kill_proc()\n\t\t */\n\t\tstart = (page->index << PAGE_SHIFT) & ~(size - 1);\n\t\tunmap_mapping_range(page->mapping, start, start + size, 0);\n\t}\n\tkill_procs(&tokill, flags & MF_MUST_KILL, !unmap_success, pfn, flags);\n\trc = 0;\nunlock:\n\tdax_unlock_mapping_entry(page);\nout:\n\t/* drop pgmap ref acquired in caller */\n\tput_dev_pagemap(pgmap);\n\taction_result(pfn, MF_MSG_DAX, rc ? MF_FAILED : MF_RECOVERED);\n\treturn rc;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int memory_failure_dev_pagemap(unsigned long pfn, int flags,\n\t\tstruct dev_pagemap *pgmap)\n{\n\tstruct page *page = pfn_to_page(pfn);\n\tconst bool unmap_success = true;\n\tunsigned long size = 0;\n\tstruct to_kill *tk;\n\tLIST_HEAD(tokill);\n\tint rc = -EBUSY;\n\tloff_t start;\n\n\t/*\n\t * Prevent the inode from being freed while we are interrogating\n\t * the address_space, typically this would be handled by\n\t * lock_page(), but dax pages do not use the page lock. This\n\t * also prevents changes to the mapping of this pfn until\n\t * poison signaling is complete.\n\t */\n\tif (!dax_lock_mapping_entry(page))\n\t\tgoto out;\n\n\tif (hwpoison_filter(page)) {\n\t\trc = 0;\n\t\tgoto unlock;\n\t}\n\n\tswitch (pgmap->type) {\n\tcase MEMORY_DEVICE_PRIVATE:\n\tcase MEMORY_DEVICE_PUBLIC:\n\t\t/*\n\t\t * TODO: Handle HMM pages which may need coordination\n\t\t * with device-side memory.\n\t\t */\n\t\tgoto unlock;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/*\n\t * Use this flag as an indication that the dax page has been\n\t * remapped UC to prevent speculative consumption of poison.\n\t */\n\tSetPageHWPoison(page);\n\n\t/*\n\t * Unlike System-RAM there is no possibility to swap in a\n\t * different physical page at a given virtual address, so all\n\t * userspace consumption of ZONE_DEVICE memory necessitates\n\t * SIGBUS (i.e. MF_MUST_KILL)\n\t */\n\tflags |= MF_ACTION_REQUIRED | MF_MUST_KILL;\n\tcollect_procs(page, &tokill, flags & MF_ACTION_REQUIRED);\n\n\tlist_for_each_entry(tk, &tokill, nd)\n\t\tif (tk->size_shift)\n\t\t\tsize = max(size, 1UL << tk->size_shift);\n\tif (size) {\n\t\t/*\n\t\t * Unmap the largest mapping to avoid breaking up\n\t\t * device-dax mappings which are constant size. The\n\t\t * actual size of the mapping being torn down is\n\t\t * communicated in siginfo, see kill_proc()\n\t\t */\n\t\tstart = (page->index << PAGE_SHIFT) & ~(size - 1);\n\t\tunmap_mapping_range(page->mapping, start, start + size, 0);\n\t}\n\tkill_procs(&tokill, flags & MF_MUST_KILL, !unmap_success, pfn, flags);\n\trc = 0;\nunlock:\n\tdax_unlock_mapping_entry(page);\nout:\n\t/* drop pgmap ref acquired in caller */\n\tput_dev_pagemap(pgmap);\n\taction_result(pfn, MF_MSG_DAX, rc ? MF_FAILED : MF_RECOVERED);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_dev_pagemap",
          "args": [
            "pfn",
            "NULL"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Memory failure: %#lx: memory outside kernel control\\n\"",
            "pfn"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "pfn"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Memory failure on page %lx\"",
            "pfn"
          ],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "check_panic_on_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "1008-1028",
          "snippet": "static void check_panic_on_oom(struct oom_control *oc,\n\t\t\t       enum oom_constraint constraint)\n{\n\tif (likely(!sysctl_panic_on_oom))\n\t\treturn;\n\tif (sysctl_panic_on_oom != 2) {\n\t\t/*\n\t\t * panic_on_oom == 1 only affects CONSTRAINT_NONE, the kernel\n\t\t * does not panic for cpuset, mempolicy, or memcg allocation\n\t\t * failures.\n\t\t */\n\t\tif (constraint != CONSTRAINT_NONE)\n\t\t\treturn;\n\t}\n\t/* Do not panic for oom kills triggered by sysrq */\n\tif (is_sysrq_oom(oc))\n\t\treturn;\n\tdump_header(oc, NULL);\n\tpanic(\"Out of memory: %s panic_on_oom is enabled\\n\",\n\t\tsysctl_panic_on_oom == 2 ? \"compulsory\" : \"system-wide\");\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int sysctl_panic_on_oom;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nint sysctl_panic_on_oom;\n\nstatic void check_panic_on_oom(struct oom_control *oc,\n\t\t\t       enum oom_constraint constraint)\n{\n\tif (likely(!sysctl_panic_on_oom))\n\t\treturn;\n\tif (sysctl_panic_on_oom != 2) {\n\t\t/*\n\t\t * panic_on_oom == 1 only affects CONSTRAINT_NONE, the kernel\n\t\t * does not panic for cpuset, mempolicy, or memcg allocation\n\t\t * failures.\n\t\t */\n\t\tif (constraint != CONSTRAINT_NONE)\n\t\t\treturn;\n\t}\n\t/* Do not panic for oom kills triggered by sysrq */\n\tif (is_sysrq_oom(oc))\n\t\treturn;\n\tdump_header(oc, NULL);\n\tpanic(\"Out of memory: %s panic_on_oom is enabled\\n\",\n\t\tsysctl_panic_on_oom == 2 ? \"compulsory\" : \"system-wide\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint sysctl_memory_failure_recovery;\n\nint memory_failure(unsigned long pfn, int flags)\n{\n\tstruct page *p;\n\tstruct page *hpage;\n\tstruct page *orig_head;\n\tstruct dev_pagemap *pgmap;\n\tint res;\n\tunsigned long page_flags;\n\n\tif (!sysctl_memory_failure_recovery)\n\t\tpanic(\"Memory failure on page %lx\", pfn);\n\n\tif (!pfn_valid(pfn)) {\n\t\tpr_err(\"Memory failure: %#lx: memory outside kernel control\\n\",\n\t\t\tpfn);\n\t\treturn -ENXIO;\n\t}\n\n\tpgmap = get_dev_pagemap(pfn, NULL);\n\tif (pgmap)\n\t\treturn memory_failure_dev_pagemap(pfn, flags, pgmap);\n\n\tp = pfn_to_page(pfn);\n\tif (PageHuge(p))\n\t\treturn memory_failure_hugetlb(pfn, flags);\n\tif (TestSetPageHWPoison(p)) {\n\t\tpr_err(\"Memory failure: %#lx: already hardware poisoned\\n\",\n\t\t\tpfn);\n\t\treturn 0;\n\t}\n\n\torig_head = hpage = compound_head(p);\n\tnum_poisoned_pages_inc();\n\n\t/*\n\t * We need/can do nothing about count=0 pages.\n\t * 1) it's a free page, and therefore in safe hand:\n\t *    prep_new_page() will be the gate keeper.\n\t * 2) it's part of a non-compound high order page.\n\t *    Implies some kernel user: cannot stop them from\n\t *    R/W the page; let's pray that the page has been\n\t *    used and will be freed some time later.\n\t * In fact it's dangerous to directly bump up page count from 0,\n\t * that may make page_ref_freeze()/page_ref_unfreeze() mismatch.\n\t */\n\tif (!(flags & MF_COUNT_INCREASED) && !get_hwpoison_page(p)) {\n\t\tif (is_free_buddy_page(p)) {\n\t\t\taction_result(pfn, MF_MSG_BUDDY, MF_DELAYED);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\taction_result(pfn, MF_MSG_KERNEL_HIGH_ORDER, MF_IGNORED);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tif (PageTransHuge(hpage)) {\n\t\tlock_page(p);\n\t\tif (!PageAnon(p) || unlikely(split_huge_page(p))) {\n\t\t\tunlock_page(p);\n\t\t\tif (!PageAnon(p))\n\t\t\t\tpr_err(\"Memory failure: %#lx: non anonymous thp\\n\",\n\t\t\t\t\tpfn);\n\t\t\telse\n\t\t\t\tpr_err(\"Memory failure: %#lx: thp split failed\\n\",\n\t\t\t\t\tpfn);\n\t\t\tif (TestClearPageHWPoison(p))\n\t\t\t\tnum_poisoned_pages_dec();\n\t\t\tput_hwpoison_page(p);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tunlock_page(p);\n\t\tVM_BUG_ON_PAGE(!page_count(p), p);\n\t\thpage = compound_head(p);\n\t}\n\n\t/*\n\t * We ignore non-LRU pages for good reasons.\n\t * - PG_locked is only well defined for LRU pages and a few others\n\t * - to avoid races with __SetPageLocked()\n\t * - to avoid races with __SetPageSlab*() (and more non-atomic ops)\n\t * The check (unnecessarily) ignores LRU pages being isolated and\n\t * walked by the page reclaim code, however that's not a big loss.\n\t */\n\tshake_page(p, 0);\n\t/* shake_page could have turned it free. */\n\tif (!PageLRU(p) && is_free_buddy_page(p)) {\n\t\tif (flags & MF_COUNT_INCREASED)\n\t\t\taction_result(pfn, MF_MSG_BUDDY, MF_DELAYED);\n\t\telse\n\t\t\taction_result(pfn, MF_MSG_BUDDY_2ND, MF_DELAYED);\n\t\treturn 0;\n\t}\n\n\tlock_page(p);\n\n\t/*\n\t * The page could have changed compound pages during the locking.\n\t * If this happens just bail out.\n\t */\n\tif (PageCompound(p) && compound_head(p) != orig_head) {\n\t\taction_result(pfn, MF_MSG_DIFFERENT_COMPOUND, MF_IGNORED);\n\t\tres = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We use page flags to determine what action should be taken, but\n\t * the flags can be modified by the error containment action.  One\n\t * example is an mlocked page, where PG_mlocked is cleared by\n\t * page_remove_rmap() in try_to_unmap_one(). So to determine page status\n\t * correctly, we save a copy of the page flags at this time.\n\t */\n\tif (PageHuge(p))\n\t\tpage_flags = hpage->flags;\n\telse\n\t\tpage_flags = p->flags;\n\n\t/*\n\t * unpoison always clear PG_hwpoison inside page lock\n\t */\n\tif (!PageHWPoison(p)) {\n\t\tpr_err(\"Memory failure: %#lx: just unpoisoned\\n\", pfn);\n\t\tnum_poisoned_pages_dec();\n\t\tunlock_page(p);\n\t\tput_hwpoison_page(p);\n\t\treturn 0;\n\t}\n\tif (hwpoison_filter(p)) {\n\t\tif (TestClearPageHWPoison(p))\n\t\t\tnum_poisoned_pages_dec();\n\t\tunlock_page(p);\n\t\tput_hwpoison_page(p);\n\t\treturn 0;\n\t}\n\n\tif (!PageTransTail(p) && !PageLRU(p))\n\t\tgoto identify_page_state;\n\n\t/*\n\t * It's very difficult to mess with pages currently under IO\n\t * and in many cases impossible, so we just avoid it here.\n\t */\n\twait_on_page_writeback(p);\n\n\t/*\n\t * Now take care of user space mappings.\n\t * Abort on fail: __delete_from_page_cache() assumes unmapped page.\n\t *\n\t * When the raw error page is thp tail page, hpage points to the raw\n\t * page after thp split.\n\t */\n\tif (!hwpoison_user_mappings(p, pfn, flags, &hpage)) {\n\t\taction_result(pfn, MF_MSG_UNMAP_FAILED, MF_IGNORED);\n\t\tres = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Torn down by someone else?\n\t */\n\tif (PageLRU(p) && !PageSwapCache(p) && p->mapping == NULL) {\n\t\taction_result(pfn, MF_MSG_TRUNCATED_LRU, MF_IGNORED);\n\t\tres = -EBUSY;\n\t\tgoto out;\n\t}\n\nidentify_page_state:\n\tres = identify_page_state(pfn, p, page_flags);\nout:\n\tunlock_page(p);\n\treturn res;\n}"
  },
  {
    "function_name": "memory_failure_dev_pagemap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "1154-1229",
    "snippet": "static int memory_failure_dev_pagemap(unsigned long pfn, int flags,\n\t\tstruct dev_pagemap *pgmap)\n{\n\tstruct page *page = pfn_to_page(pfn);\n\tconst bool unmap_success = true;\n\tunsigned long size = 0;\n\tstruct to_kill *tk;\n\tLIST_HEAD(tokill);\n\tint rc = -EBUSY;\n\tloff_t start;\n\n\t/*\n\t * Prevent the inode from being freed while we are interrogating\n\t * the address_space, typically this would be handled by\n\t * lock_page(), but dax pages do not use the page lock. This\n\t * also prevents changes to the mapping of this pfn until\n\t * poison signaling is complete.\n\t */\n\tif (!dax_lock_mapping_entry(page))\n\t\tgoto out;\n\n\tif (hwpoison_filter(page)) {\n\t\trc = 0;\n\t\tgoto unlock;\n\t}\n\n\tswitch (pgmap->type) {\n\tcase MEMORY_DEVICE_PRIVATE:\n\tcase MEMORY_DEVICE_PUBLIC:\n\t\t/*\n\t\t * TODO: Handle HMM pages which may need coordination\n\t\t * with device-side memory.\n\t\t */\n\t\tgoto unlock;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/*\n\t * Use this flag as an indication that the dax page has been\n\t * remapped UC to prevent speculative consumption of poison.\n\t */\n\tSetPageHWPoison(page);\n\n\t/*\n\t * Unlike System-RAM there is no possibility to swap in a\n\t * different physical page at a given virtual address, so all\n\t * userspace consumption of ZONE_DEVICE memory necessitates\n\t * SIGBUS (i.e. MF_MUST_KILL)\n\t */\n\tflags |= MF_ACTION_REQUIRED | MF_MUST_KILL;\n\tcollect_procs(page, &tokill, flags & MF_ACTION_REQUIRED);\n\n\tlist_for_each_entry(tk, &tokill, nd)\n\t\tif (tk->size_shift)\n\t\t\tsize = max(size, 1UL << tk->size_shift);\n\tif (size) {\n\t\t/*\n\t\t * Unmap the largest mapping to avoid breaking up\n\t\t * device-dax mappings which are constant size. The\n\t\t * actual size of the mapping being torn down is\n\t\t * communicated in siginfo, see kill_proc()\n\t\t */\n\t\tstart = (page->index << PAGE_SHIFT) & ~(size - 1);\n\t\tunmap_mapping_range(page->mapping, start, start + size, 0);\n\t}\n\tkill_procs(&tokill, flags & MF_MUST_KILL, !unmap_success, pfn, flags);\n\trc = 0;\nunlock:\n\tdax_unlock_mapping_entry(page);\nout:\n\t/* drop pgmap ref acquired in caller */\n\tput_dev_pagemap(pgmap);\n\taction_result(pfn, MF_MSG_DAX, rc ? MF_FAILED : MF_RECOVERED);\n\treturn rc;\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "action_result",
          "args": [
            "pfn",
            "MF_MSG_DAX",
            "rc ? MF_FAILED : MF_RECOVERED"
          ],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "action_result",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "886-893",
          "snippet": "static void action_result(unsigned long pfn, enum mf_action_page_type type,\n\t\t\t  enum mf_result result)\n{\n\ttrace_memory_failure_event(pfn, type, result);\n\n\tpr_err(\"Memory failure: %#lx: recovery action for %s: %s\\n\",\n\t\tpfn, action_page_types[type], action_name[result]);\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *action_name[] = {\n\t[MF_IGNORED] = \"Ignored\",\n\t[MF_FAILED] = \"Failed\",\n\t[MF_DELAYED] = \"Delayed\",\n\t[MF_RECOVERED] = \"Recovered\",\n};",
            "static const char * const action_page_types[] = {\n\t[MF_MSG_KERNEL]\t\t\t= \"reserved kernel page\",\n\t[MF_MSG_KERNEL_HIGH_ORDER]\t= \"high-order kernel page\",\n\t[MF_MSG_SLAB]\t\t\t= \"kernel slab page\",\n\t[MF_MSG_DIFFERENT_COMPOUND]\t= \"different compound page after locking\",\n\t[MF_MSG_POISONED_HUGE]\t\t= \"huge page already hardware poisoned\",\n\t[MF_MSG_HUGE]\t\t\t= \"huge page\",\n\t[MF_MSG_FREE_HUGE]\t\t= \"free huge page\",\n\t[MF_MSG_NON_PMD_HUGE]\t\t= \"non-pmd-sized huge page\",\n\t[MF_MSG_UNMAP_FAILED]\t\t= \"unmapping failed page\",\n\t[MF_MSG_DIRTY_SWAPCACHE]\t= \"dirty swapcache page\",\n\t[MF_MSG_CLEAN_SWAPCACHE]\t= \"clean swapcache page\",\n\t[MF_MSG_DIRTY_MLOCKED_LRU]\t= \"dirty mlocked LRU page\",\n\t[MF_MSG_CLEAN_MLOCKED_LRU]\t= \"clean mlocked LRU page\",\n\t[MF_MSG_DIRTY_UNEVICTABLE_LRU]\t= \"dirty unevictable LRU page\",\n\t[MF_MSG_CLEAN_UNEVICTABLE_LRU]\t= \"clean unevictable LRU page\",\n\t[MF_MSG_DIRTY_LRU]\t\t= \"dirty LRU page\",\n\t[MF_MSG_CLEAN_LRU]\t\t= \"clean LRU page\",\n\t[MF_MSG_TRUNCATED_LRU]\t\t= \"already truncated LRU page\",\n\t[MF_MSG_BUDDY]\t\t\t= \"free buddy page\",\n\t[MF_MSG_BUDDY_2ND]\t\t= \"free buddy page (2nd try)\",\n\t[MF_MSG_DAX]\t\t\t= \"dax page\",\n\t[MF_MSG_UNKNOWN]\t\t= \"unknown page\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic const char *action_name[] = {\n\t[MF_IGNORED] = \"Ignored\",\n\t[MF_FAILED] = \"Failed\",\n\t[MF_DELAYED] = \"Delayed\",\n\t[MF_RECOVERED] = \"Recovered\",\n};\nstatic const char * const action_page_types[] = {\n\t[MF_MSG_KERNEL]\t\t\t= \"reserved kernel page\",\n\t[MF_MSG_KERNEL_HIGH_ORDER]\t= \"high-order kernel page\",\n\t[MF_MSG_SLAB]\t\t\t= \"kernel slab page\",\n\t[MF_MSG_DIFFERENT_COMPOUND]\t= \"different compound page after locking\",\n\t[MF_MSG_POISONED_HUGE]\t\t= \"huge page already hardware poisoned\",\n\t[MF_MSG_HUGE]\t\t\t= \"huge page\",\n\t[MF_MSG_FREE_HUGE]\t\t= \"free huge page\",\n\t[MF_MSG_NON_PMD_HUGE]\t\t= \"non-pmd-sized huge page\",\n\t[MF_MSG_UNMAP_FAILED]\t\t= \"unmapping failed page\",\n\t[MF_MSG_DIRTY_SWAPCACHE]\t= \"dirty swapcache page\",\n\t[MF_MSG_CLEAN_SWAPCACHE]\t= \"clean swapcache page\",\n\t[MF_MSG_DIRTY_MLOCKED_LRU]\t= \"dirty mlocked LRU page\",\n\t[MF_MSG_CLEAN_MLOCKED_LRU]\t= \"clean mlocked LRU page\",\n\t[MF_MSG_DIRTY_UNEVICTABLE_LRU]\t= \"dirty unevictable LRU page\",\n\t[MF_MSG_CLEAN_UNEVICTABLE_LRU]\t= \"clean unevictable LRU page\",\n\t[MF_MSG_DIRTY_LRU]\t\t= \"dirty LRU page\",\n\t[MF_MSG_CLEAN_LRU]\t\t= \"clean LRU page\",\n\t[MF_MSG_TRUNCATED_LRU]\t\t= \"already truncated LRU page\",\n\t[MF_MSG_BUDDY]\t\t\t= \"free buddy page\",\n\t[MF_MSG_BUDDY_2ND]\t\t= \"free buddy page (2nd try)\",\n\t[MF_MSG_DAX]\t\t\t= \"dax page\",\n\t[MF_MSG_UNKNOWN]\t\t= \"unknown page\",\n};\n\nstatic void action_result(unsigned long pfn, enum mf_action_page_type type,\n\t\t\t  enum mf_result result)\n{\n\ttrace_memory_failure_event(pfn, type, result);\n\n\tpr_err(\"Memory failure: %#lx: recovery action for %s: %s\\n\",\n\t\tpfn, action_page_types[type], action_name[result]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_dev_pagemap",
          "args": [
            "pgmap"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_unlock_mapping_entry",
          "args": [
            "page"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill_procs",
          "args": [
            "&tokill",
            "flags & MF_MUST_KILL",
            "!unmap_success",
            "pfn",
            "flags"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "kill_procs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "360-391",
          "snippet": "static void kill_procs(struct list_head *to_kill, int forcekill, bool fail,\n\t\tunsigned long pfn, int flags)\n{\n\tstruct to_kill *tk, *next;\n\n\tlist_for_each_entry_safe (tk, next, to_kill, nd) {\n\t\tif (forcekill) {\n\t\t\t/*\n\t\t\t * In case something went wrong with munmapping\n\t\t\t * make sure the process doesn't catch the\n\t\t\t * signal and then access the memory. Just kill it.\n\t\t\t */\n\t\t\tif (fail || tk->addr_valid == 0) {\n\t\t\t\tpr_err(\"Memory failure: %#lx: forcibly killing %s:%d because of failure to unmap corrupted page\\n\",\n\t\t\t\t       pfn, tk->tsk->comm, tk->tsk->pid);\n\t\t\t\tforce_sig(SIGKILL, tk->tsk);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * In theory the process could have mapped\n\t\t\t * something else on the address in-between. We could\n\t\t\t * check for that, but we need to tell the\n\t\t\t * process anyways.\n\t\t\t */\n\t\t\telse if (kill_proc(tk, pfn, flags) < 0)\n\t\t\t\tpr_err(\"Memory failure: %#lx: Cannot send advisory machine check signal to %s:%d\\n\",\n\t\t\t\t       pfn, tk->tsk->comm, tk->tsk->pid);\n\t\t}\n\t\tput_task_struct(tk->tsk);\n\t\tkfree(tk);\n\t}\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic void kill_procs(struct list_head *to_kill, int forcekill, bool fail,\n\t\tunsigned long pfn, int flags)\n{\n\tstruct to_kill *tk, *next;\n\n\tlist_for_each_entry_safe (tk, next, to_kill, nd) {\n\t\tif (forcekill) {\n\t\t\t/*\n\t\t\t * In case something went wrong with munmapping\n\t\t\t * make sure the process doesn't catch the\n\t\t\t * signal and then access the memory. Just kill it.\n\t\t\t */\n\t\t\tif (fail || tk->addr_valid == 0) {\n\t\t\t\tpr_err(\"Memory failure: %#lx: forcibly killing %s:%d because of failure to unmap corrupted page\\n\",\n\t\t\t\t       pfn, tk->tsk->comm, tk->tsk->pid);\n\t\t\t\tforce_sig(SIGKILL, tk->tsk);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * In theory the process could have mapped\n\t\t\t * something else on the address in-between. We could\n\t\t\t * check for that, but we need to tell the\n\t\t\t * process anyways.\n\t\t\t */\n\t\t\telse if (kill_proc(tk, pfn, flags) < 0)\n\t\t\t\tpr_err(\"Memory failure: %#lx: Cannot send advisory machine check signal to %s:%d\\n\",\n\t\t\t\t       pfn, tk->tsk->comm, tk->tsk->pid);\n\t\t}\n\t\tput_task_struct(tk->tsk);\n\t\tkfree(tk);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unmap_mapping_range",
          "args": [
            "page->mapping",
            "start",
            "start + size",
            "0"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_mapping_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "2630-2645",
          "snippet": "void unmap_mapping_range(struct address_space *mapping,\n\t\tloff_t const holebegin, loff_t const holelen, int even_cows)\n{\n\tpgoff_t hba = holebegin >> PAGE_SHIFT;\n\tpgoff_t hlen = (holelen + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\n\t/* Check for overflow. */\n\tif (sizeof(holelen) > sizeof(hlen)) {\n\t\tlong long holeend =\n\t\t\t(holebegin + holelen + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tif (holeend & ~(long long)ULONG_MAX)\n\t\t\thlen = ULONG_MAX - hba + 1;\n\t}\n\n\tunmap_mapping_pages(mapping, hba, hlen, even_cows);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvoid unmap_mapping_range(struct address_space *mapping,\n\t\tloff_t const holebegin, loff_t const holelen, int even_cows)\n{\n\tpgoff_t hba = holebegin >> PAGE_SHIFT;\n\tpgoff_t hlen = (holelen + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\n\t/* Check for overflow. */\n\tif (sizeof(holelen) > sizeof(hlen)) {\n\t\tlong long holeend =\n\t\t\t(holebegin + holelen + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tif (holeend & ~(long long)ULONG_MAX)\n\t\t\thlen = ULONG_MAX - hba + 1;\n\t}\n\n\tunmap_mapping_pages(mapping, hba, hlen, even_cows);\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "size",
            "1UL << tk->size_shift"
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tk",
            "&tokill",
            "nd"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "collect_procs",
          "args": [
            "page",
            "&tokill",
            "flags & MF_ACTION_REQUIRED"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "collect_procs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "510-526",
          "snippet": "static void collect_procs(struct page *page, struct list_head *tokill,\n\t\t\t\tint force_early)\n{\n\tstruct to_kill *tk;\n\n\tif (!page->mapping)\n\t\treturn;\n\n\ttk = kmalloc(sizeof(struct to_kill), GFP_NOIO);\n\tif (!tk)\n\t\treturn;\n\tif (PageAnon(page))\n\t\tcollect_procs_anon(page, tokill, &tk, force_early);\n\telse\n\t\tcollect_procs_file(page, tokill, &tk, force_early);\n\tkfree(tk);\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic void collect_procs(struct page *page, struct list_head *tokill,\n\t\t\t\tint force_early)\n{\n\tstruct to_kill *tk;\n\n\tif (!page->mapping)\n\t\treturn;\n\n\ttk = kmalloc(sizeof(struct to_kill), GFP_NOIO);\n\tif (!tk)\n\t\treturn;\n\tif (PageAnon(page))\n\t\tcollect_procs_anon(page, tokill, &tk, force_early);\n\telse\n\t\tcollect_procs_file(page, tokill, &tk, force_early);\n\tkfree(tk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageHWPoison",
          "args": [
            "page"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hwpoison_filter",
          "args": [
            "page"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "hwpoison_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "170-173",
          "snippet": "int hwpoison_filter(struct page *p)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint hwpoison_filter(struct page *p)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dax_lock_mapping_entry",
          "args": [
            "page"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "tokill"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int memory_failure_dev_pagemap(unsigned long pfn, int flags,\n\t\tstruct dev_pagemap *pgmap)\n{\n\tstruct page *page = pfn_to_page(pfn);\n\tconst bool unmap_success = true;\n\tunsigned long size = 0;\n\tstruct to_kill *tk;\n\tLIST_HEAD(tokill);\n\tint rc = -EBUSY;\n\tloff_t start;\n\n\t/*\n\t * Prevent the inode from being freed while we are interrogating\n\t * the address_space, typically this would be handled by\n\t * lock_page(), but dax pages do not use the page lock. This\n\t * also prevents changes to the mapping of this pfn until\n\t * poison signaling is complete.\n\t */\n\tif (!dax_lock_mapping_entry(page))\n\t\tgoto out;\n\n\tif (hwpoison_filter(page)) {\n\t\trc = 0;\n\t\tgoto unlock;\n\t}\n\n\tswitch (pgmap->type) {\n\tcase MEMORY_DEVICE_PRIVATE:\n\tcase MEMORY_DEVICE_PUBLIC:\n\t\t/*\n\t\t * TODO: Handle HMM pages which may need coordination\n\t\t * with device-side memory.\n\t\t */\n\t\tgoto unlock;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/*\n\t * Use this flag as an indication that the dax page has been\n\t * remapped UC to prevent speculative consumption of poison.\n\t */\n\tSetPageHWPoison(page);\n\n\t/*\n\t * Unlike System-RAM there is no possibility to swap in a\n\t * different physical page at a given virtual address, so all\n\t * userspace consumption of ZONE_DEVICE memory necessitates\n\t * SIGBUS (i.e. MF_MUST_KILL)\n\t */\n\tflags |= MF_ACTION_REQUIRED | MF_MUST_KILL;\n\tcollect_procs(page, &tokill, flags & MF_ACTION_REQUIRED);\n\n\tlist_for_each_entry(tk, &tokill, nd)\n\t\tif (tk->size_shift)\n\t\t\tsize = max(size, 1UL << tk->size_shift);\n\tif (size) {\n\t\t/*\n\t\t * Unmap the largest mapping to avoid breaking up\n\t\t * device-dax mappings which are constant size. The\n\t\t * actual size of the mapping being torn down is\n\t\t * communicated in siginfo, see kill_proc()\n\t\t */\n\t\tstart = (page->index << PAGE_SHIFT) & ~(size - 1);\n\t\tunmap_mapping_range(page->mapping, start, start + size, 0);\n\t}\n\tkill_procs(&tokill, flags & MF_MUST_KILL, !unmap_success, pfn, flags);\n\trc = 0;\nunlock:\n\tdax_unlock_mapping_entry(page);\nout:\n\t/* drop pgmap ref acquired in caller */\n\tput_dev_pagemap(pgmap);\n\taction_result(pfn, MF_MSG_DAX, rc ? MF_FAILED : MF_RECOVERED);\n\treturn rc;\n}"
  },
  {
    "function_name": "memory_failure_hugetlb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "1082-1152",
    "snippet": "static int memory_failure_hugetlb(unsigned long pfn, int flags)\n{\n\tstruct page *p = pfn_to_page(pfn);\n\tstruct page *head = compound_head(p);\n\tint res;\n\tunsigned long page_flags;\n\n\tif (TestSetPageHWPoison(head)) {\n\t\tpr_err(\"Memory failure: %#lx: already hardware poisoned\\n\",\n\t\t       pfn);\n\t\treturn 0;\n\t}\n\n\tnum_poisoned_pages_inc();\n\n\tif (!(flags & MF_COUNT_INCREASED) && !get_hwpoison_page(p)) {\n\t\t/*\n\t\t * Check \"filter hit\" and \"race with other subpage.\"\n\t\t */\n\t\tlock_page(head);\n\t\tif (PageHWPoison(head)) {\n\t\t\tif ((hwpoison_filter(p) && TestClearPageHWPoison(p))\n\t\t\t    || (p != head && TestSetPageHWPoison(head))) {\n\t\t\t\tnum_poisoned_pages_dec();\n\t\t\t\tunlock_page(head);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tunlock_page(head);\n\t\tdissolve_free_huge_page(p);\n\t\taction_result(pfn, MF_MSG_FREE_HUGE, MF_DELAYED);\n\t\treturn 0;\n\t}\n\n\tlock_page(head);\n\tpage_flags = head->flags;\n\n\tif (!PageHWPoison(head)) {\n\t\tpr_err(\"Memory failure: %#lx: just unpoisoned\\n\", pfn);\n\t\tnum_poisoned_pages_dec();\n\t\tunlock_page(head);\n\t\tput_hwpoison_page(head);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * TODO: hwpoison for pud-sized hugetlb doesn't work right now, so\n\t * simply disable it. In order to make it work properly, we need\n\t * make sure that:\n\t *  - conversion of a pud that maps an error hugetlb into hwpoison\n\t *    entry properly works, and\n\t *  - other mm code walking over page table is aware of pud-aligned\n\t *    hwpoison entries.\n\t */\n\tif (huge_page_size(page_hstate(head)) > PMD_SIZE) {\n\t\taction_result(pfn, MF_MSG_NON_PMD_HUGE, MF_IGNORED);\n\t\tres = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (!hwpoison_user_mappings(p, pfn, flags, &head)) {\n\t\taction_result(pfn, MF_MSG_UNMAP_FAILED, MF_IGNORED);\n\t\tres = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tres = identify_page_state(pfn, p, page_flags);\nout:\n\tunlock_page(head);\n\treturn res;\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define head\t\t(1UL << PG_head)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "head"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "identify_page_state",
          "args": [
            "pfn",
            "p",
            "page_flags"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "identify_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "1059-1080",
          "snippet": "static int identify_page_state(unsigned long pfn, struct page *p,\n\t\t\t\tunsigned long page_flags)\n{\n\tstruct page_state *ps;\n\n\t/*\n\t * The first check uses the current page flags which may not have any\n\t * relevant information. The second check with the saved page flags is\n\t * carried out only if the first check can't determine the page status.\n\t */\n\tfor (ps = error_states;; ps++)\n\t\tif ((p->flags & ps->mask) == ps->res)\n\t\t\tbreak;\n\n\tpage_flags |= (p->flags & (1UL << PG_dirty));\n\n\tif (!ps->mask)\n\t\tfor (ps = error_states;; ps++)\n\t\t\tif ((page_flags & ps->mask) == ps->res)\n\t\t\t\tbreak;\n\treturn page_action(ps, p, pfn);\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct page_state {\n\tunsigned long mask;\n\tunsigned long res;\n\tenum mf_action_page_type type;\n\tint (*action)(struct page *p, unsigned long pfn);\n} error_states[] = {\n\t{ reserved,\treserved,\tMF_MSG_KERNEL,\tme_kernel },\n\t/*\n\t * free pages are specially detected outside this table:\n\t * PG_buddy pages only make a small fraction of all free pages.\n\t */\n\n\t/*\n\t * Could in theory check if slab page is free or if we can drop\n\t * currently unused objects without touching them. But just\n\t * treat it as standard kernel for now.\n\t */\n\t{ slab,\t\tslab,\t\tMF_MSG_SLAB,\tme_kernel },\n\n\t{ head,\t\thead,\t\tMF_MSG_HUGE,\t\tme_huge_page },\n\n\t{ sc|dirty,\tsc|dirty,\tMF_MSG_DIRTY_SWAPCACHE,\tme_swapcache_dirty },\n\t{ sc|dirty,\tsc,\t\tMF_MSG_CLEAN_SWAPCACHE,\tme_swapcache_clean },\n\n\t{ mlock|dirty,\tmlock|dirty,\tMF_MSG_DIRTY_MLOCKED_LRU,\tme_pagecache_dirty },\n\t{ mlock|dirty,\tmlock,\t\tMF_MSG_CLEAN_MLOCKED_LRU,\tme_pagecache_clean },\n\n\t{ unevict|dirty, unevict|dirty,\tMF_MSG_DIRTY_UNEVICTABLE_LRU,\tme_pagecache_dirty },\n\t{ unevict|dirty, unevict,\tMF_MSG_CLEAN_UNEVICTABLE_LRU,\tme_pagecache_clean },\n\n\t{ lru|dirty,\tlru|dirty,\tMF_MSG_DIRTY_LRU,\tme_pagecache_dirty },\n\t{ lru|dirty,\tlru,\t\tMF_MSG_CLEAN_LRU,\tme_pagecache_clean },\n\n\t/*\n\t * Catchall entry: must be at end.\n\t */\n\t{ 0,\t\t0,\t\tMF_MSG_UNKNOWN,\tme_unknown },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic struct page_state {\n\tunsigned long mask;\n\tunsigned long res;\n\tenum mf_action_page_type type;\n\tint (*action)(struct page *p, unsigned long pfn);\n} error_states[] = {\n\t{ reserved,\treserved,\tMF_MSG_KERNEL,\tme_kernel },\n\t/*\n\t * free pages are specially detected outside this table:\n\t * PG_buddy pages only make a small fraction of all free pages.\n\t */\n\n\t/*\n\t * Could in theory check if slab page is free or if we can drop\n\t * currently unused objects without touching them. But just\n\t * treat it as standard kernel for now.\n\t */\n\t{ slab,\t\tslab,\t\tMF_MSG_SLAB,\tme_kernel },\n\n\t{ head,\t\thead,\t\tMF_MSG_HUGE,\t\tme_huge_page },\n\n\t{ sc|dirty,\tsc|dirty,\tMF_MSG_DIRTY_SWAPCACHE,\tme_swapcache_dirty },\n\t{ sc|dirty,\tsc,\t\tMF_MSG_CLEAN_SWAPCACHE,\tme_swapcache_clean },\n\n\t{ mlock|dirty,\tmlock|dirty,\tMF_MSG_DIRTY_MLOCKED_LRU,\tme_pagecache_dirty },\n\t{ mlock|dirty,\tmlock,\t\tMF_MSG_CLEAN_MLOCKED_LRU,\tme_pagecache_clean },\n\n\t{ unevict|dirty, unevict|dirty,\tMF_MSG_DIRTY_UNEVICTABLE_LRU,\tme_pagecache_dirty },\n\t{ unevict|dirty, unevict,\tMF_MSG_CLEAN_UNEVICTABLE_LRU,\tme_pagecache_clean },\n\n\t{ lru|dirty,\tlru|dirty,\tMF_MSG_DIRTY_LRU,\tme_pagecache_dirty },\n\t{ lru|dirty,\tlru,\t\tMF_MSG_CLEAN_LRU,\tme_pagecache_clean },\n\n\t/*\n\t * Catchall entry: must be at end.\n\t */\n\t{ 0,\t\t0,\t\tMF_MSG_UNKNOWN,\tme_unknown },\n};\n\nstatic int identify_page_state(unsigned long pfn, struct page *p,\n\t\t\t\tunsigned long page_flags)\n{\n\tstruct page_state *ps;\n\n\t/*\n\t * The first check uses the current page flags which may not have any\n\t * relevant information. The second check with the saved page flags is\n\t * carried out only if the first check can't determine the page status.\n\t */\n\tfor (ps = error_states;; ps++)\n\t\tif ((p->flags & ps->mask) == ps->res)\n\t\t\tbreak;\n\n\tpage_flags |= (p->flags & (1UL << PG_dirty));\n\n\tif (!ps->mask)\n\t\tfor (ps = error_states;; ps++)\n\t\t\tif ((page_flags & ps->mask) == ps->res)\n\t\t\t\tbreak;\n\treturn page_action(ps, p, pfn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "action_result",
          "args": [
            "pfn",
            "MF_MSG_UNMAP_FAILED",
            "MF_IGNORED"
          ],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "action_result",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "886-893",
          "snippet": "static void action_result(unsigned long pfn, enum mf_action_page_type type,\n\t\t\t  enum mf_result result)\n{\n\ttrace_memory_failure_event(pfn, type, result);\n\n\tpr_err(\"Memory failure: %#lx: recovery action for %s: %s\\n\",\n\t\tpfn, action_page_types[type], action_name[result]);\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *action_name[] = {\n\t[MF_IGNORED] = \"Ignored\",\n\t[MF_FAILED] = \"Failed\",\n\t[MF_DELAYED] = \"Delayed\",\n\t[MF_RECOVERED] = \"Recovered\",\n};",
            "static const char * const action_page_types[] = {\n\t[MF_MSG_KERNEL]\t\t\t= \"reserved kernel page\",\n\t[MF_MSG_KERNEL_HIGH_ORDER]\t= \"high-order kernel page\",\n\t[MF_MSG_SLAB]\t\t\t= \"kernel slab page\",\n\t[MF_MSG_DIFFERENT_COMPOUND]\t= \"different compound page after locking\",\n\t[MF_MSG_POISONED_HUGE]\t\t= \"huge page already hardware poisoned\",\n\t[MF_MSG_HUGE]\t\t\t= \"huge page\",\n\t[MF_MSG_FREE_HUGE]\t\t= \"free huge page\",\n\t[MF_MSG_NON_PMD_HUGE]\t\t= \"non-pmd-sized huge page\",\n\t[MF_MSG_UNMAP_FAILED]\t\t= \"unmapping failed page\",\n\t[MF_MSG_DIRTY_SWAPCACHE]\t= \"dirty swapcache page\",\n\t[MF_MSG_CLEAN_SWAPCACHE]\t= \"clean swapcache page\",\n\t[MF_MSG_DIRTY_MLOCKED_LRU]\t= \"dirty mlocked LRU page\",\n\t[MF_MSG_CLEAN_MLOCKED_LRU]\t= \"clean mlocked LRU page\",\n\t[MF_MSG_DIRTY_UNEVICTABLE_LRU]\t= \"dirty unevictable LRU page\",\n\t[MF_MSG_CLEAN_UNEVICTABLE_LRU]\t= \"clean unevictable LRU page\",\n\t[MF_MSG_DIRTY_LRU]\t\t= \"dirty LRU page\",\n\t[MF_MSG_CLEAN_LRU]\t\t= \"clean LRU page\",\n\t[MF_MSG_TRUNCATED_LRU]\t\t= \"already truncated LRU page\",\n\t[MF_MSG_BUDDY]\t\t\t= \"free buddy page\",\n\t[MF_MSG_BUDDY_2ND]\t\t= \"free buddy page (2nd try)\",\n\t[MF_MSG_DAX]\t\t\t= \"dax page\",\n\t[MF_MSG_UNKNOWN]\t\t= \"unknown page\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic const char *action_name[] = {\n\t[MF_IGNORED] = \"Ignored\",\n\t[MF_FAILED] = \"Failed\",\n\t[MF_DELAYED] = \"Delayed\",\n\t[MF_RECOVERED] = \"Recovered\",\n};\nstatic const char * const action_page_types[] = {\n\t[MF_MSG_KERNEL]\t\t\t= \"reserved kernel page\",\n\t[MF_MSG_KERNEL_HIGH_ORDER]\t= \"high-order kernel page\",\n\t[MF_MSG_SLAB]\t\t\t= \"kernel slab page\",\n\t[MF_MSG_DIFFERENT_COMPOUND]\t= \"different compound page after locking\",\n\t[MF_MSG_POISONED_HUGE]\t\t= \"huge page already hardware poisoned\",\n\t[MF_MSG_HUGE]\t\t\t= \"huge page\",\n\t[MF_MSG_FREE_HUGE]\t\t= \"free huge page\",\n\t[MF_MSG_NON_PMD_HUGE]\t\t= \"non-pmd-sized huge page\",\n\t[MF_MSG_UNMAP_FAILED]\t\t= \"unmapping failed page\",\n\t[MF_MSG_DIRTY_SWAPCACHE]\t= \"dirty swapcache page\",\n\t[MF_MSG_CLEAN_SWAPCACHE]\t= \"clean swapcache page\",\n\t[MF_MSG_DIRTY_MLOCKED_LRU]\t= \"dirty mlocked LRU page\",\n\t[MF_MSG_CLEAN_MLOCKED_LRU]\t= \"clean mlocked LRU page\",\n\t[MF_MSG_DIRTY_UNEVICTABLE_LRU]\t= \"dirty unevictable LRU page\",\n\t[MF_MSG_CLEAN_UNEVICTABLE_LRU]\t= \"clean unevictable LRU page\",\n\t[MF_MSG_DIRTY_LRU]\t\t= \"dirty LRU page\",\n\t[MF_MSG_CLEAN_LRU]\t\t= \"clean LRU page\",\n\t[MF_MSG_TRUNCATED_LRU]\t\t= \"already truncated LRU page\",\n\t[MF_MSG_BUDDY]\t\t\t= \"free buddy page\",\n\t[MF_MSG_BUDDY_2ND]\t\t= \"free buddy page (2nd try)\",\n\t[MF_MSG_DAX]\t\t\t= \"dax page\",\n\t[MF_MSG_UNKNOWN]\t\t= \"unknown page\",\n};\n\nstatic void action_result(unsigned long pfn, enum mf_action_page_type type,\n\t\t\t  enum mf_result result)\n{\n\ttrace_memory_failure_event(pfn, type, result);\n\n\tpr_err(\"Memory failure: %#lx: recovery action for %s: %s\\n\",\n\t\tpfn, action_page_types[type], action_name[result]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hwpoison_user_mappings",
          "args": [
            "p",
            "pfn",
            "flags",
            "&head"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "hwpoison_user_mappings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "963-1057",
          "snippet": "static bool hwpoison_user_mappings(struct page *p, unsigned long pfn,\n\t\t\t\t  int flags, struct page **hpagep)\n{\n\tenum ttu_flags ttu = TTU_IGNORE_MLOCK | TTU_IGNORE_ACCESS;\n\tstruct address_space *mapping;\n\tLIST_HEAD(tokill);\n\tbool unmap_success;\n\tint kill = 1, forcekill;\n\tstruct page *hpage = *hpagep;\n\tbool mlocked = PageMlocked(hpage);\n\n\t/*\n\t * Here we are interested only in user-mapped pages, so skip any\n\t * other types of pages.\n\t */\n\tif (PageReserved(p) || PageSlab(p))\n\t\treturn true;\n\tif (!(PageLRU(hpage) || PageHuge(p)))\n\t\treturn true;\n\n\t/*\n\t * This check implies we don't kill processes if their pages\n\t * are in the swap cache early. Those are always late kills.\n\t */\n\tif (!page_mapped(hpage))\n\t\treturn true;\n\n\tif (PageKsm(p)) {\n\t\tpr_err(\"Memory failure: %#lx: can't handle KSM pages.\\n\", pfn);\n\t\treturn false;\n\t}\n\n\tif (PageSwapCache(p)) {\n\t\tpr_err(\"Memory failure: %#lx: keeping poisoned page in swap cache\\n\",\n\t\t\tpfn);\n\t\tttu |= TTU_IGNORE_HWPOISON;\n\t}\n\n\t/*\n\t * Propagate the dirty bit from PTEs to struct page first, because we\n\t * need this to decide if we should kill or just drop the page.\n\t * XXX: the dirty test could be racy: set_page_dirty() may not always\n\t * be called inside page lock (it's recommended but not enforced).\n\t */\n\tmapping = page_mapping(hpage);\n\tif (!(flags & MF_MUST_KILL) && !PageDirty(hpage) && mapping &&\n\t    mapping_cap_writeback_dirty(mapping)) {\n\t\tif (page_mkclean(hpage)) {\n\t\t\tSetPageDirty(hpage);\n\t\t} else {\n\t\t\tkill = 0;\n\t\t\tttu |= TTU_IGNORE_HWPOISON;\n\t\t\tpr_info(\"Memory failure: %#lx: corrupted page was clean: dropped without side effects\\n\",\n\t\t\t\tpfn);\n\t\t}\n\t}\n\n\t/*\n\t * First collect all the processes that have the page\n\t * mapped in dirty form.  This has to be done before try_to_unmap,\n\t * because ttu takes the rmap data structures down.\n\t *\n\t * Error handling: We ignore errors here because\n\t * there's nothing that can be done.\n\t */\n\tif (kill)\n\t\tcollect_procs(hpage, &tokill, flags & MF_ACTION_REQUIRED);\n\n\tunmap_success = try_to_unmap(hpage, ttu);\n\tif (!unmap_success)\n\t\tpr_err(\"Memory failure: %#lx: failed to unmap page (mapcount=%d)\\n\",\n\t\t       pfn, page_mapcount(hpage));\n\n\t/*\n\t * try_to_unmap() might put mlocked page in lru cache, so call\n\t * shake_page() again to ensure that it's flushed.\n\t */\n\tif (mlocked)\n\t\tshake_page(hpage, 0);\n\n\t/*\n\t * Now that the dirty bit has been propagated to the\n\t * struct page and all unmaps done we can decide if\n\t * killing is needed or not.  Only kill when the page\n\t * was dirty or the process is not restartable,\n\t * otherwise the tokill list is merely\n\t * freed.  When there was a problem unmapping earlier\n\t * use a more force-full uncatchable kill to prevent\n\t * any accesses to the poisoned memory.\n\t */\n\tforcekill = PageDirty(hpage) || (flags & MF_MUST_KILL);\n\tkill_procs(&tokill, forcekill, !unmap_success, pfn, flags);\n\n\treturn unmap_success;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define lru\t\t(1UL << PG_lru)",
            "#define dirty\t\t(1UL << PG_dirty)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define lru\t\t(1UL << PG_lru)\n#define dirty\t\t(1UL << PG_dirty)\n\nstatic bool hwpoison_user_mappings(struct page *p, unsigned long pfn,\n\t\t\t\t  int flags, struct page **hpagep)\n{\n\tenum ttu_flags ttu = TTU_IGNORE_MLOCK | TTU_IGNORE_ACCESS;\n\tstruct address_space *mapping;\n\tLIST_HEAD(tokill);\n\tbool unmap_success;\n\tint kill = 1, forcekill;\n\tstruct page *hpage = *hpagep;\n\tbool mlocked = PageMlocked(hpage);\n\n\t/*\n\t * Here we are interested only in user-mapped pages, so skip any\n\t * other types of pages.\n\t */\n\tif (PageReserved(p) || PageSlab(p))\n\t\treturn true;\n\tif (!(PageLRU(hpage) || PageHuge(p)))\n\t\treturn true;\n\n\t/*\n\t * This check implies we don't kill processes if their pages\n\t * are in the swap cache early. Those are always late kills.\n\t */\n\tif (!page_mapped(hpage))\n\t\treturn true;\n\n\tif (PageKsm(p)) {\n\t\tpr_err(\"Memory failure: %#lx: can't handle KSM pages.\\n\", pfn);\n\t\treturn false;\n\t}\n\n\tif (PageSwapCache(p)) {\n\t\tpr_err(\"Memory failure: %#lx: keeping poisoned page in swap cache\\n\",\n\t\t\tpfn);\n\t\tttu |= TTU_IGNORE_HWPOISON;\n\t}\n\n\t/*\n\t * Propagate the dirty bit from PTEs to struct page first, because we\n\t * need this to decide if we should kill or just drop the page.\n\t * XXX: the dirty test could be racy: set_page_dirty() may not always\n\t * be called inside page lock (it's recommended but not enforced).\n\t */\n\tmapping = page_mapping(hpage);\n\tif (!(flags & MF_MUST_KILL) && !PageDirty(hpage) && mapping &&\n\t    mapping_cap_writeback_dirty(mapping)) {\n\t\tif (page_mkclean(hpage)) {\n\t\t\tSetPageDirty(hpage);\n\t\t} else {\n\t\t\tkill = 0;\n\t\t\tttu |= TTU_IGNORE_HWPOISON;\n\t\t\tpr_info(\"Memory failure: %#lx: corrupted page was clean: dropped without side effects\\n\",\n\t\t\t\tpfn);\n\t\t}\n\t}\n\n\t/*\n\t * First collect all the processes that have the page\n\t * mapped in dirty form.  This has to be done before try_to_unmap,\n\t * because ttu takes the rmap data structures down.\n\t *\n\t * Error handling: We ignore errors here because\n\t * there's nothing that can be done.\n\t */\n\tif (kill)\n\t\tcollect_procs(hpage, &tokill, flags & MF_ACTION_REQUIRED);\n\n\tunmap_success = try_to_unmap(hpage, ttu);\n\tif (!unmap_success)\n\t\tpr_err(\"Memory failure: %#lx: failed to unmap page (mapcount=%d)\\n\",\n\t\t       pfn, page_mapcount(hpage));\n\n\t/*\n\t * try_to_unmap() might put mlocked page in lru cache, so call\n\t * shake_page() again to ensure that it's flushed.\n\t */\n\tif (mlocked)\n\t\tshake_page(hpage, 0);\n\n\t/*\n\t * Now that the dirty bit has been propagated to the\n\t * struct page and all unmaps done we can decide if\n\t * killing is needed or not.  Only kill when the page\n\t * was dirty or the process is not restartable,\n\t * otherwise the tokill list is merely\n\t * freed.  When there was a problem unmapping earlier\n\t * use a more force-full uncatchable kill to prevent\n\t * any accesses to the poisoned memory.\n\t */\n\tforcekill = PageDirty(hpage) || (flags & MF_MUST_KILL);\n\tkill_procs(&tokill, forcekill, !unmap_success, pfn, flags);\n\n\treturn unmap_success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_page_size",
          "args": [
            "page_hstate(head)"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_hstate",
          "args": [
            "head"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_hwpoison_page",
          "args": [
            "head"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_poisoned_pages_dec",
          "args": [],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Memory failure: %#lx: just unpoisoned\\n\"",
            "pfn"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHWPoison",
          "args": [
            "head"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dissolve_free_huge_page",
          "args": [
            "p"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "dissolve_free_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1485-1514",
          "snippet": "int dissolve_free_huge_page(struct page *page)\n{\n\tint rc = -EBUSY;\n\n\tspin_lock(&hugetlb_lock);\n\tif (PageHuge(page) && !page_count(page)) {\n\t\tstruct page *head = compound_head(page);\n\t\tstruct hstate *h = page_hstate(head);\n\t\tint nid = page_to_nid(head);\n\t\tif (h->free_huge_pages - h->resv_huge_pages == 0)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Move PageHWPoison flag from head page to the raw error page,\n\t\t * which makes any subpages rather than the error page reusable.\n\t\t */\n\t\tif (PageHWPoison(head) && page != head) {\n\t\t\tSetPageHWPoison(page);\n\t\t\tClearPageHWPoison(head);\n\t\t}\n\t\tlist_del(&head->lru);\n\t\th->free_huge_pages--;\n\t\th->free_huge_pages_node[nid]--;\n\t\th->max_huge_pages--;\n\t\tupdate_and_free_page(h, head);\n\t\trc = 0;\n\t}\nout:\n\tspin_unlock(&hugetlb_lock);\n\treturn rc;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint dissolve_free_huge_page(struct page *page)\n{\n\tint rc = -EBUSY;\n\n\tspin_lock(&hugetlb_lock);\n\tif (PageHuge(page) && !page_count(page)) {\n\t\tstruct page *head = compound_head(page);\n\t\tstruct hstate *h = page_hstate(head);\n\t\tint nid = page_to_nid(head);\n\t\tif (h->free_huge_pages - h->resv_huge_pages == 0)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Move PageHWPoison flag from head page to the raw error page,\n\t\t * which makes any subpages rather than the error page reusable.\n\t\t */\n\t\tif (PageHWPoison(head) && page != head) {\n\t\t\tSetPageHWPoison(page);\n\t\t\tClearPageHWPoison(head);\n\t\t}\n\t\tlist_del(&head->lru);\n\t\th->free_huge_pages--;\n\t\th->free_huge_pages_node[nid]--;\n\t\th->max_huge_pages--;\n\t\tupdate_and_free_page(h, head);\n\t\trc = 0;\n\t}\nout:\n\tspin_unlock(&hugetlb_lock);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_poisoned_pages_dec",
          "args": [],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestSetPageHWPoison",
          "args": [
            "head"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestClearPageHWPoison",
          "args": [
            "p"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hwpoison_filter",
          "args": [
            "p"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "hwpoison_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "170-173",
          "snippet": "int hwpoison_filter(struct page *p)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint hwpoison_filter(struct page *p)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageHWPoison",
          "args": [
            "head"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_hwpoison_page",
          "args": [
            "p"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "get_hwpoison_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "928-956",
          "snippet": "int get_hwpoison_page(struct page *page)\n{\n\tstruct page *head = compound_head(page);\n\n\tif (!PageHuge(head) && PageTransHuge(head)) {\n\t\t/*\n\t\t * Non anonymous thp exists only in allocation/free time. We\n\t\t * can't handle such a case correctly, so let's give it up.\n\t\t * This should be better than triggering BUG_ON when kernel\n\t\t * tries to touch the \"partially handled\" page.\n\t\t */\n\t\tif (!PageAnon(head)) {\n\t\t\tpr_err(\"Memory failure: %#lx: non anonymous thp\\n\",\n\t\t\t\tpage_to_pfn(page));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (get_page_unless_zero(head)) {\n\t\tif (head == compound_head(page))\n\t\t\treturn 1;\n\n\t\tpr_info(\"Memory failure: %#lx cannot catch tail\\n\",\n\t\t\tpage_to_pfn(page));\n\t\tput_page(head);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define head\t\t(1UL << PG_head)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define head\t\t(1UL << PG_head)\n\nint get_hwpoison_page(struct page *page)\n{\n\tstruct page *head = compound_head(page);\n\n\tif (!PageHuge(head) && PageTransHuge(head)) {\n\t\t/*\n\t\t * Non anonymous thp exists only in allocation/free time. We\n\t\t * can't handle such a case correctly, so let's give it up.\n\t\t * This should be better than triggering BUG_ON when kernel\n\t\t * tries to touch the \"partially handled\" page.\n\t\t */\n\t\tif (!PageAnon(head)) {\n\t\t\tpr_err(\"Memory failure: %#lx: non anonymous thp\\n\",\n\t\t\t\tpage_to_pfn(page));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (get_page_unless_zero(head)) {\n\t\tif (head == compound_head(page))\n\t\t\treturn 1;\n\n\t\tpr_info(\"Memory failure: %#lx cannot catch tail\\n\",\n\t\t\tpage_to_pfn(page));\n\t\tput_page(head);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_poisoned_pages_inc",
          "args": [],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Memory failure: %#lx: already hardware poisoned\\n\"",
            "pfn"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestSetPageHWPoison",
          "args": [
            "head"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "p"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define head\t\t(1UL << PG_head)\n\nstatic int memory_failure_hugetlb(unsigned long pfn, int flags)\n{\n\tstruct page *p = pfn_to_page(pfn);\n\tstruct page *head = compound_head(p);\n\tint res;\n\tunsigned long page_flags;\n\n\tif (TestSetPageHWPoison(head)) {\n\t\tpr_err(\"Memory failure: %#lx: already hardware poisoned\\n\",\n\t\t       pfn);\n\t\treturn 0;\n\t}\n\n\tnum_poisoned_pages_inc();\n\n\tif (!(flags & MF_COUNT_INCREASED) && !get_hwpoison_page(p)) {\n\t\t/*\n\t\t * Check \"filter hit\" and \"race with other subpage.\"\n\t\t */\n\t\tlock_page(head);\n\t\tif (PageHWPoison(head)) {\n\t\t\tif ((hwpoison_filter(p) && TestClearPageHWPoison(p))\n\t\t\t    || (p != head && TestSetPageHWPoison(head))) {\n\t\t\t\tnum_poisoned_pages_dec();\n\t\t\t\tunlock_page(head);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tunlock_page(head);\n\t\tdissolve_free_huge_page(p);\n\t\taction_result(pfn, MF_MSG_FREE_HUGE, MF_DELAYED);\n\t\treturn 0;\n\t}\n\n\tlock_page(head);\n\tpage_flags = head->flags;\n\n\tif (!PageHWPoison(head)) {\n\t\tpr_err(\"Memory failure: %#lx: just unpoisoned\\n\", pfn);\n\t\tnum_poisoned_pages_dec();\n\t\tunlock_page(head);\n\t\tput_hwpoison_page(head);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * TODO: hwpoison for pud-sized hugetlb doesn't work right now, so\n\t * simply disable it. In order to make it work properly, we need\n\t * make sure that:\n\t *  - conversion of a pud that maps an error hugetlb into hwpoison\n\t *    entry properly works, and\n\t *  - other mm code walking over page table is aware of pud-aligned\n\t *    hwpoison entries.\n\t */\n\tif (huge_page_size(page_hstate(head)) > PMD_SIZE) {\n\t\taction_result(pfn, MF_MSG_NON_PMD_HUGE, MF_IGNORED);\n\t\tres = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (!hwpoison_user_mappings(p, pfn, flags, &head)) {\n\t\taction_result(pfn, MF_MSG_UNMAP_FAILED, MF_IGNORED);\n\t\tres = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tres = identify_page_state(pfn, p, page_flags);\nout:\n\tunlock_page(head);\n\treturn res;\n}"
  },
  {
    "function_name": "identify_page_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "1059-1080",
    "snippet": "static int identify_page_state(unsigned long pfn, struct page *p,\n\t\t\t\tunsigned long page_flags)\n{\n\tstruct page_state *ps;\n\n\t/*\n\t * The first check uses the current page flags which may not have any\n\t * relevant information. The second check with the saved page flags is\n\t * carried out only if the first check can't determine the page status.\n\t */\n\tfor (ps = error_states;; ps++)\n\t\tif ((p->flags & ps->mask) == ps->res)\n\t\t\tbreak;\n\n\tpage_flags |= (p->flags & (1UL << PG_dirty));\n\n\tif (!ps->mask)\n\t\tfor (ps = error_states;; ps++)\n\t\t\tif ((page_flags & ps->mask) == ps->res)\n\t\t\t\tbreak;\n\treturn page_action(ps, p, pfn);\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct page_state {\n\tunsigned long mask;\n\tunsigned long res;\n\tenum mf_action_page_type type;\n\tint (*action)(struct page *p, unsigned long pfn);\n} error_states[] = {\n\t{ reserved,\treserved,\tMF_MSG_KERNEL,\tme_kernel },\n\t/*\n\t * free pages are specially detected outside this table:\n\t * PG_buddy pages only make a small fraction of all free pages.\n\t */\n\n\t/*\n\t * Could in theory check if slab page is free or if we can drop\n\t * currently unused objects without touching them. But just\n\t * treat it as standard kernel for now.\n\t */\n\t{ slab,\t\tslab,\t\tMF_MSG_SLAB,\tme_kernel },\n\n\t{ head,\t\thead,\t\tMF_MSG_HUGE,\t\tme_huge_page },\n\n\t{ sc|dirty,\tsc|dirty,\tMF_MSG_DIRTY_SWAPCACHE,\tme_swapcache_dirty },\n\t{ sc|dirty,\tsc,\t\tMF_MSG_CLEAN_SWAPCACHE,\tme_swapcache_clean },\n\n\t{ mlock|dirty,\tmlock|dirty,\tMF_MSG_DIRTY_MLOCKED_LRU,\tme_pagecache_dirty },\n\t{ mlock|dirty,\tmlock,\t\tMF_MSG_CLEAN_MLOCKED_LRU,\tme_pagecache_clean },\n\n\t{ unevict|dirty, unevict|dirty,\tMF_MSG_DIRTY_UNEVICTABLE_LRU,\tme_pagecache_dirty },\n\t{ unevict|dirty, unevict,\tMF_MSG_CLEAN_UNEVICTABLE_LRU,\tme_pagecache_clean },\n\n\t{ lru|dirty,\tlru|dirty,\tMF_MSG_DIRTY_LRU,\tme_pagecache_dirty },\n\t{ lru|dirty,\tlru,\t\tMF_MSG_CLEAN_LRU,\tme_pagecache_clean },\n\n\t/*\n\t * Catchall entry: must be at end.\n\t */\n\t{ 0,\t\t0,\t\tMF_MSG_UNKNOWN,\tme_unknown },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_action",
          "args": [
            "ps",
            "p",
            "pfn"
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "page_action",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "895-919",
          "snippet": "static int page_action(struct page_state *ps, struct page *p,\n\t\t\tunsigned long pfn)\n{\n\tint result;\n\tint count;\n\n\tresult = ps->action(p, pfn);\n\n\tcount = page_count(p) - 1;\n\tif (ps->action == me_swapcache_dirty && result == MF_DELAYED)\n\t\tcount--;\n\tif (count > 0) {\n\t\tpr_err(\"Memory failure: %#lx: %s still referenced by %d users\\n\",\n\t\t       pfn, action_page_types[ps->type], count);\n\t\tresult = MF_FAILED;\n\t}\n\taction_result(pfn, ps->type, result);\n\n\t/* Could do more checks here if page looks ok */\n\t/*\n\t * Could adjust zone counters here to correct for the missing page.\n\t */\n\n\treturn (result == MF_RECOVERED || result == MF_DELAYED) ? 0 : -EBUSY;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const action_page_types[] = {\n\t[MF_MSG_KERNEL]\t\t\t= \"reserved kernel page\",\n\t[MF_MSG_KERNEL_HIGH_ORDER]\t= \"high-order kernel page\",\n\t[MF_MSG_SLAB]\t\t\t= \"kernel slab page\",\n\t[MF_MSG_DIFFERENT_COMPOUND]\t= \"different compound page after locking\",\n\t[MF_MSG_POISONED_HUGE]\t\t= \"huge page already hardware poisoned\",\n\t[MF_MSG_HUGE]\t\t\t= \"huge page\",\n\t[MF_MSG_FREE_HUGE]\t\t= \"free huge page\",\n\t[MF_MSG_NON_PMD_HUGE]\t\t= \"non-pmd-sized huge page\",\n\t[MF_MSG_UNMAP_FAILED]\t\t= \"unmapping failed page\",\n\t[MF_MSG_DIRTY_SWAPCACHE]\t= \"dirty swapcache page\",\n\t[MF_MSG_CLEAN_SWAPCACHE]\t= \"clean swapcache page\",\n\t[MF_MSG_DIRTY_MLOCKED_LRU]\t= \"dirty mlocked LRU page\",\n\t[MF_MSG_CLEAN_MLOCKED_LRU]\t= \"clean mlocked LRU page\",\n\t[MF_MSG_DIRTY_UNEVICTABLE_LRU]\t= \"dirty unevictable LRU page\",\n\t[MF_MSG_CLEAN_UNEVICTABLE_LRU]\t= \"clean unevictable LRU page\",\n\t[MF_MSG_DIRTY_LRU]\t\t= \"dirty LRU page\",\n\t[MF_MSG_CLEAN_LRU]\t\t= \"clean LRU page\",\n\t[MF_MSG_TRUNCATED_LRU]\t\t= \"already truncated LRU page\",\n\t[MF_MSG_BUDDY]\t\t\t= \"free buddy page\",\n\t[MF_MSG_BUDDY_2ND]\t\t= \"free buddy page (2nd try)\",\n\t[MF_MSG_DAX]\t\t\t= \"dax page\",\n\t[MF_MSG_UNKNOWN]\t\t= \"unknown page\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic const char * const action_page_types[] = {\n\t[MF_MSG_KERNEL]\t\t\t= \"reserved kernel page\",\n\t[MF_MSG_KERNEL_HIGH_ORDER]\t= \"high-order kernel page\",\n\t[MF_MSG_SLAB]\t\t\t= \"kernel slab page\",\n\t[MF_MSG_DIFFERENT_COMPOUND]\t= \"different compound page after locking\",\n\t[MF_MSG_POISONED_HUGE]\t\t= \"huge page already hardware poisoned\",\n\t[MF_MSG_HUGE]\t\t\t= \"huge page\",\n\t[MF_MSG_FREE_HUGE]\t\t= \"free huge page\",\n\t[MF_MSG_NON_PMD_HUGE]\t\t= \"non-pmd-sized huge page\",\n\t[MF_MSG_UNMAP_FAILED]\t\t= \"unmapping failed page\",\n\t[MF_MSG_DIRTY_SWAPCACHE]\t= \"dirty swapcache page\",\n\t[MF_MSG_CLEAN_SWAPCACHE]\t= \"clean swapcache page\",\n\t[MF_MSG_DIRTY_MLOCKED_LRU]\t= \"dirty mlocked LRU page\",\n\t[MF_MSG_CLEAN_MLOCKED_LRU]\t= \"clean mlocked LRU page\",\n\t[MF_MSG_DIRTY_UNEVICTABLE_LRU]\t= \"dirty unevictable LRU page\",\n\t[MF_MSG_CLEAN_UNEVICTABLE_LRU]\t= \"clean unevictable LRU page\",\n\t[MF_MSG_DIRTY_LRU]\t\t= \"dirty LRU page\",\n\t[MF_MSG_CLEAN_LRU]\t\t= \"clean LRU page\",\n\t[MF_MSG_TRUNCATED_LRU]\t\t= \"already truncated LRU page\",\n\t[MF_MSG_BUDDY]\t\t\t= \"free buddy page\",\n\t[MF_MSG_BUDDY_2ND]\t\t= \"free buddy page (2nd try)\",\n\t[MF_MSG_DAX]\t\t\t= \"dax page\",\n\t[MF_MSG_UNKNOWN]\t\t= \"unknown page\",\n};\n\nstatic int page_action(struct page_state *ps, struct page *p,\n\t\t\tunsigned long pfn)\n{\n\tint result;\n\tint count;\n\n\tresult = ps->action(p, pfn);\n\n\tcount = page_count(p) - 1;\n\tif (ps->action == me_swapcache_dirty && result == MF_DELAYED)\n\t\tcount--;\n\tif (count > 0) {\n\t\tpr_err(\"Memory failure: %#lx: %s still referenced by %d users\\n\",\n\t\t       pfn, action_page_types[ps->type], count);\n\t\tresult = MF_FAILED;\n\t}\n\taction_result(pfn, ps->type, result);\n\n\t/* Could do more checks here if page looks ok */\n\t/*\n\t * Could adjust zone counters here to correct for the missing page.\n\t */\n\n\treturn (result == MF_RECOVERED || result == MF_DELAYED) ? 0 : -EBUSY;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic struct page_state {\n\tunsigned long mask;\n\tunsigned long res;\n\tenum mf_action_page_type type;\n\tint (*action)(struct page *p, unsigned long pfn);\n} error_states[] = {\n\t{ reserved,\treserved,\tMF_MSG_KERNEL,\tme_kernel },\n\t/*\n\t * free pages are specially detected outside this table:\n\t * PG_buddy pages only make a small fraction of all free pages.\n\t */\n\n\t/*\n\t * Could in theory check if slab page is free or if we can drop\n\t * currently unused objects without touching them. But just\n\t * treat it as standard kernel for now.\n\t */\n\t{ slab,\t\tslab,\t\tMF_MSG_SLAB,\tme_kernel },\n\n\t{ head,\t\thead,\t\tMF_MSG_HUGE,\t\tme_huge_page },\n\n\t{ sc|dirty,\tsc|dirty,\tMF_MSG_DIRTY_SWAPCACHE,\tme_swapcache_dirty },\n\t{ sc|dirty,\tsc,\t\tMF_MSG_CLEAN_SWAPCACHE,\tme_swapcache_clean },\n\n\t{ mlock|dirty,\tmlock|dirty,\tMF_MSG_DIRTY_MLOCKED_LRU,\tme_pagecache_dirty },\n\t{ mlock|dirty,\tmlock,\t\tMF_MSG_CLEAN_MLOCKED_LRU,\tme_pagecache_clean },\n\n\t{ unevict|dirty, unevict|dirty,\tMF_MSG_DIRTY_UNEVICTABLE_LRU,\tme_pagecache_dirty },\n\t{ unevict|dirty, unevict,\tMF_MSG_CLEAN_UNEVICTABLE_LRU,\tme_pagecache_clean },\n\n\t{ lru|dirty,\tlru|dirty,\tMF_MSG_DIRTY_LRU,\tme_pagecache_dirty },\n\t{ lru|dirty,\tlru,\t\tMF_MSG_CLEAN_LRU,\tme_pagecache_clean },\n\n\t/*\n\t * Catchall entry: must be at end.\n\t */\n\t{ 0,\t\t0,\t\tMF_MSG_UNKNOWN,\tme_unknown },\n};\n\nstatic int identify_page_state(unsigned long pfn, struct page *p,\n\t\t\t\tunsigned long page_flags)\n{\n\tstruct page_state *ps;\n\n\t/*\n\t * The first check uses the current page flags which may not have any\n\t * relevant information. The second check with the saved page flags is\n\t * carried out only if the first check can't determine the page status.\n\t */\n\tfor (ps = error_states;; ps++)\n\t\tif ((p->flags & ps->mask) == ps->res)\n\t\t\tbreak;\n\n\tpage_flags |= (p->flags & (1UL << PG_dirty));\n\n\tif (!ps->mask)\n\t\tfor (ps = error_states;; ps++)\n\t\t\tif ((page_flags & ps->mask) == ps->res)\n\t\t\t\tbreak;\n\treturn page_action(ps, p, pfn);\n}"
  },
  {
    "function_name": "hwpoison_user_mappings",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "963-1057",
    "snippet": "static bool hwpoison_user_mappings(struct page *p, unsigned long pfn,\n\t\t\t\t  int flags, struct page **hpagep)\n{\n\tenum ttu_flags ttu = TTU_IGNORE_MLOCK | TTU_IGNORE_ACCESS;\n\tstruct address_space *mapping;\n\tLIST_HEAD(tokill);\n\tbool unmap_success;\n\tint kill = 1, forcekill;\n\tstruct page *hpage = *hpagep;\n\tbool mlocked = PageMlocked(hpage);\n\n\t/*\n\t * Here we are interested only in user-mapped pages, so skip any\n\t * other types of pages.\n\t */\n\tif (PageReserved(p) || PageSlab(p))\n\t\treturn true;\n\tif (!(PageLRU(hpage) || PageHuge(p)))\n\t\treturn true;\n\n\t/*\n\t * This check implies we don't kill processes if their pages\n\t * are in the swap cache early. Those are always late kills.\n\t */\n\tif (!page_mapped(hpage))\n\t\treturn true;\n\n\tif (PageKsm(p)) {\n\t\tpr_err(\"Memory failure: %#lx: can't handle KSM pages.\\n\", pfn);\n\t\treturn false;\n\t}\n\n\tif (PageSwapCache(p)) {\n\t\tpr_err(\"Memory failure: %#lx: keeping poisoned page in swap cache\\n\",\n\t\t\tpfn);\n\t\tttu |= TTU_IGNORE_HWPOISON;\n\t}\n\n\t/*\n\t * Propagate the dirty bit from PTEs to struct page first, because we\n\t * need this to decide if we should kill or just drop the page.\n\t * XXX: the dirty test could be racy: set_page_dirty() may not always\n\t * be called inside page lock (it's recommended but not enforced).\n\t */\n\tmapping = page_mapping(hpage);\n\tif (!(flags & MF_MUST_KILL) && !PageDirty(hpage) && mapping &&\n\t    mapping_cap_writeback_dirty(mapping)) {\n\t\tif (page_mkclean(hpage)) {\n\t\t\tSetPageDirty(hpage);\n\t\t} else {\n\t\t\tkill = 0;\n\t\t\tttu |= TTU_IGNORE_HWPOISON;\n\t\t\tpr_info(\"Memory failure: %#lx: corrupted page was clean: dropped without side effects\\n\",\n\t\t\t\tpfn);\n\t\t}\n\t}\n\n\t/*\n\t * First collect all the processes that have the page\n\t * mapped in dirty form.  This has to be done before try_to_unmap,\n\t * because ttu takes the rmap data structures down.\n\t *\n\t * Error handling: We ignore errors here because\n\t * there's nothing that can be done.\n\t */\n\tif (kill)\n\t\tcollect_procs(hpage, &tokill, flags & MF_ACTION_REQUIRED);\n\n\tunmap_success = try_to_unmap(hpage, ttu);\n\tif (!unmap_success)\n\t\tpr_err(\"Memory failure: %#lx: failed to unmap page (mapcount=%d)\\n\",\n\t\t       pfn, page_mapcount(hpage));\n\n\t/*\n\t * try_to_unmap() might put mlocked page in lru cache, so call\n\t * shake_page() again to ensure that it's flushed.\n\t */\n\tif (mlocked)\n\t\tshake_page(hpage, 0);\n\n\t/*\n\t * Now that the dirty bit has been propagated to the\n\t * struct page and all unmaps done we can decide if\n\t * killing is needed or not.  Only kill when the page\n\t * was dirty or the process is not restartable,\n\t * otherwise the tokill list is merely\n\t * freed.  When there was a problem unmapping earlier\n\t * use a more force-full uncatchable kill to prevent\n\t * any accesses to the poisoned memory.\n\t */\n\tforcekill = PageDirty(hpage) || (flags & MF_MUST_KILL);\n\tkill_procs(&tokill, forcekill, !unmap_success, pfn, flags);\n\n\treturn unmap_success;\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define lru\t\t(1UL << PG_lru)",
      "#define dirty\t\t(1UL << PG_dirty)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill_procs",
          "args": [
            "&tokill",
            "forcekill",
            "!unmap_success",
            "pfn",
            "flags"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "kill_procs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "360-391",
          "snippet": "static void kill_procs(struct list_head *to_kill, int forcekill, bool fail,\n\t\tunsigned long pfn, int flags)\n{\n\tstruct to_kill *tk, *next;\n\n\tlist_for_each_entry_safe (tk, next, to_kill, nd) {\n\t\tif (forcekill) {\n\t\t\t/*\n\t\t\t * In case something went wrong with munmapping\n\t\t\t * make sure the process doesn't catch the\n\t\t\t * signal and then access the memory. Just kill it.\n\t\t\t */\n\t\t\tif (fail || tk->addr_valid == 0) {\n\t\t\t\tpr_err(\"Memory failure: %#lx: forcibly killing %s:%d because of failure to unmap corrupted page\\n\",\n\t\t\t\t       pfn, tk->tsk->comm, tk->tsk->pid);\n\t\t\t\tforce_sig(SIGKILL, tk->tsk);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * In theory the process could have mapped\n\t\t\t * something else on the address in-between. We could\n\t\t\t * check for that, but we need to tell the\n\t\t\t * process anyways.\n\t\t\t */\n\t\t\telse if (kill_proc(tk, pfn, flags) < 0)\n\t\t\t\tpr_err(\"Memory failure: %#lx: Cannot send advisory machine check signal to %s:%d\\n\",\n\t\t\t\t       pfn, tk->tsk->comm, tk->tsk->pid);\n\t\t}\n\t\tput_task_struct(tk->tsk);\n\t\tkfree(tk);\n\t}\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic void kill_procs(struct list_head *to_kill, int forcekill, bool fail,\n\t\tunsigned long pfn, int flags)\n{\n\tstruct to_kill *tk, *next;\n\n\tlist_for_each_entry_safe (tk, next, to_kill, nd) {\n\t\tif (forcekill) {\n\t\t\t/*\n\t\t\t * In case something went wrong with munmapping\n\t\t\t * make sure the process doesn't catch the\n\t\t\t * signal and then access the memory. Just kill it.\n\t\t\t */\n\t\t\tif (fail || tk->addr_valid == 0) {\n\t\t\t\tpr_err(\"Memory failure: %#lx: forcibly killing %s:%d because of failure to unmap corrupted page\\n\",\n\t\t\t\t       pfn, tk->tsk->comm, tk->tsk->pid);\n\t\t\t\tforce_sig(SIGKILL, tk->tsk);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * In theory the process could have mapped\n\t\t\t * something else on the address in-between. We could\n\t\t\t * check for that, but we need to tell the\n\t\t\t * process anyways.\n\t\t\t */\n\t\t\telse if (kill_proc(tk, pfn, flags) < 0)\n\t\t\t\tpr_err(\"Memory failure: %#lx: Cannot send advisory machine check signal to %s:%d\\n\",\n\t\t\t\t       pfn, tk->tsk->comm, tk->tsk->pid);\n\t\t}\n\t\tput_task_struct(tk->tsk);\n\t\tkfree(tk);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "hpage"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shake_page",
          "args": [
            "hpage",
            "0"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "shake_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "245-265",
          "snippet": "void shake_page(struct page *p, int access)\n{\n\tif (PageHuge(p))\n\t\treturn;\n\n\tif (!PageSlab(p)) {\n\t\tlru_add_drain_all();\n\t\tif (PageLRU(p))\n\t\t\treturn;\n\t\tdrain_all_pages(page_zone(p));\n\t\tif (PageLRU(p) || is_free_buddy_page(p))\n\t\t\treturn;\n\t}\n\n\t/*\n\t * Only call shrink_node_slabs here (which would also shrink\n\t * other caches) if access is not potentially fatal.\n\t */\n\tif (access)\n\t\tdrop_slab_node(page_to_nid(p));\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nvoid shake_page(struct page *p, int access)\n{\n\tif (PageHuge(p))\n\t\treturn;\n\n\tif (!PageSlab(p)) {\n\t\tlru_add_drain_all();\n\t\tif (PageLRU(p))\n\t\t\treturn;\n\t\tdrain_all_pages(page_zone(p));\n\t\tif (PageLRU(p) || is_free_buddy_page(p))\n\t\t\treturn;\n\t}\n\n\t/*\n\t * Only call shrink_node_slabs here (which would also shrink\n\t * other caches) if access is not potentially fatal.\n\t */\n\tif (access)\n\t\tdrop_slab_node(page_to_nid(p));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Memory failure: %#lx: failed to unmap page (mapcount=%d)\\n\"",
            "pfn",
            "page_mapcount(hpage)"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapcount",
          "args": [
            "hpage"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_unmap",
          "args": [
            "hpage",
            "ttu"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_unmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1699-1726",
          "snippet": "bool try_to_unmap(struct page *page, enum ttu_flags flags)\n{\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = try_to_unmap_one,\n\t\t.arg = (void *)flags,\n\t\t.done = page_mapcount_is_zero,\n\t\t.anon_lock = page_lock_anon_vma_read,\n\t};\n\n\t/*\n\t * During exec, a temporary VMA is setup and later moved.\n\t * The VMA is moved under the anon_vma lock but not the\n\t * page tables leading to a race where migration cannot\n\t * find the migration ptes. Rather than increasing the\n\t * locking requirements of exec(), migration skips\n\t * temporary VMAs until after exec() completes.\n\t */\n\tif ((flags & (TTU_MIGRATION|TTU_SPLIT_FREEZE))\n\t    && !PageKsm(page) && PageAnon(page))\n\t\trwc.invalid_vma = invalid_migration_vma;\n\n\tif (flags & TTU_RMAP_LOCKED)\n\t\trmap_walk_locked(page, &rwc);\n\telse\n\t\trmap_walk(page, &rwc);\n\n\treturn !page_mapcount(page) ? true : false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nbool try_to_unmap(struct page *page, enum ttu_flags flags)\n{\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = try_to_unmap_one,\n\t\t.arg = (void *)flags,\n\t\t.done = page_mapcount_is_zero,\n\t\t.anon_lock = page_lock_anon_vma_read,\n\t};\n\n\t/*\n\t * During exec, a temporary VMA is setup and later moved.\n\t * The VMA is moved under the anon_vma lock but not the\n\t * page tables leading to a race where migration cannot\n\t * find the migration ptes. Rather than increasing the\n\t * locking requirements of exec(), migration skips\n\t * temporary VMAs until after exec() completes.\n\t */\n\tif ((flags & (TTU_MIGRATION|TTU_SPLIT_FREEZE))\n\t    && !PageKsm(page) && PageAnon(page))\n\t\trwc.invalid_vma = invalid_migration_vma;\n\n\tif (flags & TTU_RMAP_LOCKED)\n\t\trmap_walk_locked(page, &rwc);\n\telse\n\t\trmap_walk(page, &rwc);\n\n\treturn !page_mapcount(page) ? true : false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "collect_procs",
          "args": [
            "hpage",
            "&tokill",
            "flags & MF_ACTION_REQUIRED"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "collect_procs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "510-526",
          "snippet": "static void collect_procs(struct page *page, struct list_head *tokill,\n\t\t\t\tint force_early)\n{\n\tstruct to_kill *tk;\n\n\tif (!page->mapping)\n\t\treturn;\n\n\ttk = kmalloc(sizeof(struct to_kill), GFP_NOIO);\n\tif (!tk)\n\t\treturn;\n\tif (PageAnon(page))\n\t\tcollect_procs_anon(page, tokill, &tk, force_early);\n\telse\n\t\tcollect_procs_file(page, tokill, &tk, force_early);\n\tkfree(tk);\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic void collect_procs(struct page *page, struct list_head *tokill,\n\t\t\t\tint force_early)\n{\n\tstruct to_kill *tk;\n\n\tif (!page->mapping)\n\t\treturn;\n\n\ttk = kmalloc(sizeof(struct to_kill), GFP_NOIO);\n\tif (!tk)\n\t\treturn;\n\tif (PageAnon(page))\n\t\tcollect_procs_anon(page, tokill, &tk, force_early);\n\telse\n\t\tcollect_procs_file(page, tokill, &tk, force_early);\n\tkfree(tk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Memory failure: %#lx: corrupted page was clean: dropped without side effects\\n\"",
            "pfn"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageDirty",
          "args": [
            "hpage"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mkclean",
          "args": [
            "hpage"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "page_mkclean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "965-987",
          "snippet": "int page_mkclean(struct page *page)\n{\n\tint cleaned = 0;\n\tstruct address_space *mapping;\n\tstruct rmap_walk_control rwc = {\n\t\t.arg = (void *)&cleaned,\n\t\t.rmap_one = page_mkclean_one,\n\t\t.invalid_vma = invalid_mkclean_vma,\n\t};\n\n\tBUG_ON(!PageLocked(page));\n\n\tif (!page_mapped(page))\n\t\treturn 0;\n\n\tmapping = page_mapping(page);\n\tif (!mapping)\n\t\treturn 0;\n\n\trmap_walk(page, &rwc);\n\n\treturn cleaned;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint page_mkclean(struct page *page)\n{\n\tint cleaned = 0;\n\tstruct address_space *mapping;\n\tstruct rmap_walk_control rwc = {\n\t\t.arg = (void *)&cleaned,\n\t\t.rmap_one = page_mkclean_one,\n\t\t.invalid_vma = invalid_mkclean_vma,\n\t};\n\n\tBUG_ON(!PageLocked(page));\n\n\tif (!page_mapped(page))\n\t\treturn 0;\n\n\tmapping = page_mapping(page);\n\tif (!mapping)\n\t\treturn 0;\n\n\trmap_walk(page, &rwc);\n\n\treturn cleaned;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_cap_writeback_dirty",
          "args": [
            "mapping"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "hpage"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "hpage"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapping_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "528-533",
          "snippet": "struct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Memory failure: %#lx: keeping poisoned page in swap cache\\n\"",
            "pfn"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "p"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Memory failure: %#lx: can't handle KSM pages.\\n\"",
            "pfn"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageKsm",
          "args": [
            "p"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapped",
          "args": [
            "hpage"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "470-486",
          "snippet": "bool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nbool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "p"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "PageHugeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "225-228",
          "snippet": "static int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "hpage"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSlab",
          "args": [
            "p"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageReserved",
          "args": [
            "p"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageMlocked",
          "args": [
            "hpage"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "tokill"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define lru\t\t(1UL << PG_lru)\n#define dirty\t\t(1UL << PG_dirty)\n\nstatic bool hwpoison_user_mappings(struct page *p, unsigned long pfn,\n\t\t\t\t  int flags, struct page **hpagep)\n{\n\tenum ttu_flags ttu = TTU_IGNORE_MLOCK | TTU_IGNORE_ACCESS;\n\tstruct address_space *mapping;\n\tLIST_HEAD(tokill);\n\tbool unmap_success;\n\tint kill = 1, forcekill;\n\tstruct page *hpage = *hpagep;\n\tbool mlocked = PageMlocked(hpage);\n\n\t/*\n\t * Here we are interested only in user-mapped pages, so skip any\n\t * other types of pages.\n\t */\n\tif (PageReserved(p) || PageSlab(p))\n\t\treturn true;\n\tif (!(PageLRU(hpage) || PageHuge(p)))\n\t\treturn true;\n\n\t/*\n\t * This check implies we don't kill processes if their pages\n\t * are in the swap cache early. Those are always late kills.\n\t */\n\tif (!page_mapped(hpage))\n\t\treturn true;\n\n\tif (PageKsm(p)) {\n\t\tpr_err(\"Memory failure: %#lx: can't handle KSM pages.\\n\", pfn);\n\t\treturn false;\n\t}\n\n\tif (PageSwapCache(p)) {\n\t\tpr_err(\"Memory failure: %#lx: keeping poisoned page in swap cache\\n\",\n\t\t\tpfn);\n\t\tttu |= TTU_IGNORE_HWPOISON;\n\t}\n\n\t/*\n\t * Propagate the dirty bit from PTEs to struct page first, because we\n\t * need this to decide if we should kill or just drop the page.\n\t * XXX: the dirty test could be racy: set_page_dirty() may not always\n\t * be called inside page lock (it's recommended but not enforced).\n\t */\n\tmapping = page_mapping(hpage);\n\tif (!(flags & MF_MUST_KILL) && !PageDirty(hpage) && mapping &&\n\t    mapping_cap_writeback_dirty(mapping)) {\n\t\tif (page_mkclean(hpage)) {\n\t\t\tSetPageDirty(hpage);\n\t\t} else {\n\t\t\tkill = 0;\n\t\t\tttu |= TTU_IGNORE_HWPOISON;\n\t\t\tpr_info(\"Memory failure: %#lx: corrupted page was clean: dropped without side effects\\n\",\n\t\t\t\tpfn);\n\t\t}\n\t}\n\n\t/*\n\t * First collect all the processes that have the page\n\t * mapped in dirty form.  This has to be done before try_to_unmap,\n\t * because ttu takes the rmap data structures down.\n\t *\n\t * Error handling: We ignore errors here because\n\t * there's nothing that can be done.\n\t */\n\tif (kill)\n\t\tcollect_procs(hpage, &tokill, flags & MF_ACTION_REQUIRED);\n\n\tunmap_success = try_to_unmap(hpage, ttu);\n\tif (!unmap_success)\n\t\tpr_err(\"Memory failure: %#lx: failed to unmap page (mapcount=%d)\\n\",\n\t\t       pfn, page_mapcount(hpage));\n\n\t/*\n\t * try_to_unmap() might put mlocked page in lru cache, so call\n\t * shake_page() again to ensure that it's flushed.\n\t */\n\tif (mlocked)\n\t\tshake_page(hpage, 0);\n\n\t/*\n\t * Now that the dirty bit has been propagated to the\n\t * struct page and all unmaps done we can decide if\n\t * killing is needed or not.  Only kill when the page\n\t * was dirty or the process is not restartable,\n\t * otherwise the tokill list is merely\n\t * freed.  When there was a problem unmapping earlier\n\t * use a more force-full uncatchable kill to prevent\n\t * any accesses to the poisoned memory.\n\t */\n\tforcekill = PageDirty(hpage) || (flags & MF_MUST_KILL);\n\tkill_procs(&tokill, forcekill, !unmap_success, pfn, flags);\n\n\treturn unmap_success;\n}"
  },
  {
    "function_name": "get_hwpoison_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "928-956",
    "snippet": "int get_hwpoison_page(struct page *page)\n{\n\tstruct page *head = compound_head(page);\n\n\tif (!PageHuge(head) && PageTransHuge(head)) {\n\t\t/*\n\t\t * Non anonymous thp exists only in allocation/free time. We\n\t\t * can't handle such a case correctly, so let's give it up.\n\t\t * This should be better than triggering BUG_ON when kernel\n\t\t * tries to touch the \"partially handled\" page.\n\t\t */\n\t\tif (!PageAnon(head)) {\n\t\t\tpr_err(\"Memory failure: %#lx: non anonymous thp\\n\",\n\t\t\t\tpage_to_pfn(page));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (get_page_unless_zero(head)) {\n\t\tif (head == compound_head(page))\n\t\t\treturn 1;\n\n\t\tpr_info(\"Memory failure: %#lx cannot catch tail\\n\",\n\t\t\tpage_to_pfn(page));\n\t\tput_page(head);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define head\t\t(1UL << PG_head)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "head"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Memory failure: %#lx cannot catch tail\\n\"",
            "page_to_pfn(page)"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page_unless_zero",
          "args": [
            "head"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Memory failure: %#lx: non anonymous thp\\n\"",
            "page_to_pfn(page)"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "head"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "head"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "head"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "PageHugeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "225-228",
          "snippet": "static int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define head\t\t(1UL << PG_head)\n\nint get_hwpoison_page(struct page *page)\n{\n\tstruct page *head = compound_head(page);\n\n\tif (!PageHuge(head) && PageTransHuge(head)) {\n\t\t/*\n\t\t * Non anonymous thp exists only in allocation/free time. We\n\t\t * can't handle such a case correctly, so let's give it up.\n\t\t * This should be better than triggering BUG_ON when kernel\n\t\t * tries to touch the \"partially handled\" page.\n\t\t */\n\t\tif (!PageAnon(head)) {\n\t\t\tpr_err(\"Memory failure: %#lx: non anonymous thp\\n\",\n\t\t\t\tpage_to_pfn(page));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (get_page_unless_zero(head)) {\n\t\tif (head == compound_head(page))\n\t\t\treturn 1;\n\n\t\tpr_info(\"Memory failure: %#lx cannot catch tail\\n\",\n\t\t\tpage_to_pfn(page));\n\t\tput_page(head);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "page_action",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "895-919",
    "snippet": "static int page_action(struct page_state *ps, struct page *p,\n\t\t\tunsigned long pfn)\n{\n\tint result;\n\tint count;\n\n\tresult = ps->action(p, pfn);\n\n\tcount = page_count(p) - 1;\n\tif (ps->action == me_swapcache_dirty && result == MF_DELAYED)\n\t\tcount--;\n\tif (count > 0) {\n\t\tpr_err(\"Memory failure: %#lx: %s still referenced by %d users\\n\",\n\t\t       pfn, action_page_types[ps->type], count);\n\t\tresult = MF_FAILED;\n\t}\n\taction_result(pfn, ps->type, result);\n\n\t/* Could do more checks here if page looks ok */\n\t/*\n\t * Could adjust zone counters here to correct for the missing page.\n\t */\n\n\treturn (result == MF_RECOVERED || result == MF_DELAYED) ? 0 : -EBUSY;\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char * const action_page_types[] = {\n\t[MF_MSG_KERNEL]\t\t\t= \"reserved kernel page\",\n\t[MF_MSG_KERNEL_HIGH_ORDER]\t= \"high-order kernel page\",\n\t[MF_MSG_SLAB]\t\t\t= \"kernel slab page\",\n\t[MF_MSG_DIFFERENT_COMPOUND]\t= \"different compound page after locking\",\n\t[MF_MSG_POISONED_HUGE]\t\t= \"huge page already hardware poisoned\",\n\t[MF_MSG_HUGE]\t\t\t= \"huge page\",\n\t[MF_MSG_FREE_HUGE]\t\t= \"free huge page\",\n\t[MF_MSG_NON_PMD_HUGE]\t\t= \"non-pmd-sized huge page\",\n\t[MF_MSG_UNMAP_FAILED]\t\t= \"unmapping failed page\",\n\t[MF_MSG_DIRTY_SWAPCACHE]\t= \"dirty swapcache page\",\n\t[MF_MSG_CLEAN_SWAPCACHE]\t= \"clean swapcache page\",\n\t[MF_MSG_DIRTY_MLOCKED_LRU]\t= \"dirty mlocked LRU page\",\n\t[MF_MSG_CLEAN_MLOCKED_LRU]\t= \"clean mlocked LRU page\",\n\t[MF_MSG_DIRTY_UNEVICTABLE_LRU]\t= \"dirty unevictable LRU page\",\n\t[MF_MSG_CLEAN_UNEVICTABLE_LRU]\t= \"clean unevictable LRU page\",\n\t[MF_MSG_DIRTY_LRU]\t\t= \"dirty LRU page\",\n\t[MF_MSG_CLEAN_LRU]\t\t= \"clean LRU page\",\n\t[MF_MSG_TRUNCATED_LRU]\t\t= \"already truncated LRU page\",\n\t[MF_MSG_BUDDY]\t\t\t= \"free buddy page\",\n\t[MF_MSG_BUDDY_2ND]\t\t= \"free buddy page (2nd try)\",\n\t[MF_MSG_DAX]\t\t\t= \"dax page\",\n\t[MF_MSG_UNKNOWN]\t\t= \"unknown page\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "action_result",
          "args": [
            "pfn",
            "ps->type",
            "result"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "action_result",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "886-893",
          "snippet": "static void action_result(unsigned long pfn, enum mf_action_page_type type,\n\t\t\t  enum mf_result result)\n{\n\ttrace_memory_failure_event(pfn, type, result);\n\n\tpr_err(\"Memory failure: %#lx: recovery action for %s: %s\\n\",\n\t\tpfn, action_page_types[type], action_name[result]);\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *action_name[] = {\n\t[MF_IGNORED] = \"Ignored\",\n\t[MF_FAILED] = \"Failed\",\n\t[MF_DELAYED] = \"Delayed\",\n\t[MF_RECOVERED] = \"Recovered\",\n};",
            "static const char * const action_page_types[] = {\n\t[MF_MSG_KERNEL]\t\t\t= \"reserved kernel page\",\n\t[MF_MSG_KERNEL_HIGH_ORDER]\t= \"high-order kernel page\",\n\t[MF_MSG_SLAB]\t\t\t= \"kernel slab page\",\n\t[MF_MSG_DIFFERENT_COMPOUND]\t= \"different compound page after locking\",\n\t[MF_MSG_POISONED_HUGE]\t\t= \"huge page already hardware poisoned\",\n\t[MF_MSG_HUGE]\t\t\t= \"huge page\",\n\t[MF_MSG_FREE_HUGE]\t\t= \"free huge page\",\n\t[MF_MSG_NON_PMD_HUGE]\t\t= \"non-pmd-sized huge page\",\n\t[MF_MSG_UNMAP_FAILED]\t\t= \"unmapping failed page\",\n\t[MF_MSG_DIRTY_SWAPCACHE]\t= \"dirty swapcache page\",\n\t[MF_MSG_CLEAN_SWAPCACHE]\t= \"clean swapcache page\",\n\t[MF_MSG_DIRTY_MLOCKED_LRU]\t= \"dirty mlocked LRU page\",\n\t[MF_MSG_CLEAN_MLOCKED_LRU]\t= \"clean mlocked LRU page\",\n\t[MF_MSG_DIRTY_UNEVICTABLE_LRU]\t= \"dirty unevictable LRU page\",\n\t[MF_MSG_CLEAN_UNEVICTABLE_LRU]\t= \"clean unevictable LRU page\",\n\t[MF_MSG_DIRTY_LRU]\t\t= \"dirty LRU page\",\n\t[MF_MSG_CLEAN_LRU]\t\t= \"clean LRU page\",\n\t[MF_MSG_TRUNCATED_LRU]\t\t= \"already truncated LRU page\",\n\t[MF_MSG_BUDDY]\t\t\t= \"free buddy page\",\n\t[MF_MSG_BUDDY_2ND]\t\t= \"free buddy page (2nd try)\",\n\t[MF_MSG_DAX]\t\t\t= \"dax page\",\n\t[MF_MSG_UNKNOWN]\t\t= \"unknown page\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic const char *action_name[] = {\n\t[MF_IGNORED] = \"Ignored\",\n\t[MF_FAILED] = \"Failed\",\n\t[MF_DELAYED] = \"Delayed\",\n\t[MF_RECOVERED] = \"Recovered\",\n};\nstatic const char * const action_page_types[] = {\n\t[MF_MSG_KERNEL]\t\t\t= \"reserved kernel page\",\n\t[MF_MSG_KERNEL_HIGH_ORDER]\t= \"high-order kernel page\",\n\t[MF_MSG_SLAB]\t\t\t= \"kernel slab page\",\n\t[MF_MSG_DIFFERENT_COMPOUND]\t= \"different compound page after locking\",\n\t[MF_MSG_POISONED_HUGE]\t\t= \"huge page already hardware poisoned\",\n\t[MF_MSG_HUGE]\t\t\t= \"huge page\",\n\t[MF_MSG_FREE_HUGE]\t\t= \"free huge page\",\n\t[MF_MSG_NON_PMD_HUGE]\t\t= \"non-pmd-sized huge page\",\n\t[MF_MSG_UNMAP_FAILED]\t\t= \"unmapping failed page\",\n\t[MF_MSG_DIRTY_SWAPCACHE]\t= \"dirty swapcache page\",\n\t[MF_MSG_CLEAN_SWAPCACHE]\t= \"clean swapcache page\",\n\t[MF_MSG_DIRTY_MLOCKED_LRU]\t= \"dirty mlocked LRU page\",\n\t[MF_MSG_CLEAN_MLOCKED_LRU]\t= \"clean mlocked LRU page\",\n\t[MF_MSG_DIRTY_UNEVICTABLE_LRU]\t= \"dirty unevictable LRU page\",\n\t[MF_MSG_CLEAN_UNEVICTABLE_LRU]\t= \"clean unevictable LRU page\",\n\t[MF_MSG_DIRTY_LRU]\t\t= \"dirty LRU page\",\n\t[MF_MSG_CLEAN_LRU]\t\t= \"clean LRU page\",\n\t[MF_MSG_TRUNCATED_LRU]\t\t= \"already truncated LRU page\",\n\t[MF_MSG_BUDDY]\t\t\t= \"free buddy page\",\n\t[MF_MSG_BUDDY_2ND]\t\t= \"free buddy page (2nd try)\",\n\t[MF_MSG_DAX]\t\t\t= \"dax page\",\n\t[MF_MSG_UNKNOWN]\t\t= \"unknown page\",\n};\n\nstatic void action_result(unsigned long pfn, enum mf_action_page_type type,\n\t\t\t  enum mf_result result)\n{\n\ttrace_memory_failure_event(pfn, type, result);\n\n\tpr_err(\"Memory failure: %#lx: recovery action for %s: %s\\n\",\n\t\tpfn, action_page_types[type], action_name[result]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Memory failure: %#lx: %s still referenced by %d users\\n\"",
            "pfn",
            "action_page_types[ps->type]",
            "count"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "p"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ps->action",
          "args": [
            "p",
            "pfn"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic const char * const action_page_types[] = {\n\t[MF_MSG_KERNEL]\t\t\t= \"reserved kernel page\",\n\t[MF_MSG_KERNEL_HIGH_ORDER]\t= \"high-order kernel page\",\n\t[MF_MSG_SLAB]\t\t\t= \"kernel slab page\",\n\t[MF_MSG_DIFFERENT_COMPOUND]\t= \"different compound page after locking\",\n\t[MF_MSG_POISONED_HUGE]\t\t= \"huge page already hardware poisoned\",\n\t[MF_MSG_HUGE]\t\t\t= \"huge page\",\n\t[MF_MSG_FREE_HUGE]\t\t= \"free huge page\",\n\t[MF_MSG_NON_PMD_HUGE]\t\t= \"non-pmd-sized huge page\",\n\t[MF_MSG_UNMAP_FAILED]\t\t= \"unmapping failed page\",\n\t[MF_MSG_DIRTY_SWAPCACHE]\t= \"dirty swapcache page\",\n\t[MF_MSG_CLEAN_SWAPCACHE]\t= \"clean swapcache page\",\n\t[MF_MSG_DIRTY_MLOCKED_LRU]\t= \"dirty mlocked LRU page\",\n\t[MF_MSG_CLEAN_MLOCKED_LRU]\t= \"clean mlocked LRU page\",\n\t[MF_MSG_DIRTY_UNEVICTABLE_LRU]\t= \"dirty unevictable LRU page\",\n\t[MF_MSG_CLEAN_UNEVICTABLE_LRU]\t= \"clean unevictable LRU page\",\n\t[MF_MSG_DIRTY_LRU]\t\t= \"dirty LRU page\",\n\t[MF_MSG_CLEAN_LRU]\t\t= \"clean LRU page\",\n\t[MF_MSG_TRUNCATED_LRU]\t\t= \"already truncated LRU page\",\n\t[MF_MSG_BUDDY]\t\t\t= \"free buddy page\",\n\t[MF_MSG_BUDDY_2ND]\t\t= \"free buddy page (2nd try)\",\n\t[MF_MSG_DAX]\t\t\t= \"dax page\",\n\t[MF_MSG_UNKNOWN]\t\t= \"unknown page\",\n};\n\nstatic int page_action(struct page_state *ps, struct page *p,\n\t\t\tunsigned long pfn)\n{\n\tint result;\n\tint count;\n\n\tresult = ps->action(p, pfn);\n\n\tcount = page_count(p) - 1;\n\tif (ps->action == me_swapcache_dirty && result == MF_DELAYED)\n\t\tcount--;\n\tif (count > 0) {\n\t\tpr_err(\"Memory failure: %#lx: %s still referenced by %d users\\n\",\n\t\t       pfn, action_page_types[ps->type], count);\n\t\tresult = MF_FAILED;\n\t}\n\taction_result(pfn, ps->type, result);\n\n\t/* Could do more checks here if page looks ok */\n\t/*\n\t * Could adjust zone counters here to correct for the missing page.\n\t */\n\n\treturn (result == MF_RECOVERED || result == MF_DELAYED) ? 0 : -EBUSY;\n}"
  },
  {
    "function_name": "action_result",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "886-893",
    "snippet": "static void action_result(unsigned long pfn, enum mf_action_page_type type,\n\t\t\t  enum mf_result result)\n{\n\ttrace_memory_failure_event(pfn, type, result);\n\n\tpr_err(\"Memory failure: %#lx: recovery action for %s: %s\\n\",\n\t\tpfn, action_page_types[type], action_name[result]);\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *action_name[] = {\n\t[MF_IGNORED] = \"Ignored\",\n\t[MF_FAILED] = \"Failed\",\n\t[MF_DELAYED] = \"Delayed\",\n\t[MF_RECOVERED] = \"Recovered\",\n};",
      "static const char * const action_page_types[] = {\n\t[MF_MSG_KERNEL]\t\t\t= \"reserved kernel page\",\n\t[MF_MSG_KERNEL_HIGH_ORDER]\t= \"high-order kernel page\",\n\t[MF_MSG_SLAB]\t\t\t= \"kernel slab page\",\n\t[MF_MSG_DIFFERENT_COMPOUND]\t= \"different compound page after locking\",\n\t[MF_MSG_POISONED_HUGE]\t\t= \"huge page already hardware poisoned\",\n\t[MF_MSG_HUGE]\t\t\t= \"huge page\",\n\t[MF_MSG_FREE_HUGE]\t\t= \"free huge page\",\n\t[MF_MSG_NON_PMD_HUGE]\t\t= \"non-pmd-sized huge page\",\n\t[MF_MSG_UNMAP_FAILED]\t\t= \"unmapping failed page\",\n\t[MF_MSG_DIRTY_SWAPCACHE]\t= \"dirty swapcache page\",\n\t[MF_MSG_CLEAN_SWAPCACHE]\t= \"clean swapcache page\",\n\t[MF_MSG_DIRTY_MLOCKED_LRU]\t= \"dirty mlocked LRU page\",\n\t[MF_MSG_CLEAN_MLOCKED_LRU]\t= \"clean mlocked LRU page\",\n\t[MF_MSG_DIRTY_UNEVICTABLE_LRU]\t= \"dirty unevictable LRU page\",\n\t[MF_MSG_CLEAN_UNEVICTABLE_LRU]\t= \"clean unevictable LRU page\",\n\t[MF_MSG_DIRTY_LRU]\t\t= \"dirty LRU page\",\n\t[MF_MSG_CLEAN_LRU]\t\t= \"clean LRU page\",\n\t[MF_MSG_TRUNCATED_LRU]\t\t= \"already truncated LRU page\",\n\t[MF_MSG_BUDDY]\t\t\t= \"free buddy page\",\n\t[MF_MSG_BUDDY_2ND]\t\t= \"free buddy page (2nd try)\",\n\t[MF_MSG_DAX]\t\t\t= \"dax page\",\n\t[MF_MSG_UNKNOWN]\t\t= \"unknown page\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Memory failure: %#lx: recovery action for %s: %s\\n\"",
            "pfn",
            "action_page_types[type]",
            "action_name[result]"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_memory_failure_event",
          "args": [
            "pfn",
            "type",
            "result"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic const char *action_name[] = {\n\t[MF_IGNORED] = \"Ignored\",\n\t[MF_FAILED] = \"Failed\",\n\t[MF_DELAYED] = \"Delayed\",\n\t[MF_RECOVERED] = \"Recovered\",\n};\nstatic const char * const action_page_types[] = {\n\t[MF_MSG_KERNEL]\t\t\t= \"reserved kernel page\",\n\t[MF_MSG_KERNEL_HIGH_ORDER]\t= \"high-order kernel page\",\n\t[MF_MSG_SLAB]\t\t\t= \"kernel slab page\",\n\t[MF_MSG_DIFFERENT_COMPOUND]\t= \"different compound page after locking\",\n\t[MF_MSG_POISONED_HUGE]\t\t= \"huge page already hardware poisoned\",\n\t[MF_MSG_HUGE]\t\t\t= \"huge page\",\n\t[MF_MSG_FREE_HUGE]\t\t= \"free huge page\",\n\t[MF_MSG_NON_PMD_HUGE]\t\t= \"non-pmd-sized huge page\",\n\t[MF_MSG_UNMAP_FAILED]\t\t= \"unmapping failed page\",\n\t[MF_MSG_DIRTY_SWAPCACHE]\t= \"dirty swapcache page\",\n\t[MF_MSG_CLEAN_SWAPCACHE]\t= \"clean swapcache page\",\n\t[MF_MSG_DIRTY_MLOCKED_LRU]\t= \"dirty mlocked LRU page\",\n\t[MF_MSG_CLEAN_MLOCKED_LRU]\t= \"clean mlocked LRU page\",\n\t[MF_MSG_DIRTY_UNEVICTABLE_LRU]\t= \"dirty unevictable LRU page\",\n\t[MF_MSG_CLEAN_UNEVICTABLE_LRU]\t= \"clean unevictable LRU page\",\n\t[MF_MSG_DIRTY_LRU]\t\t= \"dirty LRU page\",\n\t[MF_MSG_CLEAN_LRU]\t\t= \"clean LRU page\",\n\t[MF_MSG_TRUNCATED_LRU]\t\t= \"already truncated LRU page\",\n\t[MF_MSG_BUDDY]\t\t\t= \"free buddy page\",\n\t[MF_MSG_BUDDY_2ND]\t\t= \"free buddy page (2nd try)\",\n\t[MF_MSG_DAX]\t\t\t= \"dax page\",\n\t[MF_MSG_UNKNOWN]\t\t= \"unknown page\",\n};\n\nstatic void action_result(unsigned long pfn, enum mf_action_page_type type,\n\t\t\t  enum mf_result result)\n{\n\ttrace_memory_failure_event(pfn, type, result);\n\n\tpr_err(\"Memory failure: %#lx: recovery action for %s: %s\\n\",\n\t\tpfn, action_page_types[type], action_name[result]);\n}"
  },
  {
    "function_name": "me_huge_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "781-808",
    "snippet": "static int me_huge_page(struct page *p, unsigned long pfn)\n{\n\tint res = 0;\n\tstruct page *hpage = compound_head(p);\n\tstruct address_space *mapping;\n\n\tif (!PageHuge(hpage))\n\t\treturn MF_DELAYED;\n\n\tmapping = page_mapping(hpage);\n\tif (mapping) {\n\t\tres = truncate_error_page(hpage, pfn, mapping);\n\t} else {\n\t\tunlock_page(hpage);\n\t\t/*\n\t\t * migration entry prevents later access on error anonymous\n\t\t * hugepage, so we can free and dissolve it into buddy to\n\t\t * save healthy subpages.\n\t\t */\n\t\tif (PageAnon(hpage))\n\t\t\tput_page(hpage);\n\t\tdissolve_free_huge_page(p);\n\t\tres = MF_RECOVERED;\n\t\tlock_page(hpage);\n\t}\n\n\treturn res;\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "hpage"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dissolve_free_huge_page",
          "args": [
            "p"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "dissolve_free_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1485-1514",
          "snippet": "int dissolve_free_huge_page(struct page *page)\n{\n\tint rc = -EBUSY;\n\n\tspin_lock(&hugetlb_lock);\n\tif (PageHuge(page) && !page_count(page)) {\n\t\tstruct page *head = compound_head(page);\n\t\tstruct hstate *h = page_hstate(head);\n\t\tint nid = page_to_nid(head);\n\t\tif (h->free_huge_pages - h->resv_huge_pages == 0)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Move PageHWPoison flag from head page to the raw error page,\n\t\t * which makes any subpages rather than the error page reusable.\n\t\t */\n\t\tif (PageHWPoison(head) && page != head) {\n\t\t\tSetPageHWPoison(page);\n\t\t\tClearPageHWPoison(head);\n\t\t}\n\t\tlist_del(&head->lru);\n\t\th->free_huge_pages--;\n\t\th->free_huge_pages_node[nid]--;\n\t\th->max_huge_pages--;\n\t\tupdate_and_free_page(h, head);\n\t\trc = 0;\n\t}\nout:\n\tspin_unlock(&hugetlb_lock);\n\treturn rc;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint dissolve_free_huge_page(struct page *page)\n{\n\tint rc = -EBUSY;\n\n\tspin_lock(&hugetlb_lock);\n\tif (PageHuge(page) && !page_count(page)) {\n\t\tstruct page *head = compound_head(page);\n\t\tstruct hstate *h = page_hstate(head);\n\t\tint nid = page_to_nid(head);\n\t\tif (h->free_huge_pages - h->resv_huge_pages == 0)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Move PageHWPoison flag from head page to the raw error page,\n\t\t * which makes any subpages rather than the error page reusable.\n\t\t */\n\t\tif (PageHWPoison(head) && page != head) {\n\t\t\tSetPageHWPoison(page);\n\t\t\tClearPageHWPoison(head);\n\t\t}\n\t\tlist_del(&head->lru);\n\t\th->free_huge_pages--;\n\t\th->free_huge_pages_node[nid]--;\n\t\th->max_huge_pages--;\n\t\tupdate_and_free_page(h, head);\n\t\trc = 0;\n\t}\nout:\n\tspin_unlock(&hugetlb_lock);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "hpage"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "hpage"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_error_page",
          "args": [
            "hpage",
            "pfn",
            "mapping"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_error_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "591-622",
          "snippet": "static int truncate_error_page(struct page *p, unsigned long pfn,\n\t\t\t\tstruct address_space *mapping)\n{\n\tint ret = MF_FAILED;\n\n\tif (mapping->a_ops->error_remove_page) {\n\t\tint err = mapping->a_ops->error_remove_page(mapping, p);\n\n\t\tif (err != 0) {\n\t\t\tpr_info(\"Memory failure: %#lx: Failed to punch page: %d\\n\",\n\t\t\t\tpfn, err);\n\t\t} else if (page_has_private(p) &&\n\t\t\t   !try_to_release_page(p, GFP_NOIO)) {\n\t\t\tpr_info(\"Memory failure: %#lx: failed to release buffers\\n\",\n\t\t\t\tpfn);\n\t\t} else {\n\t\t\tret = MF_RECOVERED;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * If the file system doesn't support it just invalidate\n\t\t * This fails on dirty or anything with private pages\n\t\t */\n\t\tif (invalidate_inode_page(p))\n\t\t\tret = MF_RECOVERED;\n\t\telse\n\t\t\tpr_info(\"Memory failure: %#lx: Failed to invalidate\\n\",\n\t\t\t\tpfn);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define dirty\t\t(1UL << PG_dirty)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define dirty\t\t(1UL << PG_dirty)\n\nstatic int truncate_error_page(struct page *p, unsigned long pfn,\n\t\t\t\tstruct address_space *mapping)\n{\n\tint ret = MF_FAILED;\n\n\tif (mapping->a_ops->error_remove_page) {\n\t\tint err = mapping->a_ops->error_remove_page(mapping, p);\n\n\t\tif (err != 0) {\n\t\t\tpr_info(\"Memory failure: %#lx: Failed to punch page: %d\\n\",\n\t\t\t\tpfn, err);\n\t\t} else if (page_has_private(p) &&\n\t\t\t   !try_to_release_page(p, GFP_NOIO)) {\n\t\t\tpr_info(\"Memory failure: %#lx: failed to release buffers\\n\",\n\t\t\t\tpfn);\n\t\t} else {\n\t\t\tret = MF_RECOVERED;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * If the file system doesn't support it just invalidate\n\t\t * This fails on dirty or anything with private pages\n\t\t */\n\t\tif (invalidate_inode_page(p))\n\t\t\tret = MF_RECOVERED;\n\t\telse\n\t\t\tpr_info(\"Memory failure: %#lx: Failed to invalidate\\n\",\n\t\t\t\tpfn);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "hpage"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapping_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "528-533",
          "snippet": "struct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "hpage"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "PageHugeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "225-228",
          "snippet": "static int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "p"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int me_huge_page(struct page *p, unsigned long pfn)\n{\n\tint res = 0;\n\tstruct page *hpage = compound_head(p);\n\tstruct address_space *mapping;\n\n\tif (!PageHuge(hpage))\n\t\treturn MF_DELAYED;\n\n\tmapping = page_mapping(hpage);\n\tif (mapping) {\n\t\tres = truncate_error_page(hpage, pfn, mapping);\n\t} else {\n\t\tunlock_page(hpage);\n\t\t/*\n\t\t * migration entry prevents later access on error anonymous\n\t\t * hugepage, so we can free and dissolve it into buddy to\n\t\t * save healthy subpages.\n\t\t */\n\t\tif (PageAnon(hpage))\n\t\t\tput_page(hpage);\n\t\tdissolve_free_huge_page(p);\n\t\tres = MF_RECOVERED;\n\t\tlock_page(hpage);\n\t}\n\n\treturn res;\n}"
  },
  {
    "function_name": "me_swapcache_clean",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "765-773",
    "snippet": "static int me_swapcache_clean(struct page *p, unsigned long pfn)\n{\n\tdelete_from_swap_cache(p);\n\n\tif (!delete_from_lru_cache(p))\n\t\treturn MF_RECOVERED;\n\telse\n\t\treturn MF_FAILED;\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "delete_from_lru_cache",
          "args": [
            "p"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "delete_from_lru_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "566-589",
          "snippet": "static int delete_from_lru_cache(struct page *p)\n{\n\tif (!isolate_lru_page(p)) {\n\t\t/*\n\t\t * Clear sensible page flags, so that the buddy system won't\n\t\t * complain when the page is unpoison-and-freed.\n\t\t */\n\t\tClearPageActive(p);\n\t\tClearPageUnevictable(p);\n\n\t\t/*\n\t\t * Poisoned page might never drop its ref count to 0 so we have\n\t\t * to uncharge it manually from its memcg.\n\t\t */\n\t\tmem_cgroup_uncharge(p);\n\n\t\t/*\n\t\t * drop the page count elevated by isolate_lru_page()\n\t\t */\n\t\tput_page(p);\n\t\treturn 0;\n\t}\n\treturn -EIO;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int delete_from_lru_cache(struct page *p)\n{\n\tif (!isolate_lru_page(p)) {\n\t\t/*\n\t\t * Clear sensible page flags, so that the buddy system won't\n\t\t * complain when the page is unpoison-and-freed.\n\t\t */\n\t\tClearPageActive(p);\n\t\tClearPageUnevictable(p);\n\n\t\t/*\n\t\t * Poisoned page might never drop its ref count to 0 so we have\n\t\t * to uncharge it manually from its memcg.\n\t\t */\n\t\tmem_cgroup_uncharge(p);\n\n\t\t/*\n\t\t * drop the page count elevated by isolate_lru_page()\n\t\t */\n\t\tput_page(p);\n\t\treturn 0;\n\t}\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "delete_from_swap_cache",
          "args": [
            "p"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "delete_from_swap_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "243-254",
          "snippet": "void delete_from_swap_cache(struct page *page)\n{\n\tswp_entry_t entry = { .val = page_private(page) };\n\tstruct address_space *address_space = swap_address_space(entry);\n\n\txa_lock_irq(&address_space->i_pages);\n\t__delete_from_swap_cache(page, entry);\n\txa_unlock_irq(&address_space->i_pages);\n\n\tput_swap_page(page, entry);\n\tpage_ref_sub(page, hpage_nr_pages(page));\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nvoid delete_from_swap_cache(struct page *page)\n{\n\tswp_entry_t entry = { .val = page_private(page) };\n\tstruct address_space *address_space = swap_address_space(entry);\n\n\txa_lock_irq(&address_space->i_pages);\n\t__delete_from_swap_cache(page, entry);\n\txa_unlock_irq(&address_space->i_pages);\n\n\tput_swap_page(page, entry);\n\tpage_ref_sub(page, hpage_nr_pages(page));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int me_swapcache_clean(struct page *p, unsigned long pfn)\n{\n\tdelete_from_swap_cache(p);\n\n\tif (!delete_from_lru_cache(p))\n\t\treturn MF_RECOVERED;\n\telse\n\t\treturn MF_FAILED;\n}"
  },
  {
    "function_name": "me_swapcache_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "753-763",
    "snippet": "static int me_swapcache_dirty(struct page *p, unsigned long pfn)\n{\n\tClearPageDirty(p);\n\t/* Trigger EIO in shmem: */\n\tClearPageUptodate(p);\n\n\tif (!delete_from_lru_cache(p))\n\t\treturn MF_DELAYED;\n\telse\n\t\treturn MF_FAILED;\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "delete_from_lru_cache",
          "args": [
            "p"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "delete_from_lru_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "566-589",
          "snippet": "static int delete_from_lru_cache(struct page *p)\n{\n\tif (!isolate_lru_page(p)) {\n\t\t/*\n\t\t * Clear sensible page flags, so that the buddy system won't\n\t\t * complain when the page is unpoison-and-freed.\n\t\t */\n\t\tClearPageActive(p);\n\t\tClearPageUnevictable(p);\n\n\t\t/*\n\t\t * Poisoned page might never drop its ref count to 0 so we have\n\t\t * to uncharge it manually from its memcg.\n\t\t */\n\t\tmem_cgroup_uncharge(p);\n\n\t\t/*\n\t\t * drop the page count elevated by isolate_lru_page()\n\t\t */\n\t\tput_page(p);\n\t\treturn 0;\n\t}\n\treturn -EIO;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int delete_from_lru_cache(struct page *p)\n{\n\tif (!isolate_lru_page(p)) {\n\t\t/*\n\t\t * Clear sensible page flags, so that the buddy system won't\n\t\t * complain when the page is unpoison-and-freed.\n\t\t */\n\t\tClearPageActive(p);\n\t\tClearPageUnevictable(p);\n\n\t\t/*\n\t\t * Poisoned page might never drop its ref count to 0 so we have\n\t\t * to uncharge it manually from its memcg.\n\t\t */\n\t\tmem_cgroup_uncharge(p);\n\n\t\t/*\n\t\t * drop the page count elevated by isolate_lru_page()\n\t\t */\n\t\tput_page(p);\n\t\treturn 0;\n\t}\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPageUptodate",
          "args": [
            "p"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageDirty",
          "args": [
            "p"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int me_swapcache_dirty(struct page *p, unsigned long pfn)\n{\n\tClearPageDirty(p);\n\t/* Trigger EIO in shmem: */\n\tClearPageUptodate(p);\n\n\tif (!delete_from_lru_cache(p))\n\t\treturn MF_DELAYED;\n\telse\n\t\treturn MF_FAILED;\n}"
  },
  {
    "function_name": "me_pagecache_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "687-732",
    "snippet": "static int me_pagecache_dirty(struct page *p, unsigned long pfn)\n{\n\tstruct address_space *mapping = page_mapping(p);\n\n\tSetPageError(p);\n\t/* TBD: print more information about the file. */\n\tif (mapping) {\n\t\t/*\n\t\t * IO error will be reported by write(), fsync(), etc.\n\t\t * who check the mapping.\n\t\t * This way the application knows that something went\n\t\t * wrong with its dirty file data.\n\t\t *\n\t\t * There's one open issue:\n\t\t *\n\t\t * The EIO will be only reported on the next IO\n\t\t * operation and then cleared through the IO map.\n\t\t * Normally Linux has two mechanisms to pass IO error\n\t\t * first through the AS_EIO flag in the address space\n\t\t * and then through the PageError flag in the page.\n\t\t * Since we drop pages on memory failure handling the\n\t\t * only mechanism open to use is through AS_AIO.\n\t\t *\n\t\t * This has the disadvantage that it gets cleared on\n\t\t * the first operation that returns an error, while\n\t\t * the PageError bit is more sticky and only cleared\n\t\t * when the page is reread or dropped.  If an\n\t\t * application assumes it will always get error on\n\t\t * fsync, but does other operations on the fd before\n\t\t * and the page is dropped between then the error\n\t\t * will not be properly reported.\n\t\t *\n\t\t * This can already happen even without hwpoisoned\n\t\t * pages: first on metadata IO errors (which only\n\t\t * report through AS_EIO) or when the page is dropped\n\t\t * at the wrong time.\n\t\t *\n\t\t * So right now we assume that the application DTRT on\n\t\t * the first EIO, but we're not worse than other parts\n\t\t * of the kernel.\n\t\t */\n\t\tmapping_set_error(mapping, -EIO);\n\t}\n\n\treturn me_pagecache_clean(p, pfn);\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define dirty\t\t(1UL << PG_dirty)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "me_pagecache_clean",
          "args": [
            "p",
            "pfn"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "me_pagecache_clean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "646-680",
          "snippet": "static int me_pagecache_clean(struct page *p, unsigned long pfn)\n{\n\tstruct address_space *mapping;\n\n\tdelete_from_lru_cache(p);\n\n\t/*\n\t * For anonymous pages we're done the only reference left\n\t * should be the one m_f() holds.\n\t */\n\tif (PageAnon(p))\n\t\treturn MF_RECOVERED;\n\n\t/*\n\t * Now truncate the page in the page cache. This is really\n\t * more like a \"temporary hole punch\"\n\t * Don't do this for block devices when someone else\n\t * has a reference, because it could be file system metadata\n\t * and that's not safe to truncate.\n\t */\n\tmapping = page_mapping(p);\n\tif (!mapping) {\n\t\t/*\n\t\t * Page has been teared down in the meanwhile\n\t\t */\n\t\treturn MF_FAILED;\n\t}\n\n\t/*\n\t * Truncation is a bit tricky. Enable it per file system for now.\n\t *\n\t * Open: to take i_mutex or not for this? Right now we don't.\n\t */\n\treturn truncate_error_page(p, pfn, mapping);\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int me_pagecache_clean(struct page *p, unsigned long pfn)\n{\n\tstruct address_space *mapping;\n\n\tdelete_from_lru_cache(p);\n\n\t/*\n\t * For anonymous pages we're done the only reference left\n\t * should be the one m_f() holds.\n\t */\n\tif (PageAnon(p))\n\t\treturn MF_RECOVERED;\n\n\t/*\n\t * Now truncate the page in the page cache. This is really\n\t * more like a \"temporary hole punch\"\n\t * Don't do this for block devices when someone else\n\t * has a reference, because it could be file system metadata\n\t * and that's not safe to truncate.\n\t */\n\tmapping = page_mapping(p);\n\tif (!mapping) {\n\t\t/*\n\t\t * Page has been teared down in the meanwhile\n\t\t */\n\t\treturn MF_FAILED;\n\t}\n\n\t/*\n\t * Truncation is a bit tricky. Enable it per file system for now.\n\t *\n\t * Open: to take i_mutex or not for this? Right now we don't.\n\t */\n\treturn truncate_error_page(p, pfn, mapping);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_set_error",
          "args": [
            "mapping",
            "-EIO"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "p"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "p"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapping_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "528-533",
          "snippet": "struct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define dirty\t\t(1UL << PG_dirty)\n\nstatic int me_pagecache_dirty(struct page *p, unsigned long pfn)\n{\n\tstruct address_space *mapping = page_mapping(p);\n\n\tSetPageError(p);\n\t/* TBD: print more information about the file. */\n\tif (mapping) {\n\t\t/*\n\t\t * IO error will be reported by write(), fsync(), etc.\n\t\t * who check the mapping.\n\t\t * This way the application knows that something went\n\t\t * wrong with its dirty file data.\n\t\t *\n\t\t * There's one open issue:\n\t\t *\n\t\t * The EIO will be only reported on the next IO\n\t\t * operation and then cleared through the IO map.\n\t\t * Normally Linux has two mechanisms to pass IO error\n\t\t * first through the AS_EIO flag in the address space\n\t\t * and then through the PageError flag in the page.\n\t\t * Since we drop pages on memory failure handling the\n\t\t * only mechanism open to use is through AS_AIO.\n\t\t *\n\t\t * This has the disadvantage that it gets cleared on\n\t\t * the first operation that returns an error, while\n\t\t * the PageError bit is more sticky and only cleared\n\t\t * when the page is reread or dropped.  If an\n\t\t * application assumes it will always get error on\n\t\t * fsync, but does other operations on the fd before\n\t\t * and the page is dropped between then the error\n\t\t * will not be properly reported.\n\t\t *\n\t\t * This can already happen even without hwpoisoned\n\t\t * pages: first on metadata IO errors (which only\n\t\t * report through AS_EIO) or when the page is dropped\n\t\t * at the wrong time.\n\t\t *\n\t\t * So right now we assume that the application DTRT on\n\t\t * the first EIO, but we're not worse than other parts\n\t\t * of the kernel.\n\t\t */\n\t\tmapping_set_error(mapping, -EIO);\n\t}\n\n\treturn me_pagecache_clean(p, pfn);\n}"
  },
  {
    "function_name": "me_pagecache_clean",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "646-680",
    "snippet": "static int me_pagecache_clean(struct page *p, unsigned long pfn)\n{\n\tstruct address_space *mapping;\n\n\tdelete_from_lru_cache(p);\n\n\t/*\n\t * For anonymous pages we're done the only reference left\n\t * should be the one m_f() holds.\n\t */\n\tif (PageAnon(p))\n\t\treturn MF_RECOVERED;\n\n\t/*\n\t * Now truncate the page in the page cache. This is really\n\t * more like a \"temporary hole punch\"\n\t * Don't do this for block devices when someone else\n\t * has a reference, because it could be file system metadata\n\t * and that's not safe to truncate.\n\t */\n\tmapping = page_mapping(p);\n\tif (!mapping) {\n\t\t/*\n\t\t * Page has been teared down in the meanwhile\n\t\t */\n\t\treturn MF_FAILED;\n\t}\n\n\t/*\n\t * Truncation is a bit tricky. Enable it per file system for now.\n\t *\n\t * Open: to take i_mutex or not for this? Right now we don't.\n\t */\n\treturn truncate_error_page(p, pfn, mapping);\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "truncate_error_page",
          "args": [
            "p",
            "pfn",
            "mapping"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_error_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "591-622",
          "snippet": "static int truncate_error_page(struct page *p, unsigned long pfn,\n\t\t\t\tstruct address_space *mapping)\n{\n\tint ret = MF_FAILED;\n\n\tif (mapping->a_ops->error_remove_page) {\n\t\tint err = mapping->a_ops->error_remove_page(mapping, p);\n\n\t\tif (err != 0) {\n\t\t\tpr_info(\"Memory failure: %#lx: Failed to punch page: %d\\n\",\n\t\t\t\tpfn, err);\n\t\t} else if (page_has_private(p) &&\n\t\t\t   !try_to_release_page(p, GFP_NOIO)) {\n\t\t\tpr_info(\"Memory failure: %#lx: failed to release buffers\\n\",\n\t\t\t\tpfn);\n\t\t} else {\n\t\t\tret = MF_RECOVERED;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * If the file system doesn't support it just invalidate\n\t\t * This fails on dirty or anything with private pages\n\t\t */\n\t\tif (invalidate_inode_page(p))\n\t\t\tret = MF_RECOVERED;\n\t\telse\n\t\t\tpr_info(\"Memory failure: %#lx: Failed to invalidate\\n\",\n\t\t\t\tpfn);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define dirty\t\t(1UL << PG_dirty)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define dirty\t\t(1UL << PG_dirty)\n\nstatic int truncate_error_page(struct page *p, unsigned long pfn,\n\t\t\t\tstruct address_space *mapping)\n{\n\tint ret = MF_FAILED;\n\n\tif (mapping->a_ops->error_remove_page) {\n\t\tint err = mapping->a_ops->error_remove_page(mapping, p);\n\n\t\tif (err != 0) {\n\t\t\tpr_info(\"Memory failure: %#lx: Failed to punch page: %d\\n\",\n\t\t\t\tpfn, err);\n\t\t} else if (page_has_private(p) &&\n\t\t\t   !try_to_release_page(p, GFP_NOIO)) {\n\t\t\tpr_info(\"Memory failure: %#lx: failed to release buffers\\n\",\n\t\t\t\tpfn);\n\t\t} else {\n\t\t\tret = MF_RECOVERED;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * If the file system doesn't support it just invalidate\n\t\t * This fails on dirty or anything with private pages\n\t\t */\n\t\tif (invalidate_inode_page(p))\n\t\t\tret = MF_RECOVERED;\n\t\telse\n\t\t\tpr_info(\"Memory failure: %#lx: Failed to invalidate\\n\",\n\t\t\t\tpfn);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "p"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapping_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "528-533",
          "snippet": "struct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "p"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delete_from_lru_cache",
          "args": [
            "p"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "delete_from_lru_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "566-589",
          "snippet": "static int delete_from_lru_cache(struct page *p)\n{\n\tif (!isolate_lru_page(p)) {\n\t\t/*\n\t\t * Clear sensible page flags, so that the buddy system won't\n\t\t * complain when the page is unpoison-and-freed.\n\t\t */\n\t\tClearPageActive(p);\n\t\tClearPageUnevictable(p);\n\n\t\t/*\n\t\t * Poisoned page might never drop its ref count to 0 so we have\n\t\t * to uncharge it manually from its memcg.\n\t\t */\n\t\tmem_cgroup_uncharge(p);\n\n\t\t/*\n\t\t * drop the page count elevated by isolate_lru_page()\n\t\t */\n\t\tput_page(p);\n\t\treturn 0;\n\t}\n\treturn -EIO;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int delete_from_lru_cache(struct page *p)\n{\n\tif (!isolate_lru_page(p)) {\n\t\t/*\n\t\t * Clear sensible page flags, so that the buddy system won't\n\t\t * complain when the page is unpoison-and-freed.\n\t\t */\n\t\tClearPageActive(p);\n\t\tClearPageUnevictable(p);\n\n\t\t/*\n\t\t * Poisoned page might never drop its ref count to 0 so we have\n\t\t * to uncharge it manually from its memcg.\n\t\t */\n\t\tmem_cgroup_uncharge(p);\n\n\t\t/*\n\t\t * drop the page count elevated by isolate_lru_page()\n\t\t */\n\t\tput_page(p);\n\t\treturn 0;\n\t}\n\treturn -EIO;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int me_pagecache_clean(struct page *p, unsigned long pfn)\n{\n\tstruct address_space *mapping;\n\n\tdelete_from_lru_cache(p);\n\n\t/*\n\t * For anonymous pages we're done the only reference left\n\t * should be the one m_f() holds.\n\t */\n\tif (PageAnon(p))\n\t\treturn MF_RECOVERED;\n\n\t/*\n\t * Now truncate the page in the page cache. This is really\n\t * more like a \"temporary hole punch\"\n\t * Don't do this for block devices when someone else\n\t * has a reference, because it could be file system metadata\n\t * and that's not safe to truncate.\n\t */\n\tmapping = page_mapping(p);\n\tif (!mapping) {\n\t\t/*\n\t\t * Page has been teared down in the meanwhile\n\t\t */\n\t\treturn MF_FAILED;\n\t}\n\n\t/*\n\t * Truncation is a bit tricky. Enable it per file system for now.\n\t *\n\t * Open: to take i_mutex or not for this? Right now we don't.\n\t */\n\treturn truncate_error_page(p, pfn, mapping);\n}"
  },
  {
    "function_name": "me_unknown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "637-641",
    "snippet": "static int me_unknown(struct page *p, unsigned long pfn)\n{\n\tpr_err(\"Memory failure: %#lx: Unknown page state\\n\", pfn);\n\treturn MF_FAILED;\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Memory failure: %#lx: Unknown page state\\n\"",
            "pfn"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int me_unknown(struct page *p, unsigned long pfn)\n{\n\tpr_err(\"Memory failure: %#lx: Unknown page state\\n\", pfn);\n\treturn MF_FAILED;\n}"
  },
  {
    "function_name": "me_kernel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "629-632",
    "snippet": "static int me_kernel(struct page *p, unsigned long pfn)\n{\n\treturn MF_IGNORED;\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int me_kernel(struct page *p, unsigned long pfn)\n{\n\treturn MF_IGNORED;\n}"
  },
  {
    "function_name": "truncate_error_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "591-622",
    "snippet": "static int truncate_error_page(struct page *p, unsigned long pfn,\n\t\t\t\tstruct address_space *mapping)\n{\n\tint ret = MF_FAILED;\n\n\tif (mapping->a_ops->error_remove_page) {\n\t\tint err = mapping->a_ops->error_remove_page(mapping, p);\n\n\t\tif (err != 0) {\n\t\t\tpr_info(\"Memory failure: %#lx: Failed to punch page: %d\\n\",\n\t\t\t\tpfn, err);\n\t\t} else if (page_has_private(p) &&\n\t\t\t   !try_to_release_page(p, GFP_NOIO)) {\n\t\t\tpr_info(\"Memory failure: %#lx: failed to release buffers\\n\",\n\t\t\t\tpfn);\n\t\t} else {\n\t\t\tret = MF_RECOVERED;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * If the file system doesn't support it just invalidate\n\t\t * This fails on dirty or anything with private pages\n\t\t */\n\t\tif (invalidate_inode_page(p))\n\t\t\tret = MF_RECOVERED;\n\t\telse\n\t\t\tpr_info(\"Memory failure: %#lx: Failed to invalidate\\n\",\n\t\t\t\tpfn);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define dirty\t\t(1UL << PG_dirty)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Memory failure: %#lx: Failed to invalidate\\n\"",
            "pfn"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalidate_inode_page",
          "args": [
            "p"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_inode_pages2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
          "lines": "766-769",
          "snippet": "int invalidate_inode_pages2(struct address_space *mapping)\n{\n\treturn invalidate_inode_pages2_range(mapping, 0, -1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/rmap.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nint invalidate_inode_pages2(struct address_space *mapping)\n{\n\treturn invalidate_inode_pages2_range(mapping, 0, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Memory failure: %#lx: failed to release buffers\\n\"",
            "pfn"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_release_page",
          "args": [
            "p",
            "GFP_NOIO"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_release_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "3319-3330",
          "snippet": "int try_to_release_page(struct page *page, gfp_t gfp_mask)\n{\n\tstruct address_space * const mapping = page->mapping;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping && mapping->a_ops->releasepage)\n\t\treturn mapping->a_ops->releasepage(page, gfp_mask);\n\treturn try_to_free_buffers(page);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint try_to_release_page(struct page *page, gfp_t gfp_mask)\n{\n\tstruct address_space * const mapping = page->mapping;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping && mapping->a_ops->releasepage)\n\t\treturn mapping->a_ops->releasepage(page, gfp_mask);\n\treturn try_to_free_buffers(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_private",
          "args": [
            "p"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Memory failure: %#lx: Failed to punch page: %d\\n\"",
            "pfn",
            "err"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping->a_ops->error_remove_page",
          "args": [
            "mapping",
            "p"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define dirty\t\t(1UL << PG_dirty)\n\nstatic int truncate_error_page(struct page *p, unsigned long pfn,\n\t\t\t\tstruct address_space *mapping)\n{\n\tint ret = MF_FAILED;\n\n\tif (mapping->a_ops->error_remove_page) {\n\t\tint err = mapping->a_ops->error_remove_page(mapping, p);\n\n\t\tif (err != 0) {\n\t\t\tpr_info(\"Memory failure: %#lx: Failed to punch page: %d\\n\",\n\t\t\t\tpfn, err);\n\t\t} else if (page_has_private(p) &&\n\t\t\t   !try_to_release_page(p, GFP_NOIO)) {\n\t\t\tpr_info(\"Memory failure: %#lx: failed to release buffers\\n\",\n\t\t\t\tpfn);\n\t\t} else {\n\t\t\tret = MF_RECOVERED;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * If the file system doesn't support it just invalidate\n\t\t * This fails on dirty or anything with private pages\n\t\t */\n\t\tif (invalidate_inode_page(p))\n\t\t\tret = MF_RECOVERED;\n\t\telse\n\t\t\tpr_info(\"Memory failure: %#lx: Failed to invalidate\\n\",\n\t\t\t\tpfn);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "delete_from_lru_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "566-589",
    "snippet": "static int delete_from_lru_cache(struct page *p)\n{\n\tif (!isolate_lru_page(p)) {\n\t\t/*\n\t\t * Clear sensible page flags, so that the buddy system won't\n\t\t * complain when the page is unpoison-and-freed.\n\t\t */\n\t\tClearPageActive(p);\n\t\tClearPageUnevictable(p);\n\n\t\t/*\n\t\t * Poisoned page might never drop its ref count to 0 so we have\n\t\t * to uncharge it manually from its memcg.\n\t\t */\n\t\tmem_cgroup_uncharge(p);\n\n\t\t/*\n\t\t * drop the page count elevated by isolate_lru_page()\n\t\t */\n\t\tput_page(p);\n\t\treturn 0;\n\t}\n\treturn -EIO;\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "p"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_uncharge",
          "args": [
            "p"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_uncharge_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "6136-6143",
          "snippet": "void mem_cgroup_uncharge_list(struct list_head *page_list)\n{\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\tif (!list_empty(page_list))\n\t\tuncharge_list(page_list);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid mem_cgroup_uncharge_list(struct list_head *page_list)\n{\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\tif (!list_empty(page_list))\n\t\tuncharge_list(page_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPageUnevictable",
          "args": [
            "p"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageActive",
          "args": [
            "p"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isolate_lru_page",
          "args": [
            "p"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "isolate_lru_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1772-1795",
          "snippet": "int isolate_lru_page(struct page *page)\n{\n\tint ret = -EBUSY;\n\n\tVM_BUG_ON_PAGE(!page_count(page), page);\n\tWARN_RATELIMIT(PageTail(page), \"trying to isolate tail page\");\n\n\tif (PageLRU(page)) {\n\t\tstruct zone *zone = page_zone(page);\n\t\tstruct lruvec *lruvec;\n\n\t\tspin_lock_irq(zone_lru_lock(zone));\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\t\tif (PageLRU(page)) {\n\t\t\tint lru = page_lru(page);\n\t\t\tget_page(page);\n\t\t\tClearPageLRU(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, lru);\n\t\t\tret = 0;\n\t\t}\n\t\tspin_unlock_irq(zone_lru_lock(zone));\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint isolate_lru_page(struct page *page)\n{\n\tint ret = -EBUSY;\n\n\tVM_BUG_ON_PAGE(!page_count(page), page);\n\tWARN_RATELIMIT(PageTail(page), \"trying to isolate tail page\");\n\n\tif (PageLRU(page)) {\n\t\tstruct zone *zone = page_zone(page);\n\t\tstruct lruvec *lruvec;\n\n\t\tspin_lock_irq(zone_lru_lock(zone));\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\t\tif (PageLRU(page)) {\n\t\t\tint lru = page_lru(page);\n\t\t\tget_page(page);\n\t\t\tClearPageLRU(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, lru);\n\t\t\tret = 0;\n\t\t}\n\t\tspin_unlock_irq(zone_lru_lock(zone));\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int delete_from_lru_cache(struct page *p)\n{\n\tif (!isolate_lru_page(p)) {\n\t\t/*\n\t\t * Clear sensible page flags, so that the buddy system won't\n\t\t * complain when the page is unpoison-and-freed.\n\t\t */\n\t\tClearPageActive(p);\n\t\tClearPageUnevictable(p);\n\n\t\t/*\n\t\t * Poisoned page might never drop its ref count to 0 so we have\n\t\t * to uncharge it manually from its memcg.\n\t\t */\n\t\tmem_cgroup_uncharge(p);\n\n\t\t/*\n\t\t * drop the page count elevated by isolate_lru_page()\n\t\t */\n\t\tput_page(p);\n\t\treturn 0;\n\t}\n\treturn -EIO;\n}"
  },
  {
    "function_name": "collect_procs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "510-526",
    "snippet": "static void collect_procs(struct page *page, struct list_head *tokill,\n\t\t\t\tint force_early)\n{\n\tstruct to_kill *tk;\n\n\tif (!page->mapping)\n\t\treturn;\n\n\ttk = kmalloc(sizeof(struct to_kill), GFP_NOIO);\n\tif (!tk)\n\t\treturn;\n\tif (PageAnon(page))\n\t\tcollect_procs_anon(page, tokill, &tk, force_early);\n\telse\n\t\tcollect_procs_file(page, tokill, &tk, force_early);\n\tkfree(tk);\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tk"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "collect_procs_file",
          "args": [
            "page",
            "tokill",
            "&tk",
            "force_early"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "collect_procs_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "472-502",
          "snippet": "static void collect_procs_file(struct page *page, struct list_head *to_kill,\n\t\t\t      struct to_kill **tkc, int force_early)\n{\n\tstruct vm_area_struct *vma;\n\tstruct task_struct *tsk;\n\tstruct address_space *mapping = page->mapping;\n\n\ti_mmap_lock_read(mapping);\n\tread_lock(&tasklist_lock);\n\tfor_each_process(tsk) {\n\t\tpgoff_t pgoff = page_to_pgoff(page);\n\t\tstruct task_struct *t = task_early_kill(tsk, force_early);\n\n\t\tif (!t)\n\t\t\tcontinue;\n\t\tvma_interval_tree_foreach(vma, &mapping->i_mmap, pgoff,\n\t\t\t\t      pgoff) {\n\t\t\t/*\n\t\t\t * Send early kill signal to tasks where a vma covers\n\t\t\t * the page but the corrupted page is not necessarily\n\t\t\t * mapped it in its pte.\n\t\t\t * Assume applications who requested early kill want\n\t\t\t * to be informed of all such data corruptions.\n\t\t\t */\n\t\t\tif (vma->vm_mm == t->mm)\n\t\t\t\tadd_to_kill(t, page, vma, to_kill, tkc);\n\t\t}\n\t}\n\tread_unlock(&tasklist_lock);\n\ti_mmap_unlock_read(mapping);\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic void collect_procs_file(struct page *page, struct list_head *to_kill,\n\t\t\t      struct to_kill **tkc, int force_early)\n{\n\tstruct vm_area_struct *vma;\n\tstruct task_struct *tsk;\n\tstruct address_space *mapping = page->mapping;\n\n\ti_mmap_lock_read(mapping);\n\tread_lock(&tasklist_lock);\n\tfor_each_process(tsk) {\n\t\tpgoff_t pgoff = page_to_pgoff(page);\n\t\tstruct task_struct *t = task_early_kill(tsk, force_early);\n\n\t\tif (!t)\n\t\t\tcontinue;\n\t\tvma_interval_tree_foreach(vma, &mapping->i_mmap, pgoff,\n\t\t\t\t      pgoff) {\n\t\t\t/*\n\t\t\t * Send early kill signal to tasks where a vma covers\n\t\t\t * the page but the corrupted page is not necessarily\n\t\t\t * mapped it in its pte.\n\t\t\t * Assume applications who requested early kill want\n\t\t\t * to be informed of all such data corruptions.\n\t\t\t */\n\t\t\tif (vma->vm_mm == t->mm)\n\t\t\t\tadd_to_kill(t, page, vma, to_kill, tkc);\n\t\t}\n\t}\n\tread_unlock(&tasklist_lock);\n\ti_mmap_unlock_read(mapping);\n}"
        }
      },
      {
        "call_info": {
          "callee": "collect_procs_anon",
          "args": [
            "page",
            "tokill",
            "&tk",
            "force_early"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "collect_procs_anon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "436-467",
          "snippet": "static void collect_procs_anon(struct page *page, struct list_head *to_kill,\n\t\t\t      struct to_kill **tkc, int force_early)\n{\n\tstruct vm_area_struct *vma;\n\tstruct task_struct *tsk;\n\tstruct anon_vma *av;\n\tpgoff_t pgoff;\n\n\tav = page_lock_anon_vma_read(page);\n\tif (av == NULL)\t/* Not actually mapped anymore */\n\t\treturn;\n\n\tpgoff = page_to_pgoff(page);\n\tread_lock(&tasklist_lock);\n\tfor_each_process (tsk) {\n\t\tstruct anon_vma_chain *vmac;\n\t\tstruct task_struct *t = task_early_kill(tsk, force_early);\n\n\t\tif (!t)\n\t\t\tcontinue;\n\t\tanon_vma_interval_tree_foreach(vmac, &av->rb_root,\n\t\t\t\t\t       pgoff, pgoff) {\n\t\t\tvma = vmac->vma;\n\t\t\tif (!page_mapped_in_vma(page, vma))\n\t\t\t\tcontinue;\n\t\t\tif (vma->vm_mm == t->mm)\n\t\t\t\tadd_to_kill(t, page, vma, to_kill, tkc);\n\t\t}\n\t}\n\tread_unlock(&tasklist_lock);\n\tpage_unlock_anon_vma_read(av);\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic void collect_procs_anon(struct page *page, struct list_head *to_kill,\n\t\t\t      struct to_kill **tkc, int force_early)\n{\n\tstruct vm_area_struct *vma;\n\tstruct task_struct *tsk;\n\tstruct anon_vma *av;\n\tpgoff_t pgoff;\n\n\tav = page_lock_anon_vma_read(page);\n\tif (av == NULL)\t/* Not actually mapped anymore */\n\t\treturn;\n\n\tpgoff = page_to_pgoff(page);\n\tread_lock(&tasklist_lock);\n\tfor_each_process (tsk) {\n\t\tstruct anon_vma_chain *vmac;\n\t\tstruct task_struct *t = task_early_kill(tsk, force_early);\n\n\t\tif (!t)\n\t\t\tcontinue;\n\t\tanon_vma_interval_tree_foreach(vmac, &av->rb_root,\n\t\t\t\t\t       pgoff, pgoff) {\n\t\t\tvma = vmac->vma;\n\t\t\tif (!page_mapped_in_vma(page, vma))\n\t\t\t\tcontinue;\n\t\t\tif (vma->vm_mm == t->mm)\n\t\t\t\tadd_to_kill(t, page, vma, to_kill, tkc);\n\t\t}\n\t}\n\tread_unlock(&tasklist_lock);\n\tpage_unlock_anon_vma_read(av);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct to_kill)",
            "GFP_NOIO"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "__kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3729-3732",
          "snippet": "void *__kmalloc(size_t size, gfp_t flags)\n{\n\treturn __do_kmalloc(size, flags, _RET_IP_);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nvoid *__kmalloc(size_t size, gfp_t flags)\n{\n\treturn __do_kmalloc(size, flags, _RET_IP_);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic void collect_procs(struct page *page, struct list_head *tokill,\n\t\t\t\tint force_early)\n{\n\tstruct to_kill *tk;\n\n\tif (!page->mapping)\n\t\treturn;\n\n\ttk = kmalloc(sizeof(struct to_kill), GFP_NOIO);\n\tif (!tk)\n\t\treturn;\n\tif (PageAnon(page))\n\t\tcollect_procs_anon(page, tokill, &tk, force_early);\n\telse\n\t\tcollect_procs_file(page, tokill, &tk, force_early);\n\tkfree(tk);\n}"
  },
  {
    "function_name": "collect_procs_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "472-502",
    "snippet": "static void collect_procs_file(struct page *page, struct list_head *to_kill,\n\t\t\t      struct to_kill **tkc, int force_early)\n{\n\tstruct vm_area_struct *vma;\n\tstruct task_struct *tsk;\n\tstruct address_space *mapping = page->mapping;\n\n\ti_mmap_lock_read(mapping);\n\tread_lock(&tasklist_lock);\n\tfor_each_process(tsk) {\n\t\tpgoff_t pgoff = page_to_pgoff(page);\n\t\tstruct task_struct *t = task_early_kill(tsk, force_early);\n\n\t\tif (!t)\n\t\t\tcontinue;\n\t\tvma_interval_tree_foreach(vma, &mapping->i_mmap, pgoff,\n\t\t\t\t      pgoff) {\n\t\t\t/*\n\t\t\t * Send early kill signal to tasks where a vma covers\n\t\t\t * the page but the corrupted page is not necessarily\n\t\t\t * mapped it in its pte.\n\t\t\t * Assume applications who requested early kill want\n\t\t\t * to be informed of all such data corruptions.\n\t\t\t */\n\t\t\tif (vma->vm_mm == t->mm)\n\t\t\t\tadd_to_kill(t, page, vma, to_kill, tkc);\n\t\t}\n\t}\n\tread_unlock(&tasklist_lock);\n\ti_mmap_unlock_read(mapping);\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i_mmap_unlock_read",
          "args": [
            "mapping"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "1859-1862",
          "snippet": "static void migrate_read_unlock(struct zspage *zspage)\n{\n\tread_unlock(&zspage->lock);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void migrate_read_unlock(struct zspage *zspage)\n{\n\tread_unlock(&zspage->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_to_kill",
          "args": [
            "t",
            "page",
            "vma",
            "to_kill",
            "tkc"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "add_to_kill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "312-350",
          "snippet": "static void add_to_kill(struct task_struct *tsk, struct page *p,\n\t\t       struct vm_area_struct *vma,\n\t\t       struct list_head *to_kill,\n\t\t       struct to_kill **tkc)\n{\n\tstruct to_kill *tk;\n\n\tif (*tkc) {\n\t\ttk = *tkc;\n\t\t*tkc = NULL;\n\t} else {\n\t\ttk = kmalloc(sizeof(struct to_kill), GFP_ATOMIC);\n\t\tif (!tk) {\n\t\t\tpr_err(\"Memory failure: Out of memory while machine check handling\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\ttk->addr = page_address_in_vma(p, vma);\n\ttk->addr_valid = 1;\n\tif (is_zone_device_page(p))\n\t\ttk->size_shift = dev_pagemap_mapping_shift(p, vma);\n\telse\n\t\ttk->size_shift = compound_order(compound_head(p)) + PAGE_SHIFT;\n\n\t/*\n\t * In theory we don't have to kill when the page was\n\t * munmaped. But it could be also a mremap. Since that's\n\t * likely very rare kill anyways just out of paranoia, but use\n\t * a SIGKILL because the error is not contained anymore.\n\t */\n\tif (tk->addr == -EFAULT || tk->size_shift == 0) {\n\t\tpr_info(\"Memory failure: Unable to find user space address %lx in %s\\n\",\n\t\t\tpage_to_pfn(p), tsk->comm);\n\t\ttk->addr_valid = 0;\n\t}\n\tget_task_struct(tsk);\n\ttk->tsk = tsk;\n\tlist_add_tail(&tk->nd, to_kill);\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic void add_to_kill(struct task_struct *tsk, struct page *p,\n\t\t       struct vm_area_struct *vma,\n\t\t       struct list_head *to_kill,\n\t\t       struct to_kill **tkc)\n{\n\tstruct to_kill *tk;\n\n\tif (*tkc) {\n\t\ttk = *tkc;\n\t\t*tkc = NULL;\n\t} else {\n\t\ttk = kmalloc(sizeof(struct to_kill), GFP_ATOMIC);\n\t\tif (!tk) {\n\t\t\tpr_err(\"Memory failure: Out of memory while machine check handling\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\ttk->addr = page_address_in_vma(p, vma);\n\ttk->addr_valid = 1;\n\tif (is_zone_device_page(p))\n\t\ttk->size_shift = dev_pagemap_mapping_shift(p, vma);\n\telse\n\t\ttk->size_shift = compound_order(compound_head(p)) + PAGE_SHIFT;\n\n\t/*\n\t * In theory we don't have to kill when the page was\n\t * munmaped. But it could be also a mremap. Since that's\n\t * likely very rare kill anyways just out of paranoia, but use\n\t * a SIGKILL because the error is not contained anymore.\n\t */\n\tif (tk->addr == -EFAULT || tk->size_shift == 0) {\n\t\tpr_info(\"Memory failure: Unable to find user space address %lx in %s\\n\",\n\t\t\tpage_to_pfn(p), tsk->comm);\n\t\ttk->addr_valid = 0;\n\t}\n\tget_task_struct(tsk);\n\ttk->tsk = tsk;\n\tlist_add_tail(&tk->nd, to_kill);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_interval_tree_foreach",
          "args": [
            "vma",
            "&mapping->i_mmap",
            "pgoff",
            "pgoff"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_early_kill",
          "args": [
            "tsk",
            "force_early"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "task_early_kill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "417-431",
          "snippet": "static struct task_struct *task_early_kill(struct task_struct *tsk,\n\t\t\t\t\t   int force_early)\n{\n\tstruct task_struct *t;\n\tif (!tsk->mm)\n\t\treturn NULL;\n\tif (force_early)\n\t\treturn tsk;\n\tt = find_early_kill_thread(tsk);\n\tif (t)\n\t\treturn t;\n\tif (sysctl_memory_failure_early_kill)\n\t\treturn tsk;\n\treturn NULL;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int sysctl_memory_failure_early_kill"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint sysctl_memory_failure_early_kill;\n\nstatic struct task_struct *task_early_kill(struct task_struct *tsk,\n\t\t\t\t\t   int force_early)\n{\n\tstruct task_struct *t;\n\tif (!tsk->mm)\n\t\treturn NULL;\n\tif (force_early)\n\t\treturn tsk;\n\tt = find_early_kill_thread(tsk);\n\tif (t)\n\t\treturn t;\n\tif (sysctl_memory_failure_early_kill)\n\t\treturn tsk;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_pgoff",
          "args": [
            "page"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "1854-1857",
          "snippet": "static void migrate_read_lock(struct zspage *zspage)\n{\n\tread_lock(&zspage->lock);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void migrate_read_lock(struct zspage *zspage)\n{\n\tread_lock(&zspage->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_mmap_lock_read",
          "args": [
            "mapping"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic void collect_procs_file(struct page *page, struct list_head *to_kill,\n\t\t\t      struct to_kill **tkc, int force_early)\n{\n\tstruct vm_area_struct *vma;\n\tstruct task_struct *tsk;\n\tstruct address_space *mapping = page->mapping;\n\n\ti_mmap_lock_read(mapping);\n\tread_lock(&tasklist_lock);\n\tfor_each_process(tsk) {\n\t\tpgoff_t pgoff = page_to_pgoff(page);\n\t\tstruct task_struct *t = task_early_kill(tsk, force_early);\n\n\t\tif (!t)\n\t\t\tcontinue;\n\t\tvma_interval_tree_foreach(vma, &mapping->i_mmap, pgoff,\n\t\t\t\t      pgoff) {\n\t\t\t/*\n\t\t\t * Send early kill signal to tasks where a vma covers\n\t\t\t * the page but the corrupted page is not necessarily\n\t\t\t * mapped it in its pte.\n\t\t\t * Assume applications who requested early kill want\n\t\t\t * to be informed of all such data corruptions.\n\t\t\t */\n\t\t\tif (vma->vm_mm == t->mm)\n\t\t\t\tadd_to_kill(t, page, vma, to_kill, tkc);\n\t\t}\n\t}\n\tread_unlock(&tasklist_lock);\n\ti_mmap_unlock_read(mapping);\n}"
  },
  {
    "function_name": "collect_procs_anon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "436-467",
    "snippet": "static void collect_procs_anon(struct page *page, struct list_head *to_kill,\n\t\t\t      struct to_kill **tkc, int force_early)\n{\n\tstruct vm_area_struct *vma;\n\tstruct task_struct *tsk;\n\tstruct anon_vma *av;\n\tpgoff_t pgoff;\n\n\tav = page_lock_anon_vma_read(page);\n\tif (av == NULL)\t/* Not actually mapped anymore */\n\t\treturn;\n\n\tpgoff = page_to_pgoff(page);\n\tread_lock(&tasklist_lock);\n\tfor_each_process (tsk) {\n\t\tstruct anon_vma_chain *vmac;\n\t\tstruct task_struct *t = task_early_kill(tsk, force_early);\n\n\t\tif (!t)\n\t\t\tcontinue;\n\t\tanon_vma_interval_tree_foreach(vmac, &av->rb_root,\n\t\t\t\t\t       pgoff, pgoff) {\n\t\t\tvma = vmac->vma;\n\t\t\tif (!page_mapped_in_vma(page, vma))\n\t\t\t\tcontinue;\n\t\t\tif (vma->vm_mm == t->mm)\n\t\t\t\tadd_to_kill(t, page, vma, to_kill, tkc);\n\t\t}\n\t}\n\tread_unlock(&tasklist_lock);\n\tpage_unlock_anon_vma_read(av);\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_unlock_anon_vma_read",
          "args": [
            "av"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "page_unlock_anon_vma_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "569-572",
          "snippet": "void page_unlock_anon_vma_read(struct anon_vma *anon_vma)\n{\n\tanon_vma_unlock_read(anon_vma);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid page_unlock_anon_vma_read(struct anon_vma *anon_vma)\n{\n\tanon_vma_unlock_read(anon_vma);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "1859-1862",
          "snippet": "static void migrate_read_unlock(struct zspage *zspage)\n{\n\tread_unlock(&zspage->lock);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void migrate_read_unlock(struct zspage *zspage)\n{\n\tread_unlock(&zspage->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_to_kill",
          "args": [
            "t",
            "page",
            "vma",
            "to_kill",
            "tkc"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "add_to_kill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "312-350",
          "snippet": "static void add_to_kill(struct task_struct *tsk, struct page *p,\n\t\t       struct vm_area_struct *vma,\n\t\t       struct list_head *to_kill,\n\t\t       struct to_kill **tkc)\n{\n\tstruct to_kill *tk;\n\n\tif (*tkc) {\n\t\ttk = *tkc;\n\t\t*tkc = NULL;\n\t} else {\n\t\ttk = kmalloc(sizeof(struct to_kill), GFP_ATOMIC);\n\t\tif (!tk) {\n\t\t\tpr_err(\"Memory failure: Out of memory while machine check handling\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\ttk->addr = page_address_in_vma(p, vma);\n\ttk->addr_valid = 1;\n\tif (is_zone_device_page(p))\n\t\ttk->size_shift = dev_pagemap_mapping_shift(p, vma);\n\telse\n\t\ttk->size_shift = compound_order(compound_head(p)) + PAGE_SHIFT;\n\n\t/*\n\t * In theory we don't have to kill when the page was\n\t * munmaped. But it could be also a mremap. Since that's\n\t * likely very rare kill anyways just out of paranoia, but use\n\t * a SIGKILL because the error is not contained anymore.\n\t */\n\tif (tk->addr == -EFAULT || tk->size_shift == 0) {\n\t\tpr_info(\"Memory failure: Unable to find user space address %lx in %s\\n\",\n\t\t\tpage_to_pfn(p), tsk->comm);\n\t\ttk->addr_valid = 0;\n\t}\n\tget_task_struct(tsk);\n\ttk->tsk = tsk;\n\tlist_add_tail(&tk->nd, to_kill);\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic void add_to_kill(struct task_struct *tsk, struct page *p,\n\t\t       struct vm_area_struct *vma,\n\t\t       struct list_head *to_kill,\n\t\t       struct to_kill **tkc)\n{\n\tstruct to_kill *tk;\n\n\tif (*tkc) {\n\t\ttk = *tkc;\n\t\t*tkc = NULL;\n\t} else {\n\t\ttk = kmalloc(sizeof(struct to_kill), GFP_ATOMIC);\n\t\tif (!tk) {\n\t\t\tpr_err(\"Memory failure: Out of memory while machine check handling\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\ttk->addr = page_address_in_vma(p, vma);\n\ttk->addr_valid = 1;\n\tif (is_zone_device_page(p))\n\t\ttk->size_shift = dev_pagemap_mapping_shift(p, vma);\n\telse\n\t\ttk->size_shift = compound_order(compound_head(p)) + PAGE_SHIFT;\n\n\t/*\n\t * In theory we don't have to kill when the page was\n\t * munmaped. But it could be also a mremap. Since that's\n\t * likely very rare kill anyways just out of paranoia, but use\n\t * a SIGKILL because the error is not contained anymore.\n\t */\n\tif (tk->addr == -EFAULT || tk->size_shift == 0) {\n\t\tpr_info(\"Memory failure: Unable to find user space address %lx in %s\\n\",\n\t\t\tpage_to_pfn(p), tsk->comm);\n\t\ttk->addr_valid = 0;\n\t}\n\tget_task_struct(tsk);\n\ttk->tsk = tsk;\n\tlist_add_tail(&tk->nd, to_kill);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_mapped_in_vma",
          "args": [
            "page",
            "vma"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapped_in_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_vma_mapped.c",
          "lines": "258-277",
          "snippet": "int page_mapped_in_vma(struct page *page, struct vm_area_struct *vma)\n{\n\tstruct page_vma_mapped_walk pvmw = {\n\t\t.page = page,\n\t\t.vma = vma,\n\t\t.flags = PVMW_SYNC,\n\t};\n\tunsigned long start, end;\n\n\tstart = __vma_address(page, vma);\n\tend = start + PAGE_SIZE * (hpage_nr_pages(page) - 1);\n\n\tif (unlikely(end < vma->vm_start || start >= vma->vm_end))\n\t\treturn 0;\n\tpvmw.address = max(start, vma->vm_start);\n\tif (!page_vma_mapped_walk(&pvmw))\n\t\treturn 0;\n\tpage_vma_mapped_walk_done(&pvmw);\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/hugetlb.h>\n#include <linux/rmap.h>\n#include <linux/mm.h>\n\nint page_mapped_in_vma(struct page *page, struct vm_area_struct *vma)\n{\n\tstruct page_vma_mapped_walk pvmw = {\n\t\t.page = page,\n\t\t.vma = vma,\n\t\t.flags = PVMW_SYNC,\n\t};\n\tunsigned long start, end;\n\n\tstart = __vma_address(page, vma);\n\tend = start + PAGE_SIZE * (hpage_nr_pages(page) - 1);\n\n\tif (unlikely(end < vma->vm_start || start >= vma->vm_end))\n\t\treturn 0;\n\tpvmw.address = max(start, vma->vm_start);\n\tif (!page_vma_mapped_walk(&pvmw))\n\t\treturn 0;\n\tpage_vma_mapped_walk_done(&pvmw);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "anon_vma_interval_tree_foreach",
          "args": [
            "vmac",
            "&av->rb_root",
            "pgoff",
            "pgoff"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_early_kill",
          "args": [
            "tsk",
            "force_early"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "task_early_kill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "417-431",
          "snippet": "static struct task_struct *task_early_kill(struct task_struct *tsk,\n\t\t\t\t\t   int force_early)\n{\n\tstruct task_struct *t;\n\tif (!tsk->mm)\n\t\treturn NULL;\n\tif (force_early)\n\t\treturn tsk;\n\tt = find_early_kill_thread(tsk);\n\tif (t)\n\t\treturn t;\n\tif (sysctl_memory_failure_early_kill)\n\t\treturn tsk;\n\treturn NULL;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int sysctl_memory_failure_early_kill"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint sysctl_memory_failure_early_kill;\n\nstatic struct task_struct *task_early_kill(struct task_struct *tsk,\n\t\t\t\t\t   int force_early)\n{\n\tstruct task_struct *t;\n\tif (!tsk->mm)\n\t\treturn NULL;\n\tif (force_early)\n\t\treturn tsk;\n\tt = find_early_kill_thread(tsk);\n\tif (t)\n\t\treturn t;\n\tif (sysctl_memory_failure_early_kill)\n\t\treturn tsk;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "1854-1857",
          "snippet": "static void migrate_read_lock(struct zspage *zspage)\n{\n\tread_lock(&zspage->lock);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void migrate_read_lock(struct zspage *zspage)\n{\n\tread_lock(&zspage->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_pgoff",
          "args": [
            "page"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_lock_anon_vma_read",
          "args": [
            "page"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "page_lock_anon_vma_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "507-567",
          "snippet": "struct anon_vma *page_lock_anon_vma_read(struct page *page)\n{\n\tstruct anon_vma *anon_vma = NULL;\n\tstruct anon_vma *root_anon_vma;\n\tunsigned long anon_mapping;\n\n\trcu_read_lock();\n\tanon_mapping = (unsigned long)READ_ONCE(page->mapping);\n\tif ((anon_mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)\n\t\tgoto out;\n\tif (!page_mapped(page))\n\t\tgoto out;\n\n\tanon_vma = (struct anon_vma *) (anon_mapping - PAGE_MAPPING_ANON);\n\troot_anon_vma = READ_ONCE(anon_vma->root);\n\tif (down_read_trylock(&root_anon_vma->rwsem)) {\n\t\t/*\n\t\t * If the page is still mapped, then this anon_vma is still\n\t\t * its anon_vma, and holding the mutex ensures that it will\n\t\t * not go away, see anon_vma_free().\n\t\t */\n\t\tif (!page_mapped(page)) {\n\t\t\tup_read(&root_anon_vma->rwsem);\n\t\t\tanon_vma = NULL;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* trylock failed, we got to sleep */\n\tif (!atomic_inc_not_zero(&anon_vma->refcount)) {\n\t\tanon_vma = NULL;\n\t\tgoto out;\n\t}\n\n\tif (!page_mapped(page)) {\n\t\trcu_read_unlock();\n\t\tput_anon_vma(anon_vma);\n\t\treturn NULL;\n\t}\n\n\t/* we pinned the anon_vma, its safe to sleep */\n\trcu_read_unlock();\n\tanon_vma_lock_read(anon_vma);\n\n\tif (atomic_dec_and_test(&anon_vma->refcount)) {\n\t\t/*\n\t\t * Oops, we held the last refcount, release the lock\n\t\t * and bail -- can't simply use put_anon_vma() because\n\t\t * we'll deadlock on the anon_vma_lock_write() recursion.\n\t\t */\n\t\tanon_vma_unlock_read(anon_vma);\n\t\t__put_anon_vma(anon_vma);\n\t\tanon_vma = NULL;\n\t}\n\n\treturn anon_vma;\n\nout:\n\trcu_read_unlock();\n\treturn anon_vma;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstruct anon_vma *page_lock_anon_vma_read(struct page *page)\n{\n\tstruct anon_vma *anon_vma = NULL;\n\tstruct anon_vma *root_anon_vma;\n\tunsigned long anon_mapping;\n\n\trcu_read_lock();\n\tanon_mapping = (unsigned long)READ_ONCE(page->mapping);\n\tif ((anon_mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)\n\t\tgoto out;\n\tif (!page_mapped(page))\n\t\tgoto out;\n\n\tanon_vma = (struct anon_vma *) (anon_mapping - PAGE_MAPPING_ANON);\n\troot_anon_vma = READ_ONCE(anon_vma->root);\n\tif (down_read_trylock(&root_anon_vma->rwsem)) {\n\t\t/*\n\t\t * If the page is still mapped, then this anon_vma is still\n\t\t * its anon_vma, and holding the mutex ensures that it will\n\t\t * not go away, see anon_vma_free().\n\t\t */\n\t\tif (!page_mapped(page)) {\n\t\t\tup_read(&root_anon_vma->rwsem);\n\t\t\tanon_vma = NULL;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* trylock failed, we got to sleep */\n\tif (!atomic_inc_not_zero(&anon_vma->refcount)) {\n\t\tanon_vma = NULL;\n\t\tgoto out;\n\t}\n\n\tif (!page_mapped(page)) {\n\t\trcu_read_unlock();\n\t\tput_anon_vma(anon_vma);\n\t\treturn NULL;\n\t}\n\n\t/* we pinned the anon_vma, its safe to sleep */\n\trcu_read_unlock();\n\tanon_vma_lock_read(anon_vma);\n\n\tif (atomic_dec_and_test(&anon_vma->refcount)) {\n\t\t/*\n\t\t * Oops, we held the last refcount, release the lock\n\t\t * and bail -- can't simply use put_anon_vma() because\n\t\t * we'll deadlock on the anon_vma_lock_write() recursion.\n\t\t */\n\t\tanon_vma_unlock_read(anon_vma);\n\t\t__put_anon_vma(anon_vma);\n\t\tanon_vma = NULL;\n\t}\n\n\treturn anon_vma;\n\nout:\n\trcu_read_unlock();\n\treturn anon_vma;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic void collect_procs_anon(struct page *page, struct list_head *to_kill,\n\t\t\t      struct to_kill **tkc, int force_early)\n{\n\tstruct vm_area_struct *vma;\n\tstruct task_struct *tsk;\n\tstruct anon_vma *av;\n\tpgoff_t pgoff;\n\n\tav = page_lock_anon_vma_read(page);\n\tif (av == NULL)\t/* Not actually mapped anymore */\n\t\treturn;\n\n\tpgoff = page_to_pgoff(page);\n\tread_lock(&tasklist_lock);\n\tfor_each_process (tsk) {\n\t\tstruct anon_vma_chain *vmac;\n\t\tstruct task_struct *t = task_early_kill(tsk, force_early);\n\n\t\tif (!t)\n\t\t\tcontinue;\n\t\tanon_vma_interval_tree_foreach(vmac, &av->rb_root,\n\t\t\t\t\t       pgoff, pgoff) {\n\t\t\tvma = vmac->vma;\n\t\t\tif (!page_mapped_in_vma(page, vma))\n\t\t\t\tcontinue;\n\t\t\tif (vma->vm_mm == t->mm)\n\t\t\t\tadd_to_kill(t, page, vma, to_kill, tkc);\n\t\t}\n\t}\n\tread_unlock(&tasklist_lock);\n\tpage_unlock_anon_vma_read(av);\n}"
  },
  {
    "function_name": "task_early_kill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "417-431",
    "snippet": "static struct task_struct *task_early_kill(struct task_struct *tsk,\n\t\t\t\t\t   int force_early)\n{\n\tstruct task_struct *t;\n\tif (!tsk->mm)\n\t\treturn NULL;\n\tif (force_early)\n\t\treturn tsk;\n\tt = find_early_kill_thread(tsk);\n\tif (t)\n\t\treturn t;\n\tif (sysctl_memory_failure_early_kill)\n\t\treturn tsk;\n\treturn NULL;\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int sysctl_memory_failure_early_kill"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_early_kill_thread",
          "args": [
            "tsk"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "find_early_kill_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "401-409",
          "snippet": "static struct task_struct *find_early_kill_thread(struct task_struct *tsk)\n{\n\tstruct task_struct *t;\n\n\tfor_each_thread(tsk, t)\n\t\tif ((t->flags & PF_MCE_PROCESS) && (t->flags & PF_MCE_EARLY))\n\t\t\treturn t;\n\treturn NULL;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic struct task_struct *find_early_kill_thread(struct task_struct *tsk)\n{\n\tstruct task_struct *t;\n\n\tfor_each_thread(tsk, t)\n\t\tif ((t->flags & PF_MCE_PROCESS) && (t->flags & PF_MCE_EARLY))\n\t\t\treturn t;\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint sysctl_memory_failure_early_kill;\n\nstatic struct task_struct *task_early_kill(struct task_struct *tsk,\n\t\t\t\t\t   int force_early)\n{\n\tstruct task_struct *t;\n\tif (!tsk->mm)\n\t\treturn NULL;\n\tif (force_early)\n\t\treturn tsk;\n\tt = find_early_kill_thread(tsk);\n\tif (t)\n\t\treturn t;\n\tif (sysctl_memory_failure_early_kill)\n\t\treturn tsk;\n\treturn NULL;\n}"
  },
  {
    "function_name": "find_early_kill_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "401-409",
    "snippet": "static struct task_struct *find_early_kill_thread(struct task_struct *tsk)\n{\n\tstruct task_struct *t;\n\n\tfor_each_thread(tsk, t)\n\t\tif ((t->flags & PF_MCE_PROCESS) && (t->flags & PF_MCE_EARLY))\n\t\t\treturn t;\n\treturn NULL;\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "for_each_thread",
          "args": [
            "tsk",
            "t"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic struct task_struct *find_early_kill_thread(struct task_struct *tsk)\n{\n\tstruct task_struct *t;\n\n\tfor_each_thread(tsk, t)\n\t\tif ((t->flags & PF_MCE_PROCESS) && (t->flags & PF_MCE_EARLY))\n\t\t\treturn t;\n\treturn NULL;\n}"
  },
  {
    "function_name": "kill_procs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "360-391",
    "snippet": "static void kill_procs(struct list_head *to_kill, int forcekill, bool fail,\n\t\tunsigned long pfn, int flags)\n{\n\tstruct to_kill *tk, *next;\n\n\tlist_for_each_entry_safe (tk, next, to_kill, nd) {\n\t\tif (forcekill) {\n\t\t\t/*\n\t\t\t * In case something went wrong with munmapping\n\t\t\t * make sure the process doesn't catch the\n\t\t\t * signal and then access the memory. Just kill it.\n\t\t\t */\n\t\t\tif (fail || tk->addr_valid == 0) {\n\t\t\t\tpr_err(\"Memory failure: %#lx: forcibly killing %s:%d because of failure to unmap corrupted page\\n\",\n\t\t\t\t       pfn, tk->tsk->comm, tk->tsk->pid);\n\t\t\t\tforce_sig(SIGKILL, tk->tsk);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * In theory the process could have mapped\n\t\t\t * something else on the address in-between. We could\n\t\t\t * check for that, but we need to tell the\n\t\t\t * process anyways.\n\t\t\t */\n\t\t\telse if (kill_proc(tk, pfn, flags) < 0)\n\t\t\t\tpr_err(\"Memory failure: %#lx: Cannot send advisory machine check signal to %s:%d\\n\",\n\t\t\t\t       pfn, tk->tsk->comm, tk->tsk->pid);\n\t\t}\n\t\tput_task_struct(tk->tsk);\n\t\tkfree(tk);\n\t}\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tk"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "tk->tsk"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Memory failure: %#lx: Cannot send advisory machine check signal to %s:%d\\n\"",
            "pfn",
            "tk->tsk->comm",
            "tk->tsk->pid"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill_proc",
          "args": [
            "tk",
            "pfn",
            "flags"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "kill_proc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "213-239",
          "snippet": "static int kill_proc(struct to_kill *tk, unsigned long pfn, int flags)\n{\n\tstruct task_struct *t = tk->tsk;\n\tshort addr_lsb = tk->size_shift;\n\tint ret;\n\n\tpr_err(\"Memory failure: %#lx: Killing %s:%d due to hardware memory corruption\\n\",\n\t\tpfn, t->comm, t->pid);\n\n\tif ((flags & MF_ACTION_REQUIRED) && t->mm == current->mm) {\n\t\tret = force_sig_mceerr(BUS_MCEERR_AR, (void __user *)tk->addr,\n\t\t\t\t       addr_lsb, current);\n\t} else {\n\t\t/*\n\t\t * Don't use force here, it's convenient if the signal\n\t\t * can be temporarily blocked.\n\t\t * This could cause a loop when the user sets SIGBUS\n\t\t * to SIG_IGN, but hopefully no one will do that?\n\t\t */\n\t\tret = send_sig_mceerr(BUS_MCEERR_AO, (void __user *)tk->addr,\n\t\t\t\t      addr_lsb, t);  /* synchronous? */\n\t}\n\tif (ret < 0)\n\t\tpr_info(\"Memory failure: Error sending signal to %s:%d: %d\\n\",\n\t\t\tt->comm, t->pid, ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int kill_proc(struct to_kill *tk, unsigned long pfn, int flags)\n{\n\tstruct task_struct *t = tk->tsk;\n\tshort addr_lsb = tk->size_shift;\n\tint ret;\n\n\tpr_err(\"Memory failure: %#lx: Killing %s:%d due to hardware memory corruption\\n\",\n\t\tpfn, t->comm, t->pid);\n\n\tif ((flags & MF_ACTION_REQUIRED) && t->mm == current->mm) {\n\t\tret = force_sig_mceerr(BUS_MCEERR_AR, (void __user *)tk->addr,\n\t\t\t\t       addr_lsb, current);\n\t} else {\n\t\t/*\n\t\t * Don't use force here, it's convenient if the signal\n\t\t * can be temporarily blocked.\n\t\t * This could cause a loop when the user sets SIGBUS\n\t\t * to SIG_IGN, but hopefully no one will do that?\n\t\t */\n\t\tret = send_sig_mceerr(BUS_MCEERR_AO, (void __user *)tk->addr,\n\t\t\t\t      addr_lsb, t);  /* synchronous? */\n\t}\n\tif (ret < 0)\n\t\tpr_info(\"Memory failure: Error sending signal to %s:%d: %d\\n\",\n\t\t\tt->comm, t->pid, ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "force_sig",
          "args": [
            "SIGKILL",
            "tk->tsk"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Memory failure: %#lx: forcibly killing %s:%d because of failure to unmap corrupted page\\n\"",
            "pfn",
            "tk->tsk->comm",
            "tk->tsk->pid"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "tk",
            "next",
            "to_kill",
            "nd"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic void kill_procs(struct list_head *to_kill, int forcekill, bool fail,\n\t\tunsigned long pfn, int flags)\n{\n\tstruct to_kill *tk, *next;\n\n\tlist_for_each_entry_safe (tk, next, to_kill, nd) {\n\t\tif (forcekill) {\n\t\t\t/*\n\t\t\t * In case something went wrong with munmapping\n\t\t\t * make sure the process doesn't catch the\n\t\t\t * signal and then access the memory. Just kill it.\n\t\t\t */\n\t\t\tif (fail || tk->addr_valid == 0) {\n\t\t\t\tpr_err(\"Memory failure: %#lx: forcibly killing %s:%d because of failure to unmap corrupted page\\n\",\n\t\t\t\t       pfn, tk->tsk->comm, tk->tsk->pid);\n\t\t\t\tforce_sig(SIGKILL, tk->tsk);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * In theory the process could have mapped\n\t\t\t * something else on the address in-between. We could\n\t\t\t * check for that, but we need to tell the\n\t\t\t * process anyways.\n\t\t\t */\n\t\t\telse if (kill_proc(tk, pfn, flags) < 0)\n\t\t\t\tpr_err(\"Memory failure: %#lx: Cannot send advisory machine check signal to %s:%d\\n\",\n\t\t\t\t       pfn, tk->tsk->comm, tk->tsk->pid);\n\t\t}\n\t\tput_task_struct(tk->tsk);\n\t\tkfree(tk);\n\t}\n}"
  },
  {
    "function_name": "add_to_kill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "312-350",
    "snippet": "static void add_to_kill(struct task_struct *tsk, struct page *p,\n\t\t       struct vm_area_struct *vma,\n\t\t       struct list_head *to_kill,\n\t\t       struct to_kill **tkc)\n{\n\tstruct to_kill *tk;\n\n\tif (*tkc) {\n\t\ttk = *tkc;\n\t\t*tkc = NULL;\n\t} else {\n\t\ttk = kmalloc(sizeof(struct to_kill), GFP_ATOMIC);\n\t\tif (!tk) {\n\t\t\tpr_err(\"Memory failure: Out of memory while machine check handling\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\ttk->addr = page_address_in_vma(p, vma);\n\ttk->addr_valid = 1;\n\tif (is_zone_device_page(p))\n\t\ttk->size_shift = dev_pagemap_mapping_shift(p, vma);\n\telse\n\t\ttk->size_shift = compound_order(compound_head(p)) + PAGE_SHIFT;\n\n\t/*\n\t * In theory we don't have to kill when the page was\n\t * munmaped. But it could be also a mremap. Since that's\n\t * likely very rare kill anyways just out of paranoia, but use\n\t * a SIGKILL because the error is not contained anymore.\n\t */\n\tif (tk->addr == -EFAULT || tk->size_shift == 0) {\n\t\tpr_info(\"Memory failure: Unable to find user space address %lx in %s\\n\",\n\t\t\tpage_to_pfn(p), tsk->comm);\n\t\ttk->addr_valid = 0;\n\t}\n\tget_task_struct(tsk);\n\ttk->tsk = tsk;\n\tlist_add_tail(&tk->nd, to_kill);\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&tk->nd",
            "to_kill"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "tsk"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Memory failure: Unable to find user space address %lx in %s\\n\"",
            "page_to_pfn(p)",
            "tsk->comm"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "p"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "compound_head(p)"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "p"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_pagemap_mapping_shift",
          "args": [
            "p",
            "vma"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "dev_pagemap_mapping_shift",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "268-300",
          "snippet": "static unsigned long dev_pagemap_mapping_shift(struct page *page,\n\t\tstruct vm_area_struct *vma)\n{\n\tunsigned long address = vma_address(page, vma);\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\n\tpgd = pgd_offset(vma->vm_mm, address);\n\tif (!pgd_present(*pgd))\n\t\treturn 0;\n\tp4d = p4d_offset(pgd, address);\n\tif (!p4d_present(*p4d))\n\t\treturn 0;\n\tpud = pud_offset(p4d, address);\n\tif (!pud_present(*pud))\n\t\treturn 0;\n\tif (pud_devmap(*pud))\n\t\treturn PUD_SHIFT;\n\tpmd = pmd_offset(pud, address);\n\tif (!pmd_present(*pmd))\n\t\treturn 0;\n\tif (pmd_devmap(*pmd))\n\t\treturn PMD_SHIFT;\n\tpte = pte_offset_map(pmd, address);\n\tif (!pte_present(*pte))\n\t\treturn 0;\n\tif (pte_devmap(*pte))\n\t\treturn PAGE_SHIFT;\n\treturn 0;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic unsigned long dev_pagemap_mapping_shift(struct page *page,\n\t\tstruct vm_area_struct *vma)\n{\n\tunsigned long address = vma_address(page, vma);\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\n\tpgd = pgd_offset(vma->vm_mm, address);\n\tif (!pgd_present(*pgd))\n\t\treturn 0;\n\tp4d = p4d_offset(pgd, address);\n\tif (!p4d_present(*p4d))\n\t\treturn 0;\n\tpud = pud_offset(p4d, address);\n\tif (!pud_present(*pud))\n\t\treturn 0;\n\tif (pud_devmap(*pud))\n\t\treturn PUD_SHIFT;\n\tpmd = pmd_offset(pud, address);\n\tif (!pmd_present(*pmd))\n\t\treturn 0;\n\tif (pmd_devmap(*pmd))\n\t\treturn PMD_SHIFT;\n\tpte = pte_offset_map(pmd, address);\n\tif (!pte_present(*pte))\n\t\treturn 0;\n\tif (pte_devmap(*pte))\n\t\treturn PAGE_SHIFT;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_zone_device_page",
          "args": [
            "p"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address_in_vma",
          "args": [
            "p",
            "vma"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "page_address_in_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "687-708",
          "snippet": "unsigned long page_address_in_vma(struct page *page, struct vm_area_struct *vma)\n{\n\tunsigned long address;\n\tif (PageAnon(page)) {\n\t\tstruct anon_vma *page__anon_vma = page_anon_vma(page);\n\t\t/*\n\t\t * Note: swapoff's unuse_vma() is more efficient with this\n\t\t * check, and needs it to match anon_vma when KSM is active.\n\t\t */\n\t\tif (!vma->anon_vma || !page__anon_vma ||\n\t\t    vma->anon_vma->root != page__anon_vma->root)\n\t\t\treturn -EFAULT;\n\t} else if (page->mapping) {\n\t\tif (!vma->vm_file || vma->vm_file->f_mapping != page->mapping)\n\t\t\treturn -EFAULT;\n\t} else\n\t\treturn -EFAULT;\n\taddress = __vma_address(page, vma);\n\tif (unlikely(address < vma->vm_start || address >= vma->vm_end))\n\t\treturn -EFAULT;\n\treturn address;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nunsigned long page_address_in_vma(struct page *page, struct vm_area_struct *vma)\n{\n\tunsigned long address;\n\tif (PageAnon(page)) {\n\t\tstruct anon_vma *page__anon_vma = page_anon_vma(page);\n\t\t/*\n\t\t * Note: swapoff's unuse_vma() is more efficient with this\n\t\t * check, and needs it to match anon_vma when KSM is active.\n\t\t */\n\t\tif (!vma->anon_vma || !page__anon_vma ||\n\t\t    vma->anon_vma->root != page__anon_vma->root)\n\t\t\treturn -EFAULT;\n\t} else if (page->mapping) {\n\t\tif (!vma->vm_file || vma->vm_file->f_mapping != page->mapping)\n\t\t\treturn -EFAULT;\n\t} else\n\t\treturn -EFAULT;\n\taddress = __vma_address(page, vma);\n\tif (unlikely(address < vma->vm_start || address >= vma->vm_end))\n\t\treturn -EFAULT;\n\treturn address;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Memory failure: Out of memory while machine check handling\\n\""
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct to_kill)",
            "GFP_ATOMIC"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "__kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3729-3732",
          "snippet": "void *__kmalloc(size_t size, gfp_t flags)\n{\n\treturn __do_kmalloc(size, flags, _RET_IP_);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nvoid *__kmalloc(size_t size, gfp_t flags)\n{\n\treturn __do_kmalloc(size, flags, _RET_IP_);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic void add_to_kill(struct task_struct *tsk, struct page *p,\n\t\t       struct vm_area_struct *vma,\n\t\t       struct list_head *to_kill,\n\t\t       struct to_kill **tkc)\n{\n\tstruct to_kill *tk;\n\n\tif (*tkc) {\n\t\ttk = *tkc;\n\t\t*tkc = NULL;\n\t} else {\n\t\ttk = kmalloc(sizeof(struct to_kill), GFP_ATOMIC);\n\t\tif (!tk) {\n\t\t\tpr_err(\"Memory failure: Out of memory while machine check handling\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\ttk->addr = page_address_in_vma(p, vma);\n\ttk->addr_valid = 1;\n\tif (is_zone_device_page(p))\n\t\ttk->size_shift = dev_pagemap_mapping_shift(p, vma);\n\telse\n\t\ttk->size_shift = compound_order(compound_head(p)) + PAGE_SHIFT;\n\n\t/*\n\t * In theory we don't have to kill when the page was\n\t * munmaped. But it could be also a mremap. Since that's\n\t * likely very rare kill anyways just out of paranoia, but use\n\t * a SIGKILL because the error is not contained anymore.\n\t */\n\tif (tk->addr == -EFAULT || tk->size_shift == 0) {\n\t\tpr_info(\"Memory failure: Unable to find user space address %lx in %s\\n\",\n\t\t\tpage_to_pfn(p), tsk->comm);\n\t\ttk->addr_valid = 0;\n\t}\n\tget_task_struct(tsk);\n\ttk->tsk = tsk;\n\tlist_add_tail(&tk->nd, to_kill);\n}"
  },
  {
    "function_name": "dev_pagemap_mapping_shift",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "268-300",
    "snippet": "static unsigned long dev_pagemap_mapping_shift(struct page *page,\n\t\tstruct vm_area_struct *vma)\n{\n\tunsigned long address = vma_address(page, vma);\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\n\tpgd = pgd_offset(vma->vm_mm, address);\n\tif (!pgd_present(*pgd))\n\t\treturn 0;\n\tp4d = p4d_offset(pgd, address);\n\tif (!p4d_present(*p4d))\n\t\treturn 0;\n\tpud = pud_offset(p4d, address);\n\tif (!pud_present(*pud))\n\t\treturn 0;\n\tif (pud_devmap(*pud))\n\t\treturn PUD_SHIFT;\n\tpmd = pmd_offset(pud, address);\n\tif (!pmd_present(*pmd))\n\t\treturn 0;\n\tif (pmd_devmap(*pmd))\n\t\treturn PMD_SHIFT;\n\tpte = pte_offset_map(pmd, address);\n\tif (!pte_present(*pte))\n\t\treturn 0;\n\tif (pte_devmap(*pte))\n\t\treturn PAGE_SHIFT;\n\treturn 0;\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_devmap",
          "args": [
            "*pte"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "*pte"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_offset_map",
          "args": [
            "pmd",
            "address"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_devmap",
          "args": [
            "*pmd"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "pmd_devmap_trans_unstable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3023-3026",
          "snippet": "static int pmd_devmap_trans_unstable(pmd_t *pmd)\n{\n\treturn pmd_devmap(*pmd) || pmd_trans_unstable(pmd);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic int pmd_devmap_trans_unstable(pmd_t *pmd)\n{\n\treturn pmd_devmap(*pmd) || pmd_trans_unstable(pmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_present",
          "args": [
            "*pmd"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_offset",
          "args": [
            "pud",
            "address"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_devmap",
          "args": [
            "*pud"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_present",
          "args": [
            "*pud"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_offset",
          "args": [
            "p4d",
            "address"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_present",
          "args": [
            "*p4d"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_offset",
          "args": [
            "pgd",
            "address"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_present",
          "args": [
            "*pgd"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_offset",
          "args": [
            "vma->vm_mm",
            "address"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_address",
          "args": [
            "page",
            "vma"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "vma_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "343-355",
          "snippet": "static inline unsigned long\nvma_address(struct page *page, struct vm_area_struct *vma)\n{\n\tunsigned long start, end;\n\n\tstart = __vma_address(page, vma);\n\tend = start + PAGE_SIZE * (hpage_nr_pages(page) - 1);\n\n\t/* page should be within @vma mapping range */\n\tVM_BUG_ON_VMA(end < vma->vm_start || start >= vma->vm_end, vma);\n\n\treturn max(start, vma->vm_start);\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline unsigned long\nvma_address(struct page *page, struct vm_area_struct *vma)\n{\n\tunsigned long start, end;\n\n\tstart = __vma_address(page, vma);\n\tend = start + PAGE_SIZE * (hpage_nr_pages(page) - 1);\n\n\t/* page should be within @vma mapping range */\n\tVM_BUG_ON_VMA(end < vma->vm_start || start >= vma->vm_end, vma);\n\n\treturn max(start, vma->vm_start);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic unsigned long dev_pagemap_mapping_shift(struct page *page,\n\t\tstruct vm_area_struct *vma)\n{\n\tunsigned long address = vma_address(page, vma);\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\n\tpgd = pgd_offset(vma->vm_mm, address);\n\tif (!pgd_present(*pgd))\n\t\treturn 0;\n\tp4d = p4d_offset(pgd, address);\n\tif (!p4d_present(*p4d))\n\t\treturn 0;\n\tpud = pud_offset(p4d, address);\n\tif (!pud_present(*pud))\n\t\treturn 0;\n\tif (pud_devmap(*pud))\n\t\treturn PUD_SHIFT;\n\tpmd = pmd_offset(pud, address);\n\tif (!pmd_present(*pmd))\n\t\treturn 0;\n\tif (pmd_devmap(*pmd))\n\t\treturn PMD_SHIFT;\n\tpte = pte_offset_map(pmd, address);\n\tif (!pte_present(*pte))\n\t\treturn 0;\n\tif (pte_devmap(*pte))\n\t\treturn PAGE_SHIFT;\n\treturn 0;\n}"
  },
  {
    "function_name": "shake_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "245-265",
    "snippet": "void shake_page(struct page *p, int access)\n{\n\tif (PageHuge(p))\n\t\treturn;\n\n\tif (!PageSlab(p)) {\n\t\tlru_add_drain_all();\n\t\tif (PageLRU(p))\n\t\t\treturn;\n\t\tdrain_all_pages(page_zone(p));\n\t\tif (PageLRU(p) || is_free_buddy_page(p))\n\t\t\treturn;\n\t}\n\n\t/*\n\t * Only call shrink_node_slabs here (which would also shrink\n\t * other caches) if access is not potentially fatal.\n\t */\n\tif (access)\n\t\tdrop_slab_node(page_to_nid(p));\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "drop_slab_node",
          "args": [
            "page_to_nid(p)"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "drop_slab_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "727-740",
          "snippet": "void drop_slab_node(int nid)\n{\n\tunsigned long freed;\n\n\tdo {\n\t\tstruct mem_cgroup *memcg = NULL;\n\n\t\tfreed = 0;\n\t\tmemcg = mem_cgroup_iter(NULL, NULL, NULL);\n\t\tdo {\n\t\t\tfreed += shrink_slab(GFP_KERNEL, nid, memcg, 0);\n\t\t} while ((memcg = mem_cgroup_iter(NULL, memcg, NULL)) != NULL);\n\t} while (freed > 10);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid drop_slab_node(int nid)\n{\n\tunsigned long freed;\n\n\tdo {\n\t\tstruct mem_cgroup *memcg = NULL;\n\n\t\tfreed = 0;\n\t\tmemcg = mem_cgroup_iter(NULL, NULL, NULL);\n\t\tdo {\n\t\t\tfreed += shrink_slab(GFP_KERNEL, nid, memcg, 0);\n\t\t} while ((memcg = mem_cgroup_iter(NULL, memcg, NULL)) != NULL);\n\t} while (freed > 10);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "p"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_free_buddy_page",
          "args": [
            "p"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "p"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drain_all_pages",
          "args": [
            "page_zone(p)"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "drain_all_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2614-2682",
          "snippet": "void drain_all_pages(struct zone *zone)\n{\n\tint cpu;\n\n\t/*\n\t * Allocate in the BSS so we wont require allocation in\n\t * direct reclaim path for CONFIG_CPUMASK_OFFSTACK=y\n\t */\n\tstatic cpumask_t cpus_with_pcps;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON_ONCE(!mm_percpu_wq))\n\t\treturn;\n\n\t/*\n\t * Do not drain if one is already in progress unless it's specific to\n\t * a zone. Such callers are primarily CMA and memory hotplug and need\n\t * the drain to be complete when the call returns.\n\t */\n\tif (unlikely(!mutex_trylock(&pcpu_drain_mutex))) {\n\t\tif (!zone)\n\t\t\treturn;\n\t\tmutex_lock(&pcpu_drain_mutex);\n\t}\n\n\t/*\n\t * We don't care about racing with CPU hotplug event\n\t * as offline notification will cause the notified\n\t * cpu to drain that CPU pcps and on_each_cpu_mask\n\t * disables preemption as part of its processing\n\t */\n\tfor_each_online_cpu(cpu) {\n\t\tstruct per_cpu_pageset *pcp;\n\t\tstruct zone *z;\n\t\tbool has_pcps = false;\n\n\t\tif (zone) {\n\t\t\tpcp = per_cpu_ptr(zone->pageset, cpu);\n\t\t\tif (pcp->pcp.count)\n\t\t\t\thas_pcps = true;\n\t\t} else {\n\t\t\tfor_each_populated_zone(z) {\n\t\t\t\tpcp = per_cpu_ptr(z->pageset, cpu);\n\t\t\t\tif (pcp->pcp.count) {\n\t\t\t\t\thas_pcps = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (has_pcps)\n\t\t\tcpumask_set_cpu(cpu, &cpus_with_pcps);\n\t\telse\n\t\t\tcpumask_clear_cpu(cpu, &cpus_with_pcps);\n\t}\n\n\tfor_each_cpu(cpu, &cpus_with_pcps) {\n\t\tstruct work_struct *work = per_cpu_ptr(&pcpu_drain, cpu);\n\t\tINIT_WORK(work, drain_local_pages_wq);\n\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t}\n\tfor_each_cpu(cpu, &cpus_with_pcps)\n\t\tflush_work(per_cpu_ptr(&pcpu_drain, cpu));\n\n\tmutex_unlock(&pcpu_drain_mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid drain_all_pages(struct zone *zone)\n{\n\tint cpu;\n\n\t/*\n\t * Allocate in the BSS so we wont require allocation in\n\t * direct reclaim path for CONFIG_CPUMASK_OFFSTACK=y\n\t */\n\tstatic cpumask_t cpus_with_pcps;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON_ONCE(!mm_percpu_wq))\n\t\treturn;\n\n\t/*\n\t * Do not drain if one is already in progress unless it's specific to\n\t * a zone. Such callers are primarily CMA and memory hotplug and need\n\t * the drain to be complete when the call returns.\n\t */\n\tif (unlikely(!mutex_trylock(&pcpu_drain_mutex))) {\n\t\tif (!zone)\n\t\t\treturn;\n\t\tmutex_lock(&pcpu_drain_mutex);\n\t}\n\n\t/*\n\t * We don't care about racing with CPU hotplug event\n\t * as offline notification will cause the notified\n\t * cpu to drain that CPU pcps and on_each_cpu_mask\n\t * disables preemption as part of its processing\n\t */\n\tfor_each_online_cpu(cpu) {\n\t\tstruct per_cpu_pageset *pcp;\n\t\tstruct zone *z;\n\t\tbool has_pcps = false;\n\n\t\tif (zone) {\n\t\t\tpcp = per_cpu_ptr(zone->pageset, cpu);\n\t\t\tif (pcp->pcp.count)\n\t\t\t\thas_pcps = true;\n\t\t} else {\n\t\t\tfor_each_populated_zone(z) {\n\t\t\t\tpcp = per_cpu_ptr(z->pageset, cpu);\n\t\t\t\tif (pcp->pcp.count) {\n\t\t\t\t\thas_pcps = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (has_pcps)\n\t\t\tcpumask_set_cpu(cpu, &cpus_with_pcps);\n\t\telse\n\t\t\tcpumask_clear_cpu(cpu, &cpus_with_pcps);\n\t}\n\n\tfor_each_cpu(cpu, &cpus_with_pcps) {\n\t\tstruct work_struct *work = per_cpu_ptr(&pcpu_drain, cpu);\n\t\tINIT_WORK(work, drain_local_pages_wq);\n\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t}\n\tfor_each_cpu(cpu, &cpus_with_pcps)\n\t\tflush_work(per_cpu_ptr(&pcpu_drain, cpu));\n\n\tmutex_unlock(&pcpu_drain_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "p"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "p"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lru_add_drain_all",
          "args": [],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "lru_add_drain_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "670-704",
          "snippet": "void lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);",
            "static DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);",
            "static DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\nstatic DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);\nstatic DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);\n\nvoid lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageSlab",
          "args": [
            "p"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "p"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "PageHugeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "225-228",
          "snippet": "static int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nvoid shake_page(struct page *p, int access)\n{\n\tif (PageHuge(p))\n\t\treturn;\n\n\tif (!PageSlab(p)) {\n\t\tlru_add_drain_all();\n\t\tif (PageLRU(p))\n\t\t\treturn;\n\t\tdrain_all_pages(page_zone(p));\n\t\tif (PageLRU(p) || is_free_buddy_page(p))\n\t\t\treturn;\n\t}\n\n\t/*\n\t * Only call shrink_node_slabs here (which would also shrink\n\t * other caches) if access is not potentially fatal.\n\t */\n\tif (access)\n\t\tdrop_slab_node(page_to_nid(p));\n}"
  },
  {
    "function_name": "kill_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "213-239",
    "snippet": "static int kill_proc(struct to_kill *tk, unsigned long pfn, int flags)\n{\n\tstruct task_struct *t = tk->tsk;\n\tshort addr_lsb = tk->size_shift;\n\tint ret;\n\n\tpr_err(\"Memory failure: %#lx: Killing %s:%d due to hardware memory corruption\\n\",\n\t\tpfn, t->comm, t->pid);\n\n\tif ((flags & MF_ACTION_REQUIRED) && t->mm == current->mm) {\n\t\tret = force_sig_mceerr(BUS_MCEERR_AR, (void __user *)tk->addr,\n\t\t\t\t       addr_lsb, current);\n\t} else {\n\t\t/*\n\t\t * Don't use force here, it's convenient if the signal\n\t\t * can be temporarily blocked.\n\t\t * This could cause a loop when the user sets SIGBUS\n\t\t * to SIG_IGN, but hopefully no one will do that?\n\t\t */\n\t\tret = send_sig_mceerr(BUS_MCEERR_AO, (void __user *)tk->addr,\n\t\t\t\t      addr_lsb, t);  /* synchronous? */\n\t}\n\tif (ret < 0)\n\t\tpr_info(\"Memory failure: Error sending signal to %s:%d: %d\\n\",\n\t\t\tt->comm, t->pid, ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Memory failure: Error sending signal to %s:%d: %d\\n\"",
            "t->comm",
            "t->pid",
            "ret"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_sig_mceerr",
          "args": [
            "BUS_MCEERR_AO",
            "(void __user *)tk->addr",
            "addr_lsb",
            "t"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "force_sig_mceerr",
          "args": [
            "BUS_MCEERR_AR",
            "(void __user *)tk->addr",
            "addr_lsb",
            "current"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Memory failure: %#lx: Killing %s:%d due to hardware memory corruption\\n\"",
            "pfn",
            "t->comm",
            "t->pid"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int kill_proc(struct to_kill *tk, unsigned long pfn, int flags)\n{\n\tstruct task_struct *t = tk->tsk;\n\tshort addr_lsb = tk->size_shift;\n\tint ret;\n\n\tpr_err(\"Memory failure: %#lx: Killing %s:%d due to hardware memory corruption\\n\",\n\t\tpfn, t->comm, t->pid);\n\n\tif ((flags & MF_ACTION_REQUIRED) && t->mm == current->mm) {\n\t\tret = force_sig_mceerr(BUS_MCEERR_AR, (void __user *)tk->addr,\n\t\t\t\t       addr_lsb, current);\n\t} else {\n\t\t/*\n\t\t * Don't use force here, it's convenient if the signal\n\t\t * can be temporarily blocked.\n\t\t * This could cause a loop when the user sets SIGBUS\n\t\t * to SIG_IGN, but hopefully no one will do that?\n\t\t */\n\t\tret = send_sig_mceerr(BUS_MCEERR_AO, (void __user *)tk->addr,\n\t\t\t\t      addr_lsb, t);  /* synchronous? */\n\t}\n\tif (ret < 0)\n\t\tpr_info(\"Memory failure: Error sending signal to %s:%d: %d\\n\",\n\t\t\tt->comm, t->pid, ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "hwpoison_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "170-173",
    "snippet": "int hwpoison_filter(struct page *p)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint hwpoison_filter(struct page *p)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "hwpoison_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "153-168",
    "snippet": "int hwpoison_filter(struct page *p)\n{\n\tif (!hwpoison_filter_enable)\n\t\treturn 0;\n\n\tif (hwpoison_filter_dev(p))\n\t\treturn -EINVAL;\n\n\tif (hwpoison_filter_flags(p))\n\t\treturn -EINVAL;\n\n\tif (hwpoison_filter_task(p))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hwpoison_filter_task",
          "args": [
            "p"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "hwpoison_filter_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "150-150",
          "snippet": "static int hwpoison_filter_task(struct page *p) { return 0; }",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int hwpoison_filter_task(struct page *p) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "hwpoison_filter_flags",
          "args": [
            "p"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "hwpoison_filter_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "114-124",
          "snippet": "static int hwpoison_filter_flags(struct page *p)\n{\n\tif (!hwpoison_filter_flags_mask)\n\t\treturn 0;\n\n\tif ((stable_page_flags(p) & hwpoison_filter_flags_mask) ==\n\t\t\t\t    hwpoison_filter_flags_value)\n\t\treturn 0;\n\telse\n\t\treturn -EINVAL;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int hwpoison_filter_flags(struct page *p)\n{\n\tif (!hwpoison_filter_flags_mask)\n\t\treturn 0;\n\n\tif ((stable_page_flags(p) & hwpoison_filter_flags_mask) ==\n\t\t\t\t    hwpoison_filter_flags_value)\n\t\treturn 0;\n\telse\n\t\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hwpoison_filter_dev",
          "args": [
            "p"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "hwpoison_filter_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "84-112",
          "snippet": "static int hwpoison_filter_dev(struct page *p)\n{\n\tstruct address_space *mapping;\n\tdev_t dev;\n\n\tif (hwpoison_filter_dev_major == ~0U &&\n\t    hwpoison_filter_dev_minor == ~0U)\n\t\treturn 0;\n\n\t/*\n\t * page_mapping() does not accept slab pages.\n\t */\n\tif (PageSlab(p))\n\t\treturn -EINVAL;\n\n\tmapping = page_mapping(p);\n\tif (mapping == NULL || mapping->host == NULL)\n\t\treturn -EINVAL;\n\n\tdev = mapping->host->i_sb->s_dev;\n\tif (hwpoison_filter_dev_major != ~0U &&\n\t    hwpoison_filter_dev_major != MAJOR(dev))\n\t\treturn -EINVAL;\n\tif (hwpoison_filter_dev_minor != ~0U &&\n\t    hwpoison_filter_dev_minor != MINOR(dev))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define slab\t\t(1UL << PG_slab)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define slab\t\t(1UL << PG_slab)\n\nstatic int hwpoison_filter_dev(struct page *p)\n{\n\tstruct address_space *mapping;\n\tdev_t dev;\n\n\tif (hwpoison_filter_dev_major == ~0U &&\n\t    hwpoison_filter_dev_minor == ~0U)\n\t\treturn 0;\n\n\t/*\n\t * page_mapping() does not accept slab pages.\n\t */\n\tif (PageSlab(p))\n\t\treturn -EINVAL;\n\n\tmapping = page_mapping(p);\n\tif (mapping == NULL || mapping->host == NULL)\n\t\treturn -EINVAL;\n\n\tdev = mapping->host->i_sb->s_dev;\n\tif (hwpoison_filter_dev_major != ~0U &&\n\t    hwpoison_filter_dev_major != MAJOR(dev))\n\t\treturn -EINVAL;\n\tif (hwpoison_filter_dev_minor != ~0U &&\n\t    hwpoison_filter_dev_minor != MINOR(dev))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint hwpoison_filter(struct page *p)\n{\n\tif (!hwpoison_filter_enable)\n\t\treturn 0;\n\n\tif (hwpoison_filter_dev(p))\n\t\treturn -EINVAL;\n\n\tif (hwpoison_filter_flags(p))\n\t\treturn -EINVAL;\n\n\tif (hwpoison_filter_task(p))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hwpoison_filter_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "150-150",
    "snippet": "static int hwpoison_filter_task(struct page *p) { return 0; }",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int hwpoison_filter_task(struct page *p) { return 0; }"
  },
  {
    "function_name": "hwpoison_filter_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "139-148",
    "snippet": "static int hwpoison_filter_task(struct page *p)\n{\n\tif (!hwpoison_filter_memcg)\n\t\treturn 0;\n\n\tif (page_cgroup_ino(p) != hwpoison_filter_memcg)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cgroup_ino",
          "args": [
            "p"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "page_cgroup_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "484-497",
          "snippet": "ino_t page_cgroup_ino(struct page *page)\n{\n\tstruct mem_cgroup *memcg;\n\tunsigned long ino = 0;\n\n\trcu_read_lock();\n\tmemcg = READ_ONCE(page->mem_cgroup);\n\twhile (memcg && !(memcg->css.flags & CSS_ONLINE))\n\t\tmemcg = parent_mem_cgroup(memcg);\n\tif (memcg)\n\t\tino = cgroup_ino(memcg->css.cgroup);\n\trcu_read_unlock();\n\treturn ino;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nino_t page_cgroup_ino(struct page *page)\n{\n\tstruct mem_cgroup *memcg;\n\tunsigned long ino = 0;\n\n\trcu_read_lock();\n\tmemcg = READ_ONCE(page->mem_cgroup);\n\twhile (memcg && !(memcg->css.flags & CSS_ONLINE))\n\t\tmemcg = parent_mem_cgroup(memcg);\n\tif (memcg)\n\t\tino = cgroup_ino(memcg->css.cgroup);\n\trcu_read_unlock();\n\treturn ino;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int hwpoison_filter_task(struct page *p)\n{\n\tif (!hwpoison_filter_memcg)\n\t\treturn 0;\n\n\tif (page_cgroup_ino(p) != hwpoison_filter_memcg)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hwpoison_filter_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "114-124",
    "snippet": "static int hwpoison_filter_flags(struct page *p)\n{\n\tif (!hwpoison_filter_flags_mask)\n\t\treturn 0;\n\n\tif ((stable_page_flags(p) & hwpoison_filter_flags_mask) ==\n\t\t\t\t    hwpoison_filter_flags_value)\n\t\treturn 0;\n\telse\n\t\treturn -EINVAL;\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stable_page_flags",
          "args": [
            "p"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int hwpoison_filter_flags(struct page *p)\n{\n\tif (!hwpoison_filter_flags_mask)\n\t\treturn 0;\n\n\tif ((stable_page_flags(p) & hwpoison_filter_flags_mask) ==\n\t\t\t\t    hwpoison_filter_flags_value)\n\t\treturn 0;\n\telse\n\t\treturn -EINVAL;\n}"
  },
  {
    "function_name": "hwpoison_filter_dev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
    "lines": "84-112",
    "snippet": "static int hwpoison_filter_dev(struct page *p)\n{\n\tstruct address_space *mapping;\n\tdev_t dev;\n\n\tif (hwpoison_filter_dev_major == ~0U &&\n\t    hwpoison_filter_dev_minor == ~0U)\n\t\treturn 0;\n\n\t/*\n\t * page_mapping() does not accept slab pages.\n\t */\n\tif (PageSlab(p))\n\t\treturn -EINVAL;\n\n\tmapping = page_mapping(p);\n\tif (mapping == NULL || mapping->host == NULL)\n\t\treturn -EINVAL;\n\n\tdev = mapping->host->i_sb->s_dev;\n\tif (hwpoison_filter_dev_major != ~0U &&\n\t    hwpoison_filter_dev_major != MAJOR(dev))\n\t\treturn -EINVAL;\n\tif (hwpoison_filter_dev_minor != ~0U &&\n\t    hwpoison_filter_dev_minor != MINOR(dev))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ras/ras_event.h\"",
      "#include \"internal.h\"",
      "#include <linux/page-isolation.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/kfifo.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/slab.h>",
      "#include <linux/suspend.h>",
      "#include <linux/migrate.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/export.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel-page-flags.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define slab\t\t(1UL << PG_slab)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "dev"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "dev"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "p"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapping_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "528-533",
          "snippet": "struct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageSlab",
          "args": [
            "p"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define slab\t\t(1UL << PG_slab)\n\nstatic int hwpoison_filter_dev(struct page *p)\n{\n\tstruct address_space *mapping;\n\tdev_t dev;\n\n\tif (hwpoison_filter_dev_major == ~0U &&\n\t    hwpoison_filter_dev_minor == ~0U)\n\t\treturn 0;\n\n\t/*\n\t * page_mapping() does not accept slab pages.\n\t */\n\tif (PageSlab(p))\n\t\treturn -EINVAL;\n\n\tmapping = page_mapping(p);\n\tif (mapping == NULL || mapping->host == NULL)\n\t\treturn -EINVAL;\n\n\tdev = mapping->host->i_sb->s_dev;\n\tif (hwpoison_filter_dev_major != ~0U &&\n\t    hwpoison_filter_dev_major != MAJOR(dev))\n\t\treturn -EINVAL;\n\tif (hwpoison_filter_dev_minor != ~0U &&\n\t    hwpoison_filter_dev_minor != MINOR(dev))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  }
]