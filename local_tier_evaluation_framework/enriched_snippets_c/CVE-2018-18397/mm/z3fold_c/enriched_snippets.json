[
  {
    "function_name": "exit_z3fold",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
    "lines": "1143-1146",
    "snippet": "static void __exit exit_z3fold(void)\n{\n\tzpool_unregister_driver(&z3fold_zpool_driver);\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/sched.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct zpool_driver z3fold_zpool_driver = {\n\t.type =\t\t\"z3fold\",\n\t.owner =\tTHIS_MODULE,\n\t.create =\tz3fold_zpool_create,\n\t.destroy =\tz3fold_zpool_destroy,\n\t.malloc =\tz3fold_zpool_malloc,\n\t.free =\t\tz3fold_zpool_free,\n\t.shrink =\tz3fold_zpool_shrink,\n\t.map =\t\tz3fold_zpool_map,\n\t.unmap =\tz3fold_zpool_unmap,\n\t.total_size =\tz3fold_zpool_total_size,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "zpool_unregister_driver",
          "args": [
            "&z3fold_zpool_driver"
          ],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "zpool_unregister_driver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zpool.c",
          "lines": "58-72",
          "snippet": "int zpool_unregister_driver(struct zpool_driver *driver)\n{\n\tint ret = 0, refcount;\n\n\tspin_lock(&drivers_lock);\n\trefcount = atomic_read(&driver->refcount);\n\tWARN_ON(refcount < 0);\n\tif (refcount > 0)\n\t\tret = -EBUSY;\n\telse\n\t\tlist_del(&driver->list);\n\tspin_unlock(&drivers_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(drivers_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic DEFINE_SPINLOCK(drivers_lock);\n\nint zpool_unregister_driver(struct zpool_driver *driver)\n{\n\tint ret = 0, refcount;\n\n\tspin_lock(&drivers_lock);\n\trefcount = atomic_read(&driver->refcount);\n\tWARN_ON(refcount < 0);\n\tif (refcount > 0)\n\t\tret = -EBUSY;\n\telse\n\t\tlist_del(&driver->list);\n\tspin_unlock(&drivers_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic struct zpool_driver z3fold_zpool_driver = {\n\t.type =\t\t\"z3fold\",\n\t.owner =\tTHIS_MODULE,\n\t.create =\tz3fold_zpool_create,\n\t.destroy =\tz3fold_zpool_destroy,\n\t.malloc =\tz3fold_zpool_malloc,\n\t.free =\t\tz3fold_zpool_free,\n\t.shrink =\tz3fold_zpool_shrink,\n\t.map =\t\tz3fold_zpool_map,\n\t.unmap =\tz3fold_zpool_unmap,\n\t.total_size =\tz3fold_zpool_total_size,\n};\n\nstatic void __exit exit_z3fold(void)\n{\n\tzpool_unregister_driver(&z3fold_zpool_driver);\n}"
  },
  {
    "function_name": "init_z3fold",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
    "lines": "1134-1141",
    "snippet": "static int __init init_z3fold(void)\n{\n\t/* Make sure the z3fold header is not larger than the page size */\n\tBUILD_BUG_ON(ZHDR_SIZE_ALIGNED > PAGE_SIZE);\n\tzpool_register_driver(&z3fold_zpool_driver);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/sched.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define ZHDR_SIZE_ALIGNED round_up(sizeof(struct z3fold_header), CHUNK_SIZE)"
    ],
    "globals_used": [
      "static struct zpool_driver z3fold_zpool_driver = {\n\t.type =\t\t\"z3fold\",\n\t.owner =\tTHIS_MODULE,\n\t.create =\tz3fold_zpool_create,\n\t.destroy =\tz3fold_zpool_destroy,\n\t.malloc =\tz3fold_zpool_malloc,\n\t.free =\t\tz3fold_zpool_free,\n\t.shrink =\tz3fold_zpool_shrink,\n\t.map =\t\tz3fold_zpool_map,\n\t.unmap =\tz3fold_zpool_unmap,\n\t.total_size =\tz3fold_zpool_total_size,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "zpool_register_driver",
          "args": [
            "&z3fold_zpool_driver"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "zpool_register_driver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zpool.c",
          "lines": "39-45",
          "snippet": "void zpool_register_driver(struct zpool_driver *driver)\n{\n\tspin_lock(&drivers_lock);\n\tatomic_set(&driver->refcount, 0);\n\tlist_add(&driver->list, &drivers_head);\n\tspin_unlock(&drivers_lock);\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(drivers_head);",
            "static DEFINE_SPINLOCK(drivers_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic LIST_HEAD(drivers_head);\nstatic DEFINE_SPINLOCK(drivers_lock);\n\nvoid zpool_register_driver(struct zpool_driver *driver)\n{\n\tspin_lock(&drivers_lock);\n\tatomic_set(&driver->refcount, 0);\n\tlist_add(&driver->list, &drivers_head);\n\tspin_unlock(&drivers_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "ZHDR_SIZE_ALIGNED > PAGE_SIZE"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\n#define ZHDR_SIZE_ALIGNED round_up(sizeof(struct z3fold_header), CHUNK_SIZE)\n\nstatic struct zpool_driver z3fold_zpool_driver = {\n\t.type =\t\t\"z3fold\",\n\t.owner =\tTHIS_MODULE,\n\t.create =\tz3fold_zpool_create,\n\t.destroy =\tz3fold_zpool_destroy,\n\t.malloc =\tz3fold_zpool_malloc,\n\t.free =\t\tz3fold_zpool_free,\n\t.shrink =\tz3fold_zpool_shrink,\n\t.map =\t\tz3fold_zpool_map,\n\t.unmap =\tz3fold_zpool_unmap,\n\t.total_size =\tz3fold_zpool_total_size,\n};\n\nstatic int __init init_z3fold(void)\n{\n\t/* Make sure the z3fold header is not larger than the page size */\n\tBUILD_BUG_ON(ZHDR_SIZE_ALIGNED > PAGE_SIZE);\n\tzpool_register_driver(&z3fold_zpool_driver);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "z3fold_zpool_total_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
    "lines": "1114-1117",
    "snippet": "static u64 z3fold_zpool_total_size(void *pool)\n{\n\treturn z3fold_get_pool_size(pool) * PAGE_SIZE;\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/sched.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "z3fold_get_pool_size",
          "args": [
            "pool"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "z3fold_get_pool_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "1034-1037",
          "snippet": "static u64 z3fold_get_pool_size(struct z3fold_pool *pool)\n{\n\treturn atomic64_read(&pool->pages_nr);\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic u64 z3fold_get_pool_size(struct z3fold_pool *pool)\n{\n\treturn atomic64_read(&pool->pages_nr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic u64 z3fold_zpool_total_size(void *pool)\n{\n\treturn z3fold_get_pool_size(pool) * PAGE_SIZE;\n}"
  },
  {
    "function_name": "z3fold_zpool_unmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
    "lines": "1109-1112",
    "snippet": "static void z3fold_zpool_unmap(void *pool, unsigned long handle)\n{\n\tz3fold_unmap(pool, handle);\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/sched.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "z3fold_unmap",
          "args": [
            "pool",
            "handle"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "z3fold_unmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "1009-1026",
          "snippet": "static void z3fold_unmap(struct z3fold_pool *pool, unsigned long handle)\n{\n\tstruct z3fold_header *zhdr;\n\tstruct page *page;\n\tenum buddy buddy;\n\n\tzhdr = handle_to_z3fold_header(handle);\n\tpage = virt_to_page(zhdr);\n\n\tif (test_bit(PAGE_HEADLESS, &page->private))\n\t\treturn;\n\n\tz3fold_page_lock(zhdr);\n\tbuddy = handle_to_buddy(handle);\n\tif (buddy == MIDDLE)\n\t\tclear_bit(MIDDLE_CHUNK_MAPPED, &page->private);\n\tz3fold_page_unlock(zhdr);\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic void z3fold_unmap(struct z3fold_pool *pool, unsigned long handle)\n{\n\tstruct z3fold_header *zhdr;\n\tstruct page *page;\n\tenum buddy buddy;\n\n\tzhdr = handle_to_z3fold_header(handle);\n\tpage = virt_to_page(zhdr);\n\n\tif (test_bit(PAGE_HEADLESS, &page->private))\n\t\treturn;\n\n\tz3fold_page_lock(zhdr);\n\tbuddy = handle_to_buddy(handle);\n\tif (buddy == MIDDLE)\n\t\tclear_bit(MIDDLE_CHUNK_MAPPED, &page->private);\n\tz3fold_page_unlock(zhdr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic void z3fold_zpool_unmap(void *pool, unsigned long handle)\n{\n\tz3fold_unmap(pool, handle);\n}"
  },
  {
    "function_name": "z3fold_zpool_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
    "lines": "1104-1108",
    "snippet": "static void *z3fold_zpool_map(void *pool, unsigned long handle,\n\t\t\tenum zpool_mapmode mm)\n{\n\treturn z3fold_map(pool, handle);\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/sched.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "z3fold_map",
          "args": [
            "pool",
            "handle"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "z3fold_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "965-1002",
          "snippet": "static void *z3fold_map(struct z3fold_pool *pool, unsigned long handle)\n{\n\tstruct z3fold_header *zhdr;\n\tstruct page *page;\n\tvoid *addr;\n\tenum buddy buddy;\n\n\tzhdr = handle_to_z3fold_header(handle);\n\taddr = zhdr;\n\tpage = virt_to_page(zhdr);\n\n\tif (test_bit(PAGE_HEADLESS, &page->private))\n\t\tgoto out;\n\n\tz3fold_page_lock(zhdr);\n\tbuddy = handle_to_buddy(handle);\n\tswitch (buddy) {\n\tcase FIRST:\n\t\taddr += ZHDR_SIZE_ALIGNED;\n\t\tbreak;\n\tcase MIDDLE:\n\t\taddr += zhdr->start_middle << CHUNK_SHIFT;\n\t\tset_bit(MIDDLE_CHUNK_MAPPED, &page->private);\n\t\tbreak;\n\tcase LAST:\n\t\taddr += PAGE_SIZE - (handle_to_chunks(handle) << CHUNK_SHIFT);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unknown buddy id %d\\n\", buddy);\n\t\tWARN_ON(1);\n\t\taddr = NULL;\n\t\tbreak;\n\t}\n\n\tz3fold_page_unlock(zhdr);\nout:\n\treturn addr;\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define ZHDR_SIZE_ALIGNED round_up(sizeof(struct z3fold_header), CHUNK_SIZE)",
            "#define CHUNK_SHIFT\t(PAGE_SHIFT - NCHUNKS_ORDER)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\n#define ZHDR_SIZE_ALIGNED round_up(sizeof(struct z3fold_header), CHUNK_SIZE)\n#define CHUNK_SHIFT\t(PAGE_SHIFT - NCHUNKS_ORDER)\n\nstatic void *z3fold_map(struct z3fold_pool *pool, unsigned long handle)\n{\n\tstruct z3fold_header *zhdr;\n\tstruct page *page;\n\tvoid *addr;\n\tenum buddy buddy;\n\n\tzhdr = handle_to_z3fold_header(handle);\n\taddr = zhdr;\n\tpage = virt_to_page(zhdr);\n\n\tif (test_bit(PAGE_HEADLESS, &page->private))\n\t\tgoto out;\n\n\tz3fold_page_lock(zhdr);\n\tbuddy = handle_to_buddy(handle);\n\tswitch (buddy) {\n\tcase FIRST:\n\t\taddr += ZHDR_SIZE_ALIGNED;\n\t\tbreak;\n\tcase MIDDLE:\n\t\taddr += zhdr->start_middle << CHUNK_SHIFT;\n\t\tset_bit(MIDDLE_CHUNK_MAPPED, &page->private);\n\t\tbreak;\n\tcase LAST:\n\t\taddr += PAGE_SIZE - (handle_to_chunks(handle) << CHUNK_SHIFT);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unknown buddy id %d\\n\", buddy);\n\t\tWARN_ON(1);\n\t\taddr = NULL;\n\t\tbreak;\n\t}\n\n\tz3fold_page_unlock(zhdr);\nout:\n\treturn addr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic void *z3fold_zpool_map(void *pool, unsigned long handle,\n\t\t\tenum zpool_mapmode mm)\n{\n\treturn z3fold_map(pool, handle);\n}"
  },
  {
    "function_name": "z3fold_zpool_shrink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
    "lines": "1085-1102",
    "snippet": "static int z3fold_zpool_shrink(void *pool, unsigned int pages,\n\t\t\tunsigned int *reclaimed)\n{\n\tunsigned int total = 0;\n\tint ret = -EINVAL;\n\n\twhile (total < pages) {\n\t\tret = z3fold_reclaim_page(pool, 8);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\ttotal++;\n\t}\n\n\tif (reclaimed)\n\t\t*reclaimed = total;\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/sched.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "z3fold_reclaim_page",
          "args": [
            "pool",
            "8"
          ],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "z3fold_reclaim_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "831-953",
          "snippet": "static int z3fold_reclaim_page(struct z3fold_pool *pool, unsigned int retries)\n{\n\tint i, ret = 0;\n\tstruct z3fold_header *zhdr = NULL;\n\tstruct page *page = NULL;\n\tstruct list_head *pos;\n\tunsigned long first_handle = 0, middle_handle = 0, last_handle = 0;\n\n\tspin_lock(&pool->lock);\n\tif (!pool->ops || !pool->ops->evict || retries == 0) {\n\t\tspin_unlock(&pool->lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < retries; i++) {\n\t\tif (list_empty(&pool->lru)) {\n\t\t\tspin_unlock(&pool->lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlist_for_each_prev(pos, &pool->lru) {\n\t\t\tpage = list_entry(pos, struct page, lru);\n\n\t\t\t/* this bit could have been set by free, in which case\n\t\t\t * we pass over to the next page in the pool.\n\t\t\t */\n\t\t\tif (test_and_set_bit(PAGE_CLAIMED, &page->private))\n\t\t\t\tcontinue;\n\n\t\t\tzhdr = page_address(page);\n\t\t\tif (test_bit(PAGE_HEADLESS, &page->private))\n\t\t\t\tbreak;\n\n\t\t\tif (!z3fold_page_trylock(zhdr)) {\n\t\t\t\tzhdr = NULL;\n\t\t\t\tcontinue; /* can't evict at this point */\n\t\t\t}\n\t\t\tkref_get(&zhdr->refcount);\n\t\t\tlist_del_init(&zhdr->buddy);\n\t\t\tzhdr->cpu = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!zhdr)\n\t\t\tbreak;\n\n\t\tlist_del_init(&page->lru);\n\t\tspin_unlock(&pool->lock);\n\n\t\tif (!test_bit(PAGE_HEADLESS, &page->private)) {\n\t\t\t/*\n\t\t\t * We need encode the handles before unlocking, since\n\t\t\t * we can race with free that will set\n\t\t\t * (first|last)_chunks to 0\n\t\t\t */\n\t\t\tfirst_handle = 0;\n\t\t\tlast_handle = 0;\n\t\t\tmiddle_handle = 0;\n\t\t\tif (zhdr->first_chunks)\n\t\t\t\tfirst_handle = encode_handle(zhdr, FIRST);\n\t\t\tif (zhdr->middle_chunks)\n\t\t\t\tmiddle_handle = encode_handle(zhdr, MIDDLE);\n\t\t\tif (zhdr->last_chunks)\n\t\t\t\tlast_handle = encode_handle(zhdr, LAST);\n\t\t\t/*\n\t\t\t * it's safe to unlock here because we hold a\n\t\t\t * reference to this page\n\t\t\t */\n\t\t\tz3fold_page_unlock(zhdr);\n\t\t} else {\n\t\t\tfirst_handle = encode_handle(zhdr, HEADLESS);\n\t\t\tlast_handle = middle_handle = 0;\n\t\t}\n\n\t\t/* Issue the eviction callback(s) */\n\t\tif (middle_handle) {\n\t\t\tret = pool->ops->evict(pool, middle_handle);\n\t\t\tif (ret)\n\t\t\t\tgoto next;\n\t\t}\n\t\tif (first_handle) {\n\t\t\tret = pool->ops->evict(pool, first_handle);\n\t\t\tif (ret)\n\t\t\t\tgoto next;\n\t\t}\n\t\tif (last_handle) {\n\t\t\tret = pool->ops->evict(pool, last_handle);\n\t\t\tif (ret)\n\t\t\t\tgoto next;\n\t\t}\nnext:\n\t\tif (test_bit(PAGE_HEADLESS, &page->private)) {\n\t\t\tif (ret == 0) {\n\t\t\t\tfree_z3fold_page(page);\n\t\t\t\tatomic64_dec(&pool->pages_nr);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tspin_lock(&pool->lock);\n\t\t\tlist_add(&page->lru, &pool->lru);\n\t\t\tspin_unlock(&pool->lock);\n\t\t} else {\n\t\t\tz3fold_page_lock(zhdr);\n\t\t\tclear_bit(PAGE_CLAIMED, &page->private);\n\t\t\tif (kref_put(&zhdr->refcount,\n\t\t\t\t\trelease_z3fold_page_locked)) {\n\t\t\t\tatomic64_dec(&pool->pages_nr);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * if we are here, the page is still not completely\n\t\t\t * free. Take the global pool lock then to be able\n\t\t\t * to add it back to the lru list\n\t\t\t */\n\t\t\tspin_lock(&pool->lock);\n\t\t\tlist_add(&page->lru, &pool->lru);\n\t\t\tspin_unlock(&pool->lock);\n\t\t\tz3fold_page_unlock(zhdr);\n\t\t}\n\n\t\t/* We started off locked to we need to lock the pool back */\n\t\tspin_lock(&pool->lock);\n\t}\n\tspin_unlock(&pool->lock);\n\treturn -EAGAIN;\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic int z3fold_reclaim_page(struct z3fold_pool *pool, unsigned int retries)\n{\n\tint i, ret = 0;\n\tstruct z3fold_header *zhdr = NULL;\n\tstruct page *page = NULL;\n\tstruct list_head *pos;\n\tunsigned long first_handle = 0, middle_handle = 0, last_handle = 0;\n\n\tspin_lock(&pool->lock);\n\tif (!pool->ops || !pool->ops->evict || retries == 0) {\n\t\tspin_unlock(&pool->lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < retries; i++) {\n\t\tif (list_empty(&pool->lru)) {\n\t\t\tspin_unlock(&pool->lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlist_for_each_prev(pos, &pool->lru) {\n\t\t\tpage = list_entry(pos, struct page, lru);\n\n\t\t\t/* this bit could have been set by free, in which case\n\t\t\t * we pass over to the next page in the pool.\n\t\t\t */\n\t\t\tif (test_and_set_bit(PAGE_CLAIMED, &page->private))\n\t\t\t\tcontinue;\n\n\t\t\tzhdr = page_address(page);\n\t\t\tif (test_bit(PAGE_HEADLESS, &page->private))\n\t\t\t\tbreak;\n\n\t\t\tif (!z3fold_page_trylock(zhdr)) {\n\t\t\t\tzhdr = NULL;\n\t\t\t\tcontinue; /* can't evict at this point */\n\t\t\t}\n\t\t\tkref_get(&zhdr->refcount);\n\t\t\tlist_del_init(&zhdr->buddy);\n\t\t\tzhdr->cpu = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!zhdr)\n\t\t\tbreak;\n\n\t\tlist_del_init(&page->lru);\n\t\tspin_unlock(&pool->lock);\n\n\t\tif (!test_bit(PAGE_HEADLESS, &page->private)) {\n\t\t\t/*\n\t\t\t * We need encode the handles before unlocking, since\n\t\t\t * we can race with free that will set\n\t\t\t * (first|last)_chunks to 0\n\t\t\t */\n\t\t\tfirst_handle = 0;\n\t\t\tlast_handle = 0;\n\t\t\tmiddle_handle = 0;\n\t\t\tif (zhdr->first_chunks)\n\t\t\t\tfirst_handle = encode_handle(zhdr, FIRST);\n\t\t\tif (zhdr->middle_chunks)\n\t\t\t\tmiddle_handle = encode_handle(zhdr, MIDDLE);\n\t\t\tif (zhdr->last_chunks)\n\t\t\t\tlast_handle = encode_handle(zhdr, LAST);\n\t\t\t/*\n\t\t\t * it's safe to unlock here because we hold a\n\t\t\t * reference to this page\n\t\t\t */\n\t\t\tz3fold_page_unlock(zhdr);\n\t\t} else {\n\t\t\tfirst_handle = encode_handle(zhdr, HEADLESS);\n\t\t\tlast_handle = middle_handle = 0;\n\t\t}\n\n\t\t/* Issue the eviction callback(s) */\n\t\tif (middle_handle) {\n\t\t\tret = pool->ops->evict(pool, middle_handle);\n\t\t\tif (ret)\n\t\t\t\tgoto next;\n\t\t}\n\t\tif (first_handle) {\n\t\t\tret = pool->ops->evict(pool, first_handle);\n\t\t\tif (ret)\n\t\t\t\tgoto next;\n\t\t}\n\t\tif (last_handle) {\n\t\t\tret = pool->ops->evict(pool, last_handle);\n\t\t\tif (ret)\n\t\t\t\tgoto next;\n\t\t}\nnext:\n\t\tif (test_bit(PAGE_HEADLESS, &page->private)) {\n\t\t\tif (ret == 0) {\n\t\t\t\tfree_z3fold_page(page);\n\t\t\t\tatomic64_dec(&pool->pages_nr);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tspin_lock(&pool->lock);\n\t\t\tlist_add(&page->lru, &pool->lru);\n\t\t\tspin_unlock(&pool->lock);\n\t\t} else {\n\t\t\tz3fold_page_lock(zhdr);\n\t\t\tclear_bit(PAGE_CLAIMED, &page->private);\n\t\t\tif (kref_put(&zhdr->refcount,\n\t\t\t\t\trelease_z3fold_page_locked)) {\n\t\t\t\tatomic64_dec(&pool->pages_nr);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * if we are here, the page is still not completely\n\t\t\t * free. Take the global pool lock then to be able\n\t\t\t * to add it back to the lru list\n\t\t\t */\n\t\t\tspin_lock(&pool->lock);\n\t\t\tlist_add(&page->lru, &pool->lru);\n\t\t\tspin_unlock(&pool->lock);\n\t\t\tz3fold_page_unlock(zhdr);\n\t\t}\n\n\t\t/* We started off locked to we need to lock the pool back */\n\t\tspin_lock(&pool->lock);\n\t}\n\tspin_unlock(&pool->lock);\n\treturn -EAGAIN;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic int z3fold_zpool_shrink(void *pool, unsigned int pages,\n\t\t\tunsigned int *reclaimed)\n{\n\tunsigned int total = 0;\n\tint ret = -EINVAL;\n\n\twhile (total < pages) {\n\t\tret = z3fold_reclaim_page(pool, 8);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\ttotal++;\n\t}\n\n\tif (reclaimed)\n\t\t*reclaimed = total;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "z3fold_zpool_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
    "lines": "1080-1083",
    "snippet": "static void z3fold_zpool_free(void *pool, unsigned long handle)\n{\n\tz3fold_free(pool, handle);\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/sched.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "z3fold_free",
          "args": [
            "pool",
            "handle"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "z3fold_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "723-793",
          "snippet": "static void z3fold_free(struct z3fold_pool *pool, unsigned long handle)\n{\n\tstruct z3fold_header *zhdr;\n\tstruct page *page;\n\tenum buddy bud;\n\n\tzhdr = handle_to_z3fold_header(handle);\n\tpage = virt_to_page(zhdr);\n\n\tif (test_bit(PAGE_HEADLESS, &page->private)) {\n\t\t/* if a headless page is under reclaim, just leave.\n\t\t * NB: we use test_and_set_bit for a reason: if the bit\n\t\t * has not been set before, we release this page\n\t\t * immediately so we don't care about its value any more.\n\t\t */\n\t\tif (!test_and_set_bit(PAGE_CLAIMED, &page->private)) {\n\t\t\tspin_lock(&pool->lock);\n\t\t\tlist_del(&page->lru);\n\t\t\tspin_unlock(&pool->lock);\n\t\t\tfree_z3fold_page(page);\n\t\t\tatomic64_dec(&pool->pages_nr);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Non-headless case */\n\tz3fold_page_lock(zhdr);\n\tbud = handle_to_buddy(handle);\n\n\tswitch (bud) {\n\tcase FIRST:\n\t\tzhdr->first_chunks = 0;\n\t\tbreak;\n\tcase MIDDLE:\n\t\tzhdr->middle_chunks = 0;\n\t\tbreak;\n\tcase LAST:\n\t\tzhdr->last_chunks = 0;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: unknown bud %d\\n\", __func__, bud);\n\t\tWARN_ON(1);\n\t\tz3fold_page_unlock(zhdr);\n\t\treturn;\n\t}\n\n\tif (kref_put(&zhdr->refcount, release_z3fold_page_locked_list)) {\n\t\tatomic64_dec(&pool->pages_nr);\n\t\treturn;\n\t}\n\tif (test_bit(PAGE_CLAIMED, &page->private)) {\n\t\tz3fold_page_unlock(zhdr);\n\t\treturn;\n\t}\n\tif (test_and_set_bit(NEEDS_COMPACTING, &page->private)) {\n\t\tz3fold_page_unlock(zhdr);\n\t\treturn;\n\t}\n\tif (zhdr->cpu < 0 || !cpu_online(zhdr->cpu)) {\n\t\tspin_lock(&pool->lock);\n\t\tlist_del_init(&zhdr->buddy);\n\t\tspin_unlock(&pool->lock);\n\t\tzhdr->cpu = -1;\n\t\tkref_get(&zhdr->refcount);\n\t\tdo_compact_page(zhdr, true);\n\t\treturn;\n\t}\n\tkref_get(&zhdr->refcount);\n\tqueue_work_on(zhdr->cpu, pool->compact_wq, &zhdr->work);\n\tz3fold_page_unlock(zhdr);\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic void z3fold_free(struct z3fold_pool *pool, unsigned long handle)\n{\n\tstruct z3fold_header *zhdr;\n\tstruct page *page;\n\tenum buddy bud;\n\n\tzhdr = handle_to_z3fold_header(handle);\n\tpage = virt_to_page(zhdr);\n\n\tif (test_bit(PAGE_HEADLESS, &page->private)) {\n\t\t/* if a headless page is under reclaim, just leave.\n\t\t * NB: we use test_and_set_bit for a reason: if the bit\n\t\t * has not been set before, we release this page\n\t\t * immediately so we don't care about its value any more.\n\t\t */\n\t\tif (!test_and_set_bit(PAGE_CLAIMED, &page->private)) {\n\t\t\tspin_lock(&pool->lock);\n\t\t\tlist_del(&page->lru);\n\t\t\tspin_unlock(&pool->lock);\n\t\t\tfree_z3fold_page(page);\n\t\t\tatomic64_dec(&pool->pages_nr);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Non-headless case */\n\tz3fold_page_lock(zhdr);\n\tbud = handle_to_buddy(handle);\n\n\tswitch (bud) {\n\tcase FIRST:\n\t\tzhdr->first_chunks = 0;\n\t\tbreak;\n\tcase MIDDLE:\n\t\tzhdr->middle_chunks = 0;\n\t\tbreak;\n\tcase LAST:\n\t\tzhdr->last_chunks = 0;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: unknown bud %d\\n\", __func__, bud);\n\t\tWARN_ON(1);\n\t\tz3fold_page_unlock(zhdr);\n\t\treturn;\n\t}\n\n\tif (kref_put(&zhdr->refcount, release_z3fold_page_locked_list)) {\n\t\tatomic64_dec(&pool->pages_nr);\n\t\treturn;\n\t}\n\tif (test_bit(PAGE_CLAIMED, &page->private)) {\n\t\tz3fold_page_unlock(zhdr);\n\t\treturn;\n\t}\n\tif (test_and_set_bit(NEEDS_COMPACTING, &page->private)) {\n\t\tz3fold_page_unlock(zhdr);\n\t\treturn;\n\t}\n\tif (zhdr->cpu < 0 || !cpu_online(zhdr->cpu)) {\n\t\tspin_lock(&pool->lock);\n\t\tlist_del_init(&zhdr->buddy);\n\t\tspin_unlock(&pool->lock);\n\t\tzhdr->cpu = -1;\n\t\tkref_get(&zhdr->refcount);\n\t\tdo_compact_page(zhdr, true);\n\t\treturn;\n\t}\n\tkref_get(&zhdr->refcount);\n\tqueue_work_on(zhdr->cpu, pool->compact_wq, &zhdr->work);\n\tz3fold_page_unlock(zhdr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic void z3fold_zpool_free(void *pool, unsigned long handle)\n{\n\tz3fold_free(pool, handle);\n}"
  },
  {
    "function_name": "z3fold_zpool_malloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
    "lines": "1075-1079",
    "snippet": "static int z3fold_zpool_malloc(void *pool, size_t size, gfp_t gfp,\n\t\t\tunsigned long *handle)\n{\n\treturn z3fold_alloc(pool, size, gfp, handle);\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/sched.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "z3fold_alloc",
          "args": [
            "pool",
            "size",
            "gfp",
            "handle"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "z3fold_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "546-711",
          "snippet": "static int z3fold_alloc(struct z3fold_pool *pool, size_t size, gfp_t gfp,\n\t\t\tunsigned long *handle)\n{\n\tint chunks = 0, i, freechunks;\n\tstruct z3fold_header *zhdr = NULL;\n\tstruct page *page = NULL;\n\tenum buddy bud;\n\tbool can_sleep = gfpflags_allow_blocking(gfp);\n\n\tif (!size || (gfp & __GFP_HIGHMEM))\n\t\treturn -EINVAL;\n\n\tif (size > PAGE_SIZE)\n\t\treturn -ENOSPC;\n\n\tif (size > PAGE_SIZE - ZHDR_SIZE_ALIGNED - CHUNK_SIZE)\n\t\tbud = HEADLESS;\n\telse {\n\t\tstruct list_head *unbuddied;\n\t\tchunks = size_to_chunks(size);\n\nlookup:\n\t\t/* First, try to find an unbuddied z3fold page. */\n\t\tunbuddied = get_cpu_ptr(pool->unbuddied);\n\t\tfor_each_unbuddied_list(i, chunks) {\n\t\t\tstruct list_head *l = &unbuddied[i];\n\n\t\t\tzhdr = list_first_entry_or_null(READ_ONCE(l),\n\t\t\t\t\t\tstruct z3fold_header, buddy);\n\n\t\t\tif (!zhdr)\n\t\t\t\tcontinue;\n\n\t\t\t/* Re-check under lock. */\n\t\t\tspin_lock(&pool->lock);\n\t\t\tl = &unbuddied[i];\n\t\t\tif (unlikely(zhdr != list_first_entry(READ_ONCE(l),\n\t\t\t\t\tstruct z3fold_header, buddy)) ||\n\t\t\t    !z3fold_page_trylock(zhdr)) {\n\t\t\t\tspin_unlock(&pool->lock);\n\t\t\t\tput_cpu_ptr(pool->unbuddied);\n\t\t\t\tgoto lookup;\n\t\t\t}\n\t\t\tlist_del_init(&zhdr->buddy);\n\t\t\tzhdr->cpu = -1;\n\t\t\tspin_unlock(&pool->lock);\n\n\t\t\tpage = virt_to_page(zhdr);\n\t\t\tif (test_bit(NEEDS_COMPACTING, &page->private)) {\n\t\t\t\tz3fold_page_unlock(zhdr);\n\t\t\t\tzhdr = NULL;\n\t\t\t\tput_cpu_ptr(pool->unbuddied);\n\t\t\t\tif (can_sleep)\n\t\t\t\t\tcond_resched();\n\t\t\t\tgoto lookup;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * this page could not be removed from its unbuddied\n\t\t\t * list while pool lock was held, and then we've taken\n\t\t\t * page lock so kref_put could not be called before\n\t\t\t * we got here, so it's safe to just call kref_get()\n\t\t\t */\n\t\t\tkref_get(&zhdr->refcount);\n\t\t\tbreak;\n\t\t}\n\t\tput_cpu_ptr(pool->unbuddied);\n\n\t\tif (zhdr) {\n\t\t\tif (zhdr->first_chunks == 0) {\n\t\t\t\tif (zhdr->middle_chunks != 0 &&\n\t\t\t\t    chunks >= zhdr->start_middle)\n\t\t\t\t\tbud = LAST;\n\t\t\t\telse\n\t\t\t\t\tbud = FIRST;\n\t\t\t} else if (zhdr->last_chunks == 0)\n\t\t\t\tbud = LAST;\n\t\t\telse if (zhdr->middle_chunks == 0)\n\t\t\t\tbud = MIDDLE;\n\t\t\telse {\n\t\t\t\tif (kref_put(&zhdr->refcount,\n\t\t\t\t\t     release_z3fold_page_locked))\n\t\t\t\t\tatomic64_dec(&pool->pages_nr);\n\t\t\t\telse\n\t\t\t\t\tz3fold_page_unlock(zhdr);\n\t\t\t\tpr_err(\"No free chunks in unbuddied\\n\");\n\t\t\t\tWARN_ON(1);\n\t\t\t\tgoto lookup;\n\t\t\t}\n\t\t\tgoto found;\n\t\t}\n\t\tbud = FIRST;\n\t}\n\n\tpage = NULL;\n\tif (can_sleep) {\n\t\tspin_lock(&pool->stale_lock);\n\t\tzhdr = list_first_entry_or_null(&pool->stale,\n\t\t\t\t\t\tstruct z3fold_header, buddy);\n\t\t/*\n\t\t * Before allocating a page, let's see if we can take one from\n\t\t * the stale pages list. cancel_work_sync() can sleep so we\n\t\t * limit this case to the contexts where we can sleep\n\t\t */\n\t\tif (zhdr) {\n\t\t\tlist_del(&zhdr->buddy);\n\t\t\tspin_unlock(&pool->stale_lock);\n\t\t\tcancel_work_sync(&zhdr->work);\n\t\t\tpage = virt_to_page(zhdr);\n\t\t} else {\n\t\t\tspin_unlock(&pool->stale_lock);\n\t\t}\n\t}\n\tif (!page)\n\t\tpage = alloc_page(gfp);\n\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tatomic64_inc(&pool->pages_nr);\n\tzhdr = init_z3fold_page(page, pool);\n\n\tif (bud == HEADLESS) {\n\t\tset_bit(PAGE_HEADLESS, &page->private);\n\t\tgoto headless;\n\t}\n\tz3fold_page_lock(zhdr);\n\nfound:\n\tif (bud == FIRST)\n\t\tzhdr->first_chunks = chunks;\n\telse if (bud == LAST)\n\t\tzhdr->last_chunks = chunks;\n\telse {\n\t\tzhdr->middle_chunks = chunks;\n\t\tzhdr->start_middle = zhdr->first_chunks + ZHDR_CHUNKS;\n\t}\n\n\tif (zhdr->first_chunks == 0 || zhdr->last_chunks == 0 ||\n\t\t\tzhdr->middle_chunks == 0) {\n\t\tstruct list_head *unbuddied = get_cpu_ptr(pool->unbuddied);\n\n\t\t/* Add to unbuddied list */\n\t\tfreechunks = num_free_chunks(zhdr);\n\t\tspin_lock(&pool->lock);\n\t\tlist_add(&zhdr->buddy, &unbuddied[freechunks]);\n\t\tspin_unlock(&pool->lock);\n\t\tzhdr->cpu = smp_processor_id();\n\t\tput_cpu_ptr(pool->unbuddied);\n\t}\n\nheadless:\n\tspin_lock(&pool->lock);\n\t/* Add/move z3fold page to beginning of LRU */\n\tif (!list_empty(&page->lru))\n\t\tlist_del(&page->lru);\n\n\tlist_add(&page->lru, &pool->lru);\n\n\t*handle = encode_handle(zhdr, bud);\n\tspin_unlock(&pool->lock);\n\tif (bud != HEADLESS)\n\t\tz3fold_page_unlock(zhdr);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define ZHDR_CHUNKS\t(ZHDR_SIZE_ALIGNED >> CHUNK_SHIFT)",
            "#define ZHDR_SIZE_ALIGNED round_up(sizeof(struct z3fold_header), CHUNK_SIZE)",
            "#define CHUNK_SIZE\t(1 << CHUNK_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\n#define ZHDR_CHUNKS\t(ZHDR_SIZE_ALIGNED >> CHUNK_SHIFT)\n#define ZHDR_SIZE_ALIGNED round_up(sizeof(struct z3fold_header), CHUNK_SIZE)\n#define CHUNK_SIZE\t(1 << CHUNK_SHIFT)\n\nstatic int z3fold_alloc(struct z3fold_pool *pool, size_t size, gfp_t gfp,\n\t\t\tunsigned long *handle)\n{\n\tint chunks = 0, i, freechunks;\n\tstruct z3fold_header *zhdr = NULL;\n\tstruct page *page = NULL;\n\tenum buddy bud;\n\tbool can_sleep = gfpflags_allow_blocking(gfp);\n\n\tif (!size || (gfp & __GFP_HIGHMEM))\n\t\treturn -EINVAL;\n\n\tif (size > PAGE_SIZE)\n\t\treturn -ENOSPC;\n\n\tif (size > PAGE_SIZE - ZHDR_SIZE_ALIGNED - CHUNK_SIZE)\n\t\tbud = HEADLESS;\n\telse {\n\t\tstruct list_head *unbuddied;\n\t\tchunks = size_to_chunks(size);\n\nlookup:\n\t\t/* First, try to find an unbuddied z3fold page. */\n\t\tunbuddied = get_cpu_ptr(pool->unbuddied);\n\t\tfor_each_unbuddied_list(i, chunks) {\n\t\t\tstruct list_head *l = &unbuddied[i];\n\n\t\t\tzhdr = list_first_entry_or_null(READ_ONCE(l),\n\t\t\t\t\t\tstruct z3fold_header, buddy);\n\n\t\t\tif (!zhdr)\n\t\t\t\tcontinue;\n\n\t\t\t/* Re-check under lock. */\n\t\t\tspin_lock(&pool->lock);\n\t\t\tl = &unbuddied[i];\n\t\t\tif (unlikely(zhdr != list_first_entry(READ_ONCE(l),\n\t\t\t\t\tstruct z3fold_header, buddy)) ||\n\t\t\t    !z3fold_page_trylock(zhdr)) {\n\t\t\t\tspin_unlock(&pool->lock);\n\t\t\t\tput_cpu_ptr(pool->unbuddied);\n\t\t\t\tgoto lookup;\n\t\t\t}\n\t\t\tlist_del_init(&zhdr->buddy);\n\t\t\tzhdr->cpu = -1;\n\t\t\tspin_unlock(&pool->lock);\n\n\t\t\tpage = virt_to_page(zhdr);\n\t\t\tif (test_bit(NEEDS_COMPACTING, &page->private)) {\n\t\t\t\tz3fold_page_unlock(zhdr);\n\t\t\t\tzhdr = NULL;\n\t\t\t\tput_cpu_ptr(pool->unbuddied);\n\t\t\t\tif (can_sleep)\n\t\t\t\t\tcond_resched();\n\t\t\t\tgoto lookup;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * this page could not be removed from its unbuddied\n\t\t\t * list while pool lock was held, and then we've taken\n\t\t\t * page lock so kref_put could not be called before\n\t\t\t * we got here, so it's safe to just call kref_get()\n\t\t\t */\n\t\t\tkref_get(&zhdr->refcount);\n\t\t\tbreak;\n\t\t}\n\t\tput_cpu_ptr(pool->unbuddied);\n\n\t\tif (zhdr) {\n\t\t\tif (zhdr->first_chunks == 0) {\n\t\t\t\tif (zhdr->middle_chunks != 0 &&\n\t\t\t\t    chunks >= zhdr->start_middle)\n\t\t\t\t\tbud = LAST;\n\t\t\t\telse\n\t\t\t\t\tbud = FIRST;\n\t\t\t} else if (zhdr->last_chunks == 0)\n\t\t\t\tbud = LAST;\n\t\t\telse if (zhdr->middle_chunks == 0)\n\t\t\t\tbud = MIDDLE;\n\t\t\telse {\n\t\t\t\tif (kref_put(&zhdr->refcount,\n\t\t\t\t\t     release_z3fold_page_locked))\n\t\t\t\t\tatomic64_dec(&pool->pages_nr);\n\t\t\t\telse\n\t\t\t\t\tz3fold_page_unlock(zhdr);\n\t\t\t\tpr_err(\"No free chunks in unbuddied\\n\");\n\t\t\t\tWARN_ON(1);\n\t\t\t\tgoto lookup;\n\t\t\t}\n\t\t\tgoto found;\n\t\t}\n\t\tbud = FIRST;\n\t}\n\n\tpage = NULL;\n\tif (can_sleep) {\n\t\tspin_lock(&pool->stale_lock);\n\t\tzhdr = list_first_entry_or_null(&pool->stale,\n\t\t\t\t\t\tstruct z3fold_header, buddy);\n\t\t/*\n\t\t * Before allocating a page, let's see if we can take one from\n\t\t * the stale pages list. cancel_work_sync() can sleep so we\n\t\t * limit this case to the contexts where we can sleep\n\t\t */\n\t\tif (zhdr) {\n\t\t\tlist_del(&zhdr->buddy);\n\t\t\tspin_unlock(&pool->stale_lock);\n\t\t\tcancel_work_sync(&zhdr->work);\n\t\t\tpage = virt_to_page(zhdr);\n\t\t} else {\n\t\t\tspin_unlock(&pool->stale_lock);\n\t\t}\n\t}\n\tif (!page)\n\t\tpage = alloc_page(gfp);\n\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tatomic64_inc(&pool->pages_nr);\n\tzhdr = init_z3fold_page(page, pool);\n\n\tif (bud == HEADLESS) {\n\t\tset_bit(PAGE_HEADLESS, &page->private);\n\t\tgoto headless;\n\t}\n\tz3fold_page_lock(zhdr);\n\nfound:\n\tif (bud == FIRST)\n\t\tzhdr->first_chunks = chunks;\n\telse if (bud == LAST)\n\t\tzhdr->last_chunks = chunks;\n\telse {\n\t\tzhdr->middle_chunks = chunks;\n\t\tzhdr->start_middle = zhdr->first_chunks + ZHDR_CHUNKS;\n\t}\n\n\tif (zhdr->first_chunks == 0 || zhdr->last_chunks == 0 ||\n\t\t\tzhdr->middle_chunks == 0) {\n\t\tstruct list_head *unbuddied = get_cpu_ptr(pool->unbuddied);\n\n\t\t/* Add to unbuddied list */\n\t\tfreechunks = num_free_chunks(zhdr);\n\t\tspin_lock(&pool->lock);\n\t\tlist_add(&zhdr->buddy, &unbuddied[freechunks]);\n\t\tspin_unlock(&pool->lock);\n\t\tzhdr->cpu = smp_processor_id();\n\t\tput_cpu_ptr(pool->unbuddied);\n\t}\n\nheadless:\n\tspin_lock(&pool->lock);\n\t/* Add/move z3fold page to beginning of LRU */\n\tif (!list_empty(&page->lru))\n\t\tlist_del(&page->lru);\n\n\tlist_add(&page->lru, &pool->lru);\n\n\t*handle = encode_handle(zhdr, bud);\n\tspin_unlock(&pool->lock);\n\tif (bud != HEADLESS)\n\t\tz3fold_page_unlock(zhdr);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic int z3fold_zpool_malloc(void *pool, size_t size, gfp_t gfp,\n\t\t\tunsigned long *handle)\n{\n\treturn z3fold_alloc(pool, size, gfp, handle);\n}"
  },
  {
    "function_name": "z3fold_zpool_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
    "lines": "1070-1073",
    "snippet": "static void z3fold_zpool_destroy(void *pool)\n{\n\tz3fold_destroy_pool(pool);\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/sched.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "z3fold_destroy_pool",
          "args": [
            "pool"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "z3fold_destroy_pool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "520-525",
          "snippet": "static void z3fold_destroy_pool(struct z3fold_pool *pool)\n{\n\tdestroy_workqueue(pool->release_wq);\n\tdestroy_workqueue(pool->compact_wq);\n\tkfree(pool);\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic void z3fold_destroy_pool(struct z3fold_pool *pool)\n{\n\tdestroy_workqueue(pool->release_wq);\n\tdestroy_workqueue(pool->compact_wq);\n\tkfree(pool);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic void z3fold_zpool_destroy(void *pool)\n{\n\tz3fold_destroy_pool(pool);\n}"
  },
  {
    "function_name": "z3fold_zpool_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
    "lines": "1055-1068",
    "snippet": "static void *z3fold_zpool_create(const char *name, gfp_t gfp,\n\t\t\t       const struct zpool_ops *zpool_ops,\n\t\t\t       struct zpool *zpool)\n{\n\tstruct z3fold_pool *pool;\n\n\tpool = z3fold_create_pool(name, gfp,\n\t\t\t\tzpool_ops ? &z3fold_zpool_ops : NULL);\n\tif (pool) {\n\t\tpool->zpool = zpool;\n\t\tpool->zpool_ops = zpool_ops;\n\t}\n\treturn pool;\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/sched.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct z3fold_ops z3fold_zpool_ops = {\n\t.evict =\tz3fold_zpool_evict\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "z3fold_create_pool",
          "args": [
            "name",
            "gfp",
            "zpool_ops ? &z3fold_zpool_ops : NULL"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "z3fold_create_pool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "470-512",
          "snippet": "static struct z3fold_pool *z3fold_create_pool(const char *name, gfp_t gfp,\n\t\tconst struct z3fold_ops *ops)\n{\n\tstruct z3fold_pool *pool = NULL;\n\tint i, cpu;\n\n\tpool = kzalloc(sizeof(struct z3fold_pool), gfp);\n\tif (!pool)\n\t\tgoto out;\n\tspin_lock_init(&pool->lock);\n\tspin_lock_init(&pool->stale_lock);\n\tpool->unbuddied = __alloc_percpu(sizeof(struct list_head)*NCHUNKS, 2);\n\tif (!pool->unbuddied)\n\t\tgoto out_pool;\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct list_head *unbuddied =\n\t\t\t\tper_cpu_ptr(pool->unbuddied, cpu);\n\t\tfor_each_unbuddied_list(i, 0)\n\t\t\tINIT_LIST_HEAD(&unbuddied[i]);\n\t}\n\tINIT_LIST_HEAD(&pool->lru);\n\tINIT_LIST_HEAD(&pool->stale);\n\tatomic64_set(&pool->pages_nr, 0);\n\tpool->name = name;\n\tpool->compact_wq = create_singlethread_workqueue(pool->name);\n\tif (!pool->compact_wq)\n\t\tgoto out_unbuddied;\n\tpool->release_wq = create_singlethread_workqueue(pool->name);\n\tif (!pool->release_wq)\n\t\tgoto out_wq;\n\tINIT_WORK(&pool->work, free_pages_work);\n\tpool->ops = ops;\n\treturn pool;\n\nout_wq:\n\tdestroy_workqueue(pool->compact_wq);\nout_unbuddied:\n\tfree_percpu(pool->unbuddied);\nout_pool:\n\tkfree(pool);\nout:\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define NCHUNKS\t\t((PAGE_SIZE - ZHDR_SIZE_ALIGNED) >> CHUNK_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\n#define NCHUNKS\t\t((PAGE_SIZE - ZHDR_SIZE_ALIGNED) >> CHUNK_SHIFT)\n\nstatic struct z3fold_pool *z3fold_create_pool(const char *name, gfp_t gfp,\n\t\tconst struct z3fold_ops *ops)\n{\n\tstruct z3fold_pool *pool = NULL;\n\tint i, cpu;\n\n\tpool = kzalloc(sizeof(struct z3fold_pool), gfp);\n\tif (!pool)\n\t\tgoto out;\n\tspin_lock_init(&pool->lock);\n\tspin_lock_init(&pool->stale_lock);\n\tpool->unbuddied = __alloc_percpu(sizeof(struct list_head)*NCHUNKS, 2);\n\tif (!pool->unbuddied)\n\t\tgoto out_pool;\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct list_head *unbuddied =\n\t\t\t\tper_cpu_ptr(pool->unbuddied, cpu);\n\t\tfor_each_unbuddied_list(i, 0)\n\t\t\tINIT_LIST_HEAD(&unbuddied[i]);\n\t}\n\tINIT_LIST_HEAD(&pool->lru);\n\tINIT_LIST_HEAD(&pool->stale);\n\tatomic64_set(&pool->pages_nr, 0);\n\tpool->name = name;\n\tpool->compact_wq = create_singlethread_workqueue(pool->name);\n\tif (!pool->compact_wq)\n\t\tgoto out_unbuddied;\n\tpool->release_wq = create_singlethread_workqueue(pool->name);\n\tif (!pool->release_wq)\n\t\tgoto out_wq;\n\tINIT_WORK(&pool->work, free_pages_work);\n\tpool->ops = ops;\n\treturn pool;\n\nout_wq:\n\tdestroy_workqueue(pool->compact_wq);\nout_unbuddied:\n\tfree_percpu(pool->unbuddied);\nout_pool:\n\tkfree(pool);\nout:\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic const struct z3fold_ops z3fold_zpool_ops = {\n\t.evict =\tz3fold_zpool_evict\n};\n\nstatic void *z3fold_zpool_create(const char *name, gfp_t gfp,\n\t\t\t       const struct zpool_ops *zpool_ops,\n\t\t\t       struct zpool *zpool)\n{\n\tstruct z3fold_pool *pool;\n\n\tpool = z3fold_create_pool(name, gfp,\n\t\t\t\tzpool_ops ? &z3fold_zpool_ops : NULL);\n\tif (pool) {\n\t\tpool->zpool = zpool;\n\t\tpool->zpool_ops = zpool_ops;\n\t}\n\treturn pool;\n}"
  },
  {
    "function_name": "z3fold_zpool_evict",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
    "lines": "1043-1049",
    "snippet": "static int z3fold_zpool_evict(struct z3fold_pool *pool, unsigned long handle)\n{\n\tif (pool->zpool && pool->zpool_ops && pool->zpool_ops->evict)\n\t\treturn pool->zpool_ops->evict(pool->zpool, handle);\n\telse\n\t\treturn -ENOENT;\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/sched.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pool->zpool_ops->evict",
          "args": [
            "pool->zpool",
            "handle"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic int z3fold_zpool_evict(struct z3fold_pool *pool, unsigned long handle)\n{\n\tif (pool->zpool && pool->zpool_ops && pool->zpool_ops->evict)\n\t\treturn pool->zpool_ops->evict(pool->zpool, handle);\n\telse\n\t\treturn -ENOENT;\n}"
  },
  {
    "function_name": "z3fold_get_pool_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
    "lines": "1034-1037",
    "snippet": "static u64 z3fold_get_pool_size(struct z3fold_pool *pool)\n{\n\treturn atomic64_read(&pool->pages_nr);\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/sched.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&pool->pages_nr"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic u64 z3fold_get_pool_size(struct z3fold_pool *pool)\n{\n\treturn atomic64_read(&pool->pages_nr);\n}"
  },
  {
    "function_name": "z3fold_unmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
    "lines": "1009-1026",
    "snippet": "static void z3fold_unmap(struct z3fold_pool *pool, unsigned long handle)\n{\n\tstruct z3fold_header *zhdr;\n\tstruct page *page;\n\tenum buddy buddy;\n\n\tzhdr = handle_to_z3fold_header(handle);\n\tpage = virt_to_page(zhdr);\n\n\tif (test_bit(PAGE_HEADLESS, &page->private))\n\t\treturn;\n\n\tz3fold_page_lock(zhdr);\n\tbuddy = handle_to_buddy(handle);\n\tif (buddy == MIDDLE)\n\t\tclear_bit(MIDDLE_CHUNK_MAPPED, &page->private);\n\tz3fold_page_unlock(zhdr);\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/sched.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "z3fold_page_unlock",
          "args": [
            "zhdr"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "z3fold_page_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "213-216",
          "snippet": "static inline void z3fold_page_unlock(struct z3fold_header *zhdr)\n{\n\tspin_unlock(&zhdr->page_lock);\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic inline void z3fold_page_unlock(struct z3fold_header *zhdr)\n{\n\tspin_unlock(&zhdr->page_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "MIDDLE_CHUNK_MAPPED",
            "&page->private"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "clear_bit_unlock_is_negative_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1171-1176",
          "snippet": "static inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_to_buddy",
          "args": [
            "handle"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "handle_to_buddy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "252-256",
          "snippet": "static enum buddy handle_to_buddy(unsigned long handle)\n{\n\tstruct z3fold_header *zhdr = handle_to_z3fold_header(handle);\n\treturn (handle - zhdr->first_num) & BUDDY_MASK;\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define BUDDY_MASK\t(0x3)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\n#define BUDDY_MASK\t(0x3)\n\nstatic enum buddy handle_to_buddy(unsigned long handle)\n{\n\tstruct z3fold_header *zhdr = handle_to_z3fold_header(handle);\n\treturn (handle - zhdr->first_num) & BUDDY_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "z3fold_page_lock",
          "args": [
            "zhdr"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "release_z3fold_page_locked_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "294-304",
          "snippet": "static void release_z3fold_page_locked_list(struct kref *ref)\n{\n\tstruct z3fold_header *zhdr = container_of(ref, struct z3fold_header,\n\t\t\t\t\t       refcount);\n\tspin_lock(&zhdr->pool->lock);\n\tlist_del_init(&zhdr->buddy);\n\tspin_unlock(&zhdr->pool->lock);\n\n\tWARN_ON(z3fold_page_trylock(zhdr));\n\t__release_z3fold_page(zhdr, true);\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic void release_z3fold_page_locked_list(struct kref *ref)\n{\n\tstruct z3fold_header *zhdr = container_of(ref, struct z3fold_header,\n\t\t\t\t\t       refcount);\n\tspin_lock(&zhdr->pool->lock);\n\tlist_del_init(&zhdr->buddy);\n\tspin_unlock(&zhdr->pool->lock);\n\n\tWARN_ON(z3fold_page_trylock(zhdr));\n\t__release_z3fold_page(zhdr, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "PAGE_HEADLESS",
            "&page->private"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "zhdr"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_to_z3fold_header",
          "args": [
            "handle"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "handle_to_z3fold_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "236-239",
          "snippet": "static struct z3fold_header *handle_to_z3fold_header(unsigned long handle)\n{\n\treturn (struct z3fold_header *)(handle & PAGE_MASK);\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic struct z3fold_header *handle_to_z3fold_header(unsigned long handle)\n{\n\treturn (struct z3fold_header *)(handle & PAGE_MASK);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic void z3fold_unmap(struct z3fold_pool *pool, unsigned long handle)\n{\n\tstruct z3fold_header *zhdr;\n\tstruct page *page;\n\tenum buddy buddy;\n\n\tzhdr = handle_to_z3fold_header(handle);\n\tpage = virt_to_page(zhdr);\n\n\tif (test_bit(PAGE_HEADLESS, &page->private))\n\t\treturn;\n\n\tz3fold_page_lock(zhdr);\n\tbuddy = handle_to_buddy(handle);\n\tif (buddy == MIDDLE)\n\t\tclear_bit(MIDDLE_CHUNK_MAPPED, &page->private);\n\tz3fold_page_unlock(zhdr);\n}"
  },
  {
    "function_name": "z3fold_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
    "lines": "965-1002",
    "snippet": "static void *z3fold_map(struct z3fold_pool *pool, unsigned long handle)\n{\n\tstruct z3fold_header *zhdr;\n\tstruct page *page;\n\tvoid *addr;\n\tenum buddy buddy;\n\n\tzhdr = handle_to_z3fold_header(handle);\n\taddr = zhdr;\n\tpage = virt_to_page(zhdr);\n\n\tif (test_bit(PAGE_HEADLESS, &page->private))\n\t\tgoto out;\n\n\tz3fold_page_lock(zhdr);\n\tbuddy = handle_to_buddy(handle);\n\tswitch (buddy) {\n\tcase FIRST:\n\t\taddr += ZHDR_SIZE_ALIGNED;\n\t\tbreak;\n\tcase MIDDLE:\n\t\taddr += zhdr->start_middle << CHUNK_SHIFT;\n\t\tset_bit(MIDDLE_CHUNK_MAPPED, &page->private);\n\t\tbreak;\n\tcase LAST:\n\t\taddr += PAGE_SIZE - (handle_to_chunks(handle) << CHUNK_SHIFT);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unknown buddy id %d\\n\", buddy);\n\t\tWARN_ON(1);\n\t\taddr = NULL;\n\t\tbreak;\n\t}\n\n\tz3fold_page_unlock(zhdr);\nout:\n\treturn addr;\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/sched.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define ZHDR_SIZE_ALIGNED round_up(sizeof(struct z3fold_header), CHUNK_SIZE)",
      "#define CHUNK_SHIFT\t(PAGE_SHIFT - NCHUNKS_ORDER)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "z3fold_page_unlock",
          "args": [
            "zhdr"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "z3fold_page_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "213-216",
          "snippet": "static inline void z3fold_page_unlock(struct z3fold_header *zhdr)\n{\n\tspin_unlock(&zhdr->page_lock);\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic inline void z3fold_page_unlock(struct z3fold_header *zhdr)\n{\n\tspin_unlock(&zhdr->page_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"unknown buddy id %d\\n\"",
            "buddy"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_to_chunks",
          "args": [
            "handle"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "handle_to_chunks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "242-245",
          "snippet": "static unsigned short handle_to_chunks(unsigned long handle)\n{\n\treturn (handle & ~PAGE_MASK) >> BUDDY_SHIFT;\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define BUDDY_SHIFT\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\n#define BUDDY_SHIFT\t2\n\nstatic unsigned short handle_to_chunks(unsigned long handle)\n{\n\treturn (handle & ~PAGE_MASK) >> BUDDY_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "MIDDLE_CHUNK_MAPPED",
            "&page->private"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_to_buddy",
          "args": [
            "handle"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "handle_to_buddy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "252-256",
          "snippet": "static enum buddy handle_to_buddy(unsigned long handle)\n{\n\tstruct z3fold_header *zhdr = handle_to_z3fold_header(handle);\n\treturn (handle - zhdr->first_num) & BUDDY_MASK;\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define BUDDY_MASK\t(0x3)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\n#define BUDDY_MASK\t(0x3)\n\nstatic enum buddy handle_to_buddy(unsigned long handle)\n{\n\tstruct z3fold_header *zhdr = handle_to_z3fold_header(handle);\n\treturn (handle - zhdr->first_num) & BUDDY_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "z3fold_page_lock",
          "args": [
            "zhdr"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "release_z3fold_page_locked_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "294-304",
          "snippet": "static void release_z3fold_page_locked_list(struct kref *ref)\n{\n\tstruct z3fold_header *zhdr = container_of(ref, struct z3fold_header,\n\t\t\t\t\t       refcount);\n\tspin_lock(&zhdr->pool->lock);\n\tlist_del_init(&zhdr->buddy);\n\tspin_unlock(&zhdr->pool->lock);\n\n\tWARN_ON(z3fold_page_trylock(zhdr));\n\t__release_z3fold_page(zhdr, true);\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic void release_z3fold_page_locked_list(struct kref *ref)\n{\n\tstruct z3fold_header *zhdr = container_of(ref, struct z3fold_header,\n\t\t\t\t\t       refcount);\n\tspin_lock(&zhdr->pool->lock);\n\tlist_del_init(&zhdr->buddy);\n\tspin_unlock(&zhdr->pool->lock);\n\n\tWARN_ON(z3fold_page_trylock(zhdr));\n\t__release_z3fold_page(zhdr, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "PAGE_HEADLESS",
            "&page->private"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "zhdr"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_to_z3fold_header",
          "args": [
            "handle"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "handle_to_z3fold_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "236-239",
          "snippet": "static struct z3fold_header *handle_to_z3fold_header(unsigned long handle)\n{\n\treturn (struct z3fold_header *)(handle & PAGE_MASK);\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic struct z3fold_header *handle_to_z3fold_header(unsigned long handle)\n{\n\treturn (struct z3fold_header *)(handle & PAGE_MASK);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\n#define ZHDR_SIZE_ALIGNED round_up(sizeof(struct z3fold_header), CHUNK_SIZE)\n#define CHUNK_SHIFT\t(PAGE_SHIFT - NCHUNKS_ORDER)\n\nstatic void *z3fold_map(struct z3fold_pool *pool, unsigned long handle)\n{\n\tstruct z3fold_header *zhdr;\n\tstruct page *page;\n\tvoid *addr;\n\tenum buddy buddy;\n\n\tzhdr = handle_to_z3fold_header(handle);\n\taddr = zhdr;\n\tpage = virt_to_page(zhdr);\n\n\tif (test_bit(PAGE_HEADLESS, &page->private))\n\t\tgoto out;\n\n\tz3fold_page_lock(zhdr);\n\tbuddy = handle_to_buddy(handle);\n\tswitch (buddy) {\n\tcase FIRST:\n\t\taddr += ZHDR_SIZE_ALIGNED;\n\t\tbreak;\n\tcase MIDDLE:\n\t\taddr += zhdr->start_middle << CHUNK_SHIFT;\n\t\tset_bit(MIDDLE_CHUNK_MAPPED, &page->private);\n\t\tbreak;\n\tcase LAST:\n\t\taddr += PAGE_SIZE - (handle_to_chunks(handle) << CHUNK_SHIFT);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unknown buddy id %d\\n\", buddy);\n\t\tWARN_ON(1);\n\t\taddr = NULL;\n\t\tbreak;\n\t}\n\n\tz3fold_page_unlock(zhdr);\nout:\n\treturn addr;\n}"
  },
  {
    "function_name": "z3fold_reclaim_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
    "lines": "831-953",
    "snippet": "static int z3fold_reclaim_page(struct z3fold_pool *pool, unsigned int retries)\n{\n\tint i, ret = 0;\n\tstruct z3fold_header *zhdr = NULL;\n\tstruct page *page = NULL;\n\tstruct list_head *pos;\n\tunsigned long first_handle = 0, middle_handle = 0, last_handle = 0;\n\n\tspin_lock(&pool->lock);\n\tif (!pool->ops || !pool->ops->evict || retries == 0) {\n\t\tspin_unlock(&pool->lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < retries; i++) {\n\t\tif (list_empty(&pool->lru)) {\n\t\t\tspin_unlock(&pool->lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlist_for_each_prev(pos, &pool->lru) {\n\t\t\tpage = list_entry(pos, struct page, lru);\n\n\t\t\t/* this bit could have been set by free, in which case\n\t\t\t * we pass over to the next page in the pool.\n\t\t\t */\n\t\t\tif (test_and_set_bit(PAGE_CLAIMED, &page->private))\n\t\t\t\tcontinue;\n\n\t\t\tzhdr = page_address(page);\n\t\t\tif (test_bit(PAGE_HEADLESS, &page->private))\n\t\t\t\tbreak;\n\n\t\t\tif (!z3fold_page_trylock(zhdr)) {\n\t\t\t\tzhdr = NULL;\n\t\t\t\tcontinue; /* can't evict at this point */\n\t\t\t}\n\t\t\tkref_get(&zhdr->refcount);\n\t\t\tlist_del_init(&zhdr->buddy);\n\t\t\tzhdr->cpu = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!zhdr)\n\t\t\tbreak;\n\n\t\tlist_del_init(&page->lru);\n\t\tspin_unlock(&pool->lock);\n\n\t\tif (!test_bit(PAGE_HEADLESS, &page->private)) {\n\t\t\t/*\n\t\t\t * We need encode the handles before unlocking, since\n\t\t\t * we can race with free that will set\n\t\t\t * (first|last)_chunks to 0\n\t\t\t */\n\t\t\tfirst_handle = 0;\n\t\t\tlast_handle = 0;\n\t\t\tmiddle_handle = 0;\n\t\t\tif (zhdr->first_chunks)\n\t\t\t\tfirst_handle = encode_handle(zhdr, FIRST);\n\t\t\tif (zhdr->middle_chunks)\n\t\t\t\tmiddle_handle = encode_handle(zhdr, MIDDLE);\n\t\t\tif (zhdr->last_chunks)\n\t\t\t\tlast_handle = encode_handle(zhdr, LAST);\n\t\t\t/*\n\t\t\t * it's safe to unlock here because we hold a\n\t\t\t * reference to this page\n\t\t\t */\n\t\t\tz3fold_page_unlock(zhdr);\n\t\t} else {\n\t\t\tfirst_handle = encode_handle(zhdr, HEADLESS);\n\t\t\tlast_handle = middle_handle = 0;\n\t\t}\n\n\t\t/* Issue the eviction callback(s) */\n\t\tif (middle_handle) {\n\t\t\tret = pool->ops->evict(pool, middle_handle);\n\t\t\tif (ret)\n\t\t\t\tgoto next;\n\t\t}\n\t\tif (first_handle) {\n\t\t\tret = pool->ops->evict(pool, first_handle);\n\t\t\tif (ret)\n\t\t\t\tgoto next;\n\t\t}\n\t\tif (last_handle) {\n\t\t\tret = pool->ops->evict(pool, last_handle);\n\t\t\tif (ret)\n\t\t\t\tgoto next;\n\t\t}\nnext:\n\t\tif (test_bit(PAGE_HEADLESS, &page->private)) {\n\t\t\tif (ret == 0) {\n\t\t\t\tfree_z3fold_page(page);\n\t\t\t\tatomic64_dec(&pool->pages_nr);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tspin_lock(&pool->lock);\n\t\t\tlist_add(&page->lru, &pool->lru);\n\t\t\tspin_unlock(&pool->lock);\n\t\t} else {\n\t\t\tz3fold_page_lock(zhdr);\n\t\t\tclear_bit(PAGE_CLAIMED, &page->private);\n\t\t\tif (kref_put(&zhdr->refcount,\n\t\t\t\t\trelease_z3fold_page_locked)) {\n\t\t\t\tatomic64_dec(&pool->pages_nr);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * if we are here, the page is still not completely\n\t\t\t * free. Take the global pool lock then to be able\n\t\t\t * to add it back to the lru list\n\t\t\t */\n\t\t\tspin_lock(&pool->lock);\n\t\t\tlist_add(&page->lru, &pool->lru);\n\t\t\tspin_unlock(&pool->lock);\n\t\t\tz3fold_page_unlock(zhdr);\n\t\t}\n\n\t\t/* We started off locked to we need to lock the pool back */\n\t\tspin_lock(&pool->lock);\n\t}\n\tspin_unlock(&pool->lock);\n\treturn -EAGAIN;\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/sched.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pool->lock"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pool->lock"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "z3fold_page_unlock",
          "args": [
            "zhdr"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "z3fold_page_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "213-216",
          "snippet": "static inline void z3fold_page_unlock(struct z3fold_header *zhdr)\n{\n\tspin_unlock(&zhdr->page_lock);\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic inline void z3fold_page_unlock(struct z3fold_header *zhdr)\n{\n\tspin_unlock(&zhdr->page_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pool->lock"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&page->lru",
            "&pool->lru"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pool->lock"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_dec",
          "args": [
            "&pool->pages_nr"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&zhdr->refcount",
            "release_z3fold_page_locked"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "PAGE_CLAIMED",
            "&page->private"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "clear_bit_unlock_is_negative_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1171-1176",
          "snippet": "static inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "z3fold_page_lock",
          "args": [
            "zhdr"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "release_z3fold_page_locked_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "294-304",
          "snippet": "static void release_z3fold_page_locked_list(struct kref *ref)\n{\n\tstruct z3fold_header *zhdr = container_of(ref, struct z3fold_header,\n\t\t\t\t\t       refcount);\n\tspin_lock(&zhdr->pool->lock);\n\tlist_del_init(&zhdr->buddy);\n\tspin_unlock(&zhdr->pool->lock);\n\n\tWARN_ON(z3fold_page_trylock(zhdr));\n\t__release_z3fold_page(zhdr, true);\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic void release_z3fold_page_locked_list(struct kref *ref)\n{\n\tstruct z3fold_header *zhdr = container_of(ref, struct z3fold_header,\n\t\t\t\t\t       refcount);\n\tspin_lock(&zhdr->pool->lock);\n\tlist_del_init(&zhdr->buddy);\n\tspin_unlock(&zhdr->pool->lock);\n\n\tWARN_ON(z3fold_page_trylock(zhdr));\n\t__release_z3fold_page(zhdr, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pool->lock"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&page->lru",
            "&pool->lru"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pool->lock"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_dec",
          "args": [
            "&pool->pages_nr"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_z3fold_page",
          "args": [
            "page"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "free_z3fold_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "195-198",
          "snippet": "static void free_z3fold_page(struct page *page)\n{\n\t__free_page(page);\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic void free_z3fold_page(struct page *page)\n{\n\t__free_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "PAGE_HEADLESS",
            "&page->private"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pool->ops->evict",
          "args": [
            "pool",
            "last_handle"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pool->ops->evict",
          "args": [
            "pool",
            "first_handle"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pool->ops->evict",
          "args": [
            "pool",
            "middle_handle"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encode_handle",
          "args": [
            "zhdr",
            "HEADLESS"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "encode_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "222-233",
          "snippet": "static unsigned long encode_handle(struct z3fold_header *zhdr, enum buddy bud)\n{\n\tunsigned long handle;\n\n\thandle = (unsigned long)zhdr;\n\tif (bud != HEADLESS) {\n\t\thandle |= (bud + zhdr->first_num) & BUDDY_MASK;\n\t\tif (bud == LAST)\n\t\t\thandle |= (zhdr->last_chunks << BUDDY_SHIFT);\n\t}\n\treturn handle;\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define BUDDY_SHIFT\t2",
            "#define BUDDY_MASK\t(0x3)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\n#define BUDDY_SHIFT\t2\n#define BUDDY_MASK\t(0x3)\n\nstatic unsigned long encode_handle(struct z3fold_header *zhdr, enum buddy bud)\n{\n\tunsigned long handle;\n\n\thandle = (unsigned long)zhdr;\n\tif (bud != HEADLESS) {\n\t\thandle |= (bud + zhdr->first_num) & BUDDY_MASK;\n\t\tif (bud == LAST)\n\t\t\thandle |= (zhdr->last_chunks << BUDDY_SHIFT);\n\t}\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "PAGE_HEADLESS",
            "&page->private"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pool->lock"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&page->lru"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&zhdr->buddy"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&zhdr->refcount"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "z3fold_page_trylock",
          "args": [
            "zhdr"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "z3fold_page_trylock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "207-210",
          "snippet": "static inline int z3fold_page_trylock(struct z3fold_header *zhdr)\n{\n\treturn spin_trylock(&zhdr->page_lock);\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic inline int z3fold_page_trylock(struct z3fold_header *zhdr)\n{\n\treturn spin_trylock(&zhdr->page_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "PAGE_HEADLESS",
            "&page->private"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "page_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "409-434",
          "snippet": "void *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "PAGE_CLAIMED",
            "&page->private"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "pos",
            "structpage",
            "lru"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_prev",
          "args": [
            "pos",
            "&pool->lru"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pool->lock"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pool->lru"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pool->lock"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pool->lock"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic int z3fold_reclaim_page(struct z3fold_pool *pool, unsigned int retries)\n{\n\tint i, ret = 0;\n\tstruct z3fold_header *zhdr = NULL;\n\tstruct page *page = NULL;\n\tstruct list_head *pos;\n\tunsigned long first_handle = 0, middle_handle = 0, last_handle = 0;\n\n\tspin_lock(&pool->lock);\n\tif (!pool->ops || !pool->ops->evict || retries == 0) {\n\t\tspin_unlock(&pool->lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < retries; i++) {\n\t\tif (list_empty(&pool->lru)) {\n\t\t\tspin_unlock(&pool->lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlist_for_each_prev(pos, &pool->lru) {\n\t\t\tpage = list_entry(pos, struct page, lru);\n\n\t\t\t/* this bit could have been set by free, in which case\n\t\t\t * we pass over to the next page in the pool.\n\t\t\t */\n\t\t\tif (test_and_set_bit(PAGE_CLAIMED, &page->private))\n\t\t\t\tcontinue;\n\n\t\t\tzhdr = page_address(page);\n\t\t\tif (test_bit(PAGE_HEADLESS, &page->private))\n\t\t\t\tbreak;\n\n\t\t\tif (!z3fold_page_trylock(zhdr)) {\n\t\t\t\tzhdr = NULL;\n\t\t\t\tcontinue; /* can't evict at this point */\n\t\t\t}\n\t\t\tkref_get(&zhdr->refcount);\n\t\t\tlist_del_init(&zhdr->buddy);\n\t\t\tzhdr->cpu = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!zhdr)\n\t\t\tbreak;\n\n\t\tlist_del_init(&page->lru);\n\t\tspin_unlock(&pool->lock);\n\n\t\tif (!test_bit(PAGE_HEADLESS, &page->private)) {\n\t\t\t/*\n\t\t\t * We need encode the handles before unlocking, since\n\t\t\t * we can race with free that will set\n\t\t\t * (first|last)_chunks to 0\n\t\t\t */\n\t\t\tfirst_handle = 0;\n\t\t\tlast_handle = 0;\n\t\t\tmiddle_handle = 0;\n\t\t\tif (zhdr->first_chunks)\n\t\t\t\tfirst_handle = encode_handle(zhdr, FIRST);\n\t\t\tif (zhdr->middle_chunks)\n\t\t\t\tmiddle_handle = encode_handle(zhdr, MIDDLE);\n\t\t\tif (zhdr->last_chunks)\n\t\t\t\tlast_handle = encode_handle(zhdr, LAST);\n\t\t\t/*\n\t\t\t * it's safe to unlock here because we hold a\n\t\t\t * reference to this page\n\t\t\t */\n\t\t\tz3fold_page_unlock(zhdr);\n\t\t} else {\n\t\t\tfirst_handle = encode_handle(zhdr, HEADLESS);\n\t\t\tlast_handle = middle_handle = 0;\n\t\t}\n\n\t\t/* Issue the eviction callback(s) */\n\t\tif (middle_handle) {\n\t\t\tret = pool->ops->evict(pool, middle_handle);\n\t\t\tif (ret)\n\t\t\t\tgoto next;\n\t\t}\n\t\tif (first_handle) {\n\t\t\tret = pool->ops->evict(pool, first_handle);\n\t\t\tif (ret)\n\t\t\t\tgoto next;\n\t\t}\n\t\tif (last_handle) {\n\t\t\tret = pool->ops->evict(pool, last_handle);\n\t\t\tif (ret)\n\t\t\t\tgoto next;\n\t\t}\nnext:\n\t\tif (test_bit(PAGE_HEADLESS, &page->private)) {\n\t\t\tif (ret == 0) {\n\t\t\t\tfree_z3fold_page(page);\n\t\t\t\tatomic64_dec(&pool->pages_nr);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tspin_lock(&pool->lock);\n\t\t\tlist_add(&page->lru, &pool->lru);\n\t\t\tspin_unlock(&pool->lock);\n\t\t} else {\n\t\t\tz3fold_page_lock(zhdr);\n\t\t\tclear_bit(PAGE_CLAIMED, &page->private);\n\t\t\tif (kref_put(&zhdr->refcount,\n\t\t\t\t\trelease_z3fold_page_locked)) {\n\t\t\t\tatomic64_dec(&pool->pages_nr);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * if we are here, the page is still not completely\n\t\t\t * free. Take the global pool lock then to be able\n\t\t\t * to add it back to the lru list\n\t\t\t */\n\t\t\tspin_lock(&pool->lock);\n\t\t\tlist_add(&page->lru, &pool->lru);\n\t\t\tspin_unlock(&pool->lock);\n\t\t\tz3fold_page_unlock(zhdr);\n\t\t}\n\n\t\t/* We started off locked to we need to lock the pool back */\n\t\tspin_lock(&pool->lock);\n\t}\n\tspin_unlock(&pool->lock);\n\treturn -EAGAIN;\n}"
  },
  {
    "function_name": "z3fold_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
    "lines": "723-793",
    "snippet": "static void z3fold_free(struct z3fold_pool *pool, unsigned long handle)\n{\n\tstruct z3fold_header *zhdr;\n\tstruct page *page;\n\tenum buddy bud;\n\n\tzhdr = handle_to_z3fold_header(handle);\n\tpage = virt_to_page(zhdr);\n\n\tif (test_bit(PAGE_HEADLESS, &page->private)) {\n\t\t/* if a headless page is under reclaim, just leave.\n\t\t * NB: we use test_and_set_bit for a reason: if the bit\n\t\t * has not been set before, we release this page\n\t\t * immediately so we don't care about its value any more.\n\t\t */\n\t\tif (!test_and_set_bit(PAGE_CLAIMED, &page->private)) {\n\t\t\tspin_lock(&pool->lock);\n\t\t\tlist_del(&page->lru);\n\t\t\tspin_unlock(&pool->lock);\n\t\t\tfree_z3fold_page(page);\n\t\t\tatomic64_dec(&pool->pages_nr);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Non-headless case */\n\tz3fold_page_lock(zhdr);\n\tbud = handle_to_buddy(handle);\n\n\tswitch (bud) {\n\tcase FIRST:\n\t\tzhdr->first_chunks = 0;\n\t\tbreak;\n\tcase MIDDLE:\n\t\tzhdr->middle_chunks = 0;\n\t\tbreak;\n\tcase LAST:\n\t\tzhdr->last_chunks = 0;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: unknown bud %d\\n\", __func__, bud);\n\t\tWARN_ON(1);\n\t\tz3fold_page_unlock(zhdr);\n\t\treturn;\n\t}\n\n\tif (kref_put(&zhdr->refcount, release_z3fold_page_locked_list)) {\n\t\tatomic64_dec(&pool->pages_nr);\n\t\treturn;\n\t}\n\tif (test_bit(PAGE_CLAIMED, &page->private)) {\n\t\tz3fold_page_unlock(zhdr);\n\t\treturn;\n\t}\n\tif (test_and_set_bit(NEEDS_COMPACTING, &page->private)) {\n\t\tz3fold_page_unlock(zhdr);\n\t\treturn;\n\t}\n\tif (zhdr->cpu < 0 || !cpu_online(zhdr->cpu)) {\n\t\tspin_lock(&pool->lock);\n\t\tlist_del_init(&zhdr->buddy);\n\t\tspin_unlock(&pool->lock);\n\t\tzhdr->cpu = -1;\n\t\tkref_get(&zhdr->refcount);\n\t\tdo_compact_page(zhdr, true);\n\t\treturn;\n\t}\n\tkref_get(&zhdr->refcount);\n\tqueue_work_on(zhdr->cpu, pool->compact_wq, &zhdr->work);\n\tz3fold_page_unlock(zhdr);\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/sched.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "z3fold_page_unlock",
          "args": [
            "zhdr"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "z3fold_page_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "213-216",
          "snippet": "static inline void z3fold_page_unlock(struct z3fold_header *zhdr)\n{\n\tspin_unlock(&zhdr->page_lock);\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic inline void z3fold_page_unlock(struct z3fold_header *zhdr)\n{\n\tspin_unlock(&zhdr->page_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_work_on",
          "args": [
            "zhdr->cpu",
            "pool->compact_wq",
            "&zhdr->work"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&zhdr->refcount"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_compact_page",
          "args": [
            "zhdr",
            "true"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "do_compact_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "407-446",
          "snippet": "static void do_compact_page(struct z3fold_header *zhdr, bool locked)\n{\n\tstruct z3fold_pool *pool = zhdr->pool;\n\tstruct page *page;\n\tstruct list_head *unbuddied;\n\tint fchunks;\n\n\tpage = virt_to_page(zhdr);\n\tif (locked)\n\t\tWARN_ON(z3fold_page_trylock(zhdr));\n\telse\n\t\tz3fold_page_lock(zhdr);\n\tif (WARN_ON(!test_and_clear_bit(NEEDS_COMPACTING, &page->private))) {\n\t\tz3fold_page_unlock(zhdr);\n\t\treturn;\n\t}\n\tspin_lock(&pool->lock);\n\tlist_del_init(&zhdr->buddy);\n\tspin_unlock(&pool->lock);\n\n\tif (kref_put(&zhdr->refcount, release_z3fold_page_locked)) {\n\t\tatomic64_dec(&pool->pages_nr);\n\t\treturn;\n\t}\n\n\tz3fold_compact_page(zhdr);\n\tunbuddied = get_cpu_ptr(pool->unbuddied);\n\tfchunks = num_free_chunks(zhdr);\n\tif (fchunks < NCHUNKS &&\n\t    (!zhdr->first_chunks || !zhdr->middle_chunks ||\n\t\t\t!zhdr->last_chunks)) {\n\t\t/* the page's not completely free and it's unbuddied */\n\t\tspin_lock(&pool->lock);\n\t\tlist_add(&zhdr->buddy, &unbuddied[fchunks]);\n\t\tspin_unlock(&pool->lock);\n\t\tzhdr->cpu = smp_processor_id();\n\t}\n\tput_cpu_ptr(pool->unbuddied);\n\tz3fold_page_unlock(zhdr);\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define NCHUNKS\t\t((PAGE_SIZE - ZHDR_SIZE_ALIGNED) >> CHUNK_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\n#define NCHUNKS\t\t((PAGE_SIZE - ZHDR_SIZE_ALIGNED) >> CHUNK_SHIFT)\n\nstatic void do_compact_page(struct z3fold_header *zhdr, bool locked)\n{\n\tstruct z3fold_pool *pool = zhdr->pool;\n\tstruct page *page;\n\tstruct list_head *unbuddied;\n\tint fchunks;\n\n\tpage = virt_to_page(zhdr);\n\tif (locked)\n\t\tWARN_ON(z3fold_page_trylock(zhdr));\n\telse\n\t\tz3fold_page_lock(zhdr);\n\tif (WARN_ON(!test_and_clear_bit(NEEDS_COMPACTING, &page->private))) {\n\t\tz3fold_page_unlock(zhdr);\n\t\treturn;\n\t}\n\tspin_lock(&pool->lock);\n\tlist_del_init(&zhdr->buddy);\n\tspin_unlock(&pool->lock);\n\n\tif (kref_put(&zhdr->refcount, release_z3fold_page_locked)) {\n\t\tatomic64_dec(&pool->pages_nr);\n\t\treturn;\n\t}\n\n\tz3fold_compact_page(zhdr);\n\tunbuddied = get_cpu_ptr(pool->unbuddied);\n\tfchunks = num_free_chunks(zhdr);\n\tif (fchunks < NCHUNKS &&\n\t    (!zhdr->first_chunks || !zhdr->middle_chunks ||\n\t\t\t!zhdr->last_chunks)) {\n\t\t/* the page's not completely free and it's unbuddied */\n\t\tspin_lock(&pool->lock);\n\t\tlist_add(&zhdr->buddy, &unbuddied[fchunks]);\n\t\tspin_unlock(&pool->lock);\n\t\tzhdr->cpu = smp_processor_id();\n\t}\n\tput_cpu_ptr(pool->unbuddied);\n\tz3fold_page_unlock(zhdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&zhdr->refcount"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pool->lock"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&zhdr->buddy"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pool->lock"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "zhdr->cpu"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "page_writeback_cpu_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2052-2056",
          "snippet": "static int page_writeback_cpu_online(unsigned int cpu)\n{\n\twriteback_set_ratelimit();\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic int page_writeback_cpu_online(unsigned int cpu)\n{\n\twriteback_set_ratelimit();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "NEEDS_COMPACTING",
            "&page->private"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "PAGE_CLAIMED",
            "&page->private"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_dec",
          "args": [
            "&pool->pages_nr"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&zhdr->refcount",
            "release_z3fold_page_locked_list"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: unknown bud %d\\n\"",
            "__func__",
            "bud"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_to_buddy",
          "args": [
            "handle"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "handle_to_buddy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "252-256",
          "snippet": "static enum buddy handle_to_buddy(unsigned long handle)\n{\n\tstruct z3fold_header *zhdr = handle_to_z3fold_header(handle);\n\treturn (handle - zhdr->first_num) & BUDDY_MASK;\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define BUDDY_MASK\t(0x3)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\n#define BUDDY_MASK\t(0x3)\n\nstatic enum buddy handle_to_buddy(unsigned long handle)\n{\n\tstruct z3fold_header *zhdr = handle_to_z3fold_header(handle);\n\treturn (handle - zhdr->first_num) & BUDDY_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "z3fold_page_lock",
          "args": [
            "zhdr"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "release_z3fold_page_locked_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "294-304",
          "snippet": "static void release_z3fold_page_locked_list(struct kref *ref)\n{\n\tstruct z3fold_header *zhdr = container_of(ref, struct z3fold_header,\n\t\t\t\t\t       refcount);\n\tspin_lock(&zhdr->pool->lock);\n\tlist_del_init(&zhdr->buddy);\n\tspin_unlock(&zhdr->pool->lock);\n\n\tWARN_ON(z3fold_page_trylock(zhdr));\n\t__release_z3fold_page(zhdr, true);\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic void release_z3fold_page_locked_list(struct kref *ref)\n{\n\tstruct z3fold_header *zhdr = container_of(ref, struct z3fold_header,\n\t\t\t\t\t       refcount);\n\tspin_lock(&zhdr->pool->lock);\n\tlist_del_init(&zhdr->buddy);\n\tspin_unlock(&zhdr->pool->lock);\n\n\tWARN_ON(z3fold_page_trylock(zhdr));\n\t__release_z3fold_page(zhdr, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic64_dec",
          "args": [
            "&pool->pages_nr"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_z3fold_page",
          "args": [
            "page"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "free_z3fold_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "195-198",
          "snippet": "static void free_z3fold_page(struct page *page)\n{\n\t__free_page(page);\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic void free_z3fold_page(struct page *page)\n{\n\t__free_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pool->lock"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pool->lock"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "PAGE_CLAIMED",
            "&page->private"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "PAGE_HEADLESS",
            "&page->private"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "zhdr"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_to_z3fold_header",
          "args": [
            "handle"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "handle_to_z3fold_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "236-239",
          "snippet": "static struct z3fold_header *handle_to_z3fold_header(unsigned long handle)\n{\n\treturn (struct z3fold_header *)(handle & PAGE_MASK);\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic struct z3fold_header *handle_to_z3fold_header(unsigned long handle)\n{\n\treturn (struct z3fold_header *)(handle & PAGE_MASK);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic void z3fold_free(struct z3fold_pool *pool, unsigned long handle)\n{\n\tstruct z3fold_header *zhdr;\n\tstruct page *page;\n\tenum buddy bud;\n\n\tzhdr = handle_to_z3fold_header(handle);\n\tpage = virt_to_page(zhdr);\n\n\tif (test_bit(PAGE_HEADLESS, &page->private)) {\n\t\t/* if a headless page is under reclaim, just leave.\n\t\t * NB: we use test_and_set_bit for a reason: if the bit\n\t\t * has not been set before, we release this page\n\t\t * immediately so we don't care about its value any more.\n\t\t */\n\t\tif (!test_and_set_bit(PAGE_CLAIMED, &page->private)) {\n\t\t\tspin_lock(&pool->lock);\n\t\t\tlist_del(&page->lru);\n\t\t\tspin_unlock(&pool->lock);\n\t\t\tfree_z3fold_page(page);\n\t\t\tatomic64_dec(&pool->pages_nr);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Non-headless case */\n\tz3fold_page_lock(zhdr);\n\tbud = handle_to_buddy(handle);\n\n\tswitch (bud) {\n\tcase FIRST:\n\t\tzhdr->first_chunks = 0;\n\t\tbreak;\n\tcase MIDDLE:\n\t\tzhdr->middle_chunks = 0;\n\t\tbreak;\n\tcase LAST:\n\t\tzhdr->last_chunks = 0;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: unknown bud %d\\n\", __func__, bud);\n\t\tWARN_ON(1);\n\t\tz3fold_page_unlock(zhdr);\n\t\treturn;\n\t}\n\n\tif (kref_put(&zhdr->refcount, release_z3fold_page_locked_list)) {\n\t\tatomic64_dec(&pool->pages_nr);\n\t\treturn;\n\t}\n\tif (test_bit(PAGE_CLAIMED, &page->private)) {\n\t\tz3fold_page_unlock(zhdr);\n\t\treturn;\n\t}\n\tif (test_and_set_bit(NEEDS_COMPACTING, &page->private)) {\n\t\tz3fold_page_unlock(zhdr);\n\t\treturn;\n\t}\n\tif (zhdr->cpu < 0 || !cpu_online(zhdr->cpu)) {\n\t\tspin_lock(&pool->lock);\n\t\tlist_del_init(&zhdr->buddy);\n\t\tspin_unlock(&pool->lock);\n\t\tzhdr->cpu = -1;\n\t\tkref_get(&zhdr->refcount);\n\t\tdo_compact_page(zhdr, true);\n\t\treturn;\n\t}\n\tkref_get(&zhdr->refcount);\n\tqueue_work_on(zhdr->cpu, pool->compact_wq, &zhdr->work);\n\tz3fold_page_unlock(zhdr);\n}"
  },
  {
    "function_name": "z3fold_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
    "lines": "546-711",
    "snippet": "static int z3fold_alloc(struct z3fold_pool *pool, size_t size, gfp_t gfp,\n\t\t\tunsigned long *handle)\n{\n\tint chunks = 0, i, freechunks;\n\tstruct z3fold_header *zhdr = NULL;\n\tstruct page *page = NULL;\n\tenum buddy bud;\n\tbool can_sleep = gfpflags_allow_blocking(gfp);\n\n\tif (!size || (gfp & __GFP_HIGHMEM))\n\t\treturn -EINVAL;\n\n\tif (size > PAGE_SIZE)\n\t\treturn -ENOSPC;\n\n\tif (size > PAGE_SIZE - ZHDR_SIZE_ALIGNED - CHUNK_SIZE)\n\t\tbud = HEADLESS;\n\telse {\n\t\tstruct list_head *unbuddied;\n\t\tchunks = size_to_chunks(size);\n\nlookup:\n\t\t/* First, try to find an unbuddied z3fold page. */\n\t\tunbuddied = get_cpu_ptr(pool->unbuddied);\n\t\tfor_each_unbuddied_list(i, chunks) {\n\t\t\tstruct list_head *l = &unbuddied[i];\n\n\t\t\tzhdr = list_first_entry_or_null(READ_ONCE(l),\n\t\t\t\t\t\tstruct z3fold_header, buddy);\n\n\t\t\tif (!zhdr)\n\t\t\t\tcontinue;\n\n\t\t\t/* Re-check under lock. */\n\t\t\tspin_lock(&pool->lock);\n\t\t\tl = &unbuddied[i];\n\t\t\tif (unlikely(zhdr != list_first_entry(READ_ONCE(l),\n\t\t\t\t\tstruct z3fold_header, buddy)) ||\n\t\t\t    !z3fold_page_trylock(zhdr)) {\n\t\t\t\tspin_unlock(&pool->lock);\n\t\t\t\tput_cpu_ptr(pool->unbuddied);\n\t\t\t\tgoto lookup;\n\t\t\t}\n\t\t\tlist_del_init(&zhdr->buddy);\n\t\t\tzhdr->cpu = -1;\n\t\t\tspin_unlock(&pool->lock);\n\n\t\t\tpage = virt_to_page(zhdr);\n\t\t\tif (test_bit(NEEDS_COMPACTING, &page->private)) {\n\t\t\t\tz3fold_page_unlock(zhdr);\n\t\t\t\tzhdr = NULL;\n\t\t\t\tput_cpu_ptr(pool->unbuddied);\n\t\t\t\tif (can_sleep)\n\t\t\t\t\tcond_resched();\n\t\t\t\tgoto lookup;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * this page could not be removed from its unbuddied\n\t\t\t * list while pool lock was held, and then we've taken\n\t\t\t * page lock so kref_put could not be called before\n\t\t\t * we got here, so it's safe to just call kref_get()\n\t\t\t */\n\t\t\tkref_get(&zhdr->refcount);\n\t\t\tbreak;\n\t\t}\n\t\tput_cpu_ptr(pool->unbuddied);\n\n\t\tif (zhdr) {\n\t\t\tif (zhdr->first_chunks == 0) {\n\t\t\t\tif (zhdr->middle_chunks != 0 &&\n\t\t\t\t    chunks >= zhdr->start_middle)\n\t\t\t\t\tbud = LAST;\n\t\t\t\telse\n\t\t\t\t\tbud = FIRST;\n\t\t\t} else if (zhdr->last_chunks == 0)\n\t\t\t\tbud = LAST;\n\t\t\telse if (zhdr->middle_chunks == 0)\n\t\t\t\tbud = MIDDLE;\n\t\t\telse {\n\t\t\t\tif (kref_put(&zhdr->refcount,\n\t\t\t\t\t     release_z3fold_page_locked))\n\t\t\t\t\tatomic64_dec(&pool->pages_nr);\n\t\t\t\telse\n\t\t\t\t\tz3fold_page_unlock(zhdr);\n\t\t\t\tpr_err(\"No free chunks in unbuddied\\n\");\n\t\t\t\tWARN_ON(1);\n\t\t\t\tgoto lookup;\n\t\t\t}\n\t\t\tgoto found;\n\t\t}\n\t\tbud = FIRST;\n\t}\n\n\tpage = NULL;\n\tif (can_sleep) {\n\t\tspin_lock(&pool->stale_lock);\n\t\tzhdr = list_first_entry_or_null(&pool->stale,\n\t\t\t\t\t\tstruct z3fold_header, buddy);\n\t\t/*\n\t\t * Before allocating a page, let's see if we can take one from\n\t\t * the stale pages list. cancel_work_sync() can sleep so we\n\t\t * limit this case to the contexts where we can sleep\n\t\t */\n\t\tif (zhdr) {\n\t\t\tlist_del(&zhdr->buddy);\n\t\t\tspin_unlock(&pool->stale_lock);\n\t\t\tcancel_work_sync(&zhdr->work);\n\t\t\tpage = virt_to_page(zhdr);\n\t\t} else {\n\t\t\tspin_unlock(&pool->stale_lock);\n\t\t}\n\t}\n\tif (!page)\n\t\tpage = alloc_page(gfp);\n\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tatomic64_inc(&pool->pages_nr);\n\tzhdr = init_z3fold_page(page, pool);\n\n\tif (bud == HEADLESS) {\n\t\tset_bit(PAGE_HEADLESS, &page->private);\n\t\tgoto headless;\n\t}\n\tz3fold_page_lock(zhdr);\n\nfound:\n\tif (bud == FIRST)\n\t\tzhdr->first_chunks = chunks;\n\telse if (bud == LAST)\n\t\tzhdr->last_chunks = chunks;\n\telse {\n\t\tzhdr->middle_chunks = chunks;\n\t\tzhdr->start_middle = zhdr->first_chunks + ZHDR_CHUNKS;\n\t}\n\n\tif (zhdr->first_chunks == 0 || zhdr->last_chunks == 0 ||\n\t\t\tzhdr->middle_chunks == 0) {\n\t\tstruct list_head *unbuddied = get_cpu_ptr(pool->unbuddied);\n\n\t\t/* Add to unbuddied list */\n\t\tfreechunks = num_free_chunks(zhdr);\n\t\tspin_lock(&pool->lock);\n\t\tlist_add(&zhdr->buddy, &unbuddied[freechunks]);\n\t\tspin_unlock(&pool->lock);\n\t\tzhdr->cpu = smp_processor_id();\n\t\tput_cpu_ptr(pool->unbuddied);\n\t}\n\nheadless:\n\tspin_lock(&pool->lock);\n\t/* Add/move z3fold page to beginning of LRU */\n\tif (!list_empty(&page->lru))\n\t\tlist_del(&page->lru);\n\n\tlist_add(&page->lru, &pool->lru);\n\n\t*handle = encode_handle(zhdr, bud);\n\tspin_unlock(&pool->lock);\n\tif (bud != HEADLESS)\n\t\tz3fold_page_unlock(zhdr);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/sched.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define ZHDR_CHUNKS\t(ZHDR_SIZE_ALIGNED >> CHUNK_SHIFT)",
      "#define ZHDR_SIZE_ALIGNED round_up(sizeof(struct z3fold_header), CHUNK_SIZE)",
      "#define CHUNK_SIZE\t(1 << CHUNK_SHIFT)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "z3fold_page_unlock",
          "args": [
            "zhdr"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "z3fold_page_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "213-216",
          "snippet": "static inline void z3fold_page_unlock(struct z3fold_header *zhdr)\n{\n\tspin_unlock(&zhdr->page_lock);\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic inline void z3fold_page_unlock(struct z3fold_header *zhdr)\n{\n\tspin_unlock(&zhdr->page_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pool->lock"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encode_handle",
          "args": [
            "zhdr",
            "bud"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "encode_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "222-233",
          "snippet": "static unsigned long encode_handle(struct z3fold_header *zhdr, enum buddy bud)\n{\n\tunsigned long handle;\n\n\thandle = (unsigned long)zhdr;\n\tif (bud != HEADLESS) {\n\t\thandle |= (bud + zhdr->first_num) & BUDDY_MASK;\n\t\tif (bud == LAST)\n\t\t\thandle |= (zhdr->last_chunks << BUDDY_SHIFT);\n\t}\n\treturn handle;\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define BUDDY_SHIFT\t2",
            "#define BUDDY_MASK\t(0x3)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\n#define BUDDY_SHIFT\t2\n#define BUDDY_MASK\t(0x3)\n\nstatic unsigned long encode_handle(struct z3fold_header *zhdr, enum buddy bud)\n{\n\tunsigned long handle;\n\n\thandle = (unsigned long)zhdr;\n\tif (bud != HEADLESS) {\n\t\thandle |= (bud + zhdr->first_num) & BUDDY_MASK;\n\t\tif (bud == LAST)\n\t\t\thandle |= (zhdr->last_chunks << BUDDY_SHIFT);\n\t}\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&page->lru",
            "&pool->lru"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&page->lru"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pool->lock"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_cpu_ptr",
          "args": [
            "pool->unbuddied"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pool->lock"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&zhdr->buddy",
            "&unbuddied[freechunks]"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pool->lock"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_free_chunks",
          "args": [
            "zhdr"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "num_free_chunks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "332-350",
          "snippet": "static int num_free_chunks(struct z3fold_header *zhdr)\n{\n\tint nfree;\n\t/*\n\t * If there is a middle object, pick up the bigger free space\n\t * either before or after it. Otherwise just subtract the number\n\t * of chunks occupied by the first and the last objects.\n\t */\n\tif (zhdr->middle_chunks != 0) {\n\t\tint nfree_before = zhdr->first_chunks ?\n\t\t\t0 : zhdr->start_middle - ZHDR_CHUNKS;\n\t\tint nfree_after = zhdr->last_chunks ?\n\t\t\t0 : TOTAL_CHUNKS -\n\t\t\t\t(zhdr->start_middle + zhdr->middle_chunks);\n\t\tnfree = max(nfree_before, nfree_after);\n\t} else\n\t\tnfree = NCHUNKS - zhdr->first_chunks - zhdr->last_chunks;\n\treturn nfree;\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define NCHUNKS\t\t((PAGE_SIZE - ZHDR_SIZE_ALIGNED) >> CHUNK_SHIFT)",
            "#define TOTAL_CHUNKS\t(PAGE_SIZE >> CHUNK_SHIFT)",
            "#define ZHDR_CHUNKS\t(ZHDR_SIZE_ALIGNED >> CHUNK_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\n#define NCHUNKS\t\t((PAGE_SIZE - ZHDR_SIZE_ALIGNED) >> CHUNK_SHIFT)\n#define TOTAL_CHUNKS\t(PAGE_SIZE >> CHUNK_SHIFT)\n#define ZHDR_CHUNKS\t(ZHDR_SIZE_ALIGNED >> CHUNK_SHIFT)\n\nstatic int num_free_chunks(struct z3fold_header *zhdr)\n{\n\tint nfree;\n\t/*\n\t * If there is a middle object, pick up the bigger free space\n\t * either before or after it. Otherwise just subtract the number\n\t * of chunks occupied by the first and the last objects.\n\t */\n\tif (zhdr->middle_chunks != 0) {\n\t\tint nfree_before = zhdr->first_chunks ?\n\t\t\t0 : zhdr->start_middle - ZHDR_CHUNKS;\n\t\tint nfree_after = zhdr->last_chunks ?\n\t\t\t0 : TOTAL_CHUNKS -\n\t\t\t\t(zhdr->start_middle + zhdr->middle_chunks);\n\t\tnfree = max(nfree_before, nfree_after);\n\t} else\n\t\tnfree = NCHUNKS - zhdr->first_chunks - zhdr->last_chunks;\n\treturn nfree;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cpu_ptr",
          "args": [
            "pool->unbuddied"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "z3fold_page_lock",
          "args": [
            "zhdr"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "release_z3fold_page_locked_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "294-304",
          "snippet": "static void release_z3fold_page_locked_list(struct kref *ref)\n{\n\tstruct z3fold_header *zhdr = container_of(ref, struct z3fold_header,\n\t\t\t\t\t       refcount);\n\tspin_lock(&zhdr->pool->lock);\n\tlist_del_init(&zhdr->buddy);\n\tspin_unlock(&zhdr->pool->lock);\n\n\tWARN_ON(z3fold_page_trylock(zhdr));\n\t__release_z3fold_page(zhdr, true);\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic void release_z3fold_page_locked_list(struct kref *ref)\n{\n\tstruct z3fold_header *zhdr = container_of(ref, struct z3fold_header,\n\t\t\t\t\t       refcount);\n\tspin_lock(&zhdr->pool->lock);\n\tlist_del_init(&zhdr->buddy);\n\tspin_unlock(&zhdr->pool->lock);\n\n\tWARN_ON(z3fold_page_trylock(zhdr));\n\t__release_z3fold_page(zhdr, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "PAGE_HEADLESS",
            "&page->private"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_z3fold_page",
          "args": [
            "page",
            "pool"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "init_z3fold_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "168-192",
          "snippet": "static struct z3fold_header *init_z3fold_page(struct page *page,\n\t\t\t\t\tstruct z3fold_pool *pool)\n{\n\tstruct z3fold_header *zhdr = page_address(page);\n\n\tINIT_LIST_HEAD(&page->lru);\n\tclear_bit(PAGE_HEADLESS, &page->private);\n\tclear_bit(MIDDLE_CHUNK_MAPPED, &page->private);\n\tclear_bit(NEEDS_COMPACTING, &page->private);\n\tclear_bit(PAGE_STALE, &page->private);\n\tclear_bit(PAGE_CLAIMED, &page->private);\n\n\tspin_lock_init(&zhdr->page_lock);\n\tkref_init(&zhdr->refcount);\n\tzhdr->first_chunks = 0;\n\tzhdr->middle_chunks = 0;\n\tzhdr->last_chunks = 0;\n\tzhdr->first_num = 0;\n\tzhdr->start_middle = 0;\n\tzhdr->cpu = -1;\n\tzhdr->pool = pool;\n\tINIT_LIST_HEAD(&zhdr->buddy);\n\tINIT_WORK(&zhdr->work, compact_page_work);\n\treturn zhdr;\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic struct z3fold_header *init_z3fold_page(struct page *page,\n\t\t\t\t\tstruct z3fold_pool *pool)\n{\n\tstruct z3fold_header *zhdr = page_address(page);\n\n\tINIT_LIST_HEAD(&page->lru);\n\tclear_bit(PAGE_HEADLESS, &page->private);\n\tclear_bit(MIDDLE_CHUNK_MAPPED, &page->private);\n\tclear_bit(NEEDS_COMPACTING, &page->private);\n\tclear_bit(PAGE_STALE, &page->private);\n\tclear_bit(PAGE_CLAIMED, &page->private);\n\n\tspin_lock_init(&zhdr->page_lock);\n\tkref_init(&zhdr->refcount);\n\tzhdr->first_chunks = 0;\n\tzhdr->middle_chunks = 0;\n\tzhdr->last_chunks = 0;\n\tzhdr->first_num = 0;\n\tzhdr->start_middle = 0;\n\tzhdr->cpu = -1;\n\tzhdr->pool = pool;\n\tINIT_LIST_HEAD(&zhdr->buddy);\n\tINIT_WORK(&zhdr->work, compact_page_work);\n\treturn zhdr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic64_inc",
          "args": [
            "&pool->pages_nr"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "gfp"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_hstate_alloc_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "2163-2184",
          "snippet": "static void __init hugetlb_hstate_alloc_pages(struct hstate *h)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < h->max_huge_pages; ++i) {\n\t\tif (hstate_is_gigantic(h)) {\n\t\t\tif (!alloc_bootmem_huge_page(h))\n\t\t\t\tbreak;\n\t\t} else if (!alloc_pool_huge_page(h,\n\t\t\t\t\t &node_states[N_MEMORY]))\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n\tif (i < h->max_huge_pages) {\n\t\tchar buf[32];\n\n\t\tstring_get_size(huge_page_size(h), 1, STRING_UNITS_2, buf, 32);\n\t\tpr_warn(\"HugeTLB: allocating %lu of page size %s failed.  Only allocated %lu hugepages.\\n\",\n\t\t\th->max_huge_pages, buf, i);\n\t\th->max_huge_pages = i;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void __init hugetlb_hstate_alloc_pages(struct hstate *h)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < h->max_huge_pages; ++i) {\n\t\tif (hstate_is_gigantic(h)) {\n\t\t\tif (!alloc_bootmem_huge_page(h))\n\t\t\t\tbreak;\n\t\t} else if (!alloc_pool_huge_page(h,\n\t\t\t\t\t &node_states[N_MEMORY]))\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n\tif (i < h->max_huge_pages) {\n\t\tchar buf[32];\n\n\t\tstring_get_size(huge_page_size(h), 1, STRING_UNITS_2, buf, 32);\n\t\tpr_warn(\"HugeTLB: allocating %lu of page size %s failed.  Only allocated %lu hugepages.\\n\",\n\t\t\th->max_huge_pages, buf, i);\n\t\th->max_huge_pages = i;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pool->stale_lock"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "zhdr"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cancel_work_sync",
          "args": [
            "&zhdr->work"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pool->stale_lock"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&zhdr->buddy"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry_or_null",
          "args": [
            "&pool->stale",
            "structz3fold_header",
            "buddy"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pool->stale_lock"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"No free chunks in unbuddied\\n\""
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_dec",
          "args": [
            "&pool->pages_nr"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&zhdr->refcount",
            "release_z3fold_page_locked"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_cpu_ptr",
          "args": [
            "pool->unbuddied"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&zhdr->refcount"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_cpu_ptr",
          "args": [
            "pool->unbuddied"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NEEDS_COMPACTING",
            "&page->private"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "zhdr"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pool->lock"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&zhdr->buddy"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_cpu_ptr",
          "args": [
            "pool->unbuddied"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pool->lock"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "z3fold_page_trylock",
          "args": [
            "zhdr"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "z3fold_page_trylock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "207-210",
          "snippet": "static inline int z3fold_page_trylock(struct z3fold_header *zhdr)\n{\n\treturn spin_trylock(&zhdr->page_lock);\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic inline int z3fold_page_trylock(struct z3fold_header *zhdr)\n{\n\treturn spin_trylock(&zhdr->page_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "zhdr != list_first_entry(READ_ONCE(l),\n\t\t\t\t\tstruct z3fold_header, buddy)"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "READ_ONCE(l)",
            "structz3fold_header",
            "buddy"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "l"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pool->lock"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry_or_null",
          "args": [
            "READ_ONCE(l)",
            "structz3fold_header",
            "buddy"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "l"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_unbuddied_list",
          "args": [
            "i",
            "chunks"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu_ptr",
          "args": [
            "pool->unbuddied"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "size_to_chunks",
          "args": [
            "size"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "size_to_chunks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "157-160",
          "snippet": "static int size_to_chunks(size_t size)\n{\n\treturn (size + CHUNK_SIZE - 1) >> CHUNK_SHIFT;\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define CHUNK_SIZE\t(1 << CHUNK_SHIFT)",
            "#define CHUNK_SHIFT\t(PAGE_SHIFT - NCHUNKS_ORDER)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\n#define CHUNK_SIZE\t(1 << CHUNK_SHIFT)\n#define CHUNK_SHIFT\t(PAGE_SHIFT - NCHUNKS_ORDER)\n\nstatic int size_to_chunks(size_t size)\n{\n\treturn (size + CHUNK_SIZE - 1) >> CHUNK_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfpflags_allow_blocking",
          "args": [
            "gfp"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\n#define ZHDR_CHUNKS\t(ZHDR_SIZE_ALIGNED >> CHUNK_SHIFT)\n#define ZHDR_SIZE_ALIGNED round_up(sizeof(struct z3fold_header), CHUNK_SIZE)\n#define CHUNK_SIZE\t(1 << CHUNK_SHIFT)\n\nstatic int z3fold_alloc(struct z3fold_pool *pool, size_t size, gfp_t gfp,\n\t\t\tunsigned long *handle)\n{\n\tint chunks = 0, i, freechunks;\n\tstruct z3fold_header *zhdr = NULL;\n\tstruct page *page = NULL;\n\tenum buddy bud;\n\tbool can_sleep = gfpflags_allow_blocking(gfp);\n\n\tif (!size || (gfp & __GFP_HIGHMEM))\n\t\treturn -EINVAL;\n\n\tif (size > PAGE_SIZE)\n\t\treturn -ENOSPC;\n\n\tif (size > PAGE_SIZE - ZHDR_SIZE_ALIGNED - CHUNK_SIZE)\n\t\tbud = HEADLESS;\n\telse {\n\t\tstruct list_head *unbuddied;\n\t\tchunks = size_to_chunks(size);\n\nlookup:\n\t\t/* First, try to find an unbuddied z3fold page. */\n\t\tunbuddied = get_cpu_ptr(pool->unbuddied);\n\t\tfor_each_unbuddied_list(i, chunks) {\n\t\t\tstruct list_head *l = &unbuddied[i];\n\n\t\t\tzhdr = list_first_entry_or_null(READ_ONCE(l),\n\t\t\t\t\t\tstruct z3fold_header, buddy);\n\n\t\t\tif (!zhdr)\n\t\t\t\tcontinue;\n\n\t\t\t/* Re-check under lock. */\n\t\t\tspin_lock(&pool->lock);\n\t\t\tl = &unbuddied[i];\n\t\t\tif (unlikely(zhdr != list_first_entry(READ_ONCE(l),\n\t\t\t\t\tstruct z3fold_header, buddy)) ||\n\t\t\t    !z3fold_page_trylock(zhdr)) {\n\t\t\t\tspin_unlock(&pool->lock);\n\t\t\t\tput_cpu_ptr(pool->unbuddied);\n\t\t\t\tgoto lookup;\n\t\t\t}\n\t\t\tlist_del_init(&zhdr->buddy);\n\t\t\tzhdr->cpu = -1;\n\t\t\tspin_unlock(&pool->lock);\n\n\t\t\tpage = virt_to_page(zhdr);\n\t\t\tif (test_bit(NEEDS_COMPACTING, &page->private)) {\n\t\t\t\tz3fold_page_unlock(zhdr);\n\t\t\t\tzhdr = NULL;\n\t\t\t\tput_cpu_ptr(pool->unbuddied);\n\t\t\t\tif (can_sleep)\n\t\t\t\t\tcond_resched();\n\t\t\t\tgoto lookup;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * this page could not be removed from its unbuddied\n\t\t\t * list while pool lock was held, and then we've taken\n\t\t\t * page lock so kref_put could not be called before\n\t\t\t * we got here, so it's safe to just call kref_get()\n\t\t\t */\n\t\t\tkref_get(&zhdr->refcount);\n\t\t\tbreak;\n\t\t}\n\t\tput_cpu_ptr(pool->unbuddied);\n\n\t\tif (zhdr) {\n\t\t\tif (zhdr->first_chunks == 0) {\n\t\t\t\tif (zhdr->middle_chunks != 0 &&\n\t\t\t\t    chunks >= zhdr->start_middle)\n\t\t\t\t\tbud = LAST;\n\t\t\t\telse\n\t\t\t\t\tbud = FIRST;\n\t\t\t} else if (zhdr->last_chunks == 0)\n\t\t\t\tbud = LAST;\n\t\t\telse if (zhdr->middle_chunks == 0)\n\t\t\t\tbud = MIDDLE;\n\t\t\telse {\n\t\t\t\tif (kref_put(&zhdr->refcount,\n\t\t\t\t\t     release_z3fold_page_locked))\n\t\t\t\t\tatomic64_dec(&pool->pages_nr);\n\t\t\t\telse\n\t\t\t\t\tz3fold_page_unlock(zhdr);\n\t\t\t\tpr_err(\"No free chunks in unbuddied\\n\");\n\t\t\t\tWARN_ON(1);\n\t\t\t\tgoto lookup;\n\t\t\t}\n\t\t\tgoto found;\n\t\t}\n\t\tbud = FIRST;\n\t}\n\n\tpage = NULL;\n\tif (can_sleep) {\n\t\tspin_lock(&pool->stale_lock);\n\t\tzhdr = list_first_entry_or_null(&pool->stale,\n\t\t\t\t\t\tstruct z3fold_header, buddy);\n\t\t/*\n\t\t * Before allocating a page, let's see if we can take one from\n\t\t * the stale pages list. cancel_work_sync() can sleep so we\n\t\t * limit this case to the contexts where we can sleep\n\t\t */\n\t\tif (zhdr) {\n\t\t\tlist_del(&zhdr->buddy);\n\t\t\tspin_unlock(&pool->stale_lock);\n\t\t\tcancel_work_sync(&zhdr->work);\n\t\t\tpage = virt_to_page(zhdr);\n\t\t} else {\n\t\t\tspin_unlock(&pool->stale_lock);\n\t\t}\n\t}\n\tif (!page)\n\t\tpage = alloc_page(gfp);\n\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tatomic64_inc(&pool->pages_nr);\n\tzhdr = init_z3fold_page(page, pool);\n\n\tif (bud == HEADLESS) {\n\t\tset_bit(PAGE_HEADLESS, &page->private);\n\t\tgoto headless;\n\t}\n\tz3fold_page_lock(zhdr);\n\nfound:\n\tif (bud == FIRST)\n\t\tzhdr->first_chunks = chunks;\n\telse if (bud == LAST)\n\t\tzhdr->last_chunks = chunks;\n\telse {\n\t\tzhdr->middle_chunks = chunks;\n\t\tzhdr->start_middle = zhdr->first_chunks + ZHDR_CHUNKS;\n\t}\n\n\tif (zhdr->first_chunks == 0 || zhdr->last_chunks == 0 ||\n\t\t\tzhdr->middle_chunks == 0) {\n\t\tstruct list_head *unbuddied = get_cpu_ptr(pool->unbuddied);\n\n\t\t/* Add to unbuddied list */\n\t\tfreechunks = num_free_chunks(zhdr);\n\t\tspin_lock(&pool->lock);\n\t\tlist_add(&zhdr->buddy, &unbuddied[freechunks]);\n\t\tspin_unlock(&pool->lock);\n\t\tzhdr->cpu = smp_processor_id();\n\t\tput_cpu_ptr(pool->unbuddied);\n\t}\n\nheadless:\n\tspin_lock(&pool->lock);\n\t/* Add/move z3fold page to beginning of LRU */\n\tif (!list_empty(&page->lru))\n\t\tlist_del(&page->lru);\n\n\tlist_add(&page->lru, &pool->lru);\n\n\t*handle = encode_handle(zhdr, bud);\n\tspin_unlock(&pool->lock);\n\tif (bud != HEADLESS)\n\t\tz3fold_page_unlock(zhdr);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "z3fold_destroy_pool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
    "lines": "520-525",
    "snippet": "static void z3fold_destroy_pool(struct z3fold_pool *pool)\n{\n\tdestroy_workqueue(pool->release_wq);\n\tdestroy_workqueue(pool->compact_wq);\n\tkfree(pool);\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/sched.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pool"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "pool->compact_wq"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "pool->release_wq"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic void z3fold_destroy_pool(struct z3fold_pool *pool)\n{\n\tdestroy_workqueue(pool->release_wq);\n\tdestroy_workqueue(pool->compact_wq);\n\tkfree(pool);\n}"
  },
  {
    "function_name": "z3fold_create_pool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
    "lines": "470-512",
    "snippet": "static struct z3fold_pool *z3fold_create_pool(const char *name, gfp_t gfp,\n\t\tconst struct z3fold_ops *ops)\n{\n\tstruct z3fold_pool *pool = NULL;\n\tint i, cpu;\n\n\tpool = kzalloc(sizeof(struct z3fold_pool), gfp);\n\tif (!pool)\n\t\tgoto out;\n\tspin_lock_init(&pool->lock);\n\tspin_lock_init(&pool->stale_lock);\n\tpool->unbuddied = __alloc_percpu(sizeof(struct list_head)*NCHUNKS, 2);\n\tif (!pool->unbuddied)\n\t\tgoto out_pool;\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct list_head *unbuddied =\n\t\t\t\tper_cpu_ptr(pool->unbuddied, cpu);\n\t\tfor_each_unbuddied_list(i, 0)\n\t\t\tINIT_LIST_HEAD(&unbuddied[i]);\n\t}\n\tINIT_LIST_HEAD(&pool->lru);\n\tINIT_LIST_HEAD(&pool->stale);\n\tatomic64_set(&pool->pages_nr, 0);\n\tpool->name = name;\n\tpool->compact_wq = create_singlethread_workqueue(pool->name);\n\tif (!pool->compact_wq)\n\t\tgoto out_unbuddied;\n\tpool->release_wq = create_singlethread_workqueue(pool->name);\n\tif (!pool->release_wq)\n\t\tgoto out_wq;\n\tINIT_WORK(&pool->work, free_pages_work);\n\tpool->ops = ops;\n\treturn pool;\n\nout_wq:\n\tdestroy_workqueue(pool->compact_wq);\nout_unbuddied:\n\tfree_percpu(pool->unbuddied);\nout_pool:\n\tkfree(pool);\nout:\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/sched.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define NCHUNKS\t\t((PAGE_SIZE - ZHDR_SIZE_ALIGNED) >> CHUNK_SHIFT)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pool"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "pool->unbuddied"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "free_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "1718-1753",
          "snippet": "void free_percpu(void __percpu *ptr)\n{\n\tvoid *addr;\n\tstruct pcpu_chunk *chunk;\n\tunsigned long flags;\n\tint off;\n\n\tif (!ptr)\n\t\treturn;\n\n\tkmemleak_free_percpu(ptr);\n\n\taddr = __pcpu_ptr_to_addr(ptr);\n\n\tspin_lock_irqsave(&pcpu_lock, flags);\n\n\tchunk = pcpu_chunk_addr_search(addr);\n\toff = addr - chunk->base_addr;\n\n\tpcpu_free_area(chunk, off);\n\n\t/* if there are more than one fully free chunks, wake up grim reaper */\n\tif (chunk->free_bytes == pcpu_unit_size) {\n\t\tstruct pcpu_chunk *pos;\n\n\t\tlist_for_each_entry(pos, &pcpu_slot[pcpu_nr_slots - 1], list)\n\t\t\tif (pos != chunk) {\n\t\t\t\tpcpu_schedule_balance_work();\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\ttrace_percpu_free_percpu(chunk->base_addr, off, ptr);\n\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int pcpu_unit_size",
            "int pcpu_nr_slots",
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);",
            "static struct page *pcpu_addr_to_page(void *addr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int pcpu_unit_size;\nint pcpu_nr_slots;\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\nstatic struct page *pcpu_addr_to_page(void *addr);\n\nvoid free_percpu(void __percpu *ptr)\n{\n\tvoid *addr;\n\tstruct pcpu_chunk *chunk;\n\tunsigned long flags;\n\tint off;\n\n\tif (!ptr)\n\t\treturn;\n\n\tkmemleak_free_percpu(ptr);\n\n\taddr = __pcpu_ptr_to_addr(ptr);\n\n\tspin_lock_irqsave(&pcpu_lock, flags);\n\n\tchunk = pcpu_chunk_addr_search(addr);\n\toff = addr - chunk->base_addr;\n\n\tpcpu_free_area(chunk, off);\n\n\t/* if there are more than one fully free chunks, wake up grim reaper */\n\tif (chunk->free_bytes == pcpu_unit_size) {\n\t\tstruct pcpu_chunk *pos;\n\n\t\tlist_for_each_entry(pos, &pcpu_slot[pcpu_nr_slots - 1], list)\n\t\t\tif (pos != chunk) {\n\t\t\t\tpcpu_schedule_balance_work();\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\ttrace_percpu_free_percpu(chunk->base_addr, off, ptr);\n\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "pool->compact_wq"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&pool->work",
            "free_pages_work"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_singlethread_workqueue",
          "args": [
            "pool->name"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_singlethread_workqueue",
          "args": [
            "pool->name"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&pool->pages_nr",
            "0"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pool->stale"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pool->lru"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&unbuddied[i]"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_unbuddied_list",
          "args": [
            "i",
            "0"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "pool->unbuddied",
            "cpu"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__alloc_percpu",
          "args": [
            "sizeof(struct list_head)*NCHUNKS",
            "2"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "__alloc_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "1557-1560",
          "snippet": "void __percpu *__alloc_percpu(size_t size, size_t align)\n{\n\treturn pcpu_alloc(size, align, false, GFP_KERNEL);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nvoid __percpu *__alloc_percpu(size_t size, size_t align)\n{\n\treturn pcpu_alloc(size, align, false, GFP_KERNEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&pool->stale_lock"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&pool->lock"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct z3fold_pool)",
            "gfp"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\n#define NCHUNKS\t\t((PAGE_SIZE - ZHDR_SIZE_ALIGNED) >> CHUNK_SHIFT)\n\nstatic struct z3fold_pool *z3fold_create_pool(const char *name, gfp_t gfp,\n\t\tconst struct z3fold_ops *ops)\n{\n\tstruct z3fold_pool *pool = NULL;\n\tint i, cpu;\n\n\tpool = kzalloc(sizeof(struct z3fold_pool), gfp);\n\tif (!pool)\n\t\tgoto out;\n\tspin_lock_init(&pool->lock);\n\tspin_lock_init(&pool->stale_lock);\n\tpool->unbuddied = __alloc_percpu(sizeof(struct list_head)*NCHUNKS, 2);\n\tif (!pool->unbuddied)\n\t\tgoto out_pool;\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct list_head *unbuddied =\n\t\t\t\tper_cpu_ptr(pool->unbuddied, cpu);\n\t\tfor_each_unbuddied_list(i, 0)\n\t\t\tINIT_LIST_HEAD(&unbuddied[i]);\n\t}\n\tINIT_LIST_HEAD(&pool->lru);\n\tINIT_LIST_HEAD(&pool->stale);\n\tatomic64_set(&pool->pages_nr, 0);\n\tpool->name = name;\n\tpool->compact_wq = create_singlethread_workqueue(pool->name);\n\tif (!pool->compact_wq)\n\t\tgoto out_unbuddied;\n\tpool->release_wq = create_singlethread_workqueue(pool->name);\n\tif (!pool->release_wq)\n\t\tgoto out_wq;\n\tINIT_WORK(&pool->work, free_pages_work);\n\tpool->ops = ops;\n\treturn pool;\n\nout_wq:\n\tdestroy_workqueue(pool->compact_wq);\nout_unbuddied:\n\tfree_percpu(pool->unbuddied);\nout_pool:\n\tkfree(pool);\nout:\n\treturn NULL;\n}"
  },
  {
    "function_name": "compact_page_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
    "lines": "448-454",
    "snippet": "static void compact_page_work(struct work_struct *w)\n{\n\tstruct z3fold_header *zhdr = container_of(w, struct z3fold_header,\n\t\t\t\t\t\twork);\n\n\tdo_compact_page(zhdr, false);\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/sched.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void compact_page_work(struct work_struct *w);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_compact_page",
          "args": [
            "zhdr",
            "false"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "do_compact_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "407-446",
          "snippet": "static void do_compact_page(struct z3fold_header *zhdr, bool locked)\n{\n\tstruct z3fold_pool *pool = zhdr->pool;\n\tstruct page *page;\n\tstruct list_head *unbuddied;\n\tint fchunks;\n\n\tpage = virt_to_page(zhdr);\n\tif (locked)\n\t\tWARN_ON(z3fold_page_trylock(zhdr));\n\telse\n\t\tz3fold_page_lock(zhdr);\n\tif (WARN_ON(!test_and_clear_bit(NEEDS_COMPACTING, &page->private))) {\n\t\tz3fold_page_unlock(zhdr);\n\t\treturn;\n\t}\n\tspin_lock(&pool->lock);\n\tlist_del_init(&zhdr->buddy);\n\tspin_unlock(&pool->lock);\n\n\tif (kref_put(&zhdr->refcount, release_z3fold_page_locked)) {\n\t\tatomic64_dec(&pool->pages_nr);\n\t\treturn;\n\t}\n\n\tz3fold_compact_page(zhdr);\n\tunbuddied = get_cpu_ptr(pool->unbuddied);\n\tfchunks = num_free_chunks(zhdr);\n\tif (fchunks < NCHUNKS &&\n\t    (!zhdr->first_chunks || !zhdr->middle_chunks ||\n\t\t\t!zhdr->last_chunks)) {\n\t\t/* the page's not completely free and it's unbuddied */\n\t\tspin_lock(&pool->lock);\n\t\tlist_add(&zhdr->buddy, &unbuddied[fchunks]);\n\t\tspin_unlock(&pool->lock);\n\t\tzhdr->cpu = smp_processor_id();\n\t}\n\tput_cpu_ptr(pool->unbuddied);\n\tz3fold_page_unlock(zhdr);\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define NCHUNKS\t\t((PAGE_SIZE - ZHDR_SIZE_ALIGNED) >> CHUNK_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\n#define NCHUNKS\t\t((PAGE_SIZE - ZHDR_SIZE_ALIGNED) >> CHUNK_SHIFT)\n\nstatic void do_compact_page(struct z3fold_header *zhdr, bool locked)\n{\n\tstruct z3fold_pool *pool = zhdr->pool;\n\tstruct page *page;\n\tstruct list_head *unbuddied;\n\tint fchunks;\n\n\tpage = virt_to_page(zhdr);\n\tif (locked)\n\t\tWARN_ON(z3fold_page_trylock(zhdr));\n\telse\n\t\tz3fold_page_lock(zhdr);\n\tif (WARN_ON(!test_and_clear_bit(NEEDS_COMPACTING, &page->private))) {\n\t\tz3fold_page_unlock(zhdr);\n\t\treturn;\n\t}\n\tspin_lock(&pool->lock);\n\tlist_del_init(&zhdr->buddy);\n\tspin_unlock(&pool->lock);\n\n\tif (kref_put(&zhdr->refcount, release_z3fold_page_locked)) {\n\t\tatomic64_dec(&pool->pages_nr);\n\t\treturn;\n\t}\n\n\tz3fold_compact_page(zhdr);\n\tunbuddied = get_cpu_ptr(pool->unbuddied);\n\tfchunks = num_free_chunks(zhdr);\n\tif (fchunks < NCHUNKS &&\n\t    (!zhdr->first_chunks || !zhdr->middle_chunks ||\n\t\t\t!zhdr->last_chunks)) {\n\t\t/* the page's not completely free and it's unbuddied */\n\t\tspin_lock(&pool->lock);\n\t\tlist_add(&zhdr->buddy, &unbuddied[fchunks]);\n\t\tspin_unlock(&pool->lock);\n\t\tzhdr->cpu = smp_processor_id();\n\t}\n\tput_cpu_ptr(pool->unbuddied);\n\tz3fold_page_unlock(zhdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "w",
            "structz3fold_header",
            "work"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic void compact_page_work(struct work_struct *w);\n\nstatic void compact_page_work(struct work_struct *w)\n{\n\tstruct z3fold_header *zhdr = container_of(w, struct z3fold_header,\n\t\t\t\t\t\twork);\n\n\tdo_compact_page(zhdr, false);\n}"
  },
  {
    "function_name": "do_compact_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
    "lines": "407-446",
    "snippet": "static void do_compact_page(struct z3fold_header *zhdr, bool locked)\n{\n\tstruct z3fold_pool *pool = zhdr->pool;\n\tstruct page *page;\n\tstruct list_head *unbuddied;\n\tint fchunks;\n\n\tpage = virt_to_page(zhdr);\n\tif (locked)\n\t\tWARN_ON(z3fold_page_trylock(zhdr));\n\telse\n\t\tz3fold_page_lock(zhdr);\n\tif (WARN_ON(!test_and_clear_bit(NEEDS_COMPACTING, &page->private))) {\n\t\tz3fold_page_unlock(zhdr);\n\t\treturn;\n\t}\n\tspin_lock(&pool->lock);\n\tlist_del_init(&zhdr->buddy);\n\tspin_unlock(&pool->lock);\n\n\tif (kref_put(&zhdr->refcount, release_z3fold_page_locked)) {\n\t\tatomic64_dec(&pool->pages_nr);\n\t\treturn;\n\t}\n\n\tz3fold_compact_page(zhdr);\n\tunbuddied = get_cpu_ptr(pool->unbuddied);\n\tfchunks = num_free_chunks(zhdr);\n\tif (fchunks < NCHUNKS &&\n\t    (!zhdr->first_chunks || !zhdr->middle_chunks ||\n\t\t\t!zhdr->last_chunks)) {\n\t\t/* the page's not completely free and it's unbuddied */\n\t\tspin_lock(&pool->lock);\n\t\tlist_add(&zhdr->buddy, &unbuddied[fchunks]);\n\t\tspin_unlock(&pool->lock);\n\t\tzhdr->cpu = smp_processor_id();\n\t}\n\tput_cpu_ptr(pool->unbuddied);\n\tz3fold_page_unlock(zhdr);\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/sched.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define NCHUNKS\t\t((PAGE_SIZE - ZHDR_SIZE_ALIGNED) >> CHUNK_SHIFT)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "z3fold_page_unlock",
          "args": [
            "zhdr"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "z3fold_page_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "213-216",
          "snippet": "static inline void z3fold_page_unlock(struct z3fold_header *zhdr)\n{\n\tspin_unlock(&zhdr->page_lock);\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic inline void z3fold_page_unlock(struct z3fold_header *zhdr)\n{\n\tspin_unlock(&zhdr->page_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_cpu_ptr",
          "args": [
            "pool->unbuddied"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pool->lock"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&zhdr->buddy",
            "&unbuddied[fchunks]"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pool->lock"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_free_chunks",
          "args": [
            "zhdr"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "num_free_chunks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "332-350",
          "snippet": "static int num_free_chunks(struct z3fold_header *zhdr)\n{\n\tint nfree;\n\t/*\n\t * If there is a middle object, pick up the bigger free space\n\t * either before or after it. Otherwise just subtract the number\n\t * of chunks occupied by the first and the last objects.\n\t */\n\tif (zhdr->middle_chunks != 0) {\n\t\tint nfree_before = zhdr->first_chunks ?\n\t\t\t0 : zhdr->start_middle - ZHDR_CHUNKS;\n\t\tint nfree_after = zhdr->last_chunks ?\n\t\t\t0 : TOTAL_CHUNKS -\n\t\t\t\t(zhdr->start_middle + zhdr->middle_chunks);\n\t\tnfree = max(nfree_before, nfree_after);\n\t} else\n\t\tnfree = NCHUNKS - zhdr->first_chunks - zhdr->last_chunks;\n\treturn nfree;\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define NCHUNKS\t\t((PAGE_SIZE - ZHDR_SIZE_ALIGNED) >> CHUNK_SHIFT)",
            "#define TOTAL_CHUNKS\t(PAGE_SIZE >> CHUNK_SHIFT)",
            "#define ZHDR_CHUNKS\t(ZHDR_SIZE_ALIGNED >> CHUNK_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\n#define NCHUNKS\t\t((PAGE_SIZE - ZHDR_SIZE_ALIGNED) >> CHUNK_SHIFT)\n#define TOTAL_CHUNKS\t(PAGE_SIZE >> CHUNK_SHIFT)\n#define ZHDR_CHUNKS\t(ZHDR_SIZE_ALIGNED >> CHUNK_SHIFT)\n\nstatic int num_free_chunks(struct z3fold_header *zhdr)\n{\n\tint nfree;\n\t/*\n\t * If there is a middle object, pick up the bigger free space\n\t * either before or after it. Otherwise just subtract the number\n\t * of chunks occupied by the first and the last objects.\n\t */\n\tif (zhdr->middle_chunks != 0) {\n\t\tint nfree_before = zhdr->first_chunks ?\n\t\t\t0 : zhdr->start_middle - ZHDR_CHUNKS;\n\t\tint nfree_after = zhdr->last_chunks ?\n\t\t\t0 : TOTAL_CHUNKS -\n\t\t\t\t(zhdr->start_middle + zhdr->middle_chunks);\n\t\tnfree = max(nfree_before, nfree_after);\n\t} else\n\t\tnfree = NCHUNKS - zhdr->first_chunks - zhdr->last_chunks;\n\treturn nfree;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cpu_ptr",
          "args": [
            "pool->unbuddied"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "z3fold_compact_page",
          "args": [
            "zhdr"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "z3fold_compact_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "363-405",
          "snippet": "static int z3fold_compact_page(struct z3fold_header *zhdr)\n{\n\tstruct page *page = virt_to_page(zhdr);\n\n\tif (test_bit(MIDDLE_CHUNK_MAPPED, &page->private))\n\t\treturn 0; /* can't move middle chunk, it's used */\n\n\tif (zhdr->middle_chunks == 0)\n\t\treturn 0; /* nothing to compact */\n\n\tif (zhdr->first_chunks == 0 && zhdr->last_chunks == 0) {\n\t\t/* move to the beginning */\n\t\tmchunk_memmove(zhdr, ZHDR_CHUNKS);\n\t\tzhdr->first_chunks = zhdr->middle_chunks;\n\t\tzhdr->middle_chunks = 0;\n\t\tzhdr->start_middle = 0;\n\t\tzhdr->first_num++;\n\t\treturn 1;\n\t}\n\n\t/*\n\t * moving data is expensive, so let's only do that if\n\t * there's substantial gain (at least BIG_CHUNK_GAP chunks)\n\t */\n\tif (zhdr->first_chunks != 0 && zhdr->last_chunks == 0 &&\n\t    zhdr->start_middle - (zhdr->first_chunks + ZHDR_CHUNKS) >=\n\t\t\tBIG_CHUNK_GAP) {\n\t\tmchunk_memmove(zhdr, zhdr->first_chunks + ZHDR_CHUNKS);\n\t\tzhdr->start_middle = zhdr->first_chunks + ZHDR_CHUNKS;\n\t\treturn 1;\n\t} else if (zhdr->last_chunks != 0 && zhdr->first_chunks == 0 &&\n\t\t   TOTAL_CHUNKS - (zhdr->last_chunks + zhdr->start_middle\n\t\t\t\t\t+ zhdr->middle_chunks) >=\n\t\t\tBIG_CHUNK_GAP) {\n\t\tunsigned short new_start = TOTAL_CHUNKS - zhdr->last_chunks -\n\t\t\tzhdr->middle_chunks;\n\t\tmchunk_memmove(zhdr, new_start);\n\t\tzhdr->start_middle = new_start;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define BIG_CHUNK_GAP\t3",
            "#define TOTAL_CHUNKS\t(PAGE_SIZE >> CHUNK_SHIFT)",
            "#define ZHDR_CHUNKS\t(ZHDR_SIZE_ALIGNED >> CHUNK_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\n#define BIG_CHUNK_GAP\t3\n#define TOTAL_CHUNKS\t(PAGE_SIZE >> CHUNK_SHIFT)\n#define ZHDR_CHUNKS\t(ZHDR_SIZE_ALIGNED >> CHUNK_SHIFT)\n\nstatic int z3fold_compact_page(struct z3fold_header *zhdr)\n{\n\tstruct page *page = virt_to_page(zhdr);\n\n\tif (test_bit(MIDDLE_CHUNK_MAPPED, &page->private))\n\t\treturn 0; /* can't move middle chunk, it's used */\n\n\tif (zhdr->middle_chunks == 0)\n\t\treturn 0; /* nothing to compact */\n\n\tif (zhdr->first_chunks == 0 && zhdr->last_chunks == 0) {\n\t\t/* move to the beginning */\n\t\tmchunk_memmove(zhdr, ZHDR_CHUNKS);\n\t\tzhdr->first_chunks = zhdr->middle_chunks;\n\t\tzhdr->middle_chunks = 0;\n\t\tzhdr->start_middle = 0;\n\t\tzhdr->first_num++;\n\t\treturn 1;\n\t}\n\n\t/*\n\t * moving data is expensive, so let's only do that if\n\t * there's substantial gain (at least BIG_CHUNK_GAP chunks)\n\t */\n\tif (zhdr->first_chunks != 0 && zhdr->last_chunks == 0 &&\n\t    zhdr->start_middle - (zhdr->first_chunks + ZHDR_CHUNKS) >=\n\t\t\tBIG_CHUNK_GAP) {\n\t\tmchunk_memmove(zhdr, zhdr->first_chunks + ZHDR_CHUNKS);\n\t\tzhdr->start_middle = zhdr->first_chunks + ZHDR_CHUNKS;\n\t\treturn 1;\n\t} else if (zhdr->last_chunks != 0 && zhdr->first_chunks == 0 &&\n\t\t   TOTAL_CHUNKS - (zhdr->last_chunks + zhdr->start_middle\n\t\t\t\t\t+ zhdr->middle_chunks) >=\n\t\t\tBIG_CHUNK_GAP) {\n\t\tunsigned short new_start = TOTAL_CHUNKS - zhdr->last_chunks -\n\t\t\tzhdr->middle_chunks;\n\t\tmchunk_memmove(zhdr, new_start);\n\t\tzhdr->start_middle = new_start;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic64_dec",
          "args": [
            "&pool->pages_nr"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&zhdr->refcount",
            "release_z3fold_page_locked"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pool->lock"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&zhdr->buddy"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pool->lock"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!test_and_clear_bit(NEEDS_COMPACTING, &page->private)"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "NEEDS_COMPACTING",
            "&page->private"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "z3fold_page_lock",
          "args": [
            "zhdr"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "release_z3fold_page_locked_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "294-304",
          "snippet": "static void release_z3fold_page_locked_list(struct kref *ref)\n{\n\tstruct z3fold_header *zhdr = container_of(ref, struct z3fold_header,\n\t\t\t\t\t       refcount);\n\tspin_lock(&zhdr->pool->lock);\n\tlist_del_init(&zhdr->buddy);\n\tspin_unlock(&zhdr->pool->lock);\n\n\tWARN_ON(z3fold_page_trylock(zhdr));\n\t__release_z3fold_page(zhdr, true);\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic void release_z3fold_page_locked_list(struct kref *ref)\n{\n\tstruct z3fold_header *zhdr = container_of(ref, struct z3fold_header,\n\t\t\t\t\t       refcount);\n\tspin_lock(&zhdr->pool->lock);\n\tlist_del_init(&zhdr->buddy);\n\tspin_unlock(&zhdr->pool->lock);\n\n\tWARN_ON(z3fold_page_trylock(zhdr));\n\t__release_z3fold_page(zhdr, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "z3fold_page_trylock(zhdr)"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "z3fold_page_trylock",
          "args": [
            "zhdr"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "z3fold_page_trylock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "207-210",
          "snippet": "static inline int z3fold_page_trylock(struct z3fold_header *zhdr)\n{\n\treturn spin_trylock(&zhdr->page_lock);\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic inline int z3fold_page_trylock(struct z3fold_header *zhdr)\n{\n\treturn spin_trylock(&zhdr->page_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "zhdr"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\n#define NCHUNKS\t\t((PAGE_SIZE - ZHDR_SIZE_ALIGNED) >> CHUNK_SHIFT)\n\nstatic void do_compact_page(struct z3fold_header *zhdr, bool locked)\n{\n\tstruct z3fold_pool *pool = zhdr->pool;\n\tstruct page *page;\n\tstruct list_head *unbuddied;\n\tint fchunks;\n\n\tpage = virt_to_page(zhdr);\n\tif (locked)\n\t\tWARN_ON(z3fold_page_trylock(zhdr));\n\telse\n\t\tz3fold_page_lock(zhdr);\n\tif (WARN_ON(!test_and_clear_bit(NEEDS_COMPACTING, &page->private))) {\n\t\tz3fold_page_unlock(zhdr);\n\t\treturn;\n\t}\n\tspin_lock(&pool->lock);\n\tlist_del_init(&zhdr->buddy);\n\tspin_unlock(&pool->lock);\n\n\tif (kref_put(&zhdr->refcount, release_z3fold_page_locked)) {\n\t\tatomic64_dec(&pool->pages_nr);\n\t\treturn;\n\t}\n\n\tz3fold_compact_page(zhdr);\n\tunbuddied = get_cpu_ptr(pool->unbuddied);\n\tfchunks = num_free_chunks(zhdr);\n\tif (fchunks < NCHUNKS &&\n\t    (!zhdr->first_chunks || !zhdr->middle_chunks ||\n\t\t\t!zhdr->last_chunks)) {\n\t\t/* the page's not completely free and it's unbuddied */\n\t\tspin_lock(&pool->lock);\n\t\tlist_add(&zhdr->buddy, &unbuddied[fchunks]);\n\t\tspin_unlock(&pool->lock);\n\t\tzhdr->cpu = smp_processor_id();\n\t}\n\tput_cpu_ptr(pool->unbuddied);\n\tz3fold_page_unlock(zhdr);\n}"
  },
  {
    "function_name": "z3fold_compact_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
    "lines": "363-405",
    "snippet": "static int z3fold_compact_page(struct z3fold_header *zhdr)\n{\n\tstruct page *page = virt_to_page(zhdr);\n\n\tif (test_bit(MIDDLE_CHUNK_MAPPED, &page->private))\n\t\treturn 0; /* can't move middle chunk, it's used */\n\n\tif (zhdr->middle_chunks == 0)\n\t\treturn 0; /* nothing to compact */\n\n\tif (zhdr->first_chunks == 0 && zhdr->last_chunks == 0) {\n\t\t/* move to the beginning */\n\t\tmchunk_memmove(zhdr, ZHDR_CHUNKS);\n\t\tzhdr->first_chunks = zhdr->middle_chunks;\n\t\tzhdr->middle_chunks = 0;\n\t\tzhdr->start_middle = 0;\n\t\tzhdr->first_num++;\n\t\treturn 1;\n\t}\n\n\t/*\n\t * moving data is expensive, so let's only do that if\n\t * there's substantial gain (at least BIG_CHUNK_GAP chunks)\n\t */\n\tif (zhdr->first_chunks != 0 && zhdr->last_chunks == 0 &&\n\t    zhdr->start_middle - (zhdr->first_chunks + ZHDR_CHUNKS) >=\n\t\t\tBIG_CHUNK_GAP) {\n\t\tmchunk_memmove(zhdr, zhdr->first_chunks + ZHDR_CHUNKS);\n\t\tzhdr->start_middle = zhdr->first_chunks + ZHDR_CHUNKS;\n\t\treturn 1;\n\t} else if (zhdr->last_chunks != 0 && zhdr->first_chunks == 0 &&\n\t\t   TOTAL_CHUNKS - (zhdr->last_chunks + zhdr->start_middle\n\t\t\t\t\t+ zhdr->middle_chunks) >=\n\t\t\tBIG_CHUNK_GAP) {\n\t\tunsigned short new_start = TOTAL_CHUNKS - zhdr->last_chunks -\n\t\t\tzhdr->middle_chunks;\n\t\tmchunk_memmove(zhdr, new_start);\n\t\tzhdr->start_middle = new_start;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/sched.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define BIG_CHUNK_GAP\t3",
      "#define TOTAL_CHUNKS\t(PAGE_SIZE >> CHUNK_SHIFT)",
      "#define ZHDR_CHUNKS\t(ZHDR_SIZE_ALIGNED >> CHUNK_SHIFT)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mchunk_memmove",
          "args": [
            "zhdr",
            "new_start"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "mchunk_memmove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "352-359",
          "snippet": "static inline void *mchunk_memmove(struct z3fold_header *zhdr,\n\t\t\t\tunsigned short dst_chunk)\n{\n\tvoid *beg = zhdr;\n\treturn memmove(beg + (dst_chunk << CHUNK_SHIFT),\n\t\t       beg + (zhdr->start_middle << CHUNK_SHIFT),\n\t\t       zhdr->middle_chunks << CHUNK_SHIFT);\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define CHUNK_SHIFT\t(PAGE_SHIFT - NCHUNKS_ORDER)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\n#define CHUNK_SHIFT\t(PAGE_SHIFT - NCHUNKS_ORDER)\n\nstatic inline void *mchunk_memmove(struct z3fold_header *zhdr,\n\t\t\t\tunsigned short dst_chunk)\n{\n\tvoid *beg = zhdr;\n\treturn memmove(beg + (dst_chunk << CHUNK_SHIFT),\n\t\t       beg + (zhdr->start_middle << CHUNK_SHIFT),\n\t\t       zhdr->middle_chunks << CHUNK_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "MIDDLE_CHUNK_MAPPED",
            "&page->private"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "zhdr"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\n#define BIG_CHUNK_GAP\t3\n#define TOTAL_CHUNKS\t(PAGE_SIZE >> CHUNK_SHIFT)\n#define ZHDR_CHUNKS\t(ZHDR_SIZE_ALIGNED >> CHUNK_SHIFT)\n\nstatic int z3fold_compact_page(struct z3fold_header *zhdr)\n{\n\tstruct page *page = virt_to_page(zhdr);\n\n\tif (test_bit(MIDDLE_CHUNK_MAPPED, &page->private))\n\t\treturn 0; /* can't move middle chunk, it's used */\n\n\tif (zhdr->middle_chunks == 0)\n\t\treturn 0; /* nothing to compact */\n\n\tif (zhdr->first_chunks == 0 && zhdr->last_chunks == 0) {\n\t\t/* move to the beginning */\n\t\tmchunk_memmove(zhdr, ZHDR_CHUNKS);\n\t\tzhdr->first_chunks = zhdr->middle_chunks;\n\t\tzhdr->middle_chunks = 0;\n\t\tzhdr->start_middle = 0;\n\t\tzhdr->first_num++;\n\t\treturn 1;\n\t}\n\n\t/*\n\t * moving data is expensive, so let's only do that if\n\t * there's substantial gain (at least BIG_CHUNK_GAP chunks)\n\t */\n\tif (zhdr->first_chunks != 0 && zhdr->last_chunks == 0 &&\n\t    zhdr->start_middle - (zhdr->first_chunks + ZHDR_CHUNKS) >=\n\t\t\tBIG_CHUNK_GAP) {\n\t\tmchunk_memmove(zhdr, zhdr->first_chunks + ZHDR_CHUNKS);\n\t\tzhdr->start_middle = zhdr->first_chunks + ZHDR_CHUNKS;\n\t\treturn 1;\n\t} else if (zhdr->last_chunks != 0 && zhdr->first_chunks == 0 &&\n\t\t   TOTAL_CHUNKS - (zhdr->last_chunks + zhdr->start_middle\n\t\t\t\t\t+ zhdr->middle_chunks) >=\n\t\t\tBIG_CHUNK_GAP) {\n\t\tunsigned short new_start = TOTAL_CHUNKS - zhdr->last_chunks -\n\t\t\tzhdr->middle_chunks;\n\t\tmchunk_memmove(zhdr, new_start);\n\t\tzhdr->start_middle = new_start;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "mchunk_memmove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
    "lines": "352-359",
    "snippet": "static inline void *mchunk_memmove(struct z3fold_header *zhdr,\n\t\t\t\tunsigned short dst_chunk)\n{\n\tvoid *beg = zhdr;\n\treturn memmove(beg + (dst_chunk << CHUNK_SHIFT),\n\t\t       beg + (zhdr->start_middle << CHUNK_SHIFT),\n\t\t       zhdr->middle_chunks << CHUNK_SHIFT);\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/sched.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define CHUNK_SHIFT\t(PAGE_SHIFT - NCHUNKS_ORDER)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "beg + (dst_chunk << CHUNK_SHIFT)",
            "beg + (zhdr->start_middle << CHUNK_SHIFT)",
            "zhdr->middle_chunks << CHUNK_SHIFT"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "memmove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "291-297",
          "snippet": "void *memmove(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memmove(dest, src, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memmove(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memmove(dest, src, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\n#define CHUNK_SHIFT\t(PAGE_SHIFT - NCHUNKS_ORDER)\n\nstatic inline void *mchunk_memmove(struct z3fold_header *zhdr,\n\t\t\t\tunsigned short dst_chunk)\n{\n\tvoid *beg = zhdr;\n\treturn memmove(beg + (dst_chunk << CHUNK_SHIFT),\n\t\t       beg + (zhdr->start_middle << CHUNK_SHIFT),\n\t\t       zhdr->middle_chunks << CHUNK_SHIFT);\n}"
  },
  {
    "function_name": "num_free_chunks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
    "lines": "332-350",
    "snippet": "static int num_free_chunks(struct z3fold_header *zhdr)\n{\n\tint nfree;\n\t/*\n\t * If there is a middle object, pick up the bigger free space\n\t * either before or after it. Otherwise just subtract the number\n\t * of chunks occupied by the first and the last objects.\n\t */\n\tif (zhdr->middle_chunks != 0) {\n\t\tint nfree_before = zhdr->first_chunks ?\n\t\t\t0 : zhdr->start_middle - ZHDR_CHUNKS;\n\t\tint nfree_after = zhdr->last_chunks ?\n\t\t\t0 : TOTAL_CHUNKS -\n\t\t\t\t(zhdr->start_middle + zhdr->middle_chunks);\n\t\tnfree = max(nfree_before, nfree_after);\n\t} else\n\t\tnfree = NCHUNKS - zhdr->first_chunks - zhdr->last_chunks;\n\treturn nfree;\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/sched.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define NCHUNKS\t\t((PAGE_SIZE - ZHDR_SIZE_ALIGNED) >> CHUNK_SHIFT)",
      "#define TOTAL_CHUNKS\t(PAGE_SIZE >> CHUNK_SHIFT)",
      "#define ZHDR_CHUNKS\t(ZHDR_SIZE_ALIGNED >> CHUNK_SHIFT)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "max",
          "args": [
            "nfree_before",
            "nfree_after"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\n#define NCHUNKS\t\t((PAGE_SIZE - ZHDR_SIZE_ALIGNED) >> CHUNK_SHIFT)\n#define TOTAL_CHUNKS\t(PAGE_SIZE >> CHUNK_SHIFT)\n#define ZHDR_CHUNKS\t(ZHDR_SIZE_ALIGNED >> CHUNK_SHIFT)\n\nstatic int num_free_chunks(struct z3fold_header *zhdr)\n{\n\tint nfree;\n\t/*\n\t * If there is a middle object, pick up the bigger free space\n\t * either before or after it. Otherwise just subtract the number\n\t * of chunks occupied by the first and the last objects.\n\t */\n\tif (zhdr->middle_chunks != 0) {\n\t\tint nfree_before = zhdr->first_chunks ?\n\t\t\t0 : zhdr->start_middle - ZHDR_CHUNKS;\n\t\tint nfree_after = zhdr->last_chunks ?\n\t\t\t0 : TOTAL_CHUNKS -\n\t\t\t\t(zhdr->start_middle + zhdr->middle_chunks);\n\t\tnfree = max(nfree_before, nfree_after);\n\t} else\n\t\tnfree = NCHUNKS - zhdr->first_chunks - zhdr->last_chunks;\n\treturn nfree;\n}"
  },
  {
    "function_name": "free_pages_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
    "lines": "306-326",
    "snippet": "static void free_pages_work(struct work_struct *w)\n{\n\tstruct z3fold_pool *pool = container_of(w, struct z3fold_pool, work);\n\n\tspin_lock(&pool->stale_lock);\n\twhile (!list_empty(&pool->stale)) {\n\t\tstruct z3fold_header *zhdr = list_first_entry(&pool->stale,\n\t\t\t\t\t\tstruct z3fold_header, buddy);\n\t\tstruct page *page = virt_to_page(zhdr);\n\n\t\tlist_del(&zhdr->buddy);\n\t\tif (WARN_ON(!test_bit(PAGE_STALE, &page->private)))\n\t\t\tcontinue;\n\t\tspin_unlock(&pool->stale_lock);\n\t\tcancel_work_sync(&zhdr->work);\n\t\tfree_z3fold_page(page);\n\t\tcond_resched();\n\t\tspin_lock(&pool->stale_lock);\n\t}\n\tspin_unlock(&pool->stale_lock);\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/sched.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void compact_page_work(struct work_struct *w);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pool->stale_lock"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pool->stale_lock"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_z3fold_page",
          "args": [
            "page"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "free_z3fold_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "195-198",
          "snippet": "static void free_z3fold_page(struct page *page)\n{\n\t__free_page(page);\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic void free_z3fold_page(struct page *page)\n{\n\t__free_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cancel_work_sync",
          "args": [
            "&zhdr->work"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pool->stale_lock"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!test_bit(PAGE_STALE, &page->private)"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "PAGE_STALE",
            "&page->private"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&zhdr->buddy"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "zhdr"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&pool->stale",
            "structz3fold_header",
            "buddy"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pool->stale"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pool->stale_lock"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "w",
            "structz3fold_pool",
            "work"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic void compact_page_work(struct work_struct *w);\n\nstatic void free_pages_work(struct work_struct *w)\n{\n\tstruct z3fold_pool *pool = container_of(w, struct z3fold_pool, work);\n\n\tspin_lock(&pool->stale_lock);\n\twhile (!list_empty(&pool->stale)) {\n\t\tstruct z3fold_header *zhdr = list_first_entry(&pool->stale,\n\t\t\t\t\t\tstruct z3fold_header, buddy);\n\t\tstruct page *page = virt_to_page(zhdr);\n\n\t\tlist_del(&zhdr->buddy);\n\t\tif (WARN_ON(!test_bit(PAGE_STALE, &page->private)))\n\t\t\tcontinue;\n\t\tspin_unlock(&pool->stale_lock);\n\t\tcancel_work_sync(&zhdr->work);\n\t\tfree_z3fold_page(page);\n\t\tcond_resched();\n\t\tspin_lock(&pool->stale_lock);\n\t}\n\tspin_unlock(&pool->stale_lock);\n}"
  },
  {
    "function_name": "release_z3fold_page_locked_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
    "lines": "294-304",
    "snippet": "static void release_z3fold_page_locked_list(struct kref *ref)\n{\n\tstruct z3fold_header *zhdr = container_of(ref, struct z3fold_header,\n\t\t\t\t\t       refcount);\n\tspin_lock(&zhdr->pool->lock);\n\tlist_del_init(&zhdr->buddy);\n\tspin_unlock(&zhdr->pool->lock);\n\n\tWARN_ON(z3fold_page_trylock(zhdr));\n\t__release_z3fold_page(zhdr, true);\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/sched.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__release_z3fold_page",
          "args": [
            "zhdr",
            "true"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "__release_z3fold_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "258-276",
          "snippet": "static void __release_z3fold_page(struct z3fold_header *zhdr, bool locked)\n{\n\tstruct page *page = virt_to_page(zhdr);\n\tstruct z3fold_pool *pool = zhdr->pool;\n\n\tWARN_ON(!list_empty(&zhdr->buddy));\n\tset_bit(PAGE_STALE, &page->private);\n\tclear_bit(NEEDS_COMPACTING, &page->private);\n\tspin_lock(&pool->lock);\n\tif (!list_empty(&page->lru))\n\t\tlist_del(&page->lru);\n\tspin_unlock(&pool->lock);\n\tif (locked)\n\t\tz3fold_page_unlock(zhdr);\n\tspin_lock(&pool->stale_lock);\n\tlist_add(&zhdr->buddy, &pool->stale);\n\tqueue_work(pool->release_wq, &pool->work);\n\tspin_unlock(&pool->stale_lock);\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic void __release_z3fold_page(struct z3fold_header *zhdr, bool locked)\n{\n\tstruct page *page = virt_to_page(zhdr);\n\tstruct z3fold_pool *pool = zhdr->pool;\n\n\tWARN_ON(!list_empty(&zhdr->buddy));\n\tset_bit(PAGE_STALE, &page->private);\n\tclear_bit(NEEDS_COMPACTING, &page->private);\n\tspin_lock(&pool->lock);\n\tif (!list_empty(&page->lru))\n\t\tlist_del(&page->lru);\n\tspin_unlock(&pool->lock);\n\tif (locked)\n\t\tz3fold_page_unlock(zhdr);\n\tspin_lock(&pool->stale_lock);\n\tlist_add(&zhdr->buddy, &pool->stale);\n\tqueue_work(pool->release_wq, &pool->work);\n\tspin_unlock(&pool->stale_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "z3fold_page_trylock(zhdr)"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "z3fold_page_trylock",
          "args": [
            "zhdr"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "z3fold_page_trylock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "207-210",
          "snippet": "static inline int z3fold_page_trylock(struct z3fold_header *zhdr)\n{\n\treturn spin_trylock(&zhdr->page_lock);\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic inline int z3fold_page_trylock(struct z3fold_header *zhdr)\n{\n\treturn spin_trylock(&zhdr->page_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&zhdr->pool->lock"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&zhdr->buddy"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&zhdr->pool->lock"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ref",
            "structz3fold_header",
            "refcount"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic void release_z3fold_page_locked_list(struct kref *ref)\n{\n\tstruct z3fold_header *zhdr = container_of(ref, struct z3fold_header,\n\t\t\t\t\t       refcount);\n\tspin_lock(&zhdr->pool->lock);\n\tlist_del_init(&zhdr->buddy);\n\tspin_unlock(&zhdr->pool->lock);\n\n\tWARN_ON(z3fold_page_trylock(zhdr));\n\t__release_z3fold_page(zhdr, true);\n}"
  },
  {
    "function_name": "release_z3fold_page_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
    "lines": "286-292",
    "snippet": "static void release_z3fold_page_locked(struct kref *ref)\n{\n\tstruct z3fold_header *zhdr = container_of(ref, struct z3fold_header,\n\t\t\t\t\t\trefcount);\n\tWARN_ON(z3fold_page_trylock(zhdr));\n\t__release_z3fold_page(zhdr, true);\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/sched.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__release_z3fold_page",
          "args": [
            "zhdr",
            "true"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "__release_z3fold_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "258-276",
          "snippet": "static void __release_z3fold_page(struct z3fold_header *zhdr, bool locked)\n{\n\tstruct page *page = virt_to_page(zhdr);\n\tstruct z3fold_pool *pool = zhdr->pool;\n\n\tWARN_ON(!list_empty(&zhdr->buddy));\n\tset_bit(PAGE_STALE, &page->private);\n\tclear_bit(NEEDS_COMPACTING, &page->private);\n\tspin_lock(&pool->lock);\n\tif (!list_empty(&page->lru))\n\t\tlist_del(&page->lru);\n\tspin_unlock(&pool->lock);\n\tif (locked)\n\t\tz3fold_page_unlock(zhdr);\n\tspin_lock(&pool->stale_lock);\n\tlist_add(&zhdr->buddy, &pool->stale);\n\tqueue_work(pool->release_wq, &pool->work);\n\tspin_unlock(&pool->stale_lock);\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic void __release_z3fold_page(struct z3fold_header *zhdr, bool locked)\n{\n\tstruct page *page = virt_to_page(zhdr);\n\tstruct z3fold_pool *pool = zhdr->pool;\n\n\tWARN_ON(!list_empty(&zhdr->buddy));\n\tset_bit(PAGE_STALE, &page->private);\n\tclear_bit(NEEDS_COMPACTING, &page->private);\n\tspin_lock(&pool->lock);\n\tif (!list_empty(&page->lru))\n\t\tlist_del(&page->lru);\n\tspin_unlock(&pool->lock);\n\tif (locked)\n\t\tz3fold_page_unlock(zhdr);\n\tspin_lock(&pool->stale_lock);\n\tlist_add(&zhdr->buddy, &pool->stale);\n\tqueue_work(pool->release_wq, &pool->work);\n\tspin_unlock(&pool->stale_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "z3fold_page_trylock(zhdr)"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "z3fold_page_trylock",
          "args": [
            "zhdr"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "z3fold_page_trylock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "207-210",
          "snippet": "static inline int z3fold_page_trylock(struct z3fold_header *zhdr)\n{\n\treturn spin_trylock(&zhdr->page_lock);\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic inline int z3fold_page_trylock(struct z3fold_header *zhdr)\n{\n\treturn spin_trylock(&zhdr->page_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ref",
            "structz3fold_header",
            "refcount"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic void release_z3fold_page_locked(struct kref *ref)\n{\n\tstruct z3fold_header *zhdr = container_of(ref, struct z3fold_header,\n\t\t\t\t\t\trefcount);\n\tWARN_ON(z3fold_page_trylock(zhdr));\n\t__release_z3fold_page(zhdr, true);\n}"
  },
  {
    "function_name": "release_z3fold_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
    "lines": "278-284",
    "snippet": "static void __attribute__((__unused__))\n\t\t\trelease_z3fold_page(struct kref *ref)\n{\n\tstruct z3fold_header *zhdr = container_of(ref, struct z3fold_header,\n\t\t\t\t\t\trefcount);\n\t__release_z3fold_page(zhdr, false);\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/sched.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__release_z3fold_page",
          "args": [
            "zhdr",
            "false"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "__release_z3fold_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "258-276",
          "snippet": "static void __release_z3fold_page(struct z3fold_header *zhdr, bool locked)\n{\n\tstruct page *page = virt_to_page(zhdr);\n\tstruct z3fold_pool *pool = zhdr->pool;\n\n\tWARN_ON(!list_empty(&zhdr->buddy));\n\tset_bit(PAGE_STALE, &page->private);\n\tclear_bit(NEEDS_COMPACTING, &page->private);\n\tspin_lock(&pool->lock);\n\tif (!list_empty(&page->lru))\n\t\tlist_del(&page->lru);\n\tspin_unlock(&pool->lock);\n\tif (locked)\n\t\tz3fold_page_unlock(zhdr);\n\tspin_lock(&pool->stale_lock);\n\tlist_add(&zhdr->buddy, &pool->stale);\n\tqueue_work(pool->release_wq, &pool->work);\n\tspin_unlock(&pool->stale_lock);\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic void __release_z3fold_page(struct z3fold_header *zhdr, bool locked)\n{\n\tstruct page *page = virt_to_page(zhdr);\n\tstruct z3fold_pool *pool = zhdr->pool;\n\n\tWARN_ON(!list_empty(&zhdr->buddy));\n\tset_bit(PAGE_STALE, &page->private);\n\tclear_bit(NEEDS_COMPACTING, &page->private);\n\tspin_lock(&pool->lock);\n\tif (!list_empty(&page->lru))\n\t\tlist_del(&page->lru);\n\tspin_unlock(&pool->lock);\n\tif (locked)\n\t\tz3fold_page_unlock(zhdr);\n\tspin_lock(&pool->stale_lock);\n\tlist_add(&zhdr->buddy, &pool->stale);\n\tqueue_work(pool->release_wq, &pool->work);\n\tspin_unlock(&pool->stale_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ref",
            "structz3fold_header",
            "refcount"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic void __attribute__((__unused__))\n\t\t\trelease_z3fold_page(struct kref *ref)\n{\n\tstruct z3fold_header *zhdr = container_of(ref, struct z3fold_header,\n\t\t\t\t\t\trefcount);\n\t__release_z3fold_page(zhdr, false);\n}"
  },
  {
    "function_name": "__release_z3fold_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
    "lines": "258-276",
    "snippet": "static void __release_z3fold_page(struct z3fold_header *zhdr, bool locked)\n{\n\tstruct page *page = virt_to_page(zhdr);\n\tstruct z3fold_pool *pool = zhdr->pool;\n\n\tWARN_ON(!list_empty(&zhdr->buddy));\n\tset_bit(PAGE_STALE, &page->private);\n\tclear_bit(NEEDS_COMPACTING, &page->private);\n\tspin_lock(&pool->lock);\n\tif (!list_empty(&page->lru))\n\t\tlist_del(&page->lru);\n\tspin_unlock(&pool->lock);\n\tif (locked)\n\t\tz3fold_page_unlock(zhdr);\n\tspin_lock(&pool->stale_lock);\n\tlist_add(&zhdr->buddy, &pool->stale);\n\tqueue_work(pool->release_wq, &pool->work);\n\tspin_unlock(&pool->stale_lock);\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/sched.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pool->stale_lock"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "pool->release_wq",
            "&pool->work"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&zhdr->buddy",
            "&pool->stale"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pool->stale_lock"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "z3fold_page_unlock",
          "args": [
            "zhdr"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "z3fold_page_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "213-216",
          "snippet": "static inline void z3fold_page_unlock(struct z3fold_header *zhdr)\n{\n\tspin_unlock(&zhdr->page_lock);\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic inline void z3fold_page_unlock(struct z3fold_header *zhdr)\n{\n\tspin_unlock(&zhdr->page_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pool->lock"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&page->lru"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pool->lock"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "NEEDS_COMPACTING",
            "&page->private"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "clear_bit_unlock_is_negative_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1171-1176",
          "snippet": "static inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "PAGE_STALE",
            "&page->private"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&zhdr->buddy)"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "zhdr"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic void __release_z3fold_page(struct z3fold_header *zhdr, bool locked)\n{\n\tstruct page *page = virt_to_page(zhdr);\n\tstruct z3fold_pool *pool = zhdr->pool;\n\n\tWARN_ON(!list_empty(&zhdr->buddy));\n\tset_bit(PAGE_STALE, &page->private);\n\tclear_bit(NEEDS_COMPACTING, &page->private);\n\tspin_lock(&pool->lock);\n\tif (!list_empty(&page->lru))\n\t\tlist_del(&page->lru);\n\tspin_unlock(&pool->lock);\n\tif (locked)\n\t\tz3fold_page_unlock(zhdr);\n\tspin_lock(&pool->stale_lock);\n\tlist_add(&zhdr->buddy, &pool->stale);\n\tqueue_work(pool->release_wq, &pool->work);\n\tspin_unlock(&pool->stale_lock);\n}"
  },
  {
    "function_name": "handle_to_buddy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
    "lines": "252-256",
    "snippet": "static enum buddy handle_to_buddy(unsigned long handle)\n{\n\tstruct z3fold_header *zhdr = handle_to_z3fold_header(handle);\n\treturn (handle - zhdr->first_num) & BUDDY_MASK;\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/sched.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define BUDDY_MASK\t(0x3)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "handle_to_z3fold_header",
          "args": [
            "handle"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "handle_to_z3fold_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
          "lines": "236-239",
          "snippet": "static struct z3fold_header *handle_to_z3fold_header(unsigned long handle)\n{\n\treturn (struct z3fold_header *)(handle & PAGE_MASK);\n}",
          "includes": [
            "#include <linux/zpool.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic struct z3fold_header *handle_to_z3fold_header(unsigned long handle)\n{\n\treturn (struct z3fold_header *)(handle & PAGE_MASK);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\n#define BUDDY_MASK\t(0x3)\n\nstatic enum buddy handle_to_buddy(unsigned long handle)\n{\n\tstruct z3fold_header *zhdr = handle_to_z3fold_header(handle);\n\treturn (handle - zhdr->first_num) & BUDDY_MASK;\n}"
  },
  {
    "function_name": "handle_to_chunks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
    "lines": "242-245",
    "snippet": "static unsigned short handle_to_chunks(unsigned long handle)\n{\n\treturn (handle & ~PAGE_MASK) >> BUDDY_SHIFT;\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/sched.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define BUDDY_SHIFT\t2"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\n#define BUDDY_SHIFT\t2\n\nstatic unsigned short handle_to_chunks(unsigned long handle)\n{\n\treturn (handle & ~PAGE_MASK) >> BUDDY_SHIFT;\n}"
  },
  {
    "function_name": "handle_to_z3fold_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
    "lines": "236-239",
    "snippet": "static struct z3fold_header *handle_to_z3fold_header(unsigned long handle)\n{\n\treturn (struct z3fold_header *)(handle & PAGE_MASK);\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/sched.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic struct z3fold_header *handle_to_z3fold_header(unsigned long handle)\n{\n\treturn (struct z3fold_header *)(handle & PAGE_MASK);\n}"
  },
  {
    "function_name": "encode_handle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
    "lines": "222-233",
    "snippet": "static unsigned long encode_handle(struct z3fold_header *zhdr, enum buddy bud)\n{\n\tunsigned long handle;\n\n\thandle = (unsigned long)zhdr;\n\tif (bud != HEADLESS) {\n\t\thandle |= (bud + zhdr->first_num) & BUDDY_MASK;\n\t\tif (bud == LAST)\n\t\t\thandle |= (zhdr->last_chunks << BUDDY_SHIFT);\n\t}\n\treturn handle;\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/sched.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define BUDDY_SHIFT\t2",
      "#define BUDDY_MASK\t(0x3)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\n#define BUDDY_SHIFT\t2\n#define BUDDY_MASK\t(0x3)\n\nstatic unsigned long encode_handle(struct z3fold_header *zhdr, enum buddy bud)\n{\n\tunsigned long handle;\n\n\thandle = (unsigned long)zhdr;\n\tif (bud != HEADLESS) {\n\t\thandle |= (bud + zhdr->first_num) & BUDDY_MASK;\n\t\tif (bud == LAST)\n\t\t\thandle |= (zhdr->last_chunks << BUDDY_SHIFT);\n\t}\n\treturn handle;\n}"
  },
  {
    "function_name": "z3fold_page_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
    "lines": "213-216",
    "snippet": "static inline void z3fold_page_unlock(struct z3fold_header *zhdr)\n{\n\tspin_unlock(&zhdr->page_lock);\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/sched.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&zhdr->page_lock"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic inline void z3fold_page_unlock(struct z3fold_header *zhdr)\n{\n\tspin_unlock(&zhdr->page_lock);\n}"
  },
  {
    "function_name": "z3fold_page_trylock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
    "lines": "207-210",
    "snippet": "static inline int z3fold_page_trylock(struct z3fold_header *zhdr)\n{\n\treturn spin_trylock(&zhdr->page_lock);\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/sched.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_trylock",
          "args": [
            "&zhdr->page_lock"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic inline int z3fold_page_trylock(struct z3fold_header *zhdr)\n{\n\treturn spin_trylock(&zhdr->page_lock);\n}"
  },
  {
    "function_name": "z3fold_page_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
    "lines": "201-204",
    "snippet": "static inline void z3fold_page_lock(struct z3fold_header *zhdr)\n{\n\tspin_lock(&zhdr->page_lock);\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/sched.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&zhdr->page_lock"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic inline void z3fold_page_lock(struct z3fold_header *zhdr)\n{\n\tspin_lock(&zhdr->page_lock);\n}"
  },
  {
    "function_name": "free_z3fold_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
    "lines": "195-198",
    "snippet": "static void free_z3fold_page(struct page *page)\n{\n\t__free_page(page);\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/sched.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "page"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "__free_page_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "280-291",
          "snippet": "static void __free_page_ext(unsigned long pfn)\n{\n\tstruct mem_section *ms;\n\tstruct page_ext *base;\n\n\tms = __pfn_to_section(pfn);\n\tif (!ms || !ms->page_ext)\n\t\treturn;\n\tbase = get_entry(ms->page_ext, pfn);\n\tfree_page_ext(base);\n\tms->page_ext = NULL;\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/memory.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic void __free_page_ext(unsigned long pfn)\n{\n\tstruct mem_section *ms;\n\tstruct page_ext *base;\n\n\tms = __pfn_to_section(pfn);\n\tif (!ms || !ms->page_ext)\n\t\treturn;\n\tbase = get_entry(ms->page_ext, pfn);\n\tfree_page_ext(base);\n\tms->page_ext = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic void free_z3fold_page(struct page *page)\n{\n\t__free_page(page);\n}"
  },
  {
    "function_name": "init_z3fold_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
    "lines": "168-192",
    "snippet": "static struct z3fold_header *init_z3fold_page(struct page *page,\n\t\t\t\t\tstruct z3fold_pool *pool)\n{\n\tstruct z3fold_header *zhdr = page_address(page);\n\n\tINIT_LIST_HEAD(&page->lru);\n\tclear_bit(PAGE_HEADLESS, &page->private);\n\tclear_bit(MIDDLE_CHUNK_MAPPED, &page->private);\n\tclear_bit(NEEDS_COMPACTING, &page->private);\n\tclear_bit(PAGE_STALE, &page->private);\n\tclear_bit(PAGE_CLAIMED, &page->private);\n\n\tspin_lock_init(&zhdr->page_lock);\n\tkref_init(&zhdr->refcount);\n\tzhdr->first_chunks = 0;\n\tzhdr->middle_chunks = 0;\n\tzhdr->last_chunks = 0;\n\tzhdr->first_num = 0;\n\tzhdr->start_middle = 0;\n\tzhdr->cpu = -1;\n\tzhdr->pool = pool;\n\tINIT_LIST_HEAD(&zhdr->buddy);\n\tINIT_WORK(&zhdr->work, compact_page_work);\n\treturn zhdr;\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/sched.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&zhdr->work",
            "compact_page_work"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&zhdr->buddy"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_init",
          "args": [
            "&zhdr->refcount"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&zhdr->page_lock"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "PAGE_CLAIMED",
            "&page->private"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "clear_bit_unlock_is_negative_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1171-1176",
          "snippet": "static inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&page->lru"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "page_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "409-434",
          "snippet": "void *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\nstatic struct z3fold_header *init_z3fold_page(struct page *page,\n\t\t\t\t\tstruct z3fold_pool *pool)\n{\n\tstruct z3fold_header *zhdr = page_address(page);\n\n\tINIT_LIST_HEAD(&page->lru);\n\tclear_bit(PAGE_HEADLESS, &page->private);\n\tclear_bit(MIDDLE_CHUNK_MAPPED, &page->private);\n\tclear_bit(NEEDS_COMPACTING, &page->private);\n\tclear_bit(PAGE_STALE, &page->private);\n\tclear_bit(PAGE_CLAIMED, &page->private);\n\n\tspin_lock_init(&zhdr->page_lock);\n\tkref_init(&zhdr->refcount);\n\tzhdr->first_chunks = 0;\n\tzhdr->middle_chunks = 0;\n\tzhdr->last_chunks = 0;\n\tzhdr->first_num = 0;\n\tzhdr->start_middle = 0;\n\tzhdr->cpu = -1;\n\tzhdr->pool = pool;\n\tINIT_LIST_HEAD(&zhdr->buddy);\n\tINIT_WORK(&zhdr->work, compact_page_work);\n\treturn zhdr;\n}"
  },
  {
    "function_name": "size_to_chunks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/z3fold.c",
    "lines": "157-160",
    "snippet": "static int size_to_chunks(size_t size)\n{\n\treturn (size + CHUNK_SIZE - 1) >> CHUNK_SHIFT;\n}",
    "includes": [
      "#include <linux/zpool.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/sched.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define CHUNK_SIZE\t(1 << CHUNK_SHIFT)",
      "#define CHUNK_SHIFT\t(PAGE_SHIFT - NCHUNKS_ORDER)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/zpool.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n\n#define CHUNK_SIZE\t(1 << CHUNK_SHIFT)\n#define CHUNK_SHIFT\t(PAGE_SHIFT - NCHUNKS_ORDER)\n\nstatic int size_to_chunks(size_t size)\n{\n\treturn (size + CHUNK_SIZE - 1) >> CHUNK_SHIFT;\n}"
  }
]