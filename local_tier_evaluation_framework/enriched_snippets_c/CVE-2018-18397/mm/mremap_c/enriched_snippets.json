[
  {
    "function_name": "vma_expandable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mremap.c",
    "lines": "495-506",
    "snippet": "static int vma_expandable(struct vm_area_struct *vma, unsigned long delta)\n{\n\tunsigned long end = vma->vm_end + delta;\n\tif (end < vma->vm_end) /* overflow */\n\t\treturn 0;\n\tif (vma->vm_next && vma->vm_next->vm_start < end) /* intersection */\n\t\treturn 0;\n\tif (get_unmapped_area(NULL, vma->vm_start, end - vma->vm_start,\n\t\t\t      0, MAP_FIXED) & ~PAGE_MASK)\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/mm-arch-hooks.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swapops.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/ksm.h>",
      "#include <linux/shm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_unmapped_area",
          "args": [
            "NULL",
            "vma->vm_start",
            "end - vma->vm_start",
            "0",
            "MAP_FIXED"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "arch_get_unmapped_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "1754-1758",
          "snippet": "unsigned long arch_get_unmapped_area(struct file *file, unsigned long addr,\n\tunsigned long len, unsigned long pgoff, unsigned long flags)\n{\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nunsigned long arch_get_unmapped_area(struct file *file, unsigned long addr,\n\tunsigned long len, unsigned long pgoff, unsigned long flags)\n{\n\treturn -ENOMEM;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mm-arch-hooks.h>\n#include <linux/uaccess.h>\n#include <linux/mmu_notifier.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/swapops.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/ksm.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nstatic int vma_expandable(struct vm_area_struct *vma, unsigned long delta)\n{\n\tunsigned long end = vma->vm_end + delta;\n\tif (end < vma->vm_end) /* overflow */\n\t\treturn 0;\n\tif (vma->vm_next && vma->vm_next->vm_start < end) /* intersection */\n\t\treturn 0;\n\tif (get_unmapped_area(NULL, vma->vm_start, end - vma->vm_start,\n\t\t\t      0, MAP_FIXED) & ~PAGE_MASK)\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "mremap_to",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mremap.c",
    "lines": "435-493",
    "snippet": "static unsigned long mremap_to(unsigned long addr, unsigned long old_len,\n\t\tunsigned long new_addr, unsigned long new_len, bool *locked,\n\t\tstruct vm_userfaultfd_ctx *uf,\n\t\tstruct list_head *uf_unmap_early,\n\t\tstruct list_head *uf_unmap)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma;\n\tunsigned long ret = -EINVAL;\n\tunsigned long charged = 0;\n\tunsigned long map_flags;\n\n\tif (offset_in_page(new_addr))\n\t\tgoto out;\n\n\tif (new_len > TASK_SIZE || new_addr > TASK_SIZE - new_len)\n\t\tgoto out;\n\n\t/* Ensure the old/new locations do not overlap */\n\tif (addr + old_len > new_addr && new_addr + new_len > addr)\n\t\tgoto out;\n\n\tret = do_munmap(mm, new_addr, new_len, uf_unmap_early);\n\tif (ret)\n\t\tgoto out;\n\n\tif (old_len >= new_len) {\n\t\tret = do_munmap(mm, addr+new_len, old_len - new_len, uf_unmap);\n\t\tif (ret && old_len != new_len)\n\t\t\tgoto out;\n\t\told_len = new_len;\n\t}\n\n\tvma = vma_to_resize(addr, old_len, new_len, &charged);\n\tif (IS_ERR(vma)) {\n\t\tret = PTR_ERR(vma);\n\t\tgoto out;\n\t}\n\n\tmap_flags = MAP_FIXED;\n\tif (vma->vm_flags & VM_MAYSHARE)\n\t\tmap_flags |= MAP_SHARED;\n\n\tret = get_unmapped_area(vma->vm_file, new_addr, new_len, vma->vm_pgoff +\n\t\t\t\t((addr - vma->vm_start) >> PAGE_SHIFT),\n\t\t\t\tmap_flags);\n\tif (offset_in_page(ret))\n\t\tgoto out1;\n\n\tret = move_vma(vma, addr, old_len, new_len, new_addr, locked, uf,\n\t\t       uf_unmap);\n\tif (!(offset_in_page(ret)))\n\t\tgoto out;\nout1:\n\tvm_unacct_memory(charged);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/mm-arch-hooks.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swapops.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/ksm.h>",
      "#include <linux/shm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vm_unacct_memory",
          "args": [
            "charged"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "ret"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "move_vma",
          "args": [
            "vma",
            "addr",
            "old_len",
            "new_len",
            "new_addr",
            "locked",
            "uf",
            "uf_unmap"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "move_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mremap.c",
          "lines": "255-368",
          "snippet": "static unsigned long move_vma(struct vm_area_struct *vma,\n\t\tunsigned long old_addr, unsigned long old_len,\n\t\tunsigned long new_len, unsigned long new_addr,\n\t\tbool *locked, struct vm_userfaultfd_ctx *uf,\n\t\tstruct list_head *uf_unmap)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *new_vma;\n\tunsigned long vm_flags = vma->vm_flags;\n\tunsigned long new_pgoff;\n\tunsigned long moved_len;\n\tunsigned long excess = 0;\n\tunsigned long hiwater_vm;\n\tint split = 0;\n\tint err;\n\tbool need_rmap_locks;\n\n\t/*\n\t * We'd prefer to avoid failure later on in do_munmap:\n\t * which may split one vma into three before unmapping.\n\t */\n\tif (mm->map_count >= sysctl_max_map_count - 3)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Advise KSM to break any KSM pages in the area to be moved:\n\t * it would be confusing if they were to turn up at the new\n\t * location, where they happen to coincide with different KSM\n\t * pages recently unmapped.  But leave vma->vm_flags as it was,\n\t * so KSM can come around to merge on vma and new_vma afterwards.\n\t */\n\terr = ksm_madvise(vma, old_addr, old_addr + old_len,\n\t\t\t\t\t\tMADV_UNMERGEABLE, &vm_flags);\n\tif (err)\n\t\treturn err;\n\n\tnew_pgoff = vma->vm_pgoff + ((old_addr - vma->vm_start) >> PAGE_SHIFT);\n\tnew_vma = copy_vma(&vma, new_addr, new_len, new_pgoff,\n\t\t\t   &need_rmap_locks);\n\tif (!new_vma)\n\t\treturn -ENOMEM;\n\n\tmoved_len = move_page_tables(vma, old_addr, new_vma, new_addr, old_len,\n\t\t\t\t     need_rmap_locks);\n\tif (moved_len < old_len) {\n\t\terr = -ENOMEM;\n\t} else if (vma->vm_ops && vma->vm_ops->mremap) {\n\t\terr = vma->vm_ops->mremap(new_vma);\n\t}\n\n\tif (unlikely(err)) {\n\t\t/*\n\t\t * On error, move entries back from new area to old,\n\t\t * which will succeed since page tables still there,\n\t\t * and then proceed to unmap new area instead of old.\n\t\t */\n\t\tmove_page_tables(new_vma, new_addr, vma, old_addr, moved_len,\n\t\t\t\t true);\n\t\tvma = new_vma;\n\t\told_len = new_len;\n\t\told_addr = new_addr;\n\t\tnew_addr = err;\n\t} else {\n\t\tmremap_userfaultfd_prep(new_vma, uf);\n\t\tarch_remap(mm, old_addr, old_addr + old_len,\n\t\t\t   new_addr, new_addr + new_len);\n\t}\n\n\t/* Conceal VM_ACCOUNT so old reservation is not undone */\n\tif (vm_flags & VM_ACCOUNT) {\n\t\tvma->vm_flags &= ~VM_ACCOUNT;\n\t\texcess = vma->vm_end - vma->vm_start - old_len;\n\t\tif (old_addr > vma->vm_start &&\n\t\t    old_addr + old_len < vma->vm_end)\n\t\t\tsplit = 1;\n\t}\n\n\t/*\n\t * If we failed to move page tables we still do total_vm increment\n\t * since do_munmap() will decrement it by old_len == new_len.\n\t *\n\t * Since total_vm is about to be raised artificially high for a\n\t * moment, we need to restore high watermark afterwards: if stats\n\t * are taken meanwhile, total_vm and hiwater_vm appear too high.\n\t * If this were a serious issue, we'd add a flag to do_munmap().\n\t */\n\thiwater_vm = mm->hiwater_vm;\n\tvm_stat_account(mm, vma->vm_flags, new_len >> PAGE_SHIFT);\n\n\t/* Tell pfnmap has moved from this vma */\n\tif (unlikely(vma->vm_flags & VM_PFNMAP))\n\t\tuntrack_pfn_moved(vma);\n\n\tif (do_munmap(mm, old_addr, old_len, uf_unmap) < 0) {\n\t\t/* OOM: unable to split vma, just get accounts right */\n\t\tvm_unacct_memory(excess >> PAGE_SHIFT);\n\t\texcess = 0;\n\t}\n\tmm->hiwater_vm = hiwater_vm;\n\n\t/* Restore VM_ACCOUNT if one or two pieces of vma left */\n\tif (excess) {\n\t\tvma->vm_flags |= VM_ACCOUNT;\n\t\tif (split)\n\t\t\tvma->vm_next->vm_flags |= VM_ACCOUNT;\n\t}\n\n\tif (vm_flags & VM_LOCKED) {\n\t\tmm->locked_vm += new_len >> PAGE_SHIFT;\n\t\t*locked = true;\n\t}\n\n\treturn new_addr;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/mm-arch-hooks.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swapops.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/ksm.h>",
            "#include <linux/shm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mm-arch-hooks.h>\n#include <linux/uaccess.h>\n#include <linux/mmu_notifier.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/swapops.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/ksm.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nstatic unsigned long move_vma(struct vm_area_struct *vma,\n\t\tunsigned long old_addr, unsigned long old_len,\n\t\tunsigned long new_len, unsigned long new_addr,\n\t\tbool *locked, struct vm_userfaultfd_ctx *uf,\n\t\tstruct list_head *uf_unmap)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *new_vma;\n\tunsigned long vm_flags = vma->vm_flags;\n\tunsigned long new_pgoff;\n\tunsigned long moved_len;\n\tunsigned long excess = 0;\n\tunsigned long hiwater_vm;\n\tint split = 0;\n\tint err;\n\tbool need_rmap_locks;\n\n\t/*\n\t * We'd prefer to avoid failure later on in do_munmap:\n\t * which may split one vma into three before unmapping.\n\t */\n\tif (mm->map_count >= sysctl_max_map_count - 3)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Advise KSM to break any KSM pages in the area to be moved:\n\t * it would be confusing if they were to turn up at the new\n\t * location, where they happen to coincide with different KSM\n\t * pages recently unmapped.  But leave vma->vm_flags as it was,\n\t * so KSM can come around to merge on vma and new_vma afterwards.\n\t */\n\terr = ksm_madvise(vma, old_addr, old_addr + old_len,\n\t\t\t\t\t\tMADV_UNMERGEABLE, &vm_flags);\n\tif (err)\n\t\treturn err;\n\n\tnew_pgoff = vma->vm_pgoff + ((old_addr - vma->vm_start) >> PAGE_SHIFT);\n\tnew_vma = copy_vma(&vma, new_addr, new_len, new_pgoff,\n\t\t\t   &need_rmap_locks);\n\tif (!new_vma)\n\t\treturn -ENOMEM;\n\n\tmoved_len = move_page_tables(vma, old_addr, new_vma, new_addr, old_len,\n\t\t\t\t     need_rmap_locks);\n\tif (moved_len < old_len) {\n\t\terr = -ENOMEM;\n\t} else if (vma->vm_ops && vma->vm_ops->mremap) {\n\t\terr = vma->vm_ops->mremap(new_vma);\n\t}\n\n\tif (unlikely(err)) {\n\t\t/*\n\t\t * On error, move entries back from new area to old,\n\t\t * which will succeed since page tables still there,\n\t\t * and then proceed to unmap new area instead of old.\n\t\t */\n\t\tmove_page_tables(new_vma, new_addr, vma, old_addr, moved_len,\n\t\t\t\t true);\n\t\tvma = new_vma;\n\t\told_len = new_len;\n\t\told_addr = new_addr;\n\t\tnew_addr = err;\n\t} else {\n\t\tmremap_userfaultfd_prep(new_vma, uf);\n\t\tarch_remap(mm, old_addr, old_addr + old_len,\n\t\t\t   new_addr, new_addr + new_len);\n\t}\n\n\t/* Conceal VM_ACCOUNT so old reservation is not undone */\n\tif (vm_flags & VM_ACCOUNT) {\n\t\tvma->vm_flags &= ~VM_ACCOUNT;\n\t\texcess = vma->vm_end - vma->vm_start - old_len;\n\t\tif (old_addr > vma->vm_start &&\n\t\t    old_addr + old_len < vma->vm_end)\n\t\t\tsplit = 1;\n\t}\n\n\t/*\n\t * If we failed to move page tables we still do total_vm increment\n\t * since do_munmap() will decrement it by old_len == new_len.\n\t *\n\t * Since total_vm is about to be raised artificially high for a\n\t * moment, we need to restore high watermark afterwards: if stats\n\t * are taken meanwhile, total_vm and hiwater_vm appear too high.\n\t * If this were a serious issue, we'd add a flag to do_munmap().\n\t */\n\thiwater_vm = mm->hiwater_vm;\n\tvm_stat_account(mm, vma->vm_flags, new_len >> PAGE_SHIFT);\n\n\t/* Tell pfnmap has moved from this vma */\n\tif (unlikely(vma->vm_flags & VM_PFNMAP))\n\t\tuntrack_pfn_moved(vma);\n\n\tif (do_munmap(mm, old_addr, old_len, uf_unmap) < 0) {\n\t\t/* OOM: unable to split vma, just get accounts right */\n\t\tvm_unacct_memory(excess >> PAGE_SHIFT);\n\t\texcess = 0;\n\t}\n\tmm->hiwater_vm = hiwater_vm;\n\n\t/* Restore VM_ACCOUNT if one or two pieces of vma left */\n\tif (excess) {\n\t\tvma->vm_flags |= VM_ACCOUNT;\n\t\tif (split)\n\t\t\tvma->vm_next->vm_flags |= VM_ACCOUNT;\n\t}\n\n\tif (vm_flags & VM_LOCKED) {\n\t\tmm->locked_vm += new_len >> PAGE_SHIFT;\n\t\t*locked = true;\n\t}\n\n\treturn new_addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "ret"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unmapped_area",
          "args": [
            "vma->vm_file",
            "new_addr",
            "new_len",
            "vma->vm_pgoff +\n\t\t\t\t((addr - vma->vm_start) >> PAGE_SHIFT)",
            "map_flags"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "arch_get_unmapped_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "1754-1758",
          "snippet": "unsigned long arch_get_unmapped_area(struct file *file, unsigned long addr,\n\tunsigned long len, unsigned long pgoff, unsigned long flags)\n{\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nunsigned long arch_get_unmapped_area(struct file *file, unsigned long addr,\n\tunsigned long len, unsigned long pgoff, unsigned long flags)\n{\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "vma"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "vma"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_to_resize",
          "args": [
            "addr",
            "old_len",
            "new_len",
            "&charged"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "vma_to_resize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mremap.c",
          "lines": "370-433",
          "snippet": "static struct vm_area_struct *vma_to_resize(unsigned long addr,\n\tunsigned long old_len, unsigned long new_len, unsigned long *p)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = find_vma(mm, addr);\n\tunsigned long pgoff;\n\n\tif (!vma || vma->vm_start > addr)\n\t\treturn ERR_PTR(-EFAULT);\n\n\t/*\n\t * !old_len is a special case where an attempt is made to 'duplicate'\n\t * a mapping.  This makes no sense for private mappings as it will\n\t * instead create a fresh/new mapping unrelated to the original.  This\n\t * is contrary to the basic idea of mremap which creates new mappings\n\t * based on the original.  There are no known use cases for this\n\t * behavior.  As a result, fail such attempts.\n\t */\n\tif (!old_len && !(vma->vm_flags & (VM_SHARED | VM_MAYSHARE))) {\n\t\tpr_warn_once(\"%s (%d): attempted to duplicate a private mapping with mremap.  This is not supported.\\n\", current->comm, current->pid);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (is_vm_hugetlb_page(vma))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* We can't remap across vm area boundaries */\n\tif (old_len > vma->vm_end - addr)\n\t\treturn ERR_PTR(-EFAULT);\n\n\tif (new_len == old_len)\n\t\treturn vma;\n\n\t/* Need to be careful about a growing mapping */\n\tpgoff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\tpgoff += vma->vm_pgoff;\n\tif (pgoff + (new_len >> PAGE_SHIFT) < pgoff)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (vma->vm_flags & (VM_DONTEXPAND | VM_PFNMAP))\n\t\treturn ERR_PTR(-EFAULT);\n\n\tif (vma->vm_flags & VM_LOCKED) {\n\t\tunsigned long locked, lock_limit;\n\t\tlocked = mm->locked_vm << PAGE_SHIFT;\n\t\tlock_limit = rlimit(RLIMIT_MEMLOCK);\n\t\tlocked += new_len - old_len;\n\t\tif (locked > lock_limit && !capable(CAP_IPC_LOCK))\n\t\t\treturn ERR_PTR(-EAGAIN);\n\t}\n\n\tif (!may_expand_vm(mm, vma->vm_flags,\n\t\t\t\t(new_len - old_len) >> PAGE_SHIFT))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (vma->vm_flags & VM_ACCOUNT) {\n\t\tunsigned long charged = (new_len - old_len) >> PAGE_SHIFT;\n\t\tif (security_vm_enough_memory_mm(mm, charged))\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t*p = charged;\n\t}\n\n\treturn vma;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/mm-arch-hooks.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swapops.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/ksm.h>",
            "#include <linux/shm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mm-arch-hooks.h>\n#include <linux/uaccess.h>\n#include <linux/mmu_notifier.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/swapops.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/ksm.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nstatic struct vm_area_struct *vma_to_resize(unsigned long addr,\n\tunsigned long old_len, unsigned long new_len, unsigned long *p)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = find_vma(mm, addr);\n\tunsigned long pgoff;\n\n\tif (!vma || vma->vm_start > addr)\n\t\treturn ERR_PTR(-EFAULT);\n\n\t/*\n\t * !old_len is a special case where an attempt is made to 'duplicate'\n\t * a mapping.  This makes no sense for private mappings as it will\n\t * instead create a fresh/new mapping unrelated to the original.  This\n\t * is contrary to the basic idea of mremap which creates new mappings\n\t * based on the original.  There are no known use cases for this\n\t * behavior.  As a result, fail such attempts.\n\t */\n\tif (!old_len && !(vma->vm_flags & (VM_SHARED | VM_MAYSHARE))) {\n\t\tpr_warn_once(\"%s (%d): attempted to duplicate a private mapping with mremap.  This is not supported.\\n\", current->comm, current->pid);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (is_vm_hugetlb_page(vma))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* We can't remap across vm area boundaries */\n\tif (old_len > vma->vm_end - addr)\n\t\treturn ERR_PTR(-EFAULT);\n\n\tif (new_len == old_len)\n\t\treturn vma;\n\n\t/* Need to be careful about a growing mapping */\n\tpgoff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\tpgoff += vma->vm_pgoff;\n\tif (pgoff + (new_len >> PAGE_SHIFT) < pgoff)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (vma->vm_flags & (VM_DONTEXPAND | VM_PFNMAP))\n\t\treturn ERR_PTR(-EFAULT);\n\n\tif (vma->vm_flags & VM_LOCKED) {\n\t\tunsigned long locked, lock_limit;\n\t\tlocked = mm->locked_vm << PAGE_SHIFT;\n\t\tlock_limit = rlimit(RLIMIT_MEMLOCK);\n\t\tlocked += new_len - old_len;\n\t\tif (locked > lock_limit && !capable(CAP_IPC_LOCK))\n\t\t\treturn ERR_PTR(-EAGAIN);\n\t}\n\n\tif (!may_expand_vm(mm, vma->vm_flags,\n\t\t\t\t(new_len - old_len) >> PAGE_SHIFT))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (vma->vm_flags & VM_ACCOUNT) {\n\t\tunsigned long charged = (new_len - old_len) >> PAGE_SHIFT;\n\t\tif (security_vm_enough_memory_mm(mm, charged))\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t*p = charged;\n\t}\n\n\treturn vma;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_munmap",
          "args": [
            "mm",
            "addr+new_len",
            "old_len - new_len",
            "uf_unmap"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "do_munmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "1552-1609",
          "snippet": "int do_munmap(struct mm_struct *mm, unsigned long start, size_t len, struct list_head *uf)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned long end;\n\tint ret;\n\n\tlen = PAGE_ALIGN(len);\n\tif (len == 0)\n\t\treturn -EINVAL;\n\n\tend = start + len;\n\n\t/* find the first potentially overlapping VMA */\n\tvma = find_vma(mm, start);\n\tif (!vma) {\n\t\tstatic int limit;\n\t\tif (limit < 5) {\n\t\t\tpr_warn(\"munmap of memory not mmapped by process %d (%s): 0x%lx-0x%lx\\n\",\n\t\t\t\t\tcurrent->pid, current->comm,\n\t\t\t\t\tstart, start + len - 1);\n\t\t\tlimit++;\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\n\t/* we're allowed to split an anonymous VMA but not a file-backed one */\n\tif (vma->vm_file) {\n\t\tdo {\n\t\t\tif (start > vma->vm_start)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (end == vma->vm_end)\n\t\t\t\tgoto erase_whole_vma;\n\t\t\tvma = vma->vm_next;\n\t\t} while (vma);\n\t\treturn -EINVAL;\n\t} else {\n\t\t/* the chunk must be a subset of the VMA found */\n\t\tif (start == vma->vm_start && end == vma->vm_end)\n\t\t\tgoto erase_whole_vma;\n\t\tif (start < vma->vm_start || end > vma->vm_end)\n\t\t\treturn -EINVAL;\n\t\tif (offset_in_page(start))\n\t\t\treturn -EINVAL;\n\t\tif (end != vma->vm_end && offset_in_page(end))\n\t\t\treturn -EINVAL;\n\t\tif (start != vma->vm_start && end != vma->vm_end) {\n\t\t\tret = split_vma(mm, vma, start, 1);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t\treturn shrink_vma(mm, vma, start, end);\n\t}\n\nerase_whole_vma:\n\tdelete_vma_from_mm(vma);\n\tdelete_vma(mm, vma);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nint do_munmap(struct mm_struct *mm, unsigned long start, size_t len, struct list_head *uf)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned long end;\n\tint ret;\n\n\tlen = PAGE_ALIGN(len);\n\tif (len == 0)\n\t\treturn -EINVAL;\n\n\tend = start + len;\n\n\t/* find the first potentially overlapping VMA */\n\tvma = find_vma(mm, start);\n\tif (!vma) {\n\t\tstatic int limit;\n\t\tif (limit < 5) {\n\t\t\tpr_warn(\"munmap of memory not mmapped by process %d (%s): 0x%lx-0x%lx\\n\",\n\t\t\t\t\tcurrent->pid, current->comm,\n\t\t\t\t\tstart, start + len - 1);\n\t\t\tlimit++;\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\n\t/* we're allowed to split an anonymous VMA but not a file-backed one */\n\tif (vma->vm_file) {\n\t\tdo {\n\t\t\tif (start > vma->vm_start)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (end == vma->vm_end)\n\t\t\t\tgoto erase_whole_vma;\n\t\t\tvma = vma->vm_next;\n\t\t} while (vma);\n\t\treturn -EINVAL;\n\t} else {\n\t\t/* the chunk must be a subset of the VMA found */\n\t\tif (start == vma->vm_start && end == vma->vm_end)\n\t\t\tgoto erase_whole_vma;\n\t\tif (start < vma->vm_start || end > vma->vm_end)\n\t\t\treturn -EINVAL;\n\t\tif (offset_in_page(start))\n\t\t\treturn -EINVAL;\n\t\tif (end != vma->vm_end && offset_in_page(end))\n\t\t\treturn -EINVAL;\n\t\tif (start != vma->vm_start && end != vma->vm_end) {\n\t\t\tret = split_vma(mm, vma, start, 1);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t\treturn shrink_vma(mm, vma, start, end);\n\t}\n\nerase_whole_vma:\n\tdelete_vma_from_mm(vma);\n\tdelete_vma(mm, vma);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "new_addr"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mm-arch-hooks.h>\n#include <linux/uaccess.h>\n#include <linux/mmu_notifier.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/swapops.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/ksm.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nstatic unsigned long mremap_to(unsigned long addr, unsigned long old_len,\n\t\tunsigned long new_addr, unsigned long new_len, bool *locked,\n\t\tstruct vm_userfaultfd_ctx *uf,\n\t\tstruct list_head *uf_unmap_early,\n\t\tstruct list_head *uf_unmap)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma;\n\tunsigned long ret = -EINVAL;\n\tunsigned long charged = 0;\n\tunsigned long map_flags;\n\n\tif (offset_in_page(new_addr))\n\t\tgoto out;\n\n\tif (new_len > TASK_SIZE || new_addr > TASK_SIZE - new_len)\n\t\tgoto out;\n\n\t/* Ensure the old/new locations do not overlap */\n\tif (addr + old_len > new_addr && new_addr + new_len > addr)\n\t\tgoto out;\n\n\tret = do_munmap(mm, new_addr, new_len, uf_unmap_early);\n\tif (ret)\n\t\tgoto out;\n\n\tif (old_len >= new_len) {\n\t\tret = do_munmap(mm, addr+new_len, old_len - new_len, uf_unmap);\n\t\tif (ret && old_len != new_len)\n\t\t\tgoto out;\n\t\told_len = new_len;\n\t}\n\n\tvma = vma_to_resize(addr, old_len, new_len, &charged);\n\tif (IS_ERR(vma)) {\n\t\tret = PTR_ERR(vma);\n\t\tgoto out;\n\t}\n\n\tmap_flags = MAP_FIXED;\n\tif (vma->vm_flags & VM_MAYSHARE)\n\t\tmap_flags |= MAP_SHARED;\n\n\tret = get_unmapped_area(vma->vm_file, new_addr, new_len, vma->vm_pgoff +\n\t\t\t\t((addr - vma->vm_start) >> PAGE_SHIFT),\n\t\t\t\tmap_flags);\n\tif (offset_in_page(ret))\n\t\tgoto out1;\n\n\tret = move_vma(vma, addr, old_len, new_len, new_addr, locked, uf,\n\t\t       uf_unmap);\n\tif (!(offset_in_page(ret)))\n\t\tgoto out;\nout1:\n\tvm_unacct_memory(charged);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "vma_to_resize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mremap.c",
    "lines": "370-433",
    "snippet": "static struct vm_area_struct *vma_to_resize(unsigned long addr,\n\tunsigned long old_len, unsigned long new_len, unsigned long *p)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = find_vma(mm, addr);\n\tunsigned long pgoff;\n\n\tif (!vma || vma->vm_start > addr)\n\t\treturn ERR_PTR(-EFAULT);\n\n\t/*\n\t * !old_len is a special case where an attempt is made to 'duplicate'\n\t * a mapping.  This makes no sense for private mappings as it will\n\t * instead create a fresh/new mapping unrelated to the original.  This\n\t * is contrary to the basic idea of mremap which creates new mappings\n\t * based on the original.  There are no known use cases for this\n\t * behavior.  As a result, fail such attempts.\n\t */\n\tif (!old_len && !(vma->vm_flags & (VM_SHARED | VM_MAYSHARE))) {\n\t\tpr_warn_once(\"%s (%d): attempted to duplicate a private mapping with mremap.  This is not supported.\\n\", current->comm, current->pid);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (is_vm_hugetlb_page(vma))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* We can't remap across vm area boundaries */\n\tif (old_len > vma->vm_end - addr)\n\t\treturn ERR_PTR(-EFAULT);\n\n\tif (new_len == old_len)\n\t\treturn vma;\n\n\t/* Need to be careful about a growing mapping */\n\tpgoff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\tpgoff += vma->vm_pgoff;\n\tif (pgoff + (new_len >> PAGE_SHIFT) < pgoff)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (vma->vm_flags & (VM_DONTEXPAND | VM_PFNMAP))\n\t\treturn ERR_PTR(-EFAULT);\n\n\tif (vma->vm_flags & VM_LOCKED) {\n\t\tunsigned long locked, lock_limit;\n\t\tlocked = mm->locked_vm << PAGE_SHIFT;\n\t\tlock_limit = rlimit(RLIMIT_MEMLOCK);\n\t\tlocked += new_len - old_len;\n\t\tif (locked > lock_limit && !capable(CAP_IPC_LOCK))\n\t\t\treturn ERR_PTR(-EAGAIN);\n\t}\n\n\tif (!may_expand_vm(mm, vma->vm_flags,\n\t\t\t\t(new_len - old_len) >> PAGE_SHIFT))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (vma->vm_flags & VM_ACCOUNT) {\n\t\tunsigned long charged = (new_len - old_len) >> PAGE_SHIFT;\n\t\tif (security_vm_enough_memory_mm(mm, charged))\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t*p = charged;\n\t}\n\n\treturn vma;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/mm-arch-hooks.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swapops.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/ksm.h>",
      "#include <linux/shm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_vm_enough_memory_mm",
          "args": [
            "mm",
            "charged"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "may_expand_vm",
          "args": [
            "mm",
            "vma->vm_flags",
            "(new_len - old_len) >> PAGE_SHIFT"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "may_expand_vm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "3281-3304",
          "snippet": "bool may_expand_vm(struct mm_struct *mm, vm_flags_t flags, unsigned long npages)\n{\n\tif (mm->total_vm + npages > rlimit(RLIMIT_AS) >> PAGE_SHIFT)\n\t\treturn false;\n\n\tif (is_data_mapping(flags) &&\n\t    mm->data_vm + npages > rlimit(RLIMIT_DATA) >> PAGE_SHIFT) {\n\t\t/* Workaround for Valgrind */\n\t\tif (rlimit(RLIMIT_DATA) == 0 &&\n\t\t    mm->data_vm + npages <= rlimit_max(RLIMIT_DATA) >> PAGE_SHIFT)\n\t\t\treturn true;\n\n\t\tpr_warn_once(\"%s (%d): VmData %lu exceed data ulimit %lu. Update limits%s.\\n\",\n\t\t\t     current->comm, current->pid,\n\t\t\t     (mm->data_vm + npages) << PAGE_SHIFT,\n\t\t\t     rlimit(RLIMIT_DATA),\n\t\t\t     ignore_rlimit_data ? \"\" : \" or use boot option ignore_rlimit_data\");\n\n\t\tif (!ignore_rlimit_data)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool ignore_rlimit_data;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic bool ignore_rlimit_data;\n\nbool may_expand_vm(struct mm_struct *mm, vm_flags_t flags, unsigned long npages)\n{\n\tif (mm->total_vm + npages > rlimit(RLIMIT_AS) >> PAGE_SHIFT)\n\t\treturn false;\n\n\tif (is_data_mapping(flags) &&\n\t    mm->data_vm + npages > rlimit(RLIMIT_DATA) >> PAGE_SHIFT) {\n\t\t/* Workaround for Valgrind */\n\t\tif (rlimit(RLIMIT_DATA) == 0 &&\n\t\t    mm->data_vm + npages <= rlimit_max(RLIMIT_DATA) >> PAGE_SHIFT)\n\t\t\treturn true;\n\n\t\tpr_warn_once(\"%s (%d): VmData %lu exceed data ulimit %lu. Update limits%s.\\n\",\n\t\t\t     current->comm, current->pid,\n\t\t\t     (mm->data_vm + npages) << PAGE_SHIFT,\n\t\t\t     rlimit(RLIMIT_DATA),\n\t\t\t     ignore_rlimit_data ? \"\" : \" or use boot option ignore_rlimit_data\");\n\n\t\tif (!ignore_rlimit_data)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EAGAIN"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_IPC_LOCK"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rlimit",
          "args": [
            "RLIMIT_MEMLOCK"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EFAULT"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EFAULT"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vm_hugetlb_page",
          "args": [
            "vma"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn_once",
          "args": [
            "\"%s (%d): attempted to duplicate a private mapping with mremap.  This is not supported.\\n\"",
            "current->comm",
            "current->pid"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EFAULT"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_vma",
          "args": [
            "mm",
            "addr"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "find_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "775-796",
          "snippet": "struct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\n\t/* check the cache first */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\t/* trawl the list (there may be multiple mappings in which addr\n\t * resides) */\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_start > addr)\n\t\t\treturn NULL;\n\t\tif (vma->vm_end > addr) {\n\t\t\tvmacache_update(addr, vma);\n\t\t\treturn vma;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nstruct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\n\t/* check the cache first */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\t/* trawl the list (there may be multiple mappings in which addr\n\t * resides) */\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_start > addr)\n\t\t\treturn NULL;\n\t\tif (vma->vm_end > addr) {\n\t\t\tvmacache_update(addr, vma);\n\t\t\treturn vma;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mm-arch-hooks.h>\n#include <linux/uaccess.h>\n#include <linux/mmu_notifier.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/swapops.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/ksm.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nstatic struct vm_area_struct *vma_to_resize(unsigned long addr,\n\tunsigned long old_len, unsigned long new_len, unsigned long *p)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = find_vma(mm, addr);\n\tunsigned long pgoff;\n\n\tif (!vma || vma->vm_start > addr)\n\t\treturn ERR_PTR(-EFAULT);\n\n\t/*\n\t * !old_len is a special case where an attempt is made to 'duplicate'\n\t * a mapping.  This makes no sense for private mappings as it will\n\t * instead create a fresh/new mapping unrelated to the original.  This\n\t * is contrary to the basic idea of mremap which creates new mappings\n\t * based on the original.  There are no known use cases for this\n\t * behavior.  As a result, fail such attempts.\n\t */\n\tif (!old_len && !(vma->vm_flags & (VM_SHARED | VM_MAYSHARE))) {\n\t\tpr_warn_once(\"%s (%d): attempted to duplicate a private mapping with mremap.  This is not supported.\\n\", current->comm, current->pid);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (is_vm_hugetlb_page(vma))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* We can't remap across vm area boundaries */\n\tif (old_len > vma->vm_end - addr)\n\t\treturn ERR_PTR(-EFAULT);\n\n\tif (new_len == old_len)\n\t\treturn vma;\n\n\t/* Need to be careful about a growing mapping */\n\tpgoff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\tpgoff += vma->vm_pgoff;\n\tif (pgoff + (new_len >> PAGE_SHIFT) < pgoff)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (vma->vm_flags & (VM_DONTEXPAND | VM_PFNMAP))\n\t\treturn ERR_PTR(-EFAULT);\n\n\tif (vma->vm_flags & VM_LOCKED) {\n\t\tunsigned long locked, lock_limit;\n\t\tlocked = mm->locked_vm << PAGE_SHIFT;\n\t\tlock_limit = rlimit(RLIMIT_MEMLOCK);\n\t\tlocked += new_len - old_len;\n\t\tif (locked > lock_limit && !capable(CAP_IPC_LOCK))\n\t\t\treturn ERR_PTR(-EAGAIN);\n\t}\n\n\tif (!may_expand_vm(mm, vma->vm_flags,\n\t\t\t\t(new_len - old_len) >> PAGE_SHIFT))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (vma->vm_flags & VM_ACCOUNT) {\n\t\tunsigned long charged = (new_len - old_len) >> PAGE_SHIFT;\n\t\tif (security_vm_enough_memory_mm(mm, charged))\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t*p = charged;\n\t}\n\n\treturn vma;\n}"
  },
  {
    "function_name": "move_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mremap.c",
    "lines": "255-368",
    "snippet": "static unsigned long move_vma(struct vm_area_struct *vma,\n\t\tunsigned long old_addr, unsigned long old_len,\n\t\tunsigned long new_len, unsigned long new_addr,\n\t\tbool *locked, struct vm_userfaultfd_ctx *uf,\n\t\tstruct list_head *uf_unmap)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *new_vma;\n\tunsigned long vm_flags = vma->vm_flags;\n\tunsigned long new_pgoff;\n\tunsigned long moved_len;\n\tunsigned long excess = 0;\n\tunsigned long hiwater_vm;\n\tint split = 0;\n\tint err;\n\tbool need_rmap_locks;\n\n\t/*\n\t * We'd prefer to avoid failure later on in do_munmap:\n\t * which may split one vma into three before unmapping.\n\t */\n\tif (mm->map_count >= sysctl_max_map_count - 3)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Advise KSM to break any KSM pages in the area to be moved:\n\t * it would be confusing if they were to turn up at the new\n\t * location, where they happen to coincide with different KSM\n\t * pages recently unmapped.  But leave vma->vm_flags as it was,\n\t * so KSM can come around to merge on vma and new_vma afterwards.\n\t */\n\terr = ksm_madvise(vma, old_addr, old_addr + old_len,\n\t\t\t\t\t\tMADV_UNMERGEABLE, &vm_flags);\n\tif (err)\n\t\treturn err;\n\n\tnew_pgoff = vma->vm_pgoff + ((old_addr - vma->vm_start) >> PAGE_SHIFT);\n\tnew_vma = copy_vma(&vma, new_addr, new_len, new_pgoff,\n\t\t\t   &need_rmap_locks);\n\tif (!new_vma)\n\t\treturn -ENOMEM;\n\n\tmoved_len = move_page_tables(vma, old_addr, new_vma, new_addr, old_len,\n\t\t\t\t     need_rmap_locks);\n\tif (moved_len < old_len) {\n\t\terr = -ENOMEM;\n\t} else if (vma->vm_ops && vma->vm_ops->mremap) {\n\t\terr = vma->vm_ops->mremap(new_vma);\n\t}\n\n\tif (unlikely(err)) {\n\t\t/*\n\t\t * On error, move entries back from new area to old,\n\t\t * which will succeed since page tables still there,\n\t\t * and then proceed to unmap new area instead of old.\n\t\t */\n\t\tmove_page_tables(new_vma, new_addr, vma, old_addr, moved_len,\n\t\t\t\t true);\n\t\tvma = new_vma;\n\t\told_len = new_len;\n\t\told_addr = new_addr;\n\t\tnew_addr = err;\n\t} else {\n\t\tmremap_userfaultfd_prep(new_vma, uf);\n\t\tarch_remap(mm, old_addr, old_addr + old_len,\n\t\t\t   new_addr, new_addr + new_len);\n\t}\n\n\t/* Conceal VM_ACCOUNT so old reservation is not undone */\n\tif (vm_flags & VM_ACCOUNT) {\n\t\tvma->vm_flags &= ~VM_ACCOUNT;\n\t\texcess = vma->vm_end - vma->vm_start - old_len;\n\t\tif (old_addr > vma->vm_start &&\n\t\t    old_addr + old_len < vma->vm_end)\n\t\t\tsplit = 1;\n\t}\n\n\t/*\n\t * If we failed to move page tables we still do total_vm increment\n\t * since do_munmap() will decrement it by old_len == new_len.\n\t *\n\t * Since total_vm is about to be raised artificially high for a\n\t * moment, we need to restore high watermark afterwards: if stats\n\t * are taken meanwhile, total_vm and hiwater_vm appear too high.\n\t * If this were a serious issue, we'd add a flag to do_munmap().\n\t */\n\thiwater_vm = mm->hiwater_vm;\n\tvm_stat_account(mm, vma->vm_flags, new_len >> PAGE_SHIFT);\n\n\t/* Tell pfnmap has moved from this vma */\n\tif (unlikely(vma->vm_flags & VM_PFNMAP))\n\t\tuntrack_pfn_moved(vma);\n\n\tif (do_munmap(mm, old_addr, old_len, uf_unmap) < 0) {\n\t\t/* OOM: unable to split vma, just get accounts right */\n\t\tvm_unacct_memory(excess >> PAGE_SHIFT);\n\t\texcess = 0;\n\t}\n\tmm->hiwater_vm = hiwater_vm;\n\n\t/* Restore VM_ACCOUNT if one or two pieces of vma left */\n\tif (excess) {\n\t\tvma->vm_flags |= VM_ACCOUNT;\n\t\tif (split)\n\t\t\tvma->vm_next->vm_flags |= VM_ACCOUNT;\n\t}\n\n\tif (vm_flags & VM_LOCKED) {\n\t\tmm->locked_vm += new_len >> PAGE_SHIFT;\n\t\t*locked = true;\n\t}\n\n\treturn new_addr;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/mm-arch-hooks.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swapops.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/ksm.h>",
      "#include <linux/shm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vm_unacct_memory",
          "args": [
            "excess >> PAGE_SHIFT"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_munmap",
          "args": [
            "mm",
            "old_addr",
            "old_len",
            "uf_unmap"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "do_munmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "1552-1609",
          "snippet": "int do_munmap(struct mm_struct *mm, unsigned long start, size_t len, struct list_head *uf)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned long end;\n\tint ret;\n\n\tlen = PAGE_ALIGN(len);\n\tif (len == 0)\n\t\treturn -EINVAL;\n\n\tend = start + len;\n\n\t/* find the first potentially overlapping VMA */\n\tvma = find_vma(mm, start);\n\tif (!vma) {\n\t\tstatic int limit;\n\t\tif (limit < 5) {\n\t\t\tpr_warn(\"munmap of memory not mmapped by process %d (%s): 0x%lx-0x%lx\\n\",\n\t\t\t\t\tcurrent->pid, current->comm,\n\t\t\t\t\tstart, start + len - 1);\n\t\t\tlimit++;\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\n\t/* we're allowed to split an anonymous VMA but not a file-backed one */\n\tif (vma->vm_file) {\n\t\tdo {\n\t\t\tif (start > vma->vm_start)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (end == vma->vm_end)\n\t\t\t\tgoto erase_whole_vma;\n\t\t\tvma = vma->vm_next;\n\t\t} while (vma);\n\t\treturn -EINVAL;\n\t} else {\n\t\t/* the chunk must be a subset of the VMA found */\n\t\tif (start == vma->vm_start && end == vma->vm_end)\n\t\t\tgoto erase_whole_vma;\n\t\tif (start < vma->vm_start || end > vma->vm_end)\n\t\t\treturn -EINVAL;\n\t\tif (offset_in_page(start))\n\t\t\treturn -EINVAL;\n\t\tif (end != vma->vm_end && offset_in_page(end))\n\t\t\treturn -EINVAL;\n\t\tif (start != vma->vm_start && end != vma->vm_end) {\n\t\t\tret = split_vma(mm, vma, start, 1);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t\treturn shrink_vma(mm, vma, start, end);\n\t}\n\nerase_whole_vma:\n\tdelete_vma_from_mm(vma);\n\tdelete_vma(mm, vma);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nint do_munmap(struct mm_struct *mm, unsigned long start, size_t len, struct list_head *uf)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned long end;\n\tint ret;\n\n\tlen = PAGE_ALIGN(len);\n\tif (len == 0)\n\t\treturn -EINVAL;\n\n\tend = start + len;\n\n\t/* find the first potentially overlapping VMA */\n\tvma = find_vma(mm, start);\n\tif (!vma) {\n\t\tstatic int limit;\n\t\tif (limit < 5) {\n\t\t\tpr_warn(\"munmap of memory not mmapped by process %d (%s): 0x%lx-0x%lx\\n\",\n\t\t\t\t\tcurrent->pid, current->comm,\n\t\t\t\t\tstart, start + len - 1);\n\t\t\tlimit++;\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\n\t/* we're allowed to split an anonymous VMA but not a file-backed one */\n\tif (vma->vm_file) {\n\t\tdo {\n\t\t\tif (start > vma->vm_start)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (end == vma->vm_end)\n\t\t\t\tgoto erase_whole_vma;\n\t\t\tvma = vma->vm_next;\n\t\t} while (vma);\n\t\treturn -EINVAL;\n\t} else {\n\t\t/* the chunk must be a subset of the VMA found */\n\t\tif (start == vma->vm_start && end == vma->vm_end)\n\t\t\tgoto erase_whole_vma;\n\t\tif (start < vma->vm_start || end > vma->vm_end)\n\t\t\treturn -EINVAL;\n\t\tif (offset_in_page(start))\n\t\t\treturn -EINVAL;\n\t\tif (end != vma->vm_end && offset_in_page(end))\n\t\t\treturn -EINVAL;\n\t\tif (start != vma->vm_start && end != vma->vm_end) {\n\t\t\tret = split_vma(mm, vma, start, 1);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t\treturn shrink_vma(mm, vma, start, end);\n\t}\n\nerase_whole_vma:\n\tdelete_vma_from_mm(vma);\n\tdelete_vma(mm, vma);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "untrack_pfn_moved",
          "args": [
            "vma"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "vma->vm_flags & VM_PFNMAP"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_stat_account",
          "args": [
            "mm",
            "vma->vm_flags",
            "new_len >> PAGE_SHIFT"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "vm_stat_account",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "3306-3316",
          "snippet": "void vm_stat_account(struct mm_struct *mm, vm_flags_t flags, long npages)\n{\n\tmm->total_vm += npages;\n\n\tif (is_exec_mapping(flags))\n\t\tmm->exec_vm += npages;\n\telse if (is_stack_mapping(flags))\n\t\tmm->stack_vm += npages;\n\telse if (is_data_mapping(flags))\n\t\tmm->data_vm += npages;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid vm_stat_account(struct mm_struct *mm, vm_flags_t flags, long npages)\n{\n\tmm->total_vm += npages;\n\n\tif (is_exec_mapping(flags))\n\t\tmm->exec_vm += npages;\n\telse if (is_stack_mapping(flags))\n\t\tmm->stack_vm += npages;\n\telse if (is_data_mapping(flags))\n\t\tmm->data_vm += npages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_remap",
          "args": [
            "mm",
            "old_addr",
            "old_addr + old_len",
            "new_addr",
            "new_addr + new_len"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mremap_userfaultfd_prep",
          "args": [
            "new_vma",
            "uf"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "move_page_tables",
          "args": [
            "new_vma",
            "new_addr",
            "vma",
            "old_addr",
            "moved_len",
            "true"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "move_page_tables",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mremap.c",
          "lines": "194-253",
          "snippet": "unsigned long move_page_tables(struct vm_area_struct *vma,\n\t\tunsigned long old_addr, struct vm_area_struct *new_vma,\n\t\tunsigned long new_addr, unsigned long len,\n\t\tbool need_rmap_locks)\n{\n\tunsigned long extent, next, old_end;\n\tpmd_t *old_pmd, *new_pmd;\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\n\told_end = old_addr + len;\n\tflush_cache_range(vma, old_addr, old_end);\n\n\tmmun_start = old_addr;\n\tmmun_end   = old_end;\n\tmmu_notifier_invalidate_range_start(vma->vm_mm, mmun_start, mmun_end);\n\n\tfor (; old_addr < old_end; old_addr += extent, new_addr += extent) {\n\t\tcond_resched();\n\t\tnext = (old_addr + PMD_SIZE) & PMD_MASK;\n\t\t/* even if next overflowed, extent below will be ok */\n\t\textent = next - old_addr;\n\t\tif (extent > old_end - old_addr)\n\t\t\textent = old_end - old_addr;\n\t\told_pmd = get_old_pmd(vma->vm_mm, old_addr);\n\t\tif (!old_pmd)\n\t\t\tcontinue;\n\t\tnew_pmd = alloc_new_pmd(vma->vm_mm, vma, new_addr);\n\t\tif (!new_pmd)\n\t\t\tbreak;\n\t\tif (is_swap_pmd(*old_pmd) || pmd_trans_huge(*old_pmd)) {\n\t\t\tif (extent == HPAGE_PMD_SIZE) {\n\t\t\t\tbool moved;\n\t\t\t\t/* See comment in move_ptes() */\n\t\t\t\tif (need_rmap_locks)\n\t\t\t\t\ttake_rmap_locks(vma);\n\t\t\t\tmoved = move_huge_pmd(vma, old_addr, new_addr,\n\t\t\t\t\t\t    old_end, old_pmd, new_pmd);\n\t\t\t\tif (need_rmap_locks)\n\t\t\t\t\tdrop_rmap_locks(vma);\n\t\t\t\tif (moved)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsplit_huge_pmd(vma, old_pmd, old_addr);\n\t\t\tif (pmd_trans_unstable(old_pmd))\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (pte_alloc(new_vma->vm_mm, new_pmd, new_addr))\n\t\t\tbreak;\n\t\tnext = (new_addr + PMD_SIZE) & PMD_MASK;\n\t\tif (extent > next - new_addr)\n\t\t\textent = next - new_addr;\n\t\tmove_ptes(vma, old_pmd, old_addr, old_addr + extent, new_vma,\n\t\t\t  new_pmd, new_addr, need_rmap_locks);\n\t}\n\n\tmmu_notifier_invalidate_range_end(vma->vm_mm, mmun_start, mmun_end);\n\n\treturn len + old_addr - old_end;\t/* how much done */\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/mm-arch-hooks.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swapops.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/ksm.h>",
            "#include <linux/shm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mm-arch-hooks.h>\n#include <linux/uaccess.h>\n#include <linux/mmu_notifier.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/swapops.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/ksm.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nunsigned long move_page_tables(struct vm_area_struct *vma,\n\t\tunsigned long old_addr, struct vm_area_struct *new_vma,\n\t\tunsigned long new_addr, unsigned long len,\n\t\tbool need_rmap_locks)\n{\n\tunsigned long extent, next, old_end;\n\tpmd_t *old_pmd, *new_pmd;\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\n\told_end = old_addr + len;\n\tflush_cache_range(vma, old_addr, old_end);\n\n\tmmun_start = old_addr;\n\tmmun_end   = old_end;\n\tmmu_notifier_invalidate_range_start(vma->vm_mm, mmun_start, mmun_end);\n\n\tfor (; old_addr < old_end; old_addr += extent, new_addr += extent) {\n\t\tcond_resched();\n\t\tnext = (old_addr + PMD_SIZE) & PMD_MASK;\n\t\t/* even if next overflowed, extent below will be ok */\n\t\textent = next - old_addr;\n\t\tif (extent > old_end - old_addr)\n\t\t\textent = old_end - old_addr;\n\t\told_pmd = get_old_pmd(vma->vm_mm, old_addr);\n\t\tif (!old_pmd)\n\t\t\tcontinue;\n\t\tnew_pmd = alloc_new_pmd(vma->vm_mm, vma, new_addr);\n\t\tif (!new_pmd)\n\t\t\tbreak;\n\t\tif (is_swap_pmd(*old_pmd) || pmd_trans_huge(*old_pmd)) {\n\t\t\tif (extent == HPAGE_PMD_SIZE) {\n\t\t\t\tbool moved;\n\t\t\t\t/* See comment in move_ptes() */\n\t\t\t\tif (need_rmap_locks)\n\t\t\t\t\ttake_rmap_locks(vma);\n\t\t\t\tmoved = move_huge_pmd(vma, old_addr, new_addr,\n\t\t\t\t\t\t    old_end, old_pmd, new_pmd);\n\t\t\t\tif (need_rmap_locks)\n\t\t\t\t\tdrop_rmap_locks(vma);\n\t\t\t\tif (moved)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsplit_huge_pmd(vma, old_pmd, old_addr);\n\t\t\tif (pmd_trans_unstable(old_pmd))\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (pte_alloc(new_vma->vm_mm, new_pmd, new_addr))\n\t\t\tbreak;\n\t\tnext = (new_addr + PMD_SIZE) & PMD_MASK;\n\t\tif (extent > next - new_addr)\n\t\t\textent = next - new_addr;\n\t\tmove_ptes(vma, old_pmd, old_addr, old_addr + extent, new_vma,\n\t\t\t  new_pmd, new_addr, need_rmap_locks);\n\t}\n\n\tmmu_notifier_invalidate_range_end(vma->vm_mm, mmun_start, mmun_end);\n\n\treturn len + old_addr - old_end;\t/* how much done */\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma->vm_ops->mremap",
          "args": [
            "new_vma"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_vma",
          "args": [
            "&vma",
            "new_addr",
            "new_len",
            "new_pgoff",
            "&need_rmap_locks"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "copy_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "3202-3275",
          "snippet": "struct vm_area_struct *copy_vma(struct vm_area_struct **vmap,\n\tunsigned long addr, unsigned long len, pgoff_t pgoff,\n\tbool *need_rmap_locks)\n{\n\tstruct vm_area_struct *vma = *vmap;\n\tunsigned long vma_start = vma->vm_start;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *new_vma, *prev;\n\tstruct rb_node **rb_link, *rb_parent;\n\tbool faulted_in_anon_vma = true;\n\n\t/*\n\t * If anonymous vma has not yet been faulted, update new pgoff\n\t * to match new location, to increase its chance of merging.\n\t */\n\tif (unlikely(vma_is_anonymous(vma) && !vma->anon_vma)) {\n\t\tpgoff = addr >> PAGE_SHIFT;\n\t\tfaulted_in_anon_vma = false;\n\t}\n\n\tif (find_vma_links(mm, addr, addr + len, &prev, &rb_link, &rb_parent))\n\t\treturn NULL;\t/* should never get here */\n\tnew_vma = vma_merge(mm, prev, addr, addr + len, vma->vm_flags,\n\t\t\t    vma->anon_vma, vma->vm_file, pgoff, vma_policy(vma),\n\t\t\t    vma->vm_userfaultfd_ctx);\n\tif (new_vma) {\n\t\t/*\n\t\t * Source vma may have been merged into new_vma\n\t\t */\n\t\tif (unlikely(vma_start >= new_vma->vm_start &&\n\t\t\t     vma_start < new_vma->vm_end)) {\n\t\t\t/*\n\t\t\t * The only way we can get a vma_merge with\n\t\t\t * self during an mremap is if the vma hasn't\n\t\t\t * been faulted in yet and we were allowed to\n\t\t\t * reset the dst vma->vm_pgoff to the\n\t\t\t * destination address of the mremap to allow\n\t\t\t * the merge to happen. mremap must change the\n\t\t\t * vm_pgoff linearity between src and dst vmas\n\t\t\t * (in turn preventing a vma_merge) to be\n\t\t\t * safe. It is only safe to keep the vm_pgoff\n\t\t\t * linear if there are no pages mapped yet.\n\t\t\t */\n\t\t\tVM_BUG_ON_VMA(faulted_in_anon_vma, new_vma);\n\t\t\t*vmap = vma = new_vma;\n\t\t}\n\t\t*need_rmap_locks = (new_vma->vm_pgoff <= vma->vm_pgoff);\n\t} else {\n\t\tnew_vma = vm_area_dup(vma);\n\t\tif (!new_vma)\n\t\t\tgoto out;\n\t\tnew_vma->vm_start = addr;\n\t\tnew_vma->vm_end = addr + len;\n\t\tnew_vma->vm_pgoff = pgoff;\n\t\tif (vma_dup_policy(vma, new_vma))\n\t\t\tgoto out_free_vma;\n\t\tif (anon_vma_clone(new_vma, vma))\n\t\t\tgoto out_free_mempol;\n\t\tif (new_vma->vm_file)\n\t\t\tget_file(new_vma->vm_file);\n\t\tif (new_vma->vm_ops && new_vma->vm_ops->open)\n\t\t\tnew_vma->vm_ops->open(new_vma);\n\t\tvma_link(mm, new_vma, prev, rb_link, rb_parent);\n\t\t*need_rmap_locks = false;\n\t}\n\treturn new_vma;\n\nout_free_mempol:\n\tmpol_put(vma_policy(new_vma));\nout_free_vma:\n\tvm_area_free(new_vma);\nout:\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct vm_area_struct *copy_vma(struct vm_area_struct **vmap,\n\tunsigned long addr, unsigned long len, pgoff_t pgoff,\n\tbool *need_rmap_locks)\n{\n\tstruct vm_area_struct *vma = *vmap;\n\tunsigned long vma_start = vma->vm_start;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *new_vma, *prev;\n\tstruct rb_node **rb_link, *rb_parent;\n\tbool faulted_in_anon_vma = true;\n\n\t/*\n\t * If anonymous vma has not yet been faulted, update new pgoff\n\t * to match new location, to increase its chance of merging.\n\t */\n\tif (unlikely(vma_is_anonymous(vma) && !vma->anon_vma)) {\n\t\tpgoff = addr >> PAGE_SHIFT;\n\t\tfaulted_in_anon_vma = false;\n\t}\n\n\tif (find_vma_links(mm, addr, addr + len, &prev, &rb_link, &rb_parent))\n\t\treturn NULL;\t/* should never get here */\n\tnew_vma = vma_merge(mm, prev, addr, addr + len, vma->vm_flags,\n\t\t\t    vma->anon_vma, vma->vm_file, pgoff, vma_policy(vma),\n\t\t\t    vma->vm_userfaultfd_ctx);\n\tif (new_vma) {\n\t\t/*\n\t\t * Source vma may have been merged into new_vma\n\t\t */\n\t\tif (unlikely(vma_start >= new_vma->vm_start &&\n\t\t\t     vma_start < new_vma->vm_end)) {\n\t\t\t/*\n\t\t\t * The only way we can get a vma_merge with\n\t\t\t * self during an mremap is if the vma hasn't\n\t\t\t * been faulted in yet and we were allowed to\n\t\t\t * reset the dst vma->vm_pgoff to the\n\t\t\t * destination address of the mremap to allow\n\t\t\t * the merge to happen. mremap must change the\n\t\t\t * vm_pgoff linearity between src and dst vmas\n\t\t\t * (in turn preventing a vma_merge) to be\n\t\t\t * safe. It is only safe to keep the vm_pgoff\n\t\t\t * linear if there are no pages mapped yet.\n\t\t\t */\n\t\t\tVM_BUG_ON_VMA(faulted_in_anon_vma, new_vma);\n\t\t\t*vmap = vma = new_vma;\n\t\t}\n\t\t*need_rmap_locks = (new_vma->vm_pgoff <= vma->vm_pgoff);\n\t} else {\n\t\tnew_vma = vm_area_dup(vma);\n\t\tif (!new_vma)\n\t\t\tgoto out;\n\t\tnew_vma->vm_start = addr;\n\t\tnew_vma->vm_end = addr + len;\n\t\tnew_vma->vm_pgoff = pgoff;\n\t\tif (vma_dup_policy(vma, new_vma))\n\t\t\tgoto out_free_vma;\n\t\tif (anon_vma_clone(new_vma, vma))\n\t\t\tgoto out_free_mempol;\n\t\tif (new_vma->vm_file)\n\t\t\tget_file(new_vma->vm_file);\n\t\tif (new_vma->vm_ops && new_vma->vm_ops->open)\n\t\t\tnew_vma->vm_ops->open(new_vma);\n\t\tvma_link(mm, new_vma, prev, rb_link, rb_parent);\n\t\t*need_rmap_locks = false;\n\t}\n\treturn new_vma;\n\nout_free_mempol:\n\tmpol_put(vma_policy(new_vma));\nout_free_vma:\n\tvm_area_free(new_vma);\nout:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ksm_madvise",
          "args": [
            "vma",
            "old_addr",
            "old_addr + old_len",
            "MADV_UNMERGEABLE",
            "&vm_flags"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "ksm_madvise",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "2417-2469",
          "snippet": "int ksm_madvise(struct vm_area_struct *vma, unsigned long start,\n\t\tunsigned long end, int advice, unsigned long *vm_flags)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tint err;\n\n\tswitch (advice) {\n\tcase MADV_MERGEABLE:\n\t\t/*\n\t\t * Be somewhat over-protective for now!\n\t\t */\n\t\tif (*vm_flags & (VM_MERGEABLE | VM_SHARED  | VM_MAYSHARE   |\n\t\t\t\t VM_PFNMAP    | VM_IO      | VM_DONTEXPAND |\n\t\t\t\t VM_HUGETLB | VM_MIXEDMAP))\n\t\t\treturn 0;\t\t/* just ignore the advice */\n\n\t\tif (vma_is_dax(vma))\n\t\t\treturn 0;\n\n#ifdef VM_SAO\n\t\tif (*vm_flags & VM_SAO)\n\t\t\treturn 0;\n#endif\n#ifdef VM_SPARC_ADI\n\t\tif (*vm_flags & VM_SPARC_ADI)\n\t\t\treturn 0;\n#endif\n\n\t\tif (!test_bit(MMF_VM_MERGEABLE, &mm->flags)) {\n\t\t\terr = __ksm_enter(mm);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\t*vm_flags |= VM_MERGEABLE;\n\t\tbreak;\n\n\tcase MADV_UNMERGEABLE:\n\t\tif (!(*vm_flags & VM_MERGEABLE))\n\t\t\treturn 0;\t\t/* just ignore the advice */\n\n\t\tif (vma->anon_vma) {\n\t\t\terr = unmerge_ksm_pages(vma, start, end);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\t*vm_flags &= ~VM_MERGEABLE;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nint ksm_madvise(struct vm_area_struct *vma, unsigned long start,\n\t\tunsigned long end, int advice, unsigned long *vm_flags)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tint err;\n\n\tswitch (advice) {\n\tcase MADV_MERGEABLE:\n\t\t/*\n\t\t * Be somewhat over-protective for now!\n\t\t */\n\t\tif (*vm_flags & (VM_MERGEABLE | VM_SHARED  | VM_MAYSHARE   |\n\t\t\t\t VM_PFNMAP    | VM_IO      | VM_DONTEXPAND |\n\t\t\t\t VM_HUGETLB | VM_MIXEDMAP))\n\t\t\treturn 0;\t\t/* just ignore the advice */\n\n\t\tif (vma_is_dax(vma))\n\t\t\treturn 0;\n\n#ifdef VM_SAO\n\t\tif (*vm_flags & VM_SAO)\n\t\t\treturn 0;\n#endif\n#ifdef VM_SPARC_ADI\n\t\tif (*vm_flags & VM_SPARC_ADI)\n\t\t\treturn 0;\n#endif\n\n\t\tif (!test_bit(MMF_VM_MERGEABLE, &mm->flags)) {\n\t\t\terr = __ksm_enter(mm);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\t*vm_flags |= VM_MERGEABLE;\n\t\tbreak;\n\n\tcase MADV_UNMERGEABLE:\n\t\tif (!(*vm_flags & VM_MERGEABLE))\n\t\t\treturn 0;\t\t/* just ignore the advice */\n\n\t\tif (vma->anon_vma) {\n\t\t\terr = unmerge_ksm_pages(vma, start, end);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\t*vm_flags &= ~VM_MERGEABLE;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mm-arch-hooks.h>\n#include <linux/uaccess.h>\n#include <linux/mmu_notifier.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/swapops.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/ksm.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nstatic unsigned long move_vma(struct vm_area_struct *vma,\n\t\tunsigned long old_addr, unsigned long old_len,\n\t\tunsigned long new_len, unsigned long new_addr,\n\t\tbool *locked, struct vm_userfaultfd_ctx *uf,\n\t\tstruct list_head *uf_unmap)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *new_vma;\n\tunsigned long vm_flags = vma->vm_flags;\n\tunsigned long new_pgoff;\n\tunsigned long moved_len;\n\tunsigned long excess = 0;\n\tunsigned long hiwater_vm;\n\tint split = 0;\n\tint err;\n\tbool need_rmap_locks;\n\n\t/*\n\t * We'd prefer to avoid failure later on in do_munmap:\n\t * which may split one vma into three before unmapping.\n\t */\n\tif (mm->map_count >= sysctl_max_map_count - 3)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Advise KSM to break any KSM pages in the area to be moved:\n\t * it would be confusing if they were to turn up at the new\n\t * location, where they happen to coincide with different KSM\n\t * pages recently unmapped.  But leave vma->vm_flags as it was,\n\t * so KSM can come around to merge on vma and new_vma afterwards.\n\t */\n\terr = ksm_madvise(vma, old_addr, old_addr + old_len,\n\t\t\t\t\t\tMADV_UNMERGEABLE, &vm_flags);\n\tif (err)\n\t\treturn err;\n\n\tnew_pgoff = vma->vm_pgoff + ((old_addr - vma->vm_start) >> PAGE_SHIFT);\n\tnew_vma = copy_vma(&vma, new_addr, new_len, new_pgoff,\n\t\t\t   &need_rmap_locks);\n\tif (!new_vma)\n\t\treturn -ENOMEM;\n\n\tmoved_len = move_page_tables(vma, old_addr, new_vma, new_addr, old_len,\n\t\t\t\t     need_rmap_locks);\n\tif (moved_len < old_len) {\n\t\terr = -ENOMEM;\n\t} else if (vma->vm_ops && vma->vm_ops->mremap) {\n\t\terr = vma->vm_ops->mremap(new_vma);\n\t}\n\n\tif (unlikely(err)) {\n\t\t/*\n\t\t * On error, move entries back from new area to old,\n\t\t * which will succeed since page tables still there,\n\t\t * and then proceed to unmap new area instead of old.\n\t\t */\n\t\tmove_page_tables(new_vma, new_addr, vma, old_addr, moved_len,\n\t\t\t\t true);\n\t\tvma = new_vma;\n\t\told_len = new_len;\n\t\told_addr = new_addr;\n\t\tnew_addr = err;\n\t} else {\n\t\tmremap_userfaultfd_prep(new_vma, uf);\n\t\tarch_remap(mm, old_addr, old_addr + old_len,\n\t\t\t   new_addr, new_addr + new_len);\n\t}\n\n\t/* Conceal VM_ACCOUNT so old reservation is not undone */\n\tif (vm_flags & VM_ACCOUNT) {\n\t\tvma->vm_flags &= ~VM_ACCOUNT;\n\t\texcess = vma->vm_end - vma->vm_start - old_len;\n\t\tif (old_addr > vma->vm_start &&\n\t\t    old_addr + old_len < vma->vm_end)\n\t\t\tsplit = 1;\n\t}\n\n\t/*\n\t * If we failed to move page tables we still do total_vm increment\n\t * since do_munmap() will decrement it by old_len == new_len.\n\t *\n\t * Since total_vm is about to be raised artificially high for a\n\t * moment, we need to restore high watermark afterwards: if stats\n\t * are taken meanwhile, total_vm and hiwater_vm appear too high.\n\t * If this were a serious issue, we'd add a flag to do_munmap().\n\t */\n\thiwater_vm = mm->hiwater_vm;\n\tvm_stat_account(mm, vma->vm_flags, new_len >> PAGE_SHIFT);\n\n\t/* Tell pfnmap has moved from this vma */\n\tif (unlikely(vma->vm_flags & VM_PFNMAP))\n\t\tuntrack_pfn_moved(vma);\n\n\tif (do_munmap(mm, old_addr, old_len, uf_unmap) < 0) {\n\t\t/* OOM: unable to split vma, just get accounts right */\n\t\tvm_unacct_memory(excess >> PAGE_SHIFT);\n\t\texcess = 0;\n\t}\n\tmm->hiwater_vm = hiwater_vm;\n\n\t/* Restore VM_ACCOUNT if one or two pieces of vma left */\n\tif (excess) {\n\t\tvma->vm_flags |= VM_ACCOUNT;\n\t\tif (split)\n\t\t\tvma->vm_next->vm_flags |= VM_ACCOUNT;\n\t}\n\n\tif (vm_flags & VM_LOCKED) {\n\t\tmm->locked_vm += new_len >> PAGE_SHIFT;\n\t\t*locked = true;\n\t}\n\n\treturn new_addr;\n}"
  },
  {
    "function_name": "move_page_tables",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mremap.c",
    "lines": "194-253",
    "snippet": "unsigned long move_page_tables(struct vm_area_struct *vma,\n\t\tunsigned long old_addr, struct vm_area_struct *new_vma,\n\t\tunsigned long new_addr, unsigned long len,\n\t\tbool need_rmap_locks)\n{\n\tunsigned long extent, next, old_end;\n\tpmd_t *old_pmd, *new_pmd;\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\n\told_end = old_addr + len;\n\tflush_cache_range(vma, old_addr, old_end);\n\n\tmmun_start = old_addr;\n\tmmun_end   = old_end;\n\tmmu_notifier_invalidate_range_start(vma->vm_mm, mmun_start, mmun_end);\n\n\tfor (; old_addr < old_end; old_addr += extent, new_addr += extent) {\n\t\tcond_resched();\n\t\tnext = (old_addr + PMD_SIZE) & PMD_MASK;\n\t\t/* even if next overflowed, extent below will be ok */\n\t\textent = next - old_addr;\n\t\tif (extent > old_end - old_addr)\n\t\t\textent = old_end - old_addr;\n\t\told_pmd = get_old_pmd(vma->vm_mm, old_addr);\n\t\tif (!old_pmd)\n\t\t\tcontinue;\n\t\tnew_pmd = alloc_new_pmd(vma->vm_mm, vma, new_addr);\n\t\tif (!new_pmd)\n\t\t\tbreak;\n\t\tif (is_swap_pmd(*old_pmd) || pmd_trans_huge(*old_pmd)) {\n\t\t\tif (extent == HPAGE_PMD_SIZE) {\n\t\t\t\tbool moved;\n\t\t\t\t/* See comment in move_ptes() */\n\t\t\t\tif (need_rmap_locks)\n\t\t\t\t\ttake_rmap_locks(vma);\n\t\t\t\tmoved = move_huge_pmd(vma, old_addr, new_addr,\n\t\t\t\t\t\t    old_end, old_pmd, new_pmd);\n\t\t\t\tif (need_rmap_locks)\n\t\t\t\t\tdrop_rmap_locks(vma);\n\t\t\t\tif (moved)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsplit_huge_pmd(vma, old_pmd, old_addr);\n\t\t\tif (pmd_trans_unstable(old_pmd))\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (pte_alloc(new_vma->vm_mm, new_pmd, new_addr))\n\t\t\tbreak;\n\t\tnext = (new_addr + PMD_SIZE) & PMD_MASK;\n\t\tif (extent > next - new_addr)\n\t\t\textent = next - new_addr;\n\t\tmove_ptes(vma, old_pmd, old_addr, old_addr + extent, new_vma,\n\t\t\t  new_pmd, new_addr, need_rmap_locks);\n\t}\n\n\tmmu_notifier_invalidate_range_end(vma->vm_mm, mmun_start, mmun_end);\n\n\treturn len + old_addr - old_end;\t/* how much done */\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/mm-arch-hooks.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swapops.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/ksm.h>",
      "#include <linux/shm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_end",
          "args": [
            "vma->vm_mm",
            "mmun_start",
            "mmun_end"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "move_ptes",
          "args": [
            "vma",
            "old_pmd",
            "old_addr",
            "old_addr + extent",
            "new_vma",
            "new_pmd",
            "new_addr",
            "need_rmap_locks"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "move_ptes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mremap.c",
          "lines": "115-192",
          "snippet": "static void move_ptes(struct vm_area_struct *vma, pmd_t *old_pmd,\n\t\tunsigned long old_addr, unsigned long old_end,\n\t\tstruct vm_area_struct *new_vma, pmd_t *new_pmd,\n\t\tunsigned long new_addr, bool need_rmap_locks)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpte_t *old_pte, *new_pte, pte;\n\tspinlock_t *old_ptl, *new_ptl;\n\tbool force_flush = false;\n\tunsigned long len = old_end - old_addr;\n\n\t/*\n\t * When need_rmap_locks is true, we take the i_mmap_rwsem and anon_vma\n\t * locks to ensure that rmap will always observe either the old or the\n\t * new ptes. This is the easiest way to avoid races with\n\t * truncate_pagecache(), page migration, etc...\n\t *\n\t * When need_rmap_locks is false, we use other ways to avoid\n\t * such races:\n\t *\n\t * - During exec() shift_arg_pages(), we use a specially tagged vma\n\t *   which rmap call sites look for using is_vma_temporary_stack().\n\t *\n\t * - During mremap(), new_vma is often known to be placed after vma\n\t *   in rmap traversal order. This ensures rmap will always observe\n\t *   either the old pte, or the new pte, or both (the page table locks\n\t *   serialize access to individual ptes, but only rmap traversal\n\t *   order guarantees that we won't miss both the old and new ptes).\n\t */\n\tif (need_rmap_locks)\n\t\ttake_rmap_locks(vma);\n\n\t/*\n\t * We don't have to worry about the ordering of src and dst\n\t * pte locks because exclusive mmap_sem prevents deadlock.\n\t */\n\told_pte = pte_offset_map_lock(mm, old_pmd, old_addr, &old_ptl);\n\tnew_pte = pte_offset_map(new_pmd, new_addr);\n\tnew_ptl = pte_lockptr(mm, new_pmd);\n\tif (new_ptl != old_ptl)\n\t\tspin_lock_nested(new_ptl, SINGLE_DEPTH_NESTING);\n\tflush_tlb_batched_pending(vma->vm_mm);\n\tarch_enter_lazy_mmu_mode();\n\n\tfor (; old_addr < old_end; old_pte++, old_addr += PAGE_SIZE,\n\t\t\t\t   new_pte++, new_addr += PAGE_SIZE) {\n\t\tif (pte_none(*old_pte))\n\t\t\tcontinue;\n\n\t\tpte = ptep_get_and_clear(mm, old_addr, old_pte);\n\t\t/*\n\t\t * If we are remapping a valid PTE, make sure\n\t\t * to flush TLB before we drop the PTL for the\n\t\t * PTE.\n\t\t *\n\t\t * NOTE! Both old and new PTL matter: the old one\n\t\t * for racing with page_mkclean(), the new one to\n\t\t * make sure the physical page stays valid until\n\t\t * the TLB entry for the old mapping has been\n\t\t * flushed.\n\t\t */\n\t\tif (pte_present(pte))\n\t\t\tforce_flush = true;\n\t\tpte = move_pte(pte, new_vma->vm_page_prot, old_addr, new_addr);\n\t\tpte = move_soft_dirty_pte(pte);\n\t\tset_pte_at(mm, new_addr, new_pte, pte);\n\t}\n\n\tarch_leave_lazy_mmu_mode();\n\tif (force_flush)\n\t\tflush_tlb_range(vma, old_end - len, old_end);\n\tif (new_ptl != old_ptl)\n\t\tspin_unlock(new_ptl);\n\tpte_unmap(new_pte - 1);\n\tpte_unmap_unlock(old_pte - 1, old_ptl);\n\tif (need_rmap_locks)\n\t\tdrop_rmap_locks(vma);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/mm-arch-hooks.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swapops.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/ksm.h>",
            "#include <linux/shm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mm-arch-hooks.h>\n#include <linux/uaccess.h>\n#include <linux/mmu_notifier.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/swapops.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/ksm.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nstatic void move_ptes(struct vm_area_struct *vma, pmd_t *old_pmd,\n\t\tunsigned long old_addr, unsigned long old_end,\n\t\tstruct vm_area_struct *new_vma, pmd_t *new_pmd,\n\t\tunsigned long new_addr, bool need_rmap_locks)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpte_t *old_pte, *new_pte, pte;\n\tspinlock_t *old_ptl, *new_ptl;\n\tbool force_flush = false;\n\tunsigned long len = old_end - old_addr;\n\n\t/*\n\t * When need_rmap_locks is true, we take the i_mmap_rwsem and anon_vma\n\t * locks to ensure that rmap will always observe either the old or the\n\t * new ptes. This is the easiest way to avoid races with\n\t * truncate_pagecache(), page migration, etc...\n\t *\n\t * When need_rmap_locks is false, we use other ways to avoid\n\t * such races:\n\t *\n\t * - During exec() shift_arg_pages(), we use a specially tagged vma\n\t *   which rmap call sites look for using is_vma_temporary_stack().\n\t *\n\t * - During mremap(), new_vma is often known to be placed after vma\n\t *   in rmap traversal order. This ensures rmap will always observe\n\t *   either the old pte, or the new pte, or both (the page table locks\n\t *   serialize access to individual ptes, but only rmap traversal\n\t *   order guarantees that we won't miss both the old and new ptes).\n\t */\n\tif (need_rmap_locks)\n\t\ttake_rmap_locks(vma);\n\n\t/*\n\t * We don't have to worry about the ordering of src and dst\n\t * pte locks because exclusive mmap_sem prevents deadlock.\n\t */\n\told_pte = pte_offset_map_lock(mm, old_pmd, old_addr, &old_ptl);\n\tnew_pte = pte_offset_map(new_pmd, new_addr);\n\tnew_ptl = pte_lockptr(mm, new_pmd);\n\tif (new_ptl != old_ptl)\n\t\tspin_lock_nested(new_ptl, SINGLE_DEPTH_NESTING);\n\tflush_tlb_batched_pending(vma->vm_mm);\n\tarch_enter_lazy_mmu_mode();\n\n\tfor (; old_addr < old_end; old_pte++, old_addr += PAGE_SIZE,\n\t\t\t\t   new_pte++, new_addr += PAGE_SIZE) {\n\t\tif (pte_none(*old_pte))\n\t\t\tcontinue;\n\n\t\tpte = ptep_get_and_clear(mm, old_addr, old_pte);\n\t\t/*\n\t\t * If we are remapping a valid PTE, make sure\n\t\t * to flush TLB before we drop the PTL for the\n\t\t * PTE.\n\t\t *\n\t\t * NOTE! Both old and new PTL matter: the old one\n\t\t * for racing with page_mkclean(), the new one to\n\t\t * make sure the physical page stays valid until\n\t\t * the TLB entry for the old mapping has been\n\t\t * flushed.\n\t\t */\n\t\tif (pte_present(pte))\n\t\t\tforce_flush = true;\n\t\tpte = move_pte(pte, new_vma->vm_page_prot, old_addr, new_addr);\n\t\tpte = move_soft_dirty_pte(pte);\n\t\tset_pte_at(mm, new_addr, new_pte, pte);\n\t}\n\n\tarch_leave_lazy_mmu_mode();\n\tif (force_flush)\n\t\tflush_tlb_range(vma, old_end - len, old_end);\n\tif (new_ptl != old_ptl)\n\t\tspin_unlock(new_ptl);\n\tpte_unmap(new_pte - 1);\n\tpte_unmap_unlock(old_pte - 1, old_ptl);\n\tif (need_rmap_locks)\n\t\tdrop_rmap_locks(vma);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_alloc",
          "args": [
            "new_vma->vm_mm",
            "new_pmd",
            "new_addr"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "__pte_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "403-435",
          "snippet": "int __pte_alloc(struct mm_struct *mm, pmd_t *pmd, unsigned long address)\n{\n\tspinlock_t *ptl;\n\tpgtable_t new = pte_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Ensure all pte setup (eg. pte page lock and page clearing) are\n\t * visible before the pte is made visible to other CPUs by being\n\t * put into page tables.\n\t *\n\t * The other side of the story is the pointer chasing in the page\n\t * table walking code (when walking the page table without locking;\n\t * ie. most of the time). Fortunately, these data accesses consist\n\t * of a chain of data-dependent loads, meaning most CPUs (alpha\n\t * being the notable exception) will already guarantee loads are\n\t * seen in-order. See the alpha page table accessors for the\n\t * smp_read_barrier_depends() barriers in page table walking code.\n\t */\n\tsmp_wmb(); /* Could be smp_wmb__xxx(before|after)_spin_lock */\n\n\tptl = pmd_lock(mm, pmd);\n\tif (likely(pmd_none(*pmd))) {\t/* Has another populated it ? */\n\t\tmm_inc_nr_ptes(mm);\n\t\tpmd_populate(mm, pmd, new);\n\t\tnew = NULL;\n\t}\n\tspin_unlock(ptl);\n\tif (new)\n\t\tpte_free(mm, new);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __pte_alloc(struct mm_struct *mm, pmd_t *pmd, unsigned long address)\n{\n\tspinlock_t *ptl;\n\tpgtable_t new = pte_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Ensure all pte setup (eg. pte page lock and page clearing) are\n\t * visible before the pte is made visible to other CPUs by being\n\t * put into page tables.\n\t *\n\t * The other side of the story is the pointer chasing in the page\n\t * table walking code (when walking the page table without locking;\n\t * ie. most of the time). Fortunately, these data accesses consist\n\t * of a chain of data-dependent loads, meaning most CPUs (alpha\n\t * being the notable exception) will already guarantee loads are\n\t * seen in-order. See the alpha page table accessors for the\n\t * smp_read_barrier_depends() barriers in page table walking code.\n\t */\n\tsmp_wmb(); /* Could be smp_wmb__xxx(before|after)_spin_lock */\n\n\tptl = pmd_lock(mm, pmd);\n\tif (likely(pmd_none(*pmd))) {\t/* Has another populated it ? */\n\t\tmm_inc_nr_ptes(mm);\n\t\tpmd_populate(mm, pmd, new);\n\t\tnew = NULL;\n\t}\n\tspin_unlock(ptl);\n\tif (new)\n\t\tpte_free(mm, new);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_trans_unstable",
          "args": [
            "old_pmd"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "split_huge_pmd",
          "args": [
            "vma",
            "old_pmd",
            "old_addr"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drop_rmap_locks",
          "args": [
            "vma"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "drop_rmap_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mremap.c",
          "lines": "92-98",
          "snippet": "static void drop_rmap_locks(struct vm_area_struct *vma)\n{\n\tif (vma->anon_vma)\n\t\tanon_vma_unlock_write(vma->anon_vma);\n\tif (vma->vm_file)\n\t\ti_mmap_unlock_write(vma->vm_file->f_mapping);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/mm-arch-hooks.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swapops.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/ksm.h>",
            "#include <linux/shm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mm-arch-hooks.h>\n#include <linux/uaccess.h>\n#include <linux/mmu_notifier.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/swapops.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/ksm.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nstatic void drop_rmap_locks(struct vm_area_struct *vma)\n{\n\tif (vma->anon_vma)\n\t\tanon_vma_unlock_write(vma->anon_vma);\n\tif (vma->vm_file)\n\t\ti_mmap_unlock_write(vma->vm_file->f_mapping);\n}"
        }
      },
      {
        "call_info": {
          "callee": "move_huge_pmd",
          "args": [
            "vma",
            "old_addr",
            "new_addr",
            "old_end",
            "old_pmd",
            "new_pmd"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "move_huge_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "1809-1861",
          "snippet": "bool move_huge_pmd(struct vm_area_struct *vma, unsigned long old_addr,\n\t\t  unsigned long new_addr, unsigned long old_end,\n\t\t  pmd_t *old_pmd, pmd_t *new_pmd)\n{\n\tspinlock_t *old_ptl, *new_ptl;\n\tpmd_t pmd;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tbool force_flush = false;\n\n\tif ((old_addr & ~HPAGE_PMD_MASK) ||\n\t    (new_addr & ~HPAGE_PMD_MASK) ||\n\t    old_end - old_addr < HPAGE_PMD_SIZE)\n\t\treturn false;\n\n\t/*\n\t * The destination pmd shouldn't be established, free_pgtables()\n\t * should have release it.\n\t */\n\tif (WARN_ON(!pmd_none(*new_pmd))) {\n\t\tVM_BUG_ON(pmd_trans_huge(*new_pmd));\n\t\treturn false;\n\t}\n\n\t/*\n\t * We don't have to worry about the ordering of src and dst\n\t * ptlocks because exclusive mmap_sem prevents deadlock.\n\t */\n\told_ptl = __pmd_trans_huge_lock(old_pmd, vma);\n\tif (old_ptl) {\n\t\tnew_ptl = pmd_lockptr(mm, new_pmd);\n\t\tif (new_ptl != old_ptl)\n\t\t\tspin_lock_nested(new_ptl, SINGLE_DEPTH_NESTING);\n\t\tpmd = pmdp_huge_get_and_clear(mm, old_addr, old_pmd);\n\t\tif (pmd_present(pmd))\n\t\t\tforce_flush = true;\n\t\tVM_BUG_ON(!pmd_none(*new_pmd));\n\n\t\tif (pmd_move_must_withdraw(new_ptl, old_ptl, vma)) {\n\t\t\tpgtable_t pgtable;\n\t\t\tpgtable = pgtable_trans_huge_withdraw(mm, old_pmd);\n\t\t\tpgtable_trans_huge_deposit(mm, new_pmd, pgtable);\n\t\t}\n\t\tpmd = move_soft_dirty_pmd(pmd);\n\t\tset_pmd_at(mm, new_addr, new_pmd, pmd);\n\t\tif (force_flush)\n\t\t\tflush_tlb_range(vma, old_addr, old_addr + PMD_SIZE);\n\t\tif (new_ptl != old_ptl)\n\t\t\tspin_unlock(new_ptl);\n\t\tspin_unlock(old_ptl);\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nbool move_huge_pmd(struct vm_area_struct *vma, unsigned long old_addr,\n\t\t  unsigned long new_addr, unsigned long old_end,\n\t\t  pmd_t *old_pmd, pmd_t *new_pmd)\n{\n\tspinlock_t *old_ptl, *new_ptl;\n\tpmd_t pmd;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tbool force_flush = false;\n\n\tif ((old_addr & ~HPAGE_PMD_MASK) ||\n\t    (new_addr & ~HPAGE_PMD_MASK) ||\n\t    old_end - old_addr < HPAGE_PMD_SIZE)\n\t\treturn false;\n\n\t/*\n\t * The destination pmd shouldn't be established, free_pgtables()\n\t * should have release it.\n\t */\n\tif (WARN_ON(!pmd_none(*new_pmd))) {\n\t\tVM_BUG_ON(pmd_trans_huge(*new_pmd));\n\t\treturn false;\n\t}\n\n\t/*\n\t * We don't have to worry about the ordering of src and dst\n\t * ptlocks because exclusive mmap_sem prevents deadlock.\n\t */\n\told_ptl = __pmd_trans_huge_lock(old_pmd, vma);\n\tif (old_ptl) {\n\t\tnew_ptl = pmd_lockptr(mm, new_pmd);\n\t\tif (new_ptl != old_ptl)\n\t\t\tspin_lock_nested(new_ptl, SINGLE_DEPTH_NESTING);\n\t\tpmd = pmdp_huge_get_and_clear(mm, old_addr, old_pmd);\n\t\tif (pmd_present(pmd))\n\t\t\tforce_flush = true;\n\t\tVM_BUG_ON(!pmd_none(*new_pmd));\n\n\t\tif (pmd_move_must_withdraw(new_ptl, old_ptl, vma)) {\n\t\t\tpgtable_t pgtable;\n\t\t\tpgtable = pgtable_trans_huge_withdraw(mm, old_pmd);\n\t\t\tpgtable_trans_huge_deposit(mm, new_pmd, pgtable);\n\t\t}\n\t\tpmd = move_soft_dirty_pmd(pmd);\n\t\tset_pmd_at(mm, new_addr, new_pmd, pmd);\n\t\tif (force_flush)\n\t\t\tflush_tlb_range(vma, old_addr, old_addr + PMD_SIZE);\n\t\tif (new_ptl != old_ptl)\n\t\t\tspin_unlock(new_ptl);\n\t\tspin_unlock(old_ptl);\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "take_rmap_locks",
          "args": [
            "vma"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "take_rmap_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mremap.c",
          "lines": "84-90",
          "snippet": "static void take_rmap_locks(struct vm_area_struct *vma)\n{\n\tif (vma->vm_file)\n\t\ti_mmap_lock_write(vma->vm_file->f_mapping);\n\tif (vma->anon_vma)\n\t\tanon_vma_lock_write(vma->anon_vma);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/mm-arch-hooks.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swapops.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/ksm.h>",
            "#include <linux/shm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mm-arch-hooks.h>\n#include <linux/uaccess.h>\n#include <linux/mmu_notifier.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/swapops.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/ksm.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nstatic void take_rmap_locks(struct vm_area_struct *vma)\n{\n\tif (vma->vm_file)\n\t\ti_mmap_lock_write(vma->vm_file->f_mapping);\n\tif (vma->anon_vma)\n\t\tanon_vma_lock_write(vma->anon_vma);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_trans_huge",
          "args": [
            "*old_pmd"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_swap_pmd",
          "args": [
            "*old_pmd"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_new_pmd",
          "args": [
            "vma->vm_mm",
            "vma",
            "new_addr"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_new_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mremap.c",
          "lines": "59-82",
          "snippet": "static pmd_t *alloc_new_pmd(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t\t    unsigned long addr)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(mm, addr);\n\tp4d = p4d_alloc(mm, pgd, addr);\n\tif (!p4d)\n\t\treturn NULL;\n\tpud = pud_alloc(mm, p4d, addr);\n\tif (!pud)\n\t\treturn NULL;\n\n\tpmd = pmd_alloc(mm, pud, addr);\n\tif (!pmd)\n\t\treturn NULL;\n\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\n\treturn pmd;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/mm-arch-hooks.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swapops.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/ksm.h>",
            "#include <linux/shm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mm-arch-hooks.h>\n#include <linux/uaccess.h>\n#include <linux/mmu_notifier.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/swapops.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/ksm.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nstatic pmd_t *alloc_new_pmd(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t\t    unsigned long addr)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(mm, addr);\n\tp4d = p4d_alloc(mm, pgd, addr);\n\tif (!p4d)\n\t\treturn NULL;\n\tpud = pud_alloc(mm, p4d, addr);\n\tif (!pud)\n\t\treturn NULL;\n\n\tpmd = pmd_alloc(mm, pud, addr);\n\tif (!pmd)\n\t\treturn NULL;\n\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\n\treturn pmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_old_pmd",
          "args": [
            "vma->vm_mm",
            "old_addr"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "get_old_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mremap.c",
          "lines": "33-57",
          "snippet": "static pmd_t *get_old_pmd(struct mm_struct *mm, unsigned long addr)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(mm, addr);\n\tif (pgd_none_or_clear_bad(pgd))\n\t\treturn NULL;\n\n\tp4d = p4d_offset(pgd, addr);\n\tif (p4d_none_or_clear_bad(p4d))\n\t\treturn NULL;\n\n\tpud = pud_offset(p4d, addr);\n\tif (pud_none_or_clear_bad(pud))\n\t\treturn NULL;\n\n\tpmd = pmd_offset(pud, addr);\n\tif (pmd_none(*pmd))\n\t\treturn NULL;\n\n\treturn pmd;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/mm-arch-hooks.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swapops.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/ksm.h>",
            "#include <linux/shm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mm-arch-hooks.h>\n#include <linux/uaccess.h>\n#include <linux/mmu_notifier.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/swapops.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/ksm.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nstatic pmd_t *get_old_pmd(struct mm_struct *mm, unsigned long addr)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(mm, addr);\n\tif (pgd_none_or_clear_bad(pgd))\n\t\treturn NULL;\n\n\tp4d = p4d_offset(pgd, addr);\n\tif (p4d_none_or_clear_bad(p4d))\n\t\treturn NULL;\n\n\tpud = pud_offset(p4d, addr);\n\tif (pud_none_or_clear_bad(pud))\n\t\treturn NULL;\n\n\tpmd = pmd_offset(pud, addr);\n\tif (pmd_none(*pmd))\n\t\treturn NULL;\n\n\treturn pmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_start",
          "args": [
            "vma->vm_mm",
            "mmun_start",
            "mmun_end"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_cache_range",
          "args": [
            "vma",
            "old_addr",
            "old_end"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mm-arch-hooks.h>\n#include <linux/uaccess.h>\n#include <linux/mmu_notifier.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/swapops.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/ksm.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nunsigned long move_page_tables(struct vm_area_struct *vma,\n\t\tunsigned long old_addr, struct vm_area_struct *new_vma,\n\t\tunsigned long new_addr, unsigned long len,\n\t\tbool need_rmap_locks)\n{\n\tunsigned long extent, next, old_end;\n\tpmd_t *old_pmd, *new_pmd;\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\n\told_end = old_addr + len;\n\tflush_cache_range(vma, old_addr, old_end);\n\n\tmmun_start = old_addr;\n\tmmun_end   = old_end;\n\tmmu_notifier_invalidate_range_start(vma->vm_mm, mmun_start, mmun_end);\n\n\tfor (; old_addr < old_end; old_addr += extent, new_addr += extent) {\n\t\tcond_resched();\n\t\tnext = (old_addr + PMD_SIZE) & PMD_MASK;\n\t\t/* even if next overflowed, extent below will be ok */\n\t\textent = next - old_addr;\n\t\tif (extent > old_end - old_addr)\n\t\t\textent = old_end - old_addr;\n\t\told_pmd = get_old_pmd(vma->vm_mm, old_addr);\n\t\tif (!old_pmd)\n\t\t\tcontinue;\n\t\tnew_pmd = alloc_new_pmd(vma->vm_mm, vma, new_addr);\n\t\tif (!new_pmd)\n\t\t\tbreak;\n\t\tif (is_swap_pmd(*old_pmd) || pmd_trans_huge(*old_pmd)) {\n\t\t\tif (extent == HPAGE_PMD_SIZE) {\n\t\t\t\tbool moved;\n\t\t\t\t/* See comment in move_ptes() */\n\t\t\t\tif (need_rmap_locks)\n\t\t\t\t\ttake_rmap_locks(vma);\n\t\t\t\tmoved = move_huge_pmd(vma, old_addr, new_addr,\n\t\t\t\t\t\t    old_end, old_pmd, new_pmd);\n\t\t\t\tif (need_rmap_locks)\n\t\t\t\t\tdrop_rmap_locks(vma);\n\t\t\t\tif (moved)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsplit_huge_pmd(vma, old_pmd, old_addr);\n\t\t\tif (pmd_trans_unstable(old_pmd))\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (pte_alloc(new_vma->vm_mm, new_pmd, new_addr))\n\t\t\tbreak;\n\t\tnext = (new_addr + PMD_SIZE) & PMD_MASK;\n\t\tif (extent > next - new_addr)\n\t\t\textent = next - new_addr;\n\t\tmove_ptes(vma, old_pmd, old_addr, old_addr + extent, new_vma,\n\t\t\t  new_pmd, new_addr, need_rmap_locks);\n\t}\n\n\tmmu_notifier_invalidate_range_end(vma->vm_mm, mmun_start, mmun_end);\n\n\treturn len + old_addr - old_end;\t/* how much done */\n}"
  },
  {
    "function_name": "move_ptes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mremap.c",
    "lines": "115-192",
    "snippet": "static void move_ptes(struct vm_area_struct *vma, pmd_t *old_pmd,\n\t\tunsigned long old_addr, unsigned long old_end,\n\t\tstruct vm_area_struct *new_vma, pmd_t *new_pmd,\n\t\tunsigned long new_addr, bool need_rmap_locks)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpte_t *old_pte, *new_pte, pte;\n\tspinlock_t *old_ptl, *new_ptl;\n\tbool force_flush = false;\n\tunsigned long len = old_end - old_addr;\n\n\t/*\n\t * When need_rmap_locks is true, we take the i_mmap_rwsem and anon_vma\n\t * locks to ensure that rmap will always observe either the old or the\n\t * new ptes. This is the easiest way to avoid races with\n\t * truncate_pagecache(), page migration, etc...\n\t *\n\t * When need_rmap_locks is false, we use other ways to avoid\n\t * such races:\n\t *\n\t * - During exec() shift_arg_pages(), we use a specially tagged vma\n\t *   which rmap call sites look for using is_vma_temporary_stack().\n\t *\n\t * - During mremap(), new_vma is often known to be placed after vma\n\t *   in rmap traversal order. This ensures rmap will always observe\n\t *   either the old pte, or the new pte, or both (the page table locks\n\t *   serialize access to individual ptes, but only rmap traversal\n\t *   order guarantees that we won't miss both the old and new ptes).\n\t */\n\tif (need_rmap_locks)\n\t\ttake_rmap_locks(vma);\n\n\t/*\n\t * We don't have to worry about the ordering of src and dst\n\t * pte locks because exclusive mmap_sem prevents deadlock.\n\t */\n\told_pte = pte_offset_map_lock(mm, old_pmd, old_addr, &old_ptl);\n\tnew_pte = pte_offset_map(new_pmd, new_addr);\n\tnew_ptl = pte_lockptr(mm, new_pmd);\n\tif (new_ptl != old_ptl)\n\t\tspin_lock_nested(new_ptl, SINGLE_DEPTH_NESTING);\n\tflush_tlb_batched_pending(vma->vm_mm);\n\tarch_enter_lazy_mmu_mode();\n\n\tfor (; old_addr < old_end; old_pte++, old_addr += PAGE_SIZE,\n\t\t\t\t   new_pte++, new_addr += PAGE_SIZE) {\n\t\tif (pte_none(*old_pte))\n\t\t\tcontinue;\n\n\t\tpte = ptep_get_and_clear(mm, old_addr, old_pte);\n\t\t/*\n\t\t * If we are remapping a valid PTE, make sure\n\t\t * to flush TLB before we drop the PTL for the\n\t\t * PTE.\n\t\t *\n\t\t * NOTE! Both old and new PTL matter: the old one\n\t\t * for racing with page_mkclean(), the new one to\n\t\t * make sure the physical page stays valid until\n\t\t * the TLB entry for the old mapping has been\n\t\t * flushed.\n\t\t */\n\t\tif (pte_present(pte))\n\t\t\tforce_flush = true;\n\t\tpte = move_pte(pte, new_vma->vm_page_prot, old_addr, new_addr);\n\t\tpte = move_soft_dirty_pte(pte);\n\t\tset_pte_at(mm, new_addr, new_pte, pte);\n\t}\n\n\tarch_leave_lazy_mmu_mode();\n\tif (force_flush)\n\t\tflush_tlb_range(vma, old_end - len, old_end);\n\tif (new_ptl != old_ptl)\n\t\tspin_unlock(new_ptl);\n\tpte_unmap(new_pte - 1);\n\tpte_unmap_unlock(old_pte - 1, old_ptl);\n\tif (need_rmap_locks)\n\t\tdrop_rmap_locks(vma);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/mm-arch-hooks.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swapops.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/ksm.h>",
      "#include <linux/shm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "drop_rmap_locks",
          "args": [
            "vma"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "drop_rmap_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mremap.c",
          "lines": "92-98",
          "snippet": "static void drop_rmap_locks(struct vm_area_struct *vma)\n{\n\tif (vma->anon_vma)\n\t\tanon_vma_unlock_write(vma->anon_vma);\n\tif (vma->vm_file)\n\t\ti_mmap_unlock_write(vma->vm_file->f_mapping);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/mm-arch-hooks.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swapops.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/ksm.h>",
            "#include <linux/shm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mm-arch-hooks.h>\n#include <linux/uaccess.h>\n#include <linux/mmu_notifier.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/swapops.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/ksm.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nstatic void drop_rmap_locks(struct vm_area_struct *vma)\n{\n\tif (vma->anon_vma)\n\t\tanon_vma_unlock_write(vma->anon_vma);\n\tif (vma->vm_file)\n\t\ti_mmap_unlock_write(vma->vm_file->f_mapping);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "old_pte - 1",
            "old_ptl"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unmap",
          "args": [
            "new_pte - 1"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "new_ptl"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_tlb_range",
          "args": [
            "vma",
            "old_end - len",
            "old_end"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_leave_lazy_mmu_mode",
          "args": [],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pte_at",
          "args": [
            "mm",
            "new_addr",
            "new_pte",
            "pte"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "move_soft_dirty_pte",
          "args": [
            "pte"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "move_soft_dirty_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mremap.c",
          "lines": "100-113",
          "snippet": "static pte_t move_soft_dirty_pte(pte_t pte)\n{\n\t/*\n\t * Set soft dirty bit so we can notice\n\t * in userspace the ptes were moved.\n\t */\n#ifdef CONFIG_MEM_SOFT_DIRTY\n\tif (pte_present(pte))\n\t\tpte = pte_mksoft_dirty(pte);\n\telse if (is_swap_pte(pte))\n\t\tpte = pte_swp_mksoft_dirty(pte);\n#endif\n\treturn pte;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/mm-arch-hooks.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swapops.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/ksm.h>",
            "#include <linux/shm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mm-arch-hooks.h>\n#include <linux/uaccess.h>\n#include <linux/mmu_notifier.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/swapops.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/ksm.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nstatic pte_t move_soft_dirty_pte(pte_t pte)\n{\n\t/*\n\t * Set soft dirty bit so we can notice\n\t * in userspace the ptes were moved.\n\t */\n#ifdef CONFIG_MEM_SOFT_DIRTY\n\tif (pte_present(pte))\n\t\tpte = pte_mksoft_dirty(pte);\n\telse if (is_swap_pte(pte))\n\t\tpte = pte_swp_mksoft_dirty(pte);\n#endif\n\treturn pte;\n}"
        }
      },
      {
        "call_info": {
          "callee": "move_pte",
          "args": [
            "pte",
            "new_vma->vm_page_prot",
            "old_addr",
            "new_addr"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "pte"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptep_get_and_clear",
          "args": [
            "mm",
            "old_addr",
            "old_pte"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_none",
          "args": [
            "*old_pte"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_enter_lazy_mmu_mode",
          "args": [],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_tlb_batched_pending",
          "args": [
            "vma->vm_mm"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "flush_tlb_batched_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "509-511",
          "snippet": "static inline void flush_tlb_batched_pending(struct mm_struct *mm)\n{\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void flush_tlb_batched_pending(struct mm_struct *mm)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_nested",
          "args": [
            "new_ptl",
            "SINGLE_DEPTH_NESTING"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_lockptr",
          "args": [
            "mm",
            "new_pmd"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_offset_map",
          "args": [
            "new_pmd",
            "new_addr"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_offset_map_lock",
          "args": [
            "mm",
            "old_pmd",
            "old_addr",
            "&old_ptl"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "take_rmap_locks",
          "args": [
            "vma"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "take_rmap_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mremap.c",
          "lines": "84-90",
          "snippet": "static void take_rmap_locks(struct vm_area_struct *vma)\n{\n\tif (vma->vm_file)\n\t\ti_mmap_lock_write(vma->vm_file->f_mapping);\n\tif (vma->anon_vma)\n\t\tanon_vma_lock_write(vma->anon_vma);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/mm-arch-hooks.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swapops.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/ksm.h>",
            "#include <linux/shm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mm-arch-hooks.h>\n#include <linux/uaccess.h>\n#include <linux/mmu_notifier.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/swapops.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/ksm.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nstatic void take_rmap_locks(struct vm_area_struct *vma)\n{\n\tif (vma->vm_file)\n\t\ti_mmap_lock_write(vma->vm_file->f_mapping);\n\tif (vma->anon_vma)\n\t\tanon_vma_lock_write(vma->anon_vma);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mm-arch-hooks.h>\n#include <linux/uaccess.h>\n#include <linux/mmu_notifier.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/swapops.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/ksm.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nstatic void move_ptes(struct vm_area_struct *vma, pmd_t *old_pmd,\n\t\tunsigned long old_addr, unsigned long old_end,\n\t\tstruct vm_area_struct *new_vma, pmd_t *new_pmd,\n\t\tunsigned long new_addr, bool need_rmap_locks)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpte_t *old_pte, *new_pte, pte;\n\tspinlock_t *old_ptl, *new_ptl;\n\tbool force_flush = false;\n\tunsigned long len = old_end - old_addr;\n\n\t/*\n\t * When need_rmap_locks is true, we take the i_mmap_rwsem and anon_vma\n\t * locks to ensure that rmap will always observe either the old or the\n\t * new ptes. This is the easiest way to avoid races with\n\t * truncate_pagecache(), page migration, etc...\n\t *\n\t * When need_rmap_locks is false, we use other ways to avoid\n\t * such races:\n\t *\n\t * - During exec() shift_arg_pages(), we use a specially tagged vma\n\t *   which rmap call sites look for using is_vma_temporary_stack().\n\t *\n\t * - During mremap(), new_vma is often known to be placed after vma\n\t *   in rmap traversal order. This ensures rmap will always observe\n\t *   either the old pte, or the new pte, or both (the page table locks\n\t *   serialize access to individual ptes, but only rmap traversal\n\t *   order guarantees that we won't miss both the old and new ptes).\n\t */\n\tif (need_rmap_locks)\n\t\ttake_rmap_locks(vma);\n\n\t/*\n\t * We don't have to worry about the ordering of src and dst\n\t * pte locks because exclusive mmap_sem prevents deadlock.\n\t */\n\told_pte = pte_offset_map_lock(mm, old_pmd, old_addr, &old_ptl);\n\tnew_pte = pte_offset_map(new_pmd, new_addr);\n\tnew_ptl = pte_lockptr(mm, new_pmd);\n\tif (new_ptl != old_ptl)\n\t\tspin_lock_nested(new_ptl, SINGLE_DEPTH_NESTING);\n\tflush_tlb_batched_pending(vma->vm_mm);\n\tarch_enter_lazy_mmu_mode();\n\n\tfor (; old_addr < old_end; old_pte++, old_addr += PAGE_SIZE,\n\t\t\t\t   new_pte++, new_addr += PAGE_SIZE) {\n\t\tif (pte_none(*old_pte))\n\t\t\tcontinue;\n\n\t\tpte = ptep_get_and_clear(mm, old_addr, old_pte);\n\t\t/*\n\t\t * If we are remapping a valid PTE, make sure\n\t\t * to flush TLB before we drop the PTL for the\n\t\t * PTE.\n\t\t *\n\t\t * NOTE! Both old and new PTL matter: the old one\n\t\t * for racing with page_mkclean(), the new one to\n\t\t * make sure the physical page stays valid until\n\t\t * the TLB entry for the old mapping has been\n\t\t * flushed.\n\t\t */\n\t\tif (pte_present(pte))\n\t\t\tforce_flush = true;\n\t\tpte = move_pte(pte, new_vma->vm_page_prot, old_addr, new_addr);\n\t\tpte = move_soft_dirty_pte(pte);\n\t\tset_pte_at(mm, new_addr, new_pte, pte);\n\t}\n\n\tarch_leave_lazy_mmu_mode();\n\tif (force_flush)\n\t\tflush_tlb_range(vma, old_end - len, old_end);\n\tif (new_ptl != old_ptl)\n\t\tspin_unlock(new_ptl);\n\tpte_unmap(new_pte - 1);\n\tpte_unmap_unlock(old_pte - 1, old_ptl);\n\tif (need_rmap_locks)\n\t\tdrop_rmap_locks(vma);\n}"
  },
  {
    "function_name": "move_soft_dirty_pte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mremap.c",
    "lines": "100-113",
    "snippet": "static pte_t move_soft_dirty_pte(pte_t pte)\n{\n\t/*\n\t * Set soft dirty bit so we can notice\n\t * in userspace the ptes were moved.\n\t */\n#ifdef CONFIG_MEM_SOFT_DIRTY\n\tif (pte_present(pte))\n\t\tpte = pte_mksoft_dirty(pte);\n\telse if (is_swap_pte(pte))\n\t\tpte = pte_swp_mksoft_dirty(pte);\n#endif\n\treturn pte;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/mm-arch-hooks.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swapops.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/ksm.h>",
      "#include <linux/shm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_swp_mksoft_dirty",
          "args": [
            "pte"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_swap_pte",
          "args": [
            "pte"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mksoft_dirty",
          "args": [
            "pte"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "pte"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mm-arch-hooks.h>\n#include <linux/uaccess.h>\n#include <linux/mmu_notifier.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/swapops.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/ksm.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nstatic pte_t move_soft_dirty_pte(pte_t pte)\n{\n\t/*\n\t * Set soft dirty bit so we can notice\n\t * in userspace the ptes were moved.\n\t */\n#ifdef CONFIG_MEM_SOFT_DIRTY\n\tif (pte_present(pte))\n\t\tpte = pte_mksoft_dirty(pte);\n\telse if (is_swap_pte(pte))\n\t\tpte = pte_swp_mksoft_dirty(pte);\n#endif\n\treturn pte;\n}"
  },
  {
    "function_name": "drop_rmap_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mremap.c",
    "lines": "92-98",
    "snippet": "static void drop_rmap_locks(struct vm_area_struct *vma)\n{\n\tif (vma->anon_vma)\n\t\tanon_vma_unlock_write(vma->anon_vma);\n\tif (vma->vm_file)\n\t\ti_mmap_unlock_write(vma->vm_file->f_mapping);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/mm-arch-hooks.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swapops.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/ksm.h>",
      "#include <linux/shm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i_mmap_unlock_write",
          "args": [
            "vma->vm_file->f_mapping"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_vma_unlock_write",
          "args": [
            "vma->anon_vma"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mm-arch-hooks.h>\n#include <linux/uaccess.h>\n#include <linux/mmu_notifier.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/swapops.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/ksm.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nstatic void drop_rmap_locks(struct vm_area_struct *vma)\n{\n\tif (vma->anon_vma)\n\t\tanon_vma_unlock_write(vma->anon_vma);\n\tif (vma->vm_file)\n\t\ti_mmap_unlock_write(vma->vm_file->f_mapping);\n}"
  },
  {
    "function_name": "take_rmap_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mremap.c",
    "lines": "84-90",
    "snippet": "static void take_rmap_locks(struct vm_area_struct *vma)\n{\n\tif (vma->vm_file)\n\t\ti_mmap_lock_write(vma->vm_file->f_mapping);\n\tif (vma->anon_vma)\n\t\tanon_vma_lock_write(vma->anon_vma);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/mm-arch-hooks.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swapops.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/ksm.h>",
      "#include <linux/shm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "anon_vma_lock_write",
          "args": [
            "vma->anon_vma"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_mmap_lock_write",
          "args": [
            "vma->vm_file->f_mapping"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mm-arch-hooks.h>\n#include <linux/uaccess.h>\n#include <linux/mmu_notifier.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/swapops.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/ksm.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nstatic void take_rmap_locks(struct vm_area_struct *vma)\n{\n\tif (vma->vm_file)\n\t\ti_mmap_lock_write(vma->vm_file->f_mapping);\n\tif (vma->anon_vma)\n\t\tanon_vma_lock_write(vma->anon_vma);\n}"
  },
  {
    "function_name": "alloc_new_pmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mremap.c",
    "lines": "59-82",
    "snippet": "static pmd_t *alloc_new_pmd(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t\t    unsigned long addr)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(mm, addr);\n\tp4d = p4d_alloc(mm, pgd, addr);\n\tif (!p4d)\n\t\treturn NULL;\n\tpud = pud_alloc(mm, p4d, addr);\n\tif (!pud)\n\t\treturn NULL;\n\n\tpmd = pmd_alloc(mm, pud, addr);\n\tif (!pmd)\n\t\treturn NULL;\n\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\n\treturn pmd;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/mm-arch-hooks.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swapops.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/ksm.h>",
      "#include <linux/shm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "pmd_trans_huge(*pmd)"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_huge",
          "args": [
            "*pmd"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_alloc",
          "args": [
            "mm",
            "pud",
            "addr"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "__pmd_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "4004-4029",
          "snippet": "int __pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)\n{\n\tspinlock_t *ptl;\n\tpmd_t *new = pmd_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tptl = pud_lock(mm, pud);\n#ifndef __ARCH_HAS_4LEVEL_HACK\n\tif (!pud_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpud_populate(mm, pud, new);\n\t} else\t/* Another has populated it */\n\t\tpmd_free(mm, new);\n#else\n\tif (!pgd_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpgd_populate(mm, pud, new);\n\t} else /* Another has populated it */\n\t\tpmd_free(mm, new);\n#endif /* __ARCH_HAS_4LEVEL_HACK */\n\tspin_unlock(ptl);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)\n{\n\tspinlock_t *ptl;\n\tpmd_t *new = pmd_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tptl = pud_lock(mm, pud);\n#ifndef __ARCH_HAS_4LEVEL_HACK\n\tif (!pud_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpud_populate(mm, pud, new);\n\t} else\t/* Another has populated it */\n\t\tpmd_free(mm, new);\n#else\n\tif (!pgd_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpgd_populate(mm, pud, new);\n\t} else /* Another has populated it */\n\t\tpmd_free(mm, new);\n#endif /* __ARCH_HAS_4LEVEL_HACK */\n\tspin_unlock(ptl);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pud_alloc",
          "args": [
            "mm",
            "p4d",
            "addr"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "__pud_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3972-3996",
          "snippet": "int __pud_alloc(struct mm_struct *mm, p4d_t *p4d, unsigned long address)\n{\n\tpud_t *new = pud_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n#ifndef __ARCH_HAS_5LEVEL_HACK\n\tif (!p4d_present(*p4d)) {\n\t\tmm_inc_nr_puds(mm);\n\t\tp4d_populate(mm, p4d, new);\n\t} else\t/* Another has populated it */\n\t\tpud_free(mm, new);\n#else\n\tif (!pgd_present(*p4d)) {\n\t\tmm_inc_nr_puds(mm);\n\t\tpgd_populate(mm, p4d, new);\n\t} else\t/* Another has populated it */\n\t\tpud_free(mm, new);\n#endif /* __ARCH_HAS_5LEVEL_HACK */\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __pud_alloc(struct mm_struct *mm, p4d_t *p4d, unsigned long address)\n{\n\tpud_t *new = pud_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n#ifndef __ARCH_HAS_5LEVEL_HACK\n\tif (!p4d_present(*p4d)) {\n\t\tmm_inc_nr_puds(mm);\n\t\tp4d_populate(mm, p4d, new);\n\t} else\t/* Another has populated it */\n\t\tpud_free(mm, new);\n#else\n\tif (!pgd_present(*p4d)) {\n\t\tmm_inc_nr_puds(mm);\n\t\tpgd_populate(mm, p4d, new);\n\t} else\t/* Another has populated it */\n\t\tpud_free(mm, new);\n#endif /* __ARCH_HAS_5LEVEL_HACK */\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p4d_alloc",
          "args": [
            "mm",
            "pgd",
            "addr"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "__p4d_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3949-3964",
          "snippet": "int __p4d_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address)\n{\n\tp4d_t *new = p4d_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n\tif (pgd_present(*pgd))\t\t/* Another has populated it */\n\t\tp4d_free(mm, new);\n\telse\n\t\tpgd_populate(mm, pgd, new);\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __p4d_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address)\n{\n\tp4d_t *new = p4d_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n\tif (pgd_present(*pgd))\t\t/* Another has populated it */\n\t\tp4d_free(mm, new);\n\telse\n\t\tpgd_populate(mm, pgd, new);\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgd_offset",
          "args": [
            "mm",
            "addr"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mm-arch-hooks.h>\n#include <linux/uaccess.h>\n#include <linux/mmu_notifier.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/swapops.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/ksm.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nstatic pmd_t *alloc_new_pmd(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t\t    unsigned long addr)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(mm, addr);\n\tp4d = p4d_alloc(mm, pgd, addr);\n\tif (!p4d)\n\t\treturn NULL;\n\tpud = pud_alloc(mm, p4d, addr);\n\tif (!pud)\n\t\treturn NULL;\n\n\tpmd = pmd_alloc(mm, pud, addr);\n\tif (!pmd)\n\t\treturn NULL;\n\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\n\treturn pmd;\n}"
  },
  {
    "function_name": "get_old_pmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mremap.c",
    "lines": "33-57",
    "snippet": "static pmd_t *get_old_pmd(struct mm_struct *mm, unsigned long addr)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(mm, addr);\n\tif (pgd_none_or_clear_bad(pgd))\n\t\treturn NULL;\n\n\tp4d = p4d_offset(pgd, addr);\n\tif (p4d_none_or_clear_bad(p4d))\n\t\treturn NULL;\n\n\tpud = pud_offset(p4d, addr);\n\tif (pud_none_or_clear_bad(pud))\n\t\treturn NULL;\n\n\tpmd = pmd_offset(pud, addr);\n\tif (pmd_none(*pmd))\n\t\treturn NULL;\n\n\treturn pmd;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/mm-arch-hooks.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swapops.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/ksm.h>",
      "#include <linux/shm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pmd_none",
          "args": [
            "*pmd"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_offset",
          "args": [
            "pud",
            "addr"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_none_or_clear_bad",
          "args": [
            "pud"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_offset",
          "args": [
            "p4d",
            "addr"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_none_or_clear_bad",
          "args": [
            "p4d"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_offset",
          "args": [
            "pgd",
            "addr"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_none_or_clear_bad",
          "args": [
            "pgd"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_offset",
          "args": [
            "mm",
            "addr"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mm-arch-hooks.h>\n#include <linux/uaccess.h>\n#include <linux/mmu_notifier.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/swapops.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/ksm.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nstatic pmd_t *get_old_pmd(struct mm_struct *mm, unsigned long addr)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(mm, addr);\n\tif (pgd_none_or_clear_bad(pgd))\n\t\treturn NULL;\n\n\tp4d = p4d_offset(pgd, addr);\n\tif (p4d_none_or_clear_bad(p4d))\n\t\treturn NULL;\n\n\tpud = pud_offset(p4d, addr);\n\tif (pud_none_or_clear_bad(pud))\n\t\treturn NULL;\n\n\tpmd = pmd_offset(pud, addr);\n\tif (pmd_none(*pmd))\n\t\treturn NULL;\n\n\treturn pmd;\n}"
  },
  {
    "function_name": "mremap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mremap.c",
    "lines": "515-649",
    "snippet": "SYSCALL_DEFINE5(mremap, unsigned long, addr, unsigned long, old_len,\n\t\tunsigned long, new_len, unsigned long, flags,\n\t\tunsigned long, new_addr)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma;\n\tunsigned long ret = -EINVAL;\n\tunsigned long charged = 0;\n\tbool locked = false;\n\tbool downgraded = false;\n\tstruct vm_userfaultfd_ctx uf = NULL_VM_UFFD_CTX;\n\tLIST_HEAD(uf_unmap_early);\n\tLIST_HEAD(uf_unmap);\n\n\tif (flags & ~(MREMAP_FIXED | MREMAP_MAYMOVE))\n\t\treturn ret;\n\n\tif (flags & MREMAP_FIXED && !(flags & MREMAP_MAYMOVE))\n\t\treturn ret;\n\n\tif (offset_in_page(addr))\n\t\treturn ret;\n\n\told_len = PAGE_ALIGN(old_len);\n\tnew_len = PAGE_ALIGN(new_len);\n\n\t/*\n\t * We allow a zero old-len as a special case\n\t * for DOS-emu \"duplicate shm area\" thing. But\n\t * a zero new-len is nonsensical.\n\t */\n\tif (!new_len)\n\t\treturn ret;\n\n\tif (down_write_killable(&current->mm->mmap_sem))\n\t\treturn -EINTR;\n\n\tif (flags & MREMAP_FIXED) {\n\t\tret = mremap_to(addr, old_len, new_addr, new_len,\n\t\t\t\t&locked, &uf, &uf_unmap_early, &uf_unmap);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Always allow a shrinking remap: that just unmaps\n\t * the unnecessary pages..\n\t * __do_munmap does all the needed commit accounting, and\n\t * downgrades mmap_sem to read if so directed.\n\t */\n\tif (old_len >= new_len) {\n\t\tint retval;\n\n\t\tretval = __do_munmap(mm, addr+new_len, old_len - new_len,\n\t\t\t\t  &uf_unmap, true);\n\t\tif (retval < 0 && old_len != new_len) {\n\t\t\tret = retval;\n\t\t\tgoto out;\n\t\t/* Returning 1 indicates mmap_sem is downgraded to read. */\n\t\t} else if (retval == 1)\n\t\t\tdowngraded = true;\n\t\tret = addr;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Ok, we need to grow..\n\t */\n\tvma = vma_to_resize(addr, old_len, new_len, &charged);\n\tif (IS_ERR(vma)) {\n\t\tret = PTR_ERR(vma);\n\t\tgoto out;\n\t}\n\n\t/* old_len exactly to the end of the area..\n\t */\n\tif (old_len == vma->vm_end - addr) {\n\t\t/* can we just expand the current mapping? */\n\t\tif (vma_expandable(vma, new_len - old_len)) {\n\t\t\tint pages = (new_len - old_len) >> PAGE_SHIFT;\n\n\t\t\tif (vma_adjust(vma, vma->vm_start, addr + new_len,\n\t\t\t\t       vma->vm_pgoff, NULL)) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvm_stat_account(mm, vma->vm_flags, pages);\n\t\t\tif (vma->vm_flags & VM_LOCKED) {\n\t\t\t\tmm->locked_vm += pages;\n\t\t\t\tlocked = true;\n\t\t\t\tnew_addr = addr;\n\t\t\t}\n\t\t\tret = addr;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * We weren't able to just expand or shrink the area,\n\t * we need to create a new one and move it..\n\t */\n\tret = -ENOMEM;\n\tif (flags & MREMAP_MAYMOVE) {\n\t\tunsigned long map_flags = 0;\n\t\tif (vma->vm_flags & VM_MAYSHARE)\n\t\t\tmap_flags |= MAP_SHARED;\n\n\t\tnew_addr = get_unmapped_area(vma->vm_file, 0, new_len,\n\t\t\t\t\tvma->vm_pgoff +\n\t\t\t\t\t((addr - vma->vm_start) >> PAGE_SHIFT),\n\t\t\t\t\tmap_flags);\n\t\tif (offset_in_page(new_addr)) {\n\t\t\tret = new_addr;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = move_vma(vma, addr, old_len, new_len, new_addr,\n\t\t\t       &locked, &uf, &uf_unmap);\n\t}\nout:\n\tif (offset_in_page(ret)) {\n\t\tvm_unacct_memory(charged);\n\t\tlocked = 0;\n\t}\n\tif (downgraded)\n\t\tup_read(&current->mm->mmap_sem);\n\telse\n\t\tup_write(&current->mm->mmap_sem);\n\tif (locked && new_len > old_len)\n\t\tmm_populate(new_addr + old_len, new_len - old_len);\n\tuserfaultfd_unmap_complete(mm, &uf_unmap_early);\n\tmremap_userfaultfd_complete(&uf, addr, new_addr, old_len);\n\tuserfaultfd_unmap_complete(mm, &uf_unmap);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/mm-arch-hooks.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/highmem.h>",
      "#include <linux/swapops.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/swap.h>",
      "#include <linux/mman.h>",
      "#include <linux/ksm.h>",
      "#include <linux/shm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mm-arch-hooks.h>\n#include <linux/uaccess.h>\n#include <linux/mmu_notifier.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/swapops.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/ksm.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE5(mremap, unsigned long, addr, unsigned long, old_len,\n\t\tunsigned long, new_len, unsigned long, flags,\n\t\tunsigned long, new_addr)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma;\n\tunsigned long ret = -EINVAL;\n\tunsigned long charged = 0;\n\tbool locked = false;\n\tbool downgraded = false;\n\tstruct vm_userfaultfd_ctx uf = NULL_VM_UFFD_CTX;\n\tLIST_HEAD(uf_unmap_early);\n\tLIST_HEAD(uf_unmap);\n\n\tif (flags & ~(MREMAP_FIXED | MREMAP_MAYMOVE))\n\t\treturn ret;\n\n\tif (flags & MREMAP_FIXED && !(flags & MREMAP_MAYMOVE))\n\t\treturn ret;\n\n\tif (offset_in_page(addr))\n\t\treturn ret;\n\n\told_len = PAGE_ALIGN(old_len);\n\tnew_len = PAGE_ALIGN(new_len);\n\n\t/*\n\t * We allow a zero old-len as a special case\n\t * for DOS-emu \"duplicate shm area\" thing. But\n\t * a zero new-len is nonsensical.\n\t */\n\tif (!new_len)\n\t\treturn ret;\n\n\tif (down_write_killable(&current->mm->mmap_sem))\n\t\treturn -EINTR;\n\n\tif (flags & MREMAP_FIXED) {\n\t\tret = mremap_to(addr, old_len, new_addr, new_len,\n\t\t\t\t&locked, &uf, &uf_unmap_early, &uf_unmap);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Always allow a shrinking remap: that just unmaps\n\t * the unnecessary pages..\n\t * __do_munmap does all the needed commit accounting, and\n\t * downgrades mmap_sem to read if so directed.\n\t */\n\tif (old_len >= new_len) {\n\t\tint retval;\n\n\t\tretval = __do_munmap(mm, addr+new_len, old_len - new_len,\n\t\t\t\t  &uf_unmap, true);\n\t\tif (retval < 0 && old_len != new_len) {\n\t\t\tret = retval;\n\t\t\tgoto out;\n\t\t/* Returning 1 indicates mmap_sem is downgraded to read. */\n\t\t} else if (retval == 1)\n\t\t\tdowngraded = true;\n\t\tret = addr;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Ok, we need to grow..\n\t */\n\tvma = vma_to_resize(addr, old_len, new_len, &charged);\n\tif (IS_ERR(vma)) {\n\t\tret = PTR_ERR(vma);\n\t\tgoto out;\n\t}\n\n\t/* old_len exactly to the end of the area..\n\t */\n\tif (old_len == vma->vm_end - addr) {\n\t\t/* can we just expand the current mapping? */\n\t\tif (vma_expandable(vma, new_len - old_len)) {\n\t\t\tint pages = (new_len - old_len) >> PAGE_SHIFT;\n\n\t\t\tif (vma_adjust(vma, vma->vm_start, addr + new_len,\n\t\t\t\t       vma->vm_pgoff, NULL)) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tvm_stat_account(mm, vma->vm_flags, pages);\n\t\t\tif (vma->vm_flags & VM_LOCKED) {\n\t\t\t\tmm->locked_vm += pages;\n\t\t\t\tlocked = true;\n\t\t\t\tnew_addr = addr;\n\t\t\t}\n\t\t\tret = addr;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * We weren't able to just expand or shrink the area,\n\t * we need to create a new one and move it..\n\t */\n\tret = -ENOMEM;\n\tif (flags & MREMAP_MAYMOVE) {\n\t\tunsigned long map_flags = 0;\n\t\tif (vma->vm_flags & VM_MAYSHARE)\n\t\t\tmap_flags |= MAP_SHARED;\n\n\t\tnew_addr = get_unmapped_area(vma->vm_file, 0, new_len,\n\t\t\t\t\tvma->vm_pgoff +\n\t\t\t\t\t((addr - vma->vm_start) >> PAGE_SHIFT),\n\t\t\t\t\tmap_flags);\n\t\tif (offset_in_page(new_addr)) {\n\t\t\tret = new_addr;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = move_vma(vma, addr, old_len, new_len, new_addr,\n\t\t\t       &locked, &uf, &uf_unmap);\n\t}\nout:\n\tif (offset_in_page(ret)) {\n\t\tvm_unacct_memory(charged);\n\t\tlocked = 0;\n\t}\n\tif (downgraded)\n\t\tup_read(&current->mm->mmap_sem);\n\telse\n\t\tup_write(&current->mm->mmap_sem);\n\tif (locked && new_len > old_len)\n\t\tmm_populate(new_addr + old_len, new_len - old_len);\n\tuserfaultfd_unmap_complete(mm, &uf_unmap_early);\n\tmremap_userfaultfd_complete(&uf, addr, new_addr, old_len);\n\tuserfaultfd_unmap_complete(mm, &uf_unmap);\n\treturn ret;\n}"
  }
]