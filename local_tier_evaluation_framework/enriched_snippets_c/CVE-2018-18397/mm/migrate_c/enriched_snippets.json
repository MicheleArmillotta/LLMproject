[
  {
    "function_name": "migrate_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "2880-2946",
    "snippet": "int migrate_vma(const struct migrate_vma_ops *ops,\n\t\tstruct vm_area_struct *vma,\n\t\tunsigned long start,\n\t\tunsigned long end,\n\t\tunsigned long *src,\n\t\tunsigned long *dst,\n\t\tvoid *private)\n{\n\tstruct migrate_vma migrate;\n\n\t/* Sanity check the arguments */\n\tstart &= PAGE_MASK;\n\tend &= PAGE_MASK;\n\tif (!vma || is_vm_hugetlb_page(vma) || (vma->vm_flags & VM_SPECIAL) ||\n\t\t\tvma_is_dax(vma))\n\t\treturn -EINVAL;\n\tif (start < vma->vm_start || start >= vma->vm_end)\n\t\treturn -EINVAL;\n\tif (end <= vma->vm_start || end > vma->vm_end)\n\t\treturn -EINVAL;\n\tif (!ops || !src || !dst || start >= end)\n\t\treturn -EINVAL;\n\n\tmemset(src, 0, sizeof(*src) * ((end - start) >> PAGE_SHIFT));\n\tmigrate.src = src;\n\tmigrate.dst = dst;\n\tmigrate.start = start;\n\tmigrate.npages = 0;\n\tmigrate.cpages = 0;\n\tmigrate.end = end;\n\tmigrate.vma = vma;\n\n\t/* Collect, and try to unmap source pages */\n\tmigrate_vma_collect(&migrate);\n\tif (!migrate.cpages)\n\t\treturn 0;\n\n\t/* Lock and isolate page */\n\tmigrate_vma_prepare(&migrate);\n\tif (!migrate.cpages)\n\t\treturn 0;\n\n\t/* Unmap pages */\n\tmigrate_vma_unmap(&migrate);\n\tif (!migrate.cpages)\n\t\treturn 0;\n\n\t/*\n\t * At this point pages are locked and unmapped, and thus they have\n\t * stable content and can safely be copied to destination memory that\n\t * is allocated by the callback.\n\t *\n\t * Note that migration can fail in migrate_vma_struct_page() for each\n\t * individual page.\n\t */\n\tops->alloc_and_copy(vma, src, dst, start, end, private);\n\n\t/* This does the real migration of struct page */\n\tmigrate_vma_pages(&migrate);\n\n\tops->finalize_and_map(vma, src, dst, start, end, private);\n\n\t/* Unlock and remap pages */\n\tmigrate_vma_finalize(&migrate);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "migrate_vma_finalize",
          "args": [
            "&migrate"
          ],
          "line": 2943
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_vma_finalize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "2785-2827",
          "snippet": "static void migrate_vma_finalize(struct migrate_vma *migrate)\n{\n\tconst unsigned long npages = migrate->npages;\n\tunsigned long i;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tstruct page *newpage = migrate_pfn_to_page(migrate->dst[i]);\n\t\tstruct page *page = migrate_pfn_to_page(migrate->src[i]);\n\n\t\tif (!page) {\n\t\t\tif (newpage) {\n\t\t\t\tunlock_page(newpage);\n\t\t\t\tput_page(newpage);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(migrate->src[i] & MIGRATE_PFN_MIGRATE) || !newpage) {\n\t\t\tif (newpage) {\n\t\t\t\tunlock_page(newpage);\n\t\t\t\tput_page(newpage);\n\t\t\t}\n\t\t\tnewpage = page;\n\t\t}\n\n\t\tremove_migration_ptes(page, newpage, false);\n\t\tunlock_page(page);\n\t\tmigrate->cpages--;\n\n\t\tif (is_zone_device_page(page))\n\t\t\tput_page(page);\n\t\telse\n\t\t\tputback_lru_page(page);\n\n\t\tif (newpage != page) {\n\t\t\tunlock_page(newpage);\n\t\t\tif (is_zone_device_page(newpage))\n\t\t\t\tput_page(newpage);\n\t\t\telse\n\t\t\t\tputback_lru_page(newpage);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic void migrate_vma_finalize(struct migrate_vma *migrate)\n{\n\tconst unsigned long npages = migrate->npages;\n\tunsigned long i;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tstruct page *newpage = migrate_pfn_to_page(migrate->dst[i]);\n\t\tstruct page *page = migrate_pfn_to_page(migrate->src[i]);\n\n\t\tif (!page) {\n\t\t\tif (newpage) {\n\t\t\t\tunlock_page(newpage);\n\t\t\t\tput_page(newpage);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(migrate->src[i] & MIGRATE_PFN_MIGRATE) || !newpage) {\n\t\t\tif (newpage) {\n\t\t\t\tunlock_page(newpage);\n\t\t\t\tput_page(newpage);\n\t\t\t}\n\t\t\tnewpage = page;\n\t\t}\n\n\t\tremove_migration_ptes(page, newpage, false);\n\t\tunlock_page(page);\n\t\tmigrate->cpages--;\n\n\t\tif (is_zone_device_page(page))\n\t\t\tput_page(page);\n\t\telse\n\t\t\tputback_lru_page(page);\n\n\t\tif (newpage != page) {\n\t\t\tunlock_page(newpage);\n\t\t\tif (is_zone_device_page(newpage))\n\t\t\t\tput_page(newpage);\n\t\t\telse\n\t\t\t\tputback_lru_page(newpage);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->finalize_and_map",
          "args": [
            "vma",
            "src",
            "dst",
            "start",
            "end",
            "private"
          ],
          "line": 2940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_vma_pages",
          "args": [
            "&migrate"
          ],
          "line": 2938
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_vma_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "2700-2772",
          "snippet": "static void migrate_vma_pages(struct migrate_vma *migrate)\n{\n\tconst unsigned long npages = migrate->npages;\n\tconst unsigned long start = migrate->start;\n\tstruct vm_area_struct *vma = migrate->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long addr, i, mmu_start;\n\tbool notified = false;\n\n\tfor (i = 0, addr = start; i < npages; addr += PAGE_SIZE, i++) {\n\t\tstruct page *newpage = migrate_pfn_to_page(migrate->dst[i]);\n\t\tstruct page *page = migrate_pfn_to_page(migrate->src[i]);\n\t\tstruct address_space *mapping;\n\t\tint r;\n\n\t\tif (!newpage) {\n\t\t\tmigrate->src[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!page) {\n\t\t\tif (!(migrate->src[i] & MIGRATE_PFN_MIGRATE)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!notified) {\n\t\t\t\tmmu_start = addr;\n\t\t\t\tnotified = true;\n\t\t\t\tmmu_notifier_invalidate_range_start(mm,\n\t\t\t\t\t\t\t\tmmu_start,\n\t\t\t\t\t\t\t\tmigrate->end);\n\t\t\t}\n\t\t\tmigrate_vma_insert_page(migrate, addr, newpage,\n\t\t\t\t\t\t&migrate->src[i],\n\t\t\t\t\t\t&migrate->dst[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmapping = page_mapping(page);\n\n\t\tif (is_zone_device_page(newpage)) {\n\t\t\tif (is_device_private_page(newpage)) {\n\t\t\t\t/*\n\t\t\t\t * For now only support private anonymous when\n\t\t\t\t * migrating to un-addressable device memory.\n\t\t\t\t */\n\t\t\t\tif (mapping) {\n\t\t\t\t\tmigrate->src[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (!is_device_public_page(newpage)) {\n\t\t\t\t/*\n\t\t\t\t * Other types of ZONE_DEVICE page are not\n\t\t\t\t * supported.\n\t\t\t\t */\n\t\t\t\tmigrate->src[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tr = migrate_page(mapping, newpage, page, MIGRATE_SYNC_NO_COPY);\n\t\tif (r != MIGRATEPAGE_SUCCESS)\n\t\t\tmigrate->src[i] &= ~MIGRATE_PFN_MIGRATE;\n\t}\n\n\t/*\n\t * No need to double call mmu_notifier->invalidate_range() callback as\n\t * the above ptep_clear_flush_notify() inside migrate_vma_insert_page()\n\t * did already call it.\n\t */\n\tif (notified)\n\t\tmmu_notifier_invalidate_range_only_end(mm, mmu_start,\n\t\t\t\t\t\t       migrate->end);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic void migrate_vma_pages(struct migrate_vma *migrate)\n{\n\tconst unsigned long npages = migrate->npages;\n\tconst unsigned long start = migrate->start;\n\tstruct vm_area_struct *vma = migrate->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long addr, i, mmu_start;\n\tbool notified = false;\n\n\tfor (i = 0, addr = start; i < npages; addr += PAGE_SIZE, i++) {\n\t\tstruct page *newpage = migrate_pfn_to_page(migrate->dst[i]);\n\t\tstruct page *page = migrate_pfn_to_page(migrate->src[i]);\n\t\tstruct address_space *mapping;\n\t\tint r;\n\n\t\tif (!newpage) {\n\t\t\tmigrate->src[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!page) {\n\t\t\tif (!(migrate->src[i] & MIGRATE_PFN_MIGRATE)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!notified) {\n\t\t\t\tmmu_start = addr;\n\t\t\t\tnotified = true;\n\t\t\t\tmmu_notifier_invalidate_range_start(mm,\n\t\t\t\t\t\t\t\tmmu_start,\n\t\t\t\t\t\t\t\tmigrate->end);\n\t\t\t}\n\t\t\tmigrate_vma_insert_page(migrate, addr, newpage,\n\t\t\t\t\t\t&migrate->src[i],\n\t\t\t\t\t\t&migrate->dst[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmapping = page_mapping(page);\n\n\t\tif (is_zone_device_page(newpage)) {\n\t\t\tif (is_device_private_page(newpage)) {\n\t\t\t\t/*\n\t\t\t\t * For now only support private anonymous when\n\t\t\t\t * migrating to un-addressable device memory.\n\t\t\t\t */\n\t\t\t\tif (mapping) {\n\t\t\t\t\tmigrate->src[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (!is_device_public_page(newpage)) {\n\t\t\t\t/*\n\t\t\t\t * Other types of ZONE_DEVICE page are not\n\t\t\t\t * supported.\n\t\t\t\t */\n\t\t\t\tmigrate->src[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tr = migrate_page(mapping, newpage, page, MIGRATE_SYNC_NO_COPY);\n\t\tif (r != MIGRATEPAGE_SUCCESS)\n\t\t\tmigrate->src[i] &= ~MIGRATE_PFN_MIGRATE;\n\t}\n\n\t/*\n\t * No need to double call mmu_notifier->invalidate_range() callback as\n\t * the above ptep_clear_flush_notify() inside migrate_vma_insert_page()\n\t * did already call it.\n\t */\n\tif (notified)\n\t\tmmu_notifier_invalidate_range_only_end(mm, mmu_start,\n\t\t\t\t\t\t       migrate->end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->alloc_and_copy",
          "args": [
            "vma",
            "src",
            "dst",
            "start",
            "end",
            "private"
          ],
          "line": 2935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_vma_unmap",
          "args": [
            "&migrate"
          ],
          "line": 2923
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_vma_unmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "2509-2554",
          "snippet": "static void migrate_vma_unmap(struct migrate_vma *migrate)\n{\n\tint flags = TTU_MIGRATION | TTU_IGNORE_MLOCK | TTU_IGNORE_ACCESS;\n\tconst unsigned long npages = migrate->npages;\n\tconst unsigned long start = migrate->start;\n\tunsigned long addr, i, restore = 0;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tstruct page *page = migrate_pfn_to_page(migrate->src[i]);\n\n\t\tif (!page || !(migrate->src[i] & MIGRATE_PFN_MIGRATE))\n\t\t\tcontinue;\n\n\t\tif (page_mapped(page)) {\n\t\t\ttry_to_unmap(page, flags);\n\t\t\tif (page_mapped(page))\n\t\t\t\tgoto restore;\n\t\t}\n\n\t\tif (migrate_vma_check_page(page))\n\t\t\tcontinue;\n\nrestore:\n\t\tmigrate->src[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\tmigrate->cpages--;\n\t\trestore++;\n\t}\n\n\tfor (addr = start, i = 0; i < npages && restore; addr += PAGE_SIZE, i++) {\n\t\tstruct page *page = migrate_pfn_to_page(migrate->src[i]);\n\n\t\tif (!page || (migrate->src[i] & MIGRATE_PFN_MIGRATE))\n\t\t\tcontinue;\n\n\t\tremove_migration_ptes(page, page, false);\n\n\t\tmigrate->src[i] = 0;\n\t\tunlock_page(page);\n\t\trestore--;\n\n\t\tif (is_zone_device_page(page))\n\t\t\tput_page(page);\n\t\telse\n\t\t\tputback_lru_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic void migrate_vma_unmap(struct migrate_vma *migrate)\n{\n\tint flags = TTU_MIGRATION | TTU_IGNORE_MLOCK | TTU_IGNORE_ACCESS;\n\tconst unsigned long npages = migrate->npages;\n\tconst unsigned long start = migrate->start;\n\tunsigned long addr, i, restore = 0;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tstruct page *page = migrate_pfn_to_page(migrate->src[i]);\n\n\t\tif (!page || !(migrate->src[i] & MIGRATE_PFN_MIGRATE))\n\t\t\tcontinue;\n\n\t\tif (page_mapped(page)) {\n\t\t\ttry_to_unmap(page, flags);\n\t\t\tif (page_mapped(page))\n\t\t\t\tgoto restore;\n\t\t}\n\n\t\tif (migrate_vma_check_page(page))\n\t\t\tcontinue;\n\nrestore:\n\t\tmigrate->src[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\tmigrate->cpages--;\n\t\trestore++;\n\t}\n\n\tfor (addr = start, i = 0; i < npages && restore; addr += PAGE_SIZE, i++) {\n\t\tstruct page *page = migrate_pfn_to_page(migrate->src[i]);\n\n\t\tif (!page || (migrate->src[i] & MIGRATE_PFN_MIGRATE))\n\t\t\tcontinue;\n\n\t\tremove_migration_ptes(page, page, false);\n\n\t\tmigrate->src[i] = 0;\n\t\tunlock_page(page);\n\t\trestore--;\n\n\t\tif (is_zone_device_page(page))\n\t\t\tput_page(page);\n\t\telse\n\t\t\tputback_lru_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "migrate_vma_prepare",
          "args": [
            "&migrate"
          ],
          "line": 2918
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_vma_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "2399-2496",
          "snippet": "static void migrate_vma_prepare(struct migrate_vma *migrate)\n{\n\tconst unsigned long npages = migrate->npages;\n\tconst unsigned long start = migrate->start;\n\tunsigned long addr, i, restore = 0;\n\tbool allow_drain = true;\n\n\tlru_add_drain();\n\n\tfor (i = 0; (i < npages) && migrate->cpages; i++) {\n\t\tstruct page *page = migrate_pfn_to_page(migrate->src[i]);\n\t\tbool remap = true;\n\n\t\tif (!page)\n\t\t\tcontinue;\n\n\t\tif (!(migrate->src[i] & MIGRATE_PFN_LOCKED)) {\n\t\t\t/*\n\t\t\t * Because we are migrating several pages there can be\n\t\t\t * a deadlock between 2 concurrent migration where each\n\t\t\t * are waiting on each other page lock.\n\t\t\t *\n\t\t\t * Make migrate_vma() a best effort thing and backoff\n\t\t\t * for any page we can not lock right away.\n\t\t\t */\n\t\t\tif (!trylock_page(page)) {\n\t\t\t\tmigrate->src[i] = 0;\n\t\t\t\tmigrate->cpages--;\n\t\t\t\tput_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tremap = false;\n\t\t\tmigrate->src[i] |= MIGRATE_PFN_LOCKED;\n\t\t}\n\n\t\t/* ZONE_DEVICE pages are not on LRU */\n\t\tif (!is_zone_device_page(page)) {\n\t\t\tif (!PageLRU(page) && allow_drain) {\n\t\t\t\t/* Drain CPU's pagevec */\n\t\t\t\tlru_add_drain_all();\n\t\t\t\tallow_drain = false;\n\t\t\t}\n\n\t\t\tif (isolate_lru_page(page)) {\n\t\t\t\tif (remap) {\n\t\t\t\t\tmigrate->src[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t\t\t\tmigrate->cpages--;\n\t\t\t\t\trestore++;\n\t\t\t\t} else {\n\t\t\t\t\tmigrate->src[i] = 0;\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tmigrate->cpages--;\n\t\t\t\t\tput_page(page);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Drop the reference we took in collect */\n\t\t\tput_page(page);\n\t\t}\n\n\t\tif (!migrate_vma_check_page(page)) {\n\t\t\tif (remap) {\n\t\t\t\tmigrate->src[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t\t\tmigrate->cpages--;\n\t\t\t\trestore++;\n\n\t\t\t\tif (!is_zone_device_page(page)) {\n\t\t\t\t\tget_page(page);\n\t\t\t\t\tputback_lru_page(page);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmigrate->src[i] = 0;\n\t\t\t\tunlock_page(page);\n\t\t\t\tmigrate->cpages--;\n\n\t\t\t\tif (!is_zone_device_page(page))\n\t\t\t\t\tputback_lru_page(page);\n\t\t\t\telse\n\t\t\t\t\tput_page(page);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0, addr = start; i < npages && restore; i++, addr += PAGE_SIZE) {\n\t\tstruct page *page = migrate_pfn_to_page(migrate->src[i]);\n\n\t\tif (!page || (migrate->src[i] & MIGRATE_PFN_MIGRATE))\n\t\t\tcontinue;\n\n\t\tremove_migration_pte(page, migrate->vma, addr, page);\n\n\t\tmigrate->src[i] = 0;\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\trestore--;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic void migrate_vma_prepare(struct migrate_vma *migrate)\n{\n\tconst unsigned long npages = migrate->npages;\n\tconst unsigned long start = migrate->start;\n\tunsigned long addr, i, restore = 0;\n\tbool allow_drain = true;\n\n\tlru_add_drain();\n\n\tfor (i = 0; (i < npages) && migrate->cpages; i++) {\n\t\tstruct page *page = migrate_pfn_to_page(migrate->src[i]);\n\t\tbool remap = true;\n\n\t\tif (!page)\n\t\t\tcontinue;\n\n\t\tif (!(migrate->src[i] & MIGRATE_PFN_LOCKED)) {\n\t\t\t/*\n\t\t\t * Because we are migrating several pages there can be\n\t\t\t * a deadlock between 2 concurrent migration where each\n\t\t\t * are waiting on each other page lock.\n\t\t\t *\n\t\t\t * Make migrate_vma() a best effort thing and backoff\n\t\t\t * for any page we can not lock right away.\n\t\t\t */\n\t\t\tif (!trylock_page(page)) {\n\t\t\t\tmigrate->src[i] = 0;\n\t\t\t\tmigrate->cpages--;\n\t\t\t\tput_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tremap = false;\n\t\t\tmigrate->src[i] |= MIGRATE_PFN_LOCKED;\n\t\t}\n\n\t\t/* ZONE_DEVICE pages are not on LRU */\n\t\tif (!is_zone_device_page(page)) {\n\t\t\tif (!PageLRU(page) && allow_drain) {\n\t\t\t\t/* Drain CPU's pagevec */\n\t\t\t\tlru_add_drain_all();\n\t\t\t\tallow_drain = false;\n\t\t\t}\n\n\t\t\tif (isolate_lru_page(page)) {\n\t\t\t\tif (remap) {\n\t\t\t\t\tmigrate->src[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t\t\t\tmigrate->cpages--;\n\t\t\t\t\trestore++;\n\t\t\t\t} else {\n\t\t\t\t\tmigrate->src[i] = 0;\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tmigrate->cpages--;\n\t\t\t\t\tput_page(page);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Drop the reference we took in collect */\n\t\t\tput_page(page);\n\t\t}\n\n\t\tif (!migrate_vma_check_page(page)) {\n\t\t\tif (remap) {\n\t\t\t\tmigrate->src[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t\t\tmigrate->cpages--;\n\t\t\t\trestore++;\n\n\t\t\t\tif (!is_zone_device_page(page)) {\n\t\t\t\t\tget_page(page);\n\t\t\t\t\tputback_lru_page(page);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmigrate->src[i] = 0;\n\t\t\t\tunlock_page(page);\n\t\t\t\tmigrate->cpages--;\n\n\t\t\t\tif (!is_zone_device_page(page))\n\t\t\t\t\tputback_lru_page(page);\n\t\t\t\telse\n\t\t\t\t\tput_page(page);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0, addr = start; i < npages && restore; i++, addr += PAGE_SIZE) {\n\t\tstruct page *page = migrate_pfn_to_page(migrate->src[i]);\n\n\t\tif (!page || (migrate->src[i] & MIGRATE_PFN_MIGRATE))\n\t\t\tcontinue;\n\n\t\tremove_migration_pte(page, migrate->vma, addr, page);\n\n\t\tmigrate->src[i] = 0;\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\trestore--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "migrate_vma_collect",
          "args": [
            "&migrate"
          ],
          "line": 2913
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_vma_collect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "2304-2326",
          "snippet": "static void migrate_vma_collect(struct migrate_vma *migrate)\n{\n\tstruct mm_walk mm_walk;\n\n\tmm_walk.pmd_entry = migrate_vma_collect_pmd;\n\tmm_walk.pte_entry = NULL;\n\tmm_walk.pte_hole = migrate_vma_collect_hole;\n\tmm_walk.hugetlb_entry = NULL;\n\tmm_walk.test_walk = NULL;\n\tmm_walk.vma = migrate->vma;\n\tmm_walk.mm = migrate->vma->vm_mm;\n\tmm_walk.private = migrate;\n\n\tmmu_notifier_invalidate_range_start(mm_walk.mm,\n\t\t\t\t\t    migrate->start,\n\t\t\t\t\t    migrate->end);\n\twalk_page_range(migrate->start, migrate->end, &mm_walk);\n\tmmu_notifier_invalidate_range_end(mm_walk.mm,\n\t\t\t\t\t  migrate->start,\n\t\t\t\t\t  migrate->end);\n\n\tmigrate->end = migrate->start + (migrate->npages << PAGE_SHIFT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic void migrate_vma_collect(struct migrate_vma *migrate)\n{\n\tstruct mm_walk mm_walk;\n\n\tmm_walk.pmd_entry = migrate_vma_collect_pmd;\n\tmm_walk.pte_entry = NULL;\n\tmm_walk.pte_hole = migrate_vma_collect_hole;\n\tmm_walk.hugetlb_entry = NULL;\n\tmm_walk.test_walk = NULL;\n\tmm_walk.vma = migrate->vma;\n\tmm_walk.mm = migrate->vma->vm_mm;\n\tmm_walk.private = migrate;\n\n\tmmu_notifier_invalidate_range_start(mm_walk.mm,\n\t\t\t\t\t    migrate->start,\n\t\t\t\t\t    migrate->end);\n\twalk_page_range(migrate->start, migrate->end, &mm_walk);\n\tmmu_notifier_invalidate_range_end(mm_walk.mm,\n\t\t\t\t\t  migrate->start,\n\t\t\t\t\t  migrate->end);\n\n\tmigrate->end = migrate->start + (migrate->npages << PAGE_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "src",
            "0",
            "sizeof(*src) * ((end - start) >> PAGE_SHIFT)"
          ],
          "line": 2903
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_is_dax",
          "args": [
            "vma"
          ],
          "line": 2894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vm_hugetlb_page",
          "args": [
            "vma"
          ],
          "line": 2893
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nint migrate_vma(const struct migrate_vma_ops *ops,\n\t\tstruct vm_area_struct *vma,\n\t\tunsigned long start,\n\t\tunsigned long end,\n\t\tunsigned long *src,\n\t\tunsigned long *dst,\n\t\tvoid *private)\n{\n\tstruct migrate_vma migrate;\n\n\t/* Sanity check the arguments */\n\tstart &= PAGE_MASK;\n\tend &= PAGE_MASK;\n\tif (!vma || is_vm_hugetlb_page(vma) || (vma->vm_flags & VM_SPECIAL) ||\n\t\t\tvma_is_dax(vma))\n\t\treturn -EINVAL;\n\tif (start < vma->vm_start || start >= vma->vm_end)\n\t\treturn -EINVAL;\n\tif (end <= vma->vm_start || end > vma->vm_end)\n\t\treturn -EINVAL;\n\tif (!ops || !src || !dst || start >= end)\n\t\treturn -EINVAL;\n\n\tmemset(src, 0, sizeof(*src) * ((end - start) >> PAGE_SHIFT));\n\tmigrate.src = src;\n\tmigrate.dst = dst;\n\tmigrate.start = start;\n\tmigrate.npages = 0;\n\tmigrate.cpages = 0;\n\tmigrate.end = end;\n\tmigrate.vma = vma;\n\n\t/* Collect, and try to unmap source pages */\n\tmigrate_vma_collect(&migrate);\n\tif (!migrate.cpages)\n\t\treturn 0;\n\n\t/* Lock and isolate page */\n\tmigrate_vma_prepare(&migrate);\n\tif (!migrate.cpages)\n\t\treturn 0;\n\n\t/* Unmap pages */\n\tmigrate_vma_unmap(&migrate);\n\tif (!migrate.cpages)\n\t\treturn 0;\n\n\t/*\n\t * At this point pages are locked and unmapped, and thus they have\n\t * stable content and can safely be copied to destination memory that\n\t * is allocated by the callback.\n\t *\n\t * Note that migration can fail in migrate_vma_struct_page() for each\n\t * individual page.\n\t */\n\tops->alloc_and_copy(vma, src, dst, start, end, private);\n\n\t/* This does the real migration of struct page */\n\tmigrate_vma_pages(&migrate);\n\n\tops->finalize_and_map(vma, src, dst, start, end, private);\n\n\t/* Unlock and remap pages */\n\tmigrate_vma_finalize(&migrate);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "migrate_vma_finalize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "2785-2827",
    "snippet": "static void migrate_vma_finalize(struct migrate_vma *migrate)\n{\n\tconst unsigned long npages = migrate->npages;\n\tunsigned long i;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tstruct page *newpage = migrate_pfn_to_page(migrate->dst[i]);\n\t\tstruct page *page = migrate_pfn_to_page(migrate->src[i]);\n\n\t\tif (!page) {\n\t\t\tif (newpage) {\n\t\t\t\tunlock_page(newpage);\n\t\t\t\tput_page(newpage);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(migrate->src[i] & MIGRATE_PFN_MIGRATE) || !newpage) {\n\t\t\tif (newpage) {\n\t\t\t\tunlock_page(newpage);\n\t\t\t\tput_page(newpage);\n\t\t\t}\n\t\t\tnewpage = page;\n\t\t}\n\n\t\tremove_migration_ptes(page, newpage, false);\n\t\tunlock_page(page);\n\t\tmigrate->cpages--;\n\n\t\tif (is_zone_device_page(page))\n\t\t\tput_page(page);\n\t\telse\n\t\t\tputback_lru_page(page);\n\n\t\tif (newpage != page) {\n\t\t\tunlock_page(newpage);\n\t\t\tif (is_zone_device_page(newpage))\n\t\t\t\tput_page(newpage);\n\t\t\telse\n\t\t\t\tputback_lru_page(newpage);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "putback_lru_page",
          "args": [
            "newpage"
          ],
          "line": 2824
        },
        "resolved": true,
        "details": {
          "function_name": "putback_lru_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1005-1009",
          "snippet": "void putback_lru_page(struct page *page)\n{\n\tlru_cache_add(page);\n\tput_page(page);\t\t/* drop ref from isolate */\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid putback_lru_page(struct page *page)\n{\n\tlru_cache_add(page);\n\tput_page(page);\t\t/* drop ref from isolate */\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "newpage"
          ],
          "line": 2822
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_zone_device_page",
          "args": [
            "newpage"
          ],
          "line": 2821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "newpage"
          ],
          "line": 2820
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_zone_device_page",
          "args": [
            "page"
          ],
          "line": 2814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_migration_ptes",
          "args": [
            "page",
            "newpage",
            "false"
          ],
          "line": 2810
        },
        "resolved": true,
        "details": {
          "function_name": "remove_migration_ptes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "292-303",
          "snippet": "void remove_migration_ptes(struct page *old, struct page *new, bool locked)\n{\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = remove_migration_pte,\n\t\t.arg = old,\n\t};\n\n\tif (locked)\n\t\trmap_walk_locked(new, &rwc);\n\telse\n\t\trmap_walk(new, &rwc);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nvoid remove_migration_ptes(struct page *old, struct page *new, bool locked)\n{\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = remove_migration_pte,\n\t\t.arg = old,\n\t};\n\n\tif (locked)\n\t\trmap_walk_locked(new, &rwc);\n\telse\n\t\trmap_walk(new, &rwc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "migrate_pfn_to_page",
          "args": [
            "migrate->src[i]"
          ],
          "line": 2792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_pfn_to_page",
          "args": [
            "migrate->dst[i]"
          ],
          "line": 2791
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic void migrate_vma_finalize(struct migrate_vma *migrate)\n{\n\tconst unsigned long npages = migrate->npages;\n\tunsigned long i;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tstruct page *newpage = migrate_pfn_to_page(migrate->dst[i]);\n\t\tstruct page *page = migrate_pfn_to_page(migrate->src[i]);\n\n\t\tif (!page) {\n\t\t\tif (newpage) {\n\t\t\t\tunlock_page(newpage);\n\t\t\t\tput_page(newpage);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(migrate->src[i] & MIGRATE_PFN_MIGRATE) || !newpage) {\n\t\t\tif (newpage) {\n\t\t\t\tunlock_page(newpage);\n\t\t\t\tput_page(newpage);\n\t\t\t}\n\t\t\tnewpage = page;\n\t\t}\n\n\t\tremove_migration_ptes(page, newpage, false);\n\t\tunlock_page(page);\n\t\tmigrate->cpages--;\n\n\t\tif (is_zone_device_page(page))\n\t\t\tput_page(page);\n\t\telse\n\t\t\tputback_lru_page(page);\n\n\t\tif (newpage != page) {\n\t\t\tunlock_page(newpage);\n\t\t\tif (is_zone_device_page(newpage))\n\t\t\t\tput_page(newpage);\n\t\t\telse\n\t\t\t\tputback_lru_page(newpage);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "migrate_vma_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "2700-2772",
    "snippet": "static void migrate_vma_pages(struct migrate_vma *migrate)\n{\n\tconst unsigned long npages = migrate->npages;\n\tconst unsigned long start = migrate->start;\n\tstruct vm_area_struct *vma = migrate->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long addr, i, mmu_start;\n\tbool notified = false;\n\n\tfor (i = 0, addr = start; i < npages; addr += PAGE_SIZE, i++) {\n\t\tstruct page *newpage = migrate_pfn_to_page(migrate->dst[i]);\n\t\tstruct page *page = migrate_pfn_to_page(migrate->src[i]);\n\t\tstruct address_space *mapping;\n\t\tint r;\n\n\t\tif (!newpage) {\n\t\t\tmigrate->src[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!page) {\n\t\t\tif (!(migrate->src[i] & MIGRATE_PFN_MIGRATE)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!notified) {\n\t\t\t\tmmu_start = addr;\n\t\t\t\tnotified = true;\n\t\t\t\tmmu_notifier_invalidate_range_start(mm,\n\t\t\t\t\t\t\t\tmmu_start,\n\t\t\t\t\t\t\t\tmigrate->end);\n\t\t\t}\n\t\t\tmigrate_vma_insert_page(migrate, addr, newpage,\n\t\t\t\t\t\t&migrate->src[i],\n\t\t\t\t\t\t&migrate->dst[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmapping = page_mapping(page);\n\n\t\tif (is_zone_device_page(newpage)) {\n\t\t\tif (is_device_private_page(newpage)) {\n\t\t\t\t/*\n\t\t\t\t * For now only support private anonymous when\n\t\t\t\t * migrating to un-addressable device memory.\n\t\t\t\t */\n\t\t\t\tif (mapping) {\n\t\t\t\t\tmigrate->src[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (!is_device_public_page(newpage)) {\n\t\t\t\t/*\n\t\t\t\t * Other types of ZONE_DEVICE page are not\n\t\t\t\t * supported.\n\t\t\t\t */\n\t\t\t\tmigrate->src[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tr = migrate_page(mapping, newpage, page, MIGRATE_SYNC_NO_COPY);\n\t\tif (r != MIGRATEPAGE_SUCCESS)\n\t\t\tmigrate->src[i] &= ~MIGRATE_PFN_MIGRATE;\n\t}\n\n\t/*\n\t * No need to double call mmu_notifier->invalidate_range() callback as\n\t * the above ptep_clear_flush_notify() inside migrate_vma_insert_page()\n\t * did already call it.\n\t */\n\tif (notified)\n\t\tmmu_notifier_invalidate_range_only_end(mm, mmu_start,\n\t\t\t\t\t\t       migrate->end);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_only_end",
          "args": [
            "mm",
            "mmu_start",
            "migrate->end"
          ],
          "line": 2770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_page",
          "args": [
            "mapping",
            "newpage",
            "page",
            "MIGRATE_SYNC_NO_COPY"
          ],
          "line": 2759
        },
        "resolved": true,
        "details": {
          "function_name": "fallback_migrate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "871-895",
          "snippet": "static int fallback_migrate_page(struct address_space *mapping,\n\tstruct page *newpage, struct page *page, enum migrate_mode mode)\n{\n\tif (PageDirty(page)) {\n\t\t/* Only writeback pages in full synchronous migration */\n\t\tswitch (mode) {\n\t\tcase MIGRATE_SYNC:\n\t\tcase MIGRATE_SYNC_NO_COPY:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EBUSY;\n\t\t}\n\t\treturn writeout(mapping, page);\n\t}\n\n\t/*\n\t * Buffers may be managed in a filesystem specific way.\n\t * We must have no buffers or drop them.\n\t */\n\tif (page_has_private(page) &&\n\t    !try_to_release_page(page, GFP_KERNEL))\n\t\treturn -EAGAIN;\n\n\treturn migrate_page(mapping, newpage, page, mode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic int fallback_migrate_page(struct address_space *mapping,\n\tstruct page *newpage, struct page *page, enum migrate_mode mode)\n{\n\tif (PageDirty(page)) {\n\t\t/* Only writeback pages in full synchronous migration */\n\t\tswitch (mode) {\n\t\tcase MIGRATE_SYNC:\n\t\tcase MIGRATE_SYNC_NO_COPY:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EBUSY;\n\t\t}\n\t\treturn writeout(mapping, page);\n\t}\n\n\t/*\n\t * Buffers may be managed in a filesystem specific way.\n\t * We must have no buffers or drop them.\n\t */\n\tif (page_has_private(page) &&\n\t    !try_to_release_page(page, GFP_KERNEL))\n\t\treturn -EAGAIN;\n\n\treturn migrate_page(mapping, newpage, page, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_device_public_page",
          "args": [
            "newpage"
          ],
          "line": 2749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_device_private_page",
          "args": [
            "newpage"
          ],
          "line": 2740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_zone_device_page",
          "args": [
            "newpage"
          ],
          "line": 2739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "page"
          ],
          "line": 2737
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapping_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "528-533",
          "snippet": "struct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "migrate_vma_insert_page",
          "args": [
            "migrate",
            "addr",
            "newpage",
            "&migrate->src[i]",
            "&migrate->dst[i]"
          ],
          "line": 2731
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_vma_insert_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "2556-2690",
          "snippet": "static void migrate_vma_insert_page(struct migrate_vma *migrate,\n\t\t\t\t    unsigned long addr,\n\t\t\t\t    struct page *page,\n\t\t\t\t    unsigned long *src,\n\t\t\t\t    unsigned long *dst)\n{\n\tstruct vm_area_struct *vma = migrate->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct mem_cgroup *memcg;\n\tbool flush = false;\n\tspinlock_t *ptl;\n\tpte_t entry;\n\tpgd_t *pgdp;\n\tp4d_t *p4dp;\n\tpud_t *pudp;\n\tpmd_t *pmdp;\n\tpte_t *ptep;\n\n\t/* Only allow populating anonymous memory */\n\tif (!vma_is_anonymous(vma))\n\t\tgoto abort;\n\n\tpgdp = pgd_offset(mm, addr);\n\tp4dp = p4d_alloc(mm, pgdp, addr);\n\tif (!p4dp)\n\t\tgoto abort;\n\tpudp = pud_alloc(mm, p4dp, addr);\n\tif (!pudp)\n\t\tgoto abort;\n\tpmdp = pmd_alloc(mm, pudp, addr);\n\tif (!pmdp)\n\t\tgoto abort;\n\n\tif (pmd_trans_huge(*pmdp) || pmd_devmap(*pmdp))\n\t\tgoto abort;\n\n\t/*\n\t * Use pte_alloc() instead of pte_alloc_map().  We can't run\n\t * pte_offset_map() on pmds where a huge pmd might be created\n\t * from a different thread.\n\t *\n\t * pte_alloc_map() is safe to use under down_write(mmap_sem) or when\n\t * parallel threads are excluded by other means.\n\t *\n\t * Here we only have down_read(mmap_sem).\n\t */\n\tif (pte_alloc(mm, pmdp, addr))\n\t\tgoto abort;\n\n\t/* See the comment in pte_alloc_one_map() */\n\tif (unlikely(pmd_trans_unstable(pmdp)))\n\t\tgoto abort;\n\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\tgoto abort;\n\tif (mem_cgroup_try_charge(page, vma->vm_mm, GFP_KERNEL, &memcg, false))\n\t\tgoto abort;\n\n\t/*\n\t * The memory barrier inside __SetPageUptodate makes sure that\n\t * preceding stores to the page contents become visible before\n\t * the set_pte_at() write.\n\t */\n\t__SetPageUptodate(page);\n\n\tif (is_zone_device_page(page)) {\n\t\tif (is_device_private_page(page)) {\n\t\t\tswp_entry_t swp_entry;\n\n\t\t\tswp_entry = make_device_private_entry(page, vma->vm_flags & VM_WRITE);\n\t\t\tentry = swp_entry_to_pte(swp_entry);\n\t\t} else if (is_device_public_page(page)) {\n\t\t\tentry = pte_mkold(mk_pte(page, READ_ONCE(vma->vm_page_prot)));\n\t\t\tif (vma->vm_flags & VM_WRITE)\n\t\t\t\tentry = pte_mkwrite(pte_mkdirty(entry));\n\t\t\tentry = pte_mkdevmap(entry);\n\t\t}\n\t} else {\n\t\tentry = mk_pte(page, vma->vm_page_prot);\n\t\tif (vma->vm_flags & VM_WRITE)\n\t\t\tentry = pte_mkwrite(pte_mkdirty(entry));\n\t}\n\n\tptep = pte_offset_map_lock(mm, pmdp, addr, &ptl);\n\n\tif (pte_present(*ptep)) {\n\t\tunsigned long pfn = pte_pfn(*ptep);\n\n\t\tif (!is_zero_pfn(pfn)) {\n\t\t\tpte_unmap_unlock(ptep, ptl);\n\t\t\tmem_cgroup_cancel_charge(page, memcg, false);\n\t\t\tgoto abort;\n\t\t}\n\t\tflush = true;\n\t} else if (!pte_none(*ptep)) {\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\tmem_cgroup_cancel_charge(page, memcg, false);\n\t\tgoto abort;\n\t}\n\n\t/*\n\t * Check for usefaultfd but do not deliver the fault. Instead,\n\t * just back off.\n\t */\n\tif (userfaultfd_missing(vma)) {\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\tmem_cgroup_cancel_charge(page, memcg, false);\n\t\tgoto abort;\n\t}\n\n\tinc_mm_counter(mm, MM_ANONPAGES);\n\tpage_add_new_anon_rmap(page, vma, addr, false);\n\tmem_cgroup_commit_charge(page, memcg, false, false);\n\tif (!is_zone_device_page(page))\n\t\tlru_cache_add_active_or_unevictable(page, vma);\n\tget_page(page);\n\n\tif (flush) {\n\t\tflush_cache_page(vma, addr, pte_pfn(*ptep));\n\t\tptep_clear_flush_notify(vma, addr, ptep);\n\t\tset_pte_at_notify(mm, addr, ptep, entry);\n\t\tupdate_mmu_cache(vma, addr, ptep);\n\t} else {\n\t\t/* No need to invalidate - it was non-present before */\n\t\tset_pte_at(mm, addr, ptep, entry);\n\t\tupdate_mmu_cache(vma, addr, ptep);\n\t}\n\n\tpte_unmap_unlock(ptep, ptl);\n\t*src = MIGRATE_PFN_MIGRATE;\n\treturn;\n\nabort:\n\t*src &= ~MIGRATE_PFN_MIGRATE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic void migrate_vma_insert_page(struct migrate_vma *migrate,\n\t\t\t\t    unsigned long addr,\n\t\t\t\t    struct page *page,\n\t\t\t\t    unsigned long *src,\n\t\t\t\t    unsigned long *dst)\n{\n\tstruct vm_area_struct *vma = migrate->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct mem_cgroup *memcg;\n\tbool flush = false;\n\tspinlock_t *ptl;\n\tpte_t entry;\n\tpgd_t *pgdp;\n\tp4d_t *p4dp;\n\tpud_t *pudp;\n\tpmd_t *pmdp;\n\tpte_t *ptep;\n\n\t/* Only allow populating anonymous memory */\n\tif (!vma_is_anonymous(vma))\n\t\tgoto abort;\n\n\tpgdp = pgd_offset(mm, addr);\n\tp4dp = p4d_alloc(mm, pgdp, addr);\n\tif (!p4dp)\n\t\tgoto abort;\n\tpudp = pud_alloc(mm, p4dp, addr);\n\tif (!pudp)\n\t\tgoto abort;\n\tpmdp = pmd_alloc(mm, pudp, addr);\n\tif (!pmdp)\n\t\tgoto abort;\n\n\tif (pmd_trans_huge(*pmdp) || pmd_devmap(*pmdp))\n\t\tgoto abort;\n\n\t/*\n\t * Use pte_alloc() instead of pte_alloc_map().  We can't run\n\t * pte_offset_map() on pmds where a huge pmd might be created\n\t * from a different thread.\n\t *\n\t * pte_alloc_map() is safe to use under down_write(mmap_sem) or when\n\t * parallel threads are excluded by other means.\n\t *\n\t * Here we only have down_read(mmap_sem).\n\t */\n\tif (pte_alloc(mm, pmdp, addr))\n\t\tgoto abort;\n\n\t/* See the comment in pte_alloc_one_map() */\n\tif (unlikely(pmd_trans_unstable(pmdp)))\n\t\tgoto abort;\n\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\tgoto abort;\n\tif (mem_cgroup_try_charge(page, vma->vm_mm, GFP_KERNEL, &memcg, false))\n\t\tgoto abort;\n\n\t/*\n\t * The memory barrier inside __SetPageUptodate makes sure that\n\t * preceding stores to the page contents become visible before\n\t * the set_pte_at() write.\n\t */\n\t__SetPageUptodate(page);\n\n\tif (is_zone_device_page(page)) {\n\t\tif (is_device_private_page(page)) {\n\t\t\tswp_entry_t swp_entry;\n\n\t\t\tswp_entry = make_device_private_entry(page, vma->vm_flags & VM_WRITE);\n\t\t\tentry = swp_entry_to_pte(swp_entry);\n\t\t} else if (is_device_public_page(page)) {\n\t\t\tentry = pte_mkold(mk_pte(page, READ_ONCE(vma->vm_page_prot)));\n\t\t\tif (vma->vm_flags & VM_WRITE)\n\t\t\t\tentry = pte_mkwrite(pte_mkdirty(entry));\n\t\t\tentry = pte_mkdevmap(entry);\n\t\t}\n\t} else {\n\t\tentry = mk_pte(page, vma->vm_page_prot);\n\t\tif (vma->vm_flags & VM_WRITE)\n\t\t\tentry = pte_mkwrite(pte_mkdirty(entry));\n\t}\n\n\tptep = pte_offset_map_lock(mm, pmdp, addr, &ptl);\n\n\tif (pte_present(*ptep)) {\n\t\tunsigned long pfn = pte_pfn(*ptep);\n\n\t\tif (!is_zero_pfn(pfn)) {\n\t\t\tpte_unmap_unlock(ptep, ptl);\n\t\t\tmem_cgroup_cancel_charge(page, memcg, false);\n\t\t\tgoto abort;\n\t\t}\n\t\tflush = true;\n\t} else if (!pte_none(*ptep)) {\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\tmem_cgroup_cancel_charge(page, memcg, false);\n\t\tgoto abort;\n\t}\n\n\t/*\n\t * Check for usefaultfd but do not deliver the fault. Instead,\n\t * just back off.\n\t */\n\tif (userfaultfd_missing(vma)) {\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\tmem_cgroup_cancel_charge(page, memcg, false);\n\t\tgoto abort;\n\t}\n\n\tinc_mm_counter(mm, MM_ANONPAGES);\n\tpage_add_new_anon_rmap(page, vma, addr, false);\n\tmem_cgroup_commit_charge(page, memcg, false, false);\n\tif (!is_zone_device_page(page))\n\t\tlru_cache_add_active_or_unevictable(page, vma);\n\tget_page(page);\n\n\tif (flush) {\n\t\tflush_cache_page(vma, addr, pte_pfn(*ptep));\n\t\tptep_clear_flush_notify(vma, addr, ptep);\n\t\tset_pte_at_notify(mm, addr, ptep, entry);\n\t\tupdate_mmu_cache(vma, addr, ptep);\n\t} else {\n\t\t/* No need to invalidate - it was non-present before */\n\t\tset_pte_at(mm, addr, ptep, entry);\n\t\tupdate_mmu_cache(vma, addr, ptep);\n\t}\n\n\tpte_unmap_unlock(ptep, ptl);\n\t*src = MIGRATE_PFN_MIGRATE;\n\treturn;\n\nabort:\n\t*src &= ~MIGRATE_PFN_MIGRATE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_start",
          "args": [
            "mm",
            "mmu_start",
            "migrate->end"
          ],
          "line": 2727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_pfn_to_page",
          "args": [
            "migrate->src[i]"
          ],
          "line": 2711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_pfn_to_page",
          "args": [
            "migrate->dst[i]"
          ],
          "line": 2710
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic void migrate_vma_pages(struct migrate_vma *migrate)\n{\n\tconst unsigned long npages = migrate->npages;\n\tconst unsigned long start = migrate->start;\n\tstruct vm_area_struct *vma = migrate->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long addr, i, mmu_start;\n\tbool notified = false;\n\n\tfor (i = 0, addr = start; i < npages; addr += PAGE_SIZE, i++) {\n\t\tstruct page *newpage = migrate_pfn_to_page(migrate->dst[i]);\n\t\tstruct page *page = migrate_pfn_to_page(migrate->src[i]);\n\t\tstruct address_space *mapping;\n\t\tint r;\n\n\t\tif (!newpage) {\n\t\t\tmigrate->src[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!page) {\n\t\t\tif (!(migrate->src[i] & MIGRATE_PFN_MIGRATE)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!notified) {\n\t\t\t\tmmu_start = addr;\n\t\t\t\tnotified = true;\n\t\t\t\tmmu_notifier_invalidate_range_start(mm,\n\t\t\t\t\t\t\t\tmmu_start,\n\t\t\t\t\t\t\t\tmigrate->end);\n\t\t\t}\n\t\t\tmigrate_vma_insert_page(migrate, addr, newpage,\n\t\t\t\t\t\t&migrate->src[i],\n\t\t\t\t\t\t&migrate->dst[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmapping = page_mapping(page);\n\n\t\tif (is_zone_device_page(newpage)) {\n\t\t\tif (is_device_private_page(newpage)) {\n\t\t\t\t/*\n\t\t\t\t * For now only support private anonymous when\n\t\t\t\t * migrating to un-addressable device memory.\n\t\t\t\t */\n\t\t\t\tif (mapping) {\n\t\t\t\t\tmigrate->src[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (!is_device_public_page(newpage)) {\n\t\t\t\t/*\n\t\t\t\t * Other types of ZONE_DEVICE page are not\n\t\t\t\t * supported.\n\t\t\t\t */\n\t\t\t\tmigrate->src[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tr = migrate_page(mapping, newpage, page, MIGRATE_SYNC_NO_COPY);\n\t\tif (r != MIGRATEPAGE_SUCCESS)\n\t\t\tmigrate->src[i] &= ~MIGRATE_PFN_MIGRATE;\n\t}\n\n\t/*\n\t * No need to double call mmu_notifier->invalidate_range() callback as\n\t * the above ptep_clear_flush_notify() inside migrate_vma_insert_page()\n\t * did already call it.\n\t */\n\tif (notified)\n\t\tmmu_notifier_invalidate_range_only_end(mm, mmu_start,\n\t\t\t\t\t\t       migrate->end);\n}"
  },
  {
    "function_name": "migrate_vma_insert_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "2556-2690",
    "snippet": "static void migrate_vma_insert_page(struct migrate_vma *migrate,\n\t\t\t\t    unsigned long addr,\n\t\t\t\t    struct page *page,\n\t\t\t\t    unsigned long *src,\n\t\t\t\t    unsigned long *dst)\n{\n\tstruct vm_area_struct *vma = migrate->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct mem_cgroup *memcg;\n\tbool flush = false;\n\tspinlock_t *ptl;\n\tpte_t entry;\n\tpgd_t *pgdp;\n\tp4d_t *p4dp;\n\tpud_t *pudp;\n\tpmd_t *pmdp;\n\tpte_t *ptep;\n\n\t/* Only allow populating anonymous memory */\n\tif (!vma_is_anonymous(vma))\n\t\tgoto abort;\n\n\tpgdp = pgd_offset(mm, addr);\n\tp4dp = p4d_alloc(mm, pgdp, addr);\n\tif (!p4dp)\n\t\tgoto abort;\n\tpudp = pud_alloc(mm, p4dp, addr);\n\tif (!pudp)\n\t\tgoto abort;\n\tpmdp = pmd_alloc(mm, pudp, addr);\n\tif (!pmdp)\n\t\tgoto abort;\n\n\tif (pmd_trans_huge(*pmdp) || pmd_devmap(*pmdp))\n\t\tgoto abort;\n\n\t/*\n\t * Use pte_alloc() instead of pte_alloc_map().  We can't run\n\t * pte_offset_map() on pmds where a huge pmd might be created\n\t * from a different thread.\n\t *\n\t * pte_alloc_map() is safe to use under down_write(mmap_sem) or when\n\t * parallel threads are excluded by other means.\n\t *\n\t * Here we only have down_read(mmap_sem).\n\t */\n\tif (pte_alloc(mm, pmdp, addr))\n\t\tgoto abort;\n\n\t/* See the comment in pte_alloc_one_map() */\n\tif (unlikely(pmd_trans_unstable(pmdp)))\n\t\tgoto abort;\n\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\tgoto abort;\n\tif (mem_cgroup_try_charge(page, vma->vm_mm, GFP_KERNEL, &memcg, false))\n\t\tgoto abort;\n\n\t/*\n\t * The memory barrier inside __SetPageUptodate makes sure that\n\t * preceding stores to the page contents become visible before\n\t * the set_pte_at() write.\n\t */\n\t__SetPageUptodate(page);\n\n\tif (is_zone_device_page(page)) {\n\t\tif (is_device_private_page(page)) {\n\t\t\tswp_entry_t swp_entry;\n\n\t\t\tswp_entry = make_device_private_entry(page, vma->vm_flags & VM_WRITE);\n\t\t\tentry = swp_entry_to_pte(swp_entry);\n\t\t} else if (is_device_public_page(page)) {\n\t\t\tentry = pte_mkold(mk_pte(page, READ_ONCE(vma->vm_page_prot)));\n\t\t\tif (vma->vm_flags & VM_WRITE)\n\t\t\t\tentry = pte_mkwrite(pte_mkdirty(entry));\n\t\t\tentry = pte_mkdevmap(entry);\n\t\t}\n\t} else {\n\t\tentry = mk_pte(page, vma->vm_page_prot);\n\t\tif (vma->vm_flags & VM_WRITE)\n\t\t\tentry = pte_mkwrite(pte_mkdirty(entry));\n\t}\n\n\tptep = pte_offset_map_lock(mm, pmdp, addr, &ptl);\n\n\tif (pte_present(*ptep)) {\n\t\tunsigned long pfn = pte_pfn(*ptep);\n\n\t\tif (!is_zero_pfn(pfn)) {\n\t\t\tpte_unmap_unlock(ptep, ptl);\n\t\t\tmem_cgroup_cancel_charge(page, memcg, false);\n\t\t\tgoto abort;\n\t\t}\n\t\tflush = true;\n\t} else if (!pte_none(*ptep)) {\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\tmem_cgroup_cancel_charge(page, memcg, false);\n\t\tgoto abort;\n\t}\n\n\t/*\n\t * Check for usefaultfd but do not deliver the fault. Instead,\n\t * just back off.\n\t */\n\tif (userfaultfd_missing(vma)) {\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\tmem_cgroup_cancel_charge(page, memcg, false);\n\t\tgoto abort;\n\t}\n\n\tinc_mm_counter(mm, MM_ANONPAGES);\n\tpage_add_new_anon_rmap(page, vma, addr, false);\n\tmem_cgroup_commit_charge(page, memcg, false, false);\n\tif (!is_zone_device_page(page))\n\t\tlru_cache_add_active_or_unevictable(page, vma);\n\tget_page(page);\n\n\tif (flush) {\n\t\tflush_cache_page(vma, addr, pte_pfn(*ptep));\n\t\tptep_clear_flush_notify(vma, addr, ptep);\n\t\tset_pte_at_notify(mm, addr, ptep, entry);\n\t\tupdate_mmu_cache(vma, addr, ptep);\n\t} else {\n\t\t/* No need to invalidate - it was non-present before */\n\t\tset_pte_at(mm, addr, ptep, entry);\n\t\tupdate_mmu_cache(vma, addr, ptep);\n\t}\n\n\tpte_unmap_unlock(ptep, ptl);\n\t*src = MIGRATE_PFN_MIGRATE;\n\treturn;\n\nabort:\n\t*src &= ~MIGRATE_PFN_MIGRATE;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "ptep",
            "ptl"
          ],
          "line": 2684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_mmu_cache",
          "args": [
            "vma",
            "addr",
            "ptep"
          ],
          "line": 2681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pte_at",
          "args": [
            "mm",
            "addr",
            "ptep",
            "entry"
          ],
          "line": 2680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_mmu_cache",
          "args": [
            "vma",
            "addr",
            "ptep"
          ],
          "line": 2677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pte_at_notify",
          "args": [
            "mm",
            "addr",
            "ptep",
            "entry"
          ],
          "line": 2676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptep_clear_flush_notify",
          "args": [
            "vma",
            "addr",
            "ptep"
          ],
          "line": 2675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_cache_page",
          "args": [
            "vma",
            "addr",
            "pte_pfn(*ptep)"
          ],
          "line": 2674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_pfn",
          "args": [
            "*ptep"
          ],
          "line": 2674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "page"
          ],
          "line": 2671
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lru_cache_add_active_or_unevictable",
          "args": [
            "page",
            "vma"
          ],
          "line": 2670
        },
        "resolved": true,
        "details": {
          "function_name": "lru_cache_add_active_or_unevictable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "458-476",
          "snippet": "void lru_cache_add_active_or_unevictable(struct page *page,\n\t\t\t\t\t struct vm_area_struct *vma)\n{\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\n\tif (likely((vma->vm_flags & (VM_LOCKED | VM_SPECIAL)) != VM_LOCKED))\n\t\tSetPageActive(page);\n\telse if (!TestSetPageMlocked(page)) {\n\t\t/*\n\t\t * We use the irq-unsafe __mod_zone_page_stat because this\n\t\t * counter is not modified from interrupt context, and the pte\n\t\t * lock is held(spinlock), which implies preemption disabled.\n\t\t */\n\t\t__mod_zone_page_state(page_zone(page), NR_MLOCK,\n\t\t\t\t    hpage_nr_pages(page));\n\t\tcount_vm_event(UNEVICTABLE_PGMLOCKED);\n\t}\n\tlru_cache_add(page);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid lru_cache_add_active_or_unevictable(struct page *page,\n\t\t\t\t\t struct vm_area_struct *vma)\n{\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\n\tif (likely((vma->vm_flags & (VM_LOCKED | VM_SPECIAL)) != VM_LOCKED))\n\t\tSetPageActive(page);\n\telse if (!TestSetPageMlocked(page)) {\n\t\t/*\n\t\t * We use the irq-unsafe __mod_zone_page_stat because this\n\t\t * counter is not modified from interrupt context, and the pte\n\t\t * lock is held(spinlock), which implies preemption disabled.\n\t\t */\n\t\t__mod_zone_page_state(page_zone(page), NR_MLOCK,\n\t\t\t\t    hpage_nr_pages(page));\n\t\tcount_vm_event(UNEVICTABLE_PGMLOCKED);\n\t}\n\tlru_cache_add(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_zone_device_page",
          "args": [
            "page"
          ],
          "line": 2669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_commit_charge",
          "args": [
            "page",
            "memcg",
            "false",
            "false"
          ],
          "line": 2668
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_commit_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5928-5962",
          "snippet": "void mem_cgroup_commit_charge(struct page *page, struct mem_cgroup *memcg,\n\t\t\t      bool lrucare, bool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_PAGE(!page->mapping, page);\n\tVM_BUG_ON_PAGE(PageLRU(page) && !lrucare, page);\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcommit_charge(page, memcg, lrucare);\n\n\tlocal_irq_disable();\n\tmem_cgroup_charge_statistics(memcg, page, compound, nr_pages);\n\tmemcg_check_events(memcg, page);\n\tlocal_irq_enable();\n\n\tif (do_memsw_account() && PageSwapCache(page)) {\n\t\tswp_entry_t entry = { .val = page_private(page) };\n\t\t/*\n\t\t * The swap entry might not get freed for a long time,\n\t\t * let's not wait for it.  The page already received a\n\t\t * memory+swap charge, drop the swap entry duplicate.\n\t\t */\n\t\tmem_cgroup_uncharge_swap(entry, nr_pages);\n\t}\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid mem_cgroup_commit_charge(struct page *page, struct mem_cgroup *memcg,\n\t\t\t      bool lrucare, bool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_PAGE(!page->mapping, page);\n\tVM_BUG_ON_PAGE(PageLRU(page) && !lrucare, page);\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcommit_charge(page, memcg, lrucare);\n\n\tlocal_irq_disable();\n\tmem_cgroup_charge_statistics(memcg, page, compound, nr_pages);\n\tmemcg_check_events(memcg, page);\n\tlocal_irq_enable();\n\n\tif (do_memsw_account() && PageSwapCache(page)) {\n\t\tswp_entry_t entry = { .val = page_private(page) };\n\t\t/*\n\t\t * The swap entry might not get freed for a long time,\n\t\t * let's not wait for it.  The page already received a\n\t\t * memory+swap charge, drop the swap entry duplicate.\n\t\t */\n\t\tmem_cgroup_uncharge_swap(entry, nr_pages);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_add_new_anon_rmap",
          "args": [
            "page",
            "vma",
            "addr",
            "false"
          ],
          "line": 2667
        },
        "resolved": true,
        "details": {
          "function_name": "page_add_new_anon_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1150-1170",
          "snippet": "void page_add_new_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, bool compound)\n{\n\tint nr = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_VMA(address < vma->vm_start || address >= vma->vm_end, vma);\n\t__SetPageSwapBacked(page);\n\tif (compound) {\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(compound_mapcount_ptr(page), 0);\n\t\t__inc_node_page_state(page, NR_ANON_THPS);\n\t} else {\n\t\t/* Anon THP always mapped first with PMD */\n\t\tVM_BUG_ON_PAGE(PageTransCompound(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(&page->_mapcount, 0);\n\t}\n\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, nr);\n\t__page_set_anon_rmap(page, vma, address, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid page_add_new_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, bool compound)\n{\n\tint nr = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_VMA(address < vma->vm_start || address >= vma->vm_end, vma);\n\t__SetPageSwapBacked(page);\n\tif (compound) {\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(compound_mapcount_ptr(page), 0);\n\t\t__inc_node_page_state(page, NR_ANON_THPS);\n\t} else {\n\t\t/* Anon THP always mapped first with PMD */\n\t\tVM_BUG_ON_PAGE(PageTransCompound(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(&page->_mapcount, 0);\n\t}\n\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, nr);\n\t__page_set_anon_rmap(page, vma, address, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_mm_counter",
          "args": [
            "mm",
            "MM_ANONPAGES"
          ],
          "line": 2666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_cancel_charge",
          "args": [
            "page",
            "memcg",
            "false"
          ],
          "line": 2662
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_cancel_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5972-5988",
          "snippet": "void mem_cgroup_cancel_charge(struct page *page, struct mem_cgroup *memcg,\n\t\tbool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcancel_charge(memcg, nr_pages);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid mem_cgroup_cancel_charge(struct page *page, struct mem_cgroup *memcg,\n\t\tbool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcancel_charge(memcg, nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "ptep",
            "ptl"
          ],
          "line": 2661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userfaultfd_missing",
          "args": [
            "vma"
          ],
          "line": 2660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "ptep",
            "ptl"
          ],
          "line": 2651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_none",
          "args": [
            "*ptep"
          ],
          "line": 2650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "ptep",
            "ptl"
          ],
          "line": 2645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_zero_pfn",
          "args": [
            "pfn"
          ],
          "line": 2644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_pfn",
          "args": [
            "*ptep"
          ],
          "line": 2642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "*ptep"
          ],
          "line": 2641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_offset_map_lock",
          "args": [
            "mm",
            "pmdp",
            "addr",
            "&ptl"
          ],
          "line": 2639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkwrite",
          "args": [
            "pte_mkdirty(entry)"
          ],
          "line": 2636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkdirty",
          "args": [
            "entry"
          ],
          "line": 2636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mk_pte",
          "args": [
            "page",
            "vma->vm_page_prot"
          ],
          "line": 2634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkdevmap",
          "args": [
            "entry"
          ],
          "line": 2631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkwrite",
          "args": [
            "pte_mkdirty(entry)"
          ],
          "line": 2630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkdirty",
          "args": [
            "entry"
          ],
          "line": 2630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkold",
          "args": [
            "mk_pte(page, READ_ONCE(vma->vm_page_prot))"
          ],
          "line": 2628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mk_pte",
          "args": [
            "page",
            "READ_ONCE(vma->vm_page_prot)"
          ],
          "line": 2628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "vma->vm_page_prot"
          ],
          "line": 2628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_device_public_page",
          "args": [
            "page"
          ],
          "line": 2627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_entry_to_pte",
          "args": [
            "swp_entry"
          ],
          "line": 2626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_device_private_entry",
          "args": [
            "page",
            "vma->vm_flags & VM_WRITE"
          ],
          "line": 2625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_device_private_page",
          "args": [
            "page"
          ],
          "line": 2622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_zone_device_page",
          "args": [
            "page"
          ],
          "line": 2621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 2619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_try_charge",
          "args": [
            "page",
            "vma->vm_mm",
            "GFP_KERNEL",
            "&memcg",
            "false"
          ],
          "line": 2611
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_try_charge_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5898-5909",
          "snippet": "int mem_cgroup_try_charge_delay(struct page *page, struct mm_struct *mm,\n\t\t\t  gfp_t gfp_mask, struct mem_cgroup **memcgp,\n\t\t\t  bool compound)\n{\n\tstruct mem_cgroup *memcg;\n\tint ret;\n\n\tret = mem_cgroup_try_charge(page, mm, gfp_mask, memcgp, compound);\n\tmemcg = *memcgp;\n\tmem_cgroup_throttle_swaprate(memcg, page_to_nid(page), gfp_mask);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nint mem_cgroup_try_charge_delay(struct page *page, struct mm_struct *mm,\n\t\t\t  gfp_t gfp_mask, struct mem_cgroup **memcgp,\n\t\t\t  bool compound)\n{\n\tstruct mem_cgroup *memcg;\n\tint ret;\n\n\tret = mem_cgroup_try_charge(page, mm, gfp_mask, memcgp, compound);\n\tmemcg = *memcgp;\n\tmem_cgroup_throttle_swaprate(memcg, page_to_nid(page), gfp_mask);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "anon_vma_prepare(vma)"
          ],
          "line": 2609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_vma_prepare",
          "args": [
            "vma"
          ],
          "line": 2609
        },
        "resolved": true,
        "details": {
          "function_name": "__anon_vma_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "175-221",
          "snippet": "int __anon_vma_prepare(struct vm_area_struct *vma)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct anon_vma *anon_vma, *allocated;\n\tstruct anon_vma_chain *avc;\n\n\tmight_sleep();\n\n\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\tif (!avc)\n\t\tgoto out_enomem;\n\n\tanon_vma = find_mergeable_anon_vma(vma);\n\tallocated = NULL;\n\tif (!anon_vma) {\n\t\tanon_vma = anon_vma_alloc();\n\t\tif (unlikely(!anon_vma))\n\t\t\tgoto out_enomem_free_avc;\n\t\tallocated = anon_vma;\n\t}\n\n\tanon_vma_lock_write(anon_vma);\n\t/* page_table_lock to protect against threads */\n\tspin_lock(&mm->page_table_lock);\n\tif (likely(!vma->anon_vma)) {\n\t\tvma->anon_vma = anon_vma;\n\t\tanon_vma_chain_link(vma, avc, anon_vma);\n\t\t/* vma reference or self-parent link for new root */\n\t\tanon_vma->degree++;\n\t\tallocated = NULL;\n\t\tavc = NULL;\n\t}\n\tspin_unlock(&mm->page_table_lock);\n\tanon_vma_unlock_write(anon_vma);\n\n\tif (unlikely(allocated))\n\t\tput_anon_vma(allocated);\n\tif (unlikely(avc))\n\t\tanon_vma_chain_free(avc);\n\n\treturn 0;\n\n out_enomem_free_avc:\n\tanon_vma_chain_free(avc);\n out_enomem:\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint __anon_vma_prepare(struct vm_area_struct *vma)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct anon_vma *anon_vma, *allocated;\n\tstruct anon_vma_chain *avc;\n\n\tmight_sleep();\n\n\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\tif (!avc)\n\t\tgoto out_enomem;\n\n\tanon_vma = find_mergeable_anon_vma(vma);\n\tallocated = NULL;\n\tif (!anon_vma) {\n\t\tanon_vma = anon_vma_alloc();\n\t\tif (unlikely(!anon_vma))\n\t\t\tgoto out_enomem_free_avc;\n\t\tallocated = anon_vma;\n\t}\n\n\tanon_vma_lock_write(anon_vma);\n\t/* page_table_lock to protect against threads */\n\tspin_lock(&mm->page_table_lock);\n\tif (likely(!vma->anon_vma)) {\n\t\tvma->anon_vma = anon_vma;\n\t\tanon_vma_chain_link(vma, avc, anon_vma);\n\t\t/* vma reference or self-parent link for new root */\n\t\tanon_vma->degree++;\n\t\tallocated = NULL;\n\t\tavc = NULL;\n\t}\n\tspin_unlock(&mm->page_table_lock);\n\tanon_vma_unlock_write(anon_vma);\n\n\tif (unlikely(allocated))\n\t\tput_anon_vma(allocated);\n\tif (unlikely(avc))\n\t\tanon_vma_chain_free(avc);\n\n\treturn 0;\n\n out_enomem_free_avc:\n\tanon_vma_chain_free(avc);\n out_enomem:\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pmd_trans_unstable(pmdp)"
          ],
          "line": 2606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_unstable",
          "args": [
            "pmdp"
          ],
          "line": 2606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_alloc",
          "args": [
            "mm",
            "pmdp",
            "addr"
          ],
          "line": 2602
        },
        "resolved": true,
        "details": {
          "function_name": "__pte_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "403-435",
          "snippet": "int __pte_alloc(struct mm_struct *mm, pmd_t *pmd, unsigned long address)\n{\n\tspinlock_t *ptl;\n\tpgtable_t new = pte_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Ensure all pte setup (eg. pte page lock and page clearing) are\n\t * visible before the pte is made visible to other CPUs by being\n\t * put into page tables.\n\t *\n\t * The other side of the story is the pointer chasing in the page\n\t * table walking code (when walking the page table without locking;\n\t * ie. most of the time). Fortunately, these data accesses consist\n\t * of a chain of data-dependent loads, meaning most CPUs (alpha\n\t * being the notable exception) will already guarantee loads are\n\t * seen in-order. See the alpha page table accessors for the\n\t * smp_read_barrier_depends() barriers in page table walking code.\n\t */\n\tsmp_wmb(); /* Could be smp_wmb__xxx(before|after)_spin_lock */\n\n\tptl = pmd_lock(mm, pmd);\n\tif (likely(pmd_none(*pmd))) {\t/* Has another populated it ? */\n\t\tmm_inc_nr_ptes(mm);\n\t\tpmd_populate(mm, pmd, new);\n\t\tnew = NULL;\n\t}\n\tspin_unlock(ptl);\n\tif (new)\n\t\tpte_free(mm, new);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __pte_alloc(struct mm_struct *mm, pmd_t *pmd, unsigned long address)\n{\n\tspinlock_t *ptl;\n\tpgtable_t new = pte_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Ensure all pte setup (eg. pte page lock and page clearing) are\n\t * visible before the pte is made visible to other CPUs by being\n\t * put into page tables.\n\t *\n\t * The other side of the story is the pointer chasing in the page\n\t * table walking code (when walking the page table without locking;\n\t * ie. most of the time). Fortunately, these data accesses consist\n\t * of a chain of data-dependent loads, meaning most CPUs (alpha\n\t * being the notable exception) will already guarantee loads are\n\t * seen in-order. See the alpha page table accessors for the\n\t * smp_read_barrier_depends() barriers in page table walking code.\n\t */\n\tsmp_wmb(); /* Could be smp_wmb__xxx(before|after)_spin_lock */\n\n\tptl = pmd_lock(mm, pmd);\n\tif (likely(pmd_none(*pmd))) {\t/* Has another populated it ? */\n\t\tmm_inc_nr_ptes(mm);\n\t\tpmd_populate(mm, pmd, new);\n\t\tnew = NULL;\n\t}\n\tspin_unlock(ptl);\n\tif (new)\n\t\tpte_free(mm, new);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_devmap",
          "args": [
            "*pmdp"
          ],
          "line": 2589
        },
        "resolved": true,
        "details": {
          "function_name": "pmd_devmap_trans_unstable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3023-3026",
          "snippet": "static int pmd_devmap_trans_unstable(pmd_t *pmd)\n{\n\treturn pmd_devmap(*pmd) || pmd_trans_unstable(pmd);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic int pmd_devmap_trans_unstable(pmd_t *pmd)\n{\n\treturn pmd_devmap(*pmd) || pmd_trans_unstable(pmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_trans_huge",
          "args": [
            "*pmdp"
          ],
          "line": 2589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_alloc",
          "args": [
            "mm",
            "pudp",
            "addr"
          ],
          "line": 2585
        },
        "resolved": true,
        "details": {
          "function_name": "__pmd_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "4004-4029",
          "snippet": "int __pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)\n{\n\tspinlock_t *ptl;\n\tpmd_t *new = pmd_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tptl = pud_lock(mm, pud);\n#ifndef __ARCH_HAS_4LEVEL_HACK\n\tif (!pud_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpud_populate(mm, pud, new);\n\t} else\t/* Another has populated it */\n\t\tpmd_free(mm, new);\n#else\n\tif (!pgd_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpgd_populate(mm, pud, new);\n\t} else /* Another has populated it */\n\t\tpmd_free(mm, new);\n#endif /* __ARCH_HAS_4LEVEL_HACK */\n\tspin_unlock(ptl);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)\n{\n\tspinlock_t *ptl;\n\tpmd_t *new = pmd_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tptl = pud_lock(mm, pud);\n#ifndef __ARCH_HAS_4LEVEL_HACK\n\tif (!pud_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpud_populate(mm, pud, new);\n\t} else\t/* Another has populated it */\n\t\tpmd_free(mm, new);\n#else\n\tif (!pgd_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpgd_populate(mm, pud, new);\n\t} else /* Another has populated it */\n\t\tpmd_free(mm, new);\n#endif /* __ARCH_HAS_4LEVEL_HACK */\n\tspin_unlock(ptl);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pud_alloc",
          "args": [
            "mm",
            "p4dp",
            "addr"
          ],
          "line": 2582
        },
        "resolved": true,
        "details": {
          "function_name": "__pud_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3972-3996",
          "snippet": "int __pud_alloc(struct mm_struct *mm, p4d_t *p4d, unsigned long address)\n{\n\tpud_t *new = pud_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n#ifndef __ARCH_HAS_5LEVEL_HACK\n\tif (!p4d_present(*p4d)) {\n\t\tmm_inc_nr_puds(mm);\n\t\tp4d_populate(mm, p4d, new);\n\t} else\t/* Another has populated it */\n\t\tpud_free(mm, new);\n#else\n\tif (!pgd_present(*p4d)) {\n\t\tmm_inc_nr_puds(mm);\n\t\tpgd_populate(mm, p4d, new);\n\t} else\t/* Another has populated it */\n\t\tpud_free(mm, new);\n#endif /* __ARCH_HAS_5LEVEL_HACK */\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __pud_alloc(struct mm_struct *mm, p4d_t *p4d, unsigned long address)\n{\n\tpud_t *new = pud_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n#ifndef __ARCH_HAS_5LEVEL_HACK\n\tif (!p4d_present(*p4d)) {\n\t\tmm_inc_nr_puds(mm);\n\t\tp4d_populate(mm, p4d, new);\n\t} else\t/* Another has populated it */\n\t\tpud_free(mm, new);\n#else\n\tif (!pgd_present(*p4d)) {\n\t\tmm_inc_nr_puds(mm);\n\t\tpgd_populate(mm, p4d, new);\n\t} else\t/* Another has populated it */\n\t\tpud_free(mm, new);\n#endif /* __ARCH_HAS_5LEVEL_HACK */\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p4d_alloc",
          "args": [
            "mm",
            "pgdp",
            "addr"
          ],
          "line": 2579
        },
        "resolved": true,
        "details": {
          "function_name": "__p4d_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3949-3964",
          "snippet": "int __p4d_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address)\n{\n\tp4d_t *new = p4d_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n\tif (pgd_present(*pgd))\t\t/* Another has populated it */\n\t\tp4d_free(mm, new);\n\telse\n\t\tpgd_populate(mm, pgd, new);\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __p4d_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address)\n{\n\tp4d_t *new = p4d_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n\tif (pgd_present(*pgd))\t\t/* Another has populated it */\n\t\tp4d_free(mm, new);\n\telse\n\t\tpgd_populate(mm, pgd, new);\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgd_offset",
          "args": [
            "mm",
            "addr"
          ],
          "line": 2578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_is_anonymous",
          "args": [
            "vma"
          ],
          "line": 2575
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic void migrate_vma_insert_page(struct migrate_vma *migrate,\n\t\t\t\t    unsigned long addr,\n\t\t\t\t    struct page *page,\n\t\t\t\t    unsigned long *src,\n\t\t\t\t    unsigned long *dst)\n{\n\tstruct vm_area_struct *vma = migrate->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct mem_cgroup *memcg;\n\tbool flush = false;\n\tspinlock_t *ptl;\n\tpte_t entry;\n\tpgd_t *pgdp;\n\tp4d_t *p4dp;\n\tpud_t *pudp;\n\tpmd_t *pmdp;\n\tpte_t *ptep;\n\n\t/* Only allow populating anonymous memory */\n\tif (!vma_is_anonymous(vma))\n\t\tgoto abort;\n\n\tpgdp = pgd_offset(mm, addr);\n\tp4dp = p4d_alloc(mm, pgdp, addr);\n\tif (!p4dp)\n\t\tgoto abort;\n\tpudp = pud_alloc(mm, p4dp, addr);\n\tif (!pudp)\n\t\tgoto abort;\n\tpmdp = pmd_alloc(mm, pudp, addr);\n\tif (!pmdp)\n\t\tgoto abort;\n\n\tif (pmd_trans_huge(*pmdp) || pmd_devmap(*pmdp))\n\t\tgoto abort;\n\n\t/*\n\t * Use pte_alloc() instead of pte_alloc_map().  We can't run\n\t * pte_offset_map() on pmds where a huge pmd might be created\n\t * from a different thread.\n\t *\n\t * pte_alloc_map() is safe to use under down_write(mmap_sem) or when\n\t * parallel threads are excluded by other means.\n\t *\n\t * Here we only have down_read(mmap_sem).\n\t */\n\tif (pte_alloc(mm, pmdp, addr))\n\t\tgoto abort;\n\n\t/* See the comment in pte_alloc_one_map() */\n\tif (unlikely(pmd_trans_unstable(pmdp)))\n\t\tgoto abort;\n\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\tgoto abort;\n\tif (mem_cgroup_try_charge(page, vma->vm_mm, GFP_KERNEL, &memcg, false))\n\t\tgoto abort;\n\n\t/*\n\t * The memory barrier inside __SetPageUptodate makes sure that\n\t * preceding stores to the page contents become visible before\n\t * the set_pte_at() write.\n\t */\n\t__SetPageUptodate(page);\n\n\tif (is_zone_device_page(page)) {\n\t\tif (is_device_private_page(page)) {\n\t\t\tswp_entry_t swp_entry;\n\n\t\t\tswp_entry = make_device_private_entry(page, vma->vm_flags & VM_WRITE);\n\t\t\tentry = swp_entry_to_pte(swp_entry);\n\t\t} else if (is_device_public_page(page)) {\n\t\t\tentry = pte_mkold(mk_pte(page, READ_ONCE(vma->vm_page_prot)));\n\t\t\tif (vma->vm_flags & VM_WRITE)\n\t\t\t\tentry = pte_mkwrite(pte_mkdirty(entry));\n\t\t\tentry = pte_mkdevmap(entry);\n\t\t}\n\t} else {\n\t\tentry = mk_pte(page, vma->vm_page_prot);\n\t\tif (vma->vm_flags & VM_WRITE)\n\t\t\tentry = pte_mkwrite(pte_mkdirty(entry));\n\t}\n\n\tptep = pte_offset_map_lock(mm, pmdp, addr, &ptl);\n\n\tif (pte_present(*ptep)) {\n\t\tunsigned long pfn = pte_pfn(*ptep);\n\n\t\tif (!is_zero_pfn(pfn)) {\n\t\t\tpte_unmap_unlock(ptep, ptl);\n\t\t\tmem_cgroup_cancel_charge(page, memcg, false);\n\t\t\tgoto abort;\n\t\t}\n\t\tflush = true;\n\t} else if (!pte_none(*ptep)) {\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\tmem_cgroup_cancel_charge(page, memcg, false);\n\t\tgoto abort;\n\t}\n\n\t/*\n\t * Check for usefaultfd but do not deliver the fault. Instead,\n\t * just back off.\n\t */\n\tif (userfaultfd_missing(vma)) {\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\tmem_cgroup_cancel_charge(page, memcg, false);\n\t\tgoto abort;\n\t}\n\n\tinc_mm_counter(mm, MM_ANONPAGES);\n\tpage_add_new_anon_rmap(page, vma, addr, false);\n\tmem_cgroup_commit_charge(page, memcg, false, false);\n\tif (!is_zone_device_page(page))\n\t\tlru_cache_add_active_or_unevictable(page, vma);\n\tget_page(page);\n\n\tif (flush) {\n\t\tflush_cache_page(vma, addr, pte_pfn(*ptep));\n\t\tptep_clear_flush_notify(vma, addr, ptep);\n\t\tset_pte_at_notify(mm, addr, ptep, entry);\n\t\tupdate_mmu_cache(vma, addr, ptep);\n\t} else {\n\t\t/* No need to invalidate - it was non-present before */\n\t\tset_pte_at(mm, addr, ptep, entry);\n\t\tupdate_mmu_cache(vma, addr, ptep);\n\t}\n\n\tpte_unmap_unlock(ptep, ptl);\n\t*src = MIGRATE_PFN_MIGRATE;\n\treturn;\n\nabort:\n\t*src &= ~MIGRATE_PFN_MIGRATE;\n}"
  },
  {
    "function_name": "migrate_vma_unmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "2509-2554",
    "snippet": "static void migrate_vma_unmap(struct migrate_vma *migrate)\n{\n\tint flags = TTU_MIGRATION | TTU_IGNORE_MLOCK | TTU_IGNORE_ACCESS;\n\tconst unsigned long npages = migrate->npages;\n\tconst unsigned long start = migrate->start;\n\tunsigned long addr, i, restore = 0;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tstruct page *page = migrate_pfn_to_page(migrate->src[i]);\n\n\t\tif (!page || !(migrate->src[i] & MIGRATE_PFN_MIGRATE))\n\t\t\tcontinue;\n\n\t\tif (page_mapped(page)) {\n\t\t\ttry_to_unmap(page, flags);\n\t\t\tif (page_mapped(page))\n\t\t\t\tgoto restore;\n\t\t}\n\n\t\tif (migrate_vma_check_page(page))\n\t\t\tcontinue;\n\nrestore:\n\t\tmigrate->src[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\tmigrate->cpages--;\n\t\trestore++;\n\t}\n\n\tfor (addr = start, i = 0; i < npages && restore; addr += PAGE_SIZE, i++) {\n\t\tstruct page *page = migrate_pfn_to_page(migrate->src[i]);\n\n\t\tif (!page || (migrate->src[i] & MIGRATE_PFN_MIGRATE))\n\t\t\tcontinue;\n\n\t\tremove_migration_ptes(page, page, false);\n\n\t\tmigrate->src[i] = 0;\n\t\tunlock_page(page);\n\t\trestore--;\n\n\t\tif (is_zone_device_page(page))\n\t\t\tput_page(page);\n\t\telse\n\t\t\tputback_lru_page(page);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "putback_lru_page",
          "args": [
            "page"
          ],
          "line": 2552
        },
        "resolved": true,
        "details": {
          "function_name": "putback_lru_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1005-1009",
          "snippet": "void putback_lru_page(struct page *page)\n{\n\tlru_cache_add(page);\n\tput_page(page);\t\t/* drop ref from isolate */\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid putback_lru_page(struct page *page)\n{\n\tlru_cache_add(page);\n\tput_page(page);\t\t/* drop ref from isolate */\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 2550
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_zone_device_page",
          "args": [
            "page"
          ],
          "line": 2549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2546
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_migration_ptes",
          "args": [
            "page",
            "page",
            "false"
          ],
          "line": 2543
        },
        "resolved": true,
        "details": {
          "function_name": "remove_migration_ptes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "292-303",
          "snippet": "void remove_migration_ptes(struct page *old, struct page *new, bool locked)\n{\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = remove_migration_pte,\n\t\t.arg = old,\n\t};\n\n\tif (locked)\n\t\trmap_walk_locked(new, &rwc);\n\telse\n\t\trmap_walk(new, &rwc);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nvoid remove_migration_ptes(struct page *old, struct page *new, bool locked)\n{\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = remove_migration_pte,\n\t\t.arg = old,\n\t};\n\n\tif (locked)\n\t\trmap_walk_locked(new, &rwc);\n\telse\n\t\trmap_walk(new, &rwc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "migrate_pfn_to_page",
          "args": [
            "migrate->src[i]"
          ],
          "line": 2538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_vma_check_page",
          "args": [
            "page"
          ],
          "line": 2528
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_vma_check_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "2336-2388",
          "snippet": "static bool migrate_vma_check_page(struct page *page)\n{\n\t/*\n\t * One extra ref because caller holds an extra reference, either from\n\t * isolate_lru_page() for a regular page, or migrate_vma_collect() for\n\t * a device page.\n\t */\n\tint extra = 1;\n\n\t/*\n\t * FIXME support THP (transparent huge page), it is bit more complex to\n\t * check them than regular pages, because they can be mapped with a pmd\n\t * or with a pte (split pte mapping).\n\t */\n\tif (PageCompound(page))\n\t\treturn false;\n\n\t/* Page from ZONE_DEVICE have one extra reference */\n\tif (is_zone_device_page(page)) {\n\t\t/*\n\t\t * Private page can never be pin as they have no valid pte and\n\t\t * GUP will fail for those. Yet if there is a pending migration\n\t\t * a thread might try to wait on the pte migration entry and\n\t\t * will bump the page reference count. Sadly there is no way to\n\t\t * differentiate a regular pin from migration wait. Hence to\n\t\t * avoid 2 racing thread trying to migrate back to CPU to enter\n\t\t * infinite loop (one stoping migration because the other is\n\t\t * waiting on pte migration entry). We always return true here.\n\t\t *\n\t\t * FIXME proper solution is to rework migration_entry_wait() so\n\t\t * it does not need to take a reference on page.\n\t\t */\n\t\tif (is_device_private_page(page))\n\t\t\treturn true;\n\n\t\t/*\n\t\t * Only allow device public page to be migrated and account for\n\t\t * the extra reference count imply by ZONE_DEVICE pages.\n\t\t */\n\t\tif (!is_device_public_page(page))\n\t\t\treturn false;\n\t\textra++;\n\t}\n\n\t/* For file back page */\n\tif (page_mapping(page))\n\t\textra += 1 + page_has_private(page);\n\n\tif ((page_count(page) - extra) > page_mapcount(page))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic bool migrate_vma_check_page(struct page *page)\n{\n\t/*\n\t * One extra ref because caller holds an extra reference, either from\n\t * isolate_lru_page() for a regular page, or migrate_vma_collect() for\n\t * a device page.\n\t */\n\tint extra = 1;\n\n\t/*\n\t * FIXME support THP (transparent huge page), it is bit more complex to\n\t * check them than regular pages, because they can be mapped with a pmd\n\t * or with a pte (split pte mapping).\n\t */\n\tif (PageCompound(page))\n\t\treturn false;\n\n\t/* Page from ZONE_DEVICE have one extra reference */\n\tif (is_zone_device_page(page)) {\n\t\t/*\n\t\t * Private page can never be pin as they have no valid pte and\n\t\t * GUP will fail for those. Yet if there is a pending migration\n\t\t * a thread might try to wait on the pte migration entry and\n\t\t * will bump the page reference count. Sadly there is no way to\n\t\t * differentiate a regular pin from migration wait. Hence to\n\t\t * avoid 2 racing thread trying to migrate back to CPU to enter\n\t\t * infinite loop (one stoping migration because the other is\n\t\t * waiting on pte migration entry). We always return true here.\n\t\t *\n\t\t * FIXME proper solution is to rework migration_entry_wait() so\n\t\t * it does not need to take a reference on page.\n\t\t */\n\t\tif (is_device_private_page(page))\n\t\t\treturn true;\n\n\t\t/*\n\t\t * Only allow device public page to be migrated and account for\n\t\t * the extra reference count imply by ZONE_DEVICE pages.\n\t\t */\n\t\tif (!is_device_public_page(page))\n\t\t\treturn false;\n\t\textra++;\n\t}\n\n\t/* For file back page */\n\tif (page_mapping(page))\n\t\textra += 1 + page_has_private(page);\n\n\tif ((page_count(page) - extra) > page_mapcount(page))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_mapped",
          "args": [
            "page"
          ],
          "line": 2524
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "470-486",
          "snippet": "bool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nbool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_unmap",
          "args": [
            "page",
            "flags"
          ],
          "line": 2523
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_unmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1699-1726",
          "snippet": "bool try_to_unmap(struct page *page, enum ttu_flags flags)\n{\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = try_to_unmap_one,\n\t\t.arg = (void *)flags,\n\t\t.done = page_mapcount_is_zero,\n\t\t.anon_lock = page_lock_anon_vma_read,\n\t};\n\n\t/*\n\t * During exec, a temporary VMA is setup and later moved.\n\t * The VMA is moved under the anon_vma lock but not the\n\t * page tables leading to a race where migration cannot\n\t * find the migration ptes. Rather than increasing the\n\t * locking requirements of exec(), migration skips\n\t * temporary VMAs until after exec() completes.\n\t */\n\tif ((flags & (TTU_MIGRATION|TTU_SPLIT_FREEZE))\n\t    && !PageKsm(page) && PageAnon(page))\n\t\trwc.invalid_vma = invalid_migration_vma;\n\n\tif (flags & TTU_RMAP_LOCKED)\n\t\trmap_walk_locked(page, &rwc);\n\telse\n\t\trmap_walk(page, &rwc);\n\n\treturn !page_mapcount(page) ? true : false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nbool try_to_unmap(struct page *page, enum ttu_flags flags)\n{\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = try_to_unmap_one,\n\t\t.arg = (void *)flags,\n\t\t.done = page_mapcount_is_zero,\n\t\t.anon_lock = page_lock_anon_vma_read,\n\t};\n\n\t/*\n\t * During exec, a temporary VMA is setup and later moved.\n\t * The VMA is moved under the anon_vma lock but not the\n\t * page tables leading to a race where migration cannot\n\t * find the migration ptes. Rather than increasing the\n\t * locking requirements of exec(), migration skips\n\t * temporary VMAs until after exec() completes.\n\t */\n\tif ((flags & (TTU_MIGRATION|TTU_SPLIT_FREEZE))\n\t    && !PageKsm(page) && PageAnon(page))\n\t\trwc.invalid_vma = invalid_migration_vma;\n\n\tif (flags & TTU_RMAP_LOCKED)\n\t\trmap_walk_locked(page, &rwc);\n\telse\n\t\trmap_walk(page, &rwc);\n\n\treturn !page_mapcount(page) ? true : false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "migrate_pfn_to_page",
          "args": [
            "migrate->src[i]"
          ],
          "line": 2517
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic void migrate_vma_unmap(struct migrate_vma *migrate)\n{\n\tint flags = TTU_MIGRATION | TTU_IGNORE_MLOCK | TTU_IGNORE_ACCESS;\n\tconst unsigned long npages = migrate->npages;\n\tconst unsigned long start = migrate->start;\n\tunsigned long addr, i, restore = 0;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tstruct page *page = migrate_pfn_to_page(migrate->src[i]);\n\n\t\tif (!page || !(migrate->src[i] & MIGRATE_PFN_MIGRATE))\n\t\t\tcontinue;\n\n\t\tif (page_mapped(page)) {\n\t\t\ttry_to_unmap(page, flags);\n\t\t\tif (page_mapped(page))\n\t\t\t\tgoto restore;\n\t\t}\n\n\t\tif (migrate_vma_check_page(page))\n\t\t\tcontinue;\n\nrestore:\n\t\tmigrate->src[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\tmigrate->cpages--;\n\t\trestore++;\n\t}\n\n\tfor (addr = start, i = 0; i < npages && restore; addr += PAGE_SIZE, i++) {\n\t\tstruct page *page = migrate_pfn_to_page(migrate->src[i]);\n\n\t\tif (!page || (migrate->src[i] & MIGRATE_PFN_MIGRATE))\n\t\t\tcontinue;\n\n\t\tremove_migration_ptes(page, page, false);\n\n\t\tmigrate->src[i] = 0;\n\t\tunlock_page(page);\n\t\trestore--;\n\n\t\tif (is_zone_device_page(page))\n\t\t\tput_page(page);\n\t\telse\n\t\t\tputback_lru_page(page);\n\t}\n}"
  },
  {
    "function_name": "migrate_vma_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "2399-2496",
    "snippet": "static void migrate_vma_prepare(struct migrate_vma *migrate)\n{\n\tconst unsigned long npages = migrate->npages;\n\tconst unsigned long start = migrate->start;\n\tunsigned long addr, i, restore = 0;\n\tbool allow_drain = true;\n\n\tlru_add_drain();\n\n\tfor (i = 0; (i < npages) && migrate->cpages; i++) {\n\t\tstruct page *page = migrate_pfn_to_page(migrate->src[i]);\n\t\tbool remap = true;\n\n\t\tif (!page)\n\t\t\tcontinue;\n\n\t\tif (!(migrate->src[i] & MIGRATE_PFN_LOCKED)) {\n\t\t\t/*\n\t\t\t * Because we are migrating several pages there can be\n\t\t\t * a deadlock between 2 concurrent migration where each\n\t\t\t * are waiting on each other page lock.\n\t\t\t *\n\t\t\t * Make migrate_vma() a best effort thing and backoff\n\t\t\t * for any page we can not lock right away.\n\t\t\t */\n\t\t\tif (!trylock_page(page)) {\n\t\t\t\tmigrate->src[i] = 0;\n\t\t\t\tmigrate->cpages--;\n\t\t\t\tput_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tremap = false;\n\t\t\tmigrate->src[i] |= MIGRATE_PFN_LOCKED;\n\t\t}\n\n\t\t/* ZONE_DEVICE pages are not on LRU */\n\t\tif (!is_zone_device_page(page)) {\n\t\t\tif (!PageLRU(page) && allow_drain) {\n\t\t\t\t/* Drain CPU's pagevec */\n\t\t\t\tlru_add_drain_all();\n\t\t\t\tallow_drain = false;\n\t\t\t}\n\n\t\t\tif (isolate_lru_page(page)) {\n\t\t\t\tif (remap) {\n\t\t\t\t\tmigrate->src[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t\t\t\tmigrate->cpages--;\n\t\t\t\t\trestore++;\n\t\t\t\t} else {\n\t\t\t\t\tmigrate->src[i] = 0;\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tmigrate->cpages--;\n\t\t\t\t\tput_page(page);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Drop the reference we took in collect */\n\t\t\tput_page(page);\n\t\t}\n\n\t\tif (!migrate_vma_check_page(page)) {\n\t\t\tif (remap) {\n\t\t\t\tmigrate->src[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t\t\tmigrate->cpages--;\n\t\t\t\trestore++;\n\n\t\t\t\tif (!is_zone_device_page(page)) {\n\t\t\t\t\tget_page(page);\n\t\t\t\t\tputback_lru_page(page);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmigrate->src[i] = 0;\n\t\t\t\tunlock_page(page);\n\t\t\t\tmigrate->cpages--;\n\n\t\t\t\tif (!is_zone_device_page(page))\n\t\t\t\t\tputback_lru_page(page);\n\t\t\t\telse\n\t\t\t\t\tput_page(page);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0, addr = start; i < npages && restore; i++, addr += PAGE_SIZE) {\n\t\tstruct page *page = migrate_pfn_to_page(migrate->src[i]);\n\n\t\tif (!page || (migrate->src[i] & MIGRATE_PFN_MIGRATE))\n\t\t\tcontinue;\n\n\t\tremove_migration_pte(page, migrate->vma, addr, page);\n\n\t\tmigrate->src[i] = 0;\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\trestore--;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 2493
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2492
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_migration_pte",
          "args": [
            "page",
            "migrate->vma",
            "addr",
            "page"
          ],
          "line": 2489
        },
        "resolved": true,
        "details": {
          "function_name": "remove_migration_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "203-286",
          "snippet": "static bool remove_migration_pte(struct page *page, struct vm_area_struct *vma,\n\t\t\t\t unsigned long addr, void *old)\n{\n\tstruct page_vma_mapped_walk pvmw = {\n\t\t.page = old,\n\t\t.vma = vma,\n\t\t.address = addr,\n\t\t.flags = PVMW_SYNC | PVMW_MIGRATION,\n\t};\n\tstruct page *new;\n\tpte_t pte;\n\tswp_entry_t entry;\n\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\twhile (page_vma_mapped_walk(&pvmw)) {\n\t\tif (PageKsm(page))\n\t\t\tnew = page;\n\t\telse\n\t\t\tnew = page - pvmw.page->index +\n\t\t\t\tlinear_page_index(vma, pvmw.address);\n\n#ifdef CONFIG_ARCH_ENABLE_THP_MIGRATION\n\t\t/* PMD-mapped THP migration entry */\n\t\tif (!pvmw.pte) {\n\t\t\tVM_BUG_ON_PAGE(PageHuge(page) || !PageTransCompound(page), page);\n\t\t\tremove_migration_pmd(&pvmw, new);\n\t\t\tcontinue;\n\t\t}\n#endif\n\n\t\tget_page(new);\n\t\tpte = pte_mkold(mk_pte(new, READ_ONCE(vma->vm_page_prot)));\n\t\tif (pte_swp_soft_dirty(*pvmw.pte))\n\t\t\tpte = pte_mksoft_dirty(pte);\n\n\t\t/*\n\t\t * Recheck VMA as permissions can change since migration started\n\t\t */\n\t\tentry = pte_to_swp_entry(*pvmw.pte);\n\t\tif (is_write_migration_entry(entry))\n\t\t\tpte = maybe_mkwrite(pte, vma);\n\n\t\tif (unlikely(is_zone_device_page(new))) {\n\t\t\tif (is_device_private_page(new)) {\n\t\t\t\tentry = make_device_private_entry(new, pte_write(pte));\n\t\t\t\tpte = swp_entry_to_pte(entry);\n\t\t\t} else if (is_device_public_page(new)) {\n\t\t\t\tpte = pte_mkdevmap(pte);\n\t\t\t\tflush_dcache_page(new);\n\t\t\t}\n\t\t} else\n\t\t\tflush_dcache_page(new);\n\n#ifdef CONFIG_HUGETLB_PAGE\n\t\tif (PageHuge(new)) {\n\t\t\tpte = pte_mkhuge(pte);\n\t\t\tpte = arch_make_huge_pte(pte, vma, new, 0);\n\t\t\tset_huge_pte_at(vma->vm_mm, pvmw.address, pvmw.pte, pte);\n\t\t\tif (PageAnon(new))\n\t\t\t\thugepage_add_anon_rmap(new, vma, pvmw.address);\n\t\t\telse\n\t\t\t\tpage_dup_rmap(new, true);\n\t\t} else\n#endif\n\t\t{\n\t\t\tset_pte_at(vma->vm_mm, pvmw.address, pvmw.pte, pte);\n\n\t\t\tif (PageAnon(new))\n\t\t\t\tpage_add_anon_rmap(new, vma, pvmw.address, false);\n\t\t\telse\n\t\t\t\tpage_add_file_rmap(new, false);\n\t\t}\n\t\tif (vma->vm_flags & VM_LOCKED && !PageTransCompound(new))\n\t\t\tmlock_vma_page(new);\n\n\t\tif (PageTransHuge(page) && PageMlocked(page))\n\t\t\tclear_page_mlock(page);\n\n\t\t/* No need to invalidate - it was non-present before */\n\t\tupdate_mmu_cache(vma, pvmw.address, pvmw.pte);\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic bool remove_migration_pte(struct page *page, struct vm_area_struct *vma,\n\t\t\t\t unsigned long addr, void *old)\n{\n\tstruct page_vma_mapped_walk pvmw = {\n\t\t.page = old,\n\t\t.vma = vma,\n\t\t.address = addr,\n\t\t.flags = PVMW_SYNC | PVMW_MIGRATION,\n\t};\n\tstruct page *new;\n\tpte_t pte;\n\tswp_entry_t entry;\n\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\twhile (page_vma_mapped_walk(&pvmw)) {\n\t\tif (PageKsm(page))\n\t\t\tnew = page;\n\t\telse\n\t\t\tnew = page - pvmw.page->index +\n\t\t\t\tlinear_page_index(vma, pvmw.address);\n\n#ifdef CONFIG_ARCH_ENABLE_THP_MIGRATION\n\t\t/* PMD-mapped THP migration entry */\n\t\tif (!pvmw.pte) {\n\t\t\tVM_BUG_ON_PAGE(PageHuge(page) || !PageTransCompound(page), page);\n\t\t\tremove_migration_pmd(&pvmw, new);\n\t\t\tcontinue;\n\t\t}\n#endif\n\n\t\tget_page(new);\n\t\tpte = pte_mkold(mk_pte(new, READ_ONCE(vma->vm_page_prot)));\n\t\tif (pte_swp_soft_dirty(*pvmw.pte))\n\t\t\tpte = pte_mksoft_dirty(pte);\n\n\t\t/*\n\t\t * Recheck VMA as permissions can change since migration started\n\t\t */\n\t\tentry = pte_to_swp_entry(*pvmw.pte);\n\t\tif (is_write_migration_entry(entry))\n\t\t\tpte = maybe_mkwrite(pte, vma);\n\n\t\tif (unlikely(is_zone_device_page(new))) {\n\t\t\tif (is_device_private_page(new)) {\n\t\t\t\tentry = make_device_private_entry(new, pte_write(pte));\n\t\t\t\tpte = swp_entry_to_pte(entry);\n\t\t\t} else if (is_device_public_page(new)) {\n\t\t\t\tpte = pte_mkdevmap(pte);\n\t\t\t\tflush_dcache_page(new);\n\t\t\t}\n\t\t} else\n\t\t\tflush_dcache_page(new);\n\n#ifdef CONFIG_HUGETLB_PAGE\n\t\tif (PageHuge(new)) {\n\t\t\tpte = pte_mkhuge(pte);\n\t\t\tpte = arch_make_huge_pte(pte, vma, new, 0);\n\t\t\tset_huge_pte_at(vma->vm_mm, pvmw.address, pvmw.pte, pte);\n\t\t\tif (PageAnon(new))\n\t\t\t\thugepage_add_anon_rmap(new, vma, pvmw.address);\n\t\t\telse\n\t\t\t\tpage_dup_rmap(new, true);\n\t\t} else\n#endif\n\t\t{\n\t\t\tset_pte_at(vma->vm_mm, pvmw.address, pvmw.pte, pte);\n\n\t\t\tif (PageAnon(new))\n\t\t\t\tpage_add_anon_rmap(new, vma, pvmw.address, false);\n\t\t\telse\n\t\t\t\tpage_add_file_rmap(new, false);\n\t\t}\n\t\tif (vma->vm_flags & VM_LOCKED && !PageTransCompound(new))\n\t\t\tmlock_vma_page(new);\n\n\t\tif (PageTransHuge(page) && PageMlocked(page))\n\t\t\tclear_page_mlock(page);\n\n\t\t/* No need to invalidate - it was non-present before */\n\t\tupdate_mmu_cache(vma, pvmw.address, pvmw.pte);\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "migrate_pfn_to_page",
          "args": [
            "migrate->src[i]"
          ],
          "line": 2484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "putback_lru_page",
          "args": [
            "page"
          ],
          "line": 2476
        },
        "resolved": true,
        "details": {
          "function_name": "putback_lru_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1005-1009",
          "snippet": "void putback_lru_page(struct page *page)\n{\n\tlru_cache_add(page);\n\tput_page(page);\t\t/* drop ref from isolate */\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid putback_lru_page(struct page *page)\n{\n\tlru_cache_add(page);\n\tput_page(page);\t\t/* drop ref from isolate */\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_zone_device_page",
          "args": [
            "page"
          ],
          "line": 2475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "page"
          ],
          "line": 2467
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_zone_device_page",
          "args": [
            "page"
          ],
          "line": 2466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_vma_check_page",
          "args": [
            "page"
          ],
          "line": 2460
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_vma_check_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "2336-2388",
          "snippet": "static bool migrate_vma_check_page(struct page *page)\n{\n\t/*\n\t * One extra ref because caller holds an extra reference, either from\n\t * isolate_lru_page() for a regular page, or migrate_vma_collect() for\n\t * a device page.\n\t */\n\tint extra = 1;\n\n\t/*\n\t * FIXME support THP (transparent huge page), it is bit more complex to\n\t * check them than regular pages, because they can be mapped with a pmd\n\t * or with a pte (split pte mapping).\n\t */\n\tif (PageCompound(page))\n\t\treturn false;\n\n\t/* Page from ZONE_DEVICE have one extra reference */\n\tif (is_zone_device_page(page)) {\n\t\t/*\n\t\t * Private page can never be pin as they have no valid pte and\n\t\t * GUP will fail for those. Yet if there is a pending migration\n\t\t * a thread might try to wait on the pte migration entry and\n\t\t * will bump the page reference count. Sadly there is no way to\n\t\t * differentiate a regular pin from migration wait. Hence to\n\t\t * avoid 2 racing thread trying to migrate back to CPU to enter\n\t\t * infinite loop (one stoping migration because the other is\n\t\t * waiting on pte migration entry). We always return true here.\n\t\t *\n\t\t * FIXME proper solution is to rework migration_entry_wait() so\n\t\t * it does not need to take a reference on page.\n\t\t */\n\t\tif (is_device_private_page(page))\n\t\t\treturn true;\n\n\t\t/*\n\t\t * Only allow device public page to be migrated and account for\n\t\t * the extra reference count imply by ZONE_DEVICE pages.\n\t\t */\n\t\tif (!is_device_public_page(page))\n\t\t\treturn false;\n\t\textra++;\n\t}\n\n\t/* For file back page */\n\tif (page_mapping(page))\n\t\textra += 1 + page_has_private(page);\n\n\tif ((page_count(page) - extra) > page_mapcount(page))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic bool migrate_vma_check_page(struct page *page)\n{\n\t/*\n\t * One extra ref because caller holds an extra reference, either from\n\t * isolate_lru_page() for a regular page, or migrate_vma_collect() for\n\t * a device page.\n\t */\n\tint extra = 1;\n\n\t/*\n\t * FIXME support THP (transparent huge page), it is bit more complex to\n\t * check them than regular pages, because they can be mapped with a pmd\n\t * or with a pte (split pte mapping).\n\t */\n\tif (PageCompound(page))\n\t\treturn false;\n\n\t/* Page from ZONE_DEVICE have one extra reference */\n\tif (is_zone_device_page(page)) {\n\t\t/*\n\t\t * Private page can never be pin as they have no valid pte and\n\t\t * GUP will fail for those. Yet if there is a pending migration\n\t\t * a thread might try to wait on the pte migration entry and\n\t\t * will bump the page reference count. Sadly there is no way to\n\t\t * differentiate a regular pin from migration wait. Hence to\n\t\t * avoid 2 racing thread trying to migrate back to CPU to enter\n\t\t * infinite loop (one stoping migration because the other is\n\t\t * waiting on pte migration entry). We always return true here.\n\t\t *\n\t\t * FIXME proper solution is to rework migration_entry_wait() so\n\t\t * it does not need to take a reference on page.\n\t\t */\n\t\tif (is_device_private_page(page))\n\t\t\treturn true;\n\n\t\t/*\n\t\t * Only allow device public page to be migrated and account for\n\t\t * the extra reference count imply by ZONE_DEVICE pages.\n\t\t */\n\t\tif (!is_device_public_page(page))\n\t\t\treturn false;\n\t\textra++;\n\t}\n\n\t/* For file back page */\n\tif (page_mapping(page))\n\t\textra += 1 + page_has_private(page);\n\n\tif ((page_count(page) - extra) > page_mapcount(page))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isolate_lru_page",
          "args": [
            "page"
          ],
          "line": 2442
        },
        "resolved": true,
        "details": {
          "function_name": "isolate_lru_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1772-1795",
          "snippet": "int isolate_lru_page(struct page *page)\n{\n\tint ret = -EBUSY;\n\n\tVM_BUG_ON_PAGE(!page_count(page), page);\n\tWARN_RATELIMIT(PageTail(page), \"trying to isolate tail page\");\n\n\tif (PageLRU(page)) {\n\t\tstruct zone *zone = page_zone(page);\n\t\tstruct lruvec *lruvec;\n\n\t\tspin_lock_irq(zone_lru_lock(zone));\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\t\tif (PageLRU(page)) {\n\t\t\tint lru = page_lru(page);\n\t\t\tget_page(page);\n\t\t\tClearPageLRU(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, lru);\n\t\t\tret = 0;\n\t\t}\n\t\tspin_unlock_irq(zone_lru_lock(zone));\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint isolate_lru_page(struct page *page)\n{\n\tint ret = -EBUSY;\n\n\tVM_BUG_ON_PAGE(!page_count(page), page);\n\tWARN_RATELIMIT(PageTail(page), \"trying to isolate tail page\");\n\n\tif (PageLRU(page)) {\n\t\tstruct zone *zone = page_zone(page);\n\t\tstruct lruvec *lruvec;\n\n\t\tspin_lock_irq(zone_lru_lock(zone));\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\t\tif (PageLRU(page)) {\n\t\t\tint lru = page_lru(page);\n\t\t\tget_page(page);\n\t\t\tClearPageLRU(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, lru);\n\t\t\tret = 0;\n\t\t}\n\t\tspin_unlock_irq(zone_lru_lock(zone));\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lru_add_drain_all",
          "args": [],
          "line": 2438
        },
        "resolved": true,
        "details": {
          "function_name": "lru_add_drain_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "670-704",
          "snippet": "void lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);",
            "static DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);",
            "static DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\nstatic DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);\nstatic DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);\n\nvoid lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 2436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_zone_device_page",
          "args": [
            "page"
          ],
          "line": 2435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 2424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_pfn_to_page",
          "args": [
            "migrate->src[i]"
          ],
          "line": 2409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic void migrate_vma_prepare(struct migrate_vma *migrate)\n{\n\tconst unsigned long npages = migrate->npages;\n\tconst unsigned long start = migrate->start;\n\tunsigned long addr, i, restore = 0;\n\tbool allow_drain = true;\n\n\tlru_add_drain();\n\n\tfor (i = 0; (i < npages) && migrate->cpages; i++) {\n\t\tstruct page *page = migrate_pfn_to_page(migrate->src[i]);\n\t\tbool remap = true;\n\n\t\tif (!page)\n\t\t\tcontinue;\n\n\t\tif (!(migrate->src[i] & MIGRATE_PFN_LOCKED)) {\n\t\t\t/*\n\t\t\t * Because we are migrating several pages there can be\n\t\t\t * a deadlock between 2 concurrent migration where each\n\t\t\t * are waiting on each other page lock.\n\t\t\t *\n\t\t\t * Make migrate_vma() a best effort thing and backoff\n\t\t\t * for any page we can not lock right away.\n\t\t\t */\n\t\t\tif (!trylock_page(page)) {\n\t\t\t\tmigrate->src[i] = 0;\n\t\t\t\tmigrate->cpages--;\n\t\t\t\tput_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tremap = false;\n\t\t\tmigrate->src[i] |= MIGRATE_PFN_LOCKED;\n\t\t}\n\n\t\t/* ZONE_DEVICE pages are not on LRU */\n\t\tif (!is_zone_device_page(page)) {\n\t\t\tif (!PageLRU(page) && allow_drain) {\n\t\t\t\t/* Drain CPU's pagevec */\n\t\t\t\tlru_add_drain_all();\n\t\t\t\tallow_drain = false;\n\t\t\t}\n\n\t\t\tif (isolate_lru_page(page)) {\n\t\t\t\tif (remap) {\n\t\t\t\t\tmigrate->src[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t\t\t\tmigrate->cpages--;\n\t\t\t\t\trestore++;\n\t\t\t\t} else {\n\t\t\t\t\tmigrate->src[i] = 0;\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tmigrate->cpages--;\n\t\t\t\t\tput_page(page);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Drop the reference we took in collect */\n\t\t\tput_page(page);\n\t\t}\n\n\t\tif (!migrate_vma_check_page(page)) {\n\t\t\tif (remap) {\n\t\t\t\tmigrate->src[i] &= ~MIGRATE_PFN_MIGRATE;\n\t\t\t\tmigrate->cpages--;\n\t\t\t\trestore++;\n\n\t\t\t\tif (!is_zone_device_page(page)) {\n\t\t\t\t\tget_page(page);\n\t\t\t\t\tputback_lru_page(page);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmigrate->src[i] = 0;\n\t\t\t\tunlock_page(page);\n\t\t\t\tmigrate->cpages--;\n\n\t\t\t\tif (!is_zone_device_page(page))\n\t\t\t\t\tputback_lru_page(page);\n\t\t\t\telse\n\t\t\t\t\tput_page(page);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0, addr = start; i < npages && restore; i++, addr += PAGE_SIZE) {\n\t\tstruct page *page = migrate_pfn_to_page(migrate->src[i]);\n\n\t\tif (!page || (migrate->src[i] & MIGRATE_PFN_MIGRATE))\n\t\t\tcontinue;\n\n\t\tremove_migration_pte(page, migrate->vma, addr, page);\n\n\t\tmigrate->src[i] = 0;\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\trestore--;\n\t}\n}"
  },
  {
    "function_name": "migrate_vma_check_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "2336-2388",
    "snippet": "static bool migrate_vma_check_page(struct page *page)\n{\n\t/*\n\t * One extra ref because caller holds an extra reference, either from\n\t * isolate_lru_page() for a regular page, or migrate_vma_collect() for\n\t * a device page.\n\t */\n\tint extra = 1;\n\n\t/*\n\t * FIXME support THP (transparent huge page), it is bit more complex to\n\t * check them than regular pages, because they can be mapped with a pmd\n\t * or with a pte (split pte mapping).\n\t */\n\tif (PageCompound(page))\n\t\treturn false;\n\n\t/* Page from ZONE_DEVICE have one extra reference */\n\tif (is_zone_device_page(page)) {\n\t\t/*\n\t\t * Private page can never be pin as they have no valid pte and\n\t\t * GUP will fail for those. Yet if there is a pending migration\n\t\t * a thread might try to wait on the pte migration entry and\n\t\t * will bump the page reference count. Sadly there is no way to\n\t\t * differentiate a regular pin from migration wait. Hence to\n\t\t * avoid 2 racing thread trying to migrate back to CPU to enter\n\t\t * infinite loop (one stoping migration because the other is\n\t\t * waiting on pte migration entry). We always return true here.\n\t\t *\n\t\t * FIXME proper solution is to rework migration_entry_wait() so\n\t\t * it does not need to take a reference on page.\n\t\t */\n\t\tif (is_device_private_page(page))\n\t\t\treturn true;\n\n\t\t/*\n\t\t * Only allow device public page to be migrated and account for\n\t\t * the extra reference count imply by ZONE_DEVICE pages.\n\t\t */\n\t\tif (!is_device_public_page(page))\n\t\t\treturn false;\n\t\textra++;\n\t}\n\n\t/* For file back page */\n\tif (page_mapping(page))\n\t\textra += 1 + page_has_private(page);\n\n\tif ((page_count(page) - extra) > page_mapcount(page))\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_mapcount",
          "args": [
            "page"
          ],
          "line": 2384
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 2384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_private",
          "args": [
            "page"
          ],
          "line": 2382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "page"
          ],
          "line": 2381
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapping_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "528-533",
          "snippet": "struct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_device_public_page",
          "args": [
            "page"
          ],
          "line": 2375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_device_private_page",
          "args": [
            "page"
          ],
          "line": 2368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_zone_device_page",
          "args": [
            "page"
          ],
          "line": 2354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "page"
          ],
          "line": 2350
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic bool migrate_vma_check_page(struct page *page)\n{\n\t/*\n\t * One extra ref because caller holds an extra reference, either from\n\t * isolate_lru_page() for a regular page, or migrate_vma_collect() for\n\t * a device page.\n\t */\n\tint extra = 1;\n\n\t/*\n\t * FIXME support THP (transparent huge page), it is bit more complex to\n\t * check them than regular pages, because they can be mapped with a pmd\n\t * or with a pte (split pte mapping).\n\t */\n\tif (PageCompound(page))\n\t\treturn false;\n\n\t/* Page from ZONE_DEVICE have one extra reference */\n\tif (is_zone_device_page(page)) {\n\t\t/*\n\t\t * Private page can never be pin as they have no valid pte and\n\t\t * GUP will fail for those. Yet if there is a pending migration\n\t\t * a thread might try to wait on the pte migration entry and\n\t\t * will bump the page reference count. Sadly there is no way to\n\t\t * differentiate a regular pin from migration wait. Hence to\n\t\t * avoid 2 racing thread trying to migrate back to CPU to enter\n\t\t * infinite loop (one stoping migration because the other is\n\t\t * waiting on pte migration entry). We always return true here.\n\t\t *\n\t\t * FIXME proper solution is to rework migration_entry_wait() so\n\t\t * it does not need to take a reference on page.\n\t\t */\n\t\tif (is_device_private_page(page))\n\t\t\treturn true;\n\n\t\t/*\n\t\t * Only allow device public page to be migrated and account for\n\t\t * the extra reference count imply by ZONE_DEVICE pages.\n\t\t */\n\t\tif (!is_device_public_page(page))\n\t\t\treturn false;\n\t\textra++;\n\t}\n\n\t/* For file back page */\n\tif (page_mapping(page))\n\t\textra += 1 + page_has_private(page);\n\n\tif ((page_count(page) - extra) > page_mapcount(page))\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "migrate_vma_collect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "2304-2326",
    "snippet": "static void migrate_vma_collect(struct migrate_vma *migrate)\n{\n\tstruct mm_walk mm_walk;\n\n\tmm_walk.pmd_entry = migrate_vma_collect_pmd;\n\tmm_walk.pte_entry = NULL;\n\tmm_walk.pte_hole = migrate_vma_collect_hole;\n\tmm_walk.hugetlb_entry = NULL;\n\tmm_walk.test_walk = NULL;\n\tmm_walk.vma = migrate->vma;\n\tmm_walk.mm = migrate->vma->vm_mm;\n\tmm_walk.private = migrate;\n\n\tmmu_notifier_invalidate_range_start(mm_walk.mm,\n\t\t\t\t\t    migrate->start,\n\t\t\t\t\t    migrate->end);\n\twalk_page_range(migrate->start, migrate->end, &mm_walk);\n\tmmu_notifier_invalidate_range_end(mm_walk.mm,\n\t\t\t\t\t  migrate->start,\n\t\t\t\t\t  migrate->end);\n\n\tmigrate->end = migrate->start + (migrate->npages << PAGE_SHIFT);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_end",
          "args": [
            "mm_walk.mm",
            "migrate->start",
            "migrate->end"
          ],
          "line": 2321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "walk_page_range",
          "args": [
            "migrate->start",
            "migrate->end",
            "&mm_walk"
          ],
          "line": 2320
        },
        "resolved": true,
        "details": {
          "function_name": "walk_page_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pagewalk.c",
          "lines": "293-340",
          "snippet": "int walk_page_range(unsigned long start, unsigned long end,\n\t\t    struct mm_walk *walk)\n{\n\tint err = 0;\n\tunsigned long next;\n\tstruct vm_area_struct *vma;\n\n\tif (start >= end)\n\t\treturn -EINVAL;\n\n\tif (!walk->mm)\n\t\treturn -EINVAL;\n\n\tVM_BUG_ON_MM(!rwsem_is_locked(&walk->mm->mmap_sem), walk->mm);\n\n\tvma = find_vma(walk->mm, start);\n\tdo {\n\t\tif (!vma) { /* after the last vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = end;\n\t\t} else if (start < vma->vm_start) { /* outside vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = min(end, vma->vm_start);\n\t\t} else { /* inside vma */\n\t\t\twalk->vma = vma;\n\t\t\tnext = min(end, vma->vm_end);\n\t\t\tvma = vma->vm_next;\n\n\t\t\terr = walk_page_test(start, next, walk);\n\t\t\tif (err > 0) {\n\t\t\t\t/*\n\t\t\t\t * positive return values are purely for\n\t\t\t\t * controlling the pagewalk, so should never\n\t\t\t\t * be passed to the callers.\n\t\t\t\t */\n\t\t\t\terr = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (walk->vma || walk->pte_hole)\n\t\t\terr = __walk_page_range(start, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (start = next, start < end);\n\treturn err;\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nint walk_page_range(unsigned long start, unsigned long end,\n\t\t    struct mm_walk *walk)\n{\n\tint err = 0;\n\tunsigned long next;\n\tstruct vm_area_struct *vma;\n\n\tif (start >= end)\n\t\treturn -EINVAL;\n\n\tif (!walk->mm)\n\t\treturn -EINVAL;\n\n\tVM_BUG_ON_MM(!rwsem_is_locked(&walk->mm->mmap_sem), walk->mm);\n\n\tvma = find_vma(walk->mm, start);\n\tdo {\n\t\tif (!vma) { /* after the last vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = end;\n\t\t} else if (start < vma->vm_start) { /* outside vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = min(end, vma->vm_start);\n\t\t} else { /* inside vma */\n\t\t\twalk->vma = vma;\n\t\t\tnext = min(end, vma->vm_end);\n\t\t\tvma = vma->vm_next;\n\n\t\t\terr = walk_page_test(start, next, walk);\n\t\t\tif (err > 0) {\n\t\t\t\t/*\n\t\t\t\t * positive return values are purely for\n\t\t\t\t * controlling the pagewalk, so should never\n\t\t\t\t * be passed to the callers.\n\t\t\t\t */\n\t\t\t\terr = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (walk->vma || walk->pte_hole)\n\t\t\terr = __walk_page_range(start, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (start = next, start < end);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_start",
          "args": [
            "mm_walk.mm",
            "migrate->start",
            "migrate->end"
          ],
          "line": 2317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic void migrate_vma_collect(struct migrate_vma *migrate)\n{\n\tstruct mm_walk mm_walk;\n\n\tmm_walk.pmd_entry = migrate_vma_collect_pmd;\n\tmm_walk.pte_entry = NULL;\n\tmm_walk.pte_hole = migrate_vma_collect_hole;\n\tmm_walk.hugetlb_entry = NULL;\n\tmm_walk.test_walk = NULL;\n\tmm_walk.vma = migrate->vma;\n\tmm_walk.mm = migrate->vma->vm_mm;\n\tmm_walk.private = migrate;\n\n\tmmu_notifier_invalidate_range_start(mm_walk.mm,\n\t\t\t\t\t    migrate->start,\n\t\t\t\t\t    migrate->end);\n\twalk_page_range(migrate->start, migrate->end, &mm_walk);\n\tmmu_notifier_invalidate_range_end(mm_walk.mm,\n\t\t\t\t\t  migrate->start,\n\t\t\t\t\t  migrate->end);\n\n\tmigrate->end = migrate->start + (migrate->npages << PAGE_SHIFT);\n}"
  },
  {
    "function_name": "migrate_vma_collect_pmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "2129-2294",
    "snippet": "static int migrate_vma_collect_pmd(pmd_t *pmdp,\n\t\t\t\t   unsigned long start,\n\t\t\t\t   unsigned long end,\n\t\t\t\t   struct mm_walk *walk)\n{\n\tstruct migrate_vma *migrate = walk->private;\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long addr = start, unmapped = 0;\n\tspinlock_t *ptl;\n\tpte_t *ptep;\n\nagain:\n\tif (pmd_none(*pmdp))\n\t\treturn migrate_vma_collect_hole(start, end, walk);\n\n\tif (pmd_trans_huge(*pmdp)) {\n\t\tstruct page *page;\n\n\t\tptl = pmd_lock(mm, pmdp);\n\t\tif (unlikely(!pmd_trans_huge(*pmdp))) {\n\t\t\tspin_unlock(ptl);\n\t\t\tgoto again;\n\t\t}\n\n\t\tpage = pmd_page(*pmdp);\n\t\tif (is_huge_zero_page(page)) {\n\t\t\tspin_unlock(ptl);\n\t\t\tsplit_huge_pmd(vma, pmdp, addr);\n\t\t\tif (pmd_trans_unstable(pmdp))\n\t\t\t\treturn migrate_vma_collect_skip(start, end,\n\t\t\t\t\t\t\t\twalk);\n\t\t} else {\n\t\t\tint ret;\n\n\t\t\tget_page(page);\n\t\t\tspin_unlock(ptl);\n\t\t\tif (unlikely(!trylock_page(page)))\n\t\t\t\treturn migrate_vma_collect_skip(start, end,\n\t\t\t\t\t\t\t\twalk);\n\t\t\tret = split_huge_page(page);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tif (ret)\n\t\t\t\treturn migrate_vma_collect_skip(start, end,\n\t\t\t\t\t\t\t\twalk);\n\t\t\tif (pmd_none(*pmdp))\n\t\t\t\treturn migrate_vma_collect_hole(start, end,\n\t\t\t\t\t\t\t\twalk);\n\t\t}\n\t}\n\n\tif (unlikely(pmd_bad(*pmdp)))\n\t\treturn migrate_vma_collect_skip(start, end, walk);\n\n\tptep = pte_offset_map_lock(mm, pmdp, addr, &ptl);\n\tarch_enter_lazy_mmu_mode();\n\n\tfor (; addr < end; addr += PAGE_SIZE, ptep++) {\n\t\tunsigned long mpfn, pfn;\n\t\tstruct page *page;\n\t\tswp_entry_t entry;\n\t\tpte_t pte;\n\n\t\tpte = *ptep;\n\t\tpfn = pte_pfn(pte);\n\n\t\tif (pte_none(pte)) {\n\t\t\tmpfn = MIGRATE_PFN_MIGRATE;\n\t\t\tmigrate->cpages++;\n\t\t\tpfn = 0;\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (!pte_present(pte)) {\n\t\t\tmpfn = pfn = 0;\n\n\t\t\t/*\n\t\t\t * Only care about unaddressable device page special\n\t\t\t * page table entry. Other special swap entries are not\n\t\t\t * migratable, and we ignore regular swapped page.\n\t\t\t */\n\t\t\tentry = pte_to_swp_entry(pte);\n\t\t\tif (!is_device_private_entry(entry))\n\t\t\t\tgoto next;\n\n\t\t\tpage = device_private_entry_to_page(entry);\n\t\t\tmpfn = migrate_pfn(page_to_pfn(page))|\n\t\t\t\tMIGRATE_PFN_DEVICE | MIGRATE_PFN_MIGRATE;\n\t\t\tif (is_write_device_private_entry(entry))\n\t\t\t\tmpfn |= MIGRATE_PFN_WRITE;\n\t\t} else {\n\t\t\tif (is_zero_pfn(pfn)) {\n\t\t\t\tmpfn = MIGRATE_PFN_MIGRATE;\n\t\t\t\tmigrate->cpages++;\n\t\t\t\tpfn = 0;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tpage = _vm_normal_page(migrate->vma, addr, pte, true);\n\t\t\tmpfn = migrate_pfn(pfn) | MIGRATE_PFN_MIGRATE;\n\t\t\tmpfn |= pte_write(pte) ? MIGRATE_PFN_WRITE : 0;\n\t\t}\n\n\t\t/* FIXME support THP */\n\t\tif (!page || !page->mapping || PageTransCompound(page)) {\n\t\t\tmpfn = pfn = 0;\n\t\t\tgoto next;\n\t\t}\n\t\tpfn = page_to_pfn(page);\n\n\t\t/*\n\t\t * By getting a reference on the page we pin it and that blocks\n\t\t * any kind of migration. Side effect is that it \"freezes\" the\n\t\t * pte.\n\t\t *\n\t\t * We drop this reference after isolating the page from the lru\n\t\t * for non device page (device page are not on the lru and thus\n\t\t * can't be dropped from it).\n\t\t */\n\t\tget_page(page);\n\t\tmigrate->cpages++;\n\n\t\t/*\n\t\t * Optimize for the common case where page is only mapped once\n\t\t * in one process. If we can lock the page, then we can safely\n\t\t * set up a special migration page table entry now.\n\t\t */\n\t\tif (trylock_page(page)) {\n\t\t\tpte_t swp_pte;\n\n\t\t\tmpfn |= MIGRATE_PFN_LOCKED;\n\t\t\tptep_get_and_clear(mm, addr, ptep);\n\n\t\t\t/* Setup special migration page table entry */\n\t\t\tentry = make_migration_entry(page, mpfn &\n\t\t\t\t\t\t     MIGRATE_PFN_WRITE);\n\t\t\tswp_pte = swp_entry_to_pte(entry);\n\t\t\tif (pte_soft_dirty(pte))\n\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\tset_pte_at(mm, addr, ptep, swp_pte);\n\n\t\t\t/*\n\t\t\t * This is like regular unmap: we remove the rmap and\n\t\t\t * drop page refcount. Page won't be freed, as we took\n\t\t\t * a reference just above.\n\t\t\t */\n\t\t\tpage_remove_rmap(page, false);\n\t\t\tput_page(page);\n\n\t\t\tif (pte_present(pte))\n\t\t\t\tunmapped++;\n\t\t}\n\nnext:\n\t\tmigrate->dst[migrate->npages] = 0;\n\t\tmigrate->src[migrate->npages++] = mpfn;\n\t}\n\tarch_leave_lazy_mmu_mode();\n\tpte_unmap_unlock(ptep - 1, ptl);\n\n\t/* Only flush the TLB if we actually modified any entries */\n\tif (unmapped)\n\t\tflush_tlb_range(walk->vma, start, end);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_tlb_range",
          "args": [
            "walk->vma",
            "start",
            "end"
          ],
          "line": 2291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "ptep - 1",
            "ptl"
          ],
          "line": 2287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_leave_lazy_mmu_mode",
          "args": [],
          "line": 2286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "pte"
          ],
          "line": 2278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 2276
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_remove_rmap",
          "args": [
            "page",
            "false"
          ],
          "line": 2275
        },
        "resolved": true,
        "details": {
          "function_name": "page_remove_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1297-1331",
          "snippet": "void page_remove_rmap(struct page *page, bool compound)\n{\n\tif (!PageAnon(page))\n\t\treturn page_remove_file_rmap(page, compound);\n\n\tif (compound)\n\t\treturn page_remove_anon_compound_rmap(page);\n\n\t/* page still mapped by someone else? */\n\tif (!atomic_add_negative(-1, &page->_mapcount))\n\t\treturn;\n\n\t/*\n\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t * these counters are not modified in interrupt context, and\n\t * pte lock(a spinlock) is held, which implies preemption disabled.\n\t */\n\t__dec_node_page_state(page, NR_ANON_MAPPED);\n\n\tif (unlikely(PageMlocked(page)))\n\t\tclear_page_mlock(page);\n\n\tif (PageTransCompound(page))\n\t\tdeferred_split_huge_page(compound_head(page));\n\n\t/*\n\t * It would be tidy to reset the PageAnon mapping here,\n\t * but that might overwrite a racing page_add_anon_rmap\n\t * which increments mapcount after us but sets mapping\n\t * before us: so leave the reset to free_unref_page,\n\t * and remember that it's only reliable while mapped.\n\t * Leaving it set also helps swapoff to reinstate ptes\n\t * faster for those pages still in swapcache.\n\t */\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid page_remove_rmap(struct page *page, bool compound)\n{\n\tif (!PageAnon(page))\n\t\treturn page_remove_file_rmap(page, compound);\n\n\tif (compound)\n\t\treturn page_remove_anon_compound_rmap(page);\n\n\t/* page still mapped by someone else? */\n\tif (!atomic_add_negative(-1, &page->_mapcount))\n\t\treturn;\n\n\t/*\n\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t * these counters are not modified in interrupt context, and\n\t * pte lock(a spinlock) is held, which implies preemption disabled.\n\t */\n\t__dec_node_page_state(page, NR_ANON_MAPPED);\n\n\tif (unlikely(PageMlocked(page)))\n\t\tclear_page_mlock(page);\n\n\tif (PageTransCompound(page))\n\t\tdeferred_split_huge_page(compound_head(page));\n\n\t/*\n\t * It would be tidy to reset the PageAnon mapping here,\n\t * but that might overwrite a racing page_add_anon_rmap\n\t * which increments mapcount after us but sets mapping\n\t * before us: so leave the reset to free_unref_page,\n\t * and remember that it's only reliable while mapped.\n\t * Leaving it set also helps swapoff to reinstate ptes\n\t * faster for those pages still in swapcache.\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_pte_at",
          "args": [
            "mm",
            "addr",
            "ptep",
            "swp_pte"
          ],
          "line": 2268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_swp_mksoft_dirty",
          "args": [
            "swp_pte"
          ],
          "line": 2267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_soft_dirty",
          "args": [
            "pte"
          ],
          "line": 2266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_entry_to_pte",
          "args": [
            "entry"
          ],
          "line": 2265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_migration_entry",
          "args": [
            "page",
            "mpfn &\n\t\t\t\t\t\t     MIGRATE_PFN_WRITE"
          ],
          "line": 2263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptep_get_and_clear",
          "args": [
            "mm",
            "addr",
            "ptep"
          ],
          "line": 2260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 2256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "page"
          ],
          "line": 2248
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 2237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransCompound",
          "args": [
            "page"
          ],
          "line": 2233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_write",
          "args": [
            "pte"
          ],
          "line": 2229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_pfn",
          "args": [
            "pfn"
          ],
          "line": 2228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_vm_normal_page",
          "args": [
            "migrate->vma",
            "addr",
            "pte",
            "true"
          ],
          "line": 2227
        },
        "resolved": true,
        "details": {
          "function_name": "_vm_normal_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "572-648",
          "snippet": "struct page *_vm_normal_page(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t     pte_t pte, bool with_public_device)\n{\n\tunsigned long pfn = pte_pfn(pte);\n\n\tif (IS_ENABLED(CONFIG_ARCH_HAS_PTE_SPECIAL)) {\n\t\tif (likely(!pte_special(pte)))\n\t\t\tgoto check_pfn;\n\t\tif (vma->vm_ops && vma->vm_ops->find_special_page)\n\t\t\treturn vma->vm_ops->find_special_page(vma, addr);\n\t\tif (vma->vm_flags & (VM_PFNMAP | VM_MIXEDMAP))\n\t\t\treturn NULL;\n\t\tif (is_zero_pfn(pfn))\n\t\t\treturn NULL;\n\n\t\t/*\n\t\t * Device public pages are special pages (they are ZONE_DEVICE\n\t\t * pages but different from persistent memory). They behave\n\t\t * allmost like normal pages. The difference is that they are\n\t\t * not on the lru and thus should never be involve with any-\n\t\t * thing that involve lru manipulation (mlock, numa balancing,\n\t\t * ...).\n\t\t *\n\t\t * This is why we still want to return NULL for such page from\n\t\t * vm_normal_page() so that we do not have to special case all\n\t\t * call site of vm_normal_page().\n\t\t */\n\t\tif (likely(pfn <= highest_memmap_pfn)) {\n\t\t\tstruct page *page = pfn_to_page(pfn);\n\n\t\t\tif (is_device_public_page(page)) {\n\t\t\t\tif (with_public_device)\n\t\t\t\t\treturn page;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (pte_devmap(pte))\n\t\t\treturn NULL;\n\n\t\tprint_bad_pte(vma, addr, pte, NULL);\n\t\treturn NULL;\n\t}\n\n\t/* !CONFIG_ARCH_HAS_PTE_SPECIAL case follows: */\n\n\tif (unlikely(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP))) {\n\t\tif (vma->vm_flags & VM_MIXEDMAP) {\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\treturn NULL;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tunsigned long off;\n\t\t\toff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\t\tif (pfn == vma->vm_pgoff + off)\n\t\t\t\treturn NULL;\n\t\t\tif (!is_cow_mapping(vma->vm_flags))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (is_zero_pfn(pfn))\n\t\treturn NULL;\n\ncheck_pfn:\n\tif (unlikely(pfn > highest_memmap_pfn)) {\n\t\tprint_bad_pte(vma, addr, pte, NULL);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * NOTE! We still have PageReserved() pages in the page tables.\n\t * eg. VDSO mappings can cause them to exist.\n\t */\nout:\n\treturn pfn_to_page(pfn);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstruct page *_vm_normal_page(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t     pte_t pte, bool with_public_device)\n{\n\tunsigned long pfn = pte_pfn(pte);\n\n\tif (IS_ENABLED(CONFIG_ARCH_HAS_PTE_SPECIAL)) {\n\t\tif (likely(!pte_special(pte)))\n\t\t\tgoto check_pfn;\n\t\tif (vma->vm_ops && vma->vm_ops->find_special_page)\n\t\t\treturn vma->vm_ops->find_special_page(vma, addr);\n\t\tif (vma->vm_flags & (VM_PFNMAP | VM_MIXEDMAP))\n\t\t\treturn NULL;\n\t\tif (is_zero_pfn(pfn))\n\t\t\treturn NULL;\n\n\t\t/*\n\t\t * Device public pages are special pages (they are ZONE_DEVICE\n\t\t * pages but different from persistent memory). They behave\n\t\t * allmost like normal pages. The difference is that they are\n\t\t * not on the lru and thus should never be involve with any-\n\t\t * thing that involve lru manipulation (mlock, numa balancing,\n\t\t * ...).\n\t\t *\n\t\t * This is why we still want to return NULL for such page from\n\t\t * vm_normal_page() so that we do not have to special case all\n\t\t * call site of vm_normal_page().\n\t\t */\n\t\tif (likely(pfn <= highest_memmap_pfn)) {\n\t\t\tstruct page *page = pfn_to_page(pfn);\n\n\t\t\tif (is_device_public_page(page)) {\n\t\t\t\tif (with_public_device)\n\t\t\t\t\treturn page;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (pte_devmap(pte))\n\t\t\treturn NULL;\n\n\t\tprint_bad_pte(vma, addr, pte, NULL);\n\t\treturn NULL;\n\t}\n\n\t/* !CONFIG_ARCH_HAS_PTE_SPECIAL case follows: */\n\n\tif (unlikely(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP))) {\n\t\tif (vma->vm_flags & VM_MIXEDMAP) {\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\treturn NULL;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tunsigned long off;\n\t\t\toff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\t\tif (pfn == vma->vm_pgoff + off)\n\t\t\t\treturn NULL;\n\t\t\tif (!is_cow_mapping(vma->vm_flags))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (is_zero_pfn(pfn))\n\t\treturn NULL;\n\ncheck_pfn:\n\tif (unlikely(pfn > highest_memmap_pfn)) {\n\t\tprint_bad_pte(vma, addr, pte, NULL);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * NOTE! We still have PageReserved() pages in the page tables.\n\t * eg. VDSO mappings can cause them to exist.\n\t */\nout:\n\treturn pfn_to_page(pfn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_zero_pfn",
          "args": [
            "pfn"
          ],
          "line": 2221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_write_device_private_entry",
          "args": [
            "entry"
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_pfn",
          "args": [
            "page_to_pfn(page)"
          ],
          "line": 2216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 2216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_private_entry_to_page",
          "args": [
            "entry"
          ],
          "line": 2215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_device_private_entry",
          "args": [
            "entry"
          ],
          "line": 2212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_to_swp_entry",
          "args": [
            "pte"
          ],
          "line": 2211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "pte"
          ],
          "line": 2203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_none",
          "args": [
            "pte"
          ],
          "line": 2196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_pfn",
          "args": [
            "pte"
          ],
          "line": 2194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_enter_lazy_mmu_mode",
          "args": [],
          "line": 2185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_offset_map_lock",
          "args": [
            "mm",
            "pmdp",
            "addr",
            "&ptl"
          ],
          "line": 2184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_vma_collect_skip",
          "args": [
            "start",
            "end",
            "walk"
          ],
          "line": 2182
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_vma_collect_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "2114-2127",
          "snippet": "static int migrate_vma_collect_skip(unsigned long start,\n\t\t\t\t    unsigned long end,\n\t\t\t\t    struct mm_walk *walk)\n{\n\tstruct migrate_vma *migrate = walk->private;\n\tunsigned long addr;\n\n\tfor (addr = start & PAGE_MASK; addr < end; addr += PAGE_SIZE) {\n\t\tmigrate->dst[migrate->npages] = 0;\n\t\tmigrate->src[migrate->npages++] = 0;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic int migrate_vma_collect_skip(unsigned long start,\n\t\t\t\t    unsigned long end,\n\t\t\t\t    struct mm_walk *walk)\n{\n\tstruct migrate_vma *migrate = walk->private;\n\tunsigned long addr;\n\n\tfor (addr = start & PAGE_MASK; addr < end; addr += PAGE_SIZE) {\n\t\tmigrate->dst[migrate->npages] = 0;\n\t\tmigrate->src[migrate->npages++] = 0;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pmd_bad(*pmdp)"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_bad",
          "args": [
            "*pmdp"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_vma_collect_hole",
          "args": [
            "start",
            "end",
            "walk"
          ],
          "line": 2176
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_vma_collect_hole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "2097-2112",
          "snippet": "static int migrate_vma_collect_hole(unsigned long start,\n\t\t\t\t    unsigned long end,\n\t\t\t\t    struct mm_walk *walk)\n{\n\tstruct migrate_vma *migrate = walk->private;\n\tunsigned long addr;\n\n\tfor (addr = start & PAGE_MASK; addr < end; addr += PAGE_SIZE) {\n\t\tmigrate->src[migrate->npages] = MIGRATE_PFN_MIGRATE;\n\t\tmigrate->dst[migrate->npages] = 0;\n\t\tmigrate->npages++;\n\t\tmigrate->cpages++;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic int migrate_vma_collect_hole(unsigned long start,\n\t\t\t\t    unsigned long end,\n\t\t\t\t    struct mm_walk *walk)\n{\n\tstruct migrate_vma *migrate = walk->private;\n\tunsigned long addr;\n\n\tfor (addr = start & PAGE_MASK; addr < end; addr += PAGE_SIZE) {\n\t\tmigrate->src[migrate->npages] = MIGRATE_PFN_MIGRATE;\n\t\tmigrate->dst[migrate->npages] = 0;\n\t\tmigrate->npages++;\n\t\tmigrate->cpages++;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_none",
          "args": [
            "*pmdp"
          ],
          "line": 2175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2170
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "split_huge_page",
          "args": [
            "page"
          ],
          "line": 2169
        },
        "resolved": true,
        "details": {
          "function_name": "deferred_split_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "2760-2774",
          "snippet": "void deferred_split_huge_page(struct page *page)\n{\n\tstruct pglist_data *pgdata = NODE_DATA(page_to_nid(page));\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\n\tspin_lock_irqsave(&pgdata->split_queue_lock, flags);\n\tif (list_empty(page_deferred_list(page))) {\n\t\tcount_vm_event(THP_DEFERRED_SPLIT_PAGE);\n\t\tlist_add_tail(page_deferred_list(page), &pgdata->split_queue);\n\t\tpgdata->split_queue_len++;\n\t}\n\tspin_unlock_irqrestore(&pgdata->split_queue_lock, flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid deferred_split_huge_page(struct page *page)\n{\n\tstruct pglist_data *pgdata = NODE_DATA(page_to_nid(page));\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\n\tspin_lock_irqsave(&pgdata->split_queue_lock, flags);\n\tif (list_empty(page_deferred_list(page))) {\n\t\tcount_vm_event(THP_DEFERRED_SPLIT_PAGE);\n\t\tlist_add_tail(page_deferred_list(page), &pgdata->split_queue);\n\t\tpgdata->split_queue_len++;\n\t}\n\tspin_unlock_irqrestore(&pgdata->split_queue_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!trylock_page(page)"
          ],
          "line": 2166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 2166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 2165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_unstable",
          "args": [
            "pmdp"
          ],
          "line": 2158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "split_huge_pmd",
          "args": [
            "vma",
            "pmdp",
            "addr"
          ],
          "line": 2157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 2156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_huge_zero_page",
          "args": [
            "page"
          ],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_page",
          "args": [
            "*pmdp"
          ],
          "line": 2154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 2150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pmd_trans_huge(*pmdp)"
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_huge",
          "args": [
            "*pmdp"
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_lock",
          "args": [
            "mm",
            "pmdp"
          ],
          "line": 2148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_huge",
          "args": [
            "*pmdp"
          ],
          "line": 2145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_none",
          "args": [
            "*pmdp"
          ],
          "line": 2142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic int migrate_vma_collect_pmd(pmd_t *pmdp,\n\t\t\t\t   unsigned long start,\n\t\t\t\t   unsigned long end,\n\t\t\t\t   struct mm_walk *walk)\n{\n\tstruct migrate_vma *migrate = walk->private;\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long addr = start, unmapped = 0;\n\tspinlock_t *ptl;\n\tpte_t *ptep;\n\nagain:\n\tif (pmd_none(*pmdp))\n\t\treturn migrate_vma_collect_hole(start, end, walk);\n\n\tif (pmd_trans_huge(*pmdp)) {\n\t\tstruct page *page;\n\n\t\tptl = pmd_lock(mm, pmdp);\n\t\tif (unlikely(!pmd_trans_huge(*pmdp))) {\n\t\t\tspin_unlock(ptl);\n\t\t\tgoto again;\n\t\t}\n\n\t\tpage = pmd_page(*pmdp);\n\t\tif (is_huge_zero_page(page)) {\n\t\t\tspin_unlock(ptl);\n\t\t\tsplit_huge_pmd(vma, pmdp, addr);\n\t\t\tif (pmd_trans_unstable(pmdp))\n\t\t\t\treturn migrate_vma_collect_skip(start, end,\n\t\t\t\t\t\t\t\twalk);\n\t\t} else {\n\t\t\tint ret;\n\n\t\t\tget_page(page);\n\t\t\tspin_unlock(ptl);\n\t\t\tif (unlikely(!trylock_page(page)))\n\t\t\t\treturn migrate_vma_collect_skip(start, end,\n\t\t\t\t\t\t\t\twalk);\n\t\t\tret = split_huge_page(page);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tif (ret)\n\t\t\t\treturn migrate_vma_collect_skip(start, end,\n\t\t\t\t\t\t\t\twalk);\n\t\t\tif (pmd_none(*pmdp))\n\t\t\t\treturn migrate_vma_collect_hole(start, end,\n\t\t\t\t\t\t\t\twalk);\n\t\t}\n\t}\n\n\tif (unlikely(pmd_bad(*pmdp)))\n\t\treturn migrate_vma_collect_skip(start, end, walk);\n\n\tptep = pte_offset_map_lock(mm, pmdp, addr, &ptl);\n\tarch_enter_lazy_mmu_mode();\n\n\tfor (; addr < end; addr += PAGE_SIZE, ptep++) {\n\t\tunsigned long mpfn, pfn;\n\t\tstruct page *page;\n\t\tswp_entry_t entry;\n\t\tpte_t pte;\n\n\t\tpte = *ptep;\n\t\tpfn = pte_pfn(pte);\n\n\t\tif (pte_none(pte)) {\n\t\t\tmpfn = MIGRATE_PFN_MIGRATE;\n\t\t\tmigrate->cpages++;\n\t\t\tpfn = 0;\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (!pte_present(pte)) {\n\t\t\tmpfn = pfn = 0;\n\n\t\t\t/*\n\t\t\t * Only care about unaddressable device page special\n\t\t\t * page table entry. Other special swap entries are not\n\t\t\t * migratable, and we ignore regular swapped page.\n\t\t\t */\n\t\t\tentry = pte_to_swp_entry(pte);\n\t\t\tif (!is_device_private_entry(entry))\n\t\t\t\tgoto next;\n\n\t\t\tpage = device_private_entry_to_page(entry);\n\t\t\tmpfn = migrate_pfn(page_to_pfn(page))|\n\t\t\t\tMIGRATE_PFN_DEVICE | MIGRATE_PFN_MIGRATE;\n\t\t\tif (is_write_device_private_entry(entry))\n\t\t\t\tmpfn |= MIGRATE_PFN_WRITE;\n\t\t} else {\n\t\t\tif (is_zero_pfn(pfn)) {\n\t\t\t\tmpfn = MIGRATE_PFN_MIGRATE;\n\t\t\t\tmigrate->cpages++;\n\t\t\t\tpfn = 0;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tpage = _vm_normal_page(migrate->vma, addr, pte, true);\n\t\t\tmpfn = migrate_pfn(pfn) | MIGRATE_PFN_MIGRATE;\n\t\t\tmpfn |= pte_write(pte) ? MIGRATE_PFN_WRITE : 0;\n\t\t}\n\n\t\t/* FIXME support THP */\n\t\tif (!page || !page->mapping || PageTransCompound(page)) {\n\t\t\tmpfn = pfn = 0;\n\t\t\tgoto next;\n\t\t}\n\t\tpfn = page_to_pfn(page);\n\n\t\t/*\n\t\t * By getting a reference on the page we pin it and that blocks\n\t\t * any kind of migration. Side effect is that it \"freezes\" the\n\t\t * pte.\n\t\t *\n\t\t * We drop this reference after isolating the page from the lru\n\t\t * for non device page (device page are not on the lru and thus\n\t\t * can't be dropped from it).\n\t\t */\n\t\tget_page(page);\n\t\tmigrate->cpages++;\n\n\t\t/*\n\t\t * Optimize for the common case where page is only mapped once\n\t\t * in one process. If we can lock the page, then we can safely\n\t\t * set up a special migration page table entry now.\n\t\t */\n\t\tif (trylock_page(page)) {\n\t\t\tpte_t swp_pte;\n\n\t\t\tmpfn |= MIGRATE_PFN_LOCKED;\n\t\t\tptep_get_and_clear(mm, addr, ptep);\n\n\t\t\t/* Setup special migration page table entry */\n\t\t\tentry = make_migration_entry(page, mpfn &\n\t\t\t\t\t\t     MIGRATE_PFN_WRITE);\n\t\t\tswp_pte = swp_entry_to_pte(entry);\n\t\t\tif (pte_soft_dirty(pte))\n\t\t\t\tswp_pte = pte_swp_mksoft_dirty(swp_pte);\n\t\t\tset_pte_at(mm, addr, ptep, swp_pte);\n\n\t\t\t/*\n\t\t\t * This is like regular unmap: we remove the rmap and\n\t\t\t * drop page refcount. Page won't be freed, as we took\n\t\t\t * a reference just above.\n\t\t\t */\n\t\t\tpage_remove_rmap(page, false);\n\t\t\tput_page(page);\n\n\t\t\tif (pte_present(pte))\n\t\t\t\tunmapped++;\n\t\t}\n\nnext:\n\t\tmigrate->dst[migrate->npages] = 0;\n\t\tmigrate->src[migrate->npages++] = mpfn;\n\t}\n\tarch_leave_lazy_mmu_mode();\n\tpte_unmap_unlock(ptep - 1, ptl);\n\n\t/* Only flush the TLB if we actually modified any entries */\n\tif (unmapped)\n\t\tflush_tlb_range(walk->vma, start, end);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "migrate_vma_collect_skip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "2114-2127",
    "snippet": "static int migrate_vma_collect_skip(unsigned long start,\n\t\t\t\t    unsigned long end,\n\t\t\t\t    struct mm_walk *walk)\n{\n\tstruct migrate_vma *migrate = walk->private;\n\tunsigned long addr;\n\n\tfor (addr = start & PAGE_MASK; addr < end; addr += PAGE_SIZE) {\n\t\tmigrate->dst[migrate->npages] = 0;\n\t\tmigrate->src[migrate->npages++] = 0;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic int migrate_vma_collect_skip(unsigned long start,\n\t\t\t\t    unsigned long end,\n\t\t\t\t    struct mm_walk *walk)\n{\n\tstruct migrate_vma *migrate = walk->private;\n\tunsigned long addr;\n\n\tfor (addr = start & PAGE_MASK; addr < end; addr += PAGE_SIZE) {\n\t\tmigrate->dst[migrate->npages] = 0;\n\t\tmigrate->src[migrate->npages++] = 0;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "migrate_vma_collect_hole",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "2097-2112",
    "snippet": "static int migrate_vma_collect_hole(unsigned long start,\n\t\t\t\t    unsigned long end,\n\t\t\t\t    struct mm_walk *walk)\n{\n\tstruct migrate_vma *migrate = walk->private;\n\tunsigned long addr;\n\n\tfor (addr = start & PAGE_MASK; addr < end; addr += PAGE_SIZE) {\n\t\tmigrate->src[migrate->npages] = MIGRATE_PFN_MIGRATE;\n\t\tmigrate->dst[migrate->npages] = 0;\n\t\tmigrate->npages++;\n\t\tmigrate->cpages++;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic int migrate_vma_collect_hole(unsigned long start,\n\t\t\t\t    unsigned long end,\n\t\t\t\t    struct mm_walk *walk)\n{\n\tstruct migrate_vma *migrate = walk->private;\n\tunsigned long addr;\n\n\tfor (addr = start & PAGE_MASK; addr < end; addr += PAGE_SIZE) {\n\t\tmigrate->src[migrate->npages] = MIGRATE_PFN_MIGRATE;\n\t\tmigrate->dst[migrate->npages] = 0;\n\t\tmigrate->npages++;\n\t\tmigrate->cpages++;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "migrate_misplaced_transhuge_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "1955-2081",
    "snippet": "int migrate_misplaced_transhuge_page(struct mm_struct *mm,\n\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\tpmd_t *pmd, pmd_t entry,\n\t\t\t\tunsigned long address,\n\t\t\t\tstruct page *page, int node)\n{\n\tspinlock_t *ptl;\n\tpg_data_t *pgdat = NODE_DATA(node);\n\tint isolated = 0;\n\tstruct page *new_page = NULL;\n\tint page_lru = page_is_file_cache(page);\n\tunsigned long start = address & HPAGE_PMD_MASK;\n\n\tnew_page = alloc_pages_node(node,\n\t\t(GFP_TRANSHUGE_LIGHT | __GFP_THISNODE),\n\t\tHPAGE_PMD_ORDER);\n\tif (!new_page)\n\t\tgoto out_fail;\n\tprep_transhuge_page(new_page);\n\n\tisolated = numamigrate_isolate_page(pgdat, page);\n\tif (!isolated) {\n\t\tput_page(new_page);\n\t\tgoto out_fail;\n\t}\n\n\t/* Prepare a page as a migration target */\n\t__SetPageLocked(new_page);\n\tif (PageSwapBacked(page))\n\t\t__SetPageSwapBacked(new_page);\n\n\t/* anon mapping, we can simply copy page->mapping to the new page: */\n\tnew_page->mapping = page->mapping;\n\tnew_page->index = page->index;\n\t/* flush the cache before copying using the kernel virtual address */\n\tflush_cache_range(vma, start, start + HPAGE_PMD_SIZE);\n\tmigrate_page_copy(new_page, page);\n\tWARN_ON(PageLRU(new_page));\n\n\t/* Recheck the target PMD */\n\tptl = pmd_lock(mm, pmd);\n\tif (unlikely(!pmd_same(*pmd, entry) || !page_ref_freeze(page, 2))) {\n\t\tspin_unlock(ptl);\n\n\t\t/* Reverse changes made by migrate_page_copy() */\n\t\tif (TestClearPageActive(new_page))\n\t\t\tSetPageActive(page);\n\t\tif (TestClearPageUnevictable(new_page))\n\t\t\tSetPageUnevictable(page);\n\n\t\tunlock_page(new_page);\n\t\tput_page(new_page);\t\t/* Free it */\n\n\t\t/* Retake the callers reference and putback on LRU */\n\t\tget_page(page);\n\t\tputback_lru_page(page);\n\t\tmod_node_page_state(page_pgdat(page),\n\t\t\t NR_ISOLATED_ANON + page_lru, -HPAGE_PMD_NR);\n\n\t\tgoto out_unlock;\n\t}\n\n\tentry = mk_huge_pmd(new_page, vma->vm_page_prot);\n\tentry = maybe_pmd_mkwrite(pmd_mkdirty(entry), vma);\n\n\t/*\n\t * Overwrite the old entry under pagetable lock and establish\n\t * the new PTE. Any parallel GUP will either observe the old\n\t * page blocking on the page lock, block on the page table\n\t * lock or observe the new page. The SetPageUptodate on the\n\t * new page and page_add_new_anon_rmap guarantee the copy is\n\t * visible before the pagetable update.\n\t */\n\tpage_add_anon_rmap(new_page, vma, start, true);\n\t/*\n\t * At this point the pmd is numa/protnone (i.e. non present) and the TLB\n\t * has already been flushed globally.  So no TLB can be currently\n\t * caching this non present pmd mapping.  There's no need to clear the\n\t * pmd before doing set_pmd_at(), nor to flush the TLB after\n\t * set_pmd_at().  Clearing the pmd here would introduce a race\n\t * condition against MADV_DONTNEED, because MADV_DONTNEED only holds the\n\t * mmap_sem for reading.  If the pmd is set to NULL at any given time,\n\t * MADV_DONTNEED won't wait on the pmd lock and it'll skip clearing this\n\t * pmd.\n\t */\n\tset_pmd_at(mm, start, pmd, entry);\n\tupdate_mmu_cache_pmd(vma, address, &entry);\n\n\tpage_ref_unfreeze(page, 2);\n\tmlock_migrate_page(new_page, page);\n\tpage_remove_rmap(page, true);\n\tset_page_owner_migrate_reason(new_page, MR_NUMA_MISPLACED);\n\n\tspin_unlock(ptl);\n\n\t/* Take an \"isolate\" reference and put new page on the LRU. */\n\tget_page(new_page);\n\tputback_lru_page(new_page);\n\n\tunlock_page(new_page);\n\tunlock_page(page);\n\tput_page(page);\t\t\t/* Drop the rmap reference */\n\tput_page(page);\t\t\t/* Drop the LRU isolation reference */\n\n\tcount_vm_events(PGMIGRATE_SUCCESS, HPAGE_PMD_NR);\n\tcount_vm_numa_events(NUMA_PAGE_MIGRATE, HPAGE_PMD_NR);\n\n\tmod_node_page_state(page_pgdat(page),\n\t\t\tNR_ISOLATED_ANON + page_lru,\n\t\t\t-HPAGE_PMD_NR);\n\treturn isolated;\n\nout_fail:\n\tcount_vm_events(PGMIGRATE_FAIL, HPAGE_PMD_NR);\n\tptl = pmd_lock(mm, pmd);\n\tif (pmd_same(*pmd, entry)) {\n\t\tentry = pmd_modify(entry, vma->vm_page_prot);\n\t\tset_pmd_at(mm, start, pmd, entry);\n\t\tupdate_mmu_cache_pmd(vma, address, &entry);\n\t}\n\tspin_unlock(ptl);\n\nout_unlock:\n\tunlock_page(page);\n\tput_page(page);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 2079
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2078
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 2075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_mmu_cache_pmd",
          "args": [
            "vma",
            "address",
            "&entry"
          ],
          "line": 2073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pmd_at",
          "args": [
            "mm",
            "start",
            "pmd",
            "entry"
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_modify",
          "args": [
            "entry",
            "vma->vm_page_prot"
          ],
          "line": 2071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_same",
          "args": [
            "*pmd",
            "entry"
          ],
          "line": 2070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_lock",
          "args": [
            "mm",
            "pmd"
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vm_events",
          "args": [
            "PGMIGRATE_FAIL",
            "HPAGE_PMD_NR"
          ],
          "line": 2068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mod_node_page_state",
          "args": [
            "page_pgdat(page)",
            "NR_ISOLATED_ANON + page_lru",
            "-HPAGE_PMD_NR"
          ],
          "line": 2062
        },
        "resolved": true,
        "details": {
          "function_name": "mod_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "644-652",
          "snippet": "void mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,\n\t\t\t\t\tlong delta)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__mod_node_page_state(pgdat, item, delta);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,\n\t\t\t\t\tlong delta)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__mod_node_page_state(pgdat, item, delta);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_pgdat",
          "args": [
            "page"
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vm_numa_events",
          "args": [
            "NUMA_PAGE_MIGRATE",
            "HPAGE_PMD_NR"
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vm_events",
          "args": [
            "PGMIGRATE_SUCCESS",
            "HPAGE_PMD_NR"
          ],
          "line": 2059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "putback_lru_page",
          "args": [
            "new_page"
          ],
          "line": 2052
        },
        "resolved": true,
        "details": {
          "function_name": "putback_lru_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1005-1009",
          "snippet": "void putback_lru_page(struct page *page)\n{\n\tlru_cache_add(page);\n\tput_page(page);\t\t/* drop ref from isolate */\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid putback_lru_page(struct page *page)\n{\n\tlru_cache_add(page);\n\tput_page(page);\t\t/* drop ref from isolate */\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "new_page"
          ],
          "line": 2051
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 2048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_owner_migrate_reason",
          "args": [
            "new_page",
            "MR_NUMA_MISPLACED"
          ],
          "line": 2046
        },
        "resolved": true,
        "details": {
          "function_name": "__set_page_owner_migrate_reason",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
          "lines": "199-209",
          "snippet": "void __set_page_owner_migrate_reason(struct page *page, int reason)\n{\n\tstruct page_ext *page_ext = lookup_page_ext(page);\n\tstruct page_owner *page_owner;\n\n\tif (unlikely(!page_ext))\n\t\treturn;\n\n\tpage_owner = get_page_owner(page_ext);\n\tpage_owner->last_migrate_reason = reason;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/stackdepot.h>",
            "#include <linux/migrate.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nvoid __set_page_owner_migrate_reason(struct page *page, int reason)\n{\n\tstruct page_ext *page_ext = lookup_page_ext(page);\n\tstruct page_owner *page_owner;\n\n\tif (unlikely(!page_ext))\n\t\treturn;\n\n\tpage_owner = get_page_owner(page_ext);\n\tpage_owner->last_migrate_reason = reason;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_remove_rmap",
          "args": [
            "page",
            "true"
          ],
          "line": 2045
        },
        "resolved": true,
        "details": {
          "function_name": "page_remove_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1297-1331",
          "snippet": "void page_remove_rmap(struct page *page, bool compound)\n{\n\tif (!PageAnon(page))\n\t\treturn page_remove_file_rmap(page, compound);\n\n\tif (compound)\n\t\treturn page_remove_anon_compound_rmap(page);\n\n\t/* page still mapped by someone else? */\n\tif (!atomic_add_negative(-1, &page->_mapcount))\n\t\treturn;\n\n\t/*\n\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t * these counters are not modified in interrupt context, and\n\t * pte lock(a spinlock) is held, which implies preemption disabled.\n\t */\n\t__dec_node_page_state(page, NR_ANON_MAPPED);\n\n\tif (unlikely(PageMlocked(page)))\n\t\tclear_page_mlock(page);\n\n\tif (PageTransCompound(page))\n\t\tdeferred_split_huge_page(compound_head(page));\n\n\t/*\n\t * It would be tidy to reset the PageAnon mapping here,\n\t * but that might overwrite a racing page_add_anon_rmap\n\t * which increments mapcount after us but sets mapping\n\t * before us: so leave the reset to free_unref_page,\n\t * and remember that it's only reliable while mapped.\n\t * Leaving it set also helps swapoff to reinstate ptes\n\t * faster for those pages still in swapcache.\n\t */\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid page_remove_rmap(struct page *page, bool compound)\n{\n\tif (!PageAnon(page))\n\t\treturn page_remove_file_rmap(page, compound);\n\n\tif (compound)\n\t\treturn page_remove_anon_compound_rmap(page);\n\n\t/* page still mapped by someone else? */\n\tif (!atomic_add_negative(-1, &page->_mapcount))\n\t\treturn;\n\n\t/*\n\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t * these counters are not modified in interrupt context, and\n\t * pte lock(a spinlock) is held, which implies preemption disabled.\n\t */\n\t__dec_node_page_state(page, NR_ANON_MAPPED);\n\n\tif (unlikely(PageMlocked(page)))\n\t\tclear_page_mlock(page);\n\n\tif (PageTransCompound(page))\n\t\tdeferred_split_huge_page(compound_head(page));\n\n\t/*\n\t * It would be tidy to reset the PageAnon mapping here,\n\t * but that might overwrite a racing page_add_anon_rmap\n\t * which increments mapcount after us but sets mapping\n\t * before us: so leave the reset to free_unref_page,\n\t * and remember that it's only reliable while mapped.\n\t * Leaving it set also helps swapoff to reinstate ptes\n\t * faster for those pages still in swapcache.\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlock_migrate_page",
          "args": [
            "new_page",
            "page"
          ],
          "line": 2044
        },
        "resolved": true,
        "details": {
          "function_name": "mlock_migrate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "360-360",
          "snippet": "static inline void mlock_migrate_page(struct page *new, struct page *old) { }",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void mlock_migrate_page(struct page *new, struct page *old) { }"
        }
      },
      {
        "call_info": {
          "callee": "page_ref_unfreeze",
          "args": [
            "page",
            "2"
          ],
          "line": 2043
        },
        "resolved": true,
        "details": {
          "function_name": "__page_ref_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/debug_page_ref.c",
          "lines": "50-53",
          "snippet": "void __page_ref_unfreeze(struct page *page, int v)\n{\n\ttrace_page_ref_unfreeze(page, v);\n}",
          "includes": [
            "#include <trace/events/page_ref.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/page_ref.h>\n#include <linux/tracepoint.h>\n#include <linux/mm_types.h>\n\nvoid __page_ref_unfreeze(struct page *page, int v)\n{\n\ttrace_page_ref_unfreeze(page, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_mmu_cache_pmd",
          "args": [
            "vma",
            "address",
            "&entry"
          ],
          "line": 2041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pmd_at",
          "args": [
            "mm",
            "start",
            "pmd",
            "entry"
          ],
          "line": 2040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_add_anon_rmap",
          "args": [
            "new_page",
            "vma",
            "start",
            "true"
          ],
          "line": 2028
        },
        "resolved": true,
        "details": {
          "function_name": "do_page_add_anon_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1098-1137",
          "snippet": "void do_page_add_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, int flags)\n{\n\tbool compound = flags & RMAP_COMPOUND;\n\tbool first;\n\n\tif (compound) {\n\t\tatomic_t *mapcount;\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\tmapcount = compound_mapcount_ptr(page);\n\t\tfirst = atomic_inc_and_test(mapcount);\n\t} else {\n\t\tfirst = atomic_inc_and_test(&page->_mapcount);\n\t}\n\n\tif (first) {\n\t\tint nr = compound ? hpage_nr_pages(page) : 1;\n\t\t/*\n\t\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t\t * these counters are not modified in interrupt context, and\n\t\t * pte lock(a spinlock) is held, which implies preemption\n\t\t * disabled.\n\t\t */\n\t\tif (compound)\n\t\t\t__inc_node_page_state(page, NR_ANON_THPS);\n\t\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, nr);\n\t}\n\tif (unlikely(PageKsm(page)))\n\t\treturn;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\t/* address might be in next vma when migration races vma_adjust */\n\tif (first)\n\t\t__page_set_anon_rmap(page, vma, address,\n\t\t\t\tflags & RMAP_EXCLUSIVE);\n\telse\n\t\t__page_check_anon_rmap(page, vma, address);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid do_page_add_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, int flags)\n{\n\tbool compound = flags & RMAP_COMPOUND;\n\tbool first;\n\n\tif (compound) {\n\t\tatomic_t *mapcount;\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\tmapcount = compound_mapcount_ptr(page);\n\t\tfirst = atomic_inc_and_test(mapcount);\n\t} else {\n\t\tfirst = atomic_inc_and_test(&page->_mapcount);\n\t}\n\n\tif (first) {\n\t\tint nr = compound ? hpage_nr_pages(page) : 1;\n\t\t/*\n\t\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t\t * these counters are not modified in interrupt context, and\n\t\t * pte lock(a spinlock) is held, which implies preemption\n\t\t * disabled.\n\t\t */\n\t\tif (compound)\n\t\t\t__inc_node_page_state(page, NR_ANON_THPS);\n\t\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, nr);\n\t}\n\tif (unlikely(PageKsm(page)))\n\t\treturn;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\t/* address might be in next vma when migration races vma_adjust */\n\tif (first)\n\t\t__page_set_anon_rmap(page, vma, address,\n\t\t\t\tflags & RMAP_EXCLUSIVE);\n\telse\n\t\t__page_check_anon_rmap(page, vma, address);\n}"
        }
      },
      {
        "call_info": {
          "callee": "maybe_pmd_mkwrite",
          "args": [
            "pmd_mkdirty(entry)",
            "vma"
          ],
          "line": 2018
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_pmd_mkwrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "477-482",
          "snippet": "pmd_t maybe_pmd_mkwrite(pmd_t pmd, struct vm_area_struct *vma)\n{\n\tif (likely(vma->vm_flags & VM_WRITE))\n\t\tpmd = pmd_mkwrite(pmd);\n\treturn pmd;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\npmd_t maybe_pmd_mkwrite(pmd_t pmd, struct vm_area_struct *vma)\n{\n\tif (likely(vma->vm_flags & VM_WRITE))\n\t\tpmd = pmd_mkwrite(pmd);\n\treturn pmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_mkdirty",
          "args": [
            "entry"
          ],
          "line": 2018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mk_huge_pmd",
          "args": [
            "new_page",
            "vma->vm_page_prot"
          ],
          "line": 2017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_pgdat",
          "args": [
            "page"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUnevictable",
          "args": [
            "page"
          ],
          "line": 2003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestClearPageUnevictable",
          "args": [
            "new_page"
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageActive",
          "args": [
            "page"
          ],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestClearPageActive",
          "args": [
            "new_page"
          ],
          "line": 2000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 1997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pmd_same(*pmd, entry) || !page_ref_freeze(page, 2)"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_ref_freeze",
          "args": [
            "page",
            "2"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_same",
          "args": [
            "*pmd",
            "entry"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_lock",
          "args": [
            "mm",
            "pmd"
          ],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "PageLRU(new_page)"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "new_page"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_page_copy",
          "args": [
            "new_page",
            "page"
          ],
          "line": 1991
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_page_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "722-730",
          "snippet": "void migrate_page_copy(struct page *newpage, struct page *page)\n{\n\tif (PageHuge(page) || PageTransHuge(page))\n\t\tcopy_huge_page(newpage, page);\n\telse\n\t\tcopy_highpage(newpage, page);\n\n\tmigrate_page_states(newpage, page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nvoid migrate_page_copy(struct page *newpage, struct page *page)\n{\n\tif (PageHuge(page) || PageTransHuge(page))\n\t\tcopy_huge_page(newpage, page);\n\telse\n\t\tcopy_highpage(newpage, page);\n\n\tmigrate_page_states(newpage, page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_cache_range",
          "args": [
            "vma",
            "start",
            "start + HPAGE_PMD_SIZE"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__SetPageSwapBacked",
          "args": [
            "new_page"
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapBacked",
          "args": [
            "page"
          ],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__SetPageLocked",
          "args": [
            "new_page"
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "numamigrate_isolate_page",
          "args": [
            "pgdat",
            "page"
          ],
          "line": 1975
        },
        "resolved": true,
        "details": {
          "function_name": "numamigrate_isolate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "1851-1887",
          "snippet": "static int numamigrate_isolate_page(pg_data_t *pgdat, struct page *page)\n{\n\tint page_lru;\n\n\tVM_BUG_ON_PAGE(compound_order(page) && !PageTransHuge(page), page);\n\n\t/* Avoid migrating to a node that is nearly full */\n\tif (!migrate_balanced_pgdat(pgdat, 1UL << compound_order(page)))\n\t\treturn 0;\n\n\tif (isolate_lru_page(page))\n\t\treturn 0;\n\n\t/*\n\t * migrate_misplaced_transhuge_page() skips page migration's usual\n\t * check on page_count(), so we must do it here, now that the page\n\t * has been isolated: a GUP pin, or any other pin, prevents migration.\n\t * The expected page count is 3: 1 for page's mapcount and 1 for the\n\t * caller's pin and 1 for the reference taken by isolate_lru_page().\n\t */\n\tif (PageTransHuge(page) && page_count(page) != 3) {\n\t\tputback_lru_page(page);\n\t\treturn 0;\n\t}\n\n\tpage_lru = page_is_file_cache(page);\n\tmod_node_page_state(page_pgdat(page), NR_ISOLATED_ANON + page_lru,\n\t\t\t\thpage_nr_pages(page));\n\n\t/*\n\t * Isolating the page has taken another reference, so the\n\t * caller's reference can be safely dropped without the page\n\t * disappearing underneath us during migration.\n\t */\n\tput_page(page);\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic int numamigrate_isolate_page(pg_data_t *pgdat, struct page *page)\n{\n\tint page_lru;\n\n\tVM_BUG_ON_PAGE(compound_order(page) && !PageTransHuge(page), page);\n\n\t/* Avoid migrating to a node that is nearly full */\n\tif (!migrate_balanced_pgdat(pgdat, 1UL << compound_order(page)))\n\t\treturn 0;\n\n\tif (isolate_lru_page(page))\n\t\treturn 0;\n\n\t/*\n\t * migrate_misplaced_transhuge_page() skips page migration's usual\n\t * check on page_count(), so we must do it here, now that the page\n\t * has been isolated: a GUP pin, or any other pin, prevents migration.\n\t * The expected page count is 3: 1 for page's mapcount and 1 for the\n\t * caller's pin and 1 for the reference taken by isolate_lru_page().\n\t */\n\tif (PageTransHuge(page) && page_count(page) != 3) {\n\t\tputback_lru_page(page);\n\t\treturn 0;\n\t}\n\n\tpage_lru = page_is_file_cache(page);\n\tmod_node_page_state(page_pgdat(page), NR_ISOLATED_ANON + page_lru,\n\t\t\t\thpage_nr_pages(page));\n\n\t/*\n\t * Isolating the page has taken another reference, so the\n\t * caller's reference can be safely dropped without the page\n\t * disappearing underneath us during migration.\n\t */\n\tput_page(page);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prep_transhuge_page",
          "args": [
            "new_page"
          ],
          "line": 1973
        },
        "resolved": true,
        "details": {
          "function_name": "prep_transhuge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "490-499",
          "snippet": "void prep_transhuge_page(struct page *page)\n{\n\t/*\n\t * we use page->mapping and page->indexlru in second tail page\n\t * as list_head: assuming THP order >= 2\n\t */\n\n\tINIT_LIST_HEAD(page_deferred_list(page));\n\tset_compound_page_dtor(page, TRANSHUGE_PAGE_DTOR);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid prep_transhuge_page(struct page *page)\n{\n\t/*\n\t * we use page->mapping and page->indexlru in second tail page\n\t * as list_head: assuming THP order >= 2\n\t */\n\n\tINIT_LIST_HEAD(page_deferred_list(page));\n\tset_compound_page_dtor(page, TRANSHUGE_PAGE_DTOR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_pages_node",
          "args": [
            "node",
            "(GFP_TRANSHUGE_LIGHT | __GFP_THISNODE)",
            "HPAGE_PMD_ORDER"
          ],
          "line": 1968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_is_file_cache",
          "args": [
            "page"
          ],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "node"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nint migrate_misplaced_transhuge_page(struct mm_struct *mm,\n\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\tpmd_t *pmd, pmd_t entry,\n\t\t\t\tunsigned long address,\n\t\t\t\tstruct page *page, int node)\n{\n\tspinlock_t *ptl;\n\tpg_data_t *pgdat = NODE_DATA(node);\n\tint isolated = 0;\n\tstruct page *new_page = NULL;\n\tint page_lru = page_is_file_cache(page);\n\tunsigned long start = address & HPAGE_PMD_MASK;\n\n\tnew_page = alloc_pages_node(node,\n\t\t(GFP_TRANSHUGE_LIGHT | __GFP_THISNODE),\n\t\tHPAGE_PMD_ORDER);\n\tif (!new_page)\n\t\tgoto out_fail;\n\tprep_transhuge_page(new_page);\n\n\tisolated = numamigrate_isolate_page(pgdat, page);\n\tif (!isolated) {\n\t\tput_page(new_page);\n\t\tgoto out_fail;\n\t}\n\n\t/* Prepare a page as a migration target */\n\t__SetPageLocked(new_page);\n\tif (PageSwapBacked(page))\n\t\t__SetPageSwapBacked(new_page);\n\n\t/* anon mapping, we can simply copy page->mapping to the new page: */\n\tnew_page->mapping = page->mapping;\n\tnew_page->index = page->index;\n\t/* flush the cache before copying using the kernel virtual address */\n\tflush_cache_range(vma, start, start + HPAGE_PMD_SIZE);\n\tmigrate_page_copy(new_page, page);\n\tWARN_ON(PageLRU(new_page));\n\n\t/* Recheck the target PMD */\n\tptl = pmd_lock(mm, pmd);\n\tif (unlikely(!pmd_same(*pmd, entry) || !page_ref_freeze(page, 2))) {\n\t\tspin_unlock(ptl);\n\n\t\t/* Reverse changes made by migrate_page_copy() */\n\t\tif (TestClearPageActive(new_page))\n\t\t\tSetPageActive(page);\n\t\tif (TestClearPageUnevictable(new_page))\n\t\t\tSetPageUnevictable(page);\n\n\t\tunlock_page(new_page);\n\t\tput_page(new_page);\t\t/* Free it */\n\n\t\t/* Retake the callers reference and putback on LRU */\n\t\tget_page(page);\n\t\tputback_lru_page(page);\n\t\tmod_node_page_state(page_pgdat(page),\n\t\t\t NR_ISOLATED_ANON + page_lru, -HPAGE_PMD_NR);\n\n\t\tgoto out_unlock;\n\t}\n\n\tentry = mk_huge_pmd(new_page, vma->vm_page_prot);\n\tentry = maybe_pmd_mkwrite(pmd_mkdirty(entry), vma);\n\n\t/*\n\t * Overwrite the old entry under pagetable lock and establish\n\t * the new PTE. Any parallel GUP will either observe the old\n\t * page blocking on the page lock, block on the page table\n\t * lock or observe the new page. The SetPageUptodate on the\n\t * new page and page_add_new_anon_rmap guarantee the copy is\n\t * visible before the pagetable update.\n\t */\n\tpage_add_anon_rmap(new_page, vma, start, true);\n\t/*\n\t * At this point the pmd is numa/protnone (i.e. non present) and the TLB\n\t * has already been flushed globally.  So no TLB can be currently\n\t * caching this non present pmd mapping.  There's no need to clear the\n\t * pmd before doing set_pmd_at(), nor to flush the TLB after\n\t * set_pmd_at().  Clearing the pmd here would introduce a race\n\t * condition against MADV_DONTNEED, because MADV_DONTNEED only holds the\n\t * mmap_sem for reading.  If the pmd is set to NULL at any given time,\n\t * MADV_DONTNEED won't wait on the pmd lock and it'll skip clearing this\n\t * pmd.\n\t */\n\tset_pmd_at(mm, start, pmd, entry);\n\tupdate_mmu_cache_pmd(vma, address, &entry);\n\n\tpage_ref_unfreeze(page, 2);\n\tmlock_migrate_page(new_page, page);\n\tpage_remove_rmap(page, true);\n\tset_page_owner_migrate_reason(new_page, MR_NUMA_MISPLACED);\n\n\tspin_unlock(ptl);\n\n\t/* Take an \"isolate\" reference and put new page on the LRU. */\n\tget_page(new_page);\n\tputback_lru_page(new_page);\n\n\tunlock_page(new_page);\n\tunlock_page(page);\n\tput_page(page);\t\t\t/* Drop the rmap reference */\n\tput_page(page);\t\t\t/* Drop the LRU isolation reference */\n\n\tcount_vm_events(PGMIGRATE_SUCCESS, HPAGE_PMD_NR);\n\tcount_vm_numa_events(NUMA_PAGE_MIGRATE, HPAGE_PMD_NR);\n\n\tmod_node_page_state(page_pgdat(page),\n\t\t\tNR_ISOLATED_ANON + page_lru,\n\t\t\t-HPAGE_PMD_NR);\n\treturn isolated;\n\nout_fail:\n\tcount_vm_events(PGMIGRATE_FAIL, HPAGE_PMD_NR);\n\tptl = pmd_lock(mm, pmd);\n\tif (pmd_same(*pmd, entry)) {\n\t\tentry = pmd_modify(entry, vma->vm_page_prot);\n\t\tset_pmd_at(mm, start, pmd, entry);\n\t\tupdate_mmu_cache_pmd(vma, address, &entry);\n\t}\n\tspin_unlock(ptl);\n\nout_unlock:\n\tunlock_page(page);\n\tput_page(page);\n\treturn 0;\n}"
  },
  {
    "function_name": "migrate_misplaced_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "1900-1947",
    "snippet": "int migrate_misplaced_page(struct page *page, struct vm_area_struct *vma,\n\t\t\t   int node)\n{\n\tpg_data_t *pgdat = NODE_DATA(node);\n\tint isolated;\n\tint nr_remaining;\n\tLIST_HEAD(migratepages);\n\n\t/*\n\t * Don't migrate file pages that are mapped in multiple processes\n\t * with execute permissions as they are probably shared libraries.\n\t */\n\tif (page_mapcount(page) != 1 && page_is_file_cache(page) &&\n\t    (vma->vm_flags & VM_EXEC))\n\t\tgoto out;\n\n\t/*\n\t * Also do not migrate dirty pages as not all filesystems can move\n\t * dirty pages in MIGRATE_ASYNC mode which is a waste of cycles.\n\t */\n\tif (page_is_file_cache(page) && PageDirty(page))\n\t\tgoto out;\n\n\tisolated = numamigrate_isolate_page(pgdat, page);\n\tif (!isolated)\n\t\tgoto out;\n\n\tlist_add(&page->lru, &migratepages);\n\tnr_remaining = migrate_pages(&migratepages, alloc_misplaced_dst_page,\n\t\t\t\t     NULL, node, MIGRATE_ASYNC,\n\t\t\t\t     MR_NUMA_MISPLACED);\n\tif (nr_remaining) {\n\t\tif (!list_empty(&migratepages)) {\n\t\t\tlist_del(&page->lru);\n\t\t\tdec_node_page_state(page, NR_ISOLATED_ANON +\n\t\t\t\t\tpage_is_file_cache(page));\n\t\t\tputback_lru_page(page);\n\t\t}\n\t\tisolated = 0;\n\t} else\n\t\tcount_vm_numa_event(NUMA_PAGE_MIGRATE);\n\tBUG_ON(!list_empty(&migratepages));\n\treturn isolated;\n\nout:\n\tput_page(page);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 1945
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&migratepages)"
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&migratepages"
          ],
          "line": 1941
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "count_vm_numa_event",
          "args": [
            "NUMA_PAGE_MIGRATE"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "putback_lru_page",
          "args": [
            "page"
          ],
          "line": 1936
        },
        "resolved": true,
        "details": {
          "function_name": "putback_lru_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1005-1009",
          "snippet": "void putback_lru_page(struct page *page)\n{\n\tlru_cache_add(page);\n\tput_page(page);\t\t/* drop ref from isolate */\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid putback_lru_page(struct page *page)\n{\n\tlru_cache_add(page);\n\tput_page(page);\t\t/* drop ref from isolate */\n}"
        }
      },
      {
        "call_info": {
          "callee": "dec_node_page_state",
          "args": [
            "page",
            "NR_ISOLATED_ANON +\n\t\t\t\t\tpage_is_file_cache(page)"
          ],
          "line": 1934
        },
        "resolved": true,
        "details": {
          "function_name": "dec_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "667-674",
          "snippet": "void dec_node_page_state(struct page *page, enum node_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_node_page_state(page, item);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid dec_node_page_state(struct page *page, enum node_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_node_page_state(page, item);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_is_file_cache",
          "args": [
            "page"
          ],
          "line": 1935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_pages",
          "args": [
            "&migratepages",
            "alloc_misplaced_dst_page",
            "NULL",
            "node",
            "MIGRATE_ASYNC",
            "MR_NUMA_MISPLACED"
          ],
          "line": 1928
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "1362-1449",
          "snippet": "int migrate_pages(struct list_head *from, new_page_t get_new_page,\n\t\tfree_page_t put_new_page, unsigned long private,\n\t\tenum migrate_mode mode, int reason)\n{\n\tint retry = 1;\n\tint nr_failed = 0;\n\tint nr_succeeded = 0;\n\tint pass = 0;\n\tstruct page *page;\n\tstruct page *page2;\n\tint swapwrite = current->flags & PF_SWAPWRITE;\n\tint rc;\n\n\tif (!swapwrite)\n\t\tcurrent->flags |= PF_SWAPWRITE;\n\n\tfor(pass = 0; pass < 10 && retry; pass++) {\n\t\tretry = 0;\n\n\t\tlist_for_each_entry_safe(page, page2, from, lru) {\nretry:\n\t\t\tcond_resched();\n\n\t\t\tif (PageHuge(page))\n\t\t\t\trc = unmap_and_move_huge_page(get_new_page,\n\t\t\t\t\t\tput_new_page, private, page,\n\t\t\t\t\t\tpass > 2, mode, reason);\n\t\t\telse\n\t\t\t\trc = unmap_and_move(get_new_page, put_new_page,\n\t\t\t\t\t\tprivate, page, pass > 2, mode,\n\t\t\t\t\t\treason);\n\n\t\t\tswitch(rc) {\n\t\t\tcase -ENOMEM:\n\t\t\t\t/*\n\t\t\t\t * THP migration might be unsupported or the\n\t\t\t\t * allocation could've failed so we should\n\t\t\t\t * retry on the same page with the THP split\n\t\t\t\t * to base pages.\n\t\t\t\t *\n\t\t\t\t * Head page is retried immediately and tail\n\t\t\t\t * pages are added to the tail of the list so\n\t\t\t\t * we encounter them after the rest of the list\n\t\t\t\t * is processed.\n\t\t\t\t */\n\t\t\t\tif (PageTransHuge(page) && !PageHuge(page)) {\n\t\t\t\t\tlock_page(page);\n\t\t\t\t\trc = split_huge_page_to_list(page, from);\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tif (!rc) {\n\t\t\t\t\t\tlist_safe_reset_next(page, page2, lru);\n\t\t\t\t\t\tgoto retry;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnr_failed++;\n\t\t\t\tgoto out;\n\t\t\tcase -EAGAIN:\n\t\t\t\tretry++;\n\t\t\t\tbreak;\n\t\t\tcase MIGRATEPAGE_SUCCESS:\n\t\t\t\tnr_succeeded++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t * Permanent failure (-EBUSY, -ENOSYS, etc.):\n\t\t\t\t * unlike -EAGAIN case, the failed page is\n\t\t\t\t * removed from migration page list and not\n\t\t\t\t * retried in the next outer loop.\n\t\t\t\t */\n\t\t\t\tnr_failed++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tnr_failed += retry;\n\trc = nr_failed;\nout:\n\tif (nr_succeeded)\n\t\tcount_vm_events(PGMIGRATE_SUCCESS, nr_succeeded);\n\tif (nr_failed)\n\t\tcount_vm_events(PGMIGRATE_FAIL, nr_failed);\n\ttrace_mm_migrate_pages(nr_succeeded, nr_failed, mode, reason);\n\n\tif (!swapwrite)\n\t\tcurrent->flags &= ~PF_SWAPWRITE;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nint migrate_pages(struct list_head *from, new_page_t get_new_page,\n\t\tfree_page_t put_new_page, unsigned long private,\n\t\tenum migrate_mode mode, int reason)\n{\n\tint retry = 1;\n\tint nr_failed = 0;\n\tint nr_succeeded = 0;\n\tint pass = 0;\n\tstruct page *page;\n\tstruct page *page2;\n\tint swapwrite = current->flags & PF_SWAPWRITE;\n\tint rc;\n\n\tif (!swapwrite)\n\t\tcurrent->flags |= PF_SWAPWRITE;\n\n\tfor(pass = 0; pass < 10 && retry; pass++) {\n\t\tretry = 0;\n\n\t\tlist_for_each_entry_safe(page, page2, from, lru) {\nretry:\n\t\t\tcond_resched();\n\n\t\t\tif (PageHuge(page))\n\t\t\t\trc = unmap_and_move_huge_page(get_new_page,\n\t\t\t\t\t\tput_new_page, private, page,\n\t\t\t\t\t\tpass > 2, mode, reason);\n\t\t\telse\n\t\t\t\trc = unmap_and_move(get_new_page, put_new_page,\n\t\t\t\t\t\tprivate, page, pass > 2, mode,\n\t\t\t\t\t\treason);\n\n\t\t\tswitch(rc) {\n\t\t\tcase -ENOMEM:\n\t\t\t\t/*\n\t\t\t\t * THP migration might be unsupported or the\n\t\t\t\t * allocation could've failed so we should\n\t\t\t\t * retry on the same page with the THP split\n\t\t\t\t * to base pages.\n\t\t\t\t *\n\t\t\t\t * Head page is retried immediately and tail\n\t\t\t\t * pages are added to the tail of the list so\n\t\t\t\t * we encounter them after the rest of the list\n\t\t\t\t * is processed.\n\t\t\t\t */\n\t\t\t\tif (PageTransHuge(page) && !PageHuge(page)) {\n\t\t\t\t\tlock_page(page);\n\t\t\t\t\trc = split_huge_page_to_list(page, from);\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tif (!rc) {\n\t\t\t\t\t\tlist_safe_reset_next(page, page2, lru);\n\t\t\t\t\t\tgoto retry;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnr_failed++;\n\t\t\t\tgoto out;\n\t\t\tcase -EAGAIN:\n\t\t\t\tretry++;\n\t\t\t\tbreak;\n\t\t\tcase MIGRATEPAGE_SUCCESS:\n\t\t\t\tnr_succeeded++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t * Permanent failure (-EBUSY, -ENOSYS, etc.):\n\t\t\t\t * unlike -EAGAIN case, the failed page is\n\t\t\t\t * removed from migration page list and not\n\t\t\t\t * retried in the next outer loop.\n\t\t\t\t */\n\t\t\t\tnr_failed++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tnr_failed += retry;\n\trc = nr_failed;\nout:\n\tif (nr_succeeded)\n\t\tcount_vm_events(PGMIGRATE_SUCCESS, nr_succeeded);\n\tif (nr_failed)\n\t\tcount_vm_events(PGMIGRATE_FAIL, nr_failed);\n\ttrace_mm_migrate_pages(nr_succeeded, nr_failed, mode, reason);\n\n\tif (!swapwrite)\n\t\tcurrent->flags &= ~PF_SWAPWRITE;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&page->lru",
            "&migratepages"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "numamigrate_isolate_page",
          "args": [
            "pgdat",
            "page"
          ],
          "line": 1923
        },
        "resolved": true,
        "details": {
          "function_name": "numamigrate_isolate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "1851-1887",
          "snippet": "static int numamigrate_isolate_page(pg_data_t *pgdat, struct page *page)\n{\n\tint page_lru;\n\n\tVM_BUG_ON_PAGE(compound_order(page) && !PageTransHuge(page), page);\n\n\t/* Avoid migrating to a node that is nearly full */\n\tif (!migrate_balanced_pgdat(pgdat, 1UL << compound_order(page)))\n\t\treturn 0;\n\n\tif (isolate_lru_page(page))\n\t\treturn 0;\n\n\t/*\n\t * migrate_misplaced_transhuge_page() skips page migration's usual\n\t * check on page_count(), so we must do it here, now that the page\n\t * has been isolated: a GUP pin, or any other pin, prevents migration.\n\t * The expected page count is 3: 1 for page's mapcount and 1 for the\n\t * caller's pin and 1 for the reference taken by isolate_lru_page().\n\t */\n\tif (PageTransHuge(page) && page_count(page) != 3) {\n\t\tputback_lru_page(page);\n\t\treturn 0;\n\t}\n\n\tpage_lru = page_is_file_cache(page);\n\tmod_node_page_state(page_pgdat(page), NR_ISOLATED_ANON + page_lru,\n\t\t\t\thpage_nr_pages(page));\n\n\t/*\n\t * Isolating the page has taken another reference, so the\n\t * caller's reference can be safely dropped without the page\n\t * disappearing underneath us during migration.\n\t */\n\tput_page(page);\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic int numamigrate_isolate_page(pg_data_t *pgdat, struct page *page)\n{\n\tint page_lru;\n\n\tVM_BUG_ON_PAGE(compound_order(page) && !PageTransHuge(page), page);\n\n\t/* Avoid migrating to a node that is nearly full */\n\tif (!migrate_balanced_pgdat(pgdat, 1UL << compound_order(page)))\n\t\treturn 0;\n\n\tif (isolate_lru_page(page))\n\t\treturn 0;\n\n\t/*\n\t * migrate_misplaced_transhuge_page() skips page migration's usual\n\t * check on page_count(), so we must do it here, now that the page\n\t * has been isolated: a GUP pin, or any other pin, prevents migration.\n\t * The expected page count is 3: 1 for page's mapcount and 1 for the\n\t * caller's pin and 1 for the reference taken by isolate_lru_page().\n\t */\n\tif (PageTransHuge(page) && page_count(page) != 3) {\n\t\tputback_lru_page(page);\n\t\treturn 0;\n\t}\n\n\tpage_lru = page_is_file_cache(page);\n\tmod_node_page_state(page_pgdat(page), NR_ISOLATED_ANON + page_lru,\n\t\t\t\thpage_nr_pages(page));\n\n\t/*\n\t * Isolating the page has taken another reference, so the\n\t * caller's reference can be safely dropped without the page\n\t * disappearing underneath us during migration.\n\t */\n\tput_page(page);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 1920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_is_file_cache",
          "args": [
            "page"
          ],
          "line": 1920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_is_file_cache",
          "args": [
            "page"
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapcount",
          "args": [
            "page"
          ],
          "line": 1912
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "migratepages"
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "node"
          ],
          "line": 1903
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nint migrate_misplaced_page(struct page *page, struct vm_area_struct *vma,\n\t\t\t   int node)\n{\n\tpg_data_t *pgdat = NODE_DATA(node);\n\tint isolated;\n\tint nr_remaining;\n\tLIST_HEAD(migratepages);\n\n\t/*\n\t * Don't migrate file pages that are mapped in multiple processes\n\t * with execute permissions as they are probably shared libraries.\n\t */\n\tif (page_mapcount(page) != 1 && page_is_file_cache(page) &&\n\t    (vma->vm_flags & VM_EXEC))\n\t\tgoto out;\n\n\t/*\n\t * Also do not migrate dirty pages as not all filesystems can move\n\t * dirty pages in MIGRATE_ASYNC mode which is a waste of cycles.\n\t */\n\tif (page_is_file_cache(page) && PageDirty(page))\n\t\tgoto out;\n\n\tisolated = numamigrate_isolate_page(pgdat, page);\n\tif (!isolated)\n\t\tgoto out;\n\n\tlist_add(&page->lru, &migratepages);\n\tnr_remaining = migrate_pages(&migratepages, alloc_misplaced_dst_page,\n\t\t\t\t     NULL, node, MIGRATE_ASYNC,\n\t\t\t\t     MR_NUMA_MISPLACED);\n\tif (nr_remaining) {\n\t\tif (!list_empty(&migratepages)) {\n\t\t\tlist_del(&page->lru);\n\t\t\tdec_node_page_state(page, NR_ISOLATED_ANON +\n\t\t\t\t\tpage_is_file_cache(page));\n\t\t\tputback_lru_page(page);\n\t\t}\n\t\tisolated = 0;\n\t} else\n\t\tcount_vm_numa_event(NUMA_PAGE_MIGRATE);\n\tBUG_ON(!list_empty(&migratepages));\n\treturn isolated;\n\nout:\n\tput_page(page);\n\treturn 0;\n}"
  },
  {
    "function_name": "pmd_trans_migrating",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "1889-1893",
    "snippet": "bool pmd_trans_migrating(pmd_t pmd)\n{\n\tstruct page *page = pmd_page(pmd);\n\treturn PageLocked(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_page",
          "args": [
            "pmd"
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nbool pmd_trans_migrating(pmd_t pmd)\n{\n\tstruct page *page = pmd_page(pmd);\n\treturn PageLocked(page);\n}"
  },
  {
    "function_name": "numamigrate_isolate_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "1851-1887",
    "snippet": "static int numamigrate_isolate_page(pg_data_t *pgdat, struct page *page)\n{\n\tint page_lru;\n\n\tVM_BUG_ON_PAGE(compound_order(page) && !PageTransHuge(page), page);\n\n\t/* Avoid migrating to a node that is nearly full */\n\tif (!migrate_balanced_pgdat(pgdat, 1UL << compound_order(page)))\n\t\treturn 0;\n\n\tif (isolate_lru_page(page))\n\t\treturn 0;\n\n\t/*\n\t * migrate_misplaced_transhuge_page() skips page migration's usual\n\t * check on page_count(), so we must do it here, now that the page\n\t * has been isolated: a GUP pin, or any other pin, prevents migration.\n\t * The expected page count is 3: 1 for page's mapcount and 1 for the\n\t * caller's pin and 1 for the reference taken by isolate_lru_page().\n\t */\n\tif (PageTransHuge(page) && page_count(page) != 3) {\n\t\tputback_lru_page(page);\n\t\treturn 0;\n\t}\n\n\tpage_lru = page_is_file_cache(page);\n\tmod_node_page_state(page_pgdat(page), NR_ISOLATED_ANON + page_lru,\n\t\t\t\thpage_nr_pages(page));\n\n\t/*\n\t * Isolating the page has taken another reference, so the\n\t * caller's reference can be safely dropped without the page\n\t * disappearing underneath us during migration.\n\t */\n\tput_page(page);\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 1885
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mod_node_page_state",
          "args": [
            "page_pgdat(page)",
            "NR_ISOLATED_ANON + page_lru",
            "hpage_nr_pages(page)"
          ],
          "line": 1877
        },
        "resolved": true,
        "details": {
          "function_name": "mod_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "644-652",
          "snippet": "void mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,\n\t\t\t\t\tlong delta)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__mod_node_page_state(pgdat, item, delta);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,\n\t\t\t\t\tlong delta)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__mod_node_page_state(pgdat, item, delta);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "page"
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_pgdat",
          "args": [
            "page"
          ],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_is_file_cache",
          "args": [
            "page"
          ],
          "line": 1876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "putback_lru_page",
          "args": [
            "page"
          ],
          "line": 1872
        },
        "resolved": true,
        "details": {
          "function_name": "putback_lru_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1005-1009",
          "snippet": "void putback_lru_page(struct page *page)\n{\n\tlru_cache_add(page);\n\tput_page(page);\t\t/* drop ref from isolate */\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid putback_lru_page(struct page *page)\n{\n\tlru_cache_add(page);\n\tput_page(page);\t\t/* drop ref from isolate */\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 1871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "page"
          ],
          "line": 1871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isolate_lru_page",
          "args": [
            "page"
          ],
          "line": 1861
        },
        "resolved": true,
        "details": {
          "function_name": "isolate_lru_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1772-1795",
          "snippet": "int isolate_lru_page(struct page *page)\n{\n\tint ret = -EBUSY;\n\n\tVM_BUG_ON_PAGE(!page_count(page), page);\n\tWARN_RATELIMIT(PageTail(page), \"trying to isolate tail page\");\n\n\tif (PageLRU(page)) {\n\t\tstruct zone *zone = page_zone(page);\n\t\tstruct lruvec *lruvec;\n\n\t\tspin_lock_irq(zone_lru_lock(zone));\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\t\tif (PageLRU(page)) {\n\t\t\tint lru = page_lru(page);\n\t\t\tget_page(page);\n\t\t\tClearPageLRU(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, lru);\n\t\t\tret = 0;\n\t\t}\n\t\tspin_unlock_irq(zone_lru_lock(zone));\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint isolate_lru_page(struct page *page)\n{\n\tint ret = -EBUSY;\n\n\tVM_BUG_ON_PAGE(!page_count(page), page);\n\tWARN_RATELIMIT(PageTail(page), \"trying to isolate tail page\");\n\n\tif (PageLRU(page)) {\n\t\tstruct zone *zone = page_zone(page);\n\t\tstruct lruvec *lruvec;\n\n\t\tspin_lock_irq(zone_lru_lock(zone));\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\t\tif (PageLRU(page)) {\n\t\t\tint lru = page_lru(page);\n\t\t\tget_page(page);\n\t\t\tClearPageLRU(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, lru);\n\t\t\tret = 0;\n\t\t}\n\t\tspin_unlock_irq(zone_lru_lock(zone));\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "migrate_balanced_pgdat",
          "args": [
            "pgdat",
            "1UL << compound_order(page)"
          ],
          "line": 1858
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_balanced_pgdat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "1814-1834",
          "snippet": "static bool migrate_balanced_pgdat(struct pglist_data *pgdat,\n\t\t\t\t   unsigned long nr_migrate_pages)\n{\n\tint z;\n\n\tfor (z = pgdat->nr_zones - 1; z >= 0; z--) {\n\t\tstruct zone *zone = pgdat->node_zones + z;\n\n\t\tif (!populated_zone(zone))\n\t\t\tcontinue;\n\n\t\t/* Avoid waking kswapd by allocating pages_to_migrate pages. */\n\t\tif (!zone_watermark_ok(zone, 0,\n\t\t\t\t       high_wmark_pages(zone) +\n\t\t\t\t       nr_migrate_pages,\n\t\t\t\t       0, 0))\n\t\t\tcontinue;\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic bool migrate_balanced_pgdat(struct pglist_data *pgdat,\n\t\t\t\t   unsigned long nr_migrate_pages)\n{\n\tint z;\n\n\tfor (z = pgdat->nr_zones - 1; z >= 0; z--) {\n\t\tstruct zone *zone = pgdat->node_zones + z;\n\n\t\tif (!populated_zone(zone))\n\t\t\tcontinue;\n\n\t\t/* Avoid waking kswapd by allocating pages_to_migrate pages. */\n\t\tif (!zone_watermark_ok(zone, 0,\n\t\t\t\t       high_wmark_pages(zone) +\n\t\t\t\t       nr_migrate_pages,\n\t\t\t\t       0, 0))\n\t\t\tcontinue;\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "page"
          ],
          "line": 1858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "compound_order(page) && !PageTransHuge(page)",
            "page"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "page"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "page"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic int numamigrate_isolate_page(pg_data_t *pgdat, struct page *page)\n{\n\tint page_lru;\n\n\tVM_BUG_ON_PAGE(compound_order(page) && !PageTransHuge(page), page);\n\n\t/* Avoid migrating to a node that is nearly full */\n\tif (!migrate_balanced_pgdat(pgdat, 1UL << compound_order(page)))\n\t\treturn 0;\n\n\tif (isolate_lru_page(page))\n\t\treturn 0;\n\n\t/*\n\t * migrate_misplaced_transhuge_page() skips page migration's usual\n\t * check on page_count(), so we must do it here, now that the page\n\t * has been isolated: a GUP pin, or any other pin, prevents migration.\n\t * The expected page count is 3: 1 for page's mapcount and 1 for the\n\t * caller's pin and 1 for the reference taken by isolate_lru_page().\n\t */\n\tif (PageTransHuge(page) && page_count(page) != 3) {\n\t\tputback_lru_page(page);\n\t\treturn 0;\n\t}\n\n\tpage_lru = page_is_file_cache(page);\n\tmod_node_page_state(page_pgdat(page), NR_ISOLATED_ANON + page_lru,\n\t\t\t\thpage_nr_pages(page));\n\n\t/*\n\t * Isolating the page has taken another reference, so the\n\t * caller's reference can be safely dropped without the page\n\t * disappearing underneath us during migration.\n\t */\n\tput_page(page);\n\treturn 1;\n}"
  },
  {
    "function_name": "alloc_misplaced_dst_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "1836-1849",
    "snippet": "static struct page *alloc_misplaced_dst_page(struct page *page,\n\t\t\t\t\t   unsigned long data)\n{\n\tint nid = (int) data;\n\tstruct page *newpage;\n\n\tnewpage = __alloc_pages_node(nid,\n\t\t\t\t\t (GFP_HIGHUSER_MOVABLE |\n\t\t\t\t\t  __GFP_THISNODE | __GFP_NOMEMALLOC |\n\t\t\t\t\t  __GFP_NORETRY | __GFP_NOWARN) &\n\t\t\t\t\t ~__GFP_RECLAIM, 0);\n\n\treturn newpage;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__alloc_pages_node",
          "args": [
            "nid",
            "(GFP_HIGHUSER_MOVABLE |\n\t\t\t\t\t  __GFP_THISNODE | __GFP_NOMEMALLOC |\n\t\t\t\t\t  __GFP_NORETRY | __GFP_NOWARN) &\n\t\t\t\t\t ~__GFP_RECLAIM",
            "0"
          ],
          "line": 1842
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic struct page *alloc_misplaced_dst_page(struct page *page,\n\t\t\t\t\t   unsigned long data)\n{\n\tint nid = (int) data;\n\tstruct page *newpage;\n\n\tnewpage = __alloc_pages_node(nid,\n\t\t\t\t\t (GFP_HIGHUSER_MOVABLE |\n\t\t\t\t\t  __GFP_THISNODE | __GFP_NOMEMALLOC |\n\t\t\t\t\t  __GFP_NORETRY | __GFP_NOWARN) &\n\t\t\t\t\t ~__GFP_RECLAIM, 0);\n\n\treturn newpage;\n}"
  },
  {
    "function_name": "migrate_balanced_pgdat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "1814-1834",
    "snippet": "static bool migrate_balanced_pgdat(struct pglist_data *pgdat,\n\t\t\t\t   unsigned long nr_migrate_pages)\n{\n\tint z;\n\n\tfor (z = pgdat->nr_zones - 1; z >= 0; z--) {\n\t\tstruct zone *zone = pgdat->node_zones + z;\n\n\t\tif (!populated_zone(zone))\n\t\t\tcontinue;\n\n\t\t/* Avoid waking kswapd by allocating pages_to_migrate pages. */\n\t\tif (!zone_watermark_ok(zone, 0,\n\t\t\t\t       high_wmark_pages(zone) +\n\t\t\t\t       nr_migrate_pages,\n\t\t\t\t       0, 0))\n\t\t\tcontinue;\n\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zone_watermark_ok",
          "args": [
            "zone",
            "0",
            "high_wmark_pages(zone) +\n\t\t\t\t       nr_migrate_pages",
            "0",
            "0"
          ],
          "line": 1826
        },
        "resolved": true,
        "details": {
          "function_name": "zone_watermark_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3198-3203",
          "snippet": "bool zone_watermark_ok(struct zone *z, unsigned int order, unsigned long mark,\n\t\t      int classzone_idx, unsigned int alloc_flags)\n{\n\treturn __zone_watermark_ok(z, order, mark, classzone_idx, alloc_flags,\n\t\t\t\t\tzone_page_state(z, NR_FREE_PAGES));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nbool zone_watermark_ok(struct zone *z, unsigned int order, unsigned long mark,\n\t\t      int classzone_idx, unsigned int alloc_flags)\n{\n\treturn __zone_watermark_ok(z, order, mark, classzone_idx, alloc_flags,\n\t\t\t\t\tzone_page_state(z, NR_FREE_PAGES));\n}"
        }
      },
      {
        "call_info": {
          "callee": "high_wmark_pages",
          "args": [
            "zone"
          ],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "populated_zone",
          "args": [
            "zone"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic bool migrate_balanced_pgdat(struct pglist_data *pgdat,\n\t\t\t\t   unsigned long nr_migrate_pages)\n{\n\tint z;\n\n\tfor (z = pgdat->nr_zones - 1; z >= 0; z--) {\n\t\tstruct zone *zone = pgdat->node_zones + z;\n\n\t\tif (!populated_zone(zone))\n\t\t\tcontinue;\n\n\t\t/* Avoid waking kswapd by allocating pages_to_migrate pages. */\n\t\tif (!zone_watermark_ok(zone, 0,\n\t\t\t\t       high_wmark_pages(zone) +\n\t\t\t\t       nr_migrate_pages,\n\t\t\t\t       0, 0))\n\t\t\tcontinue;\n\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "kernel_move_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "1717-1777",
    "snippet": "static int kernel_move_pages(pid_t pid, unsigned long nr_pages,\n\t\t\t     const void __user * __user *pages,\n\t\t\t     const int __user *nodes,\n\t\t\t     int __user *status, int flags)\n{\n\tstruct task_struct *task;\n\tstruct mm_struct *mm;\n\tint err;\n\tnodemask_t task_nodes;\n\n\t/* Check flags */\n\tif (flags & ~(MPOL_MF_MOVE|MPOL_MF_MOVE_ALL))\n\t\treturn -EINVAL;\n\n\tif ((flags & MPOL_MF_MOVE_ALL) && !capable(CAP_SYS_NICE))\n\t\treturn -EPERM;\n\n\t/* Find the mm_struct */\n\trcu_read_lock();\n\ttask = pid ? find_task_by_vpid(pid) : current;\n\tif (!task) {\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\tget_task_struct(task);\n\n\t/*\n\t * Check if this process has the right to modify the specified\n\t * process. Use the regular \"ptrace_may_access()\" checks.\n\t */\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS)) {\n\t\trcu_read_unlock();\n\t\terr = -EPERM;\n\t\tgoto out;\n\t}\n\trcu_read_unlock();\n\n \terr = security_task_movememory(task);\n \tif (err)\n\t\tgoto out;\n\n\ttask_nodes = cpuset_mems_allowed(task);\n\tmm = get_task_mm(task);\n\tput_task_struct(task);\n\n\tif (!mm)\n\t\treturn -EINVAL;\n\n\tif (nodes)\n\t\terr = do_pages_move(mm, task_nodes, nr_pages, pages,\n\t\t\t\t    nodes, status, flags);\n\telse\n\t\terr = do_pages_stat(mm, nr_pages, pages, status);\n\n\tmmput(mm);\n\treturn err;\n\nout:\n\tput_task_struct(task);\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "mm"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_pages_stat",
          "args": [
            "mm",
            "nr_pages",
            "pages",
            "status"
          ],
          "line": 1769
        },
        "resolved": true,
        "details": {
          "function_name": "do_pages_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "1683-1711",
          "snippet": "static int do_pages_stat(struct mm_struct *mm, unsigned long nr_pages,\n\t\t\t const void __user * __user *pages,\n\t\t\t int __user *status)\n{\n#define DO_PAGES_STAT_CHUNK_NR 16\n\tconst void __user *chunk_pages[DO_PAGES_STAT_CHUNK_NR];\n\tint chunk_status[DO_PAGES_STAT_CHUNK_NR];\n\n\twhile (nr_pages) {\n\t\tunsigned long chunk_nr;\n\n\t\tchunk_nr = nr_pages;\n\t\tif (chunk_nr > DO_PAGES_STAT_CHUNK_NR)\n\t\t\tchunk_nr = DO_PAGES_STAT_CHUNK_NR;\n\n\t\tif (copy_from_user(chunk_pages, pages, chunk_nr * sizeof(*chunk_pages)))\n\t\t\tbreak;\n\n\t\tdo_pages_stat_array(mm, chunk_nr, chunk_pages, chunk_status);\n\n\t\tif (copy_to_user(status, chunk_status, chunk_nr * sizeof(*status)))\n\t\t\tbreak;\n\n\t\tpages += chunk_nr;\n\t\tstatus += chunk_nr;\n\t\tnr_pages -= chunk_nr;\n\t}\n\treturn nr_pages ? -EFAULT : 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [
            "#define DO_PAGES_STAT_CHUNK_NR 16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\n#define DO_PAGES_STAT_CHUNK_NR 16\n\nstatic int do_pages_stat(struct mm_struct *mm, unsigned long nr_pages,\n\t\t\t const void __user * __user *pages,\n\t\t\t int __user *status)\n{\n#define DO_PAGES_STAT_CHUNK_NR 16\n\tconst void __user *chunk_pages[DO_PAGES_STAT_CHUNK_NR];\n\tint chunk_status[DO_PAGES_STAT_CHUNK_NR];\n\n\twhile (nr_pages) {\n\t\tunsigned long chunk_nr;\n\n\t\tchunk_nr = nr_pages;\n\t\tif (chunk_nr > DO_PAGES_STAT_CHUNK_NR)\n\t\t\tchunk_nr = DO_PAGES_STAT_CHUNK_NR;\n\n\t\tif (copy_from_user(chunk_pages, pages, chunk_nr * sizeof(*chunk_pages)))\n\t\t\tbreak;\n\n\t\tdo_pages_stat_array(mm, chunk_nr, chunk_pages, chunk_status);\n\n\t\tif (copy_to_user(status, chunk_status, chunk_nr * sizeof(*status)))\n\t\t\tbreak;\n\n\t\tpages += chunk_nr;\n\t\tstatus += chunk_nr;\n\t\tnr_pages -= chunk_nr;\n\t}\n\treturn nr_pages ? -EFAULT : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_pages_move",
          "args": [
            "mm",
            "task_nodes",
            "nr_pages",
            "pages",
            "nodes",
            "status",
            "flags"
          ],
          "line": 1766
        },
        "resolved": true,
        "details": {
          "function_name": "do_pages_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "1555-1639",
          "snippet": "static int do_pages_move(struct mm_struct *mm, nodemask_t task_nodes,\n\t\t\t unsigned long nr_pages,\n\t\t\t const void __user * __user *pages,\n\t\t\t const int __user *nodes,\n\t\t\t int __user *status, int flags)\n{\n\tint current_node = NUMA_NO_NODE;\n\tLIST_HEAD(pagelist);\n\tint start, i;\n\tint err = 0, err1;\n\n\tmigrate_prep();\n\n\tfor (i = start = 0; i < nr_pages; i++) {\n\t\tconst void __user *p;\n\t\tunsigned long addr;\n\t\tint node;\n\n\t\terr = -EFAULT;\n\t\tif (get_user(p, pages + i))\n\t\t\tgoto out_flush;\n\t\tif (get_user(node, nodes + i))\n\t\t\tgoto out_flush;\n\t\taddr = (unsigned long)p;\n\n\t\terr = -ENODEV;\n\t\tif (node < 0 || node >= MAX_NUMNODES)\n\t\t\tgoto out_flush;\n\t\tif (!node_state(node, N_MEMORY))\n\t\t\tgoto out_flush;\n\n\t\terr = -EACCES;\n\t\tif (!node_isset(node, task_nodes))\n\t\t\tgoto out_flush;\n\n\t\tif (current_node == NUMA_NO_NODE) {\n\t\t\tcurrent_node = node;\n\t\t\tstart = i;\n\t\t} else if (node != current_node) {\n\t\t\terr = do_move_pages_to_node(mm, &pagelist, current_node);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\terr = store_status(status, start, current_node, i - start);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tstart = i;\n\t\t\tcurrent_node = node;\n\t\t}\n\n\t\t/*\n\t\t * Errors in the page lookup or isolation are not fatal and we simply\n\t\t * report them via status\n\t\t */\n\t\terr = add_page_for_migration(mm, addr, current_node,\n\t\t\t\t&pagelist, flags & MPOL_MF_MOVE_ALL);\n\t\tif (!err)\n\t\t\tcontinue;\n\n\t\terr = store_status(status, i, err, 1);\n\t\tif (err)\n\t\t\tgoto out_flush;\n\n\t\terr = do_move_pages_to_node(mm, &pagelist, current_node);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (i > start) {\n\t\t\terr = store_status(status, start, current_node, i - start);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tcurrent_node = NUMA_NO_NODE;\n\t}\nout_flush:\n\tif (list_empty(&pagelist))\n\t\treturn err;\n\n\t/* Make sure we do not overwrite the existing error */\n\terr1 = do_move_pages_to_node(mm, &pagelist, current_node);\n\tif (!err1)\n\t\terr1 = store_status(status, start, current_node, i - start);\n\tif (!err)\n\t\terr = err1;\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic int do_pages_move(struct mm_struct *mm, nodemask_t task_nodes,\n\t\t\t unsigned long nr_pages,\n\t\t\t const void __user * __user *pages,\n\t\t\t const int __user *nodes,\n\t\t\t int __user *status, int flags)\n{\n\tint current_node = NUMA_NO_NODE;\n\tLIST_HEAD(pagelist);\n\tint start, i;\n\tint err = 0, err1;\n\n\tmigrate_prep();\n\n\tfor (i = start = 0; i < nr_pages; i++) {\n\t\tconst void __user *p;\n\t\tunsigned long addr;\n\t\tint node;\n\n\t\terr = -EFAULT;\n\t\tif (get_user(p, pages + i))\n\t\t\tgoto out_flush;\n\t\tif (get_user(node, nodes + i))\n\t\t\tgoto out_flush;\n\t\taddr = (unsigned long)p;\n\n\t\terr = -ENODEV;\n\t\tif (node < 0 || node >= MAX_NUMNODES)\n\t\t\tgoto out_flush;\n\t\tif (!node_state(node, N_MEMORY))\n\t\t\tgoto out_flush;\n\n\t\terr = -EACCES;\n\t\tif (!node_isset(node, task_nodes))\n\t\t\tgoto out_flush;\n\n\t\tif (current_node == NUMA_NO_NODE) {\n\t\t\tcurrent_node = node;\n\t\t\tstart = i;\n\t\t} else if (node != current_node) {\n\t\t\terr = do_move_pages_to_node(mm, &pagelist, current_node);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\terr = store_status(status, start, current_node, i - start);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tstart = i;\n\t\t\tcurrent_node = node;\n\t\t}\n\n\t\t/*\n\t\t * Errors in the page lookup or isolation are not fatal and we simply\n\t\t * report them via status\n\t\t */\n\t\terr = add_page_for_migration(mm, addr, current_node,\n\t\t\t\t&pagelist, flags & MPOL_MF_MOVE_ALL);\n\t\tif (!err)\n\t\t\tcontinue;\n\n\t\terr = store_status(status, i, err, 1);\n\t\tif (err)\n\t\t\tgoto out_flush;\n\n\t\terr = do_move_pages_to_node(mm, &pagelist, current_node);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (i > start) {\n\t\t\terr = store_status(status, start, current_node, i - start);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tcurrent_node = NUMA_NO_NODE;\n\t}\nout_flush:\n\tif (list_empty(&pagelist))\n\t\treturn err;\n\n\t/* Make sure we do not overwrite the existing error */\n\terr1 = do_move_pages_to_node(mm, &pagelist, current_node);\n\tif (!err1)\n\t\terr1 = store_status(status, start, current_node, i - start);\n\tif (!err)\n\t\terr = err1;\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_mm",
          "args": [
            "task"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuset_mems_allowed",
          "args": [
            "task"
          ],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_task_movememory",
          "args": [
            "task"
          ],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_may_access",
          "args": [
            "task",
            "PTRACE_MODE_READ_REALCREDS"
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "task"
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_task_by_vpid",
          "args": [
            "pid"
          ],
          "line": 1736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_NICE"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic int kernel_move_pages(pid_t pid, unsigned long nr_pages,\n\t\t\t     const void __user * __user *pages,\n\t\t\t     const int __user *nodes,\n\t\t\t     int __user *status, int flags)\n{\n\tstruct task_struct *task;\n\tstruct mm_struct *mm;\n\tint err;\n\tnodemask_t task_nodes;\n\n\t/* Check flags */\n\tif (flags & ~(MPOL_MF_MOVE|MPOL_MF_MOVE_ALL))\n\t\treturn -EINVAL;\n\n\tif ((flags & MPOL_MF_MOVE_ALL) && !capable(CAP_SYS_NICE))\n\t\treturn -EPERM;\n\n\t/* Find the mm_struct */\n\trcu_read_lock();\n\ttask = pid ? find_task_by_vpid(pid) : current;\n\tif (!task) {\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\tget_task_struct(task);\n\n\t/*\n\t * Check if this process has the right to modify the specified\n\t * process. Use the regular \"ptrace_may_access()\" checks.\n\t */\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS)) {\n\t\trcu_read_unlock();\n\t\terr = -EPERM;\n\t\tgoto out;\n\t}\n\trcu_read_unlock();\n\n \terr = security_task_movememory(task);\n \tif (err)\n\t\tgoto out;\n\n\ttask_nodes = cpuset_mems_allowed(task);\n\tmm = get_task_mm(task);\n\tput_task_struct(task);\n\n\tif (!mm)\n\t\treturn -EINVAL;\n\n\tif (nodes)\n\t\terr = do_pages_move(mm, task_nodes, nr_pages, pages,\n\t\t\t\t    nodes, status, flags);\n\telse\n\t\terr = do_pages_stat(mm, nr_pages, pages, status);\n\n\tmmput(mm);\n\treturn err;\n\nout:\n\tput_task_struct(task);\n\treturn err;\n}"
  },
  {
    "function_name": "do_pages_stat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "1683-1711",
    "snippet": "static int do_pages_stat(struct mm_struct *mm, unsigned long nr_pages,\n\t\t\t const void __user * __user *pages,\n\t\t\t int __user *status)\n{\n#define DO_PAGES_STAT_CHUNK_NR 16\n\tconst void __user *chunk_pages[DO_PAGES_STAT_CHUNK_NR];\n\tint chunk_status[DO_PAGES_STAT_CHUNK_NR];\n\n\twhile (nr_pages) {\n\t\tunsigned long chunk_nr;\n\n\t\tchunk_nr = nr_pages;\n\t\tif (chunk_nr > DO_PAGES_STAT_CHUNK_NR)\n\t\t\tchunk_nr = DO_PAGES_STAT_CHUNK_NR;\n\n\t\tif (copy_from_user(chunk_pages, pages, chunk_nr * sizeof(*chunk_pages)))\n\t\t\tbreak;\n\n\t\tdo_pages_stat_array(mm, chunk_nr, chunk_pages, chunk_status);\n\n\t\tif (copy_to_user(status, chunk_status, chunk_nr * sizeof(*status)))\n\t\t\tbreak;\n\n\t\tpages += chunk_nr;\n\t\tstatus += chunk_nr;\n\t\tnr_pages -= chunk_nr;\n\t}\n\treturn nr_pages ? -EFAULT : 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [
      "#define DO_PAGES_STAT_CHUNK_NR 16"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "status",
            "chunk_status",
            "chunk_nr * sizeof(*status)"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_pages_stat_array",
          "args": [
            "mm",
            "chunk_nr",
            "chunk_pages",
            "chunk_status"
          ],
          "line": 1701
        },
        "resolved": true,
        "details": {
          "function_name": "do_pages_stat_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "1644-1677",
          "snippet": "static void do_pages_stat_array(struct mm_struct *mm, unsigned long nr_pages,\n\t\t\t\tconst void __user **pages, int *status)\n{\n\tunsigned long i;\n\n\tdown_read(&mm->mmap_sem);\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tunsigned long addr = (unsigned long)(*pages);\n\t\tstruct vm_area_struct *vma;\n\t\tstruct page *page;\n\t\tint err = -EFAULT;\n\n\t\tvma = find_vma(mm, addr);\n\t\tif (!vma || addr < vma->vm_start)\n\t\t\tgoto set_status;\n\n\t\t/* FOLL_DUMP to ignore special (like zero) pages */\n\t\tpage = follow_page(vma, addr, FOLL_DUMP);\n\n\t\terr = PTR_ERR(page);\n\t\tif (IS_ERR(page))\n\t\t\tgoto set_status;\n\n\t\terr = page ? page_to_nid(page) : -ENOENT;\nset_status:\n\t\t*status = err;\n\n\t\tpages++;\n\t\tstatus++;\n\t}\n\n\tup_read(&mm->mmap_sem);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic void do_pages_stat_array(struct mm_struct *mm, unsigned long nr_pages,\n\t\t\t\tconst void __user **pages, int *status)\n{\n\tunsigned long i;\n\n\tdown_read(&mm->mmap_sem);\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tunsigned long addr = (unsigned long)(*pages);\n\t\tstruct vm_area_struct *vma;\n\t\tstruct page *page;\n\t\tint err = -EFAULT;\n\n\t\tvma = find_vma(mm, addr);\n\t\tif (!vma || addr < vma->vm_start)\n\t\t\tgoto set_status;\n\n\t\t/* FOLL_DUMP to ignore special (like zero) pages */\n\t\tpage = follow_page(vma, addr, FOLL_DUMP);\n\n\t\terr = PTR_ERR(page);\n\t\tif (IS_ERR(page))\n\t\t\tgoto set_status;\n\n\t\terr = page ? page_to_nid(page) : -ENOENT;\nset_status:\n\t\t*status = err;\n\n\t\tpages++;\n\t\tstatus++;\n\t}\n\n\tup_read(&mm->mmap_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "chunk_pages",
            "pages",
            "chunk_nr * sizeof(*chunk_pages)"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\n#define DO_PAGES_STAT_CHUNK_NR 16\n\nstatic int do_pages_stat(struct mm_struct *mm, unsigned long nr_pages,\n\t\t\t const void __user * __user *pages,\n\t\t\t int __user *status)\n{\n#define DO_PAGES_STAT_CHUNK_NR 16\n\tconst void __user *chunk_pages[DO_PAGES_STAT_CHUNK_NR];\n\tint chunk_status[DO_PAGES_STAT_CHUNK_NR];\n\n\twhile (nr_pages) {\n\t\tunsigned long chunk_nr;\n\n\t\tchunk_nr = nr_pages;\n\t\tif (chunk_nr > DO_PAGES_STAT_CHUNK_NR)\n\t\t\tchunk_nr = DO_PAGES_STAT_CHUNK_NR;\n\n\t\tif (copy_from_user(chunk_pages, pages, chunk_nr * sizeof(*chunk_pages)))\n\t\t\tbreak;\n\n\t\tdo_pages_stat_array(mm, chunk_nr, chunk_pages, chunk_status);\n\n\t\tif (copy_to_user(status, chunk_status, chunk_nr * sizeof(*status)))\n\t\t\tbreak;\n\n\t\tpages += chunk_nr;\n\t\tstatus += chunk_nr;\n\t\tnr_pages -= chunk_nr;\n\t}\n\treturn nr_pages ? -EFAULT : 0;\n}"
  },
  {
    "function_name": "do_pages_stat_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "1644-1677",
    "snippet": "static void do_pages_stat_array(struct mm_struct *mm, unsigned long nr_pages,\n\t\t\t\tconst void __user **pages, int *status)\n{\n\tunsigned long i;\n\n\tdown_read(&mm->mmap_sem);\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tunsigned long addr = (unsigned long)(*pages);\n\t\tstruct vm_area_struct *vma;\n\t\tstruct page *page;\n\t\tint err = -EFAULT;\n\n\t\tvma = find_vma(mm, addr);\n\t\tif (!vma || addr < vma->vm_start)\n\t\t\tgoto set_status;\n\n\t\t/* FOLL_DUMP to ignore special (like zero) pages */\n\t\tpage = follow_page(vma, addr, FOLL_DUMP);\n\n\t\terr = PTR_ERR(page);\n\t\tif (IS_ERR(page))\n\t\t\tgoto set_status;\n\n\t\terr = page ? page_to_nid(page) : -ENOENT;\nset_status:\n\t\t*status = err;\n\n\t\tpages++;\n\t\tstatus++;\n\t}\n\n\tup_read(&mm->mmap_sem);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 1668
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "follow_page",
          "args": [
            "vma",
            "addr",
            "FOLL_DUMP"
          ],
          "line": 1662
        },
        "resolved": true,
        "details": {
          "function_name": "follow_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "1712-1716",
          "snippet": "struct page *follow_page(struct vm_area_struct *vma, unsigned long address,\n\t\t\t unsigned int foll_flags)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nstruct page *follow_page(struct vm_area_struct *vma, unsigned long address,\n\t\t\t unsigned int foll_flags)\n{\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_vma",
          "args": [
            "mm",
            "addr"
          ],
          "line": 1657
        },
        "resolved": true,
        "details": {
          "function_name": "find_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "775-796",
          "snippet": "struct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\n\t/* check the cache first */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\t/* trawl the list (there may be multiple mappings in which addr\n\t * resides) */\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_start > addr)\n\t\t\treturn NULL;\n\t\tif (vma->vm_end > addr) {\n\t\t\tvmacache_update(addr, vma);\n\t\t\treturn vma;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nstruct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\n\t/* check the cache first */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\t/* trawl the list (there may be multiple mappings in which addr\n\t * resides) */\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_start > addr)\n\t\t\treturn NULL;\n\t\tif (vma->vm_end > addr) {\n\t\t\tvmacache_update(addr, vma);\n\t\t\treturn vma;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic void do_pages_stat_array(struct mm_struct *mm, unsigned long nr_pages,\n\t\t\t\tconst void __user **pages, int *status)\n{\n\tunsigned long i;\n\n\tdown_read(&mm->mmap_sem);\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tunsigned long addr = (unsigned long)(*pages);\n\t\tstruct vm_area_struct *vma;\n\t\tstruct page *page;\n\t\tint err = -EFAULT;\n\n\t\tvma = find_vma(mm, addr);\n\t\tif (!vma || addr < vma->vm_start)\n\t\t\tgoto set_status;\n\n\t\t/* FOLL_DUMP to ignore special (like zero) pages */\n\t\tpage = follow_page(vma, addr, FOLL_DUMP);\n\n\t\terr = PTR_ERR(page);\n\t\tif (IS_ERR(page))\n\t\t\tgoto set_status;\n\n\t\terr = page ? page_to_nid(page) : -ENOENT;\nset_status:\n\t\t*status = err;\n\n\t\tpages++;\n\t\tstatus++;\n\t}\n\n\tup_read(&mm->mmap_sem);\n}"
  },
  {
    "function_name": "do_pages_move",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "1555-1639",
    "snippet": "static int do_pages_move(struct mm_struct *mm, nodemask_t task_nodes,\n\t\t\t unsigned long nr_pages,\n\t\t\t const void __user * __user *pages,\n\t\t\t const int __user *nodes,\n\t\t\t int __user *status, int flags)\n{\n\tint current_node = NUMA_NO_NODE;\n\tLIST_HEAD(pagelist);\n\tint start, i;\n\tint err = 0, err1;\n\n\tmigrate_prep();\n\n\tfor (i = start = 0; i < nr_pages; i++) {\n\t\tconst void __user *p;\n\t\tunsigned long addr;\n\t\tint node;\n\n\t\terr = -EFAULT;\n\t\tif (get_user(p, pages + i))\n\t\t\tgoto out_flush;\n\t\tif (get_user(node, nodes + i))\n\t\t\tgoto out_flush;\n\t\taddr = (unsigned long)p;\n\n\t\terr = -ENODEV;\n\t\tif (node < 0 || node >= MAX_NUMNODES)\n\t\t\tgoto out_flush;\n\t\tif (!node_state(node, N_MEMORY))\n\t\t\tgoto out_flush;\n\n\t\terr = -EACCES;\n\t\tif (!node_isset(node, task_nodes))\n\t\t\tgoto out_flush;\n\n\t\tif (current_node == NUMA_NO_NODE) {\n\t\t\tcurrent_node = node;\n\t\t\tstart = i;\n\t\t} else if (node != current_node) {\n\t\t\terr = do_move_pages_to_node(mm, &pagelist, current_node);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\terr = store_status(status, start, current_node, i - start);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tstart = i;\n\t\t\tcurrent_node = node;\n\t\t}\n\n\t\t/*\n\t\t * Errors in the page lookup or isolation are not fatal and we simply\n\t\t * report them via status\n\t\t */\n\t\terr = add_page_for_migration(mm, addr, current_node,\n\t\t\t\t&pagelist, flags & MPOL_MF_MOVE_ALL);\n\t\tif (!err)\n\t\t\tcontinue;\n\n\t\terr = store_status(status, i, err, 1);\n\t\tif (err)\n\t\t\tgoto out_flush;\n\n\t\terr = do_move_pages_to_node(mm, &pagelist, current_node);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (i > start) {\n\t\t\terr = store_status(status, start, current_node, i - start);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tcurrent_node = NUMA_NO_NODE;\n\t}\nout_flush:\n\tif (list_empty(&pagelist))\n\t\treturn err;\n\n\t/* Make sure we do not overwrite the existing error */\n\terr1 = do_move_pages_to_node(mm, &pagelist, current_node);\n\tif (!err1)\n\t\terr1 = store_status(status, start, current_node, i - start);\n\tif (!err)\n\t\terr = err1;\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "store_status",
          "args": [
            "status",
            "start",
            "current_node",
            "i - start"
          ],
          "line": 1634
        },
        "resolved": true,
        "details": {
          "function_name": "store_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "1453-1462",
          "snippet": "static int store_status(int __user *status, int start, int value, int nr)\n{\n\twhile (nr-- > 0) {\n\t\tif (put_user(value, status + start))\n\t\t\treturn -EFAULT;\n\t\tstart++;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic int store_status(int __user *status, int start, int value, int nr)\n{\n\twhile (nr-- > 0) {\n\t\tif (put_user(value, status + start))\n\t\t\treturn -EFAULT;\n\t\tstart++;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_move_pages_to_node",
          "args": [
            "mm",
            "&pagelist",
            "current_node"
          ],
          "line": 1632
        },
        "resolved": true,
        "details": {
          "function_name": "do_move_pages_to_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "1464-1477",
          "snippet": "static int do_move_pages_to_node(struct mm_struct *mm,\n\t\tstruct list_head *pagelist, int node)\n{\n\tint err;\n\n\tif (list_empty(pagelist))\n\t\treturn 0;\n\n\terr = migrate_pages(pagelist, alloc_new_node_page, NULL, node,\n\t\t\tMIGRATE_SYNC, MR_SYSCALL);\n\tif (err)\n\t\tputback_movable_pages(pagelist);\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic int do_move_pages_to_node(struct mm_struct *mm,\n\t\tstruct list_head *pagelist, int node)\n{\n\tint err;\n\n\tif (list_empty(pagelist))\n\t\treturn 0;\n\n\terr = migrate_pages(pagelist, alloc_new_node_page, NULL, node,\n\t\t\tMIGRATE_SYNC, MR_SYSCALL);\n\tif (err)\n\t\tputback_movable_pages(pagelist);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pagelist"
          ],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_page_for_migration",
          "args": [
            "mm",
            "addr",
            "current_node",
            "&pagelist",
            "flags & MPOL_MF_MOVE_ALL"
          ],
          "line": 1608
        },
        "resolved": true,
        "details": {
          "function_name": "add_page_for_migration",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "1486-1549",
          "snippet": "static int add_page_for_migration(struct mm_struct *mm, unsigned long addr,\n\t\tint node, struct list_head *pagelist, bool migrate_all)\n{\n\tstruct vm_area_struct *vma;\n\tstruct page *page;\n\tunsigned int follflags;\n\tint err;\n\n\tdown_read(&mm->mmap_sem);\n\terr = -EFAULT;\n\tvma = find_vma(mm, addr);\n\tif (!vma || addr < vma->vm_start || !vma_migratable(vma))\n\t\tgoto out;\n\n\t/* FOLL_DUMP to ignore special (like zero) pages */\n\tfollflags = FOLL_GET | FOLL_DUMP;\n\tpage = follow_page(vma, addr, follflags);\n\n\terr = PTR_ERR(page);\n\tif (IS_ERR(page))\n\t\tgoto out;\n\n\terr = -ENOENT;\n\tif (!page)\n\t\tgoto out;\n\n\terr = 0;\n\tif (page_to_nid(page) == node)\n\t\tgoto out_putpage;\n\n\terr = -EACCES;\n\tif (page_mapcount(page) > 1 && !migrate_all)\n\t\tgoto out_putpage;\n\n\tif (PageHuge(page)) {\n\t\tif (PageHead(page)) {\n\t\t\tisolate_huge_page(page, pagelist);\n\t\t\terr = 0;\n\t\t}\n\t} else {\n\t\tstruct page *head;\n\n\t\thead = compound_head(page);\n\t\terr = isolate_lru_page(head);\n\t\tif (err)\n\t\t\tgoto out_putpage;\n\n\t\terr = 0;\n\t\tlist_add_tail(&head->lru, pagelist);\n\t\tmod_node_page_state(page_pgdat(head),\n\t\t\tNR_ISOLATED_ANON + page_is_file_cache(head),\n\t\t\thpage_nr_pages(head));\n\t}\nout_putpage:\n\t/*\n\t * Either remove the duplicate refcount from\n\t * isolate_lru_page() or drop the page ref if it was\n\t * not isolated.\n\t */\n\tput_page(page);\nout:\n\tup_read(&mm->mmap_sem);\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic int add_page_for_migration(struct mm_struct *mm, unsigned long addr,\n\t\tint node, struct list_head *pagelist, bool migrate_all)\n{\n\tstruct vm_area_struct *vma;\n\tstruct page *page;\n\tunsigned int follflags;\n\tint err;\n\n\tdown_read(&mm->mmap_sem);\n\terr = -EFAULT;\n\tvma = find_vma(mm, addr);\n\tif (!vma || addr < vma->vm_start || !vma_migratable(vma))\n\t\tgoto out;\n\n\t/* FOLL_DUMP to ignore special (like zero) pages */\n\tfollflags = FOLL_GET | FOLL_DUMP;\n\tpage = follow_page(vma, addr, follflags);\n\n\terr = PTR_ERR(page);\n\tif (IS_ERR(page))\n\t\tgoto out;\n\n\terr = -ENOENT;\n\tif (!page)\n\t\tgoto out;\n\n\terr = 0;\n\tif (page_to_nid(page) == node)\n\t\tgoto out_putpage;\n\n\terr = -EACCES;\n\tif (page_mapcount(page) > 1 && !migrate_all)\n\t\tgoto out_putpage;\n\n\tif (PageHuge(page)) {\n\t\tif (PageHead(page)) {\n\t\t\tisolate_huge_page(page, pagelist);\n\t\t\terr = 0;\n\t\t}\n\t} else {\n\t\tstruct page *head;\n\n\t\thead = compound_head(page);\n\t\terr = isolate_lru_page(head);\n\t\tif (err)\n\t\t\tgoto out_putpage;\n\n\t\terr = 0;\n\t\tlist_add_tail(&head->lru, pagelist);\n\t\tmod_node_page_state(page_pgdat(head),\n\t\t\tNR_ISOLATED_ANON + page_is_file_cache(head),\n\t\t\thpage_nr_pages(head));\n\t}\nout_putpage:\n\t/*\n\t * Either remove the duplicate refcount from\n\t * isolate_lru_page() or drop the page ref if it was\n\t * not isolated.\n\t */\n\tput_page(page);\nout:\n\tup_read(&mm->mmap_sem);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "node_isset",
          "args": [
            "node",
            "task_nodes"
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_state",
          "args": [
            "node",
            "N_MEMORY"
          ],
          "line": 1583
        },
        "resolved": true,
        "details": {
          "function_name": "inc_node_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "634-641",
          "snippet": "void inc_node_state(struct pglist_data *pgdat, enum node_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__inc_node_state(pgdat, item);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid inc_node_state(struct pglist_data *pgdat, enum node_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__inc_node_state(pgdat, item);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "node",
            "nodes + i"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "p",
            "pages + i"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_prep",
          "args": [],
          "line": 1566
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_prep_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "77-82",
          "snippet": "int migrate_prep_local(void)\n{\n\tlru_add_drain();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nint migrate_prep_local(void)\n{\n\tlru_add_drain();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "pagelist"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic int do_pages_move(struct mm_struct *mm, nodemask_t task_nodes,\n\t\t\t unsigned long nr_pages,\n\t\t\t const void __user * __user *pages,\n\t\t\t const int __user *nodes,\n\t\t\t int __user *status, int flags)\n{\n\tint current_node = NUMA_NO_NODE;\n\tLIST_HEAD(pagelist);\n\tint start, i;\n\tint err = 0, err1;\n\n\tmigrate_prep();\n\n\tfor (i = start = 0; i < nr_pages; i++) {\n\t\tconst void __user *p;\n\t\tunsigned long addr;\n\t\tint node;\n\n\t\terr = -EFAULT;\n\t\tif (get_user(p, pages + i))\n\t\t\tgoto out_flush;\n\t\tif (get_user(node, nodes + i))\n\t\t\tgoto out_flush;\n\t\taddr = (unsigned long)p;\n\n\t\terr = -ENODEV;\n\t\tif (node < 0 || node >= MAX_NUMNODES)\n\t\t\tgoto out_flush;\n\t\tif (!node_state(node, N_MEMORY))\n\t\t\tgoto out_flush;\n\n\t\terr = -EACCES;\n\t\tif (!node_isset(node, task_nodes))\n\t\t\tgoto out_flush;\n\n\t\tif (current_node == NUMA_NO_NODE) {\n\t\t\tcurrent_node = node;\n\t\t\tstart = i;\n\t\t} else if (node != current_node) {\n\t\t\terr = do_move_pages_to_node(mm, &pagelist, current_node);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\terr = store_status(status, start, current_node, i - start);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tstart = i;\n\t\t\tcurrent_node = node;\n\t\t}\n\n\t\t/*\n\t\t * Errors in the page lookup or isolation are not fatal and we simply\n\t\t * report them via status\n\t\t */\n\t\terr = add_page_for_migration(mm, addr, current_node,\n\t\t\t\t&pagelist, flags & MPOL_MF_MOVE_ALL);\n\t\tif (!err)\n\t\t\tcontinue;\n\n\t\terr = store_status(status, i, err, 1);\n\t\tif (err)\n\t\t\tgoto out_flush;\n\n\t\terr = do_move_pages_to_node(mm, &pagelist, current_node);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (i > start) {\n\t\t\terr = store_status(status, start, current_node, i - start);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tcurrent_node = NUMA_NO_NODE;\n\t}\nout_flush:\n\tif (list_empty(&pagelist))\n\t\treturn err;\n\n\t/* Make sure we do not overwrite the existing error */\n\terr1 = do_move_pages_to_node(mm, &pagelist, current_node);\n\tif (!err1)\n\t\terr1 = store_status(status, start, current_node, i - start);\n\tif (!err)\n\t\terr = err1;\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "add_page_for_migration",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "1486-1549",
    "snippet": "static int add_page_for_migration(struct mm_struct *mm, unsigned long addr,\n\t\tint node, struct list_head *pagelist, bool migrate_all)\n{\n\tstruct vm_area_struct *vma;\n\tstruct page *page;\n\tunsigned int follflags;\n\tint err;\n\n\tdown_read(&mm->mmap_sem);\n\terr = -EFAULT;\n\tvma = find_vma(mm, addr);\n\tif (!vma || addr < vma->vm_start || !vma_migratable(vma))\n\t\tgoto out;\n\n\t/* FOLL_DUMP to ignore special (like zero) pages */\n\tfollflags = FOLL_GET | FOLL_DUMP;\n\tpage = follow_page(vma, addr, follflags);\n\n\terr = PTR_ERR(page);\n\tif (IS_ERR(page))\n\t\tgoto out;\n\n\terr = -ENOENT;\n\tif (!page)\n\t\tgoto out;\n\n\terr = 0;\n\tif (page_to_nid(page) == node)\n\t\tgoto out_putpage;\n\n\terr = -EACCES;\n\tif (page_mapcount(page) > 1 && !migrate_all)\n\t\tgoto out_putpage;\n\n\tif (PageHuge(page)) {\n\t\tif (PageHead(page)) {\n\t\t\tisolate_huge_page(page, pagelist);\n\t\t\terr = 0;\n\t\t}\n\t} else {\n\t\tstruct page *head;\n\n\t\thead = compound_head(page);\n\t\terr = isolate_lru_page(head);\n\t\tif (err)\n\t\t\tgoto out_putpage;\n\n\t\terr = 0;\n\t\tlist_add_tail(&head->lru, pagelist);\n\t\tmod_node_page_state(page_pgdat(head),\n\t\t\tNR_ISOLATED_ANON + page_is_file_cache(head),\n\t\t\thpage_nr_pages(head));\n\t}\nout_putpage:\n\t/*\n\t * Either remove the duplicate refcount from\n\t * isolate_lru_page() or drop the page ref if it was\n\t * not isolated.\n\t */\n\tput_page(page);\nout:\n\tup_read(&mm->mmap_sem);\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 1545
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mod_node_page_state",
          "args": [
            "page_pgdat(head)",
            "NR_ISOLATED_ANON + page_is_file_cache(head)",
            "hpage_nr_pages(head)"
          ],
          "line": 1535
        },
        "resolved": true,
        "details": {
          "function_name": "mod_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "644-652",
          "snippet": "void mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,\n\t\t\t\t\tlong delta)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__mod_node_page_state(pgdat, item, delta);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,\n\t\t\t\t\tlong delta)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__mod_node_page_state(pgdat, item, delta);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "head"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_is_file_cache",
          "args": [
            "head"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_pgdat",
          "args": [
            "head"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&head->lru",
            "pagelist"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isolate_lru_page",
          "args": [
            "head"
          ],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "isolate_lru_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1772-1795",
          "snippet": "int isolate_lru_page(struct page *page)\n{\n\tint ret = -EBUSY;\n\n\tVM_BUG_ON_PAGE(!page_count(page), page);\n\tWARN_RATELIMIT(PageTail(page), \"trying to isolate tail page\");\n\n\tif (PageLRU(page)) {\n\t\tstruct zone *zone = page_zone(page);\n\t\tstruct lruvec *lruvec;\n\n\t\tspin_lock_irq(zone_lru_lock(zone));\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\t\tif (PageLRU(page)) {\n\t\t\tint lru = page_lru(page);\n\t\t\tget_page(page);\n\t\t\tClearPageLRU(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, lru);\n\t\t\tret = 0;\n\t\t}\n\t\tspin_unlock_irq(zone_lru_lock(zone));\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint isolate_lru_page(struct page *page)\n{\n\tint ret = -EBUSY;\n\n\tVM_BUG_ON_PAGE(!page_count(page), page);\n\tWARN_RATELIMIT(PageTail(page), \"trying to isolate tail page\");\n\n\tif (PageLRU(page)) {\n\t\tstruct zone *zone = page_zone(page);\n\t\tstruct lruvec *lruvec;\n\n\t\tspin_lock_irq(zone_lru_lock(zone));\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\t\tif (PageLRU(page)) {\n\t\t\tint lru = page_lru(page);\n\t\t\tget_page(page);\n\t\t\tClearPageLRU(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, lru);\n\t\t\tret = 0;\n\t\t}\n\t\tspin_unlock_irq(zone_lru_lock(zone));\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isolate_huge_page",
          "args": [
            "page",
            "pagelist"
          ],
          "line": 1522
        },
        "resolved": true,
        "details": {
          "function_name": "isolate_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "4891-4906",
          "snippet": "bool isolate_huge_page(struct page *page, struct list_head *list)\n{\n\tbool ret = true;\n\n\tVM_BUG_ON_PAGE(!PageHead(page), page);\n\tspin_lock(&hugetlb_lock);\n\tif (!page_huge_active(page) || !get_page_unless_zero(page)) {\n\t\tret = false;\n\t\tgoto unlock;\n\t}\n\tclear_page_huge_active(page);\n\tlist_move_tail(&page->lru, list);\nunlock:\n\tspin_unlock(&hugetlb_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nbool isolate_huge_page(struct page *page, struct list_head *list)\n{\n\tbool ret = true;\n\n\tVM_BUG_ON_PAGE(!PageHead(page), page);\n\tspin_lock(&hugetlb_lock);\n\tif (!page_huge_active(page) || !get_page_unless_zero(page)) {\n\t\tret = false;\n\t\tgoto unlock;\n\t}\n\tclear_page_huge_active(page);\n\tlist_move_tail(&page->lru, list);\nunlock:\n\tspin_unlock(&hugetlb_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageHead",
          "args": [
            "page"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "PageHeadHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1350-1356",
          "snippet": "int PageHeadHuge(struct page *page_head)\n{\n\tif (!PageHead(page_head))\n\t\treturn 0;\n\n\treturn get_compound_page_dtor(page_head) == free_huge_page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint PageHeadHuge(struct page *page_head)\n{\n\tif (!PageHead(page_head))\n\t\treturn 0;\n\n\treturn get_compound_page_dtor(page_head) == free_huge_page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "page"
          ],
          "line": 1520
        },
        "resolved": true,
        "details": {
          "function_name": "PageHugeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "225-228",
          "snippet": "static int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_mapcount",
          "args": [
            "page"
          ],
          "line": 1517
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 1513
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "follow_page",
          "args": [
            "vma",
            "addr",
            "follflags"
          ],
          "line": 1502
        },
        "resolved": true,
        "details": {
          "function_name": "follow_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "1712-1716",
          "snippet": "struct page *follow_page(struct vm_area_struct *vma, unsigned long address,\n\t\t\t unsigned int foll_flags)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nstruct page *follow_page(struct vm_area_struct *vma, unsigned long address,\n\t\t\t unsigned int foll_flags)\n{\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_migratable",
          "args": [
            "vma"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_vma",
          "args": [
            "mm",
            "addr"
          ],
          "line": 1496
        },
        "resolved": true,
        "details": {
          "function_name": "find_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "775-796",
          "snippet": "struct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\n\t/* check the cache first */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\t/* trawl the list (there may be multiple mappings in which addr\n\t * resides) */\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_start > addr)\n\t\t\treturn NULL;\n\t\tif (vma->vm_end > addr) {\n\t\t\tvmacache_update(addr, vma);\n\t\t\treturn vma;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nstruct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\n\t/* check the cache first */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\t/* trawl the list (there may be multiple mappings in which addr\n\t * resides) */\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_start > addr)\n\t\t\treturn NULL;\n\t\tif (vma->vm_end > addr) {\n\t\t\tvmacache_update(addr, vma);\n\t\t\treturn vma;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic int add_page_for_migration(struct mm_struct *mm, unsigned long addr,\n\t\tint node, struct list_head *pagelist, bool migrate_all)\n{\n\tstruct vm_area_struct *vma;\n\tstruct page *page;\n\tunsigned int follflags;\n\tint err;\n\n\tdown_read(&mm->mmap_sem);\n\terr = -EFAULT;\n\tvma = find_vma(mm, addr);\n\tif (!vma || addr < vma->vm_start || !vma_migratable(vma))\n\t\tgoto out;\n\n\t/* FOLL_DUMP to ignore special (like zero) pages */\n\tfollflags = FOLL_GET | FOLL_DUMP;\n\tpage = follow_page(vma, addr, follflags);\n\n\terr = PTR_ERR(page);\n\tif (IS_ERR(page))\n\t\tgoto out;\n\n\terr = -ENOENT;\n\tif (!page)\n\t\tgoto out;\n\n\terr = 0;\n\tif (page_to_nid(page) == node)\n\t\tgoto out_putpage;\n\n\terr = -EACCES;\n\tif (page_mapcount(page) > 1 && !migrate_all)\n\t\tgoto out_putpage;\n\n\tif (PageHuge(page)) {\n\t\tif (PageHead(page)) {\n\t\t\tisolate_huge_page(page, pagelist);\n\t\t\terr = 0;\n\t\t}\n\t} else {\n\t\tstruct page *head;\n\n\t\thead = compound_head(page);\n\t\terr = isolate_lru_page(head);\n\t\tif (err)\n\t\t\tgoto out_putpage;\n\n\t\terr = 0;\n\t\tlist_add_tail(&head->lru, pagelist);\n\t\tmod_node_page_state(page_pgdat(head),\n\t\t\tNR_ISOLATED_ANON + page_is_file_cache(head),\n\t\t\thpage_nr_pages(head));\n\t}\nout_putpage:\n\t/*\n\t * Either remove the duplicate refcount from\n\t * isolate_lru_page() or drop the page ref if it was\n\t * not isolated.\n\t */\n\tput_page(page);\nout:\n\tup_read(&mm->mmap_sem);\n\treturn err;\n}"
  },
  {
    "function_name": "do_move_pages_to_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "1464-1477",
    "snippet": "static int do_move_pages_to_node(struct mm_struct *mm,\n\t\tstruct list_head *pagelist, int node)\n{\n\tint err;\n\n\tif (list_empty(pagelist))\n\t\treturn 0;\n\n\terr = migrate_pages(pagelist, alloc_new_node_page, NULL, node,\n\t\t\tMIGRATE_SYNC, MR_SYSCALL);\n\tif (err)\n\t\tputback_movable_pages(pagelist);\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "putback_movable_pages",
          "args": [
            "pagelist"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "putback_movable_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "167-198",
          "snippet": "void putback_movable_pages(struct list_head *l)\n{\n\tstruct page *page;\n\tstruct page *page2;\n\n\tlist_for_each_entry_safe(page, page2, l, lru) {\n\t\tif (unlikely(PageHuge(page))) {\n\t\t\tputback_active_hugepage(page);\n\t\t\tcontinue;\n\t\t}\n\t\tlist_del(&page->lru);\n\t\t/*\n\t\t * We isolated non-lru movable page so here we can use\n\t\t * __PageMovable because LRU page's mapping cannot have\n\t\t * PAGE_MAPPING_MOVABLE.\n\t\t */\n\t\tif (unlikely(__PageMovable(page))) {\n\t\t\tVM_BUG_ON_PAGE(!PageIsolated(page), page);\n\t\t\tlock_page(page);\n\t\t\tif (PageMovable(page))\n\t\t\t\tputback_movable_page(page);\n\t\t\telse\n\t\t\t\t__ClearPageIsolated(page);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t} else {\n\t\t\tmod_node_page_state(page_pgdat(page), NR_ISOLATED_ANON +\n\t\t\t\t\tpage_is_file_cache(page), -hpage_nr_pages(page));\n\t\t\tputback_lru_page(page);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nvoid putback_movable_pages(struct list_head *l)\n{\n\tstruct page *page;\n\tstruct page *page2;\n\n\tlist_for_each_entry_safe(page, page2, l, lru) {\n\t\tif (unlikely(PageHuge(page))) {\n\t\t\tputback_active_hugepage(page);\n\t\t\tcontinue;\n\t\t}\n\t\tlist_del(&page->lru);\n\t\t/*\n\t\t * We isolated non-lru movable page so here we can use\n\t\t * __PageMovable because LRU page's mapping cannot have\n\t\t * PAGE_MAPPING_MOVABLE.\n\t\t */\n\t\tif (unlikely(__PageMovable(page))) {\n\t\t\tVM_BUG_ON_PAGE(!PageIsolated(page), page);\n\t\t\tlock_page(page);\n\t\t\tif (PageMovable(page))\n\t\t\t\tputback_movable_page(page);\n\t\t\telse\n\t\t\t\t__ClearPageIsolated(page);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t} else {\n\t\t\tmod_node_page_state(page_pgdat(page), NR_ISOLATED_ANON +\n\t\t\t\t\tpage_is_file_cache(page), -hpage_nr_pages(page));\n\t\t\tputback_lru_page(page);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "migrate_pages",
          "args": [
            "pagelist",
            "alloc_new_node_page",
            "NULL",
            "node",
            "MIGRATE_SYNC",
            "MR_SYSCALL"
          ],
          "line": 1472
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "1362-1449",
          "snippet": "int migrate_pages(struct list_head *from, new_page_t get_new_page,\n\t\tfree_page_t put_new_page, unsigned long private,\n\t\tenum migrate_mode mode, int reason)\n{\n\tint retry = 1;\n\tint nr_failed = 0;\n\tint nr_succeeded = 0;\n\tint pass = 0;\n\tstruct page *page;\n\tstruct page *page2;\n\tint swapwrite = current->flags & PF_SWAPWRITE;\n\tint rc;\n\n\tif (!swapwrite)\n\t\tcurrent->flags |= PF_SWAPWRITE;\n\n\tfor(pass = 0; pass < 10 && retry; pass++) {\n\t\tretry = 0;\n\n\t\tlist_for_each_entry_safe(page, page2, from, lru) {\nretry:\n\t\t\tcond_resched();\n\n\t\t\tif (PageHuge(page))\n\t\t\t\trc = unmap_and_move_huge_page(get_new_page,\n\t\t\t\t\t\tput_new_page, private, page,\n\t\t\t\t\t\tpass > 2, mode, reason);\n\t\t\telse\n\t\t\t\trc = unmap_and_move(get_new_page, put_new_page,\n\t\t\t\t\t\tprivate, page, pass > 2, mode,\n\t\t\t\t\t\treason);\n\n\t\t\tswitch(rc) {\n\t\t\tcase -ENOMEM:\n\t\t\t\t/*\n\t\t\t\t * THP migration might be unsupported or the\n\t\t\t\t * allocation could've failed so we should\n\t\t\t\t * retry on the same page with the THP split\n\t\t\t\t * to base pages.\n\t\t\t\t *\n\t\t\t\t * Head page is retried immediately and tail\n\t\t\t\t * pages are added to the tail of the list so\n\t\t\t\t * we encounter them after the rest of the list\n\t\t\t\t * is processed.\n\t\t\t\t */\n\t\t\t\tif (PageTransHuge(page) && !PageHuge(page)) {\n\t\t\t\t\tlock_page(page);\n\t\t\t\t\trc = split_huge_page_to_list(page, from);\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tif (!rc) {\n\t\t\t\t\t\tlist_safe_reset_next(page, page2, lru);\n\t\t\t\t\t\tgoto retry;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnr_failed++;\n\t\t\t\tgoto out;\n\t\t\tcase -EAGAIN:\n\t\t\t\tretry++;\n\t\t\t\tbreak;\n\t\t\tcase MIGRATEPAGE_SUCCESS:\n\t\t\t\tnr_succeeded++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t * Permanent failure (-EBUSY, -ENOSYS, etc.):\n\t\t\t\t * unlike -EAGAIN case, the failed page is\n\t\t\t\t * removed from migration page list and not\n\t\t\t\t * retried in the next outer loop.\n\t\t\t\t */\n\t\t\t\tnr_failed++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tnr_failed += retry;\n\trc = nr_failed;\nout:\n\tif (nr_succeeded)\n\t\tcount_vm_events(PGMIGRATE_SUCCESS, nr_succeeded);\n\tif (nr_failed)\n\t\tcount_vm_events(PGMIGRATE_FAIL, nr_failed);\n\ttrace_mm_migrate_pages(nr_succeeded, nr_failed, mode, reason);\n\n\tif (!swapwrite)\n\t\tcurrent->flags &= ~PF_SWAPWRITE;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nint migrate_pages(struct list_head *from, new_page_t get_new_page,\n\t\tfree_page_t put_new_page, unsigned long private,\n\t\tenum migrate_mode mode, int reason)\n{\n\tint retry = 1;\n\tint nr_failed = 0;\n\tint nr_succeeded = 0;\n\tint pass = 0;\n\tstruct page *page;\n\tstruct page *page2;\n\tint swapwrite = current->flags & PF_SWAPWRITE;\n\tint rc;\n\n\tif (!swapwrite)\n\t\tcurrent->flags |= PF_SWAPWRITE;\n\n\tfor(pass = 0; pass < 10 && retry; pass++) {\n\t\tretry = 0;\n\n\t\tlist_for_each_entry_safe(page, page2, from, lru) {\nretry:\n\t\t\tcond_resched();\n\n\t\t\tif (PageHuge(page))\n\t\t\t\trc = unmap_and_move_huge_page(get_new_page,\n\t\t\t\t\t\tput_new_page, private, page,\n\t\t\t\t\t\tpass > 2, mode, reason);\n\t\t\telse\n\t\t\t\trc = unmap_and_move(get_new_page, put_new_page,\n\t\t\t\t\t\tprivate, page, pass > 2, mode,\n\t\t\t\t\t\treason);\n\n\t\t\tswitch(rc) {\n\t\t\tcase -ENOMEM:\n\t\t\t\t/*\n\t\t\t\t * THP migration might be unsupported or the\n\t\t\t\t * allocation could've failed so we should\n\t\t\t\t * retry on the same page with the THP split\n\t\t\t\t * to base pages.\n\t\t\t\t *\n\t\t\t\t * Head page is retried immediately and tail\n\t\t\t\t * pages are added to the tail of the list so\n\t\t\t\t * we encounter them after the rest of the list\n\t\t\t\t * is processed.\n\t\t\t\t */\n\t\t\t\tif (PageTransHuge(page) && !PageHuge(page)) {\n\t\t\t\t\tlock_page(page);\n\t\t\t\t\trc = split_huge_page_to_list(page, from);\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tif (!rc) {\n\t\t\t\t\t\tlist_safe_reset_next(page, page2, lru);\n\t\t\t\t\t\tgoto retry;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnr_failed++;\n\t\t\t\tgoto out;\n\t\t\tcase -EAGAIN:\n\t\t\t\tretry++;\n\t\t\t\tbreak;\n\t\t\tcase MIGRATEPAGE_SUCCESS:\n\t\t\t\tnr_succeeded++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t * Permanent failure (-EBUSY, -ENOSYS, etc.):\n\t\t\t\t * unlike -EAGAIN case, the failed page is\n\t\t\t\t * removed from migration page list and not\n\t\t\t\t * retried in the next outer loop.\n\t\t\t\t */\n\t\t\t\tnr_failed++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tnr_failed += retry;\n\trc = nr_failed;\nout:\n\tif (nr_succeeded)\n\t\tcount_vm_events(PGMIGRATE_SUCCESS, nr_succeeded);\n\tif (nr_failed)\n\t\tcount_vm_events(PGMIGRATE_FAIL, nr_failed);\n\ttrace_mm_migrate_pages(nr_succeeded, nr_failed, mode, reason);\n\n\tif (!swapwrite)\n\t\tcurrent->flags &= ~PF_SWAPWRITE;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "pagelist"
          ],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic int do_move_pages_to_node(struct mm_struct *mm,\n\t\tstruct list_head *pagelist, int node)\n{\n\tint err;\n\n\tif (list_empty(pagelist))\n\t\treturn 0;\n\n\terr = migrate_pages(pagelist, alloc_new_node_page, NULL, node,\n\t\t\tMIGRATE_SYNC, MR_SYSCALL);\n\tif (err)\n\t\tputback_movable_pages(pagelist);\n\treturn err;\n}"
  },
  {
    "function_name": "store_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "1453-1462",
    "snippet": "static int store_status(int __user *status, int start, int value, int nr)\n{\n\twhile (nr-- > 0) {\n\t\tif (put_user(value, status + start))\n\t\t\treturn -EFAULT;\n\t\tstart++;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "value",
            "status + start"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic int store_status(int __user *status, int start, int value, int nr)\n{\n\twhile (nr-- > 0) {\n\t\tif (put_user(value, status + start))\n\t\t\treturn -EFAULT;\n\t\tstart++;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "migrate_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "1362-1449",
    "snippet": "int migrate_pages(struct list_head *from, new_page_t get_new_page,\n\t\tfree_page_t put_new_page, unsigned long private,\n\t\tenum migrate_mode mode, int reason)\n{\n\tint retry = 1;\n\tint nr_failed = 0;\n\tint nr_succeeded = 0;\n\tint pass = 0;\n\tstruct page *page;\n\tstruct page *page2;\n\tint swapwrite = current->flags & PF_SWAPWRITE;\n\tint rc;\n\n\tif (!swapwrite)\n\t\tcurrent->flags |= PF_SWAPWRITE;\n\n\tfor(pass = 0; pass < 10 && retry; pass++) {\n\t\tretry = 0;\n\n\t\tlist_for_each_entry_safe(page, page2, from, lru) {\nretry:\n\t\t\tcond_resched();\n\n\t\t\tif (PageHuge(page))\n\t\t\t\trc = unmap_and_move_huge_page(get_new_page,\n\t\t\t\t\t\tput_new_page, private, page,\n\t\t\t\t\t\tpass > 2, mode, reason);\n\t\t\telse\n\t\t\t\trc = unmap_and_move(get_new_page, put_new_page,\n\t\t\t\t\t\tprivate, page, pass > 2, mode,\n\t\t\t\t\t\treason);\n\n\t\t\tswitch(rc) {\n\t\t\tcase -ENOMEM:\n\t\t\t\t/*\n\t\t\t\t * THP migration might be unsupported or the\n\t\t\t\t * allocation could've failed so we should\n\t\t\t\t * retry on the same page with the THP split\n\t\t\t\t * to base pages.\n\t\t\t\t *\n\t\t\t\t * Head page is retried immediately and tail\n\t\t\t\t * pages are added to the tail of the list so\n\t\t\t\t * we encounter them after the rest of the list\n\t\t\t\t * is processed.\n\t\t\t\t */\n\t\t\t\tif (PageTransHuge(page) && !PageHuge(page)) {\n\t\t\t\t\tlock_page(page);\n\t\t\t\t\trc = split_huge_page_to_list(page, from);\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tif (!rc) {\n\t\t\t\t\t\tlist_safe_reset_next(page, page2, lru);\n\t\t\t\t\t\tgoto retry;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnr_failed++;\n\t\t\t\tgoto out;\n\t\t\tcase -EAGAIN:\n\t\t\t\tretry++;\n\t\t\t\tbreak;\n\t\t\tcase MIGRATEPAGE_SUCCESS:\n\t\t\t\tnr_succeeded++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t * Permanent failure (-EBUSY, -ENOSYS, etc.):\n\t\t\t\t * unlike -EAGAIN case, the failed page is\n\t\t\t\t * removed from migration page list and not\n\t\t\t\t * retried in the next outer loop.\n\t\t\t\t */\n\t\t\t\tnr_failed++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tnr_failed += retry;\n\trc = nr_failed;\nout:\n\tif (nr_succeeded)\n\t\tcount_vm_events(PGMIGRATE_SUCCESS, nr_succeeded);\n\tif (nr_failed)\n\t\tcount_vm_events(PGMIGRATE_FAIL, nr_failed);\n\ttrace_mm_migrate_pages(nr_succeeded, nr_failed, mode, reason);\n\n\tif (!swapwrite)\n\t\tcurrent->flags &= ~PF_SWAPWRITE;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_mm_migrate_pages",
          "args": [
            "nr_succeeded",
            "nr_failed",
            "mode",
            "reason"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vm_events",
          "args": [
            "PGMIGRATE_FAIL",
            "nr_failed"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vm_events",
          "args": [
            "PGMIGRATE_SUCCESS",
            "nr_succeeded"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_safe_reset_next",
          "args": [
            "page",
            "page2",
            "lru"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "split_huge_page_to_list",
          "args": [
            "page",
            "from"
          ],
          "line": 1409
        },
        "resolved": true,
        "details": {
          "function_name": "split_huge_page_to_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "2620-2744",
          "snippet": "int split_huge_page_to_list(struct page *page, struct list_head *list)\n{\n\tstruct page *head = compound_head(page);\n\tstruct pglist_data *pgdata = NODE_DATA(page_to_nid(head));\n\tstruct anon_vma *anon_vma = NULL;\n\tstruct address_space *mapping = NULL;\n\tint count, mapcount, extra_pins, ret;\n\tbool mlocked;\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(is_huge_zero_page(page), page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(!PageCompound(page), page);\n\n\tif (PageWriteback(page))\n\t\treturn -EBUSY;\n\n\tif (PageAnon(head)) {\n\t\t/*\n\t\t * The caller does not necessarily hold an mmap_sem that would\n\t\t * prevent the anon_vma disappearing so we first we take a\n\t\t * reference to it and then lock the anon_vma for write. This\n\t\t * is similar to page_lock_anon_vma_read except the write lock\n\t\t * is taken to serialise against parallel split or collapse\n\t\t * operations.\n\t\t */\n\t\tanon_vma = page_get_anon_vma(head);\n\t\tif (!anon_vma) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t\tmapping = NULL;\n\t\tanon_vma_lock_write(anon_vma);\n\t} else {\n\t\tmapping = head->mapping;\n\n\t\t/* Truncated ? */\n\t\tif (!mapping) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tanon_vma = NULL;\n\t\ti_mmap_lock_read(mapping);\n\t}\n\n\t/*\n\t * Racy check if we can split the page, before freeze_page() will\n\t * split PMDs\n\t */\n\tif (!can_split_huge_page(head, &extra_pins)) {\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\n\tmlocked = PageMlocked(page);\n\tfreeze_page(head);\n\tVM_BUG_ON_PAGE(compound_mapcount(head), head);\n\n\t/* Make sure the page is not on per-CPU pagevec as it takes pin */\n\tif (mlocked)\n\t\tlru_add_drain();\n\n\t/* prevent PageLRU to go away from under us, and freeze lru stats */\n\tspin_lock_irqsave(zone_lru_lock(page_zone(head)), flags);\n\n\tif (mapping) {\n\t\tXA_STATE(xas, &mapping->i_pages, page_index(head));\n\n\t\t/*\n\t\t * Check if the head page is present in page cache.\n\t\t * We assume all tail are present too, if head is there.\n\t\t */\n\t\txa_lock(&mapping->i_pages);\n\t\tif (xas_load(&xas) != head)\n\t\t\tgoto fail;\n\t}\n\n\t/* Prevent deferred_split_scan() touching ->_refcount */\n\tspin_lock(&pgdata->split_queue_lock);\n\tcount = page_count(head);\n\tmapcount = total_mapcount(head);\n\tif (!mapcount && page_ref_freeze(head, 1 + extra_pins)) {\n\t\tif (!list_empty(page_deferred_list(head))) {\n\t\t\tpgdata->split_queue_len--;\n\t\t\tlist_del(page_deferred_list(head));\n\t\t}\n\t\tif (mapping)\n\t\t\t__dec_node_page_state(page, NR_SHMEM_THPS);\n\t\tspin_unlock(&pgdata->split_queue_lock);\n\t\t__split_huge_page(page, list, flags);\n\t\tif (PageSwapCache(head)) {\n\t\t\tswp_entry_t entry = { .val = page_private(head) };\n\n\t\t\tret = split_swap_cluster(entry);\n\t\t} else\n\t\t\tret = 0;\n\t} else {\n\t\tif (IS_ENABLED(CONFIG_DEBUG_VM) && mapcount) {\n\t\t\tpr_alert(\"total_mapcount: %u, page_count(): %u\\n\",\n\t\t\t\t\tmapcount, count);\n\t\t\tif (PageTail(page))\n\t\t\t\tdump_page(head, NULL);\n\t\t\tdump_page(page, \"total_mapcount(head) > 0\");\n\t\t\tBUG();\n\t\t}\n\t\tspin_unlock(&pgdata->split_queue_lock);\nfail:\t\tif (mapping)\n\t\t\txa_unlock(&mapping->i_pages);\n\t\tspin_unlock_irqrestore(zone_lru_lock(page_zone(head)), flags);\n\t\tunfreeze_page(head);\n\t\tret = -EBUSY;\n\t}\n\nout_unlock:\n\tif (anon_vma) {\n\t\tanon_vma_unlock_write(anon_vma);\n\t\tput_anon_vma(anon_vma);\n\t}\n\tif (mapping)\n\t\ti_mmap_unlock_read(mapping);\nout:\n\tcount_vm_event(!ret ? THP_SPLIT_PAGE : THP_SPLIT_PAGE_FAILED);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nint split_huge_page_to_list(struct page *page, struct list_head *list)\n{\n\tstruct page *head = compound_head(page);\n\tstruct pglist_data *pgdata = NODE_DATA(page_to_nid(head));\n\tstruct anon_vma *anon_vma = NULL;\n\tstruct address_space *mapping = NULL;\n\tint count, mapcount, extra_pins, ret;\n\tbool mlocked;\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(is_huge_zero_page(page), page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(!PageCompound(page), page);\n\n\tif (PageWriteback(page))\n\t\treturn -EBUSY;\n\n\tif (PageAnon(head)) {\n\t\t/*\n\t\t * The caller does not necessarily hold an mmap_sem that would\n\t\t * prevent the anon_vma disappearing so we first we take a\n\t\t * reference to it and then lock the anon_vma for write. This\n\t\t * is similar to page_lock_anon_vma_read except the write lock\n\t\t * is taken to serialise against parallel split or collapse\n\t\t * operations.\n\t\t */\n\t\tanon_vma = page_get_anon_vma(head);\n\t\tif (!anon_vma) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t\tmapping = NULL;\n\t\tanon_vma_lock_write(anon_vma);\n\t} else {\n\t\tmapping = head->mapping;\n\n\t\t/* Truncated ? */\n\t\tif (!mapping) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tanon_vma = NULL;\n\t\ti_mmap_lock_read(mapping);\n\t}\n\n\t/*\n\t * Racy check if we can split the page, before freeze_page() will\n\t * split PMDs\n\t */\n\tif (!can_split_huge_page(head, &extra_pins)) {\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\n\tmlocked = PageMlocked(page);\n\tfreeze_page(head);\n\tVM_BUG_ON_PAGE(compound_mapcount(head), head);\n\n\t/* Make sure the page is not on per-CPU pagevec as it takes pin */\n\tif (mlocked)\n\t\tlru_add_drain();\n\n\t/* prevent PageLRU to go away from under us, and freeze lru stats */\n\tspin_lock_irqsave(zone_lru_lock(page_zone(head)), flags);\n\n\tif (mapping) {\n\t\tXA_STATE(xas, &mapping->i_pages, page_index(head));\n\n\t\t/*\n\t\t * Check if the head page is present in page cache.\n\t\t * We assume all tail are present too, if head is there.\n\t\t */\n\t\txa_lock(&mapping->i_pages);\n\t\tif (xas_load(&xas) != head)\n\t\t\tgoto fail;\n\t}\n\n\t/* Prevent deferred_split_scan() touching ->_refcount */\n\tspin_lock(&pgdata->split_queue_lock);\n\tcount = page_count(head);\n\tmapcount = total_mapcount(head);\n\tif (!mapcount && page_ref_freeze(head, 1 + extra_pins)) {\n\t\tif (!list_empty(page_deferred_list(head))) {\n\t\t\tpgdata->split_queue_len--;\n\t\t\tlist_del(page_deferred_list(head));\n\t\t}\n\t\tif (mapping)\n\t\t\t__dec_node_page_state(page, NR_SHMEM_THPS);\n\t\tspin_unlock(&pgdata->split_queue_lock);\n\t\t__split_huge_page(page, list, flags);\n\t\tif (PageSwapCache(head)) {\n\t\t\tswp_entry_t entry = { .val = page_private(head) };\n\n\t\t\tret = split_swap_cluster(entry);\n\t\t} else\n\t\t\tret = 0;\n\t} else {\n\t\tif (IS_ENABLED(CONFIG_DEBUG_VM) && mapcount) {\n\t\t\tpr_alert(\"total_mapcount: %u, page_count(): %u\\n\",\n\t\t\t\t\tmapcount, count);\n\t\t\tif (PageTail(page))\n\t\t\t\tdump_page(head, NULL);\n\t\t\tdump_page(page, \"total_mapcount(head) > 0\");\n\t\t\tBUG();\n\t\t}\n\t\tspin_unlock(&pgdata->split_queue_lock);\nfail:\t\tif (mapping)\n\t\t\txa_unlock(&mapping->i_pages);\n\t\tspin_unlock_irqrestore(zone_lru_lock(page_zone(head)), flags);\n\t\tunfreeze_page(head);\n\t\tret = -EBUSY;\n\t}\n\nout_unlock:\n\tif (anon_vma) {\n\t\tanon_vma_unlock_write(anon_vma);\n\t\tput_anon_vma(anon_vma);\n\t}\n\tif (mapping)\n\t\ti_mmap_unlock_read(mapping);\nout:\n\tcount_vm_event(!ret ? THP_SPLIT_PAGE : THP_SPLIT_PAGE_FAILED);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "page"
          ],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "PageHugeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "225-228",
          "snippet": "static int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "page"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_and_move",
          "args": [
            "get_new_page",
            "put_new_page",
            "private",
            "page",
            "pass > 2",
            "mode",
            "reason"
          ],
          "line": 1390
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_and_move_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "1254-1339",
          "snippet": "static int unmap_and_move_huge_page(new_page_t get_new_page,\n\t\t\t\tfree_page_t put_new_page, unsigned long private,\n\t\t\t\tstruct page *hpage, int force,\n\t\t\t\tenum migrate_mode mode, int reason)\n{\n\tint rc = -EAGAIN;\n\tint page_was_mapped = 0;\n\tstruct page *new_hpage;\n\tstruct anon_vma *anon_vma = NULL;\n\n\t/*\n\t * Movability of hugepages depends on architectures and hugepage size.\n\t * This check is necessary because some callers of hugepage migration\n\t * like soft offline and memory hotremove don't walk through page\n\t * tables or check whether the hugepage is pmd-based or not before\n\t * kicking migration.\n\t */\n\tif (!hugepage_migration_supported(page_hstate(hpage))) {\n\t\tputback_active_hugepage(hpage);\n\t\treturn -ENOSYS;\n\t}\n\n\tnew_hpage = get_new_page(hpage, private);\n\tif (!new_hpage)\n\t\treturn -ENOMEM;\n\n\tif (!trylock_page(hpage)) {\n\t\tif (!force)\n\t\t\tgoto out;\n\t\tswitch (mode) {\n\t\tcase MIGRATE_SYNC:\n\t\tcase MIGRATE_SYNC_NO_COPY:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\t\tlock_page(hpage);\n\t}\n\n\tif (PageAnon(hpage))\n\t\tanon_vma = page_get_anon_vma(hpage);\n\n\tif (unlikely(!trylock_page(new_hpage)))\n\t\tgoto put_anon;\n\n\tif (page_mapped(hpage)) {\n\t\ttry_to_unmap(hpage,\n\t\t\tTTU_MIGRATION|TTU_IGNORE_MLOCK|TTU_IGNORE_ACCESS);\n\t\tpage_was_mapped = 1;\n\t}\n\n\tif (!page_mapped(hpage))\n\t\trc = move_to_new_page(new_hpage, hpage, mode);\n\n\tif (page_was_mapped)\n\t\tremove_migration_ptes(hpage,\n\t\t\trc == MIGRATEPAGE_SUCCESS ? new_hpage : hpage, false);\n\n\tunlock_page(new_hpage);\n\nput_anon:\n\tif (anon_vma)\n\t\tput_anon_vma(anon_vma);\n\n\tif (rc == MIGRATEPAGE_SUCCESS) {\n\t\tmove_hugetlb_state(hpage, new_hpage, reason);\n\t\tput_new_page = NULL;\n\t}\n\n\tunlock_page(hpage);\nout:\n\tif (rc != -EAGAIN)\n\t\tputback_active_hugepage(hpage);\n\n\t/*\n\t * If migration was not successful and there's a freeing callback, use\n\t * it.  Otherwise, put_page() will drop the reference grabbed during\n\t * isolation.\n\t */\n\tif (put_new_page)\n\t\tput_new_page(new_hpage, private);\n\telse\n\t\tputback_active_hugepage(new_hpage);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic int unmap_and_move_huge_page(new_page_t get_new_page,\n\t\t\t\tfree_page_t put_new_page, unsigned long private,\n\t\t\t\tstruct page *hpage, int force,\n\t\t\t\tenum migrate_mode mode, int reason)\n{\n\tint rc = -EAGAIN;\n\tint page_was_mapped = 0;\n\tstruct page *new_hpage;\n\tstruct anon_vma *anon_vma = NULL;\n\n\t/*\n\t * Movability of hugepages depends on architectures and hugepage size.\n\t * This check is necessary because some callers of hugepage migration\n\t * like soft offline and memory hotremove don't walk through page\n\t * tables or check whether the hugepage is pmd-based or not before\n\t * kicking migration.\n\t */\n\tif (!hugepage_migration_supported(page_hstate(hpage))) {\n\t\tputback_active_hugepage(hpage);\n\t\treturn -ENOSYS;\n\t}\n\n\tnew_hpage = get_new_page(hpage, private);\n\tif (!new_hpage)\n\t\treturn -ENOMEM;\n\n\tif (!trylock_page(hpage)) {\n\t\tif (!force)\n\t\t\tgoto out;\n\t\tswitch (mode) {\n\t\tcase MIGRATE_SYNC:\n\t\tcase MIGRATE_SYNC_NO_COPY:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\t\tlock_page(hpage);\n\t}\n\n\tif (PageAnon(hpage))\n\t\tanon_vma = page_get_anon_vma(hpage);\n\n\tif (unlikely(!trylock_page(new_hpage)))\n\t\tgoto put_anon;\n\n\tif (page_mapped(hpage)) {\n\t\ttry_to_unmap(hpage,\n\t\t\tTTU_MIGRATION|TTU_IGNORE_MLOCK|TTU_IGNORE_ACCESS);\n\t\tpage_was_mapped = 1;\n\t}\n\n\tif (!page_mapped(hpage))\n\t\trc = move_to_new_page(new_hpage, hpage, mode);\n\n\tif (page_was_mapped)\n\t\tremove_migration_ptes(hpage,\n\t\t\trc == MIGRATEPAGE_SUCCESS ? new_hpage : hpage, false);\n\n\tunlock_page(new_hpage);\n\nput_anon:\n\tif (anon_vma)\n\t\tput_anon_vma(anon_vma);\n\n\tif (rc == MIGRATEPAGE_SUCCESS) {\n\t\tmove_hugetlb_state(hpage, new_hpage, reason);\n\t\tput_new_page = NULL;\n\t}\n\n\tunlock_page(hpage);\nout:\n\tif (rc != -EAGAIN)\n\t\tputback_active_hugepage(hpage);\n\n\t/*\n\t * If migration was not successful and there's a freeing callback, use\n\t * it.  Otherwise, put_page() will drop the reference grabbed during\n\t * isolation.\n\t */\n\tif (put_new_page)\n\t\tput_new_page(new_hpage, private);\n\telse\n\t\tputback_active_hugepage(new_hpage);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "page",
            "page2",
            "from",
            "lru"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nint migrate_pages(struct list_head *from, new_page_t get_new_page,\n\t\tfree_page_t put_new_page, unsigned long private,\n\t\tenum migrate_mode mode, int reason)\n{\n\tint retry = 1;\n\tint nr_failed = 0;\n\tint nr_succeeded = 0;\n\tint pass = 0;\n\tstruct page *page;\n\tstruct page *page2;\n\tint swapwrite = current->flags & PF_SWAPWRITE;\n\tint rc;\n\n\tif (!swapwrite)\n\t\tcurrent->flags |= PF_SWAPWRITE;\n\n\tfor(pass = 0; pass < 10 && retry; pass++) {\n\t\tretry = 0;\n\n\t\tlist_for_each_entry_safe(page, page2, from, lru) {\nretry:\n\t\t\tcond_resched();\n\n\t\t\tif (PageHuge(page))\n\t\t\t\trc = unmap_and_move_huge_page(get_new_page,\n\t\t\t\t\t\tput_new_page, private, page,\n\t\t\t\t\t\tpass > 2, mode, reason);\n\t\t\telse\n\t\t\t\trc = unmap_and_move(get_new_page, put_new_page,\n\t\t\t\t\t\tprivate, page, pass > 2, mode,\n\t\t\t\t\t\treason);\n\n\t\t\tswitch(rc) {\n\t\t\tcase -ENOMEM:\n\t\t\t\t/*\n\t\t\t\t * THP migration might be unsupported or the\n\t\t\t\t * allocation could've failed so we should\n\t\t\t\t * retry on the same page with the THP split\n\t\t\t\t * to base pages.\n\t\t\t\t *\n\t\t\t\t * Head page is retried immediately and tail\n\t\t\t\t * pages are added to the tail of the list so\n\t\t\t\t * we encounter them after the rest of the list\n\t\t\t\t * is processed.\n\t\t\t\t */\n\t\t\t\tif (PageTransHuge(page) && !PageHuge(page)) {\n\t\t\t\t\tlock_page(page);\n\t\t\t\t\trc = split_huge_page_to_list(page, from);\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tif (!rc) {\n\t\t\t\t\t\tlist_safe_reset_next(page, page2, lru);\n\t\t\t\t\t\tgoto retry;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnr_failed++;\n\t\t\t\tgoto out;\n\t\t\tcase -EAGAIN:\n\t\t\t\tretry++;\n\t\t\t\tbreak;\n\t\t\tcase MIGRATEPAGE_SUCCESS:\n\t\t\t\tnr_succeeded++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t * Permanent failure (-EBUSY, -ENOSYS, etc.):\n\t\t\t\t * unlike -EAGAIN case, the failed page is\n\t\t\t\t * removed from migration page list and not\n\t\t\t\t * retried in the next outer loop.\n\t\t\t\t */\n\t\t\t\tnr_failed++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tnr_failed += retry;\n\trc = nr_failed;\nout:\n\tif (nr_succeeded)\n\t\tcount_vm_events(PGMIGRATE_SUCCESS, nr_succeeded);\n\tif (nr_failed)\n\t\tcount_vm_events(PGMIGRATE_FAIL, nr_failed);\n\ttrace_mm_migrate_pages(nr_succeeded, nr_failed, mode, reason);\n\n\tif (!swapwrite)\n\t\tcurrent->flags &= ~PF_SWAPWRITE;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "unmap_and_move_huge_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "1254-1339",
    "snippet": "static int unmap_and_move_huge_page(new_page_t get_new_page,\n\t\t\t\tfree_page_t put_new_page, unsigned long private,\n\t\t\t\tstruct page *hpage, int force,\n\t\t\t\tenum migrate_mode mode, int reason)\n{\n\tint rc = -EAGAIN;\n\tint page_was_mapped = 0;\n\tstruct page *new_hpage;\n\tstruct anon_vma *anon_vma = NULL;\n\n\t/*\n\t * Movability of hugepages depends on architectures and hugepage size.\n\t * This check is necessary because some callers of hugepage migration\n\t * like soft offline and memory hotremove don't walk through page\n\t * tables or check whether the hugepage is pmd-based or not before\n\t * kicking migration.\n\t */\n\tif (!hugepage_migration_supported(page_hstate(hpage))) {\n\t\tputback_active_hugepage(hpage);\n\t\treturn -ENOSYS;\n\t}\n\n\tnew_hpage = get_new_page(hpage, private);\n\tif (!new_hpage)\n\t\treturn -ENOMEM;\n\n\tif (!trylock_page(hpage)) {\n\t\tif (!force)\n\t\t\tgoto out;\n\t\tswitch (mode) {\n\t\tcase MIGRATE_SYNC:\n\t\tcase MIGRATE_SYNC_NO_COPY:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\t\tlock_page(hpage);\n\t}\n\n\tif (PageAnon(hpage))\n\t\tanon_vma = page_get_anon_vma(hpage);\n\n\tif (unlikely(!trylock_page(new_hpage)))\n\t\tgoto put_anon;\n\n\tif (page_mapped(hpage)) {\n\t\ttry_to_unmap(hpage,\n\t\t\tTTU_MIGRATION|TTU_IGNORE_MLOCK|TTU_IGNORE_ACCESS);\n\t\tpage_was_mapped = 1;\n\t}\n\n\tif (!page_mapped(hpage))\n\t\trc = move_to_new_page(new_hpage, hpage, mode);\n\n\tif (page_was_mapped)\n\t\tremove_migration_ptes(hpage,\n\t\t\trc == MIGRATEPAGE_SUCCESS ? new_hpage : hpage, false);\n\n\tunlock_page(new_hpage);\n\nput_anon:\n\tif (anon_vma)\n\t\tput_anon_vma(anon_vma);\n\n\tif (rc == MIGRATEPAGE_SUCCESS) {\n\t\tmove_hugetlb_state(hpage, new_hpage, reason);\n\t\tput_new_page = NULL;\n\t}\n\n\tunlock_page(hpage);\nout:\n\tif (rc != -EAGAIN)\n\t\tputback_active_hugepage(hpage);\n\n\t/*\n\t * If migration was not successful and there's a freeing callback, use\n\t * it.  Otherwise, put_page() will drop the reference grabbed during\n\t * isolation.\n\t */\n\tif (put_new_page)\n\t\tput_new_page(new_hpage, private);\n\telse\n\t\tputback_active_hugepage(new_hpage);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "putback_active_hugepage",
          "args": [
            "new_hpage"
          ],
          "line": 1336
        },
        "resolved": true,
        "details": {
          "function_name": "putback_active_hugepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "4908-4916",
          "snippet": "void putback_active_hugepage(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageHead(page), page);\n\tspin_lock(&hugetlb_lock);\n\tset_page_huge_active(page);\n\tlist_move_tail(&page->lru, &(page_hstate(page))->hugepage_activelist);\n\tspin_unlock(&hugetlb_lock);\n\tput_page(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nvoid putback_active_hugepage(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageHead(page), page);\n\tspin_lock(&hugetlb_lock);\n\tset_page_huge_active(page);\n\tlist_move_tail(&page->lru, &(page_hstate(page))->hugepage_activelist);\n\tspin_unlock(&hugetlb_lock);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_new_page",
          "args": [
            "new_hpage",
            "private"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "hpage"
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "move_hugetlb_state",
          "args": [
            "hpage",
            "new_hpage",
            "reason"
          ],
          "line": 1319
        },
        "resolved": true,
        "details": {
          "function_name": "move_hugetlb_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "4918-4949",
          "snippet": "void move_hugetlb_state(struct page *oldpage, struct page *newpage, int reason)\n{\n\tstruct hstate *h = page_hstate(oldpage);\n\n\thugetlb_cgroup_migrate(oldpage, newpage);\n\tset_page_owner_migrate_reason(newpage, reason);\n\n\t/*\n\t * transfer temporary state of the new huge page. This is\n\t * reverse to other transitions because the newpage is going to\n\t * be final while the old one will be freed so it takes over\n\t * the temporary status.\n\t *\n\t * Also note that we have to transfer the per-node surplus state\n\t * here as well otherwise the global surplus count will not match\n\t * the per-node's.\n\t */\n\tif (PageHugeTemporary(newpage)) {\n\t\tint old_nid = page_to_nid(oldpage);\n\t\tint new_nid = page_to_nid(newpage);\n\n\t\tSetPageHugeTemporary(oldpage);\n\t\tClearPageHugeTemporary(newpage);\n\n\t\tspin_lock(&hugetlb_lock);\n\t\tif (h->surplus_huge_pages_node[old_nid]) {\n\t\t\th->surplus_huge_pages_node[old_nid]--;\n\t\t\th->surplus_huge_pages_node[new_nid]++;\n\t\t}\n\t\tspin_unlock(&hugetlb_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nvoid move_hugetlb_state(struct page *oldpage, struct page *newpage, int reason)\n{\n\tstruct hstate *h = page_hstate(oldpage);\n\n\thugetlb_cgroup_migrate(oldpage, newpage);\n\tset_page_owner_migrate_reason(newpage, reason);\n\n\t/*\n\t * transfer temporary state of the new huge page. This is\n\t * reverse to other transitions because the newpage is going to\n\t * be final while the old one will be freed so it takes over\n\t * the temporary status.\n\t *\n\t * Also note that we have to transfer the per-node surplus state\n\t * here as well otherwise the global surplus count will not match\n\t * the per-node's.\n\t */\n\tif (PageHugeTemporary(newpage)) {\n\t\tint old_nid = page_to_nid(oldpage);\n\t\tint new_nid = page_to_nid(newpage);\n\n\t\tSetPageHugeTemporary(oldpage);\n\t\tClearPageHugeTemporary(newpage);\n\n\t\tspin_lock(&hugetlb_lock);\n\t\tif (h->surplus_huge_pages_node[old_nid]) {\n\t\t\th->surplus_huge_pages_node[old_nid]--;\n\t\t\th->surplus_huge_pages_node[new_nid]++;\n\t\t}\n\t\tspin_unlock(&hugetlb_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_anon_vma",
          "args": [
            "anon_vma"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "__put_anon_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1758-1765",
          "snippet": "void __put_anon_vma(struct anon_vma *anon_vma)\n{\n\tstruct anon_vma *root = anon_vma->root;\n\n\tanon_vma_free(anon_vma);\n\tif (root != anon_vma && atomic_dec_and_test(&root->refcount))\n\t\tanon_vma_free(root);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid __put_anon_vma(struct anon_vma *anon_vma)\n{\n\tstruct anon_vma *root = anon_vma->root;\n\n\tanon_vma_free(anon_vma);\n\tif (root != anon_vma && atomic_dec_and_test(&root->refcount))\n\t\tanon_vma_free(root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_migration_ptes",
          "args": [
            "hpage",
            "rc == MIGRATEPAGE_SUCCESS ? new_hpage : hpage",
            "false"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "remove_migration_ptes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "292-303",
          "snippet": "void remove_migration_ptes(struct page *old, struct page *new, bool locked)\n{\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = remove_migration_pte,\n\t\t.arg = old,\n\t};\n\n\tif (locked)\n\t\trmap_walk_locked(new, &rwc);\n\telse\n\t\trmap_walk(new, &rwc);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nvoid remove_migration_ptes(struct page *old, struct page *new, bool locked)\n{\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = remove_migration_pte,\n\t\t.arg = old,\n\t};\n\n\tif (locked)\n\t\trmap_walk_locked(new, &rwc);\n\telse\n\t\trmap_walk(new, &rwc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "move_to_new_page",
          "args": [
            "new_hpage",
            "hpage",
            "mode"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "move_to_new_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "908-979",
          "snippet": "static int move_to_new_page(struct page *newpage, struct page *page,\n\t\t\t\tenum migrate_mode mode)\n{\n\tstruct address_space *mapping;\n\tint rc = -EAGAIN;\n\tbool is_lru = !__PageMovable(page);\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(!PageLocked(newpage), newpage);\n\n\tmapping = page_mapping(page);\n\n\tif (likely(is_lru)) {\n\t\tif (!mapping)\n\t\t\trc = migrate_page(mapping, newpage, page, mode);\n\t\telse if (mapping->a_ops->migratepage)\n\t\t\t/*\n\t\t\t * Most pages have a mapping and most filesystems\n\t\t\t * provide a migratepage callback. Anonymous pages\n\t\t\t * are part of swap space which also has its own\n\t\t\t * migratepage callback. This is the most common path\n\t\t\t * for page migration.\n\t\t\t */\n\t\t\trc = mapping->a_ops->migratepage(mapping, newpage,\n\t\t\t\t\t\t\tpage, mode);\n\t\telse\n\t\t\trc = fallback_migrate_page(mapping, newpage,\n\t\t\t\t\t\t\tpage, mode);\n\t} else {\n\t\t/*\n\t\t * In case of non-lru page, it could be released after\n\t\t * isolation step. In that case, we shouldn't try migration.\n\t\t */\n\t\tVM_BUG_ON_PAGE(!PageIsolated(page), page);\n\t\tif (!PageMovable(page)) {\n\t\t\trc = MIGRATEPAGE_SUCCESS;\n\t\t\t__ClearPageIsolated(page);\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = mapping->a_ops->migratepage(mapping, newpage,\n\t\t\t\t\t\tpage, mode);\n\t\tWARN_ON_ONCE(rc == MIGRATEPAGE_SUCCESS &&\n\t\t\t!PageIsolated(page));\n\t}\n\n\t/*\n\t * When successful, old pagecache page->mapping must be cleared before\n\t * page is freed; but stats require that PageAnon be left as PageAnon.\n\t */\n\tif (rc == MIGRATEPAGE_SUCCESS) {\n\t\tif (__PageMovable(page)) {\n\t\t\tVM_BUG_ON_PAGE(!PageIsolated(page), page);\n\n\t\t\t/*\n\t\t\t * We clear PG_movable under page_lock so any compactor\n\t\t\t * cannot try to migrate this page.\n\t\t\t */\n\t\t\t__ClearPageIsolated(page);\n\t\t}\n\n\t\t/*\n\t\t * Anonymous and movable page->mapping will be cleard by\n\t\t * free_pages_prepare so don't reset it here for keeping\n\t\t * the type to work PageAnon, for example.\n\t\t */\n\t\tif (!PageMappingFlags(page))\n\t\t\tpage->mapping = NULL;\n\t}\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic int move_to_new_page(struct page *newpage, struct page *page,\n\t\t\t\tenum migrate_mode mode)\n{\n\tstruct address_space *mapping;\n\tint rc = -EAGAIN;\n\tbool is_lru = !__PageMovable(page);\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(!PageLocked(newpage), newpage);\n\n\tmapping = page_mapping(page);\n\n\tif (likely(is_lru)) {\n\t\tif (!mapping)\n\t\t\trc = migrate_page(mapping, newpage, page, mode);\n\t\telse if (mapping->a_ops->migratepage)\n\t\t\t/*\n\t\t\t * Most pages have a mapping and most filesystems\n\t\t\t * provide a migratepage callback. Anonymous pages\n\t\t\t * are part of swap space which also has its own\n\t\t\t * migratepage callback. This is the most common path\n\t\t\t * for page migration.\n\t\t\t */\n\t\t\trc = mapping->a_ops->migratepage(mapping, newpage,\n\t\t\t\t\t\t\tpage, mode);\n\t\telse\n\t\t\trc = fallback_migrate_page(mapping, newpage,\n\t\t\t\t\t\t\tpage, mode);\n\t} else {\n\t\t/*\n\t\t * In case of non-lru page, it could be released after\n\t\t * isolation step. In that case, we shouldn't try migration.\n\t\t */\n\t\tVM_BUG_ON_PAGE(!PageIsolated(page), page);\n\t\tif (!PageMovable(page)) {\n\t\t\trc = MIGRATEPAGE_SUCCESS;\n\t\t\t__ClearPageIsolated(page);\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = mapping->a_ops->migratepage(mapping, newpage,\n\t\t\t\t\t\tpage, mode);\n\t\tWARN_ON_ONCE(rc == MIGRATEPAGE_SUCCESS &&\n\t\t\t!PageIsolated(page));\n\t}\n\n\t/*\n\t * When successful, old pagecache page->mapping must be cleared before\n\t * page is freed; but stats require that PageAnon be left as PageAnon.\n\t */\n\tif (rc == MIGRATEPAGE_SUCCESS) {\n\t\tif (__PageMovable(page)) {\n\t\t\tVM_BUG_ON_PAGE(!PageIsolated(page), page);\n\n\t\t\t/*\n\t\t\t * We clear PG_movable under page_lock so any compactor\n\t\t\t * cannot try to migrate this page.\n\t\t\t */\n\t\t\t__ClearPageIsolated(page);\n\t\t}\n\n\t\t/*\n\t\t * Anonymous and movable page->mapping will be cleard by\n\t\t * free_pages_prepare so don't reset it here for keeping\n\t\t * the type to work PageAnon, for example.\n\t\t */\n\t\tif (!PageMappingFlags(page))\n\t\t\tpage->mapping = NULL;\n\t}\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_mapped",
          "args": [
            "hpage"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "470-486",
          "snippet": "bool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nbool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_unmap",
          "args": [
            "hpage",
            "TTU_MIGRATION|TTU_IGNORE_MLOCK|TTU_IGNORE_ACCESS"
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_unmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1699-1726",
          "snippet": "bool try_to_unmap(struct page *page, enum ttu_flags flags)\n{\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = try_to_unmap_one,\n\t\t.arg = (void *)flags,\n\t\t.done = page_mapcount_is_zero,\n\t\t.anon_lock = page_lock_anon_vma_read,\n\t};\n\n\t/*\n\t * During exec, a temporary VMA is setup and later moved.\n\t * The VMA is moved under the anon_vma lock but not the\n\t * page tables leading to a race where migration cannot\n\t * find the migration ptes. Rather than increasing the\n\t * locking requirements of exec(), migration skips\n\t * temporary VMAs until after exec() completes.\n\t */\n\tif ((flags & (TTU_MIGRATION|TTU_SPLIT_FREEZE))\n\t    && !PageKsm(page) && PageAnon(page))\n\t\trwc.invalid_vma = invalid_migration_vma;\n\n\tif (flags & TTU_RMAP_LOCKED)\n\t\trmap_walk_locked(page, &rwc);\n\telse\n\t\trmap_walk(page, &rwc);\n\n\treturn !page_mapcount(page) ? true : false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nbool try_to_unmap(struct page *page, enum ttu_flags flags)\n{\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = try_to_unmap_one,\n\t\t.arg = (void *)flags,\n\t\t.done = page_mapcount_is_zero,\n\t\t.anon_lock = page_lock_anon_vma_read,\n\t};\n\n\t/*\n\t * During exec, a temporary VMA is setup and later moved.\n\t * The VMA is moved under the anon_vma lock but not the\n\t * page tables leading to a race where migration cannot\n\t * find the migration ptes. Rather than increasing the\n\t * locking requirements of exec(), migration skips\n\t * temporary VMAs until after exec() completes.\n\t */\n\tif ((flags & (TTU_MIGRATION|TTU_SPLIT_FREEZE))\n\t    && !PageKsm(page) && PageAnon(page))\n\t\trwc.invalid_vma = invalid_migration_vma;\n\n\tif (flags & TTU_RMAP_LOCKED)\n\t\trmap_walk_locked(page, &rwc);\n\telse\n\t\trmap_walk(page, &rwc);\n\n\treturn !page_mapcount(page) ? true : false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!trylock_page(new_hpage)"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "new_hpage"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_get_anon_vma",
          "args": [
            "hpage"
          ],
          "line": 1294
        },
        "resolved": true,
        "details": {
          "function_name": "page_get_anon_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "464-498",
          "snippet": "struct anon_vma *page_get_anon_vma(struct page *page)\n{\n\tstruct anon_vma *anon_vma = NULL;\n\tunsigned long anon_mapping;\n\n\trcu_read_lock();\n\tanon_mapping = (unsigned long)READ_ONCE(page->mapping);\n\tif ((anon_mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)\n\t\tgoto out;\n\tif (!page_mapped(page))\n\t\tgoto out;\n\n\tanon_vma = (struct anon_vma *) (anon_mapping - PAGE_MAPPING_ANON);\n\tif (!atomic_inc_not_zero(&anon_vma->refcount)) {\n\t\tanon_vma = NULL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If this page is still mapped, then its anon_vma cannot have been\n\t * freed.  But if it has been unmapped, we have no security against the\n\t * anon_vma structure being freed and reused (for another anon_vma:\n\t * SLAB_TYPESAFE_BY_RCU guarantees that - so the atomic_inc_not_zero()\n\t * above cannot corrupt).\n\t */\n\tif (!page_mapped(page)) {\n\t\trcu_read_unlock();\n\t\tput_anon_vma(anon_vma);\n\t\treturn NULL;\n\t}\nout:\n\trcu_read_unlock();\n\n\treturn anon_vma;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstruct anon_vma *page_get_anon_vma(struct page *page)\n{\n\tstruct anon_vma *anon_vma = NULL;\n\tunsigned long anon_mapping;\n\n\trcu_read_lock();\n\tanon_mapping = (unsigned long)READ_ONCE(page->mapping);\n\tif ((anon_mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)\n\t\tgoto out;\n\tif (!page_mapped(page))\n\t\tgoto out;\n\n\tanon_vma = (struct anon_vma *) (anon_mapping - PAGE_MAPPING_ANON);\n\tif (!atomic_inc_not_zero(&anon_vma->refcount)) {\n\t\tanon_vma = NULL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If this page is still mapped, then its anon_vma cannot have been\n\t * freed.  But if it has been unmapped, we have no security against the\n\t * anon_vma structure being freed and reused (for another anon_vma:\n\t * SLAB_TYPESAFE_BY_RCU guarantees that - so the atomic_inc_not_zero()\n\t * above cannot corrupt).\n\t */\n\tif (!page_mapped(page)) {\n\t\trcu_read_unlock();\n\t\tput_anon_vma(anon_vma);\n\t\treturn NULL;\n\t}\nout:\n\trcu_read_unlock();\n\n\treturn anon_vma;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "hpage"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "hpage"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_new_page",
          "args": [
            "hpage",
            "private"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugepage_migration_supported",
          "args": [
            "page_hstate(hpage)"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_hstate",
          "args": [
            "hpage"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic int unmap_and_move_huge_page(new_page_t get_new_page,\n\t\t\t\tfree_page_t put_new_page, unsigned long private,\n\t\t\t\tstruct page *hpage, int force,\n\t\t\t\tenum migrate_mode mode, int reason)\n{\n\tint rc = -EAGAIN;\n\tint page_was_mapped = 0;\n\tstruct page *new_hpage;\n\tstruct anon_vma *anon_vma = NULL;\n\n\t/*\n\t * Movability of hugepages depends on architectures and hugepage size.\n\t * This check is necessary because some callers of hugepage migration\n\t * like soft offline and memory hotremove don't walk through page\n\t * tables or check whether the hugepage is pmd-based or not before\n\t * kicking migration.\n\t */\n\tif (!hugepage_migration_supported(page_hstate(hpage))) {\n\t\tputback_active_hugepage(hpage);\n\t\treturn -ENOSYS;\n\t}\n\n\tnew_hpage = get_new_page(hpage, private);\n\tif (!new_hpage)\n\t\treturn -ENOMEM;\n\n\tif (!trylock_page(hpage)) {\n\t\tif (!force)\n\t\t\tgoto out;\n\t\tswitch (mode) {\n\t\tcase MIGRATE_SYNC:\n\t\tcase MIGRATE_SYNC_NO_COPY:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\t\tlock_page(hpage);\n\t}\n\n\tif (PageAnon(hpage))\n\t\tanon_vma = page_get_anon_vma(hpage);\n\n\tif (unlikely(!trylock_page(new_hpage)))\n\t\tgoto put_anon;\n\n\tif (page_mapped(hpage)) {\n\t\ttry_to_unmap(hpage,\n\t\t\tTTU_MIGRATION|TTU_IGNORE_MLOCK|TTU_IGNORE_ACCESS);\n\t\tpage_was_mapped = 1;\n\t}\n\n\tif (!page_mapped(hpage))\n\t\trc = move_to_new_page(new_hpage, hpage, mode);\n\n\tif (page_was_mapped)\n\t\tremove_migration_ptes(hpage,\n\t\t\trc == MIGRATEPAGE_SUCCESS ? new_hpage : hpage, false);\n\n\tunlock_page(new_hpage);\n\nput_anon:\n\tif (anon_vma)\n\t\tput_anon_vma(anon_vma);\n\n\tif (rc == MIGRATEPAGE_SUCCESS) {\n\t\tmove_hugetlb_state(hpage, new_hpage, reason);\n\t\tput_new_page = NULL;\n\t}\n\n\tunlock_page(hpage);\nout:\n\tif (rc != -EAGAIN)\n\t\tputback_active_hugepage(hpage);\n\n\t/*\n\t * If migration was not successful and there's a freeing callback, use\n\t * it.  Otherwise, put_page() will drop the reference grabbed during\n\t * isolation.\n\t */\n\tif (put_new_page)\n\t\tput_new_page(new_hpage, private);\n\telse\n\t\tputback_active_hugepage(new_hpage);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "unmap_and_move",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "1138-1234",
    "snippet": "static ICE_noinline int unmap_and_move(new_page_t get_new_page,\n\t\t\t\t   free_page_t put_new_page,\n\t\t\t\t   unsigned long private, struct page *page,\n\t\t\t\t   int force, enum migrate_mode mode,\n\t\t\t\t   enum migrate_reason reason)\n{\n\tint rc = MIGRATEPAGE_SUCCESS;\n\tstruct page *newpage;\n\n\tif (!thp_migration_supported() && PageTransHuge(page))\n\t\treturn -ENOMEM;\n\n\tnewpage = get_new_page(page, private);\n\tif (!newpage)\n\t\treturn -ENOMEM;\n\n\tif (page_count(page) == 1) {\n\t\t/* page was freed from under us. So we are done. */\n\t\tClearPageActive(page);\n\t\tClearPageUnevictable(page);\n\t\tif (unlikely(__PageMovable(page))) {\n\t\t\tlock_page(page);\n\t\t\tif (!PageMovable(page))\n\t\t\t\t__ClearPageIsolated(page);\n\t\t\tunlock_page(page);\n\t\t}\n\t\tif (put_new_page)\n\t\t\tput_new_page(newpage, private);\n\t\telse\n\t\t\tput_page(newpage);\n\t\tgoto out;\n\t}\n\n\trc = __unmap_and_move(page, newpage, force, mode);\n\tif (rc == MIGRATEPAGE_SUCCESS)\n\t\tset_page_owner_migrate_reason(newpage, reason);\n\nout:\n\tif (rc != -EAGAIN) {\n\t\t/*\n\t\t * A page that has been migrated has all references\n\t\t * removed and will be freed. A page that has not been\n\t\t * migrated will have kepts its references and be\n\t\t * restored.\n\t\t */\n\t\tlist_del(&page->lru);\n\n\t\t/*\n\t\t * Compaction can migrate also non-LRU pages which are\n\t\t * not accounted to NR_ISOLATED_*. They can be recognized\n\t\t * as __PageMovable\n\t\t */\n\t\tif (likely(!__PageMovable(page)))\n\t\t\tmod_node_page_state(page_pgdat(page), NR_ISOLATED_ANON +\n\t\t\t\t\tpage_is_file_cache(page), -hpage_nr_pages(page));\n\t}\n\n\t/*\n\t * If migration is successful, releases reference grabbed during\n\t * isolation. Otherwise, restore the page to right list unless\n\t * we want to retry.\n\t */\n\tif (rc == MIGRATEPAGE_SUCCESS) {\n\t\tput_page(page);\n\t\tif (reason == MR_MEMORY_FAILURE) {\n\t\t\t/*\n\t\t\t * Set PG_HWPoison on just freed page\n\t\t\t * intentionally. Although it's rather weird,\n\t\t\t * it's how HWPoison flag works at the moment.\n\t\t\t */\n\t\t\tif (set_hwpoison_free_buddy_page(page))\n\t\t\t\tnum_poisoned_pages_inc();\n\t\t}\n\t} else {\n\t\tif (rc != -EAGAIN) {\n\t\t\tif (likely(!__PageMovable(page))) {\n\t\t\t\tputback_lru_page(page);\n\t\t\t\tgoto put_new;\n\t\t\t}\n\n\t\t\tlock_page(page);\n\t\t\tif (PageMovable(page))\n\t\t\t\tputback_movable_page(page);\n\t\t\telse\n\t\t\t\t__ClearPageIsolated(page);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t}\nput_new:\n\t\tif (put_new_page)\n\t\t\tput_new_page(newpage, private);\n\t\telse\n\t\t\tput_page(newpage);\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [
      "#define ICE_noinline",
      "#define ICE_noinline noinline"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "newpage"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_new_page",
          "args": [
            "newpage",
            "private"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1223
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ClearPageIsolated",
          "args": [
            "page"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "putback_movable_page",
          "args": [
            "page"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "putback_movable_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "167-198",
          "snippet": "void putback_movable_pages(struct list_head *l)\n{\n\tstruct page *page;\n\tstruct page *page2;\n\n\tlist_for_each_entry_safe(page, page2, l, lru) {\n\t\tif (unlikely(PageHuge(page))) {\n\t\t\tputback_active_hugepage(page);\n\t\t\tcontinue;\n\t\t}\n\t\tlist_del(&page->lru);\n\t\t/*\n\t\t * We isolated non-lru movable page so here we can use\n\t\t * __PageMovable because LRU page's mapping cannot have\n\t\t * PAGE_MAPPING_MOVABLE.\n\t\t */\n\t\tif (unlikely(__PageMovable(page))) {\n\t\t\tVM_BUG_ON_PAGE(!PageIsolated(page), page);\n\t\t\tlock_page(page);\n\t\t\tif (PageMovable(page))\n\t\t\t\tputback_movable_page(page);\n\t\t\telse\n\t\t\t\t__ClearPageIsolated(page);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t} else {\n\t\t\tmod_node_page_state(page_pgdat(page), NR_ISOLATED_ANON +\n\t\t\t\t\tpage_is_file_cache(page), -hpage_nr_pages(page));\n\t\t\tputback_lru_page(page);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nvoid putback_movable_pages(struct list_head *l)\n{\n\tstruct page *page;\n\tstruct page *page2;\n\n\tlist_for_each_entry_safe(page, page2, l, lru) {\n\t\tif (unlikely(PageHuge(page))) {\n\t\t\tputback_active_hugepage(page);\n\t\t\tcontinue;\n\t\t}\n\t\tlist_del(&page->lru);\n\t\t/*\n\t\t * We isolated non-lru movable page so here we can use\n\t\t * __PageMovable because LRU page's mapping cannot have\n\t\t * PAGE_MAPPING_MOVABLE.\n\t\t */\n\t\tif (unlikely(__PageMovable(page))) {\n\t\t\tVM_BUG_ON_PAGE(!PageIsolated(page), page);\n\t\t\tlock_page(page);\n\t\t\tif (PageMovable(page))\n\t\t\t\tputback_movable_page(page);\n\t\t\telse\n\t\t\t\t__ClearPageIsolated(page);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t} else {\n\t\t\tmod_node_page_state(page_pgdat(page), NR_ISOLATED_ANON +\n\t\t\t\t\tpage_is_file_cache(page), -hpage_nr_pages(page));\n\t\t\tputback_lru_page(page);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageMovable",
          "args": [
            "page"
          ],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "__ClearPageMovable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "120-131",
          "snippet": "void __ClearPageMovable(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(!PageMovable(page), page);\n\t/*\n\t * Clear registered address_space val with keeping PAGE_MAPPING_MOVABLE\n\t * flag so that VM can catch up released page by driver after isolation.\n\t * With it, VM migration doesn't try to put it back.\n\t */\n\tpage->mapping = (void *)((unsigned long)page->mapping &\n\t\t\t\tPAGE_MAPPING_MOVABLE);\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nvoid __ClearPageMovable(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(!PageMovable(page), page);\n\t/*\n\t * Clear registered address_space val with keeping PAGE_MAPPING_MOVABLE\n\t * flag so that VM can catch up released page by driver after isolation.\n\t * With it, VM migration doesn't try to put it back.\n\t */\n\tpage->mapping = (void *)((unsigned long)page->mapping &\n\t\t\t\tPAGE_MAPPING_MOVABLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "putback_lru_page",
          "args": [
            "page"
          ],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "putback_lru_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1005-1009",
          "snippet": "void putback_lru_page(struct page *page)\n{\n\tlru_cache_add(page);\n\tput_page(page);\t\t/* drop ref from isolate */\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid putback_lru_page(struct page *page)\n{\n\tlru_cache_add(page);\n\tput_page(page);\t\t/* drop ref from isolate */\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!__PageMovable(page)"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__PageMovable",
          "args": [
            "page"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_poisoned_pages_inc",
          "args": [],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_hwpoison_free_buddy_page",
          "args": [
            "page"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mod_node_page_state",
          "args": [
            "page_pgdat(page)",
            "NR_ISOLATED_ANON +\n\t\t\t\t\tpage_is_file_cache(page)",
            "-hpage_nr_pages(page)"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "mod_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "644-652",
          "snippet": "void mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,\n\t\t\t\t\tlong delta)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__mod_node_page_state(pgdat, item, delta);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,\n\t\t\t\t\tlong delta)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__mod_node_page_state(pgdat, item, delta);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "page"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_is_file_cache",
          "args": [
            "page"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_pgdat",
          "args": [
            "page"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!__PageMovable(page)"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__PageMovable",
          "args": [
            "page"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_owner_migrate_reason",
          "args": [
            "newpage",
            "reason"
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "__set_page_owner_migrate_reason",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
          "lines": "199-209",
          "snippet": "void __set_page_owner_migrate_reason(struct page *page, int reason)\n{\n\tstruct page_ext *page_ext = lookup_page_ext(page);\n\tstruct page_owner *page_owner;\n\n\tif (unlikely(!page_ext))\n\t\treturn;\n\n\tpage_owner = get_page_owner(page_ext);\n\tpage_owner->last_migrate_reason = reason;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/stackdepot.h>",
            "#include <linux/migrate.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nvoid __set_page_owner_migrate_reason(struct page *page, int reason)\n{\n\tstruct page_ext *page_ext = lookup_page_ext(page);\n\tstruct page_owner *page_owner;\n\n\tif (unlikely(!page_ext))\n\t\treturn;\n\n\tpage_owner = get_page_owner(page_ext);\n\tpage_owner->last_migrate_reason = reason;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__unmap_and_move",
          "args": [
            "page",
            "newpage",
            "force",
            "mode"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "__unmap_and_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "981-1121",
          "snippet": "static int __unmap_and_move(struct page *page, struct page *newpage,\n\t\t\t\tint force, enum migrate_mode mode)\n{\n\tint rc = -EAGAIN;\n\tint page_was_mapped = 0;\n\tstruct anon_vma *anon_vma = NULL;\n\tbool is_lru = !__PageMovable(page);\n\n\tif (!trylock_page(page)) {\n\t\tif (!force || mode == MIGRATE_ASYNC)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * It's not safe for direct compaction to call lock_page.\n\t\t * For example, during page readahead pages are added locked\n\t\t * to the LRU. Later, when the IO completes the pages are\n\t\t * marked uptodate and unlocked. However, the queueing\n\t\t * could be merging multiple pages for one bio (e.g.\n\t\t * mpage_readpages). If an allocation happens for the\n\t\t * second or third page, the process can end up locking\n\t\t * the same page twice and deadlocking. Rather than\n\t\t * trying to be clever about what pages can be locked,\n\t\t * avoid the use of lock_page for direct compaction\n\t\t * altogether.\n\t\t */\n\t\tif (current->flags & PF_MEMALLOC)\n\t\t\tgoto out;\n\n\t\tlock_page(page);\n\t}\n\n\tif (PageWriteback(page)) {\n\t\t/*\n\t\t * Only in the case of a full synchronous migration is it\n\t\t * necessary to wait for PageWriteback. In the async case,\n\t\t * the retry loop is too short and in the sync-light case,\n\t\t * the overhead of stalling is too much\n\t\t */\n\t\tswitch (mode) {\n\t\tcase MIGRATE_SYNC:\n\t\tcase MIGRATE_SYNC_NO_COPY:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trc = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tif (!force)\n\t\t\tgoto out_unlock;\n\t\twait_on_page_writeback(page);\n\t}\n\n\t/*\n\t * By try_to_unmap(), page->mapcount goes down to 0 here. In this case,\n\t * we cannot notice that anon_vma is freed while we migrates a page.\n\t * This get_anon_vma() delays freeing anon_vma pointer until the end\n\t * of migration. File cache pages are no problem because of page_lock()\n\t * File Caches may use write_page() or lock_page() in migration, then,\n\t * just care Anon page here.\n\t *\n\t * Only page_get_anon_vma() understands the subtleties of\n\t * getting a hold on an anon_vma from outside one of its mms.\n\t * But if we cannot get anon_vma, then we won't need it anyway,\n\t * because that implies that the anon page is no longer mapped\n\t * (and cannot be remapped so long as we hold the page lock).\n\t */\n\tif (PageAnon(page) && !PageKsm(page))\n\t\tanon_vma = page_get_anon_vma(page);\n\n\t/*\n\t * Block others from accessing the new page when we get around to\n\t * establishing additional references. We are usually the only one\n\t * holding a reference to newpage at this point. We used to have a BUG\n\t * here if trylock_page(newpage) fails, but would like to allow for\n\t * cases where there might be a race with the previous use of newpage.\n\t * This is much like races on refcount of oldpage: just don't BUG().\n\t */\n\tif (unlikely(!trylock_page(newpage)))\n\t\tgoto out_unlock;\n\n\tif (unlikely(!is_lru)) {\n\t\trc = move_to_new_page(newpage, page, mode);\n\t\tgoto out_unlock_both;\n\t}\n\n\t/*\n\t * Corner case handling:\n\t * 1. When a new swap-cache page is read into, it is added to the LRU\n\t * and treated as swapcache but it has no rmap yet.\n\t * Calling try_to_unmap() against a page->mapping==NULL page will\n\t * trigger a BUG.  So handle it here.\n\t * 2. An orphaned page (see truncate_complete_page) might have\n\t * fs-private metadata. The page can be picked up due to memory\n\t * offlining.  Everywhere else except page reclaim, the page is\n\t * invisible to the vm, so the page can not be migrated.  So try to\n\t * free the metadata, so the page can be freed.\n\t */\n\tif (!page->mapping) {\n\t\tVM_BUG_ON_PAGE(PageAnon(page), page);\n\t\tif (page_has_private(page)) {\n\t\t\ttry_to_free_buffers(page);\n\t\t\tgoto out_unlock_both;\n\t\t}\n\t} else if (page_mapped(page)) {\n\t\t/* Establish migration ptes */\n\t\tVM_BUG_ON_PAGE(PageAnon(page) && !PageKsm(page) && !anon_vma,\n\t\t\t\tpage);\n\t\ttry_to_unmap(page,\n\t\t\tTTU_MIGRATION|TTU_IGNORE_MLOCK|TTU_IGNORE_ACCESS);\n\t\tpage_was_mapped = 1;\n\t}\n\n\tif (!page_mapped(page))\n\t\trc = move_to_new_page(newpage, page, mode);\n\n\tif (page_was_mapped)\n\t\tremove_migration_ptes(page,\n\t\t\trc == MIGRATEPAGE_SUCCESS ? newpage : page, false);\n\nout_unlock_both:\n\tunlock_page(newpage);\nout_unlock:\n\t/* Drop an anon_vma reference if we took one */\n\tif (anon_vma)\n\t\tput_anon_vma(anon_vma);\n\tunlock_page(page);\nout:\n\t/*\n\t * If migration is successful, decrease refcount of the newpage\n\t * which will not free the page because new page owner increased\n\t * refcounter. As well, if it is LRU page, add the page to LRU\n\t * list in here.\n\t */\n\tif (rc == MIGRATEPAGE_SUCCESS) {\n\t\tif (unlikely(__PageMovable(newpage)))\n\t\t\tput_page(newpage);\n\t\telse\n\t\t\tputback_lru_page(newpage);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic int __unmap_and_move(struct page *page, struct page *newpage,\n\t\t\t\tint force, enum migrate_mode mode)\n{\n\tint rc = -EAGAIN;\n\tint page_was_mapped = 0;\n\tstruct anon_vma *anon_vma = NULL;\n\tbool is_lru = !__PageMovable(page);\n\n\tif (!trylock_page(page)) {\n\t\tif (!force || mode == MIGRATE_ASYNC)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * It's not safe for direct compaction to call lock_page.\n\t\t * For example, during page readahead pages are added locked\n\t\t * to the LRU. Later, when the IO completes the pages are\n\t\t * marked uptodate and unlocked. However, the queueing\n\t\t * could be merging multiple pages for one bio (e.g.\n\t\t * mpage_readpages). If an allocation happens for the\n\t\t * second or third page, the process can end up locking\n\t\t * the same page twice and deadlocking. Rather than\n\t\t * trying to be clever about what pages can be locked,\n\t\t * avoid the use of lock_page for direct compaction\n\t\t * altogether.\n\t\t */\n\t\tif (current->flags & PF_MEMALLOC)\n\t\t\tgoto out;\n\n\t\tlock_page(page);\n\t}\n\n\tif (PageWriteback(page)) {\n\t\t/*\n\t\t * Only in the case of a full synchronous migration is it\n\t\t * necessary to wait for PageWriteback. In the async case,\n\t\t * the retry loop is too short and in the sync-light case,\n\t\t * the overhead of stalling is too much\n\t\t */\n\t\tswitch (mode) {\n\t\tcase MIGRATE_SYNC:\n\t\tcase MIGRATE_SYNC_NO_COPY:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trc = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tif (!force)\n\t\t\tgoto out_unlock;\n\t\twait_on_page_writeback(page);\n\t}\n\n\t/*\n\t * By try_to_unmap(), page->mapcount goes down to 0 here. In this case,\n\t * we cannot notice that anon_vma is freed while we migrates a page.\n\t * This get_anon_vma() delays freeing anon_vma pointer until the end\n\t * of migration. File cache pages are no problem because of page_lock()\n\t * File Caches may use write_page() or lock_page() in migration, then,\n\t * just care Anon page here.\n\t *\n\t * Only page_get_anon_vma() understands the subtleties of\n\t * getting a hold on an anon_vma from outside one of its mms.\n\t * But if we cannot get anon_vma, then we won't need it anyway,\n\t * because that implies that the anon page is no longer mapped\n\t * (and cannot be remapped so long as we hold the page lock).\n\t */\n\tif (PageAnon(page) && !PageKsm(page))\n\t\tanon_vma = page_get_anon_vma(page);\n\n\t/*\n\t * Block others from accessing the new page when we get around to\n\t * establishing additional references. We are usually the only one\n\t * holding a reference to newpage at this point. We used to have a BUG\n\t * here if trylock_page(newpage) fails, but would like to allow for\n\t * cases where there might be a race with the previous use of newpage.\n\t * This is much like races on refcount of oldpage: just don't BUG().\n\t */\n\tif (unlikely(!trylock_page(newpage)))\n\t\tgoto out_unlock;\n\n\tif (unlikely(!is_lru)) {\n\t\trc = move_to_new_page(newpage, page, mode);\n\t\tgoto out_unlock_both;\n\t}\n\n\t/*\n\t * Corner case handling:\n\t * 1. When a new swap-cache page is read into, it is added to the LRU\n\t * and treated as swapcache but it has no rmap yet.\n\t * Calling try_to_unmap() against a page->mapping==NULL page will\n\t * trigger a BUG.  So handle it here.\n\t * 2. An orphaned page (see truncate_complete_page) might have\n\t * fs-private metadata. The page can be picked up due to memory\n\t * offlining.  Everywhere else except page reclaim, the page is\n\t * invisible to the vm, so the page can not be migrated.  So try to\n\t * free the metadata, so the page can be freed.\n\t */\n\tif (!page->mapping) {\n\t\tVM_BUG_ON_PAGE(PageAnon(page), page);\n\t\tif (page_has_private(page)) {\n\t\t\ttry_to_free_buffers(page);\n\t\t\tgoto out_unlock_both;\n\t\t}\n\t} else if (page_mapped(page)) {\n\t\t/* Establish migration ptes */\n\t\tVM_BUG_ON_PAGE(PageAnon(page) && !PageKsm(page) && !anon_vma,\n\t\t\t\tpage);\n\t\ttry_to_unmap(page,\n\t\t\tTTU_MIGRATION|TTU_IGNORE_MLOCK|TTU_IGNORE_ACCESS);\n\t\tpage_was_mapped = 1;\n\t}\n\n\tif (!page_mapped(page))\n\t\trc = move_to_new_page(newpage, page, mode);\n\n\tif (page_was_mapped)\n\t\tremove_migration_ptes(page,\n\t\t\trc == MIGRATEPAGE_SUCCESS ? newpage : page, false);\n\nout_unlock_both:\n\tunlock_page(newpage);\nout_unlock:\n\t/* Drop an anon_vma reference if we took one */\n\tif (anon_vma)\n\t\tput_anon_vma(anon_vma);\n\tunlock_page(page);\nout:\n\t/*\n\t * If migration is successful, decrease refcount of the newpage\n\t * which will not free the page because new page owner increased\n\t * refcounter. As well, if it is LRU page, add the page to LRU\n\t * list in here.\n\t */\n\tif (rc == MIGRATEPAGE_SUCCESS) {\n\t\tif (unlikely(__PageMovable(newpage)))\n\t\t\tput_page(newpage);\n\t\telse\n\t\t\tputback_lru_page(newpage);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_new_page",
          "args": [
            "newpage",
            "private"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ClearPageIsolated",
          "args": [
            "page"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "__PageMovable(page)"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__PageMovable",
          "args": [
            "page"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageUnevictable",
          "args": [
            "page"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageActive",
          "args": [
            "page"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_new_page",
          "args": [
            "page",
            "private"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "page"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thp_migration_supported",
          "args": [],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\n#define ICE_noinline\n#define ICE_noinline noinline\n\nstatic ICE_noinline int unmap_and_move(new_page_t get_new_page,\n\t\t\t\t   free_page_t put_new_page,\n\t\t\t\t   unsigned long private, struct page *page,\n\t\t\t\t   int force, enum migrate_mode mode,\n\t\t\t\t   enum migrate_reason reason)\n{\n\tint rc = MIGRATEPAGE_SUCCESS;\n\tstruct page *newpage;\n\n\tif (!thp_migration_supported() && PageTransHuge(page))\n\t\treturn -ENOMEM;\n\n\tnewpage = get_new_page(page, private);\n\tif (!newpage)\n\t\treturn -ENOMEM;\n\n\tif (page_count(page) == 1) {\n\t\t/* page was freed from under us. So we are done. */\n\t\tClearPageActive(page);\n\t\tClearPageUnevictable(page);\n\t\tif (unlikely(__PageMovable(page))) {\n\t\t\tlock_page(page);\n\t\t\tif (!PageMovable(page))\n\t\t\t\t__ClearPageIsolated(page);\n\t\t\tunlock_page(page);\n\t\t}\n\t\tif (put_new_page)\n\t\t\tput_new_page(newpage, private);\n\t\telse\n\t\t\tput_page(newpage);\n\t\tgoto out;\n\t}\n\n\trc = __unmap_and_move(page, newpage, force, mode);\n\tif (rc == MIGRATEPAGE_SUCCESS)\n\t\tset_page_owner_migrate_reason(newpage, reason);\n\nout:\n\tif (rc != -EAGAIN) {\n\t\t/*\n\t\t * A page that has been migrated has all references\n\t\t * removed and will be freed. A page that has not been\n\t\t * migrated will have kepts its references and be\n\t\t * restored.\n\t\t */\n\t\tlist_del(&page->lru);\n\n\t\t/*\n\t\t * Compaction can migrate also non-LRU pages which are\n\t\t * not accounted to NR_ISOLATED_*. They can be recognized\n\t\t * as __PageMovable\n\t\t */\n\t\tif (likely(!__PageMovable(page)))\n\t\t\tmod_node_page_state(page_pgdat(page), NR_ISOLATED_ANON +\n\t\t\t\t\tpage_is_file_cache(page), -hpage_nr_pages(page));\n\t}\n\n\t/*\n\t * If migration is successful, releases reference grabbed during\n\t * isolation. Otherwise, restore the page to right list unless\n\t * we want to retry.\n\t */\n\tif (rc == MIGRATEPAGE_SUCCESS) {\n\t\tput_page(page);\n\t\tif (reason == MR_MEMORY_FAILURE) {\n\t\t\t/*\n\t\t\t * Set PG_HWPoison on just freed page\n\t\t\t * intentionally. Although it's rather weird,\n\t\t\t * it's how HWPoison flag works at the moment.\n\t\t\t */\n\t\t\tif (set_hwpoison_free_buddy_page(page))\n\t\t\t\tnum_poisoned_pages_inc();\n\t\t}\n\t} else {\n\t\tif (rc != -EAGAIN) {\n\t\t\tif (likely(!__PageMovable(page))) {\n\t\t\t\tputback_lru_page(page);\n\t\t\t\tgoto put_new;\n\t\t\t}\n\n\t\t\tlock_page(page);\n\t\t\tif (PageMovable(page))\n\t\t\t\tputback_movable_page(page);\n\t\t\telse\n\t\t\t\t__ClearPageIsolated(page);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t}\nput_new:\n\t\tif (put_new_page)\n\t\t\tput_new_page(newpage, private);\n\t\telse\n\t\t\tput_page(newpage);\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "__unmap_and_move",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "981-1121",
    "snippet": "static int __unmap_and_move(struct page *page, struct page *newpage,\n\t\t\t\tint force, enum migrate_mode mode)\n{\n\tint rc = -EAGAIN;\n\tint page_was_mapped = 0;\n\tstruct anon_vma *anon_vma = NULL;\n\tbool is_lru = !__PageMovable(page);\n\n\tif (!trylock_page(page)) {\n\t\tif (!force || mode == MIGRATE_ASYNC)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * It's not safe for direct compaction to call lock_page.\n\t\t * For example, during page readahead pages are added locked\n\t\t * to the LRU. Later, when the IO completes the pages are\n\t\t * marked uptodate and unlocked. However, the queueing\n\t\t * could be merging multiple pages for one bio (e.g.\n\t\t * mpage_readpages). If an allocation happens for the\n\t\t * second or third page, the process can end up locking\n\t\t * the same page twice and deadlocking. Rather than\n\t\t * trying to be clever about what pages can be locked,\n\t\t * avoid the use of lock_page for direct compaction\n\t\t * altogether.\n\t\t */\n\t\tif (current->flags & PF_MEMALLOC)\n\t\t\tgoto out;\n\n\t\tlock_page(page);\n\t}\n\n\tif (PageWriteback(page)) {\n\t\t/*\n\t\t * Only in the case of a full synchronous migration is it\n\t\t * necessary to wait for PageWriteback. In the async case,\n\t\t * the retry loop is too short and in the sync-light case,\n\t\t * the overhead of stalling is too much\n\t\t */\n\t\tswitch (mode) {\n\t\tcase MIGRATE_SYNC:\n\t\tcase MIGRATE_SYNC_NO_COPY:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trc = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tif (!force)\n\t\t\tgoto out_unlock;\n\t\twait_on_page_writeback(page);\n\t}\n\n\t/*\n\t * By try_to_unmap(), page->mapcount goes down to 0 here. In this case,\n\t * we cannot notice that anon_vma is freed while we migrates a page.\n\t * This get_anon_vma() delays freeing anon_vma pointer until the end\n\t * of migration. File cache pages are no problem because of page_lock()\n\t * File Caches may use write_page() or lock_page() in migration, then,\n\t * just care Anon page here.\n\t *\n\t * Only page_get_anon_vma() understands the subtleties of\n\t * getting a hold on an anon_vma from outside one of its mms.\n\t * But if we cannot get anon_vma, then we won't need it anyway,\n\t * because that implies that the anon page is no longer mapped\n\t * (and cannot be remapped so long as we hold the page lock).\n\t */\n\tif (PageAnon(page) && !PageKsm(page))\n\t\tanon_vma = page_get_anon_vma(page);\n\n\t/*\n\t * Block others from accessing the new page when we get around to\n\t * establishing additional references. We are usually the only one\n\t * holding a reference to newpage at this point. We used to have a BUG\n\t * here if trylock_page(newpage) fails, but would like to allow for\n\t * cases where there might be a race with the previous use of newpage.\n\t * This is much like races on refcount of oldpage: just don't BUG().\n\t */\n\tif (unlikely(!trylock_page(newpage)))\n\t\tgoto out_unlock;\n\n\tif (unlikely(!is_lru)) {\n\t\trc = move_to_new_page(newpage, page, mode);\n\t\tgoto out_unlock_both;\n\t}\n\n\t/*\n\t * Corner case handling:\n\t * 1. When a new swap-cache page is read into, it is added to the LRU\n\t * and treated as swapcache but it has no rmap yet.\n\t * Calling try_to_unmap() against a page->mapping==NULL page will\n\t * trigger a BUG.  So handle it here.\n\t * 2. An orphaned page (see truncate_complete_page) might have\n\t * fs-private metadata. The page can be picked up due to memory\n\t * offlining.  Everywhere else except page reclaim, the page is\n\t * invisible to the vm, so the page can not be migrated.  So try to\n\t * free the metadata, so the page can be freed.\n\t */\n\tif (!page->mapping) {\n\t\tVM_BUG_ON_PAGE(PageAnon(page), page);\n\t\tif (page_has_private(page)) {\n\t\t\ttry_to_free_buffers(page);\n\t\t\tgoto out_unlock_both;\n\t\t}\n\t} else if (page_mapped(page)) {\n\t\t/* Establish migration ptes */\n\t\tVM_BUG_ON_PAGE(PageAnon(page) && !PageKsm(page) && !anon_vma,\n\t\t\t\tpage);\n\t\ttry_to_unmap(page,\n\t\t\tTTU_MIGRATION|TTU_IGNORE_MLOCK|TTU_IGNORE_ACCESS);\n\t\tpage_was_mapped = 1;\n\t}\n\n\tif (!page_mapped(page))\n\t\trc = move_to_new_page(newpage, page, mode);\n\n\tif (page_was_mapped)\n\t\tremove_migration_ptes(page,\n\t\t\trc == MIGRATEPAGE_SUCCESS ? newpage : page, false);\n\nout_unlock_both:\n\tunlock_page(newpage);\nout_unlock:\n\t/* Drop an anon_vma reference if we took one */\n\tif (anon_vma)\n\t\tput_anon_vma(anon_vma);\n\tunlock_page(page);\nout:\n\t/*\n\t * If migration is successful, decrease refcount of the newpage\n\t * which will not free the page because new page owner increased\n\t * refcounter. As well, if it is LRU page, add the page to LRU\n\t * list in here.\n\t */\n\tif (rc == MIGRATEPAGE_SUCCESS) {\n\t\tif (unlikely(__PageMovable(newpage)))\n\t\t\tput_page(newpage);\n\t\telse\n\t\t\tputback_lru_page(newpage);\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "putback_lru_page",
          "args": [
            "newpage"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "putback_lru_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1005-1009",
          "snippet": "void putback_lru_page(struct page *page)\n{\n\tlru_cache_add(page);\n\tput_page(page);\t\t/* drop ref from isolate */\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid putback_lru_page(struct page *page)\n{\n\tlru_cache_add(page);\n\tput_page(page);\t\t/* drop ref from isolate */\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "newpage"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "__PageMovable(newpage)"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__PageMovable",
          "args": [
            "newpage"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_anon_vma",
          "args": [
            "anon_vma"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "__put_anon_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1758-1765",
          "snippet": "void __put_anon_vma(struct anon_vma *anon_vma)\n{\n\tstruct anon_vma *root = anon_vma->root;\n\n\tanon_vma_free(anon_vma);\n\tif (root != anon_vma && atomic_dec_and_test(&root->refcount))\n\t\tanon_vma_free(root);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid __put_anon_vma(struct anon_vma *anon_vma)\n{\n\tstruct anon_vma *root = anon_vma->root;\n\n\tanon_vma_free(anon_vma);\n\tif (root != anon_vma && atomic_dec_and_test(&root->refcount))\n\t\tanon_vma_free(root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_migration_ptes",
          "args": [
            "page",
            "rc == MIGRATEPAGE_SUCCESS ? newpage : page",
            "false"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "remove_migration_ptes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "292-303",
          "snippet": "void remove_migration_ptes(struct page *old, struct page *new, bool locked)\n{\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = remove_migration_pte,\n\t\t.arg = old,\n\t};\n\n\tif (locked)\n\t\trmap_walk_locked(new, &rwc);\n\telse\n\t\trmap_walk(new, &rwc);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nvoid remove_migration_ptes(struct page *old, struct page *new, bool locked)\n{\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = remove_migration_pte,\n\t\t.arg = old,\n\t};\n\n\tif (locked)\n\t\trmap_walk_locked(new, &rwc);\n\telse\n\t\trmap_walk(new, &rwc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "move_to_new_page",
          "args": [
            "newpage",
            "page",
            "mode"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "move_to_new_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "908-979",
          "snippet": "static int move_to_new_page(struct page *newpage, struct page *page,\n\t\t\t\tenum migrate_mode mode)\n{\n\tstruct address_space *mapping;\n\tint rc = -EAGAIN;\n\tbool is_lru = !__PageMovable(page);\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(!PageLocked(newpage), newpage);\n\n\tmapping = page_mapping(page);\n\n\tif (likely(is_lru)) {\n\t\tif (!mapping)\n\t\t\trc = migrate_page(mapping, newpage, page, mode);\n\t\telse if (mapping->a_ops->migratepage)\n\t\t\t/*\n\t\t\t * Most pages have a mapping and most filesystems\n\t\t\t * provide a migratepage callback. Anonymous pages\n\t\t\t * are part of swap space which also has its own\n\t\t\t * migratepage callback. This is the most common path\n\t\t\t * for page migration.\n\t\t\t */\n\t\t\trc = mapping->a_ops->migratepage(mapping, newpage,\n\t\t\t\t\t\t\tpage, mode);\n\t\telse\n\t\t\trc = fallback_migrate_page(mapping, newpage,\n\t\t\t\t\t\t\tpage, mode);\n\t} else {\n\t\t/*\n\t\t * In case of non-lru page, it could be released after\n\t\t * isolation step. In that case, we shouldn't try migration.\n\t\t */\n\t\tVM_BUG_ON_PAGE(!PageIsolated(page), page);\n\t\tif (!PageMovable(page)) {\n\t\t\trc = MIGRATEPAGE_SUCCESS;\n\t\t\t__ClearPageIsolated(page);\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = mapping->a_ops->migratepage(mapping, newpage,\n\t\t\t\t\t\tpage, mode);\n\t\tWARN_ON_ONCE(rc == MIGRATEPAGE_SUCCESS &&\n\t\t\t!PageIsolated(page));\n\t}\n\n\t/*\n\t * When successful, old pagecache page->mapping must be cleared before\n\t * page is freed; but stats require that PageAnon be left as PageAnon.\n\t */\n\tif (rc == MIGRATEPAGE_SUCCESS) {\n\t\tif (__PageMovable(page)) {\n\t\t\tVM_BUG_ON_PAGE(!PageIsolated(page), page);\n\n\t\t\t/*\n\t\t\t * We clear PG_movable under page_lock so any compactor\n\t\t\t * cannot try to migrate this page.\n\t\t\t */\n\t\t\t__ClearPageIsolated(page);\n\t\t}\n\n\t\t/*\n\t\t * Anonymous and movable page->mapping will be cleard by\n\t\t * free_pages_prepare so don't reset it here for keeping\n\t\t * the type to work PageAnon, for example.\n\t\t */\n\t\tif (!PageMappingFlags(page))\n\t\t\tpage->mapping = NULL;\n\t}\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic int move_to_new_page(struct page *newpage, struct page *page,\n\t\t\t\tenum migrate_mode mode)\n{\n\tstruct address_space *mapping;\n\tint rc = -EAGAIN;\n\tbool is_lru = !__PageMovable(page);\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(!PageLocked(newpage), newpage);\n\n\tmapping = page_mapping(page);\n\n\tif (likely(is_lru)) {\n\t\tif (!mapping)\n\t\t\trc = migrate_page(mapping, newpage, page, mode);\n\t\telse if (mapping->a_ops->migratepage)\n\t\t\t/*\n\t\t\t * Most pages have a mapping and most filesystems\n\t\t\t * provide a migratepage callback. Anonymous pages\n\t\t\t * are part of swap space which also has its own\n\t\t\t * migratepage callback. This is the most common path\n\t\t\t * for page migration.\n\t\t\t */\n\t\t\trc = mapping->a_ops->migratepage(mapping, newpage,\n\t\t\t\t\t\t\tpage, mode);\n\t\telse\n\t\t\trc = fallback_migrate_page(mapping, newpage,\n\t\t\t\t\t\t\tpage, mode);\n\t} else {\n\t\t/*\n\t\t * In case of non-lru page, it could be released after\n\t\t * isolation step. In that case, we shouldn't try migration.\n\t\t */\n\t\tVM_BUG_ON_PAGE(!PageIsolated(page), page);\n\t\tif (!PageMovable(page)) {\n\t\t\trc = MIGRATEPAGE_SUCCESS;\n\t\t\t__ClearPageIsolated(page);\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = mapping->a_ops->migratepage(mapping, newpage,\n\t\t\t\t\t\tpage, mode);\n\t\tWARN_ON_ONCE(rc == MIGRATEPAGE_SUCCESS &&\n\t\t\t!PageIsolated(page));\n\t}\n\n\t/*\n\t * When successful, old pagecache page->mapping must be cleared before\n\t * page is freed; but stats require that PageAnon be left as PageAnon.\n\t */\n\tif (rc == MIGRATEPAGE_SUCCESS) {\n\t\tif (__PageMovable(page)) {\n\t\t\tVM_BUG_ON_PAGE(!PageIsolated(page), page);\n\n\t\t\t/*\n\t\t\t * We clear PG_movable under page_lock so any compactor\n\t\t\t * cannot try to migrate this page.\n\t\t\t */\n\t\t\t__ClearPageIsolated(page);\n\t\t}\n\n\t\t/*\n\t\t * Anonymous and movable page->mapping will be cleard by\n\t\t * free_pages_prepare so don't reset it here for keeping\n\t\t * the type to work PageAnon, for example.\n\t\t */\n\t\tif (!PageMappingFlags(page))\n\t\t\tpage->mapping = NULL;\n\t}\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_mapped",
          "args": [
            "page"
          ],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "470-486",
          "snippet": "bool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nbool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_unmap",
          "args": [
            "page",
            "TTU_MIGRATION|TTU_IGNORE_MLOCK|TTU_IGNORE_ACCESS"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_unmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1699-1726",
          "snippet": "bool try_to_unmap(struct page *page, enum ttu_flags flags)\n{\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = try_to_unmap_one,\n\t\t.arg = (void *)flags,\n\t\t.done = page_mapcount_is_zero,\n\t\t.anon_lock = page_lock_anon_vma_read,\n\t};\n\n\t/*\n\t * During exec, a temporary VMA is setup and later moved.\n\t * The VMA is moved under the anon_vma lock but not the\n\t * page tables leading to a race where migration cannot\n\t * find the migration ptes. Rather than increasing the\n\t * locking requirements of exec(), migration skips\n\t * temporary VMAs until after exec() completes.\n\t */\n\tif ((flags & (TTU_MIGRATION|TTU_SPLIT_FREEZE))\n\t    && !PageKsm(page) && PageAnon(page))\n\t\trwc.invalid_vma = invalid_migration_vma;\n\n\tif (flags & TTU_RMAP_LOCKED)\n\t\trmap_walk_locked(page, &rwc);\n\telse\n\t\trmap_walk(page, &rwc);\n\n\treturn !page_mapcount(page) ? true : false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nbool try_to_unmap(struct page *page, enum ttu_flags flags)\n{\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = try_to_unmap_one,\n\t\t.arg = (void *)flags,\n\t\t.done = page_mapcount_is_zero,\n\t\t.anon_lock = page_lock_anon_vma_read,\n\t};\n\n\t/*\n\t * During exec, a temporary VMA is setup and later moved.\n\t * The VMA is moved under the anon_vma lock but not the\n\t * page tables leading to a race where migration cannot\n\t * find the migration ptes. Rather than increasing the\n\t * locking requirements of exec(), migration skips\n\t * temporary VMAs until after exec() completes.\n\t */\n\tif ((flags & (TTU_MIGRATION|TTU_SPLIT_FREEZE))\n\t    && !PageKsm(page) && PageAnon(page))\n\t\trwc.invalid_vma = invalid_migration_vma;\n\n\tif (flags & TTU_RMAP_LOCKED)\n\t\trmap_walk_locked(page, &rwc);\n\telse\n\t\trmap_walk(page, &rwc);\n\n\treturn !page_mapcount(page) ? true : false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageAnon(page) && !PageKsm(page) && !anon_vma",
            "page"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageKsm",
          "args": [
            "page"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_free_buffers",
          "args": [
            "page"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_private",
          "args": [
            "page"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageAnon(page)",
            "page"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!is_lru"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!trylock_page(newpage)"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "newpage"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_get_anon_vma",
          "args": [
            "page"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "page_get_anon_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "464-498",
          "snippet": "struct anon_vma *page_get_anon_vma(struct page *page)\n{\n\tstruct anon_vma *anon_vma = NULL;\n\tunsigned long anon_mapping;\n\n\trcu_read_lock();\n\tanon_mapping = (unsigned long)READ_ONCE(page->mapping);\n\tif ((anon_mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)\n\t\tgoto out;\n\tif (!page_mapped(page))\n\t\tgoto out;\n\n\tanon_vma = (struct anon_vma *) (anon_mapping - PAGE_MAPPING_ANON);\n\tif (!atomic_inc_not_zero(&anon_vma->refcount)) {\n\t\tanon_vma = NULL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If this page is still mapped, then its anon_vma cannot have been\n\t * freed.  But if it has been unmapped, we have no security against the\n\t * anon_vma structure being freed and reused (for another anon_vma:\n\t * SLAB_TYPESAFE_BY_RCU guarantees that - so the atomic_inc_not_zero()\n\t * above cannot corrupt).\n\t */\n\tif (!page_mapped(page)) {\n\t\trcu_read_unlock();\n\t\tput_anon_vma(anon_vma);\n\t\treturn NULL;\n\t}\nout:\n\trcu_read_unlock();\n\n\treturn anon_vma;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstruct anon_vma *page_get_anon_vma(struct page *page)\n{\n\tstruct anon_vma *anon_vma = NULL;\n\tunsigned long anon_mapping;\n\n\trcu_read_lock();\n\tanon_mapping = (unsigned long)READ_ONCE(page->mapping);\n\tif ((anon_mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)\n\t\tgoto out;\n\tif (!page_mapped(page))\n\t\tgoto out;\n\n\tanon_vma = (struct anon_vma *) (anon_mapping - PAGE_MAPPING_ANON);\n\tif (!atomic_inc_not_zero(&anon_vma->refcount)) {\n\t\tanon_vma = NULL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If this page is still mapped, then its anon_vma cannot have been\n\t * freed.  But if it has been unmapped, we have no security against the\n\t * anon_vma structure being freed and reused (for another anon_vma:\n\t * SLAB_TYPESAFE_BY_RCU guarantees that - so the atomic_inc_not_zero()\n\t * above cannot corrupt).\n\t */\n\tif (!page_mapped(page)) {\n\t\trcu_read_unlock();\n\t\tput_anon_vma(anon_vma);\n\t\treturn NULL;\n\t}\nout:\n\trcu_read_unlock();\n\n\treturn anon_vma;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageKsm",
          "args": [
            "page"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_page_writeback",
          "args": [
            "page"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__PageMovable",
          "args": [
            "page"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic int __unmap_and_move(struct page *page, struct page *newpage,\n\t\t\t\tint force, enum migrate_mode mode)\n{\n\tint rc = -EAGAIN;\n\tint page_was_mapped = 0;\n\tstruct anon_vma *anon_vma = NULL;\n\tbool is_lru = !__PageMovable(page);\n\n\tif (!trylock_page(page)) {\n\t\tif (!force || mode == MIGRATE_ASYNC)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * It's not safe for direct compaction to call lock_page.\n\t\t * For example, during page readahead pages are added locked\n\t\t * to the LRU. Later, when the IO completes the pages are\n\t\t * marked uptodate and unlocked. However, the queueing\n\t\t * could be merging multiple pages for one bio (e.g.\n\t\t * mpage_readpages). If an allocation happens for the\n\t\t * second or third page, the process can end up locking\n\t\t * the same page twice and deadlocking. Rather than\n\t\t * trying to be clever about what pages can be locked,\n\t\t * avoid the use of lock_page for direct compaction\n\t\t * altogether.\n\t\t */\n\t\tif (current->flags & PF_MEMALLOC)\n\t\t\tgoto out;\n\n\t\tlock_page(page);\n\t}\n\n\tif (PageWriteback(page)) {\n\t\t/*\n\t\t * Only in the case of a full synchronous migration is it\n\t\t * necessary to wait for PageWriteback. In the async case,\n\t\t * the retry loop is too short and in the sync-light case,\n\t\t * the overhead of stalling is too much\n\t\t */\n\t\tswitch (mode) {\n\t\tcase MIGRATE_SYNC:\n\t\tcase MIGRATE_SYNC_NO_COPY:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trc = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tif (!force)\n\t\t\tgoto out_unlock;\n\t\twait_on_page_writeback(page);\n\t}\n\n\t/*\n\t * By try_to_unmap(), page->mapcount goes down to 0 here. In this case,\n\t * we cannot notice that anon_vma is freed while we migrates a page.\n\t * This get_anon_vma() delays freeing anon_vma pointer until the end\n\t * of migration. File cache pages are no problem because of page_lock()\n\t * File Caches may use write_page() or lock_page() in migration, then,\n\t * just care Anon page here.\n\t *\n\t * Only page_get_anon_vma() understands the subtleties of\n\t * getting a hold on an anon_vma from outside one of its mms.\n\t * But if we cannot get anon_vma, then we won't need it anyway,\n\t * because that implies that the anon page is no longer mapped\n\t * (and cannot be remapped so long as we hold the page lock).\n\t */\n\tif (PageAnon(page) && !PageKsm(page))\n\t\tanon_vma = page_get_anon_vma(page);\n\n\t/*\n\t * Block others from accessing the new page when we get around to\n\t * establishing additional references. We are usually the only one\n\t * holding a reference to newpage at this point. We used to have a BUG\n\t * here if trylock_page(newpage) fails, but would like to allow for\n\t * cases where there might be a race with the previous use of newpage.\n\t * This is much like races on refcount of oldpage: just don't BUG().\n\t */\n\tif (unlikely(!trylock_page(newpage)))\n\t\tgoto out_unlock;\n\n\tif (unlikely(!is_lru)) {\n\t\trc = move_to_new_page(newpage, page, mode);\n\t\tgoto out_unlock_both;\n\t}\n\n\t/*\n\t * Corner case handling:\n\t * 1. When a new swap-cache page is read into, it is added to the LRU\n\t * and treated as swapcache but it has no rmap yet.\n\t * Calling try_to_unmap() against a page->mapping==NULL page will\n\t * trigger a BUG.  So handle it here.\n\t * 2. An orphaned page (see truncate_complete_page) might have\n\t * fs-private metadata. The page can be picked up due to memory\n\t * offlining.  Everywhere else except page reclaim, the page is\n\t * invisible to the vm, so the page can not be migrated.  So try to\n\t * free the metadata, so the page can be freed.\n\t */\n\tif (!page->mapping) {\n\t\tVM_BUG_ON_PAGE(PageAnon(page), page);\n\t\tif (page_has_private(page)) {\n\t\t\ttry_to_free_buffers(page);\n\t\t\tgoto out_unlock_both;\n\t\t}\n\t} else if (page_mapped(page)) {\n\t\t/* Establish migration ptes */\n\t\tVM_BUG_ON_PAGE(PageAnon(page) && !PageKsm(page) && !anon_vma,\n\t\t\t\tpage);\n\t\ttry_to_unmap(page,\n\t\t\tTTU_MIGRATION|TTU_IGNORE_MLOCK|TTU_IGNORE_ACCESS);\n\t\tpage_was_mapped = 1;\n\t}\n\n\tif (!page_mapped(page))\n\t\trc = move_to_new_page(newpage, page, mode);\n\n\tif (page_was_mapped)\n\t\tremove_migration_ptes(page,\n\t\t\trc == MIGRATEPAGE_SUCCESS ? newpage : page, false);\n\nout_unlock_both:\n\tunlock_page(newpage);\nout_unlock:\n\t/* Drop an anon_vma reference if we took one */\n\tif (anon_vma)\n\t\tput_anon_vma(anon_vma);\n\tunlock_page(page);\nout:\n\t/*\n\t * If migration is successful, decrease refcount of the newpage\n\t * which will not free the page because new page owner increased\n\t * refcounter. As well, if it is LRU page, add the page to LRU\n\t * list in here.\n\t */\n\tif (rc == MIGRATEPAGE_SUCCESS) {\n\t\tif (unlikely(__PageMovable(newpage)))\n\t\t\tput_page(newpage);\n\t\telse\n\t\t\tputback_lru_page(newpage);\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "move_to_new_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "908-979",
    "snippet": "static int move_to_new_page(struct page *newpage, struct page *page,\n\t\t\t\tenum migrate_mode mode)\n{\n\tstruct address_space *mapping;\n\tint rc = -EAGAIN;\n\tbool is_lru = !__PageMovable(page);\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(!PageLocked(newpage), newpage);\n\n\tmapping = page_mapping(page);\n\n\tif (likely(is_lru)) {\n\t\tif (!mapping)\n\t\t\trc = migrate_page(mapping, newpage, page, mode);\n\t\telse if (mapping->a_ops->migratepage)\n\t\t\t/*\n\t\t\t * Most pages have a mapping and most filesystems\n\t\t\t * provide a migratepage callback. Anonymous pages\n\t\t\t * are part of swap space which also has its own\n\t\t\t * migratepage callback. This is the most common path\n\t\t\t * for page migration.\n\t\t\t */\n\t\t\trc = mapping->a_ops->migratepage(mapping, newpage,\n\t\t\t\t\t\t\tpage, mode);\n\t\telse\n\t\t\trc = fallback_migrate_page(mapping, newpage,\n\t\t\t\t\t\t\tpage, mode);\n\t} else {\n\t\t/*\n\t\t * In case of non-lru page, it could be released after\n\t\t * isolation step. In that case, we shouldn't try migration.\n\t\t */\n\t\tVM_BUG_ON_PAGE(!PageIsolated(page), page);\n\t\tif (!PageMovable(page)) {\n\t\t\trc = MIGRATEPAGE_SUCCESS;\n\t\t\t__ClearPageIsolated(page);\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = mapping->a_ops->migratepage(mapping, newpage,\n\t\t\t\t\t\tpage, mode);\n\t\tWARN_ON_ONCE(rc == MIGRATEPAGE_SUCCESS &&\n\t\t\t!PageIsolated(page));\n\t}\n\n\t/*\n\t * When successful, old pagecache page->mapping must be cleared before\n\t * page is freed; but stats require that PageAnon be left as PageAnon.\n\t */\n\tif (rc == MIGRATEPAGE_SUCCESS) {\n\t\tif (__PageMovable(page)) {\n\t\t\tVM_BUG_ON_PAGE(!PageIsolated(page), page);\n\n\t\t\t/*\n\t\t\t * We clear PG_movable under page_lock so any compactor\n\t\t\t * cannot try to migrate this page.\n\t\t\t */\n\t\t\t__ClearPageIsolated(page);\n\t\t}\n\n\t\t/*\n\t\t * Anonymous and movable page->mapping will be cleard by\n\t\t * free_pages_prepare so don't reset it here for keeping\n\t\t * the type to work PageAnon, for example.\n\t\t */\n\t\tif (!PageMappingFlags(page))\n\t\t\tpage->mapping = NULL;\n\t}\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PageMappingFlags",
          "args": [
            "page"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ClearPageIsolated",
          "args": [
            "page"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageIsolated(page)",
            "page"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageIsolated",
          "args": [
            "page"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__PageMovable",
          "args": [
            "page"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rc == MIGRATEPAGE_SUCCESS &&\n\t\t\t!PageIsolated(page)"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageIsolated",
          "args": [
            "page"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping->a_ops->migratepage",
          "args": [
            "mapping",
            "newpage",
            "page",
            "mode"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ClearPageIsolated",
          "args": [
            "page"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageMovable",
          "args": [
            "page"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "__ClearPageMovable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "120-131",
          "snippet": "void __ClearPageMovable(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(!PageMovable(page), page);\n\t/*\n\t * Clear registered address_space val with keeping PAGE_MAPPING_MOVABLE\n\t * flag so that VM can catch up released page by driver after isolation.\n\t * With it, VM migration doesn't try to put it back.\n\t */\n\tpage->mapping = (void *)((unsigned long)page->mapping &\n\t\t\t\tPAGE_MAPPING_MOVABLE);\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nvoid __ClearPageMovable(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(!PageMovable(page), page);\n\t/*\n\t * Clear registered address_space val with keeping PAGE_MAPPING_MOVABLE\n\t * flag so that VM can catch up released page by driver after isolation.\n\t * With it, VM migration doesn't try to put it back.\n\t */\n\tpage->mapping = (void *)((unsigned long)page->mapping &\n\t\t\t\tPAGE_MAPPING_MOVABLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageIsolated(page)",
            "page"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageIsolated",
          "args": [
            "page"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fallback_migrate_page",
          "args": [
            "mapping",
            "newpage",
            "page",
            "mode"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "fallback_migrate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "871-895",
          "snippet": "static int fallback_migrate_page(struct address_space *mapping,\n\tstruct page *newpage, struct page *page, enum migrate_mode mode)\n{\n\tif (PageDirty(page)) {\n\t\t/* Only writeback pages in full synchronous migration */\n\t\tswitch (mode) {\n\t\tcase MIGRATE_SYNC:\n\t\tcase MIGRATE_SYNC_NO_COPY:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EBUSY;\n\t\t}\n\t\treturn writeout(mapping, page);\n\t}\n\n\t/*\n\t * Buffers may be managed in a filesystem specific way.\n\t * We must have no buffers or drop them.\n\t */\n\tif (page_has_private(page) &&\n\t    !try_to_release_page(page, GFP_KERNEL))\n\t\treturn -EAGAIN;\n\n\treturn migrate_page(mapping, newpage, page, mode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic int fallback_migrate_page(struct address_space *mapping,\n\tstruct page *newpage, struct page *page, enum migrate_mode mode)\n{\n\tif (PageDirty(page)) {\n\t\t/* Only writeback pages in full synchronous migration */\n\t\tswitch (mode) {\n\t\tcase MIGRATE_SYNC:\n\t\tcase MIGRATE_SYNC_NO_COPY:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EBUSY;\n\t\t}\n\t\treturn writeout(mapping, page);\n\t}\n\n\t/*\n\t * Buffers may be managed in a filesystem specific way.\n\t * We must have no buffers or drop them.\n\t */\n\tif (page_has_private(page) &&\n\t    !try_to_release_page(page, GFP_KERNEL))\n\t\treturn -EAGAIN;\n\n\treturn migrate_page(mapping, newpage, page, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping->a_ops->migratepage",
          "args": [
            "mapping",
            "newpage",
            "page",
            "mode"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "is_lru"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "page"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapping_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "528-533",
          "snippet": "struct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLocked(newpage)",
            "newpage"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "newpage"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLocked(page)",
            "page"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__PageMovable",
          "args": [
            "page"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic int move_to_new_page(struct page *newpage, struct page *page,\n\t\t\t\tenum migrate_mode mode)\n{\n\tstruct address_space *mapping;\n\tint rc = -EAGAIN;\n\tbool is_lru = !__PageMovable(page);\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(!PageLocked(newpage), newpage);\n\n\tmapping = page_mapping(page);\n\n\tif (likely(is_lru)) {\n\t\tif (!mapping)\n\t\t\trc = migrate_page(mapping, newpage, page, mode);\n\t\telse if (mapping->a_ops->migratepage)\n\t\t\t/*\n\t\t\t * Most pages have a mapping and most filesystems\n\t\t\t * provide a migratepage callback. Anonymous pages\n\t\t\t * are part of swap space which also has its own\n\t\t\t * migratepage callback. This is the most common path\n\t\t\t * for page migration.\n\t\t\t */\n\t\t\trc = mapping->a_ops->migratepage(mapping, newpage,\n\t\t\t\t\t\t\tpage, mode);\n\t\telse\n\t\t\trc = fallback_migrate_page(mapping, newpage,\n\t\t\t\t\t\t\tpage, mode);\n\t} else {\n\t\t/*\n\t\t * In case of non-lru page, it could be released after\n\t\t * isolation step. In that case, we shouldn't try migration.\n\t\t */\n\t\tVM_BUG_ON_PAGE(!PageIsolated(page), page);\n\t\tif (!PageMovable(page)) {\n\t\t\trc = MIGRATEPAGE_SUCCESS;\n\t\t\t__ClearPageIsolated(page);\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = mapping->a_ops->migratepage(mapping, newpage,\n\t\t\t\t\t\tpage, mode);\n\t\tWARN_ON_ONCE(rc == MIGRATEPAGE_SUCCESS &&\n\t\t\t!PageIsolated(page));\n\t}\n\n\t/*\n\t * When successful, old pagecache page->mapping must be cleared before\n\t * page is freed; but stats require that PageAnon be left as PageAnon.\n\t */\n\tif (rc == MIGRATEPAGE_SUCCESS) {\n\t\tif (__PageMovable(page)) {\n\t\t\tVM_BUG_ON_PAGE(!PageIsolated(page), page);\n\n\t\t\t/*\n\t\t\t * We clear PG_movable under page_lock so any compactor\n\t\t\t * cannot try to migrate this page.\n\t\t\t */\n\t\t\t__ClearPageIsolated(page);\n\t\t}\n\n\t\t/*\n\t\t * Anonymous and movable page->mapping will be cleard by\n\t\t * free_pages_prepare so don't reset it here for keeping\n\t\t * the type to work PageAnon, for example.\n\t\t */\n\t\tif (!PageMappingFlags(page))\n\t\t\tpage->mapping = NULL;\n\t}\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "fallback_migrate_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "871-895",
    "snippet": "static int fallback_migrate_page(struct address_space *mapping,\n\tstruct page *newpage, struct page *page, enum migrate_mode mode)\n{\n\tif (PageDirty(page)) {\n\t\t/* Only writeback pages in full synchronous migration */\n\t\tswitch (mode) {\n\t\tcase MIGRATE_SYNC:\n\t\tcase MIGRATE_SYNC_NO_COPY:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EBUSY;\n\t\t}\n\t\treturn writeout(mapping, page);\n\t}\n\n\t/*\n\t * Buffers may be managed in a filesystem specific way.\n\t * We must have no buffers or drop them.\n\t */\n\tif (page_has_private(page) &&\n\t    !try_to_release_page(page, GFP_KERNEL))\n\t\treturn -EAGAIN;\n\n\treturn migrate_page(mapping, newpage, page, mode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "migrate_page",
          "args": [
            "mapping",
            "newpage",
            "page",
            "mode"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "fallback_migrate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "871-895",
          "snippet": "static int fallback_migrate_page(struct address_space *mapping,\n\tstruct page *newpage, struct page *page, enum migrate_mode mode)\n{\n\tif (PageDirty(page)) {\n\t\t/* Only writeback pages in full synchronous migration */\n\t\tswitch (mode) {\n\t\tcase MIGRATE_SYNC:\n\t\tcase MIGRATE_SYNC_NO_COPY:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EBUSY;\n\t\t}\n\t\treturn writeout(mapping, page);\n\t}\n\n\t/*\n\t * Buffers may be managed in a filesystem specific way.\n\t * We must have no buffers or drop them.\n\t */\n\tif (page_has_private(page) &&\n\t    !try_to_release_page(page, GFP_KERNEL))\n\t\treturn -EAGAIN;\n\n\treturn migrate_page(mapping, newpage, page, mode);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "try_to_release_page",
          "args": [
            "page",
            "GFP_KERNEL"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_release_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "3319-3330",
          "snippet": "int try_to_release_page(struct page *page, gfp_t gfp_mask)\n{\n\tstruct address_space * const mapping = page->mapping;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping && mapping->a_ops->releasepage)\n\t\treturn mapping->a_ops->releasepage(page, gfp_mask);\n\treturn try_to_free_buffers(page);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint try_to_release_page(struct page *page, gfp_t gfp_mask)\n{\n\tstruct address_space * const mapping = page->mapping;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping && mapping->a_ops->releasepage)\n\t\treturn mapping->a_ops->releasepage(page, gfp_mask);\n\treturn try_to_free_buffers(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_private",
          "args": [
            "page"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writeout",
          "args": [
            "mapping",
            "page"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "writeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "830-866",
          "snippet": "static int writeout(struct address_space *mapping, struct page *page)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_NONE,\n\t\t.nr_to_write = 1,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t\t.for_reclaim = 1\n\t};\n\tint rc;\n\n\tif (!mapping->a_ops->writepage)\n\t\t/* No write method for the address space */\n\t\treturn -EINVAL;\n\n\tif (!clear_page_dirty_for_io(page))\n\t\t/* Someone else already triggered a write */\n\t\treturn -EAGAIN;\n\n\t/*\n\t * A dirty page may imply that the underlying filesystem has\n\t * the page on some queue. So the page must be clean for\n\t * migration. Writeout may mean we loose the lock and the\n\t * page state is no longer what we checked for earlier.\n\t * At this point we know that the migration attempt cannot\n\t * be successful.\n\t */\n\tremove_migration_ptes(page, page, false);\n\n\trc = mapping->a_ops->writepage(page, &wbc);\n\n\tif (rc != AOP_WRITEPAGE_ACTIVATE)\n\t\t/* unlocked. Relock */\n\t\tlock_page(page);\n\n\treturn (rc < 0) ? -EIO : -EAGAIN;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic int writeout(struct address_space *mapping, struct page *page)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_NONE,\n\t\t.nr_to_write = 1,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t\t.for_reclaim = 1\n\t};\n\tint rc;\n\n\tif (!mapping->a_ops->writepage)\n\t\t/* No write method for the address space */\n\t\treturn -EINVAL;\n\n\tif (!clear_page_dirty_for_io(page))\n\t\t/* Someone else already triggered a write */\n\t\treturn -EAGAIN;\n\n\t/*\n\t * A dirty page may imply that the underlying filesystem has\n\t * the page on some queue. So the page must be clean for\n\t * migration. Writeout may mean we loose the lock and the\n\t * page state is no longer what we checked for earlier.\n\t * At this point we know that the migration attempt cannot\n\t * be successful.\n\t */\n\tremove_migration_ptes(page, page, false);\n\n\trc = mapping->a_ops->writepage(page, &wbc);\n\n\tif (rc != AOP_WRITEPAGE_ACTIVATE)\n\t\t/* unlocked. Relock */\n\t\tlock_page(page);\n\n\treturn (rc < 0) ? -EIO : -EAGAIN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic int fallback_migrate_page(struct address_space *mapping,\n\tstruct page *newpage, struct page *page, enum migrate_mode mode)\n{\n\tif (PageDirty(page)) {\n\t\t/* Only writeback pages in full synchronous migration */\n\t\tswitch (mode) {\n\t\tcase MIGRATE_SYNC:\n\t\tcase MIGRATE_SYNC_NO_COPY:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EBUSY;\n\t\t}\n\t\treturn writeout(mapping, page);\n\t}\n\n\t/*\n\t * Buffers may be managed in a filesystem specific way.\n\t * We must have no buffers or drop them.\n\t */\n\tif (page_has_private(page) &&\n\t    !try_to_release_page(page, GFP_KERNEL))\n\t\treturn -EAGAIN;\n\n\treturn migrate_page(mapping, newpage, page, mode);\n}"
  },
  {
    "function_name": "writeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "830-866",
    "snippet": "static int writeout(struct address_space *mapping, struct page *page)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_NONE,\n\t\t.nr_to_write = 1,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t\t.for_reclaim = 1\n\t};\n\tint rc;\n\n\tif (!mapping->a_ops->writepage)\n\t\t/* No write method for the address space */\n\t\treturn -EINVAL;\n\n\tif (!clear_page_dirty_for_io(page))\n\t\t/* Someone else already triggered a write */\n\t\treturn -EAGAIN;\n\n\t/*\n\t * A dirty page may imply that the underlying filesystem has\n\t * the page on some queue. So the page must be clean for\n\t * migration. Writeout may mean we loose the lock and the\n\t * page state is no longer what we checked for earlier.\n\t * At this point we know that the migration attempt cannot\n\t * be successful.\n\t */\n\tremove_migration_ptes(page, page, false);\n\n\trc = mapping->a_ops->writepage(page, &wbc);\n\n\tif (rc != AOP_WRITEPAGE_ACTIVATE)\n\t\t/* unlocked. Relock */\n\t\tlock_page(page);\n\n\treturn (rc < 0) ? -EIO : -EAGAIN;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "page"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping->a_ops->writepage",
          "args": [
            "page",
            "&wbc"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_migration_ptes",
          "args": [
            "page",
            "page",
            "false"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "remove_migration_ptes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "292-303",
          "snippet": "void remove_migration_ptes(struct page *old, struct page *new, bool locked)\n{\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = remove_migration_pte,\n\t\t.arg = old,\n\t};\n\n\tif (locked)\n\t\trmap_walk_locked(new, &rwc);\n\telse\n\t\trmap_walk(new, &rwc);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nvoid remove_migration_ptes(struct page *old, struct page *new, bool locked)\n{\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = remove_migration_pte,\n\t\t.arg = old,\n\t};\n\n\tif (locked)\n\t\trmap_walk_locked(new, &rwc);\n\telse\n\t\trmap_walk(new, &rwc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_page_dirty_for_io",
          "args": [
            "page"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "clear_page_dirty_for_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2634-2692",
          "snippet": "int clear_page_dirty_for_io(struct page *page)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\n\tif (mapping && mapping_cap_account_dirty(mapping)) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct bdi_writeback *wb;\n\t\tstruct wb_lock_cookie cookie = {};\n\n\t\t/*\n\t\t * Yes, Virginia, this is indeed insane.\n\t\t *\n\t\t * We use this sequence to make sure that\n\t\t *  (a) we account for dirty stats properly\n\t\t *  (b) we tell the low-level filesystem to\n\t\t *      mark the whole page dirty if it was\n\t\t *      dirty in a pagetable. Only to then\n\t\t *  (c) clean the page again and return 1 to\n\t\t *      cause the writeback.\n\t\t *\n\t\t * This way we avoid all nasty races with the\n\t\t * dirty bit in multiple places and clearing\n\t\t * them concurrently from different threads.\n\t\t *\n\t\t * Note! Normally the \"set_page_dirty(page)\"\n\t\t * has no effect on the actual dirty bit - since\n\t\t * that will already usually be set. But we\n\t\t * need the side effects, and it can help us\n\t\t * avoid races.\n\t\t *\n\t\t * We basically use the page \"master dirty bit\"\n\t\t * as a serialization point for all the different\n\t\t * threads doing their things.\n\t\t */\n\t\tif (page_mkclean(page))\n\t\t\tset_page_dirty(page);\n\t\t/*\n\t\t * We carefully synchronise fault handlers against\n\t\t * installing a dirty pte and marking the page dirty\n\t\t * at this point.  We do this by having them hold the\n\t\t * page lock while dirtying the page, and pages are\n\t\t * always locked coming in here, so we get the desired\n\t\t * exclusion.\n\t\t */\n\t\twb = unlocked_inode_to_wb_begin(inode, &cookie);\n\t\tif (TestClearPageDirty(page)) {\n\t\t\tdec_lruvec_page_state(page, NR_FILE_DIRTY);\n\t\t\tdec_zone_page_state(page, NR_ZONE_WRITE_PENDING);\n\t\t\tdec_wb_stat(wb, WB_RECLAIMABLE);\n\t\t\tret = 1;\n\t\t}\n\t\tunlocked_inode_to_wb_end(inode, &cookie);\n\t\treturn ret;\n\t}\n\treturn TestClearPageDirty(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint clear_page_dirty_for_io(struct page *page)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\n\tif (mapping && mapping_cap_account_dirty(mapping)) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct bdi_writeback *wb;\n\t\tstruct wb_lock_cookie cookie = {};\n\n\t\t/*\n\t\t * Yes, Virginia, this is indeed insane.\n\t\t *\n\t\t * We use this sequence to make sure that\n\t\t *  (a) we account for dirty stats properly\n\t\t *  (b) we tell the low-level filesystem to\n\t\t *      mark the whole page dirty if it was\n\t\t *      dirty in a pagetable. Only to then\n\t\t *  (c) clean the page again and return 1 to\n\t\t *      cause the writeback.\n\t\t *\n\t\t * This way we avoid all nasty races with the\n\t\t * dirty bit in multiple places and clearing\n\t\t * them concurrently from different threads.\n\t\t *\n\t\t * Note! Normally the \"set_page_dirty(page)\"\n\t\t * has no effect on the actual dirty bit - since\n\t\t * that will already usually be set. But we\n\t\t * need the side effects, and it can help us\n\t\t * avoid races.\n\t\t *\n\t\t * We basically use the page \"master dirty bit\"\n\t\t * as a serialization point for all the different\n\t\t * threads doing their things.\n\t\t */\n\t\tif (page_mkclean(page))\n\t\t\tset_page_dirty(page);\n\t\t/*\n\t\t * We carefully synchronise fault handlers against\n\t\t * installing a dirty pte and marking the page dirty\n\t\t * at this point.  We do this by having them hold the\n\t\t * page lock while dirtying the page, and pages are\n\t\t * always locked coming in here, so we get the desired\n\t\t * exclusion.\n\t\t */\n\t\twb = unlocked_inode_to_wb_begin(inode, &cookie);\n\t\tif (TestClearPageDirty(page)) {\n\t\t\tdec_lruvec_page_state(page, NR_FILE_DIRTY);\n\t\t\tdec_zone_page_state(page, NR_ZONE_WRITE_PENDING);\n\t\t\tdec_wb_stat(wb, WB_RECLAIMABLE);\n\t\t\tret = 1;\n\t\t}\n\t\tunlocked_inode_to_wb_end(inode, &cookie);\n\t\treturn ret;\n\t}\n\treturn TestClearPageDirty(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic int writeout(struct address_space *mapping, struct page *page)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_NONE,\n\t\t.nr_to_write = 1,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t\t.for_reclaim = 1\n\t};\n\tint rc;\n\n\tif (!mapping->a_ops->writepage)\n\t\t/* No write method for the address space */\n\t\treturn -EINVAL;\n\n\tif (!clear_page_dirty_for_io(page))\n\t\t/* Someone else already triggered a write */\n\t\treturn -EAGAIN;\n\n\t/*\n\t * A dirty page may imply that the underlying filesystem has\n\t * the page on some queue. So the page must be clean for\n\t * migration. Writeout may mean we loose the lock and the\n\t * page state is no longer what we checked for earlier.\n\t * At this point we know that the migration attempt cannot\n\t * be successful.\n\t */\n\tremove_migration_ptes(page, page, false);\n\n\trc = mapping->a_ops->writepage(page, &wbc);\n\n\tif (rc != AOP_WRITEPAGE_ACTIVATE)\n\t\t/* unlocked. Relock */\n\t\tlock_page(page);\n\n\treturn (rc < 0) ? -EIO : -EAGAIN;\n}"
  },
  {
    "function_name": "buffer_migrate_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "770-823",
    "snippet": "int buffer_migrate_page(struct address_space *mapping,\n\t\tstruct page *newpage, struct page *page, enum migrate_mode mode)\n{\n\tstruct buffer_head *bh, *head;\n\tint rc;\n\n\tif (!page_has_buffers(page))\n\t\treturn migrate_page(mapping, newpage, page, mode);\n\n\thead = page_buffers(page);\n\n\trc = migrate_page_move_mapping(mapping, newpage, page, head, mode, 0);\n\n\tif (rc != MIGRATEPAGE_SUCCESS)\n\t\treturn rc;\n\n\t/*\n\t * In the async case, migrate_page_move_mapping locked the buffers\n\t * with an IRQ-safe spinlock held. In the sync case, the buffers\n\t * need to be locked now\n\t */\n\tif (mode != MIGRATE_ASYNC)\n\t\tBUG_ON(!buffer_migrate_lock_buffers(head, mode));\n\n\tClearPagePrivate(page);\n\tset_page_private(newpage, page_private(page));\n\tset_page_private(page, 0);\n\tput_page(page);\n\tget_page(newpage);\n\n\tbh = head;\n\tdo {\n\t\tset_bh_page(bh, newpage, bh_offset(bh));\n\t\tbh = bh->b_this_page;\n\n\t} while (bh != head);\n\n\tSetPagePrivate(newpage);\n\n\tif (mode != MIGRATE_SYNC_NO_COPY)\n\t\tmigrate_page_copy(newpage, page);\n\telse\n\t\tmigrate_page_states(newpage, page);\n\n\tbh = head;\n\tdo {\n\t\tunlock_buffer(bh);\n\t\tput_bh(bh);\n\t\tbh = bh->b_this_page;\n\n\t} while (bh != head);\n\n\treturn MIGRATEPAGE_SUCCESS;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_page_states",
          "args": [
            "newpage",
            "page"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_page_states",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "661-719",
          "snippet": "void migrate_page_states(struct page *newpage, struct page *page)\n{\n\tint cpupid;\n\n\tif (PageError(page))\n\t\tSetPageError(newpage);\n\tif (PageReferenced(page))\n\t\tSetPageReferenced(newpage);\n\tif (PageUptodate(page))\n\t\tSetPageUptodate(newpage);\n\tif (TestClearPageActive(page)) {\n\t\tVM_BUG_ON_PAGE(PageUnevictable(page), page);\n\t\tSetPageActive(newpage);\n\t} else if (TestClearPageUnevictable(page))\n\t\tSetPageUnevictable(newpage);\n\tif (PageWorkingset(page))\n\t\tSetPageWorkingset(newpage);\n\tif (PageChecked(page))\n\t\tSetPageChecked(newpage);\n\tif (PageMappedToDisk(page))\n\t\tSetPageMappedToDisk(newpage);\n\n\t/* Move dirty on pages not done by migrate_page_move_mapping() */\n\tif (PageDirty(page))\n\t\tSetPageDirty(newpage);\n\n\tif (page_is_young(page))\n\t\tset_page_young(newpage);\n\tif (page_is_idle(page))\n\t\tset_page_idle(newpage);\n\n\t/*\n\t * Copy NUMA information to the new page, to prevent over-eager\n\t * future migrations of this same page.\n\t */\n\tcpupid = page_cpupid_xchg_last(page, -1);\n\tpage_cpupid_xchg_last(newpage, cpupid);\n\n\tksm_migrate_page(newpage, page);\n\t/*\n\t * Please do not reorder this without considering how mm/ksm.c's\n\t * get_ksm_page() depends upon ksm_migrate_page() and PageSwapCache().\n\t */\n\tif (PageSwapCache(page))\n\t\tClearPageSwapCache(page);\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\n\t/*\n\t * If any waiters have accumulated on the new page then\n\t * wake them up.\n\t */\n\tif (PageWriteback(newpage))\n\t\tend_page_writeback(newpage);\n\n\tcopy_page_owner(page, newpage);\n\n\tmem_cgroup_migrate(page, newpage);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nvoid migrate_page_states(struct page *newpage, struct page *page)\n{\n\tint cpupid;\n\n\tif (PageError(page))\n\t\tSetPageError(newpage);\n\tif (PageReferenced(page))\n\t\tSetPageReferenced(newpage);\n\tif (PageUptodate(page))\n\t\tSetPageUptodate(newpage);\n\tif (TestClearPageActive(page)) {\n\t\tVM_BUG_ON_PAGE(PageUnevictable(page), page);\n\t\tSetPageActive(newpage);\n\t} else if (TestClearPageUnevictable(page))\n\t\tSetPageUnevictable(newpage);\n\tif (PageWorkingset(page))\n\t\tSetPageWorkingset(newpage);\n\tif (PageChecked(page))\n\t\tSetPageChecked(newpage);\n\tif (PageMappedToDisk(page))\n\t\tSetPageMappedToDisk(newpage);\n\n\t/* Move dirty on pages not done by migrate_page_move_mapping() */\n\tif (PageDirty(page))\n\t\tSetPageDirty(newpage);\n\n\tif (page_is_young(page))\n\t\tset_page_young(newpage);\n\tif (page_is_idle(page))\n\t\tset_page_idle(newpage);\n\n\t/*\n\t * Copy NUMA information to the new page, to prevent over-eager\n\t * future migrations of this same page.\n\t */\n\tcpupid = page_cpupid_xchg_last(page, -1);\n\tpage_cpupid_xchg_last(newpage, cpupid);\n\n\tksm_migrate_page(newpage, page);\n\t/*\n\t * Please do not reorder this without considering how mm/ksm.c's\n\t * get_ksm_page() depends upon ksm_migrate_page() and PageSwapCache().\n\t */\n\tif (PageSwapCache(page))\n\t\tClearPageSwapCache(page);\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\n\t/*\n\t * If any waiters have accumulated on the new page then\n\t * wake them up.\n\t */\n\tif (PageWriteback(newpage))\n\t\tend_page_writeback(newpage);\n\n\tcopy_page_owner(page, newpage);\n\n\tmem_cgroup_migrate(page, newpage);\n}"
        }
      },
      {
        "call_info": {
          "callee": "migrate_page_copy",
          "args": [
            "newpage",
            "page"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_page_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "722-730",
          "snippet": "void migrate_page_copy(struct page *newpage, struct page *page)\n{\n\tif (PageHuge(page) || PageTransHuge(page))\n\t\tcopy_huge_page(newpage, page);\n\telse\n\t\tcopy_highpage(newpage, page);\n\n\tmigrate_page_states(newpage, page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nvoid migrate_page_copy(struct page *newpage, struct page *page)\n{\n\tif (PageHuge(page) || PageTransHuge(page))\n\t\tcopy_huge_page(newpage, page);\n\telse\n\t\tcopy_highpage(newpage, page);\n\n\tmigrate_page_states(newpage, page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPagePrivate",
          "args": [
            "newpage"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bh_page",
          "args": [
            "bh",
            "newpage",
            "bh_offset(bh)"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh_offset",
          "args": [
            "bh"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "newpage"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "0"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "newpage",
            "page_private(page)"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "page"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPagePrivate",
          "args": [
            "page"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!buffer_migrate_lock_buffers(head, mode)"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_migrate_lock_buffers",
          "args": [
            "head",
            "mode"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_migrate_lock_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "424-428",
          "snippet": "static inline bool buffer_migrate_lock_buffers(struct buffer_head *head,\n\t\t\t\t\t\t\tenum migrate_mode mode)\n{\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic inline bool buffer_migrate_lock_buffers(struct buffer_head *head,\n\t\t\t\t\t\t\tenum migrate_mode mode)\n{\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "migrate_page_move_mapping",
          "args": [
            "mapping",
            "newpage",
            "page",
            "head",
            "mode",
            "0"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_page_move_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "439-571",
          "snippet": "int migrate_page_move_mapping(struct address_space *mapping,\n\t\tstruct page *newpage, struct page *page,\n\t\tstruct buffer_head *head, enum migrate_mode mode,\n\t\tint extra_count)\n{\n\tXA_STATE(xas, &mapping->i_pages, page_index(page));\n\tstruct zone *oldzone, *newzone;\n\tint dirty;\n\tint expected_count = 1 + extra_count;\n\n\t/*\n\t * Device public or private pages have an extra refcount as they are\n\t * ZONE_DEVICE pages.\n\t */\n\texpected_count += is_device_private_page(page);\n\texpected_count += is_device_public_page(page);\n\n\tif (!mapping) {\n\t\t/* Anonymous page without mapping */\n\t\tif (page_count(page) != expected_count)\n\t\t\treturn -EAGAIN;\n\n\t\t/* No turning back from here */\n\t\tnewpage->index = page->index;\n\t\tnewpage->mapping = page->mapping;\n\t\tif (PageSwapBacked(page))\n\t\t\t__SetPageSwapBacked(newpage);\n\n\t\treturn MIGRATEPAGE_SUCCESS;\n\t}\n\n\toldzone = page_zone(page);\n\tnewzone = page_zone(newpage);\n\n\txas_lock_irq(&xas);\n\n\texpected_count += hpage_nr_pages(page) + page_has_private(page);\n\tif (page_count(page) != expected_count || xas_load(&xas) != page) {\n\t\txas_unlock_irq(&xas);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!page_ref_freeze(page, expected_count)) {\n\t\txas_unlock_irq(&xas);\n\t\treturn -EAGAIN;\n\t}\n\n\t/*\n\t * In the async migration case of moving a page with buffers, lock the\n\t * buffers using trylock before the mapping is moved. If the mapping\n\t * was moved, we later failed to lock the buffers and could not move\n\t * the mapping back due to an elevated page count, we would have to\n\t * block waiting on other references to be dropped.\n\t */\n\tif (mode == MIGRATE_ASYNC && head &&\n\t\t\t!buffer_migrate_lock_buffers(head, mode)) {\n\t\tpage_ref_unfreeze(page, expected_count);\n\t\txas_unlock_irq(&xas);\n\t\treturn -EAGAIN;\n\t}\n\n\t/*\n\t * Now we know that no one else is looking at the page:\n\t * no turning back from here.\n\t */\n\tnewpage->index = page->index;\n\tnewpage->mapping = page->mapping;\n\tpage_ref_add(newpage, hpage_nr_pages(page)); /* add cache reference */\n\tif (PageSwapBacked(page)) {\n\t\t__SetPageSwapBacked(newpage);\n\t\tif (PageSwapCache(page)) {\n\t\t\tSetPageSwapCache(newpage);\n\t\t\tset_page_private(newpage, page_private(page));\n\t\t}\n\t} else {\n\t\tVM_BUG_ON_PAGE(PageSwapCache(page), page);\n\t}\n\n\t/* Move dirty while page refs frozen and newpage not yet exposed */\n\tdirty = PageDirty(page);\n\tif (dirty) {\n\t\tClearPageDirty(page);\n\t\tSetPageDirty(newpage);\n\t}\n\n\txas_store(&xas, newpage);\n\tif (PageTransHuge(page)) {\n\t\tint i;\n\n\t\tfor (i = 1; i < HPAGE_PMD_NR; i++) {\n\t\t\txas_next(&xas);\n\t\t\txas_store(&xas, newpage + i);\n\t\t}\n\t}\n\n\t/*\n\t * Drop cache reference from old page by unfreezing\n\t * to one less reference.\n\t * We know this isn't the last reference.\n\t */\n\tpage_ref_unfreeze(page, expected_count - hpage_nr_pages(page));\n\n\txas_unlock(&xas);\n\t/* Leave irq disabled to prevent preemption while updating stats */\n\n\t/*\n\t * If moved to a different zone then also account\n\t * the page for that zone. Other VM counters will be\n\t * taken care of when we establish references to the\n\t * new page and drop references to the old page.\n\t *\n\t * Note that anonymous pages are accounted for\n\t * via NR_FILE_PAGES and NR_ANON_MAPPED if they\n\t * are mapped to swap space.\n\t */\n\tif (newzone != oldzone) {\n\t\t__dec_node_state(oldzone->zone_pgdat, NR_FILE_PAGES);\n\t\t__inc_node_state(newzone->zone_pgdat, NR_FILE_PAGES);\n\t\tif (PageSwapBacked(page) && !PageSwapCache(page)) {\n\t\t\t__dec_node_state(oldzone->zone_pgdat, NR_SHMEM);\n\t\t\t__inc_node_state(newzone->zone_pgdat, NR_SHMEM);\n\t\t}\n\t\tif (dirty && mapping_cap_account_dirty(mapping)) {\n\t\t\t__dec_node_state(oldzone->zone_pgdat, NR_FILE_DIRTY);\n\t\t\t__dec_zone_state(oldzone, NR_ZONE_WRITE_PENDING);\n\t\t\t__inc_node_state(newzone->zone_pgdat, NR_FILE_DIRTY);\n\t\t\t__inc_zone_state(newzone, NR_ZONE_WRITE_PENDING);\n\t\t}\n\t}\n\tlocal_irq_enable();\n\n\treturn MIGRATEPAGE_SUCCESS;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nint migrate_page_move_mapping(struct address_space *mapping,\n\t\tstruct page *newpage, struct page *page,\n\t\tstruct buffer_head *head, enum migrate_mode mode,\n\t\tint extra_count)\n{\n\tXA_STATE(xas, &mapping->i_pages, page_index(page));\n\tstruct zone *oldzone, *newzone;\n\tint dirty;\n\tint expected_count = 1 + extra_count;\n\n\t/*\n\t * Device public or private pages have an extra refcount as they are\n\t * ZONE_DEVICE pages.\n\t */\n\texpected_count += is_device_private_page(page);\n\texpected_count += is_device_public_page(page);\n\n\tif (!mapping) {\n\t\t/* Anonymous page without mapping */\n\t\tif (page_count(page) != expected_count)\n\t\t\treturn -EAGAIN;\n\n\t\t/* No turning back from here */\n\t\tnewpage->index = page->index;\n\t\tnewpage->mapping = page->mapping;\n\t\tif (PageSwapBacked(page))\n\t\t\t__SetPageSwapBacked(newpage);\n\n\t\treturn MIGRATEPAGE_SUCCESS;\n\t}\n\n\toldzone = page_zone(page);\n\tnewzone = page_zone(newpage);\n\n\txas_lock_irq(&xas);\n\n\texpected_count += hpage_nr_pages(page) + page_has_private(page);\n\tif (page_count(page) != expected_count || xas_load(&xas) != page) {\n\t\txas_unlock_irq(&xas);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!page_ref_freeze(page, expected_count)) {\n\t\txas_unlock_irq(&xas);\n\t\treturn -EAGAIN;\n\t}\n\n\t/*\n\t * In the async migration case of moving a page with buffers, lock the\n\t * buffers using trylock before the mapping is moved. If the mapping\n\t * was moved, we later failed to lock the buffers and could not move\n\t * the mapping back due to an elevated page count, we would have to\n\t * block waiting on other references to be dropped.\n\t */\n\tif (mode == MIGRATE_ASYNC && head &&\n\t\t\t!buffer_migrate_lock_buffers(head, mode)) {\n\t\tpage_ref_unfreeze(page, expected_count);\n\t\txas_unlock_irq(&xas);\n\t\treturn -EAGAIN;\n\t}\n\n\t/*\n\t * Now we know that no one else is looking at the page:\n\t * no turning back from here.\n\t */\n\tnewpage->index = page->index;\n\tnewpage->mapping = page->mapping;\n\tpage_ref_add(newpage, hpage_nr_pages(page)); /* add cache reference */\n\tif (PageSwapBacked(page)) {\n\t\t__SetPageSwapBacked(newpage);\n\t\tif (PageSwapCache(page)) {\n\t\t\tSetPageSwapCache(newpage);\n\t\t\tset_page_private(newpage, page_private(page));\n\t\t}\n\t} else {\n\t\tVM_BUG_ON_PAGE(PageSwapCache(page), page);\n\t}\n\n\t/* Move dirty while page refs frozen and newpage not yet exposed */\n\tdirty = PageDirty(page);\n\tif (dirty) {\n\t\tClearPageDirty(page);\n\t\tSetPageDirty(newpage);\n\t}\n\n\txas_store(&xas, newpage);\n\tif (PageTransHuge(page)) {\n\t\tint i;\n\n\t\tfor (i = 1; i < HPAGE_PMD_NR; i++) {\n\t\t\txas_next(&xas);\n\t\t\txas_store(&xas, newpage + i);\n\t\t}\n\t}\n\n\t/*\n\t * Drop cache reference from old page by unfreezing\n\t * to one less reference.\n\t * We know this isn't the last reference.\n\t */\n\tpage_ref_unfreeze(page, expected_count - hpage_nr_pages(page));\n\n\txas_unlock(&xas);\n\t/* Leave irq disabled to prevent preemption while updating stats */\n\n\t/*\n\t * If moved to a different zone then also account\n\t * the page for that zone. Other VM counters will be\n\t * taken care of when we establish references to the\n\t * new page and drop references to the old page.\n\t *\n\t * Note that anonymous pages are accounted for\n\t * via NR_FILE_PAGES and NR_ANON_MAPPED if they\n\t * are mapped to swap space.\n\t */\n\tif (newzone != oldzone) {\n\t\t__dec_node_state(oldzone->zone_pgdat, NR_FILE_PAGES);\n\t\t__inc_node_state(newzone->zone_pgdat, NR_FILE_PAGES);\n\t\tif (PageSwapBacked(page) && !PageSwapCache(page)) {\n\t\t\t__dec_node_state(oldzone->zone_pgdat, NR_SHMEM);\n\t\t\t__inc_node_state(newzone->zone_pgdat, NR_SHMEM);\n\t\t}\n\t\tif (dirty && mapping_cap_account_dirty(mapping)) {\n\t\t\t__dec_node_state(oldzone->zone_pgdat, NR_FILE_DIRTY);\n\t\t\t__dec_zone_state(oldzone, NR_ZONE_WRITE_PENDING);\n\t\t\t__inc_node_state(newzone->zone_pgdat, NR_FILE_DIRTY);\n\t\t\t__inc_zone_state(newzone, NR_ZONE_WRITE_PENDING);\n\t\t}\n\t}\n\tlocal_irq_enable();\n\n\treturn MIGRATEPAGE_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_page",
          "args": [
            "mapping",
            "newpage",
            "page",
            "mode"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "fallback_migrate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "871-895",
          "snippet": "static int fallback_migrate_page(struct address_space *mapping,\n\tstruct page *newpage, struct page *page, enum migrate_mode mode)\n{\n\tif (PageDirty(page)) {\n\t\t/* Only writeback pages in full synchronous migration */\n\t\tswitch (mode) {\n\t\tcase MIGRATE_SYNC:\n\t\tcase MIGRATE_SYNC_NO_COPY:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EBUSY;\n\t\t}\n\t\treturn writeout(mapping, page);\n\t}\n\n\t/*\n\t * Buffers may be managed in a filesystem specific way.\n\t * We must have no buffers or drop them.\n\t */\n\tif (page_has_private(page) &&\n\t    !try_to_release_page(page, GFP_KERNEL))\n\t\treturn -EAGAIN;\n\n\treturn migrate_page(mapping, newpage, page, mode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic int fallback_migrate_page(struct address_space *mapping,\n\tstruct page *newpage, struct page *page, enum migrate_mode mode)\n{\n\tif (PageDirty(page)) {\n\t\t/* Only writeback pages in full synchronous migration */\n\t\tswitch (mode) {\n\t\tcase MIGRATE_SYNC:\n\t\tcase MIGRATE_SYNC_NO_COPY:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EBUSY;\n\t\t}\n\t\treturn writeout(mapping, page);\n\t}\n\n\t/*\n\t * Buffers may be managed in a filesystem specific way.\n\t * We must have no buffers or drop them.\n\t */\n\tif (page_has_private(page) &&\n\t    !try_to_release_page(page, GFP_KERNEL))\n\t\treturn -EAGAIN;\n\n\treturn migrate_page(mapping, newpage, page, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nint buffer_migrate_page(struct address_space *mapping,\n\t\tstruct page *newpage, struct page *page, enum migrate_mode mode)\n{\n\tstruct buffer_head *bh, *head;\n\tint rc;\n\n\tif (!page_has_buffers(page))\n\t\treturn migrate_page(mapping, newpage, page, mode);\n\n\thead = page_buffers(page);\n\n\trc = migrate_page_move_mapping(mapping, newpage, page, head, mode, 0);\n\n\tif (rc != MIGRATEPAGE_SUCCESS)\n\t\treturn rc;\n\n\t/*\n\t * In the async case, migrate_page_move_mapping locked the buffers\n\t * with an IRQ-safe spinlock held. In the sync case, the buffers\n\t * need to be locked now\n\t */\n\tif (mode != MIGRATE_ASYNC)\n\t\tBUG_ON(!buffer_migrate_lock_buffers(head, mode));\n\n\tClearPagePrivate(page);\n\tset_page_private(newpage, page_private(page));\n\tset_page_private(page, 0);\n\tput_page(page);\n\tget_page(newpage);\n\n\tbh = head;\n\tdo {\n\t\tset_bh_page(bh, newpage, bh_offset(bh));\n\t\tbh = bh->b_this_page;\n\n\t} while (bh != head);\n\n\tSetPagePrivate(newpage);\n\n\tif (mode != MIGRATE_SYNC_NO_COPY)\n\t\tmigrate_page_copy(newpage, page);\n\telse\n\t\tmigrate_page_states(newpage, page);\n\n\tbh = head;\n\tdo {\n\t\tunlock_buffer(bh);\n\t\tput_bh(bh);\n\t\tbh = bh->b_this_page;\n\n\t} while (bh != head);\n\n\treturn MIGRATEPAGE_SUCCESS;\n}"
  },
  {
    "function_name": "migrate_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "743-761",
    "snippet": "int migrate_page(struct address_space *mapping,\n\t\tstruct page *newpage, struct page *page,\n\t\tenum migrate_mode mode)\n{\n\tint rc;\n\n\tBUG_ON(PageWriteback(page));\t/* Writeback must be complete */\n\n\trc = migrate_page_move_mapping(mapping, newpage, page, NULL, mode, 0);\n\n\tif (rc != MIGRATEPAGE_SUCCESS)\n\t\treturn rc;\n\n\tif (mode != MIGRATE_SYNC_NO_COPY)\n\t\tmigrate_page_copy(newpage, page);\n\telse\n\t\tmigrate_page_states(newpage, page);\n\treturn MIGRATEPAGE_SUCCESS;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "migrate_page_states",
          "args": [
            "newpage",
            "page"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_page_states",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "661-719",
          "snippet": "void migrate_page_states(struct page *newpage, struct page *page)\n{\n\tint cpupid;\n\n\tif (PageError(page))\n\t\tSetPageError(newpage);\n\tif (PageReferenced(page))\n\t\tSetPageReferenced(newpage);\n\tif (PageUptodate(page))\n\t\tSetPageUptodate(newpage);\n\tif (TestClearPageActive(page)) {\n\t\tVM_BUG_ON_PAGE(PageUnevictable(page), page);\n\t\tSetPageActive(newpage);\n\t} else if (TestClearPageUnevictable(page))\n\t\tSetPageUnevictable(newpage);\n\tif (PageWorkingset(page))\n\t\tSetPageWorkingset(newpage);\n\tif (PageChecked(page))\n\t\tSetPageChecked(newpage);\n\tif (PageMappedToDisk(page))\n\t\tSetPageMappedToDisk(newpage);\n\n\t/* Move dirty on pages not done by migrate_page_move_mapping() */\n\tif (PageDirty(page))\n\t\tSetPageDirty(newpage);\n\n\tif (page_is_young(page))\n\t\tset_page_young(newpage);\n\tif (page_is_idle(page))\n\t\tset_page_idle(newpage);\n\n\t/*\n\t * Copy NUMA information to the new page, to prevent over-eager\n\t * future migrations of this same page.\n\t */\n\tcpupid = page_cpupid_xchg_last(page, -1);\n\tpage_cpupid_xchg_last(newpage, cpupid);\n\n\tksm_migrate_page(newpage, page);\n\t/*\n\t * Please do not reorder this without considering how mm/ksm.c's\n\t * get_ksm_page() depends upon ksm_migrate_page() and PageSwapCache().\n\t */\n\tif (PageSwapCache(page))\n\t\tClearPageSwapCache(page);\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\n\t/*\n\t * If any waiters have accumulated on the new page then\n\t * wake them up.\n\t */\n\tif (PageWriteback(newpage))\n\t\tend_page_writeback(newpage);\n\n\tcopy_page_owner(page, newpage);\n\n\tmem_cgroup_migrate(page, newpage);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nvoid migrate_page_states(struct page *newpage, struct page *page)\n{\n\tint cpupid;\n\n\tif (PageError(page))\n\t\tSetPageError(newpage);\n\tif (PageReferenced(page))\n\t\tSetPageReferenced(newpage);\n\tif (PageUptodate(page))\n\t\tSetPageUptodate(newpage);\n\tif (TestClearPageActive(page)) {\n\t\tVM_BUG_ON_PAGE(PageUnevictable(page), page);\n\t\tSetPageActive(newpage);\n\t} else if (TestClearPageUnevictable(page))\n\t\tSetPageUnevictable(newpage);\n\tif (PageWorkingset(page))\n\t\tSetPageWorkingset(newpage);\n\tif (PageChecked(page))\n\t\tSetPageChecked(newpage);\n\tif (PageMappedToDisk(page))\n\t\tSetPageMappedToDisk(newpage);\n\n\t/* Move dirty on pages not done by migrate_page_move_mapping() */\n\tif (PageDirty(page))\n\t\tSetPageDirty(newpage);\n\n\tif (page_is_young(page))\n\t\tset_page_young(newpage);\n\tif (page_is_idle(page))\n\t\tset_page_idle(newpage);\n\n\t/*\n\t * Copy NUMA information to the new page, to prevent over-eager\n\t * future migrations of this same page.\n\t */\n\tcpupid = page_cpupid_xchg_last(page, -1);\n\tpage_cpupid_xchg_last(newpage, cpupid);\n\n\tksm_migrate_page(newpage, page);\n\t/*\n\t * Please do not reorder this without considering how mm/ksm.c's\n\t * get_ksm_page() depends upon ksm_migrate_page() and PageSwapCache().\n\t */\n\tif (PageSwapCache(page))\n\t\tClearPageSwapCache(page);\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\n\t/*\n\t * If any waiters have accumulated on the new page then\n\t * wake them up.\n\t */\n\tif (PageWriteback(newpage))\n\t\tend_page_writeback(newpage);\n\n\tcopy_page_owner(page, newpage);\n\n\tmem_cgroup_migrate(page, newpage);\n}"
        }
      },
      {
        "call_info": {
          "callee": "migrate_page_copy",
          "args": [
            "newpage",
            "page"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_page_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "722-730",
          "snippet": "void migrate_page_copy(struct page *newpage, struct page *page)\n{\n\tif (PageHuge(page) || PageTransHuge(page))\n\t\tcopy_huge_page(newpage, page);\n\telse\n\t\tcopy_highpage(newpage, page);\n\n\tmigrate_page_states(newpage, page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nvoid migrate_page_copy(struct page *newpage, struct page *page)\n{\n\tif (PageHuge(page) || PageTransHuge(page))\n\t\tcopy_huge_page(newpage, page);\n\telse\n\t\tcopy_highpage(newpage, page);\n\n\tmigrate_page_states(newpage, page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "migrate_page_move_mapping",
          "args": [
            "mapping",
            "newpage",
            "page",
            "NULL",
            "mode",
            "0"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_page_move_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "439-571",
          "snippet": "int migrate_page_move_mapping(struct address_space *mapping,\n\t\tstruct page *newpage, struct page *page,\n\t\tstruct buffer_head *head, enum migrate_mode mode,\n\t\tint extra_count)\n{\n\tXA_STATE(xas, &mapping->i_pages, page_index(page));\n\tstruct zone *oldzone, *newzone;\n\tint dirty;\n\tint expected_count = 1 + extra_count;\n\n\t/*\n\t * Device public or private pages have an extra refcount as they are\n\t * ZONE_DEVICE pages.\n\t */\n\texpected_count += is_device_private_page(page);\n\texpected_count += is_device_public_page(page);\n\n\tif (!mapping) {\n\t\t/* Anonymous page without mapping */\n\t\tif (page_count(page) != expected_count)\n\t\t\treturn -EAGAIN;\n\n\t\t/* No turning back from here */\n\t\tnewpage->index = page->index;\n\t\tnewpage->mapping = page->mapping;\n\t\tif (PageSwapBacked(page))\n\t\t\t__SetPageSwapBacked(newpage);\n\n\t\treturn MIGRATEPAGE_SUCCESS;\n\t}\n\n\toldzone = page_zone(page);\n\tnewzone = page_zone(newpage);\n\n\txas_lock_irq(&xas);\n\n\texpected_count += hpage_nr_pages(page) + page_has_private(page);\n\tif (page_count(page) != expected_count || xas_load(&xas) != page) {\n\t\txas_unlock_irq(&xas);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!page_ref_freeze(page, expected_count)) {\n\t\txas_unlock_irq(&xas);\n\t\treturn -EAGAIN;\n\t}\n\n\t/*\n\t * In the async migration case of moving a page with buffers, lock the\n\t * buffers using trylock before the mapping is moved. If the mapping\n\t * was moved, we later failed to lock the buffers and could not move\n\t * the mapping back due to an elevated page count, we would have to\n\t * block waiting on other references to be dropped.\n\t */\n\tif (mode == MIGRATE_ASYNC && head &&\n\t\t\t!buffer_migrate_lock_buffers(head, mode)) {\n\t\tpage_ref_unfreeze(page, expected_count);\n\t\txas_unlock_irq(&xas);\n\t\treturn -EAGAIN;\n\t}\n\n\t/*\n\t * Now we know that no one else is looking at the page:\n\t * no turning back from here.\n\t */\n\tnewpage->index = page->index;\n\tnewpage->mapping = page->mapping;\n\tpage_ref_add(newpage, hpage_nr_pages(page)); /* add cache reference */\n\tif (PageSwapBacked(page)) {\n\t\t__SetPageSwapBacked(newpage);\n\t\tif (PageSwapCache(page)) {\n\t\t\tSetPageSwapCache(newpage);\n\t\t\tset_page_private(newpage, page_private(page));\n\t\t}\n\t} else {\n\t\tVM_BUG_ON_PAGE(PageSwapCache(page), page);\n\t}\n\n\t/* Move dirty while page refs frozen and newpage not yet exposed */\n\tdirty = PageDirty(page);\n\tif (dirty) {\n\t\tClearPageDirty(page);\n\t\tSetPageDirty(newpage);\n\t}\n\n\txas_store(&xas, newpage);\n\tif (PageTransHuge(page)) {\n\t\tint i;\n\n\t\tfor (i = 1; i < HPAGE_PMD_NR; i++) {\n\t\t\txas_next(&xas);\n\t\t\txas_store(&xas, newpage + i);\n\t\t}\n\t}\n\n\t/*\n\t * Drop cache reference from old page by unfreezing\n\t * to one less reference.\n\t * We know this isn't the last reference.\n\t */\n\tpage_ref_unfreeze(page, expected_count - hpage_nr_pages(page));\n\n\txas_unlock(&xas);\n\t/* Leave irq disabled to prevent preemption while updating stats */\n\n\t/*\n\t * If moved to a different zone then also account\n\t * the page for that zone. Other VM counters will be\n\t * taken care of when we establish references to the\n\t * new page and drop references to the old page.\n\t *\n\t * Note that anonymous pages are accounted for\n\t * via NR_FILE_PAGES and NR_ANON_MAPPED if they\n\t * are mapped to swap space.\n\t */\n\tif (newzone != oldzone) {\n\t\t__dec_node_state(oldzone->zone_pgdat, NR_FILE_PAGES);\n\t\t__inc_node_state(newzone->zone_pgdat, NR_FILE_PAGES);\n\t\tif (PageSwapBacked(page) && !PageSwapCache(page)) {\n\t\t\t__dec_node_state(oldzone->zone_pgdat, NR_SHMEM);\n\t\t\t__inc_node_state(newzone->zone_pgdat, NR_SHMEM);\n\t\t}\n\t\tif (dirty && mapping_cap_account_dirty(mapping)) {\n\t\t\t__dec_node_state(oldzone->zone_pgdat, NR_FILE_DIRTY);\n\t\t\t__dec_zone_state(oldzone, NR_ZONE_WRITE_PENDING);\n\t\t\t__inc_node_state(newzone->zone_pgdat, NR_FILE_DIRTY);\n\t\t\t__inc_zone_state(newzone, NR_ZONE_WRITE_PENDING);\n\t\t}\n\t}\n\tlocal_irq_enable();\n\n\treturn MIGRATEPAGE_SUCCESS;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nint migrate_page_move_mapping(struct address_space *mapping,\n\t\tstruct page *newpage, struct page *page,\n\t\tstruct buffer_head *head, enum migrate_mode mode,\n\t\tint extra_count)\n{\n\tXA_STATE(xas, &mapping->i_pages, page_index(page));\n\tstruct zone *oldzone, *newzone;\n\tint dirty;\n\tint expected_count = 1 + extra_count;\n\n\t/*\n\t * Device public or private pages have an extra refcount as they are\n\t * ZONE_DEVICE pages.\n\t */\n\texpected_count += is_device_private_page(page);\n\texpected_count += is_device_public_page(page);\n\n\tif (!mapping) {\n\t\t/* Anonymous page without mapping */\n\t\tif (page_count(page) != expected_count)\n\t\t\treturn -EAGAIN;\n\n\t\t/* No turning back from here */\n\t\tnewpage->index = page->index;\n\t\tnewpage->mapping = page->mapping;\n\t\tif (PageSwapBacked(page))\n\t\t\t__SetPageSwapBacked(newpage);\n\n\t\treturn MIGRATEPAGE_SUCCESS;\n\t}\n\n\toldzone = page_zone(page);\n\tnewzone = page_zone(newpage);\n\n\txas_lock_irq(&xas);\n\n\texpected_count += hpage_nr_pages(page) + page_has_private(page);\n\tif (page_count(page) != expected_count || xas_load(&xas) != page) {\n\t\txas_unlock_irq(&xas);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!page_ref_freeze(page, expected_count)) {\n\t\txas_unlock_irq(&xas);\n\t\treturn -EAGAIN;\n\t}\n\n\t/*\n\t * In the async migration case of moving a page with buffers, lock the\n\t * buffers using trylock before the mapping is moved. If the mapping\n\t * was moved, we later failed to lock the buffers and could not move\n\t * the mapping back due to an elevated page count, we would have to\n\t * block waiting on other references to be dropped.\n\t */\n\tif (mode == MIGRATE_ASYNC && head &&\n\t\t\t!buffer_migrate_lock_buffers(head, mode)) {\n\t\tpage_ref_unfreeze(page, expected_count);\n\t\txas_unlock_irq(&xas);\n\t\treturn -EAGAIN;\n\t}\n\n\t/*\n\t * Now we know that no one else is looking at the page:\n\t * no turning back from here.\n\t */\n\tnewpage->index = page->index;\n\tnewpage->mapping = page->mapping;\n\tpage_ref_add(newpage, hpage_nr_pages(page)); /* add cache reference */\n\tif (PageSwapBacked(page)) {\n\t\t__SetPageSwapBacked(newpage);\n\t\tif (PageSwapCache(page)) {\n\t\t\tSetPageSwapCache(newpage);\n\t\t\tset_page_private(newpage, page_private(page));\n\t\t}\n\t} else {\n\t\tVM_BUG_ON_PAGE(PageSwapCache(page), page);\n\t}\n\n\t/* Move dirty while page refs frozen and newpage not yet exposed */\n\tdirty = PageDirty(page);\n\tif (dirty) {\n\t\tClearPageDirty(page);\n\t\tSetPageDirty(newpage);\n\t}\n\n\txas_store(&xas, newpage);\n\tif (PageTransHuge(page)) {\n\t\tint i;\n\n\t\tfor (i = 1; i < HPAGE_PMD_NR; i++) {\n\t\t\txas_next(&xas);\n\t\t\txas_store(&xas, newpage + i);\n\t\t}\n\t}\n\n\t/*\n\t * Drop cache reference from old page by unfreezing\n\t * to one less reference.\n\t * We know this isn't the last reference.\n\t */\n\tpage_ref_unfreeze(page, expected_count - hpage_nr_pages(page));\n\n\txas_unlock(&xas);\n\t/* Leave irq disabled to prevent preemption while updating stats */\n\n\t/*\n\t * If moved to a different zone then also account\n\t * the page for that zone. Other VM counters will be\n\t * taken care of when we establish references to the\n\t * new page and drop references to the old page.\n\t *\n\t * Note that anonymous pages are accounted for\n\t * via NR_FILE_PAGES and NR_ANON_MAPPED if they\n\t * are mapped to swap space.\n\t */\n\tif (newzone != oldzone) {\n\t\t__dec_node_state(oldzone->zone_pgdat, NR_FILE_PAGES);\n\t\t__inc_node_state(newzone->zone_pgdat, NR_FILE_PAGES);\n\t\tif (PageSwapBacked(page) && !PageSwapCache(page)) {\n\t\t\t__dec_node_state(oldzone->zone_pgdat, NR_SHMEM);\n\t\t\t__inc_node_state(newzone->zone_pgdat, NR_SHMEM);\n\t\t}\n\t\tif (dirty && mapping_cap_account_dirty(mapping)) {\n\t\t\t__dec_node_state(oldzone->zone_pgdat, NR_FILE_DIRTY);\n\t\t\t__dec_zone_state(oldzone, NR_ZONE_WRITE_PENDING);\n\t\t\t__inc_node_state(newzone->zone_pgdat, NR_FILE_DIRTY);\n\t\t\t__inc_zone_state(newzone, NR_ZONE_WRITE_PENDING);\n\t\t}\n\t}\n\tlocal_irq_enable();\n\n\treturn MIGRATEPAGE_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "PageWriteback(page)"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nint migrate_page(struct address_space *mapping,\n\t\tstruct page *newpage, struct page *page,\n\t\tenum migrate_mode mode)\n{\n\tint rc;\n\n\tBUG_ON(PageWriteback(page));\t/* Writeback must be complete */\n\n\trc = migrate_page_move_mapping(mapping, newpage, page, NULL, mode, 0);\n\n\tif (rc != MIGRATEPAGE_SUCCESS)\n\t\treturn rc;\n\n\tif (mode != MIGRATE_SYNC_NO_COPY)\n\t\tmigrate_page_copy(newpage, page);\n\telse\n\t\tmigrate_page_states(newpage, page);\n\treturn MIGRATEPAGE_SUCCESS;\n}"
  },
  {
    "function_name": "migrate_page_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "722-730",
    "snippet": "void migrate_page_copy(struct page *newpage, struct page *page)\n{\n\tif (PageHuge(page) || PageTransHuge(page))\n\t\tcopy_huge_page(newpage, page);\n\telse\n\t\tcopy_highpage(newpage, page);\n\n\tmigrate_page_states(newpage, page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "migrate_page_states",
          "args": [
            "newpage",
            "page"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_page_states",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "661-719",
          "snippet": "void migrate_page_states(struct page *newpage, struct page *page)\n{\n\tint cpupid;\n\n\tif (PageError(page))\n\t\tSetPageError(newpage);\n\tif (PageReferenced(page))\n\t\tSetPageReferenced(newpage);\n\tif (PageUptodate(page))\n\t\tSetPageUptodate(newpage);\n\tif (TestClearPageActive(page)) {\n\t\tVM_BUG_ON_PAGE(PageUnevictable(page), page);\n\t\tSetPageActive(newpage);\n\t} else if (TestClearPageUnevictable(page))\n\t\tSetPageUnevictable(newpage);\n\tif (PageWorkingset(page))\n\t\tSetPageWorkingset(newpage);\n\tif (PageChecked(page))\n\t\tSetPageChecked(newpage);\n\tif (PageMappedToDisk(page))\n\t\tSetPageMappedToDisk(newpage);\n\n\t/* Move dirty on pages not done by migrate_page_move_mapping() */\n\tif (PageDirty(page))\n\t\tSetPageDirty(newpage);\n\n\tif (page_is_young(page))\n\t\tset_page_young(newpage);\n\tif (page_is_idle(page))\n\t\tset_page_idle(newpage);\n\n\t/*\n\t * Copy NUMA information to the new page, to prevent over-eager\n\t * future migrations of this same page.\n\t */\n\tcpupid = page_cpupid_xchg_last(page, -1);\n\tpage_cpupid_xchg_last(newpage, cpupid);\n\n\tksm_migrate_page(newpage, page);\n\t/*\n\t * Please do not reorder this without considering how mm/ksm.c's\n\t * get_ksm_page() depends upon ksm_migrate_page() and PageSwapCache().\n\t */\n\tif (PageSwapCache(page))\n\t\tClearPageSwapCache(page);\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\n\t/*\n\t * If any waiters have accumulated on the new page then\n\t * wake them up.\n\t */\n\tif (PageWriteback(newpage))\n\t\tend_page_writeback(newpage);\n\n\tcopy_page_owner(page, newpage);\n\n\tmem_cgroup_migrate(page, newpage);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nvoid migrate_page_states(struct page *newpage, struct page *page)\n{\n\tint cpupid;\n\n\tif (PageError(page))\n\t\tSetPageError(newpage);\n\tif (PageReferenced(page))\n\t\tSetPageReferenced(newpage);\n\tif (PageUptodate(page))\n\t\tSetPageUptodate(newpage);\n\tif (TestClearPageActive(page)) {\n\t\tVM_BUG_ON_PAGE(PageUnevictable(page), page);\n\t\tSetPageActive(newpage);\n\t} else if (TestClearPageUnevictable(page))\n\t\tSetPageUnevictable(newpage);\n\tif (PageWorkingset(page))\n\t\tSetPageWorkingset(newpage);\n\tif (PageChecked(page))\n\t\tSetPageChecked(newpage);\n\tif (PageMappedToDisk(page))\n\t\tSetPageMappedToDisk(newpage);\n\n\t/* Move dirty on pages not done by migrate_page_move_mapping() */\n\tif (PageDirty(page))\n\t\tSetPageDirty(newpage);\n\n\tif (page_is_young(page))\n\t\tset_page_young(newpage);\n\tif (page_is_idle(page))\n\t\tset_page_idle(newpage);\n\n\t/*\n\t * Copy NUMA information to the new page, to prevent over-eager\n\t * future migrations of this same page.\n\t */\n\tcpupid = page_cpupid_xchg_last(page, -1);\n\tpage_cpupid_xchg_last(newpage, cpupid);\n\n\tksm_migrate_page(newpage, page);\n\t/*\n\t * Please do not reorder this without considering how mm/ksm.c's\n\t * get_ksm_page() depends upon ksm_migrate_page() and PageSwapCache().\n\t */\n\tif (PageSwapCache(page))\n\t\tClearPageSwapCache(page);\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\n\t/*\n\t * If any waiters have accumulated on the new page then\n\t * wake them up.\n\t */\n\tif (PageWriteback(newpage))\n\t\tend_page_writeback(newpage);\n\n\tcopy_page_owner(page, newpage);\n\n\tmem_cgroup_migrate(page, newpage);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_highpage",
          "args": [
            "newpage",
            "page"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_huge_page",
          "args": [
            "newpage",
            "page"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "copy_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "632-656",
          "snippet": "static void copy_huge_page(struct page *dst, struct page *src)\n{\n\tint i;\n\tint nr_pages;\n\n\tif (PageHuge(src)) {\n\t\t/* hugetlbfs page */\n\t\tstruct hstate *h = page_hstate(src);\n\t\tnr_pages = pages_per_huge_page(h);\n\n\t\tif (unlikely(nr_pages > MAX_ORDER_NR_PAGES)) {\n\t\t\t__copy_gigantic_page(dst, src, nr_pages);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\t/* thp page */\n\t\tBUG_ON(!PageTransHuge(src));\n\t\tnr_pages = hpage_nr_pages(src);\n\t}\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tcond_resched();\n\t\tcopy_highpage(dst + i, src + i);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic void copy_huge_page(struct page *dst, struct page *src)\n{\n\tint i;\n\tint nr_pages;\n\n\tif (PageHuge(src)) {\n\t\t/* hugetlbfs page */\n\t\tstruct hstate *h = page_hstate(src);\n\t\tnr_pages = pages_per_huge_page(h);\n\n\t\tif (unlikely(nr_pages > MAX_ORDER_NR_PAGES)) {\n\t\t\t__copy_gigantic_page(dst, src, nr_pages);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\t/* thp page */\n\t\tBUG_ON(!PageTransHuge(src));\n\t\tnr_pages = hpage_nr_pages(src);\n\t}\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tcond_resched();\n\t\tcopy_highpage(dst + i, src + i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "page"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "page"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "PageHugeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "225-228",
          "snippet": "static int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nvoid migrate_page_copy(struct page *newpage, struct page *page)\n{\n\tif (PageHuge(page) || PageTransHuge(page))\n\t\tcopy_huge_page(newpage, page);\n\telse\n\t\tcopy_highpage(newpage, page);\n\n\tmigrate_page_states(newpage, page);\n}"
  },
  {
    "function_name": "migrate_page_states",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "661-719",
    "snippet": "void migrate_page_states(struct page *newpage, struct page *page)\n{\n\tint cpupid;\n\n\tif (PageError(page))\n\t\tSetPageError(newpage);\n\tif (PageReferenced(page))\n\t\tSetPageReferenced(newpage);\n\tif (PageUptodate(page))\n\t\tSetPageUptodate(newpage);\n\tif (TestClearPageActive(page)) {\n\t\tVM_BUG_ON_PAGE(PageUnevictable(page), page);\n\t\tSetPageActive(newpage);\n\t} else if (TestClearPageUnevictable(page))\n\t\tSetPageUnevictable(newpage);\n\tif (PageWorkingset(page))\n\t\tSetPageWorkingset(newpage);\n\tif (PageChecked(page))\n\t\tSetPageChecked(newpage);\n\tif (PageMappedToDisk(page))\n\t\tSetPageMappedToDisk(newpage);\n\n\t/* Move dirty on pages not done by migrate_page_move_mapping() */\n\tif (PageDirty(page))\n\t\tSetPageDirty(newpage);\n\n\tif (page_is_young(page))\n\t\tset_page_young(newpage);\n\tif (page_is_idle(page))\n\t\tset_page_idle(newpage);\n\n\t/*\n\t * Copy NUMA information to the new page, to prevent over-eager\n\t * future migrations of this same page.\n\t */\n\tcpupid = page_cpupid_xchg_last(page, -1);\n\tpage_cpupid_xchg_last(newpage, cpupid);\n\n\tksm_migrate_page(newpage, page);\n\t/*\n\t * Please do not reorder this without considering how mm/ksm.c's\n\t * get_ksm_page() depends upon ksm_migrate_page() and PageSwapCache().\n\t */\n\tif (PageSwapCache(page))\n\t\tClearPageSwapCache(page);\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\n\t/*\n\t * If any waiters have accumulated on the new page then\n\t * wake them up.\n\t */\n\tif (PageWriteback(newpage))\n\t\tend_page_writeback(newpage);\n\n\tcopy_page_owner(page, newpage);\n\n\tmem_cgroup_migrate(page, newpage);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cgroup_migrate",
          "args": [
            "page",
            "newpage"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_migrate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "6155-6195",
          "snippet": "void mem_cgroup_migrate(struct page *oldpage, struct page *newpage)\n{\n\tstruct mem_cgroup *memcg;\n\tunsigned int nr_pages;\n\tbool compound;\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(!PageLocked(oldpage), oldpage);\n\tVM_BUG_ON_PAGE(!PageLocked(newpage), newpage);\n\tVM_BUG_ON_PAGE(PageAnon(oldpage) != PageAnon(newpage), newpage);\n\tVM_BUG_ON_PAGE(PageTransHuge(oldpage) != PageTransHuge(newpage),\n\t\t       newpage);\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\t/* Page cache replacement: new page already charged? */\n\tif (newpage->mem_cgroup)\n\t\treturn;\n\n\t/* Swapcache readahead pages can get replaced before being charged */\n\tmemcg = oldpage->mem_cgroup;\n\tif (!memcg)\n\t\treturn;\n\n\t/* Force-charge the new page. The old one will be freed soon */\n\tcompound = PageTransHuge(newpage);\n\tnr_pages = compound ? hpage_nr_pages(newpage) : 1;\n\n\tpage_counter_charge(&memcg->memory, nr_pages);\n\tif (do_memsw_account())\n\t\tpage_counter_charge(&memcg->memsw, nr_pages);\n\tcss_get_many(&memcg->css, nr_pages);\n\n\tcommit_charge(newpage, memcg, false);\n\n\tlocal_irq_save(flags);\n\tmem_cgroup_charge_statistics(memcg, newpage, compound, nr_pages);\n\tmemcg_check_events(memcg, newpage);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid mem_cgroup_migrate(struct page *oldpage, struct page *newpage)\n{\n\tstruct mem_cgroup *memcg;\n\tunsigned int nr_pages;\n\tbool compound;\n\tunsigned long flags;\n\n\tVM_BUG_ON_PAGE(!PageLocked(oldpage), oldpage);\n\tVM_BUG_ON_PAGE(!PageLocked(newpage), newpage);\n\tVM_BUG_ON_PAGE(PageAnon(oldpage) != PageAnon(newpage), newpage);\n\tVM_BUG_ON_PAGE(PageTransHuge(oldpage) != PageTransHuge(newpage),\n\t\t       newpage);\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\t/* Page cache replacement: new page already charged? */\n\tif (newpage->mem_cgroup)\n\t\treturn;\n\n\t/* Swapcache readahead pages can get replaced before being charged */\n\tmemcg = oldpage->mem_cgroup;\n\tif (!memcg)\n\t\treturn;\n\n\t/* Force-charge the new page. The old one will be freed soon */\n\tcompound = PageTransHuge(newpage);\n\tnr_pages = compound ? hpage_nr_pages(newpage) : 1;\n\n\tpage_counter_charge(&memcg->memory, nr_pages);\n\tif (do_memsw_account())\n\t\tpage_counter_charge(&memcg->memsw, nr_pages);\n\tcss_get_many(&memcg->css, nr_pages);\n\n\tcommit_charge(newpage, memcg, false);\n\n\tlocal_irq_save(flags);\n\tmem_cgroup_charge_statistics(memcg, newpage, compound, nr_pages);\n\tmemcg_check_events(memcg, newpage);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_page_owner",
          "args": [
            "page",
            "newpage"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "__copy_page_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
          "lines": "226-253",
          "snippet": "void __copy_page_owner(struct page *oldpage, struct page *newpage)\n{\n\tstruct page_ext *old_ext = lookup_page_ext(oldpage);\n\tstruct page_ext *new_ext = lookup_page_ext(newpage);\n\tstruct page_owner *old_page_owner, *new_page_owner;\n\n\tif (unlikely(!old_ext || !new_ext))\n\t\treturn;\n\n\told_page_owner = get_page_owner(old_ext);\n\tnew_page_owner = get_page_owner(new_ext);\n\tnew_page_owner->order = old_page_owner->order;\n\tnew_page_owner->gfp_mask = old_page_owner->gfp_mask;\n\tnew_page_owner->last_migrate_reason =\n\t\told_page_owner->last_migrate_reason;\n\tnew_page_owner->handle = old_page_owner->handle;\n\n\t/*\n\t * We don't clear the bit on the oldpage as it's going to be freed\n\t * after migration. Until then, the info can be useful in case of\n\t * a bug, and the overal stats will be off a bit only temporarily.\n\t * Also, migrate_misplaced_transhuge_page() can still fail the\n\t * migration and then we want the oldpage to retain the info. But\n\t * in that case we also don't need to explicitly clear the info from\n\t * the new page, which will be freed.\n\t */\n\t__set_bit(PAGE_EXT_OWNER, &new_ext->flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/stackdepot.h>",
            "#include <linux/migrate.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nvoid __copy_page_owner(struct page *oldpage, struct page *newpage)\n{\n\tstruct page_ext *old_ext = lookup_page_ext(oldpage);\n\tstruct page_ext *new_ext = lookup_page_ext(newpage);\n\tstruct page_owner *old_page_owner, *new_page_owner;\n\n\tif (unlikely(!old_ext || !new_ext))\n\t\treturn;\n\n\told_page_owner = get_page_owner(old_ext);\n\tnew_page_owner = get_page_owner(new_ext);\n\tnew_page_owner->order = old_page_owner->order;\n\tnew_page_owner->gfp_mask = old_page_owner->gfp_mask;\n\tnew_page_owner->last_migrate_reason =\n\t\told_page_owner->last_migrate_reason;\n\tnew_page_owner->handle = old_page_owner->handle;\n\n\t/*\n\t * We don't clear the bit on the oldpage as it's going to be freed\n\t * after migration. Until then, the info can be useful in case of\n\t * a bug, and the overal stats will be off a bit only temporarily.\n\t * Also, migrate_misplaced_transhuge_page() can still fail the\n\t * migration and then we want the oldpage to retain the info. But\n\t * in that case we also don't need to explicitly clear the info from\n\t * the new page, which will be freed.\n\t */\n\t__set_bit(PAGE_EXT_OWNER, &new_ext->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "newpage"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1209-1228",
          "snippet": "void end_page_writeback(struct page *page)\n{\n\t/*\n\t * TestClearPageReclaim could be used here but it is an atomic\n\t * operation and overkill in this particular case. Failing to\n\t * shuffle a page marked for immediate reclaim is too mild to\n\t * justify taking an atomic operation penalty at the end of\n\t * ever page writeback.\n\t */\n\tif (PageReclaim(page)) {\n\t\tClearPageReclaim(page);\n\t\trotate_reclaimable_page(page);\n\t}\n\n\tif (!test_clear_page_writeback(page))\n\t\tBUG();\n\n\tsmp_mb__after_atomic();\n\twake_up_page(page, PG_writeback);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nvoid end_page_writeback(struct page *page)\n{\n\t/*\n\t * TestClearPageReclaim could be used here but it is an atomic\n\t * operation and overkill in this particular case. Failing to\n\t * shuffle a page marked for immediate reclaim is too mild to\n\t * justify taking an atomic operation penalty at the end of\n\t * ever page writeback.\n\t */\n\tif (PageReclaim(page)) {\n\t\tClearPageReclaim(page);\n\t\trotate_reclaimable_page(page);\n\t}\n\n\tif (!test_clear_page_writeback(page))\n\t\tBUG();\n\n\tsmp_mb__after_atomic();\n\twake_up_page(page, PG_writeback);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "newpage"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "0"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPagePrivate",
          "args": [
            "page"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageSwapCache",
          "args": [
            "page"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ksm_migrate_page",
          "args": [
            "newpage",
            "page"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "ksm_migrate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "2644-2665",
          "snippet": "void ksm_migrate_page(struct page *newpage, struct page *oldpage)\n{\n\tstruct stable_node *stable_node;\n\n\tVM_BUG_ON_PAGE(!PageLocked(oldpage), oldpage);\n\tVM_BUG_ON_PAGE(!PageLocked(newpage), newpage);\n\tVM_BUG_ON_PAGE(newpage->mapping != oldpage->mapping, newpage);\n\n\tstable_node = page_stable_node(newpage);\n\tif (stable_node) {\n\t\tVM_BUG_ON_PAGE(stable_node->kpfn != page_to_pfn(oldpage), oldpage);\n\t\tstable_node->kpfn = page_to_pfn(newpage);\n\t\t/*\n\t\t * newpage->mapping was set in advance; now we need smp_wmb()\n\t\t * to make sure that the new stable_node->kpfn is visible\n\t\t * to get_ksm_page() before it can see that oldpage->mapping\n\t\t * has gone stale (or that PageSwapCache has been cleared).\n\t\t */\n\t\tsmp_wmb();\n\t\tset_page_stable_node(oldpage, NULL);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nvoid ksm_migrate_page(struct page *newpage, struct page *oldpage)\n{\n\tstruct stable_node *stable_node;\n\n\tVM_BUG_ON_PAGE(!PageLocked(oldpage), oldpage);\n\tVM_BUG_ON_PAGE(!PageLocked(newpage), newpage);\n\tVM_BUG_ON_PAGE(newpage->mapping != oldpage->mapping, newpage);\n\n\tstable_node = page_stable_node(newpage);\n\tif (stable_node) {\n\t\tVM_BUG_ON_PAGE(stable_node->kpfn != page_to_pfn(oldpage), oldpage);\n\t\tstable_node->kpfn = page_to_pfn(newpage);\n\t\t/*\n\t\t * newpage->mapping was set in advance; now we need smp_wmb()\n\t\t * to make sure that the new stable_node->kpfn is visible\n\t\t * to get_ksm_page() before it can see that oldpage->mapping\n\t\t * has gone stale (or that PageSwapCache has been cleared).\n\t\t */\n\t\tsmp_wmb();\n\t\tset_page_stable_node(oldpage, NULL);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cpupid_xchg_last",
          "args": [
            "newpage",
            "cpupid"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "page_cpupid_xchg_last",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmzone.c",
          "lines": "100-114",
          "snippet": "int page_cpupid_xchg_last(struct page *page, int cpupid)\n{\n\tunsigned long old_flags, flags;\n\tint last_cpupid;\n\n\tdo {\n\t\told_flags = flags = page->flags;\n\t\tlast_cpupid = page_cpupid_last(page);\n\n\t\tflags &= ~(LAST_CPUPID_MASK << LAST_CPUPID_PGSHIFT);\n\t\tflags |= (cpupid & LAST_CPUPID_MASK) << LAST_CPUPID_PGSHIFT;\n\t} while (unlikely(cmpxchg(&page->flags, old_flags, flags) != old_flags));\n\n\treturn last_cpupid;\n}",
          "includes": [
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint page_cpupid_xchg_last(struct page *page, int cpupid)\n{\n\tunsigned long old_flags, flags;\n\tint last_cpupid;\n\n\tdo {\n\t\told_flags = flags = page->flags;\n\t\tlast_cpupid = page_cpupid_last(page);\n\n\t\tflags &= ~(LAST_CPUPID_MASK << LAST_CPUPID_PGSHIFT);\n\t\tflags |= (cpupid & LAST_CPUPID_MASK) << LAST_CPUPID_PGSHIFT;\n\t} while (unlikely(cmpxchg(&page->flags, old_flags, flags) != old_flags));\n\n\treturn last_cpupid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_idle",
          "args": [
            "newpage"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_is_idle",
          "args": [
            "page"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_young",
          "args": [
            "newpage"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_is_young",
          "args": [
            "page"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageDirty",
          "args": [
            "newpage"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageMappedToDisk",
          "args": [
            "newpage"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageMappedToDisk",
          "args": [
            "page"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageChecked",
          "args": [
            "newpage"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageChecked",
          "args": [
            "page"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageWorkingset",
          "args": [
            "newpage"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWorkingset",
          "args": [
            "page"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUnevictable",
          "args": [
            "newpage"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestClearPageUnevictable",
          "args": [
            "page"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageActive",
          "args": [
            "newpage"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageUnevictable(page)",
            "page"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUnevictable",
          "args": [
            "page"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestClearPageActive",
          "args": [
            "page"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "newpage"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageReferenced",
          "args": [
            "newpage"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageReferenced",
          "args": [
            "page"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "newpage"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageError",
          "args": [
            "page"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nvoid migrate_page_states(struct page *newpage, struct page *page)\n{\n\tint cpupid;\n\n\tif (PageError(page))\n\t\tSetPageError(newpage);\n\tif (PageReferenced(page))\n\t\tSetPageReferenced(newpage);\n\tif (PageUptodate(page))\n\t\tSetPageUptodate(newpage);\n\tif (TestClearPageActive(page)) {\n\t\tVM_BUG_ON_PAGE(PageUnevictable(page), page);\n\t\tSetPageActive(newpage);\n\t} else if (TestClearPageUnevictable(page))\n\t\tSetPageUnevictable(newpage);\n\tif (PageWorkingset(page))\n\t\tSetPageWorkingset(newpage);\n\tif (PageChecked(page))\n\t\tSetPageChecked(newpage);\n\tif (PageMappedToDisk(page))\n\t\tSetPageMappedToDisk(newpage);\n\n\t/* Move dirty on pages not done by migrate_page_move_mapping() */\n\tif (PageDirty(page))\n\t\tSetPageDirty(newpage);\n\n\tif (page_is_young(page))\n\t\tset_page_young(newpage);\n\tif (page_is_idle(page))\n\t\tset_page_idle(newpage);\n\n\t/*\n\t * Copy NUMA information to the new page, to prevent over-eager\n\t * future migrations of this same page.\n\t */\n\tcpupid = page_cpupid_xchg_last(page, -1);\n\tpage_cpupid_xchg_last(newpage, cpupid);\n\n\tksm_migrate_page(newpage, page);\n\t/*\n\t * Please do not reorder this without considering how mm/ksm.c's\n\t * get_ksm_page() depends upon ksm_migrate_page() and PageSwapCache().\n\t */\n\tif (PageSwapCache(page))\n\t\tClearPageSwapCache(page);\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\n\t/*\n\t * If any waiters have accumulated on the new page then\n\t * wake them up.\n\t */\n\tif (PageWriteback(newpage))\n\t\tend_page_writeback(newpage);\n\n\tcopy_page_owner(page, newpage);\n\n\tmem_cgroup_migrate(page, newpage);\n}"
  },
  {
    "function_name": "copy_huge_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "632-656",
    "snippet": "static void copy_huge_page(struct page *dst, struct page *src)\n{\n\tint i;\n\tint nr_pages;\n\n\tif (PageHuge(src)) {\n\t\t/* hugetlbfs page */\n\t\tstruct hstate *h = page_hstate(src);\n\t\tnr_pages = pages_per_huge_page(h);\n\n\t\tif (unlikely(nr_pages > MAX_ORDER_NR_PAGES)) {\n\t\t\t__copy_gigantic_page(dst, src, nr_pages);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\t/* thp page */\n\t\tBUG_ON(!PageTransHuge(src));\n\t\tnr_pages = hpage_nr_pages(src);\n\t}\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tcond_resched();\n\t\tcopy_highpage(dst + i, src + i);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_highpage",
          "args": [
            "dst + i",
            "src + i"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "src"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageTransHuge(src)"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "src"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_gigantic_page",
          "args": [
            "dst",
            "src",
            "nr_pages"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "__copy_gigantic_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "615-630",
          "snippet": "static void __copy_gigantic_page(struct page *dst, struct page *src,\n\t\t\t\tint nr_pages)\n{\n\tint i;\n\tstruct page *dst_base = dst;\n\tstruct page *src_base = src;\n\n\tfor (i = 0; i < nr_pages; ) {\n\t\tcond_resched();\n\t\tcopy_highpage(dst, src);\n\n\t\ti++;\n\t\tdst = mem_map_next(dst, dst_base, i);\n\t\tsrc = mem_map_next(src, src_base, i);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic void __copy_gigantic_page(struct page *dst, struct page *src,\n\t\t\t\tint nr_pages)\n{\n\tint i;\n\tstruct page *dst_base = dst;\n\tstruct page *src_base = src;\n\n\tfor (i = 0; i < nr_pages; ) {\n\t\tcond_resched();\n\t\tcopy_highpage(dst, src);\n\n\t\ti++;\n\t\tdst = mem_map_next(dst, dst_base, i);\n\t\tsrc = mem_map_next(src, src_base, i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "nr_pages > MAX_ORDER_NR_PAGES"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pages_per_huge_page",
          "args": [
            "h"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_hstate",
          "args": [
            "src"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "src"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "PageHugeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "225-228",
          "snippet": "static int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic void copy_huge_page(struct page *dst, struct page *src)\n{\n\tint i;\n\tint nr_pages;\n\n\tif (PageHuge(src)) {\n\t\t/* hugetlbfs page */\n\t\tstruct hstate *h = page_hstate(src);\n\t\tnr_pages = pages_per_huge_page(h);\n\n\t\tif (unlikely(nr_pages > MAX_ORDER_NR_PAGES)) {\n\t\t\t__copy_gigantic_page(dst, src, nr_pages);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\t/* thp page */\n\t\tBUG_ON(!PageTransHuge(src));\n\t\tnr_pages = hpage_nr_pages(src);\n\t}\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tcond_resched();\n\t\tcopy_highpage(dst + i, src + i);\n\t}\n}"
  },
  {
    "function_name": "__copy_gigantic_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "615-630",
    "snippet": "static void __copy_gigantic_page(struct page *dst, struct page *src,\n\t\t\t\tint nr_pages)\n{\n\tint i;\n\tstruct page *dst_base = dst;\n\tstruct page *src_base = src;\n\n\tfor (i = 0; i < nr_pages; ) {\n\t\tcond_resched();\n\t\tcopy_highpage(dst, src);\n\n\t\ti++;\n\t\tdst = mem_map_next(dst, dst_base, i);\n\t\tsrc = mem_map_next(src, src_base, i);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_map_next",
          "args": [
            "src",
            "src_base",
            "i"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "mem_map_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "380-390",
          "snippet": "static inline struct page *mem_map_next(struct page *iter,\n\t\t\t\t\t\tstruct page *base, int offset)\n{\n\tif (unlikely((offset & (MAX_ORDER_NR_PAGES - 1)) == 0)) {\n\t\tunsigned long pfn = page_to_pfn(base) + offset;\n\t\tif (!pfn_valid(pfn))\n\t\t\treturn NULL;\n\t\treturn pfn_to_page(pfn);\n\t}\n\treturn iter + 1;\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline struct page *mem_map_next(struct page *iter,\n\t\t\t\t\t\tstruct page *base, int offset)\n{\n\tif (unlikely((offset & (MAX_ORDER_NR_PAGES - 1)) == 0)) {\n\t\tunsigned long pfn = page_to_pfn(base) + offset;\n\t\tif (!pfn_valid(pfn))\n\t\t\treturn NULL;\n\t\treturn pfn_to_page(pfn);\n\t}\n\treturn iter + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_highpage",
          "args": [
            "dst",
            "src"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic void __copy_gigantic_page(struct page *dst, struct page *src,\n\t\t\t\tint nr_pages)\n{\n\tint i;\n\tstruct page *dst_base = dst;\n\tstruct page *src_base = src;\n\n\tfor (i = 0; i < nr_pages; ) {\n\t\tcond_resched();\n\t\tcopy_highpage(dst, src);\n\n\t\ti++;\n\t\tdst = mem_map_next(dst, dst_base, i);\n\t\tsrc = mem_map_next(src, src_base, i);\n\t}\n}"
  },
  {
    "function_name": "migrate_huge_page_move_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "578-608",
    "snippet": "int migrate_huge_page_move_mapping(struct address_space *mapping,\n\t\t\t\t   struct page *newpage, struct page *page)\n{\n\tXA_STATE(xas, &mapping->i_pages, page_index(page));\n\tint expected_count;\n\n\txas_lock_irq(&xas);\n\texpected_count = 2 + page_has_private(page);\n\tif (page_count(page) != expected_count || xas_load(&xas) != page) {\n\t\txas_unlock_irq(&xas);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!page_ref_freeze(page, expected_count)) {\n\t\txas_unlock_irq(&xas);\n\t\treturn -EAGAIN;\n\t}\n\n\tnewpage->index = page->index;\n\tnewpage->mapping = page->mapping;\n\n\tget_page(newpage);\n\n\txas_store(&xas, newpage);\n\n\tpage_ref_unfreeze(page, expected_count - 1);\n\n\txas_unlock_irq(&xas);\n\n\treturn MIGRATEPAGE_SUCCESS;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xas_unlock_irq",
          "args": [
            "&xas"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_ref_unfreeze",
          "args": [
            "page",
            "expected_count - 1"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "__page_ref_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/debug_page_ref.c",
          "lines": "50-53",
          "snippet": "void __page_ref_unfreeze(struct page *page, int v)\n{\n\ttrace_page_ref_unfreeze(page, v);\n}",
          "includes": [
            "#include <trace/events/page_ref.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/page_ref.h>\n#include <linux/tracepoint.h>\n#include <linux/mm_types.h>\n\nvoid __page_ref_unfreeze(struct page *page, int v)\n{\n\ttrace_page_ref_unfreeze(page, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xas_store",
          "args": [
            "&xas",
            "newpage"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "newpage"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xas_unlock_irq",
          "args": [
            "&xas"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_ref_freeze",
          "args": [
            "page",
            "expected_count"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_unlock_irq",
          "args": [
            "&xas"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_load",
          "args": [
            "&xas"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_private",
          "args": [
            "page"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_lock_irq",
          "args": [
            "&xas"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XA_STATE",
          "args": [
            "xas",
            "&mapping->i_pages",
            "page_index(page)"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_index",
          "args": [
            "page"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "__basepage_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1358-1373",
          "snippet": "pgoff_t __basepage_index(struct page *page)\n{\n\tstruct page *page_head = compound_head(page);\n\tpgoff_t index = page_index(page_head);\n\tunsigned long compound_idx;\n\n\tif (!PageHuge(page_head))\n\t\treturn page_index(page);\n\n\tif (compound_order(page_head) >= MAX_ORDER)\n\t\tcompound_idx = page_to_pfn(page) - page_to_pfn(page_head);\n\telse\n\t\tcompound_idx = page - page_head;\n\n\treturn (index << compound_order(page_head)) + compound_idx;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\npgoff_t __basepage_index(struct page *page)\n{\n\tstruct page *page_head = compound_head(page);\n\tpgoff_t index = page_index(page_head);\n\tunsigned long compound_idx;\n\n\tif (!PageHuge(page_head))\n\t\treturn page_index(page);\n\n\tif (compound_order(page_head) >= MAX_ORDER)\n\t\tcompound_idx = page_to_pfn(page) - page_to_pfn(page_head);\n\telse\n\t\tcompound_idx = page - page_head;\n\n\treturn (index << compound_order(page_head)) + compound_idx;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nint migrate_huge_page_move_mapping(struct address_space *mapping,\n\t\t\t\t   struct page *newpage, struct page *page)\n{\n\tXA_STATE(xas, &mapping->i_pages, page_index(page));\n\tint expected_count;\n\n\txas_lock_irq(&xas);\n\texpected_count = 2 + page_has_private(page);\n\tif (page_count(page) != expected_count || xas_load(&xas) != page) {\n\t\txas_unlock_irq(&xas);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!page_ref_freeze(page, expected_count)) {\n\t\txas_unlock_irq(&xas);\n\t\treturn -EAGAIN;\n\t}\n\n\tnewpage->index = page->index;\n\tnewpage->mapping = page->mapping;\n\n\tget_page(newpage);\n\n\txas_store(&xas, newpage);\n\n\tpage_ref_unfreeze(page, expected_count - 1);\n\n\txas_unlock_irq(&xas);\n\n\treturn MIGRATEPAGE_SUCCESS;\n}"
  },
  {
    "function_name": "migrate_page_move_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "439-571",
    "snippet": "int migrate_page_move_mapping(struct address_space *mapping,\n\t\tstruct page *newpage, struct page *page,\n\t\tstruct buffer_head *head, enum migrate_mode mode,\n\t\tint extra_count)\n{\n\tXA_STATE(xas, &mapping->i_pages, page_index(page));\n\tstruct zone *oldzone, *newzone;\n\tint dirty;\n\tint expected_count = 1 + extra_count;\n\n\t/*\n\t * Device public or private pages have an extra refcount as they are\n\t * ZONE_DEVICE pages.\n\t */\n\texpected_count += is_device_private_page(page);\n\texpected_count += is_device_public_page(page);\n\n\tif (!mapping) {\n\t\t/* Anonymous page without mapping */\n\t\tif (page_count(page) != expected_count)\n\t\t\treturn -EAGAIN;\n\n\t\t/* No turning back from here */\n\t\tnewpage->index = page->index;\n\t\tnewpage->mapping = page->mapping;\n\t\tif (PageSwapBacked(page))\n\t\t\t__SetPageSwapBacked(newpage);\n\n\t\treturn MIGRATEPAGE_SUCCESS;\n\t}\n\n\toldzone = page_zone(page);\n\tnewzone = page_zone(newpage);\n\n\txas_lock_irq(&xas);\n\n\texpected_count += hpage_nr_pages(page) + page_has_private(page);\n\tif (page_count(page) != expected_count || xas_load(&xas) != page) {\n\t\txas_unlock_irq(&xas);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!page_ref_freeze(page, expected_count)) {\n\t\txas_unlock_irq(&xas);\n\t\treturn -EAGAIN;\n\t}\n\n\t/*\n\t * In the async migration case of moving a page with buffers, lock the\n\t * buffers using trylock before the mapping is moved. If the mapping\n\t * was moved, we later failed to lock the buffers and could not move\n\t * the mapping back due to an elevated page count, we would have to\n\t * block waiting on other references to be dropped.\n\t */\n\tif (mode == MIGRATE_ASYNC && head &&\n\t\t\t!buffer_migrate_lock_buffers(head, mode)) {\n\t\tpage_ref_unfreeze(page, expected_count);\n\t\txas_unlock_irq(&xas);\n\t\treturn -EAGAIN;\n\t}\n\n\t/*\n\t * Now we know that no one else is looking at the page:\n\t * no turning back from here.\n\t */\n\tnewpage->index = page->index;\n\tnewpage->mapping = page->mapping;\n\tpage_ref_add(newpage, hpage_nr_pages(page)); /* add cache reference */\n\tif (PageSwapBacked(page)) {\n\t\t__SetPageSwapBacked(newpage);\n\t\tif (PageSwapCache(page)) {\n\t\t\tSetPageSwapCache(newpage);\n\t\t\tset_page_private(newpage, page_private(page));\n\t\t}\n\t} else {\n\t\tVM_BUG_ON_PAGE(PageSwapCache(page), page);\n\t}\n\n\t/* Move dirty while page refs frozen and newpage not yet exposed */\n\tdirty = PageDirty(page);\n\tif (dirty) {\n\t\tClearPageDirty(page);\n\t\tSetPageDirty(newpage);\n\t}\n\n\txas_store(&xas, newpage);\n\tif (PageTransHuge(page)) {\n\t\tint i;\n\n\t\tfor (i = 1; i < HPAGE_PMD_NR; i++) {\n\t\t\txas_next(&xas);\n\t\t\txas_store(&xas, newpage + i);\n\t\t}\n\t}\n\n\t/*\n\t * Drop cache reference from old page by unfreezing\n\t * to one less reference.\n\t * We know this isn't the last reference.\n\t */\n\tpage_ref_unfreeze(page, expected_count - hpage_nr_pages(page));\n\n\txas_unlock(&xas);\n\t/* Leave irq disabled to prevent preemption while updating stats */\n\n\t/*\n\t * If moved to a different zone then also account\n\t * the page for that zone. Other VM counters will be\n\t * taken care of when we establish references to the\n\t * new page and drop references to the old page.\n\t *\n\t * Note that anonymous pages are accounted for\n\t * via NR_FILE_PAGES and NR_ANON_MAPPED if they\n\t * are mapped to swap space.\n\t */\n\tif (newzone != oldzone) {\n\t\t__dec_node_state(oldzone->zone_pgdat, NR_FILE_PAGES);\n\t\t__inc_node_state(newzone->zone_pgdat, NR_FILE_PAGES);\n\t\tif (PageSwapBacked(page) && !PageSwapCache(page)) {\n\t\t\t__dec_node_state(oldzone->zone_pgdat, NR_SHMEM);\n\t\t\t__inc_node_state(newzone->zone_pgdat, NR_SHMEM);\n\t\t}\n\t\tif (dirty && mapping_cap_account_dirty(mapping)) {\n\t\t\t__dec_node_state(oldzone->zone_pgdat, NR_FILE_DIRTY);\n\t\t\t__dec_zone_state(oldzone, NR_ZONE_WRITE_PENDING);\n\t\t\t__inc_node_state(newzone->zone_pgdat, NR_FILE_DIRTY);\n\t\t\t__inc_zone_state(newzone, NR_ZONE_WRITE_PENDING);\n\t\t}\n\t}\n\tlocal_irq_enable();\n\n\treturn MIGRATEPAGE_SUCCESS;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__inc_zone_state",
          "args": [
            "newzone",
            "NR_ZONE_WRITE_PENDING"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "__inc_zone_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "378-392",
          "snippet": "void __inc_zone_state(struct zone *zone, enum zone_stat_item item)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\ts8 __percpu *p = pcp->vm_stat_diff + item;\n\ts8 v, t;\n\n\tv = __this_cpu_inc_return(*p);\n\tt = __this_cpu_read(pcp->stat_threshold);\n\tif (unlikely(v > t)) {\n\t\ts8 overstep = t >> 1;\n\n\t\tzone_page_state_add(v + overstep, zone, item);\n\t\t__this_cpu_write(*p, -overstep);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __inc_zone_state(struct zone *zone, enum zone_stat_item item)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\ts8 __percpu *p = pcp->vm_stat_diff + item;\n\ts8 v, t;\n\n\tv = __this_cpu_inc_return(*p);\n\tt = __this_cpu_read(pcp->stat_threshold);\n\tif (unlikely(v > t)) {\n\t\ts8 overstep = t >> 1;\n\n\t\tzone_page_state_add(v + overstep, zone, item);\n\t\t__this_cpu_write(*p, -overstep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__inc_node_state",
          "args": [
            "newzone->zone_pgdat",
            "NR_FILE_DIRTY"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "__inc_node_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "394-408",
          "snippet": "void __inc_node_state(struct pglist_data *pgdat, enum node_stat_item item)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\ts8 v, t;\n\n\tv = __this_cpu_inc_return(*p);\n\tt = __this_cpu_read(pcp->stat_threshold);\n\tif (unlikely(v > t)) {\n\t\ts8 overstep = t >> 1;\n\n\t\tnode_page_state_add(v + overstep, pgdat, item);\n\t\t__this_cpu_write(*p, -overstep);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __inc_node_state(struct pglist_data *pgdat, enum node_stat_item item)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\ts8 v, t;\n\n\tv = __this_cpu_inc_return(*p);\n\tt = __this_cpu_read(pcp->stat_threshold);\n\tif (unlikely(v > t)) {\n\t\ts8 overstep = t >> 1;\n\n\t\tnode_page_state_add(v + overstep, pgdat, item);\n\t\t__this_cpu_write(*p, -overstep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dec_zone_state",
          "args": [
            "oldzone",
            "NR_ZONE_WRITE_PENDING"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "__dec_zone_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "422-436",
          "snippet": "void __dec_zone_state(struct zone *zone, enum zone_stat_item item)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\ts8 __percpu *p = pcp->vm_stat_diff + item;\n\ts8 v, t;\n\n\tv = __this_cpu_dec_return(*p);\n\tt = __this_cpu_read(pcp->stat_threshold);\n\tif (unlikely(v < - t)) {\n\t\ts8 overstep = t >> 1;\n\n\t\tzone_page_state_add(v - overstep, zone, item);\n\t\t__this_cpu_write(*p, overstep);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __dec_zone_state(struct zone *zone, enum zone_stat_item item)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\ts8 __percpu *p = pcp->vm_stat_diff + item;\n\ts8 v, t;\n\n\tv = __this_cpu_dec_return(*p);\n\tt = __this_cpu_read(pcp->stat_threshold);\n\tif (unlikely(v < - t)) {\n\t\ts8 overstep = t >> 1;\n\n\t\tzone_page_state_add(v - overstep, zone, item);\n\t\t__this_cpu_write(*p, overstep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dec_node_state",
          "args": [
            "oldzone->zone_pgdat",
            "NR_FILE_DIRTY"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "__dec_node_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "438-452",
          "snippet": "void __dec_node_state(struct pglist_data *pgdat, enum node_stat_item item)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\ts8 v, t;\n\n\tv = __this_cpu_dec_return(*p);\n\tt = __this_cpu_read(pcp->stat_threshold);\n\tif (unlikely(v < - t)) {\n\t\ts8 overstep = t >> 1;\n\n\t\tnode_page_state_add(v - overstep, pgdat, item);\n\t\t__this_cpu_write(*p, overstep);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __dec_node_state(struct pglist_data *pgdat, enum node_stat_item item)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\ts8 v, t;\n\n\tv = __this_cpu_dec_return(*p);\n\tt = __this_cpu_read(pcp->stat_threshold);\n\tif (unlikely(v < - t)) {\n\t\ts8 overstep = t >> 1;\n\n\t\tnode_page_state_add(v - overstep, pgdat, item);\n\t\t__this_cpu_write(*p, overstep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_cap_account_dirty",
          "args": [
            "mapping"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapBacked",
          "args": [
            "page"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_unlock",
          "args": [
            "&xas"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_ref_unfreeze",
          "args": [
            "page",
            "expected_count - hpage_nr_pages(page)"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "__page_ref_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/debug_page_ref.c",
          "lines": "50-53",
          "snippet": "void __page_ref_unfreeze(struct page *page, int v)\n{\n\ttrace_page_ref_unfreeze(page, v);\n}",
          "includes": [
            "#include <trace/events/page_ref.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/page_ref.h>\n#include <linux/tracepoint.h>\n#include <linux/mm_types.h>\n\nvoid __page_ref_unfreeze(struct page *page, int v)\n{\n\ttrace_page_ref_unfreeze(page, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "page"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_store",
          "args": [
            "&xas",
            "newpage + i"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_next",
          "args": [
            "&xas"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "page"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_store",
          "args": [
            "&xas",
            "newpage"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageDirty",
          "args": [
            "newpage"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageDirty",
          "args": [
            "page"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageSwapCache(page)",
            "page"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "newpage",
            "page_private(page)"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "page"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageSwapCache",
          "args": [
            "newpage"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__SetPageSwapBacked",
          "args": [
            "newpage"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapBacked",
          "args": [
            "page"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_ref_add",
          "args": [
            "newpage",
            "hpage_nr_pages(page)"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "page"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_unlock_irq",
          "args": [
            "&xas"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_migrate_lock_buffers",
          "args": [
            "head",
            "mode"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_migrate_lock_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "424-428",
          "snippet": "static inline bool buffer_migrate_lock_buffers(struct buffer_head *head,\n\t\t\t\t\t\t\tenum migrate_mode mode)\n{\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic inline bool buffer_migrate_lock_buffers(struct buffer_head *head,\n\t\t\t\t\t\t\tenum migrate_mode mode)\n{\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xas_unlock_irq",
          "args": [
            "&xas"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_ref_freeze",
          "args": [
            "page",
            "expected_count"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_unlock_irq",
          "args": [
            "&xas"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_load",
          "args": [
            "&xas"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_private",
          "args": [
            "page"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "page"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_lock_irq",
          "args": [
            "&xas"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "newpage"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__SetPageSwapBacked",
          "args": [
            "newpage"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapBacked",
          "args": [
            "page"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_device_public_page",
          "args": [
            "page"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_device_private_page",
          "args": [
            "page"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XA_STATE",
          "args": [
            "xas",
            "&mapping->i_pages",
            "page_index(page)"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_index",
          "args": [
            "page"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "__basepage_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1358-1373",
          "snippet": "pgoff_t __basepage_index(struct page *page)\n{\n\tstruct page *page_head = compound_head(page);\n\tpgoff_t index = page_index(page_head);\n\tunsigned long compound_idx;\n\n\tif (!PageHuge(page_head))\n\t\treturn page_index(page);\n\n\tif (compound_order(page_head) >= MAX_ORDER)\n\t\tcompound_idx = page_to_pfn(page) - page_to_pfn(page_head);\n\telse\n\t\tcompound_idx = page - page_head;\n\n\treturn (index << compound_order(page_head)) + compound_idx;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\npgoff_t __basepage_index(struct page *page)\n{\n\tstruct page *page_head = compound_head(page);\n\tpgoff_t index = page_index(page_head);\n\tunsigned long compound_idx;\n\n\tif (!PageHuge(page_head))\n\t\treturn page_index(page);\n\n\tif (compound_order(page_head) >= MAX_ORDER)\n\t\tcompound_idx = page_to_pfn(page) - page_to_pfn(page_head);\n\telse\n\t\tcompound_idx = page - page_head;\n\n\treturn (index << compound_order(page_head)) + compound_idx;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nint migrate_page_move_mapping(struct address_space *mapping,\n\t\tstruct page *newpage, struct page *page,\n\t\tstruct buffer_head *head, enum migrate_mode mode,\n\t\tint extra_count)\n{\n\tXA_STATE(xas, &mapping->i_pages, page_index(page));\n\tstruct zone *oldzone, *newzone;\n\tint dirty;\n\tint expected_count = 1 + extra_count;\n\n\t/*\n\t * Device public or private pages have an extra refcount as they are\n\t * ZONE_DEVICE pages.\n\t */\n\texpected_count += is_device_private_page(page);\n\texpected_count += is_device_public_page(page);\n\n\tif (!mapping) {\n\t\t/* Anonymous page without mapping */\n\t\tif (page_count(page) != expected_count)\n\t\t\treturn -EAGAIN;\n\n\t\t/* No turning back from here */\n\t\tnewpage->index = page->index;\n\t\tnewpage->mapping = page->mapping;\n\t\tif (PageSwapBacked(page))\n\t\t\t__SetPageSwapBacked(newpage);\n\n\t\treturn MIGRATEPAGE_SUCCESS;\n\t}\n\n\toldzone = page_zone(page);\n\tnewzone = page_zone(newpage);\n\n\txas_lock_irq(&xas);\n\n\texpected_count += hpage_nr_pages(page) + page_has_private(page);\n\tif (page_count(page) != expected_count || xas_load(&xas) != page) {\n\t\txas_unlock_irq(&xas);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!page_ref_freeze(page, expected_count)) {\n\t\txas_unlock_irq(&xas);\n\t\treturn -EAGAIN;\n\t}\n\n\t/*\n\t * In the async migration case of moving a page with buffers, lock the\n\t * buffers using trylock before the mapping is moved. If the mapping\n\t * was moved, we later failed to lock the buffers and could not move\n\t * the mapping back due to an elevated page count, we would have to\n\t * block waiting on other references to be dropped.\n\t */\n\tif (mode == MIGRATE_ASYNC && head &&\n\t\t\t!buffer_migrate_lock_buffers(head, mode)) {\n\t\tpage_ref_unfreeze(page, expected_count);\n\t\txas_unlock_irq(&xas);\n\t\treturn -EAGAIN;\n\t}\n\n\t/*\n\t * Now we know that no one else is looking at the page:\n\t * no turning back from here.\n\t */\n\tnewpage->index = page->index;\n\tnewpage->mapping = page->mapping;\n\tpage_ref_add(newpage, hpage_nr_pages(page)); /* add cache reference */\n\tif (PageSwapBacked(page)) {\n\t\t__SetPageSwapBacked(newpage);\n\t\tif (PageSwapCache(page)) {\n\t\t\tSetPageSwapCache(newpage);\n\t\t\tset_page_private(newpage, page_private(page));\n\t\t}\n\t} else {\n\t\tVM_BUG_ON_PAGE(PageSwapCache(page), page);\n\t}\n\n\t/* Move dirty while page refs frozen and newpage not yet exposed */\n\tdirty = PageDirty(page);\n\tif (dirty) {\n\t\tClearPageDirty(page);\n\t\tSetPageDirty(newpage);\n\t}\n\n\txas_store(&xas, newpage);\n\tif (PageTransHuge(page)) {\n\t\tint i;\n\n\t\tfor (i = 1; i < HPAGE_PMD_NR; i++) {\n\t\t\txas_next(&xas);\n\t\t\txas_store(&xas, newpage + i);\n\t\t}\n\t}\n\n\t/*\n\t * Drop cache reference from old page by unfreezing\n\t * to one less reference.\n\t * We know this isn't the last reference.\n\t */\n\tpage_ref_unfreeze(page, expected_count - hpage_nr_pages(page));\n\n\txas_unlock(&xas);\n\t/* Leave irq disabled to prevent preemption while updating stats */\n\n\t/*\n\t * If moved to a different zone then also account\n\t * the page for that zone. Other VM counters will be\n\t * taken care of when we establish references to the\n\t * new page and drop references to the old page.\n\t *\n\t * Note that anonymous pages are accounted for\n\t * via NR_FILE_PAGES and NR_ANON_MAPPED if they\n\t * are mapped to swap space.\n\t */\n\tif (newzone != oldzone) {\n\t\t__dec_node_state(oldzone->zone_pgdat, NR_FILE_PAGES);\n\t\t__inc_node_state(newzone->zone_pgdat, NR_FILE_PAGES);\n\t\tif (PageSwapBacked(page) && !PageSwapCache(page)) {\n\t\t\t__dec_node_state(oldzone->zone_pgdat, NR_SHMEM);\n\t\t\t__inc_node_state(newzone->zone_pgdat, NR_SHMEM);\n\t\t}\n\t\tif (dirty && mapping_cap_account_dirty(mapping)) {\n\t\t\t__dec_node_state(oldzone->zone_pgdat, NR_FILE_DIRTY);\n\t\t\t__dec_zone_state(oldzone, NR_ZONE_WRITE_PENDING);\n\t\t\t__inc_node_state(newzone->zone_pgdat, NR_FILE_DIRTY);\n\t\t\t__inc_zone_state(newzone, NR_ZONE_WRITE_PENDING);\n\t\t}\n\t}\n\tlocal_irq_enable();\n\n\treturn MIGRATEPAGE_SUCCESS;\n}"
  },
  {
    "function_name": "buffer_migrate_lock_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "424-428",
    "snippet": "static inline bool buffer_migrate_lock_buffers(struct buffer_head *head,\n\t\t\t\t\t\t\tenum migrate_mode mode)\n{\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic inline bool buffer_migrate_lock_buffers(struct buffer_head *head,\n\t\t\t\t\t\t\tenum migrate_mode mode)\n{\n\treturn true;\n}"
  },
  {
    "function_name": "buffer_migrate_lock_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "383-422",
    "snippet": "static bool buffer_migrate_lock_buffers(struct buffer_head *head,\n\t\t\t\t\t\t\tenum migrate_mode mode)\n{\n\tstruct buffer_head *bh = head;\n\n\t/* Simple case, sync compaction */\n\tif (mode != MIGRATE_ASYNC) {\n\t\tdo {\n\t\t\tget_bh(bh);\n\t\t\tlock_buffer(bh);\n\t\t\tbh = bh->b_this_page;\n\n\t\t} while (bh != head);\n\n\t\treturn true;\n\t}\n\n\t/* async case, we cannot block on lock_buffer so use trylock_buffer */\n\tdo {\n\t\tget_bh(bh);\n\t\tif (!trylock_buffer(bh)) {\n\t\t\t/*\n\t\t\t * We failed to lock the buffer and cannot stall in\n\t\t\t * async migration. Release the taken locks\n\t\t\t */\n\t\t\tstruct buffer_head *failed_bh = bh;\n\t\t\tput_bh(failed_bh);\n\t\t\tbh = head;\n\t\t\twhile (bh != failed_bh) {\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tput_bh(bh);\n\t\t\t\tbh = bh->b_this_page;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "failed_bh"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_buffer",
          "args": [
            "bh"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_buffer",
          "args": [
            "bh"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic bool buffer_migrate_lock_buffers(struct buffer_head *head,\n\t\t\t\t\t\t\tenum migrate_mode mode)\n{\n\tstruct buffer_head *bh = head;\n\n\t/* Simple case, sync compaction */\n\tif (mode != MIGRATE_ASYNC) {\n\t\tdo {\n\t\t\tget_bh(bh);\n\t\t\tlock_buffer(bh);\n\t\t\tbh = bh->b_this_page;\n\n\t\t} while (bh != head);\n\n\t\treturn true;\n\t}\n\n\t/* async case, we cannot block on lock_buffer so use trylock_buffer */\n\tdo {\n\t\tget_bh(bh);\n\t\tif (!trylock_buffer(bh)) {\n\t\t\t/*\n\t\t\t * We failed to lock the buffer and cannot stall in\n\t\t\t * async migration. Release the taken locks\n\t\t\t */\n\t\t\tstruct buffer_head *failed_bh = bh;\n\t\t\tput_bh(failed_bh);\n\t\t\tbh = head;\n\t\t\twhile (bh != failed_bh) {\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tput_bh(bh);\n\t\t\t\tbh = bh->b_this_page;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\treturn true;\n}"
  },
  {
    "function_name": "pmd_migration_entry_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "361-378",
    "snippet": "void pmd_migration_entry_wait(struct mm_struct *mm, pmd_t *pmd)\n{\n\tspinlock_t *ptl;\n\tstruct page *page;\n\n\tptl = pmd_lock(mm, pmd);\n\tif (!is_pmd_migration_entry(*pmd))\n\t\tgoto unlock;\n\tpage = migration_entry_to_page(pmd_to_swp_entry(*pmd));\n\tif (!get_page_unless_zero(page))\n\t\tgoto unlock;\n\tspin_unlock(ptl);\n\twait_on_page_locked(page);\n\tput_page(page);\n\treturn;\nunlock:\n\tspin_unlock(ptl);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_page_locked",
          "args": [
            "page"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page_unless_zero",
          "args": [
            "page"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migration_entry_to_page",
          "args": [
            "pmd_to_swp_entry(*pmd)"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_to_swp_entry",
          "args": [
            "*pmd"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_pmd_migration_entry",
          "args": [
            "*pmd"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_lock",
          "args": [
            "mm",
            "pmd"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nvoid pmd_migration_entry_wait(struct mm_struct *mm, pmd_t *pmd)\n{\n\tspinlock_t *ptl;\n\tstruct page *page;\n\n\tptl = pmd_lock(mm, pmd);\n\tif (!is_pmd_migration_entry(*pmd))\n\t\tgoto unlock;\n\tpage = migration_entry_to_page(pmd_to_swp_entry(*pmd));\n\tif (!get_page_unless_zero(page))\n\t\tgoto unlock;\n\tspin_unlock(ptl);\n\twait_on_page_locked(page);\n\tput_page(page);\n\treturn;\nunlock:\n\tspin_unlock(ptl);\n}"
  },
  {
    "function_name": "migration_entry_wait_huge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "353-358",
    "snippet": "void migration_entry_wait_huge(struct vm_area_struct *vma,\n\t\tstruct mm_struct *mm, pte_t *pte)\n{\n\tspinlock_t *ptl = huge_pte_lockptr(hstate_vma(vma), mm, pte);\n\t__migration_entry_wait(mm, pte, ptl);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__migration_entry_wait",
          "args": [
            "mm",
            "pte",
            "ptl"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "__migration_entry_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "310-343",
          "snippet": "void __migration_entry_wait(struct mm_struct *mm, pte_t *ptep,\n\t\t\t\tspinlock_t *ptl)\n{\n\tpte_t pte;\n\tswp_entry_t entry;\n\tstruct page *page;\n\n\tspin_lock(ptl);\n\tpte = *ptep;\n\tif (!is_swap_pte(pte))\n\t\tgoto out;\n\n\tentry = pte_to_swp_entry(pte);\n\tif (!is_migration_entry(entry))\n\t\tgoto out;\n\n\tpage = migration_entry_to_page(entry);\n\n\t/*\n\t * Once page cache replacement of page migration started, page_count\n\t * *must* be zero. And, we don't want to call wait_on_page_locked()\n\t * against a page without get_page().\n\t * So, we use get_page_unless_zero(), here. Even failed, page fault\n\t * will occur again.\n\t */\n\tif (!get_page_unless_zero(page))\n\t\tgoto out;\n\tpte_unmap_unlock(ptep, ptl);\n\twait_on_page_locked(page);\n\tput_page(page);\n\treturn;\nout:\n\tpte_unmap_unlock(ptep, ptl);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nvoid __migration_entry_wait(struct mm_struct *mm, pte_t *ptep,\n\t\t\t\tspinlock_t *ptl)\n{\n\tpte_t pte;\n\tswp_entry_t entry;\n\tstruct page *page;\n\n\tspin_lock(ptl);\n\tpte = *ptep;\n\tif (!is_swap_pte(pte))\n\t\tgoto out;\n\n\tentry = pte_to_swp_entry(pte);\n\tif (!is_migration_entry(entry))\n\t\tgoto out;\n\n\tpage = migration_entry_to_page(entry);\n\n\t/*\n\t * Once page cache replacement of page migration started, page_count\n\t * *must* be zero. And, we don't want to call wait_on_page_locked()\n\t * against a page without get_page().\n\t * So, we use get_page_unless_zero(), here. Even failed, page fault\n\t * will occur again.\n\t */\n\tif (!get_page_unless_zero(page))\n\t\tgoto out;\n\tpte_unmap_unlock(ptep, ptl);\n\twait_on_page_locked(page);\n\tput_page(page);\n\treturn;\nout:\n\tpte_unmap_unlock(ptep, ptl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_pte_lockptr",
          "args": [
            "hstate_vma(vma)",
            "mm",
            "pte"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hstate_vma",
          "args": [
            "vma"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nvoid migration_entry_wait_huge(struct vm_area_struct *vma,\n\t\tstruct mm_struct *mm, pte_t *pte)\n{\n\tspinlock_t *ptl = huge_pte_lockptr(hstate_vma(vma), mm, pte);\n\t__migration_entry_wait(mm, pte, ptl);\n}"
  },
  {
    "function_name": "migration_entry_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "345-351",
    "snippet": "void migration_entry_wait(struct mm_struct *mm, pmd_t *pmd,\n\t\t\t\tunsigned long address)\n{\n\tspinlock_t *ptl = pte_lockptr(mm, pmd);\n\tpte_t *ptep = pte_offset_map(pmd, address);\n\t__migration_entry_wait(mm, ptep, ptl);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__migration_entry_wait",
          "args": [
            "mm",
            "ptep",
            "ptl"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "__migration_entry_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "310-343",
          "snippet": "void __migration_entry_wait(struct mm_struct *mm, pte_t *ptep,\n\t\t\t\tspinlock_t *ptl)\n{\n\tpte_t pte;\n\tswp_entry_t entry;\n\tstruct page *page;\n\n\tspin_lock(ptl);\n\tpte = *ptep;\n\tif (!is_swap_pte(pte))\n\t\tgoto out;\n\n\tentry = pte_to_swp_entry(pte);\n\tif (!is_migration_entry(entry))\n\t\tgoto out;\n\n\tpage = migration_entry_to_page(entry);\n\n\t/*\n\t * Once page cache replacement of page migration started, page_count\n\t * *must* be zero. And, we don't want to call wait_on_page_locked()\n\t * against a page without get_page().\n\t * So, we use get_page_unless_zero(), here. Even failed, page fault\n\t * will occur again.\n\t */\n\tif (!get_page_unless_zero(page))\n\t\tgoto out;\n\tpte_unmap_unlock(ptep, ptl);\n\twait_on_page_locked(page);\n\tput_page(page);\n\treturn;\nout:\n\tpte_unmap_unlock(ptep, ptl);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nvoid __migration_entry_wait(struct mm_struct *mm, pte_t *ptep,\n\t\t\t\tspinlock_t *ptl)\n{\n\tpte_t pte;\n\tswp_entry_t entry;\n\tstruct page *page;\n\n\tspin_lock(ptl);\n\tpte = *ptep;\n\tif (!is_swap_pte(pte))\n\t\tgoto out;\n\n\tentry = pte_to_swp_entry(pte);\n\tif (!is_migration_entry(entry))\n\t\tgoto out;\n\n\tpage = migration_entry_to_page(entry);\n\n\t/*\n\t * Once page cache replacement of page migration started, page_count\n\t * *must* be zero. And, we don't want to call wait_on_page_locked()\n\t * against a page without get_page().\n\t * So, we use get_page_unless_zero(), here. Even failed, page fault\n\t * will occur again.\n\t */\n\tif (!get_page_unless_zero(page))\n\t\tgoto out;\n\tpte_unmap_unlock(ptep, ptl);\n\twait_on_page_locked(page);\n\tput_page(page);\n\treturn;\nout:\n\tpte_unmap_unlock(ptep, ptl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_offset_map",
          "args": [
            "pmd",
            "address"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_lockptr",
          "args": [
            "mm",
            "pmd"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nvoid migration_entry_wait(struct mm_struct *mm, pmd_t *pmd,\n\t\t\t\tunsigned long address)\n{\n\tspinlock_t *ptl = pte_lockptr(mm, pmd);\n\tpte_t *ptep = pte_offset_map(pmd, address);\n\t__migration_entry_wait(mm, ptep, ptl);\n}"
  },
  {
    "function_name": "__migration_entry_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "310-343",
    "snippet": "void __migration_entry_wait(struct mm_struct *mm, pte_t *ptep,\n\t\t\t\tspinlock_t *ptl)\n{\n\tpte_t pte;\n\tswp_entry_t entry;\n\tstruct page *page;\n\n\tspin_lock(ptl);\n\tpte = *ptep;\n\tif (!is_swap_pte(pte))\n\t\tgoto out;\n\n\tentry = pte_to_swp_entry(pte);\n\tif (!is_migration_entry(entry))\n\t\tgoto out;\n\n\tpage = migration_entry_to_page(entry);\n\n\t/*\n\t * Once page cache replacement of page migration started, page_count\n\t * *must* be zero. And, we don't want to call wait_on_page_locked()\n\t * against a page without get_page().\n\t * So, we use get_page_unless_zero(), here. Even failed, page fault\n\t * will occur again.\n\t */\n\tif (!get_page_unless_zero(page))\n\t\tgoto out;\n\tpte_unmap_unlock(ptep, ptl);\n\twait_on_page_locked(page);\n\tput_page(page);\n\treturn;\nout:\n\tpte_unmap_unlock(ptep, ptl);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "ptep",
            "ptl"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_page_locked",
          "args": [
            "page"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "ptep",
            "ptl"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page_unless_zero",
          "args": [
            "page"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migration_entry_to_page",
          "args": [
            "entry"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_migration_entry",
          "args": [
            "entry"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_to_swp_entry",
          "args": [
            "pte"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_swap_pte",
          "args": [
            "pte"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "ptl"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nvoid __migration_entry_wait(struct mm_struct *mm, pte_t *ptep,\n\t\t\t\tspinlock_t *ptl)\n{\n\tpte_t pte;\n\tswp_entry_t entry;\n\tstruct page *page;\n\n\tspin_lock(ptl);\n\tpte = *ptep;\n\tif (!is_swap_pte(pte))\n\t\tgoto out;\n\n\tentry = pte_to_swp_entry(pte);\n\tif (!is_migration_entry(entry))\n\t\tgoto out;\n\n\tpage = migration_entry_to_page(entry);\n\n\t/*\n\t * Once page cache replacement of page migration started, page_count\n\t * *must* be zero. And, we don't want to call wait_on_page_locked()\n\t * against a page without get_page().\n\t * So, we use get_page_unless_zero(), here. Even failed, page fault\n\t * will occur again.\n\t */\n\tif (!get_page_unless_zero(page))\n\t\tgoto out;\n\tpte_unmap_unlock(ptep, ptl);\n\twait_on_page_locked(page);\n\tput_page(page);\n\treturn;\nout:\n\tpte_unmap_unlock(ptep, ptl);\n}"
  },
  {
    "function_name": "remove_migration_ptes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "292-303",
    "snippet": "void remove_migration_ptes(struct page *old, struct page *new, bool locked)\n{\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = remove_migration_pte,\n\t\t.arg = old,\n\t};\n\n\tif (locked)\n\t\trmap_walk_locked(new, &rwc);\n\telse\n\t\trmap_walk(new, &rwc);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rmap_walk",
          "args": [
            "new",
            "&rwc"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "rmap_walk_ksm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "2579-2641",
          "snippet": "void rmap_walk_ksm(struct page *page, struct rmap_walk_control *rwc)\n{\n\tstruct stable_node *stable_node;\n\tstruct rmap_item *rmap_item;\n\tint search_new_forks = 0;\n\n\tVM_BUG_ON_PAGE(!PageKsm(page), page);\n\n\t/*\n\t * Rely on the page lock to protect against concurrent modifications\n\t * to that page's node of the stable tree.\n\t */\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tstable_node = page_stable_node(page);\n\tif (!stable_node)\n\t\treturn;\nagain:\n\thlist_for_each_entry(rmap_item, &stable_node->hlist, hlist) {\n\t\tstruct anon_vma *anon_vma = rmap_item->anon_vma;\n\t\tstruct anon_vma_chain *vmac;\n\t\tstruct vm_area_struct *vma;\n\n\t\tcond_resched();\n\t\tanon_vma_lock_read(anon_vma);\n\t\tanon_vma_interval_tree_foreach(vmac, &anon_vma->rb_root,\n\t\t\t\t\t       0, ULONG_MAX) {\n\t\t\tunsigned long addr;\n\n\t\t\tcond_resched();\n\t\t\tvma = vmac->vma;\n\n\t\t\t/* Ignore the stable/unstable/sqnr flags */\n\t\t\taddr = rmap_item->address & ~KSM_FLAG_MASK;\n\n\t\t\tif (addr < vma->vm_start || addr >= vma->vm_end)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Initially we examine only the vma which covers this\n\t\t\t * rmap_item; but later, if there is still work to do,\n\t\t\t * we examine covering vmas in other mms: in case they\n\t\t\t * were forked from the original since ksmd passed.\n\t\t\t */\n\t\t\tif ((rmap_item->mm == vma->vm_mm) == search_new_forks)\n\t\t\t\tcontinue;\n\n\t\t\tif (rwc->invalid_vma && rwc->invalid_vma(vma, rwc->arg))\n\t\t\t\tcontinue;\n\n\t\t\tif (!rwc->rmap_one(page, vma, addr, rwc->arg)) {\n\t\t\t\tanon_vma_unlock_read(anon_vma);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (rwc->done && rwc->done(page)) {\n\t\t\t\tanon_vma_unlock_read(anon_vma);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tanon_vma_unlock_read(anon_vma);\n\t}\n\tif (!search_new_forks++)\n\t\tgoto again;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define KSM_FLAG_MASK\t(SEQNR_MASK|UNSTABLE_FLAG|STABLE_FLAG)"
          ],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define KSM_FLAG_MASK\t(SEQNR_MASK|UNSTABLE_FLAG|STABLE_FLAG)\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nvoid rmap_walk_ksm(struct page *page, struct rmap_walk_control *rwc)\n{\n\tstruct stable_node *stable_node;\n\tstruct rmap_item *rmap_item;\n\tint search_new_forks = 0;\n\n\tVM_BUG_ON_PAGE(!PageKsm(page), page);\n\n\t/*\n\t * Rely on the page lock to protect against concurrent modifications\n\t * to that page's node of the stable tree.\n\t */\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tstable_node = page_stable_node(page);\n\tif (!stable_node)\n\t\treturn;\nagain:\n\thlist_for_each_entry(rmap_item, &stable_node->hlist, hlist) {\n\t\tstruct anon_vma *anon_vma = rmap_item->anon_vma;\n\t\tstruct anon_vma_chain *vmac;\n\t\tstruct vm_area_struct *vma;\n\n\t\tcond_resched();\n\t\tanon_vma_lock_read(anon_vma);\n\t\tanon_vma_interval_tree_foreach(vmac, &anon_vma->rb_root,\n\t\t\t\t\t       0, ULONG_MAX) {\n\t\t\tunsigned long addr;\n\n\t\t\tcond_resched();\n\t\t\tvma = vmac->vma;\n\n\t\t\t/* Ignore the stable/unstable/sqnr flags */\n\t\t\taddr = rmap_item->address & ~KSM_FLAG_MASK;\n\n\t\t\tif (addr < vma->vm_start || addr >= vma->vm_end)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Initially we examine only the vma which covers this\n\t\t\t * rmap_item; but later, if there is still work to do,\n\t\t\t * we examine covering vmas in other mms: in case they\n\t\t\t * were forked from the original since ksmd passed.\n\t\t\t */\n\t\t\tif ((rmap_item->mm == vma->vm_mm) == search_new_forks)\n\t\t\t\tcontinue;\n\n\t\t\tif (rwc->invalid_vma && rwc->invalid_vma(vma, rwc->arg))\n\t\t\t\tcontinue;\n\n\t\t\tif (!rwc->rmap_one(page, vma, addr, rwc->arg)) {\n\t\t\t\tanon_vma_unlock_read(anon_vma);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (rwc->done && rwc->done(page)) {\n\t\t\t\tanon_vma_unlock_read(anon_vma);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tanon_vma_unlock_read(anon_vma);\n\t}\n\tif (!search_new_forks++)\n\t\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmap_walk_locked",
          "args": [
            "new",
            "&rwc"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "rmap_walk_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1908-1916",
          "snippet": "void rmap_walk_locked(struct page *page, struct rmap_walk_control *rwc)\n{\n\t/* no ksm support for now */\n\tVM_BUG_ON_PAGE(PageKsm(page), page);\n\tif (PageAnon(page))\n\t\trmap_walk_anon(page, rwc, true);\n\telse\n\t\trmap_walk_file(page, rwc, true);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid rmap_walk_locked(struct page *page, struct rmap_walk_control *rwc)\n{\n\t/* no ksm support for now */\n\tVM_BUG_ON_PAGE(PageKsm(page), page);\n\tif (PageAnon(page))\n\t\trmap_walk_anon(page, rwc, true);\n\telse\n\t\trmap_walk_file(page, rwc, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nvoid remove_migration_ptes(struct page *old, struct page *new, bool locked)\n{\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = remove_migration_pte,\n\t\t.arg = old,\n\t};\n\n\tif (locked)\n\t\trmap_walk_locked(new, &rwc);\n\telse\n\t\trmap_walk(new, &rwc);\n}"
  },
  {
    "function_name": "remove_migration_pte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "203-286",
    "snippet": "static bool remove_migration_pte(struct page *page, struct vm_area_struct *vma,\n\t\t\t\t unsigned long addr, void *old)\n{\n\tstruct page_vma_mapped_walk pvmw = {\n\t\t.page = old,\n\t\t.vma = vma,\n\t\t.address = addr,\n\t\t.flags = PVMW_SYNC | PVMW_MIGRATION,\n\t};\n\tstruct page *new;\n\tpte_t pte;\n\tswp_entry_t entry;\n\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\twhile (page_vma_mapped_walk(&pvmw)) {\n\t\tif (PageKsm(page))\n\t\t\tnew = page;\n\t\telse\n\t\t\tnew = page - pvmw.page->index +\n\t\t\t\tlinear_page_index(vma, pvmw.address);\n\n#ifdef CONFIG_ARCH_ENABLE_THP_MIGRATION\n\t\t/* PMD-mapped THP migration entry */\n\t\tif (!pvmw.pte) {\n\t\t\tVM_BUG_ON_PAGE(PageHuge(page) || !PageTransCompound(page), page);\n\t\t\tremove_migration_pmd(&pvmw, new);\n\t\t\tcontinue;\n\t\t}\n#endif\n\n\t\tget_page(new);\n\t\tpte = pte_mkold(mk_pte(new, READ_ONCE(vma->vm_page_prot)));\n\t\tif (pte_swp_soft_dirty(*pvmw.pte))\n\t\t\tpte = pte_mksoft_dirty(pte);\n\n\t\t/*\n\t\t * Recheck VMA as permissions can change since migration started\n\t\t */\n\t\tentry = pte_to_swp_entry(*pvmw.pte);\n\t\tif (is_write_migration_entry(entry))\n\t\t\tpte = maybe_mkwrite(pte, vma);\n\n\t\tif (unlikely(is_zone_device_page(new))) {\n\t\t\tif (is_device_private_page(new)) {\n\t\t\t\tentry = make_device_private_entry(new, pte_write(pte));\n\t\t\t\tpte = swp_entry_to_pte(entry);\n\t\t\t} else if (is_device_public_page(new)) {\n\t\t\t\tpte = pte_mkdevmap(pte);\n\t\t\t\tflush_dcache_page(new);\n\t\t\t}\n\t\t} else\n\t\t\tflush_dcache_page(new);\n\n#ifdef CONFIG_HUGETLB_PAGE\n\t\tif (PageHuge(new)) {\n\t\t\tpte = pte_mkhuge(pte);\n\t\t\tpte = arch_make_huge_pte(pte, vma, new, 0);\n\t\t\tset_huge_pte_at(vma->vm_mm, pvmw.address, pvmw.pte, pte);\n\t\t\tif (PageAnon(new))\n\t\t\t\thugepage_add_anon_rmap(new, vma, pvmw.address);\n\t\t\telse\n\t\t\t\tpage_dup_rmap(new, true);\n\t\t} else\n#endif\n\t\t{\n\t\t\tset_pte_at(vma->vm_mm, pvmw.address, pvmw.pte, pte);\n\n\t\t\tif (PageAnon(new))\n\t\t\t\tpage_add_anon_rmap(new, vma, pvmw.address, false);\n\t\t\telse\n\t\t\t\tpage_add_file_rmap(new, false);\n\t\t}\n\t\tif (vma->vm_flags & VM_LOCKED && !PageTransCompound(new))\n\t\t\tmlock_vma_page(new);\n\n\t\tif (PageTransHuge(page) && PageMlocked(page))\n\t\t\tclear_page_mlock(page);\n\n\t\t/* No need to invalidate - it was non-present before */\n\t\tupdate_mmu_cache(vma, pvmw.address, pvmw.pte);\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_mmu_cache",
          "args": [
            "vma",
            "pvmw.address",
            "pvmw.pte"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_page_mlock",
          "args": [
            "page"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "clear_page_mlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "358-358",
          "snippet": "static inline void clear_page_mlock(struct page *page) { }",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void clear_page_mlock(struct page *page) { }"
        }
      },
      {
        "call_info": {
          "callee": "PageMlocked",
          "args": [
            "page"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "page"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlock_vma_page",
          "args": [
            "new"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "mlock_vma_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "359-359",
          "snippet": "static inline void mlock_vma_page(struct page *page) { }",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void mlock_vma_page(struct page *page) { }"
        }
      },
      {
        "call_info": {
          "callee": "PageTransCompound",
          "args": [
            "new"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_add_file_rmap",
          "args": [
            "new",
            "false"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "page_add_file_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1179-1208",
          "snippet": "void page_add_file_rmap(struct page *page, bool compound)\n{\n\tint i, nr = 1;\n\n\tVM_BUG_ON_PAGE(compound && !PageTransHuge(page), page);\n\tlock_page_memcg(page);\n\tif (compound && PageTransHuge(page)) {\n\t\tfor (i = 0, nr = 0; i < HPAGE_PMD_NR; i++) {\n\t\t\tif (atomic_inc_and_test(&page[i]._mapcount))\n\t\t\t\tnr++;\n\t\t}\n\t\tif (!atomic_inc_and_test(compound_mapcount_ptr(page)))\n\t\t\tgoto out;\n\t\tVM_BUG_ON_PAGE(!PageSwapBacked(page), page);\n\t\t__inc_node_page_state(page, NR_SHMEM_PMDMAPPED);\n\t} else {\n\t\tif (PageTransCompound(page) && page_mapping(page)) {\n\t\t\tVM_WARN_ON_ONCE(!PageLocked(page));\n\n\t\t\tSetPageDoubleMap(compound_head(page));\n\t\t\tif (PageMlocked(page))\n\t\t\t\tclear_page_mlock(compound_head(page));\n\t\t}\n\t\tif (!atomic_inc_and_test(&page->_mapcount))\n\t\t\tgoto out;\n\t}\n\t__mod_lruvec_page_state(page, NR_FILE_MAPPED, nr);\nout:\n\tunlock_page_memcg(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid page_add_file_rmap(struct page *page, bool compound)\n{\n\tint i, nr = 1;\n\n\tVM_BUG_ON_PAGE(compound && !PageTransHuge(page), page);\n\tlock_page_memcg(page);\n\tif (compound && PageTransHuge(page)) {\n\t\tfor (i = 0, nr = 0; i < HPAGE_PMD_NR; i++) {\n\t\t\tif (atomic_inc_and_test(&page[i]._mapcount))\n\t\t\t\tnr++;\n\t\t}\n\t\tif (!atomic_inc_and_test(compound_mapcount_ptr(page)))\n\t\t\tgoto out;\n\t\tVM_BUG_ON_PAGE(!PageSwapBacked(page), page);\n\t\t__inc_node_page_state(page, NR_SHMEM_PMDMAPPED);\n\t} else {\n\t\tif (PageTransCompound(page) && page_mapping(page)) {\n\t\t\tVM_WARN_ON_ONCE(!PageLocked(page));\n\n\t\t\tSetPageDoubleMap(compound_head(page));\n\t\t\tif (PageMlocked(page))\n\t\t\t\tclear_page_mlock(compound_head(page));\n\t\t}\n\t\tif (!atomic_inc_and_test(&page->_mapcount))\n\t\t\tgoto out;\n\t}\n\t__mod_lruvec_page_state(page, NR_FILE_MAPPED, nr);\nout:\n\tunlock_page_memcg(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_add_anon_rmap",
          "args": [
            "new",
            "vma",
            "pvmw.address",
            "false"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "do_page_add_anon_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1098-1137",
          "snippet": "void do_page_add_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, int flags)\n{\n\tbool compound = flags & RMAP_COMPOUND;\n\tbool first;\n\n\tif (compound) {\n\t\tatomic_t *mapcount;\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\tmapcount = compound_mapcount_ptr(page);\n\t\tfirst = atomic_inc_and_test(mapcount);\n\t} else {\n\t\tfirst = atomic_inc_and_test(&page->_mapcount);\n\t}\n\n\tif (first) {\n\t\tint nr = compound ? hpage_nr_pages(page) : 1;\n\t\t/*\n\t\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t\t * these counters are not modified in interrupt context, and\n\t\t * pte lock(a spinlock) is held, which implies preemption\n\t\t * disabled.\n\t\t */\n\t\tif (compound)\n\t\t\t__inc_node_page_state(page, NR_ANON_THPS);\n\t\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, nr);\n\t}\n\tif (unlikely(PageKsm(page)))\n\t\treturn;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\t/* address might be in next vma when migration races vma_adjust */\n\tif (first)\n\t\t__page_set_anon_rmap(page, vma, address,\n\t\t\t\tflags & RMAP_EXCLUSIVE);\n\telse\n\t\t__page_check_anon_rmap(page, vma, address);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid do_page_add_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, int flags)\n{\n\tbool compound = flags & RMAP_COMPOUND;\n\tbool first;\n\n\tif (compound) {\n\t\tatomic_t *mapcount;\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\tmapcount = compound_mapcount_ptr(page);\n\t\tfirst = atomic_inc_and_test(mapcount);\n\t} else {\n\t\tfirst = atomic_inc_and_test(&page->_mapcount);\n\t}\n\n\tif (first) {\n\t\tint nr = compound ? hpage_nr_pages(page) : 1;\n\t\t/*\n\t\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t\t * these counters are not modified in interrupt context, and\n\t\t * pte lock(a spinlock) is held, which implies preemption\n\t\t * disabled.\n\t\t */\n\t\tif (compound)\n\t\t\t__inc_node_page_state(page, NR_ANON_THPS);\n\t\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, nr);\n\t}\n\tif (unlikely(PageKsm(page)))\n\t\treturn;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\t/* address might be in next vma when migration races vma_adjust */\n\tif (first)\n\t\t__page_set_anon_rmap(page, vma, address,\n\t\t\t\tflags & RMAP_EXCLUSIVE);\n\telse\n\t\t__page_check_anon_rmap(page, vma, address);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "new"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pte_at",
          "args": [
            "vma->vm_mm",
            "pvmw.address",
            "pvmw.pte",
            "pte"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_dup_rmap",
          "args": [
            "new",
            "true"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugepage_add_anon_rmap",
          "args": [
            "new",
            "vma",
            "pvmw.address"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "hugepage_add_anon_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1941-1953",
          "snippet": "void hugepage_add_anon_rmap(struct page *page,\n\t\t\t    struct vm_area_struct *vma, unsigned long address)\n{\n\tstruct anon_vma *anon_vma = vma->anon_vma;\n\tint first;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(!anon_vma);\n\t/* address might be in next vma when migration races vma_adjust */\n\tfirst = atomic_inc_and_test(compound_mapcount_ptr(page));\n\tif (first)\n\t\t__hugepage_set_anon_rmap(page, vma, address, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid hugepage_add_anon_rmap(struct page *page,\n\t\t\t    struct vm_area_struct *vma, unsigned long address)\n{\n\tstruct anon_vma *anon_vma = vma->anon_vma;\n\tint first;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(!anon_vma);\n\t/* address might be in next vma when migration races vma_adjust */\n\tfirst = atomic_inc_and_test(compound_mapcount_ptr(page));\n\tif (first)\n\t\t__hugepage_set_anon_rmap(page, vma, address, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "new"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_huge_pte_at",
          "args": [
            "vma->vm_mm",
            "pvmw.address",
            "pvmw.pte",
            "pte"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_make_huge_pte",
          "args": [
            "pte",
            "vma",
            "new",
            "0"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkhuge",
          "args": [
            "pte"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "new"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "PageHugeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "225-228",
          "snippet": "static int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "new"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "new"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkdevmap",
          "args": [
            "pte"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_device_public_page",
          "args": [
            "new"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_entry_to_pte",
          "args": [
            "entry"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_device_private_entry",
          "args": [
            "new",
            "pte_write(pte)"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_write",
          "args": [
            "pte"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_device_private_page",
          "args": [
            "new"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_zone_device_page(new)"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_zone_device_page",
          "args": [
            "new"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "maybe_mkwrite",
          "args": [
            "pte",
            "vma"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_write_migration_entry",
          "args": [
            "entry"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_to_swp_entry",
          "args": [
            "*pvmw.pte"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mksoft_dirty",
          "args": [
            "pte"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_swp_soft_dirty",
          "args": [
            "*pvmw.pte"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkold",
          "args": [
            "mk_pte(new, READ_ONCE(vma->vm_page_prot))"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mk_pte",
          "args": [
            "new",
            "READ_ONCE(vma->vm_page_prot)"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "vma->vm_page_prot"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "new"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_migration_pmd",
          "args": [
            "&pvmw",
            "new"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "remove_migration_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "2926-2955",
          "snippet": "void remove_migration_pmd(struct page_vma_mapped_walk *pvmw, struct page *new)\n{\n\tstruct vm_area_struct *vma = pvmw->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long address = pvmw->address;\n\tunsigned long mmun_start = address & HPAGE_PMD_MASK;\n\tpmd_t pmde;\n\tswp_entry_t entry;\n\n\tif (!(pvmw->pmd && !pvmw->pte))\n\t\treturn;\n\n\tentry = pmd_to_swp_entry(*pvmw->pmd);\n\tget_page(new);\n\tpmde = pmd_mkold(mk_huge_pmd(new, vma->vm_page_prot));\n\tif (pmd_swp_soft_dirty(*pvmw->pmd))\n\t\tpmde = pmd_mksoft_dirty(pmde);\n\tif (is_write_migration_entry(entry))\n\t\tpmde = maybe_pmd_mkwrite(pmde, vma);\n\n\tflush_cache_range(vma, mmun_start, mmun_start + HPAGE_PMD_SIZE);\n\tif (PageAnon(new))\n\t\tpage_add_anon_rmap(new, vma, mmun_start, true);\n\telse\n\t\tpage_add_file_rmap(new, true);\n\tset_pmd_at(mm, mmun_start, pvmw->pmd, pmde);\n\tif ((vma->vm_flags & VM_LOCKED) && !PageDoubleMap(new))\n\t\tmlock_vma_page(new);\n\tupdate_mmu_cache_pmd(vma, address, pvmw->pmd);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid remove_migration_pmd(struct page_vma_mapped_walk *pvmw, struct page *new)\n{\n\tstruct vm_area_struct *vma = pvmw->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long address = pvmw->address;\n\tunsigned long mmun_start = address & HPAGE_PMD_MASK;\n\tpmd_t pmde;\n\tswp_entry_t entry;\n\n\tif (!(pvmw->pmd && !pvmw->pte))\n\t\treturn;\n\n\tentry = pmd_to_swp_entry(*pvmw->pmd);\n\tget_page(new);\n\tpmde = pmd_mkold(mk_huge_pmd(new, vma->vm_page_prot));\n\tif (pmd_swp_soft_dirty(*pvmw->pmd))\n\t\tpmde = pmd_mksoft_dirty(pmde);\n\tif (is_write_migration_entry(entry))\n\t\tpmde = maybe_pmd_mkwrite(pmde, vma);\n\n\tflush_cache_range(vma, mmun_start, mmun_start + HPAGE_PMD_SIZE);\n\tif (PageAnon(new))\n\t\tpage_add_anon_rmap(new, vma, mmun_start, true);\n\telse\n\t\tpage_add_file_rmap(new, true);\n\tset_pmd_at(mm, mmun_start, pvmw->pmd, pmde);\n\tif ((vma->vm_flags & VM_LOCKED) && !PageDoubleMap(new))\n\t\tmlock_vma_page(new);\n\tupdate_mmu_cache_pmd(vma, address, pvmw->pmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageHuge(page) || !PageTransCompound(page)",
            "page"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransCompound",
          "args": [
            "page"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "linear_page_index",
          "args": [
            "vma",
            "pvmw.address"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageKsm",
          "args": [
            "page"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_vma_mapped_walk",
          "args": [
            "&pvmw"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "page_vma_mapped_walk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_vma_mapped.c",
          "lines": "138-247",
          "snippet": "bool page_vma_mapped_walk(struct page_vma_mapped_walk *pvmw)\n{\n\tstruct mm_struct *mm = pvmw->vma->vm_mm;\n\tstruct page *page = pvmw->page;\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t pmde;\n\n\t/* The only possible pmd mapping has been handled on last iteration */\n\tif (pvmw->pmd && !pvmw->pte)\n\t\treturn not_found(pvmw);\n\n\tif (pvmw->pte)\n\t\tgoto next_pte;\n\n\tif (unlikely(PageHuge(pvmw->page))) {\n\t\t/* when pud is not present, pte will be NULL */\n\t\tpvmw->pte = huge_pte_offset(mm, pvmw->address,\n\t\t\t\t\t    PAGE_SIZE << compound_order(page));\n\t\tif (!pvmw->pte)\n\t\t\treturn false;\n\n\t\tpvmw->ptl = huge_pte_lockptr(page_hstate(page), mm, pvmw->pte);\n\t\tspin_lock(pvmw->ptl);\n\t\tif (!check_pte(pvmw))\n\t\t\treturn not_found(pvmw);\n\t\treturn true;\n\t}\nrestart:\n\tpgd = pgd_offset(mm, pvmw->address);\n\tif (!pgd_present(*pgd))\n\t\treturn false;\n\tp4d = p4d_offset(pgd, pvmw->address);\n\tif (!p4d_present(*p4d))\n\t\treturn false;\n\tpud = pud_offset(p4d, pvmw->address);\n\tif (!pud_present(*pud))\n\t\treturn false;\n\tpvmw->pmd = pmd_offset(pud, pvmw->address);\n\t/*\n\t * Make sure the pmd value isn't cached in a register by the\n\t * compiler and used as a stale value after we've observed a\n\t * subsequent update.\n\t */\n\tpmde = READ_ONCE(*pvmw->pmd);\n\tif (pmd_trans_huge(pmde) || is_pmd_migration_entry(pmde)) {\n\t\tpvmw->ptl = pmd_lock(mm, pvmw->pmd);\n\t\tif (likely(pmd_trans_huge(*pvmw->pmd))) {\n\t\t\tif (pvmw->flags & PVMW_MIGRATION)\n\t\t\t\treturn not_found(pvmw);\n\t\t\tif (pmd_page(*pvmw->pmd) != page)\n\t\t\t\treturn not_found(pvmw);\n\t\t\treturn true;\n\t\t} else if (!pmd_present(*pvmw->pmd)) {\n\t\t\tif (thp_migration_supported()) {\n\t\t\t\tif (!(pvmw->flags & PVMW_MIGRATION))\n\t\t\t\t\treturn not_found(pvmw);\n\t\t\t\tif (is_migration_entry(pmd_to_swp_entry(*pvmw->pmd))) {\n\t\t\t\t\tswp_entry_t entry = pmd_to_swp_entry(*pvmw->pmd);\n\n\t\t\t\t\tif (migration_entry_to_page(entry) != page)\n\t\t\t\t\t\treturn not_found(pvmw);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn not_found(pvmw);\n\t\t} else {\n\t\t\t/* THP pmd was split under us: handle on pte level */\n\t\t\tspin_unlock(pvmw->ptl);\n\t\t\tpvmw->ptl = NULL;\n\t\t}\n\t} else if (!pmd_present(pmde)) {\n\t\treturn false;\n\t}\n\tif (!map_pte(pvmw))\n\t\tgoto next_pte;\n\twhile (1) {\n\t\tif (check_pte(pvmw))\n\t\t\treturn true;\nnext_pte:\n\t\t/* Seek to next pte only makes sense for THP */\n\t\tif (!PageTransHuge(pvmw->page) || PageHuge(pvmw->page))\n\t\t\treturn not_found(pvmw);\n\t\tdo {\n\t\t\tpvmw->address += PAGE_SIZE;\n\t\t\tif (pvmw->address >= pvmw->vma->vm_end ||\n\t\t\t    pvmw->address >=\n\t\t\t\t\t__vma_address(pvmw->page, pvmw->vma) +\n\t\t\t\t\thpage_nr_pages(pvmw->page) * PAGE_SIZE)\n\t\t\t\treturn not_found(pvmw);\n\t\t\t/* Did we cross page table boundary? */\n\t\t\tif (pvmw->address % PMD_SIZE == 0) {\n\t\t\t\tpte_unmap(pvmw->pte);\n\t\t\t\tif (pvmw->ptl) {\n\t\t\t\t\tspin_unlock(pvmw->ptl);\n\t\t\t\t\tpvmw->ptl = NULL;\n\t\t\t\t}\n\t\t\t\tgoto restart;\n\t\t\t} else {\n\t\t\t\tpvmw->pte++;\n\t\t\t}\n\t\t} while (pte_none(*pvmw->pte));\n\n\t\tif (!pvmw->ptl) {\n\t\t\tpvmw->ptl = pte_lockptr(mm, pvmw->pmd);\n\t\t\tspin_lock(pvmw->ptl);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/hugetlb.h>\n#include <linux/rmap.h>\n#include <linux/mm.h>\n\nbool page_vma_mapped_walk(struct page_vma_mapped_walk *pvmw)\n{\n\tstruct mm_struct *mm = pvmw->vma->vm_mm;\n\tstruct page *page = pvmw->page;\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t pmde;\n\n\t/* The only possible pmd mapping has been handled on last iteration */\n\tif (pvmw->pmd && !pvmw->pte)\n\t\treturn not_found(pvmw);\n\n\tif (pvmw->pte)\n\t\tgoto next_pte;\n\n\tif (unlikely(PageHuge(pvmw->page))) {\n\t\t/* when pud is not present, pte will be NULL */\n\t\tpvmw->pte = huge_pte_offset(mm, pvmw->address,\n\t\t\t\t\t    PAGE_SIZE << compound_order(page));\n\t\tif (!pvmw->pte)\n\t\t\treturn false;\n\n\t\tpvmw->ptl = huge_pte_lockptr(page_hstate(page), mm, pvmw->pte);\n\t\tspin_lock(pvmw->ptl);\n\t\tif (!check_pte(pvmw))\n\t\t\treturn not_found(pvmw);\n\t\treturn true;\n\t}\nrestart:\n\tpgd = pgd_offset(mm, pvmw->address);\n\tif (!pgd_present(*pgd))\n\t\treturn false;\n\tp4d = p4d_offset(pgd, pvmw->address);\n\tif (!p4d_present(*p4d))\n\t\treturn false;\n\tpud = pud_offset(p4d, pvmw->address);\n\tif (!pud_present(*pud))\n\t\treturn false;\n\tpvmw->pmd = pmd_offset(pud, pvmw->address);\n\t/*\n\t * Make sure the pmd value isn't cached in a register by the\n\t * compiler and used as a stale value after we've observed a\n\t * subsequent update.\n\t */\n\tpmde = READ_ONCE(*pvmw->pmd);\n\tif (pmd_trans_huge(pmde) || is_pmd_migration_entry(pmde)) {\n\t\tpvmw->ptl = pmd_lock(mm, pvmw->pmd);\n\t\tif (likely(pmd_trans_huge(*pvmw->pmd))) {\n\t\t\tif (pvmw->flags & PVMW_MIGRATION)\n\t\t\t\treturn not_found(pvmw);\n\t\t\tif (pmd_page(*pvmw->pmd) != page)\n\t\t\t\treturn not_found(pvmw);\n\t\t\treturn true;\n\t\t} else if (!pmd_present(*pvmw->pmd)) {\n\t\t\tif (thp_migration_supported()) {\n\t\t\t\tif (!(pvmw->flags & PVMW_MIGRATION))\n\t\t\t\t\treturn not_found(pvmw);\n\t\t\t\tif (is_migration_entry(pmd_to_swp_entry(*pvmw->pmd))) {\n\t\t\t\t\tswp_entry_t entry = pmd_to_swp_entry(*pvmw->pmd);\n\n\t\t\t\t\tif (migration_entry_to_page(entry) != page)\n\t\t\t\t\t\treturn not_found(pvmw);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn not_found(pvmw);\n\t\t} else {\n\t\t\t/* THP pmd was split under us: handle on pte level */\n\t\t\tspin_unlock(pvmw->ptl);\n\t\t\tpvmw->ptl = NULL;\n\t\t}\n\t} else if (!pmd_present(pmde)) {\n\t\treturn false;\n\t}\n\tif (!map_pte(pvmw))\n\t\tgoto next_pte;\n\twhile (1) {\n\t\tif (check_pte(pvmw))\n\t\t\treturn true;\nnext_pte:\n\t\t/* Seek to next pte only makes sense for THP */\n\t\tif (!PageTransHuge(pvmw->page) || PageHuge(pvmw->page))\n\t\t\treturn not_found(pvmw);\n\t\tdo {\n\t\t\tpvmw->address += PAGE_SIZE;\n\t\t\tif (pvmw->address >= pvmw->vma->vm_end ||\n\t\t\t    pvmw->address >=\n\t\t\t\t\t__vma_address(pvmw->page, pvmw->vma) +\n\t\t\t\t\thpage_nr_pages(pvmw->page) * PAGE_SIZE)\n\t\t\t\treturn not_found(pvmw);\n\t\t\t/* Did we cross page table boundary? */\n\t\t\tif (pvmw->address % PMD_SIZE == 0) {\n\t\t\t\tpte_unmap(pvmw->pte);\n\t\t\t\tif (pvmw->ptl) {\n\t\t\t\t\tspin_unlock(pvmw->ptl);\n\t\t\t\t\tpvmw->ptl = NULL;\n\t\t\t\t}\n\t\t\t\tgoto restart;\n\t\t\t} else {\n\t\t\t\tpvmw->pte++;\n\t\t\t}\n\t\t} while (pte_none(*pvmw->pte));\n\n\t\tif (!pvmw->ptl) {\n\t\t\tpvmw->ptl = pte_lockptr(mm, pvmw->pmd);\n\t\t\tspin_lock(pvmw->ptl);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageTail(page)",
            "page"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTail",
          "args": [
            "page"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nstatic bool remove_migration_pte(struct page *page, struct vm_area_struct *vma,\n\t\t\t\t unsigned long addr, void *old)\n{\n\tstruct page_vma_mapped_walk pvmw = {\n\t\t.page = old,\n\t\t.vma = vma,\n\t\t.address = addr,\n\t\t.flags = PVMW_SYNC | PVMW_MIGRATION,\n\t};\n\tstruct page *new;\n\tpte_t pte;\n\tswp_entry_t entry;\n\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\twhile (page_vma_mapped_walk(&pvmw)) {\n\t\tif (PageKsm(page))\n\t\t\tnew = page;\n\t\telse\n\t\t\tnew = page - pvmw.page->index +\n\t\t\t\tlinear_page_index(vma, pvmw.address);\n\n#ifdef CONFIG_ARCH_ENABLE_THP_MIGRATION\n\t\t/* PMD-mapped THP migration entry */\n\t\tif (!pvmw.pte) {\n\t\t\tVM_BUG_ON_PAGE(PageHuge(page) || !PageTransCompound(page), page);\n\t\t\tremove_migration_pmd(&pvmw, new);\n\t\t\tcontinue;\n\t\t}\n#endif\n\n\t\tget_page(new);\n\t\tpte = pte_mkold(mk_pte(new, READ_ONCE(vma->vm_page_prot)));\n\t\tif (pte_swp_soft_dirty(*pvmw.pte))\n\t\t\tpte = pte_mksoft_dirty(pte);\n\n\t\t/*\n\t\t * Recheck VMA as permissions can change since migration started\n\t\t */\n\t\tentry = pte_to_swp_entry(*pvmw.pte);\n\t\tif (is_write_migration_entry(entry))\n\t\t\tpte = maybe_mkwrite(pte, vma);\n\n\t\tif (unlikely(is_zone_device_page(new))) {\n\t\t\tif (is_device_private_page(new)) {\n\t\t\t\tentry = make_device_private_entry(new, pte_write(pte));\n\t\t\t\tpte = swp_entry_to_pte(entry);\n\t\t\t} else if (is_device_public_page(new)) {\n\t\t\t\tpte = pte_mkdevmap(pte);\n\t\t\t\tflush_dcache_page(new);\n\t\t\t}\n\t\t} else\n\t\t\tflush_dcache_page(new);\n\n#ifdef CONFIG_HUGETLB_PAGE\n\t\tif (PageHuge(new)) {\n\t\t\tpte = pte_mkhuge(pte);\n\t\t\tpte = arch_make_huge_pte(pte, vma, new, 0);\n\t\t\tset_huge_pte_at(vma->vm_mm, pvmw.address, pvmw.pte, pte);\n\t\t\tif (PageAnon(new))\n\t\t\t\thugepage_add_anon_rmap(new, vma, pvmw.address);\n\t\t\telse\n\t\t\t\tpage_dup_rmap(new, true);\n\t\t} else\n#endif\n\t\t{\n\t\t\tset_pte_at(vma->vm_mm, pvmw.address, pvmw.pte, pte);\n\n\t\t\tif (PageAnon(new))\n\t\t\t\tpage_add_anon_rmap(new, vma, pvmw.address, false);\n\t\t\telse\n\t\t\t\tpage_add_file_rmap(new, false);\n\t\t}\n\t\tif (vma->vm_flags & VM_LOCKED && !PageTransCompound(new))\n\t\t\tmlock_vma_page(new);\n\n\t\tif (PageTransHuge(page) && PageMlocked(page))\n\t\t\tclear_page_mlock(page);\n\n\t\t/* No need to invalidate - it was non-present before */\n\t\tupdate_mmu_cache(vma, pvmw.address, pvmw.pte);\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "putback_movable_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "167-198",
    "snippet": "void putback_movable_pages(struct list_head *l)\n{\n\tstruct page *page;\n\tstruct page *page2;\n\n\tlist_for_each_entry_safe(page, page2, l, lru) {\n\t\tif (unlikely(PageHuge(page))) {\n\t\t\tputback_active_hugepage(page);\n\t\t\tcontinue;\n\t\t}\n\t\tlist_del(&page->lru);\n\t\t/*\n\t\t * We isolated non-lru movable page so here we can use\n\t\t * __PageMovable because LRU page's mapping cannot have\n\t\t * PAGE_MAPPING_MOVABLE.\n\t\t */\n\t\tif (unlikely(__PageMovable(page))) {\n\t\t\tVM_BUG_ON_PAGE(!PageIsolated(page), page);\n\t\t\tlock_page(page);\n\t\t\tif (PageMovable(page))\n\t\t\t\tputback_movable_page(page);\n\t\t\telse\n\t\t\t\t__ClearPageIsolated(page);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t} else {\n\t\t\tmod_node_page_state(page_pgdat(page), NR_ISOLATED_ANON +\n\t\t\t\t\tpage_is_file_cache(page), -hpage_nr_pages(page));\n\t\t\tputback_lru_page(page);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "putback_lru_page",
          "args": [
            "page"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "putback_lru_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1005-1009",
          "snippet": "void putback_lru_page(struct page *page)\n{\n\tlru_cache_add(page);\n\tput_page(page);\t\t/* drop ref from isolate */\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid putback_lru_page(struct page *page)\n{\n\tlru_cache_add(page);\n\tput_page(page);\t\t/* drop ref from isolate */\n}"
        }
      },
      {
        "call_info": {
          "callee": "mod_node_page_state",
          "args": [
            "page_pgdat(page)",
            "NR_ISOLATED_ANON +\n\t\t\t\t\tpage_is_file_cache(page)",
            "-hpage_nr_pages(page)"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "mod_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "644-652",
          "snippet": "void mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,\n\t\t\t\t\tlong delta)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__mod_node_page_state(pgdat, item, delta);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,\n\t\t\t\t\tlong delta)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__mod_node_page_state(pgdat, item, delta);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "page"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_is_file_cache",
          "args": [
            "page"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_pgdat",
          "args": [
            "page"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ClearPageIsolated",
          "args": [
            "page"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "putback_movable_page",
          "args": [
            "page"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "putback_movable_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "167-198",
          "snippet": "void putback_movable_pages(struct list_head *l)\n{\n\tstruct page *page;\n\tstruct page *page2;\n\n\tlist_for_each_entry_safe(page, page2, l, lru) {\n\t\tif (unlikely(PageHuge(page))) {\n\t\t\tputback_active_hugepage(page);\n\t\t\tcontinue;\n\t\t}\n\t\tlist_del(&page->lru);\n\t\t/*\n\t\t * We isolated non-lru movable page so here we can use\n\t\t * __PageMovable because LRU page's mapping cannot have\n\t\t * PAGE_MAPPING_MOVABLE.\n\t\t */\n\t\tif (unlikely(__PageMovable(page))) {\n\t\t\tVM_BUG_ON_PAGE(!PageIsolated(page), page);\n\t\t\tlock_page(page);\n\t\t\tif (PageMovable(page))\n\t\t\t\tputback_movable_page(page);\n\t\t\telse\n\t\t\t\t__ClearPageIsolated(page);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t} else {\n\t\t\tmod_node_page_state(page_pgdat(page), NR_ISOLATED_ANON +\n\t\t\t\t\tpage_is_file_cache(page), -hpage_nr_pages(page));\n\t\t\tputback_lru_page(page);\n\t\t}\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "PageMovable",
          "args": [
            "page"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "__ClearPageMovable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "120-131",
          "snippet": "void __ClearPageMovable(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(!PageMovable(page), page);\n\t/*\n\t * Clear registered address_space val with keeping PAGE_MAPPING_MOVABLE\n\t * flag so that VM can catch up released page by driver after isolation.\n\t * With it, VM migration doesn't try to put it back.\n\t */\n\tpage->mapping = (void *)((unsigned long)page->mapping &\n\t\t\t\tPAGE_MAPPING_MOVABLE);\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nvoid __ClearPageMovable(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(!PageMovable(page), page);\n\t/*\n\t * Clear registered address_space val with keeping PAGE_MAPPING_MOVABLE\n\t * flag so that VM can catch up released page by driver after isolation.\n\t * With it, VM migration doesn't try to put it back.\n\t */\n\tpage->mapping = (void *)((unsigned long)page->mapping &\n\t\t\t\tPAGE_MAPPING_MOVABLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageIsolated(page)",
            "page"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageIsolated",
          "args": [
            "page"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "__PageMovable(page)"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__PageMovable",
          "args": [
            "page"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "putback_active_hugepage",
          "args": [
            "page"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "putback_active_hugepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "4908-4916",
          "snippet": "void putback_active_hugepage(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageHead(page), page);\n\tspin_lock(&hugetlb_lock);\n\tset_page_huge_active(page);\n\tlist_move_tail(&page->lru, &(page_hstate(page))->hugepage_activelist);\n\tspin_unlock(&hugetlb_lock);\n\tput_page(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nvoid putback_active_hugepage(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageHead(page), page);\n\tspin_lock(&hugetlb_lock);\n\tset_page_huge_active(page);\n\tlist_move_tail(&page->lru, &(page_hstate(page))->hugepage_activelist);\n\tspin_unlock(&hugetlb_lock);\n\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "PageHuge(page)"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "page"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "PageHugeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "225-228",
          "snippet": "static int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "page",
            "page2",
            "l",
            "lru"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nvoid putback_movable_pages(struct list_head *l)\n{\n\tstruct page *page;\n\tstruct page *page2;\n\n\tlist_for_each_entry_safe(page, page2, l, lru) {\n\t\tif (unlikely(PageHuge(page))) {\n\t\t\tputback_active_hugepage(page);\n\t\t\tcontinue;\n\t\t}\n\t\tlist_del(&page->lru);\n\t\t/*\n\t\t * We isolated non-lru movable page so here we can use\n\t\t * __PageMovable because LRU page's mapping cannot have\n\t\t * PAGE_MAPPING_MOVABLE.\n\t\t */\n\t\tif (unlikely(__PageMovable(page))) {\n\t\t\tVM_BUG_ON_PAGE(!PageIsolated(page), page);\n\t\t\tlock_page(page);\n\t\t\tif (PageMovable(page))\n\t\t\t\tputback_movable_page(page);\n\t\t\telse\n\t\t\t\t__ClearPageIsolated(page);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t} else {\n\t\t\tmod_node_page_state(page_pgdat(page), NR_ISOLATED_ANON +\n\t\t\t\t\tpage_is_file_cache(page), -hpage_nr_pages(page));\n\t\t\tputback_lru_page(page);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "putback_movable_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "146-157",
    "snippet": "void putback_movable_page(struct page *page)\n{\n\tstruct address_space *mapping;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(!PageMovable(page), page);\n\tVM_BUG_ON_PAGE(!PageIsolated(page), page);\n\n\tmapping = page_mapping(page);\n\tmapping->a_ops->putback_page(page);\n\t__ClearPageIsolated(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ClearPageIsolated",
          "args": [
            "page"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping->a_ops->putback_page",
          "args": [
            "page"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "page"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapping_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "528-533",
          "snippet": "struct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageIsolated(page)",
            "page"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageIsolated",
          "args": [
            "page"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageMovable(page)",
            "page"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageMovable",
          "args": [
            "page"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "__ClearPageMovable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "120-131",
          "snippet": "void __ClearPageMovable(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(!PageMovable(page), page);\n\t/*\n\t * Clear registered address_space val with keeping PAGE_MAPPING_MOVABLE\n\t * flag so that VM can catch up released page by driver after isolation.\n\t * With it, VM migration doesn't try to put it back.\n\t */\n\tpage->mapping = (void *)((unsigned long)page->mapping &\n\t\t\t\tPAGE_MAPPING_MOVABLE);\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nvoid __ClearPageMovable(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(!PageMovable(page), page);\n\t/*\n\t * Clear registered address_space val with keeping PAGE_MAPPING_MOVABLE\n\t * flag so that VM can catch up released page by driver after isolation.\n\t * With it, VM migration doesn't try to put it back.\n\t */\n\tpage->mapping = (void *)((unsigned long)page->mapping &\n\t\t\t\tPAGE_MAPPING_MOVABLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLocked(page)",
            "page"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nvoid putback_movable_page(struct page *page)\n{\n\tstruct address_space *mapping;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(!PageMovable(page), page);\n\tVM_BUG_ON_PAGE(!PageIsolated(page), page);\n\n\tmapping = page_mapping(page);\n\tmapping->a_ops->putback_page(page);\n\t__ClearPageIsolated(page);\n}"
  },
  {
    "function_name": "isolate_movable_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "84-143",
    "snippet": "int isolate_movable_page(struct page *page, isolate_mode_t mode)\n{\n\tstruct address_space *mapping;\n\n\t/*\n\t * Avoid burning cycles with pages that are yet under __free_pages(),\n\t * or just got freed under us.\n\t *\n\t * In case we 'win' a race for a movable page being freed under us and\n\t * raise its refcount preventing __free_pages() from doing its job\n\t * the put_page() at the end of this block will take care of\n\t * release this page, thus avoiding a nasty leakage.\n\t */\n\tif (unlikely(!get_page_unless_zero(page)))\n\t\tgoto out;\n\n\t/*\n\t * Check PageMovable before holding a PG_lock because page's owner\n\t * assumes anybody doesn't touch PG_lock of newly allocated page\n\t * so unconditionally grapping the lock ruins page's owner side.\n\t */\n\tif (unlikely(!__PageMovable(page)))\n\t\tgoto out_putpage;\n\t/*\n\t * As movable pages are not isolated from LRU lists, concurrent\n\t * compaction threads can race against page migration functions\n\t * as well as race against the releasing a page.\n\t *\n\t * In order to avoid having an already isolated movable page\n\t * being (wrongly) re-isolated while it is under migration,\n\t * or to avoid attempting to isolate pages being released,\n\t * lets be sure we have the page lock\n\t * before proceeding with the movable page isolation steps.\n\t */\n\tif (unlikely(!trylock_page(page)))\n\t\tgoto out_putpage;\n\n\tif (!PageMovable(page) || PageIsolated(page))\n\t\tgoto out_no_isolated;\n\n\tmapping = page_mapping(page);\n\tVM_BUG_ON_PAGE(!mapping, page);\n\n\tif (!mapping->a_ops->isolate_page(page, mode))\n\t\tgoto out_no_isolated;\n\n\t/* Driver shouldn't use PG_isolated bit of page->flags */\n\tWARN_ON_ONCE(PageIsolated(page));\n\t__SetPageIsolated(page);\n\tunlock_page(page);\n\n\treturn 0;\n\nout_no_isolated:\n\tunlock_page(page);\nout_putpage:\n\tput_page(page);\nout:\n\treturn -EBUSY;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__SetPageIsolated",
          "args": [
            "page"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "PageIsolated(page)"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageIsolated",
          "args": [
            "page"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping->a_ops->isolate_page",
          "args": [
            "page",
            "mode"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!mapping",
            "page"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "page"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapping_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "528-533",
          "snippet": "struct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageIsolated",
          "args": [
            "page"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageMovable",
          "args": [
            "page"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "__ClearPageMovable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "120-131",
          "snippet": "void __ClearPageMovable(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(!PageMovable(page), page);\n\t/*\n\t * Clear registered address_space val with keeping PAGE_MAPPING_MOVABLE\n\t * flag so that VM can catch up released page by driver after isolation.\n\t * With it, VM migration doesn't try to put it back.\n\t */\n\tpage->mapping = (void *)((unsigned long)page->mapping &\n\t\t\t\tPAGE_MAPPING_MOVABLE);\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nvoid __ClearPageMovable(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(!PageMovable(page), page);\n\t/*\n\t * Clear registered address_space val with keeping PAGE_MAPPING_MOVABLE\n\t * flag so that VM can catch up released page by driver after isolation.\n\t * With it, VM migration doesn't try to put it back.\n\t */\n\tpage->mapping = (void *)((unsigned long)page->mapping &\n\t\t\t\tPAGE_MAPPING_MOVABLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!trylock_page(page)"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!__PageMovable(page)"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__PageMovable",
          "args": [
            "page"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!get_page_unless_zero(page)"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page_unless_zero",
          "args": [
            "page"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nint isolate_movable_page(struct page *page, isolate_mode_t mode)\n{\n\tstruct address_space *mapping;\n\n\t/*\n\t * Avoid burning cycles with pages that are yet under __free_pages(),\n\t * or just got freed under us.\n\t *\n\t * In case we 'win' a race for a movable page being freed under us and\n\t * raise its refcount preventing __free_pages() from doing its job\n\t * the put_page() at the end of this block will take care of\n\t * release this page, thus avoiding a nasty leakage.\n\t */\n\tif (unlikely(!get_page_unless_zero(page)))\n\t\tgoto out;\n\n\t/*\n\t * Check PageMovable before holding a PG_lock because page's owner\n\t * assumes anybody doesn't touch PG_lock of newly allocated page\n\t * so unconditionally grapping the lock ruins page's owner side.\n\t */\n\tif (unlikely(!__PageMovable(page)))\n\t\tgoto out_putpage;\n\t/*\n\t * As movable pages are not isolated from LRU lists, concurrent\n\t * compaction threads can race against page migration functions\n\t * as well as race against the releasing a page.\n\t *\n\t * In order to avoid having an already isolated movable page\n\t * being (wrongly) re-isolated while it is under migration,\n\t * or to avoid attempting to isolate pages being released,\n\t * lets be sure we have the page lock\n\t * before proceeding with the movable page isolation steps.\n\t */\n\tif (unlikely(!trylock_page(page)))\n\t\tgoto out_putpage;\n\n\tif (!PageMovable(page) || PageIsolated(page))\n\t\tgoto out_no_isolated;\n\n\tmapping = page_mapping(page);\n\tVM_BUG_ON_PAGE(!mapping, page);\n\n\tif (!mapping->a_ops->isolate_page(page, mode))\n\t\tgoto out_no_isolated;\n\n\t/* Driver shouldn't use PG_isolated bit of page->flags */\n\tWARN_ON_ONCE(PageIsolated(page));\n\t__SetPageIsolated(page);\n\tunlock_page(page);\n\n\treturn 0;\n\nout_no_isolated:\n\tunlock_page(page);\nout_putpage:\n\tput_page(page);\nout:\n\treturn -EBUSY;\n}"
  },
  {
    "function_name": "migrate_prep_local",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "77-82",
    "snippet": "int migrate_prep_local(void)\n{\n\tlru_add_drain();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lru_add_drain",
          "args": [],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "lru_add_drain_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "670-704",
          "snippet": "void lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);",
            "static DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);",
            "static DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\nstatic DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);\nstatic DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);\n\nvoid lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nint migrate_prep_local(void)\n{\n\tlru_add_drain();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "migrate_prep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "63-74",
    "snippet": "int migrate_prep(void)\n{\n\t/*\n\t * Clear the LRU lists so pages can be isolated.\n\t * Note that pages may be moved off the LRU after we have\n\t * drained them. Those pages will fail to migrate like other\n\t * pages that may be busy.\n\t */\n\tlru_add_drain_all();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lru_add_drain_all",
          "args": [],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "lru_add_drain_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "670-704",
          "snippet": "void lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);",
            "static DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);",
            "static DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\nstatic DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);\nstatic DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);\n\nvoid lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nint migrate_prep(void)\n{\n\t/*\n\t * Clear the LRU lists so pages can be isolated.\n\t * Note that pages may be moved off the LRU after we have\n\t * drained them. Those pages will fail to migrate like other\n\t * pages that may be busy.\n\t */\n\tlru_add_drain_all();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "move_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "1779-1785",
    "snippet": "SYSCALL_DEFINE6(move_pages, pid_t, pid, unsigned long, nr_pages,\n\t\tconst void __user * __user *, pages,\n\t\tconst int __user *, nodes,\n\t\tint __user *, status, int, flags)\n{\n\treturn kernel_move_pages(pid, nr_pages, pages, nodes, status, flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nSYSCALL_DEFINE6(move_pages, pid_t, pid, unsigned long, nr_pages,\n\t\tconst void __user * __user *, pages,\n\t\tconst int __user *, nodes,\n\t\tint __user *, status, int, flags)\n{\n\treturn kernel_move_pages(pid, nr_pages, pages, nodes, status, flags);\n}"
  },
  {
    "function_name": "move_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
    "lines": "1788-1806",
    "snippet": "SYSCALL_DEFINE6(move_pages, pid_t, pid, compat_ulong_t, nr_pages,\n\t\t       compat_uptr_t __user *, pages32,\n\t\t       const int __user *, nodes,\n\t\t       int __user *, status,\n\t\t       int, flags)\n{\n\tconst void __user * __user *pages;\n\tint i;\n\n\tpages = compat_alloc_user_space(nr_pages * sizeof(void *));\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tcompat_uptr_t p;\n\n\t\tif (get_user(p, pages32 + i) ||\n\t\t\tput_user(compat_ptr(p), pages + i))\n\t\t\treturn -EFAULT;\n\t}\n\treturn kernel_move_pages(pid, nr_pages, pages, nodes, status, flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/migrate.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/balloon_compaction.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/memremap.h>",
      "#include <linux/pfn_t.h>",
      "#include <linux/gfp.h>",
      "#include <linux/hugetlb_cgroup.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/compaction.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/writeback.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/topology.h>",
      "#include <linux/rmap.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/migrate.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nSYSCALL_DEFINE6(move_pages, pid_t, pid, compat_ulong_t, nr_pages,\n\t\t       compat_uptr_t __user *, pages32,\n\t\t       const int __user *, nodes,\n\t\t       int __user *, status,\n\t\t       int, flags)\n{\n\tconst void __user * __user *pages;\n\tint i;\n\n\tpages = compat_alloc_user_space(nr_pages * sizeof(void *));\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tcompat_uptr_t p;\n\n\t\tif (get_user(p, pages32 + i) ||\n\t\t\tput_user(compat_ptr(p), pages + i))\n\t\t\treturn -EFAULT;\n\t}\n\treturn kernel_move_pages(pid, nr_pages, pages, nodes, status, flags);\n}"
  }
]