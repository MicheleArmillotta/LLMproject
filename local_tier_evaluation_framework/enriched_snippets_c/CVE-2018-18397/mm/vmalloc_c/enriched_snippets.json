[
  {
    "function_name": "proc_vmalloc_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "2741-2750",
    "snippet": "static int __init proc_vmalloc_init(void)\n{\n\tif (IS_ENABLED(CONFIG_NUMA))\n\t\tproc_create_seq_private(\"vmallocinfo\", 0400, NULL,\n\t\t\t\t&vmalloc_op,\n\t\t\t\tnr_node_ids * sizeof(unsigned int), NULL);\n\telse\n\t\tproc_create_seq(\"vmallocinfo\", 0400, NULL, &vmalloc_op);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_create_seq",
          "args": [
            "\"vmallocinfo\"",
            "0400",
            "NULL",
            "&vmalloc_op"
          ],
          "line": 2748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create_seq_private",
          "args": [
            "\"vmallocinfo\"",
            "0400",
            "NULL",
            "&vmalloc_op",
            "nr_node_ids * sizeof(unsigned int)",
            "NULL"
          ],
          "line": 2744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_NUMA"
          ],
          "line": 2743
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic int __init proc_vmalloc_init(void)\n{\n\tif (IS_ENABLED(CONFIG_NUMA))\n\t\tproc_create_seq_private(\"vmallocinfo\", 0400, NULL,\n\t\t\t\t&vmalloc_op,\n\t\t\t\tnr_node_ids * sizeof(unsigned int), NULL);\n\telse\n\t\tproc_create_seq(\"vmallocinfo\", 0400, NULL, &vmalloc_op);\n\treturn 0;\n}"
  },
  {
    "function_name": "s_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "2680-2732",
    "snippet": "static int s_show(struct seq_file *m, void *p)\n{\n\tstruct vmap_area *va;\n\tstruct vm_struct *v;\n\n\tva = list_entry(p, struct vmap_area, list);\n\n\t/*\n\t * s_show can encounter race with remove_vm_area, !VM_VM_AREA on\n\t * behalf of vmap area is being tear down or vm_map_ram allocation.\n\t */\n\tif (!(va->flags & VM_VM_AREA)) {\n\t\tseq_printf(m, \"0x%pK-0x%pK %7ld %s\\n\",\n\t\t\t(void *)va->va_start, (void *)va->va_end,\n\t\t\tva->va_end - va->va_start,\n\t\t\tva->flags & VM_LAZY_FREE ? \"unpurged vm_area\" : \"vm_map_ram\");\n\n\t\treturn 0;\n\t}\n\n\tv = va->vm;\n\n\tseq_printf(m, \"0x%pK-0x%pK %7ld\",\n\t\tv->addr, v->addr + v->size, v->size);\n\n\tif (v->caller)\n\t\tseq_printf(m, \" %pS\", v->caller);\n\n\tif (v->nr_pages)\n\t\tseq_printf(m, \" pages=%d\", v->nr_pages);\n\n\tif (v->phys_addr)\n\t\tseq_printf(m, \" phys=%pa\", &v->phys_addr);\n\n\tif (v->flags & VM_IOREMAP)\n\t\tseq_puts(m, \" ioremap\");\n\n\tif (v->flags & VM_ALLOC)\n\t\tseq_puts(m, \" vmalloc\");\n\n\tif (v->flags & VM_MAP)\n\t\tseq_puts(m, \" vmap\");\n\n\tif (v->flags & VM_USERMAP)\n\t\tseq_puts(m, \" user\");\n\n\tif (is_vmalloc_addr(v->pages))\n\t\tseq_puts(m, \" vpages\");\n\n\tshow_numa_info(m, v);\n\tseq_putc(m, '\\n');\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [
      "#define VM_VM_AREA\t0x04",
      "#define VM_LAZY_FREE\t0x02"
    ],
    "globals_used": [
      "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 2730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_numa_info",
          "args": [
            "m",
            "v"
          ],
          "line": 2729
        },
        "resolved": true,
        "details": {
          "function_name": "show_numa_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "2656-2678",
          "snippet": "static void show_numa_info(struct seq_file *m, struct vm_struct *v)\n{\n\tif (IS_ENABLED(CONFIG_NUMA)) {\n\t\tunsigned int nr, *counters = m->private;\n\n\t\tif (!counters)\n\t\t\treturn;\n\n\t\tif (v->flags & VM_UNINITIALIZED)\n\t\t\treturn;\n\t\t/* Pair with smp_wmb() in clear_vm_uninitialized_flag() */\n\t\tsmp_rmb();\n\n\t\tmemset(counters, 0, nr_node_ids * sizeof(unsigned int));\n\n\t\tfor (nr = 0; nr < v->nr_pages; nr++)\n\t\t\tcounters[page_to_nid(v->pages[nr])]++;\n\n\t\tfor_each_node_state(nr, N_HIGH_MEMORY)\n\t\t\tif (counters[nr])\n\t\t\t\tseq_printf(m, \" N%u=%u\", nr, counters[nr]);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void show_numa_info(struct seq_file *m, struct vm_struct *v)\n{\n\tif (IS_ENABLED(CONFIG_NUMA)) {\n\t\tunsigned int nr, *counters = m->private;\n\n\t\tif (!counters)\n\t\t\treturn;\n\n\t\tif (v->flags & VM_UNINITIALIZED)\n\t\t\treturn;\n\t\t/* Pair with smp_wmb() in clear_vm_uninitialized_flag() */\n\t\tsmp_rmb();\n\n\t\tmemset(counters, 0, nr_node_ids * sizeof(unsigned int));\n\n\t\tfor (nr = 0; nr < v->nr_pages; nr++)\n\t\t\tcounters[page_to_nid(v->pages[nr])]++;\n\n\t\tfor_each_node_state(nr, N_HIGH_MEMORY)\n\t\t\tif (counters[nr])\n\t\t\t\tseq_printf(m, \" N%u=%u\", nr, counters[nr]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\" vpages\""
          ],
          "line": 2727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vmalloc_addr",
          "args": [
            "v->pages"
          ],
          "line": 2726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\" user\""
          ],
          "line": 2724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\" vmap\""
          ],
          "line": 2721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\" vmalloc\""
          ],
          "line": 2718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\" ioremap\""
          ],
          "line": 2715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" phys=%pa\"",
            "&v->phys_addr"
          ],
          "line": 2712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" pages=%d\"",
            "v->nr_pages"
          ],
          "line": 2709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" %pS\"",
            "v->caller"
          ],
          "line": 2706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"0x%pK-0x%pK %7ld\"",
            "v->addr",
            "v->addr + v->size",
            "v->size"
          ],
          "line": 2702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"0x%pK-0x%pK %7ld %s\\n\"",
            "(void *)va->va_start",
            "(void *)va->va_end",
            "va->va_end - va->va_start",
            "va->flags & VM_LAZY_FREE ? \"unpurged vm_area\" : \"vm_map_ram\""
          ],
          "line": 2692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "p",
            "structvmap_area",
            "list"
          ],
          "line": 2685
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\n#define VM_VM_AREA\t0x04\n#define VM_LAZY_FREE\t0x02\n\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);\n\nstatic int s_show(struct seq_file *m, void *p)\n{\n\tstruct vmap_area *va;\n\tstruct vm_struct *v;\n\n\tva = list_entry(p, struct vmap_area, list);\n\n\t/*\n\t * s_show can encounter race with remove_vm_area, !VM_VM_AREA on\n\t * behalf of vmap area is being tear down or vm_map_ram allocation.\n\t */\n\tif (!(va->flags & VM_VM_AREA)) {\n\t\tseq_printf(m, \"0x%pK-0x%pK %7ld %s\\n\",\n\t\t\t(void *)va->va_start, (void *)va->va_end,\n\t\t\tva->va_end - va->va_start,\n\t\t\tva->flags & VM_LAZY_FREE ? \"unpurged vm_area\" : \"vm_map_ram\");\n\n\t\treturn 0;\n\t}\n\n\tv = va->vm;\n\n\tseq_printf(m, \"0x%pK-0x%pK %7ld\",\n\t\tv->addr, v->addr + v->size, v->size);\n\n\tif (v->caller)\n\t\tseq_printf(m, \" %pS\", v->caller);\n\n\tif (v->nr_pages)\n\t\tseq_printf(m, \" pages=%d\", v->nr_pages);\n\n\tif (v->phys_addr)\n\t\tseq_printf(m, \" phys=%pa\", &v->phys_addr);\n\n\tif (v->flags & VM_IOREMAP)\n\t\tseq_puts(m, \" ioremap\");\n\n\tif (v->flags & VM_ALLOC)\n\t\tseq_puts(m, \" vmalloc\");\n\n\tif (v->flags & VM_MAP)\n\t\tseq_puts(m, \" vmap\");\n\n\tif (v->flags & VM_USERMAP)\n\t\tseq_puts(m, \" user\");\n\n\tif (is_vmalloc_addr(v->pages))\n\t\tseq_puts(m, \" vpages\");\n\n\tshow_numa_info(m, v);\n\tseq_putc(m, '\\n');\n\treturn 0;\n}"
  },
  {
    "function_name": "show_numa_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "2656-2678",
    "snippet": "static void show_numa_info(struct seq_file *m, struct vm_struct *v)\n{\n\tif (IS_ENABLED(CONFIG_NUMA)) {\n\t\tunsigned int nr, *counters = m->private;\n\n\t\tif (!counters)\n\t\t\treturn;\n\n\t\tif (v->flags & VM_UNINITIALIZED)\n\t\t\treturn;\n\t\t/* Pair with smp_wmb() in clear_vm_uninitialized_flag() */\n\t\tsmp_rmb();\n\n\t\tmemset(counters, 0, nr_node_ids * sizeof(unsigned int));\n\n\t\tfor (nr = 0; nr < v->nr_pages; nr++)\n\t\t\tcounters[page_to_nid(v->pages[nr])]++;\n\n\t\tfor_each_node_state(nr, N_HIGH_MEMORY)\n\t\t\tif (counters[nr])\n\t\t\t\tseq_printf(m, \" N%u=%u\", nr, counters[nr]);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" N%u=%u\"",
            "nr",
            "counters[nr]"
          ],
          "line": 2676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_node_state",
          "args": [
            "nr",
            "N_HIGH_MEMORY"
          ],
          "line": 2674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "v->pages[nr]"
          ],
          "line": 2672
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "counters",
            "0",
            "nr_node_ids * sizeof(unsigned int)"
          ],
          "line": 2669
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 2667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_NUMA"
          ],
          "line": 2658
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void show_numa_info(struct seq_file *m, struct vm_struct *v)\n{\n\tif (IS_ENABLED(CONFIG_NUMA)) {\n\t\tunsigned int nr, *counters = m->private;\n\n\t\tif (!counters)\n\t\t\treturn;\n\n\t\tif (v->flags & VM_UNINITIALIZED)\n\t\t\treturn;\n\t\t/* Pair with smp_wmb() in clear_vm_uninitialized_flag() */\n\t\tsmp_rmb();\n\n\t\tmemset(counters, 0, nr_node_ids * sizeof(unsigned int));\n\n\t\tfor (nr = 0; nr < v->nr_pages; nr++)\n\t\t\tcounters[page_to_nid(v->pages[nr])]++;\n\n\t\tfor_each_node_state(nr, N_HIGH_MEMORY)\n\t\t\tif (counters[nr])\n\t\t\t\tseq_printf(m, \" N%u=%u\", nr, counters[nr]);\n\t}\n}"
  },
  {
    "function_name": "s_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "2650-2654",
    "snippet": "static void s_stop(struct seq_file *m, void *p)\n\t__releases(&vmap_area_lock)\n{\n\tspin_unlock(&vmap_area_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(vmap_area_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vmap_area_lock"
          ],
          "line": 2653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&vmap_area_lock"
          ],
          "line": 2651
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic DEFINE_SPINLOCK(vmap_area_lock);\n\nstatic void s_stop(struct seq_file *m, void *p)\n\t__releases(&vmap_area_lock)\n{\n\tspin_unlock(&vmap_area_lock);\n}"
  },
  {
    "function_name": "s_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "2645-2648",
    "snippet": "static void *s_next(struct seq_file *m, void *p, loff_t *pos)\n{\n\treturn seq_list_next(p, &vmap_area_list, pos);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_list_next",
          "args": [
            "p",
            "&vmap_area_list",
            "pos"
          ],
          "line": 2647
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void *s_next(struct seq_file *m, void *p, loff_t *pos)\n{\n\treturn seq_list_next(p, &vmap_area_list, pos);\n}"
  },
  {
    "function_name": "s_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "2638-2643",
    "snippet": "static void *s_start(struct seq_file *m, loff_t *pos)\n\t__acquires(&vmap_area_lock)\n{\n\tspin_lock(&vmap_area_lock);\n\treturn seq_list_start(&vmap_area_list, *pos);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(vmap_area_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_list_start",
          "args": [
            "&vmap_area_list",
            "*pos"
          ],
          "line": 2642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vmap_area_lock"
          ],
          "line": 2641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&vmap_area_lock"
          ],
          "line": 2639
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic DEFINE_SPINLOCK(vmap_area_lock);\n\nstatic void *s_start(struct seq_file *m, loff_t *pos)\n\t__acquires(&vmap_area_lock)\n{\n\tspin_lock(&vmap_area_lock);\n\treturn seq_list_start(&vmap_area_list, *pos);\n}"
  },
  {
    "function_name": "pcpu_free_vm_areas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "2627-2634",
    "snippet": "void pcpu_free_vm_areas(struct vm_struct **vms, int nr_vms)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_vms; i++)\n\t\tfree_vm_area(vms[i]);\n\tkfree(vms);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "vms"
          ],
          "line": 2633
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_vm_area",
          "args": [
            "vms[i]"
          ],
          "line": 2632
        },
        "resolved": true,
        "details": {
          "function_name": "free_vm_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "2353-2359",
          "snippet": "void free_vm_area(struct vm_struct *area)\n{\n\tstruct vm_struct *ret;\n\tret = remove_vm_area(area->addr);\n\tBUG_ON(ret != area);\n\tkfree(area);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nvoid free_vm_area(struct vm_struct *area)\n{\n\tstruct vm_struct *ret;\n\tret = remove_vm_area(area->addr);\n\tBUG_ON(ret != area);\n\tkfree(area);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nvoid pcpu_free_vm_areas(struct vm_struct **vms, int nr_vms)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_vms; i++)\n\t\tfree_vm_area(vms[i]);\n\tkfree(vms);\n}"
  },
  {
    "function_name": "pcpu_get_vm_areas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "2470-2618",
    "snippet": "struct vm_struct **pcpu_get_vm_areas(const unsigned long *offsets,\n\t\t\t\t     const size_t *sizes, int nr_vms,\n\t\t\t\t     size_t align)\n{\n\tconst unsigned long vmalloc_start = ALIGN(VMALLOC_START, align);\n\tconst unsigned long vmalloc_end = VMALLOC_END & ~(align - 1);\n\tstruct vmap_area **vas, *prev, *next;\n\tstruct vm_struct **vms;\n\tint area, area2, last_area, term_area;\n\tunsigned long base, start, end, last_end;\n\tbool purged = false;\n\n\t/* verify parameters and allocate data structures */\n\tBUG_ON(offset_in_page(align) || !is_power_of_2(align));\n\tfor (last_area = 0, area = 0; area < nr_vms; area++) {\n\t\tstart = offsets[area];\n\t\tend = start + sizes[area];\n\n\t\t/* is everything aligned properly? */\n\t\tBUG_ON(!IS_ALIGNED(offsets[area], align));\n\t\tBUG_ON(!IS_ALIGNED(sizes[area], align));\n\n\t\t/* detect the area with the highest address */\n\t\tif (start > offsets[last_area])\n\t\t\tlast_area = area;\n\n\t\tfor (area2 = area + 1; area2 < nr_vms; area2++) {\n\t\t\tunsigned long start2 = offsets[area2];\n\t\t\tunsigned long end2 = start2 + sizes[area2];\n\n\t\t\tBUG_ON(start2 < end && start < end2);\n\t\t}\n\t}\n\tlast_end = offsets[last_area] + sizes[last_area];\n\n\tif (vmalloc_end - vmalloc_start < last_end) {\n\t\tWARN_ON(true);\n\t\treturn NULL;\n\t}\n\n\tvms = kcalloc(nr_vms, sizeof(vms[0]), GFP_KERNEL);\n\tvas = kcalloc(nr_vms, sizeof(vas[0]), GFP_KERNEL);\n\tif (!vas || !vms)\n\t\tgoto err_free2;\n\n\tfor (area = 0; area < nr_vms; area++) {\n\t\tvas[area] = kzalloc(sizeof(struct vmap_area), GFP_KERNEL);\n\t\tvms[area] = kzalloc(sizeof(struct vm_struct), GFP_KERNEL);\n\t\tif (!vas[area] || !vms[area])\n\t\t\tgoto err_free;\n\t}\nretry:\n\tspin_lock(&vmap_area_lock);\n\n\t/* start scanning - we scan from the top, begin with the last area */\n\tarea = term_area = last_area;\n\tstart = offsets[area];\n\tend = start + sizes[area];\n\n\tif (!pvm_find_next_prev(vmap_area_pcpu_hole, &next, &prev)) {\n\t\tbase = vmalloc_end - last_end;\n\t\tgoto found;\n\t}\n\tbase = pvm_determine_end(&next, &prev, align) - end;\n\n\twhile (true) {\n\t\tBUG_ON(next && next->va_end <= base + end);\n\t\tBUG_ON(prev && prev->va_end > base + end);\n\n\t\t/*\n\t\t * base might have underflowed, add last_end before\n\t\t * comparing.\n\t\t */\n\t\tif (base + last_end < vmalloc_start + last_end) {\n\t\t\tspin_unlock(&vmap_area_lock);\n\t\t\tif (!purged) {\n\t\t\t\tpurge_vmap_area_lazy();\n\t\t\t\tpurged = true;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tgoto err_free;\n\t\t}\n\n\t\t/*\n\t\t * If next overlaps, move base downwards so that it's\n\t\t * right below next and then recheck.\n\t\t */\n\t\tif (next && next->va_start < base + end) {\n\t\t\tbase = pvm_determine_end(&next, &prev, align) - end;\n\t\t\tterm_area = area;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If prev overlaps, shift down next and prev and move\n\t\t * base so that it's right below new next and then\n\t\t * recheck.\n\t\t */\n\t\tif (prev && prev->va_end > base + start)  {\n\t\t\tnext = prev;\n\t\t\tprev = node_to_va(rb_prev(&next->rb_node));\n\t\t\tbase = pvm_determine_end(&next, &prev, align) - end;\n\t\t\tterm_area = area;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * This area fits, move on to the previous one.  If\n\t\t * the previous one is the terminal one, we're done.\n\t\t */\n\t\tarea = (area + nr_vms - 1) % nr_vms;\n\t\tif (area == term_area)\n\t\t\tbreak;\n\t\tstart = offsets[area];\n\t\tend = start + sizes[area];\n\t\tpvm_find_next_prev(base + end, &next, &prev);\n\t}\nfound:\n\t/* we've found a fitting base, insert all va's */\n\tfor (area = 0; area < nr_vms; area++) {\n\t\tstruct vmap_area *va = vas[area];\n\n\t\tva->va_start = base + offsets[area];\n\t\tva->va_end = va->va_start + sizes[area];\n\t\t__insert_vmap_area(va);\n\t}\n\n\tvmap_area_pcpu_hole = base + offsets[last_area];\n\n\tspin_unlock(&vmap_area_lock);\n\n\t/* insert all vm's */\n\tfor (area = 0; area < nr_vms; area++)\n\t\tsetup_vmalloc_vm(vms[area], vas[area], VM_ALLOC,\n\t\t\t\t pcpu_get_vm_areas);\n\n\tkfree(vas);\n\treturn vms;\n\nerr_free:\n\tfor (area = 0; area < nr_vms; area++) {\n\t\tkfree(vas[area]);\n\t\tkfree(vms[area]);\n\t}\nerr_free2:\n\tkfree(vas);\n\tkfree(vms);\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(vmap_area_lock);",
      "static unsigned long vmap_area_pcpu_hole;",
      "static void purge_vmap_area_lazy(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "vms"
          ],
          "line": 2616
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_vmalloc_vm",
          "args": [
            "vms[area]",
            "vas[area]",
            "VM_ALLOC",
            "pcpu_get_vm_areas"
          ],
          "line": 2603
        },
        "resolved": true,
        "details": {
          "function_name": "setup_vmalloc_vm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1349-1360",
          "snippet": "static void setup_vmalloc_vm(struct vm_struct *vm, struct vmap_area *va,\n\t\t\t      unsigned long flags, const void *caller)\n{\n\tspin_lock(&vmap_area_lock);\n\tvm->flags = flags;\n\tvm->addr = (void *)va->va_start;\n\tvm->size = va->va_end - va->va_start;\n\tvm->caller = caller;\n\tva->vm = vm;\n\tva->flags |= VM_VM_AREA;\n\tspin_unlock(&vmap_area_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [
            "#define VM_VM_AREA\t0x04"
          ],
          "globals_used": [
            "static DEFINE_SPINLOCK(vmap_area_lock);",
            "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\n#define VM_VM_AREA\t0x04\n\nstatic DEFINE_SPINLOCK(vmap_area_lock);\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);\n\nstatic void setup_vmalloc_vm(struct vm_struct *vm, struct vmap_area *va,\n\t\t\t      unsigned long flags, const void *caller)\n{\n\tspin_lock(&vmap_area_lock);\n\tvm->flags = flags;\n\tvm->addr = (void *)va->va_start;\n\tvm->size = va->va_end - va->va_start;\n\tvm->caller = caller;\n\tva->vm = vm;\n\tva->flags |= VM_VM_AREA;\n\tspin_unlock(&vmap_area_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vmap_area_lock"
          ],
          "line": 2599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__insert_vmap_area",
          "args": [
            "va"
          ],
          "line": 2594
        },
        "resolved": true,
        "details": {
          "function_name": "__insert_vmap_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "362-392",
          "snippet": "static void __insert_vmap_area(struct vmap_area *va)\n{\n\tstruct rb_node **p = &vmap_area_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct rb_node *tmp;\n\n\twhile (*p) {\n\t\tstruct vmap_area *tmp_va;\n\n\t\tparent = *p;\n\t\ttmp_va = rb_entry(parent, struct vmap_area, rb_node);\n\t\tif (va->va_start < tmp_va->va_end)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (va->va_end > tmp_va->va_start)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tBUG();\n\t}\n\n\trb_link_node(&va->rb_node, parent, p);\n\trb_insert_color(&va->rb_node, &vmap_area_root);\n\n\t/* address-sort this list */\n\ttmp = rb_prev(&va->rb_node);\n\tif (tmp) {\n\t\tstruct vmap_area *prev;\n\t\tprev = rb_entry(tmp, struct vmap_area, rb_node);\n\t\tlist_add_rcu(&va->list, &prev->list);\n\t} else\n\t\tlist_add_rcu(&va->list, &vmap_area_list);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root vmap_area_root = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic struct rb_root vmap_area_root = RB_ROOT;\n\nstatic void __insert_vmap_area(struct vmap_area *va)\n{\n\tstruct rb_node **p = &vmap_area_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct rb_node *tmp;\n\n\twhile (*p) {\n\t\tstruct vmap_area *tmp_va;\n\n\t\tparent = *p;\n\t\ttmp_va = rb_entry(parent, struct vmap_area, rb_node);\n\t\tif (va->va_start < tmp_va->va_end)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (va->va_end > tmp_va->va_start)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tBUG();\n\t}\n\n\trb_link_node(&va->rb_node, parent, p);\n\trb_insert_color(&va->rb_node, &vmap_area_root);\n\n\t/* address-sort this list */\n\ttmp = rb_prev(&va->rb_node);\n\tif (tmp) {\n\t\tstruct vmap_area *prev;\n\t\tprev = rb_entry(tmp, struct vmap_area, rb_node);\n\t\tlist_add_rcu(&va->list, &prev->list);\n\t} else\n\t\tlist_add_rcu(&va->list, &vmap_area_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pvm_find_next_prev",
          "args": [
            "base + end",
            "&next",
            "&prev"
          ],
          "line": 2585
        },
        "resolved": true,
        "details": {
          "function_name": "pvm_find_next_prev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "2380-2408",
          "snippet": "static bool pvm_find_next_prev(unsigned long end,\n\t\t\t       struct vmap_area **pnext,\n\t\t\t       struct vmap_area **pprev)\n{\n\tstruct rb_node *n = vmap_area_root.rb_node;\n\tstruct vmap_area *va = NULL;\n\n\twhile (n) {\n\t\tva = rb_entry(n, struct vmap_area, rb_node);\n\t\tif (end < va->va_end)\n\t\t\tn = n->rb_left;\n\t\telse if (end > va->va_end)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (!va)\n\t\treturn false;\n\n\tif (va->va_end > end) {\n\t\t*pnext = va;\n\t\t*pprev = node_to_va(rb_prev(&(*pnext)->rb_node));\n\t} else {\n\t\t*pprev = va;\n\t\t*pnext = node_to_va(rb_next(&(*pprev)->rb_node));\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root vmap_area_root = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic struct rb_root vmap_area_root = RB_ROOT;\n\nstatic bool pvm_find_next_prev(unsigned long end,\n\t\t\t       struct vmap_area **pnext,\n\t\t\t       struct vmap_area **pprev)\n{\n\tstruct rb_node *n = vmap_area_root.rb_node;\n\tstruct vmap_area *va = NULL;\n\n\twhile (n) {\n\t\tva = rb_entry(n, struct vmap_area, rb_node);\n\t\tif (end < va->va_end)\n\t\t\tn = n->rb_left;\n\t\telse if (end > va->va_end)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (!va)\n\t\treturn false;\n\n\tif (va->va_end > end) {\n\t\t*pnext = va;\n\t\t*pprev = node_to_va(rb_prev(&(*pnext)->rb_node));\n\t} else {\n\t\t*pprev = va;\n\t\t*pnext = node_to_va(rb_next(&(*pprev)->rb_node));\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pvm_determine_end",
          "args": [
            "&next",
            "&prev",
            "align"
          ],
          "line": 2571
        },
        "resolved": true,
        "details": {
          "function_name": "pvm_determine_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "2426-2444",
          "snippet": "static unsigned long pvm_determine_end(struct vmap_area **pnext,\n\t\t\t\t       struct vmap_area **pprev,\n\t\t\t\t       unsigned long align)\n{\n\tconst unsigned long vmalloc_end = VMALLOC_END & ~(align - 1);\n\tunsigned long addr;\n\n\tif (*pnext)\n\t\taddr = min((*pnext)->va_start & ~(align - 1), vmalloc_end);\n\telse\n\t\taddr = vmalloc_end;\n\n\twhile (*pprev && (*pprev)->va_end > addr) {\n\t\t*pnext = *pprev;\n\t\t*pprev = node_to_va(rb_prev(&(*pnext)->rb_node));\n\t}\n\n\treturn addr;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic unsigned long pvm_determine_end(struct vmap_area **pnext,\n\t\t\t\t       struct vmap_area **pprev,\n\t\t\t\t       unsigned long align)\n{\n\tconst unsigned long vmalloc_end = VMALLOC_END & ~(align - 1);\n\tunsigned long addr;\n\n\tif (*pnext)\n\t\taddr = min((*pnext)->va_start & ~(align - 1), vmalloc_end);\n\telse\n\t\taddr = vmalloc_end;\n\n\twhile (*pprev && (*pprev)->va_end > addr) {\n\t\t*pnext = *pprev;\n\t\t*pprev = node_to_va(rb_prev(&(*pnext)->rb_node));\n\t}\n\n\treturn addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "node_to_va",
          "args": [
            "rb_prev(&next->rb_node)"
          ],
          "line": 2570
        },
        "resolved": true,
        "details": {
          "function_name": "node_to_va",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "2363-2366",
          "snippet": "static struct vmap_area *node_to_va(struct rb_node *n)\n{\n\treturn rb_entry_safe(n, struct vmap_area, rb_node);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic struct vmap_area *node_to_va(struct rb_node *n)\n{\n\treturn rb_entry_safe(n, struct vmap_area, rb_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_prev",
          "args": [
            "&next->rb_node"
          ],
          "line": 2570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "purge_vmap_area_lazy",
          "args": [],
          "line": 2546
        },
        "resolved": true,
        "details": {
          "function_name": "purge_vmap_area_lazy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "705-711",
          "snippet": "static void purge_vmap_area_lazy(void)\n{\n\tmutex_lock(&vmap_purge_lock);\n\tpurge_fragmented_blocks_allcpus();\n\t__purge_vmap_area_lazy(ULONG_MAX, 0);\n\tmutex_unlock(&vmap_purge_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void purge_vmap_area_lazy(void);",
            "static DEFINE_MUTEX(vmap_purge_lock);",
            "static void purge_fragmented_blocks_allcpus(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void purge_vmap_area_lazy(void);\nstatic DEFINE_MUTEX(vmap_purge_lock);\nstatic void purge_fragmented_blocks_allcpus(void);\n\nstatic void purge_vmap_area_lazy(void)\n{\n\tmutex_lock(&vmap_purge_lock);\n\tpurge_fragmented_blocks_allcpus();\n\t__purge_vmap_area_lazy(ULONG_MAX, 0);\n\tmutex_unlock(&vmap_purge_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vmap_area_lock"
          ],
          "line": 2544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "prev && prev->va_end > base + end"
          ],
          "line": 2537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "next && next->va_end <= base + end"
          ],
          "line": 2536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vmap_area_lock"
          ],
          "line": 2522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct vm_struct)",
            "GFP_KERNEL"
          ],
          "line": 2517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct vmap_area)",
            "GFP_KERNEL"
          ],
          "line": 2516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "nr_vms",
            "sizeof(vas[0])",
            "GFP_KERNEL"
          ],
          "line": 2511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "nr_vms",
            "sizeof(vms[0])",
            "GFP_KERNEL"
          ],
          "line": 2510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "true"
          ],
          "line": 2506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "start2 < end && start < end2"
          ],
          "line": 2500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!IS_ALIGNED(sizes[area], align)"
          ],
          "line": 2490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "sizes[area]",
            "align"
          ],
          "line": 2490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!IS_ALIGNED(offsets[area], align)"
          ],
          "line": 2489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "offsets[area]",
            "align"
          ],
          "line": 2489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "offset_in_page(align) || !is_power_of_2(align)"
          ],
          "line": 2483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_power_of_2",
          "args": [
            "align"
          ],
          "line": 2483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "align"
          ],
          "line": 2483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "VMALLOC_START",
            "align"
          ],
          "line": 2474
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic DEFINE_SPINLOCK(vmap_area_lock);\nstatic unsigned long vmap_area_pcpu_hole;\nstatic void purge_vmap_area_lazy(void);\n\nstruct vm_struct **pcpu_get_vm_areas(const unsigned long *offsets,\n\t\t\t\t     const size_t *sizes, int nr_vms,\n\t\t\t\t     size_t align)\n{\n\tconst unsigned long vmalloc_start = ALIGN(VMALLOC_START, align);\n\tconst unsigned long vmalloc_end = VMALLOC_END & ~(align - 1);\n\tstruct vmap_area **vas, *prev, *next;\n\tstruct vm_struct **vms;\n\tint area, area2, last_area, term_area;\n\tunsigned long base, start, end, last_end;\n\tbool purged = false;\n\n\t/* verify parameters and allocate data structures */\n\tBUG_ON(offset_in_page(align) || !is_power_of_2(align));\n\tfor (last_area = 0, area = 0; area < nr_vms; area++) {\n\t\tstart = offsets[area];\n\t\tend = start + sizes[area];\n\n\t\t/* is everything aligned properly? */\n\t\tBUG_ON(!IS_ALIGNED(offsets[area], align));\n\t\tBUG_ON(!IS_ALIGNED(sizes[area], align));\n\n\t\t/* detect the area with the highest address */\n\t\tif (start > offsets[last_area])\n\t\t\tlast_area = area;\n\n\t\tfor (area2 = area + 1; area2 < nr_vms; area2++) {\n\t\t\tunsigned long start2 = offsets[area2];\n\t\t\tunsigned long end2 = start2 + sizes[area2];\n\n\t\t\tBUG_ON(start2 < end && start < end2);\n\t\t}\n\t}\n\tlast_end = offsets[last_area] + sizes[last_area];\n\n\tif (vmalloc_end - vmalloc_start < last_end) {\n\t\tWARN_ON(true);\n\t\treturn NULL;\n\t}\n\n\tvms = kcalloc(nr_vms, sizeof(vms[0]), GFP_KERNEL);\n\tvas = kcalloc(nr_vms, sizeof(vas[0]), GFP_KERNEL);\n\tif (!vas || !vms)\n\t\tgoto err_free2;\n\n\tfor (area = 0; area < nr_vms; area++) {\n\t\tvas[area] = kzalloc(sizeof(struct vmap_area), GFP_KERNEL);\n\t\tvms[area] = kzalloc(sizeof(struct vm_struct), GFP_KERNEL);\n\t\tif (!vas[area] || !vms[area])\n\t\t\tgoto err_free;\n\t}\nretry:\n\tspin_lock(&vmap_area_lock);\n\n\t/* start scanning - we scan from the top, begin with the last area */\n\tarea = term_area = last_area;\n\tstart = offsets[area];\n\tend = start + sizes[area];\n\n\tif (!pvm_find_next_prev(vmap_area_pcpu_hole, &next, &prev)) {\n\t\tbase = vmalloc_end - last_end;\n\t\tgoto found;\n\t}\n\tbase = pvm_determine_end(&next, &prev, align) - end;\n\n\twhile (true) {\n\t\tBUG_ON(next && next->va_end <= base + end);\n\t\tBUG_ON(prev && prev->va_end > base + end);\n\n\t\t/*\n\t\t * base might have underflowed, add last_end before\n\t\t * comparing.\n\t\t */\n\t\tif (base + last_end < vmalloc_start + last_end) {\n\t\t\tspin_unlock(&vmap_area_lock);\n\t\t\tif (!purged) {\n\t\t\t\tpurge_vmap_area_lazy();\n\t\t\t\tpurged = true;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tgoto err_free;\n\t\t}\n\n\t\t/*\n\t\t * If next overlaps, move base downwards so that it's\n\t\t * right below next and then recheck.\n\t\t */\n\t\tif (next && next->va_start < base + end) {\n\t\t\tbase = pvm_determine_end(&next, &prev, align) - end;\n\t\t\tterm_area = area;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If prev overlaps, shift down next and prev and move\n\t\t * base so that it's right below new next and then\n\t\t * recheck.\n\t\t */\n\t\tif (prev && prev->va_end > base + start)  {\n\t\t\tnext = prev;\n\t\t\tprev = node_to_va(rb_prev(&next->rb_node));\n\t\t\tbase = pvm_determine_end(&next, &prev, align) - end;\n\t\t\tterm_area = area;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * This area fits, move on to the previous one.  If\n\t\t * the previous one is the terminal one, we're done.\n\t\t */\n\t\tarea = (area + nr_vms - 1) % nr_vms;\n\t\tif (area == term_area)\n\t\t\tbreak;\n\t\tstart = offsets[area];\n\t\tend = start + sizes[area];\n\t\tpvm_find_next_prev(base + end, &next, &prev);\n\t}\nfound:\n\t/* we've found a fitting base, insert all va's */\n\tfor (area = 0; area < nr_vms; area++) {\n\t\tstruct vmap_area *va = vas[area];\n\n\t\tva->va_start = base + offsets[area];\n\t\tva->va_end = va->va_start + sizes[area];\n\t\t__insert_vmap_area(va);\n\t}\n\n\tvmap_area_pcpu_hole = base + offsets[last_area];\n\n\tspin_unlock(&vmap_area_lock);\n\n\t/* insert all vm's */\n\tfor (area = 0; area < nr_vms; area++)\n\t\tsetup_vmalloc_vm(vms[area], vas[area], VM_ALLOC,\n\t\t\t\t pcpu_get_vm_areas);\n\n\tkfree(vas);\n\treturn vms;\n\nerr_free:\n\tfor (area = 0; area < nr_vms; area++) {\n\t\tkfree(vas[area]);\n\t\tkfree(vms[area]);\n\t}\nerr_free2:\n\tkfree(vas);\n\tkfree(vms);\n\treturn NULL;\n}"
  },
  {
    "function_name": "pvm_determine_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "2426-2444",
    "snippet": "static unsigned long pvm_determine_end(struct vmap_area **pnext,\n\t\t\t\t       struct vmap_area **pprev,\n\t\t\t\t       unsigned long align)\n{\n\tconst unsigned long vmalloc_end = VMALLOC_END & ~(align - 1);\n\tunsigned long addr;\n\n\tif (*pnext)\n\t\taddr = min((*pnext)->va_start & ~(align - 1), vmalloc_end);\n\telse\n\t\taddr = vmalloc_end;\n\n\twhile (*pprev && (*pprev)->va_end > addr) {\n\t\t*pnext = *pprev;\n\t\t*pprev = node_to_va(rb_prev(&(*pnext)->rb_node));\n\t}\n\n\treturn addr;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "node_to_va",
          "args": [
            "rb_prev(&(*pnext)->rb_node)"
          ],
          "line": 2440
        },
        "resolved": true,
        "details": {
          "function_name": "node_to_va",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "2363-2366",
          "snippet": "static struct vmap_area *node_to_va(struct rb_node *n)\n{\n\treturn rb_entry_safe(n, struct vmap_area, rb_node);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic struct vmap_area *node_to_va(struct rb_node *n)\n{\n\treturn rb_entry_safe(n, struct vmap_area, rb_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_prev",
          "args": [
            "&(*pnext)->rb_node"
          ],
          "line": 2440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "(*pnext)->va_start & ~(align - 1)",
            "vmalloc_end"
          ],
          "line": 2434
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic unsigned long pvm_determine_end(struct vmap_area **pnext,\n\t\t\t\t       struct vmap_area **pprev,\n\t\t\t\t       unsigned long align)\n{\n\tconst unsigned long vmalloc_end = VMALLOC_END & ~(align - 1);\n\tunsigned long addr;\n\n\tif (*pnext)\n\t\taddr = min((*pnext)->va_start & ~(align - 1), vmalloc_end);\n\telse\n\t\taddr = vmalloc_end;\n\n\twhile (*pprev && (*pprev)->va_end > addr) {\n\t\t*pnext = *pprev;\n\t\t*pprev = node_to_va(rb_prev(&(*pnext)->rb_node));\n\t}\n\n\treturn addr;\n}"
  },
  {
    "function_name": "pvm_find_next_prev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "2380-2408",
    "snippet": "static bool pvm_find_next_prev(unsigned long end,\n\t\t\t       struct vmap_area **pnext,\n\t\t\t       struct vmap_area **pprev)\n{\n\tstruct rb_node *n = vmap_area_root.rb_node;\n\tstruct vmap_area *va = NULL;\n\n\twhile (n) {\n\t\tva = rb_entry(n, struct vmap_area, rb_node);\n\t\tif (end < va->va_end)\n\t\t\tn = n->rb_left;\n\t\telse if (end > va->va_end)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (!va)\n\t\treturn false;\n\n\tif (va->va_end > end) {\n\t\t*pnext = va;\n\t\t*pprev = node_to_va(rb_prev(&(*pnext)->rb_node));\n\t} else {\n\t\t*pprev = va;\n\t\t*pnext = node_to_va(rb_next(&(*pprev)->rb_node));\n\t}\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rb_root vmap_area_root = RB_ROOT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "node_to_va",
          "args": [
            "rb_next(&(*pprev)->rb_node)"
          ],
          "line": 2405
        },
        "resolved": true,
        "details": {
          "function_name": "node_to_va",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "2363-2366",
          "snippet": "static struct vmap_area *node_to_va(struct rb_node *n)\n{\n\treturn rb_entry_safe(n, struct vmap_area, rb_node);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic struct vmap_area *node_to_va(struct rb_node *n)\n{\n\treturn rb_entry_safe(n, struct vmap_area, rb_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&(*pprev)->rb_node"
          ],
          "line": 2405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_prev",
          "args": [
            "&(*pnext)->rb_node"
          ],
          "line": 2402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structvmap_area",
            "rb_node"
          ],
          "line": 2388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic struct rb_root vmap_area_root = RB_ROOT;\n\nstatic bool pvm_find_next_prev(unsigned long end,\n\t\t\t       struct vmap_area **pnext,\n\t\t\t       struct vmap_area **pprev)\n{\n\tstruct rb_node *n = vmap_area_root.rb_node;\n\tstruct vmap_area *va = NULL;\n\n\twhile (n) {\n\t\tva = rb_entry(n, struct vmap_area, rb_node);\n\t\tif (end < va->va_end)\n\t\t\tn = n->rb_left;\n\t\telse if (end > va->va_end)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (!va)\n\t\treturn false;\n\n\tif (va->va_end > end) {\n\t\t*pnext = va;\n\t\t*pprev = node_to_va(rb_prev(&(*pnext)->rb_node));\n\t} else {\n\t\t*pprev = va;\n\t\t*pnext = node_to_va(rb_next(&(*pprev)->rb_node));\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "node_to_va",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "2363-2366",
    "snippet": "static struct vmap_area *node_to_va(struct rb_node *n)\n{\n\treturn rb_entry_safe(n, struct vmap_area, rb_node);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry_safe",
          "args": [
            "n",
            "structvmap_area",
            "rb_node"
          ],
          "line": 2365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic struct vmap_area *node_to_va(struct rb_node *n)\n{\n\treturn rb_entry_safe(n, struct vmap_area, rb_node);\n}"
  },
  {
    "function_name": "free_vm_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "2353-2359",
    "snippet": "void free_vm_area(struct vm_struct *area)\n{\n\tstruct vm_struct *ret;\n\tret = remove_vm_area(area->addr);\n\tBUG_ON(ret != area);\n\tkfree(area);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "area"
          ],
          "line": 2358
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret != area"
          ],
          "line": 2357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_vm_area",
          "args": [
            "area->addr"
          ],
          "line": 2356
        },
        "resolved": true,
        "details": {
          "function_name": "remove_vm_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1473-1495",
          "snippet": "struct vm_struct *remove_vm_area(const void *addr)\n{\n\tstruct vmap_area *va;\n\n\tmight_sleep();\n\n\tva = find_vmap_area((unsigned long)addr);\n\tif (va && va->flags & VM_VM_AREA) {\n\t\tstruct vm_struct *vm = va->vm;\n\n\t\tspin_lock(&vmap_area_lock);\n\t\tva->vm = NULL;\n\t\tva->flags &= ~VM_VM_AREA;\n\t\tva->flags |= VM_LAZY_FREE;\n\t\tspin_unlock(&vmap_area_lock);\n\n\t\tkasan_free_shadow(vm);\n\t\tfree_unmap_vmap_area(va);\n\n\t\treturn vm;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [
            "#define VM_VM_AREA\t0x04",
            "#define VM_LAZY_FREE\t0x02"
          ],
          "globals_used": [
            "static DEFINE_SPINLOCK(vmap_area_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\n#define VM_VM_AREA\t0x04\n#define VM_LAZY_FREE\t0x02\n\nstatic DEFINE_SPINLOCK(vmap_area_lock);\n\nstruct vm_struct *remove_vm_area(const void *addr)\n{\n\tstruct vmap_area *va;\n\n\tmight_sleep();\n\n\tva = find_vmap_area((unsigned long)addr);\n\tif (va && va->flags & VM_VM_AREA) {\n\t\tstruct vm_struct *vm = va->vm;\n\n\t\tspin_lock(&vmap_area_lock);\n\t\tva->vm = NULL;\n\t\tva->flags &= ~VM_VM_AREA;\n\t\tva->flags |= VM_LAZY_FREE;\n\t\tspin_unlock(&vmap_area_lock);\n\n\t\tkasan_free_shadow(vm);\n\t\tfree_unmap_vmap_area(va);\n\n\t\treturn vm;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nvoid free_vm_area(struct vm_struct *area)\n{\n\tstruct vm_struct *ret;\n\tret = remove_vm_area(area->addr);\n\tBUG_ON(ret != area);\n\tkfree(area);\n}"
  },
  {
    "function_name": "alloc_vm_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "2330-2350",
    "snippet": "struct vm_struct *alloc_vm_area(size_t size, pte_t **ptes)\n{\n\tstruct vm_struct *area;\n\n\tarea = get_vm_area_caller(size, VM_IOREMAP,\n\t\t\t\t__builtin_return_address(0));\n\tif (area == NULL)\n\t\treturn NULL;\n\n\t/*\n\t * This ensures that page tables are constructed for this region\n\t * of kernel virtual address space and mapped into init_mm.\n\t */\n\tif (apply_to_page_range(&init_mm, (unsigned long)area->addr,\n\t\t\t\tsize, f, ptes ? &ptes : NULL)) {\n\t\tfree_vm_area(area);\n\t\treturn NULL;\n\t}\n\n\treturn area;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_vm_area",
          "args": [
            "area"
          ],
          "line": 2345
        },
        "resolved": true,
        "details": {
          "function_name": "free_vm_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "2353-2359",
          "snippet": "void free_vm_area(struct vm_struct *area)\n{\n\tstruct vm_struct *ret;\n\tret = remove_vm_area(area->addr);\n\tBUG_ON(ret != area);\n\tkfree(area);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nvoid free_vm_area(struct vm_struct *area)\n{\n\tstruct vm_struct *ret;\n\tret = remove_vm_area(area->addr);\n\tBUG_ON(ret != area);\n\tkfree(area);\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_to_page_range",
          "args": [
            "&init_mm",
            "(unsigned long)area->addr",
            "size",
            "f",
            "ptes ? &ptes : NULL"
          ],
          "line": 2343
        },
        "resolved": true,
        "details": {
          "function_name": "apply_to_page_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "2041-2061",
          "snippet": "int apply_to_page_range(struct mm_struct *mm, unsigned long addr,\n\t\t\tunsigned long size, pte_fn_t fn, void *data)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\tunsigned long end = addr + size;\n\tint err;\n\n\tif (WARN_ON(addr >= end))\n\t\treturn -EINVAL;\n\n\tpgd = pgd_offset(mm, addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\terr = apply_to_p4d_range(mm, pgd, addr, next, fn, data);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pgd++, addr = next, addr != end);\n\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint apply_to_page_range(struct mm_struct *mm, unsigned long addr,\n\t\t\tunsigned long size, pte_fn_t fn, void *data)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\tunsigned long end = addr + size;\n\tint err;\n\n\tif (WARN_ON(addr >= end))\n\t\treturn -EINVAL;\n\n\tpgd = pgd_offset(mm, addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\terr = apply_to_p4d_range(mm, pgd, addr, next, fn, data);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pgd++, addr = next, addr != end);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_vm_area_caller",
          "args": [
            "size",
            "VM_IOREMAP",
            "__builtin_return_address(0)"
          ],
          "line": 2334
        },
        "resolved": true,
        "details": {
          "function_name": "get_vm_area_caller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1439-1444",
          "snippet": "struct vm_struct *get_vm_area_caller(unsigned long size, unsigned long flags,\n\t\t\t\tconst void *caller)\n{\n\treturn __get_vm_area_node(size, 1, flags, VMALLOC_START, VMALLOC_END,\n\t\t\t\t  NUMA_NO_NODE, GFP_KERNEL, caller);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);\n\nstruct vm_struct *get_vm_area_caller(unsigned long size, unsigned long flags,\n\t\t\t\tconst void *caller)\n{\n\treturn __get_vm_area_node(size, 1, flags, VMALLOC_START, VMALLOC_END,\n\t\t\t\t  NUMA_NO_NODE, GFP_KERNEL, caller);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__builtin_return_address",
          "args": [
            "0"
          ],
          "line": 2335
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstruct vm_struct *alloc_vm_area(size_t size, pte_t **ptes)\n{\n\tstruct vm_struct *area;\n\n\tarea = get_vm_area_caller(size, VM_IOREMAP,\n\t\t\t\t__builtin_return_address(0));\n\tif (area == NULL)\n\t\treturn NULL;\n\n\t/*\n\t * This ensures that page tables are constructed for this region\n\t * of kernel virtual address space and mapped into init_mm.\n\t */\n\tif (apply_to_page_range(&init_mm, (unsigned long)area->addr,\n\t\t\t\tsize, f, ptes ? &ptes : NULL)) {\n\t\tfree_vm_area(area);\n\t\treturn NULL;\n\t}\n\n\treturn area;\n}"
  },
  {
    "function_name": "f",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "2305-2314",
    "snippet": "static int f(pte_t *pte, pgtable_t table, unsigned long addr, void *data)\n{\n\tpte_t ***p = data;\n\n\tif (p) {\n\t\t*(*p) = pte;\n\t\t(*p)++;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic int f(pte_t *pte, pgtable_t table, unsigned long addr, void *data)\n{\n\tpte_t ***p = data;\n\n\tif (p) {\n\t\t*(*p) = pte;\n\t\t(*p)++;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "vmalloc_sync_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "2300-2302",
    "snippet": "void __weak vmalloc_sync_all(void)\n{\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nvoid __weak vmalloc_sync_all(void)\n{\n}"
  },
  {
    "function_name": "remap_vmalloc_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "2287-2293",
    "snippet": "int remap_vmalloc_range(struct vm_area_struct *vma, void *addr,\n\t\t\t\t\t\tunsigned long pgoff)\n{\n\treturn remap_vmalloc_range_partial(vma, vma->vm_start,\n\t\t\t\t\t   addr + (pgoff << PAGE_SHIFT),\n\t\t\t\t\t   vma->vm_end - vma->vm_start);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "remap_vmalloc_range_partial",
          "args": [
            "vma",
            "vma->vm_start",
            "addr + (pgoff << PAGE_SHIFT)",
            "vma->vm_end - vma->vm_start"
          ],
          "line": 2290
        },
        "resolved": true,
        "details": {
          "function_name": "remap_vmalloc_range_partial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "2234-2270",
          "snippet": "int remap_vmalloc_range_partial(struct vm_area_struct *vma, unsigned long uaddr,\n\t\t\t\tvoid *kaddr, unsigned long size)\n{\n\tstruct vm_struct *area;\n\n\tsize = PAGE_ALIGN(size);\n\n\tif (!PAGE_ALIGNED(uaddr) || !PAGE_ALIGNED(kaddr))\n\t\treturn -EINVAL;\n\n\tarea = find_vm_area(kaddr);\n\tif (!area)\n\t\treturn -EINVAL;\n\n\tif (!(area->flags & VM_USERMAP))\n\t\treturn -EINVAL;\n\n\tif (kaddr + size > area->addr + area->size)\n\t\treturn -EINVAL;\n\n\tdo {\n\t\tstruct page *page = vmalloc_to_page(kaddr);\n\t\tint ret;\n\n\t\tret = vm_insert_page(vma, uaddr, page);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tuaddr += PAGE_SIZE;\n\t\tkaddr += PAGE_SIZE;\n\t\tsize -= PAGE_SIZE;\n\t} while (size > 0);\n\n\tvma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nint remap_vmalloc_range_partial(struct vm_area_struct *vma, unsigned long uaddr,\n\t\t\t\tvoid *kaddr, unsigned long size)\n{\n\tstruct vm_struct *area;\n\n\tsize = PAGE_ALIGN(size);\n\n\tif (!PAGE_ALIGNED(uaddr) || !PAGE_ALIGNED(kaddr))\n\t\treturn -EINVAL;\n\n\tarea = find_vm_area(kaddr);\n\tif (!area)\n\t\treturn -EINVAL;\n\n\tif (!(area->flags & VM_USERMAP))\n\t\treturn -EINVAL;\n\n\tif (kaddr + size > area->addr + area->size)\n\t\treturn -EINVAL;\n\n\tdo {\n\t\tstruct page *page = vmalloc_to_page(kaddr);\n\t\tint ret;\n\n\t\tret = vm_insert_page(vma, uaddr, page);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tuaddr += PAGE_SIZE;\n\t\tkaddr += PAGE_SIZE;\n\t\tsize -= PAGE_SIZE;\n\t} while (size > 0);\n\n\tvma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nint remap_vmalloc_range(struct vm_area_struct *vma, void *addr,\n\t\t\t\t\t\tunsigned long pgoff)\n{\n\treturn remap_vmalloc_range_partial(vma, vma->vm_start,\n\t\t\t\t\t   addr + (pgoff << PAGE_SHIFT),\n\t\t\t\t\t   vma->vm_end - vma->vm_start);\n}"
  },
  {
    "function_name": "remap_vmalloc_range_partial",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "2234-2270",
    "snippet": "int remap_vmalloc_range_partial(struct vm_area_struct *vma, unsigned long uaddr,\n\t\t\t\tvoid *kaddr, unsigned long size)\n{\n\tstruct vm_struct *area;\n\n\tsize = PAGE_ALIGN(size);\n\n\tif (!PAGE_ALIGNED(uaddr) || !PAGE_ALIGNED(kaddr))\n\t\treturn -EINVAL;\n\n\tarea = find_vm_area(kaddr);\n\tif (!area)\n\t\treturn -EINVAL;\n\n\tif (!(area->flags & VM_USERMAP))\n\t\treturn -EINVAL;\n\n\tif (kaddr + size > area->addr + area->size)\n\t\treturn -EINVAL;\n\n\tdo {\n\t\tstruct page *page = vmalloc_to_page(kaddr);\n\t\tint ret;\n\n\t\tret = vm_insert_page(vma, uaddr, page);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tuaddr += PAGE_SIZE;\n\t\tkaddr += PAGE_SIZE;\n\t\tsize -= PAGE_SIZE;\n\t} while (size > 0);\n\n\tvma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vm_insert_page",
          "args": [
            "vma",
            "uaddr",
            "page"
          ],
          "line": 2258
        },
        "resolved": true,
        "details": {
          "function_name": "vm_insert_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "469-473",
          "snippet": "int vm_insert_page(struct vm_area_struct *vma, unsigned long addr,\n\t\t   struct page *page)\n{\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nint vm_insert_page(struct vm_area_struct *vma, unsigned long addr,\n\t\t   struct page *page)\n{\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmalloc_to_page",
          "args": [
            "kaddr"
          ],
          "line": 2255
        },
        "resolved": true,
        "details": {
          "function_name": "vmalloc_to_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "266-311",
          "snippet": "struct page *vmalloc_to_page(const void *vmalloc_addr)\n{\n\tunsigned long addr = (unsigned long) vmalloc_addr;\n\tstruct page *page = NULL;\n\tpgd_t *pgd = pgd_offset_k(addr);\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *ptep, pte;\n\n\t/*\n\t * XXX we might need to change this if we add VIRTUAL_BUG_ON for\n\t * architectures that do not vmalloc module space\n\t */\n\tVIRTUAL_BUG_ON(!is_vmalloc_or_module_addr(vmalloc_addr));\n\n\tif (pgd_none(*pgd))\n\t\treturn NULL;\n\tp4d = p4d_offset(pgd, addr);\n\tif (p4d_none(*p4d))\n\t\treturn NULL;\n\tpud = pud_offset(p4d, addr);\n\n\t/*\n\t * Don't dereference bad PUD or PMD (below) entries. This will also\n\t * identify huge mappings, which we may encounter on architectures\n\t * that define CONFIG_HAVE_ARCH_HUGE_VMAP=y. Such regions will be\n\t * identified as vmalloc addresses by is_vmalloc_addr(), but are\n\t * not [unambiguously] associated with a struct page, so there is\n\t * no correct value to return for them.\n\t */\n\tWARN_ON_ONCE(pud_bad(*pud));\n\tif (pud_none(*pud) || pud_bad(*pud))\n\t\treturn NULL;\n\tpmd = pmd_offset(pud, addr);\n\tWARN_ON_ONCE(pmd_bad(*pmd));\n\tif (pmd_none(*pmd) || pmd_bad(*pmd))\n\t\treturn NULL;\n\n\tptep = pte_offset_map(pmd, addr);\n\tpte = *ptep;\n\tif (pte_present(pte))\n\t\tpage = pte_page(pte);\n\tpte_unmap(ptep);\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstruct page *vmalloc_to_page(const void *vmalloc_addr)\n{\n\tunsigned long addr = (unsigned long) vmalloc_addr;\n\tstruct page *page = NULL;\n\tpgd_t *pgd = pgd_offset_k(addr);\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *ptep, pte;\n\n\t/*\n\t * XXX we might need to change this if we add VIRTUAL_BUG_ON for\n\t * architectures that do not vmalloc module space\n\t */\n\tVIRTUAL_BUG_ON(!is_vmalloc_or_module_addr(vmalloc_addr));\n\n\tif (pgd_none(*pgd))\n\t\treturn NULL;\n\tp4d = p4d_offset(pgd, addr);\n\tif (p4d_none(*p4d))\n\t\treturn NULL;\n\tpud = pud_offset(p4d, addr);\n\n\t/*\n\t * Don't dereference bad PUD or PMD (below) entries. This will also\n\t * identify huge mappings, which we may encounter on architectures\n\t * that define CONFIG_HAVE_ARCH_HUGE_VMAP=y. Such regions will be\n\t * identified as vmalloc addresses by is_vmalloc_addr(), but are\n\t * not [unambiguously] associated with a struct page, so there is\n\t * no correct value to return for them.\n\t */\n\tWARN_ON_ONCE(pud_bad(*pud));\n\tif (pud_none(*pud) || pud_bad(*pud))\n\t\treturn NULL;\n\tpmd = pmd_offset(pud, addr);\n\tWARN_ON_ONCE(pmd_bad(*pmd));\n\tif (pmd_none(*pmd) || pmd_bad(*pmd))\n\t\treturn NULL;\n\n\tptep = pte_offset_map(pmd, addr);\n\tpte = *ptep;\n\tif (pte_present(pte))\n\t\tpage = pte_page(pte);\n\tpte_unmap(ptep);\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_vm_area",
          "args": [
            "kaddr"
          ],
          "line": 2244
        },
        "resolved": true,
        "details": {
          "function_name": "find_vm_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1454-1463",
          "snippet": "struct vm_struct *find_vm_area(const void *addr)\n{\n\tstruct vmap_area *va;\n\n\tva = find_vmap_area((unsigned long)addr);\n\tif (va && va->flags & VM_VM_AREA)\n\t\treturn va->vm;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [
            "#define VM_VM_AREA\t0x04"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\n#define VM_VM_AREA\t0x04\n\nstruct vm_struct *find_vm_area(const void *addr)\n{\n\tstruct vmap_area *va;\n\n\tva = find_vmap_area((unsigned long)addr);\n\tif (va && va->flags & VM_VM_AREA)\n\t\treturn va->vm;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGNED",
          "args": [
            "kaddr"
          ],
          "line": 2241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGNED",
          "args": [
            "uaddr"
          ],
          "line": 2241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "size"
          ],
          "line": 2239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nint remap_vmalloc_range_partial(struct vm_area_struct *vma, unsigned long uaddr,\n\t\t\t\tvoid *kaddr, unsigned long size)\n{\n\tstruct vm_struct *area;\n\n\tsize = PAGE_ALIGN(size);\n\n\tif (!PAGE_ALIGNED(uaddr) || !PAGE_ALIGNED(kaddr))\n\t\treturn -EINVAL;\n\n\tarea = find_vm_area(kaddr);\n\tif (!area)\n\t\treturn -EINVAL;\n\n\tif (!(area->flags & VM_USERMAP))\n\t\treturn -EINVAL;\n\n\tif (kaddr + size > area->addr + area->size)\n\t\treturn -EINVAL;\n\n\tdo {\n\t\tstruct page *page = vmalloc_to_page(kaddr);\n\t\tint ret;\n\n\t\tret = vm_insert_page(vma, uaddr, page);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tuaddr += PAGE_SIZE;\n\t\tkaddr += PAGE_SIZE;\n\t\tsize -= PAGE_SIZE;\n\t} while (size > 0);\n\n\tvma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "vwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "2168-2216",
    "snippet": "long vwrite(char *buf, char *addr, unsigned long count)\n{\n\tstruct vmap_area *va;\n\tstruct vm_struct *vm;\n\tchar *vaddr;\n\tunsigned long n, buflen;\n\tint copied = 0;\n\n\t/* Don't allow overflow */\n\tif ((unsigned long) addr + count < count)\n\t\tcount = -(unsigned long) addr;\n\tbuflen = count;\n\n\tspin_lock(&vmap_area_lock);\n\tlist_for_each_entry(va, &vmap_area_list, list) {\n\t\tif (!count)\n\t\t\tbreak;\n\n\t\tif (!(va->flags & VM_VM_AREA))\n\t\t\tcontinue;\n\n\t\tvm = va->vm;\n\t\tvaddr = (char *) vm->addr;\n\t\tif (addr >= vaddr + get_vm_area_size(vm))\n\t\t\tcontinue;\n\t\twhile (addr < vaddr) {\n\t\t\tif (count == 0)\n\t\t\t\tgoto finished;\n\t\t\tbuf++;\n\t\t\taddr++;\n\t\t\tcount--;\n\t\t}\n\t\tn = vaddr + get_vm_area_size(vm) - addr;\n\t\tif (n > count)\n\t\t\tn = count;\n\t\tif (!(vm->flags & VM_IOREMAP)) {\n\t\t\taligned_vwrite(buf, addr, n);\n\t\t\tcopied++;\n\t\t}\n\t\tbuf += n;\n\t\taddr += n;\n\t\tcount -= n;\n\t}\nfinished:\n\tspin_unlock(&vmap_area_lock);\n\tif (!copied)\n\t\treturn 0;\n\treturn buflen;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [
      "#define VM_VM_AREA\t0x04"
    ],
    "globals_used": [
      "static DEFINE_SPINLOCK(vmap_area_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vmap_area_lock"
          ],
          "line": 2212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aligned_vwrite",
          "args": [
            "buf",
            "addr",
            "n"
          ],
          "line": 2204
        },
        "resolved": true,
        "details": {
          "function_name": "aligned_vwrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "2024-2059",
          "snippet": "static int aligned_vwrite(char *buf, char *addr, unsigned long count)\n{\n\tstruct page *p;\n\tint copied = 0;\n\n\twhile (count) {\n\t\tunsigned long offset, length;\n\n\t\toffset = offset_in_page(addr);\n\t\tlength = PAGE_SIZE - offset;\n\t\tif (length > count)\n\t\t\tlength = count;\n\t\tp = vmalloc_to_page(addr);\n\t\t/*\n\t\t * To do safe access to this _mapped_ area, we need\n\t\t * lock. But adding lock here means that we need to add\n\t\t * overhead of vmalloc()/vfree() calles for this _debug_\n\t\t * interface, rarely used. Instead of that, we'll use\n\t\t * kmap() and get small overhead in this access function.\n\t\t */\n\t\tif (p) {\n\t\t\t/*\n\t\t\t * we can expect USER0 is not used (see vread/vwrite's\n\t\t\t * function description)\n\t\t\t */\n\t\t\tvoid *map = kmap_atomic(p);\n\t\t\tmemcpy(map + offset, buf, length);\n\t\t\tkunmap_atomic(map);\n\t\t}\n\t\taddr += length;\n\t\tbuf += length;\n\t\tcopied += length;\n\t\tcount -= length;\n\t}\n\treturn copied;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic int aligned_vwrite(char *buf, char *addr, unsigned long count)\n{\n\tstruct page *p;\n\tint copied = 0;\n\n\twhile (count) {\n\t\tunsigned long offset, length;\n\n\t\toffset = offset_in_page(addr);\n\t\tlength = PAGE_SIZE - offset;\n\t\tif (length > count)\n\t\t\tlength = count;\n\t\tp = vmalloc_to_page(addr);\n\t\t/*\n\t\t * To do safe access to this _mapped_ area, we need\n\t\t * lock. But adding lock here means that we need to add\n\t\t * overhead of vmalloc()/vfree() calles for this _debug_\n\t\t * interface, rarely used. Instead of that, we'll use\n\t\t * kmap() and get small overhead in this access function.\n\t\t */\n\t\tif (p) {\n\t\t\t/*\n\t\t\t * we can expect USER0 is not used (see vread/vwrite's\n\t\t\t * function description)\n\t\t\t */\n\t\t\tvoid *map = kmap_atomic(p);\n\t\t\tmemcpy(map + offset, buf, length);\n\t\t\tkunmap_atomic(map);\n\t\t}\n\t\taddr += length;\n\t\tbuf += length;\n\t\tcopied += length;\n\t\tcount -= length;\n\t}\n\treturn copied;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_vm_area_size",
          "args": [
            "vm"
          ],
          "line": 2200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_vm_area_size",
          "args": [
            "vm"
          ],
          "line": 2191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "va",
            "&vmap_area_list",
            "list"
          ],
          "line": 2182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vmap_area_lock"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\n#define VM_VM_AREA\t0x04\n\nstatic DEFINE_SPINLOCK(vmap_area_lock);\n\nlong vwrite(char *buf, char *addr, unsigned long count)\n{\n\tstruct vmap_area *va;\n\tstruct vm_struct *vm;\n\tchar *vaddr;\n\tunsigned long n, buflen;\n\tint copied = 0;\n\n\t/* Don't allow overflow */\n\tif ((unsigned long) addr + count < count)\n\t\tcount = -(unsigned long) addr;\n\tbuflen = count;\n\n\tspin_lock(&vmap_area_lock);\n\tlist_for_each_entry(va, &vmap_area_list, list) {\n\t\tif (!count)\n\t\t\tbreak;\n\n\t\tif (!(va->flags & VM_VM_AREA))\n\t\t\tcontinue;\n\n\t\tvm = va->vm;\n\t\tvaddr = (char *) vm->addr;\n\t\tif (addr >= vaddr + get_vm_area_size(vm))\n\t\t\tcontinue;\n\t\twhile (addr < vaddr) {\n\t\t\tif (count == 0)\n\t\t\t\tgoto finished;\n\t\t\tbuf++;\n\t\t\taddr++;\n\t\t\tcount--;\n\t\t}\n\t\tn = vaddr + get_vm_area_size(vm) - addr;\n\t\tif (n > count)\n\t\t\tn = count;\n\t\tif (!(vm->flags & VM_IOREMAP)) {\n\t\t\taligned_vwrite(buf, addr, n);\n\t\t\tcopied++;\n\t\t}\n\t\tbuf += n;\n\t\taddr += n;\n\t\tcount -= n;\n\t}\nfinished:\n\tspin_unlock(&vmap_area_lock);\n\tif (!copied)\n\t\treturn 0;\n\treturn buflen;\n}"
  },
  {
    "function_name": "vread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "2087-2140",
    "snippet": "long vread(char *buf, char *addr, unsigned long count)\n{\n\tstruct vmap_area *va;\n\tstruct vm_struct *vm;\n\tchar *vaddr, *buf_start = buf;\n\tunsigned long buflen = count;\n\tunsigned long n;\n\n\t/* Don't allow overflow */\n\tif ((unsigned long) addr + count < count)\n\t\tcount = -(unsigned long) addr;\n\n\tspin_lock(&vmap_area_lock);\n\tlist_for_each_entry(va, &vmap_area_list, list) {\n\t\tif (!count)\n\t\t\tbreak;\n\n\t\tif (!(va->flags & VM_VM_AREA))\n\t\t\tcontinue;\n\n\t\tvm = va->vm;\n\t\tvaddr = (char *) vm->addr;\n\t\tif (addr >= vaddr + get_vm_area_size(vm))\n\t\t\tcontinue;\n\t\twhile (addr < vaddr) {\n\t\t\tif (count == 0)\n\t\t\t\tgoto finished;\n\t\t\t*buf = '\\0';\n\t\t\tbuf++;\n\t\t\taddr++;\n\t\t\tcount--;\n\t\t}\n\t\tn = vaddr + get_vm_area_size(vm) - addr;\n\t\tif (n > count)\n\t\t\tn = count;\n\t\tif (!(vm->flags & VM_IOREMAP))\n\t\t\taligned_vread(buf, addr, n);\n\t\telse /* IOREMAP area is treated as memory hole */\n\t\t\tmemset(buf, 0, n);\n\t\tbuf += n;\n\t\taddr += n;\n\t\tcount -= n;\n\t}\nfinished:\n\tspin_unlock(&vmap_area_lock);\n\n\tif (buf == buf_start)\n\t\treturn 0;\n\t/* zero-fill memory holes */\n\tif (buf != buf_start + buflen)\n\t\tmemset(buf, 0, buflen - (buf - buf_start));\n\n\treturn buflen;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [
      "#define VM_VM_AREA\t0x04"
    ],
    "globals_used": [
      "static DEFINE_SPINLOCK(vmap_area_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf",
            "0",
            "buflen - (buf - buf_start)"
          ],
          "line": 2137
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vmap_area_lock"
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aligned_vread",
          "args": [
            "buf",
            "addr",
            "n"
          ],
          "line": 2123
        },
        "resolved": true,
        "details": {
          "function_name": "aligned_vread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1985-2022",
          "snippet": "static int aligned_vread(char *buf, char *addr, unsigned long count)\n{\n\tstruct page *p;\n\tint copied = 0;\n\n\twhile (count) {\n\t\tunsigned long offset, length;\n\n\t\toffset = offset_in_page(addr);\n\t\tlength = PAGE_SIZE - offset;\n\t\tif (length > count)\n\t\t\tlength = count;\n\t\tp = vmalloc_to_page(addr);\n\t\t/*\n\t\t * To do safe access to this _mapped_ area, we need\n\t\t * lock. But adding lock here means that we need to add\n\t\t * overhead of vmalloc()/vfree() calles for this _debug_\n\t\t * interface, rarely used. Instead of that, we'll use\n\t\t * kmap() and get small overhead in this access function.\n\t\t */\n\t\tif (p) {\n\t\t\t/*\n\t\t\t * we can expect USER0 is not used (see vread/vwrite's\n\t\t\t * function description)\n\t\t\t */\n\t\t\tvoid *map = kmap_atomic(p);\n\t\t\tmemcpy(buf, map + offset, length);\n\t\t\tkunmap_atomic(map);\n\t\t} else\n\t\t\tmemset(buf, 0, length);\n\n\t\taddr += length;\n\t\tbuf += length;\n\t\tcopied += length;\n\t\tcount -= length;\n\t}\n\treturn copied;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic int aligned_vread(char *buf, char *addr, unsigned long count)\n{\n\tstruct page *p;\n\tint copied = 0;\n\n\twhile (count) {\n\t\tunsigned long offset, length;\n\n\t\toffset = offset_in_page(addr);\n\t\tlength = PAGE_SIZE - offset;\n\t\tif (length > count)\n\t\t\tlength = count;\n\t\tp = vmalloc_to_page(addr);\n\t\t/*\n\t\t * To do safe access to this _mapped_ area, we need\n\t\t * lock. But adding lock here means that we need to add\n\t\t * overhead of vmalloc()/vfree() calles for this _debug_\n\t\t * interface, rarely used. Instead of that, we'll use\n\t\t * kmap() and get small overhead in this access function.\n\t\t */\n\t\tif (p) {\n\t\t\t/*\n\t\t\t * we can expect USER0 is not used (see vread/vwrite's\n\t\t\t * function description)\n\t\t\t */\n\t\t\tvoid *map = kmap_atomic(p);\n\t\t\tmemcpy(buf, map + offset, length);\n\t\t\tkunmap_atomic(map);\n\t\t} else\n\t\t\tmemset(buf, 0, length);\n\n\t\taddr += length;\n\t\tbuf += length;\n\t\tcopied += length;\n\t\tcount -= length;\n\t}\n\treturn copied;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_vm_area_size",
          "args": [
            "vm"
          ],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_vm_area_size",
          "args": [
            "vm"
          ],
          "line": 2109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "va",
            "&vmap_area_list",
            "list"
          ],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vmap_area_lock"
          ],
          "line": 2099
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\n#define VM_VM_AREA\t0x04\n\nstatic DEFINE_SPINLOCK(vmap_area_lock);\n\nlong vread(char *buf, char *addr, unsigned long count)\n{\n\tstruct vmap_area *va;\n\tstruct vm_struct *vm;\n\tchar *vaddr, *buf_start = buf;\n\tunsigned long buflen = count;\n\tunsigned long n;\n\n\t/* Don't allow overflow */\n\tif ((unsigned long) addr + count < count)\n\t\tcount = -(unsigned long) addr;\n\n\tspin_lock(&vmap_area_lock);\n\tlist_for_each_entry(va, &vmap_area_list, list) {\n\t\tif (!count)\n\t\t\tbreak;\n\n\t\tif (!(va->flags & VM_VM_AREA))\n\t\t\tcontinue;\n\n\t\tvm = va->vm;\n\t\tvaddr = (char *) vm->addr;\n\t\tif (addr >= vaddr + get_vm_area_size(vm))\n\t\t\tcontinue;\n\t\twhile (addr < vaddr) {\n\t\t\tif (count == 0)\n\t\t\t\tgoto finished;\n\t\t\t*buf = '\\0';\n\t\t\tbuf++;\n\t\t\taddr++;\n\t\t\tcount--;\n\t\t}\n\t\tn = vaddr + get_vm_area_size(vm) - addr;\n\t\tif (n > count)\n\t\t\tn = count;\n\t\tif (!(vm->flags & VM_IOREMAP))\n\t\t\taligned_vread(buf, addr, n);\n\t\telse /* IOREMAP area is treated as memory hole */\n\t\t\tmemset(buf, 0, n);\n\t\tbuf += n;\n\t\taddr += n;\n\t\tcount -= n;\n\t}\nfinished:\n\tspin_unlock(&vmap_area_lock);\n\n\tif (buf == buf_start)\n\t\treturn 0;\n\t/* zero-fill memory holes */\n\tif (buf != buf_start + buflen)\n\t\tmemset(buf, 0, buflen - (buf - buf_start));\n\n\treturn buflen;\n}"
  },
  {
    "function_name": "aligned_vwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "2024-2059",
    "snippet": "static int aligned_vwrite(char *buf, char *addr, unsigned long count)\n{\n\tstruct page *p;\n\tint copied = 0;\n\n\twhile (count) {\n\t\tunsigned long offset, length;\n\n\t\toffset = offset_in_page(addr);\n\t\tlength = PAGE_SIZE - offset;\n\t\tif (length > count)\n\t\t\tlength = count;\n\t\tp = vmalloc_to_page(addr);\n\t\t/*\n\t\t * To do safe access to this _mapped_ area, we need\n\t\t * lock. But adding lock here means that we need to add\n\t\t * overhead of vmalloc()/vfree() calles for this _debug_\n\t\t * interface, rarely used. Instead of that, we'll use\n\t\t * kmap() and get small overhead in this access function.\n\t\t */\n\t\tif (p) {\n\t\t\t/*\n\t\t\t * we can expect USER0 is not used (see vread/vwrite's\n\t\t\t * function description)\n\t\t\t */\n\t\t\tvoid *map = kmap_atomic(p);\n\t\t\tmemcpy(map + offset, buf, length);\n\t\t\tkunmap_atomic(map);\n\t\t}\n\t\taddr += length;\n\t\tbuf += length;\n\t\tcopied += length;\n\t\tcount -= length;\n\t}\n\treturn copied;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "map"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "map + offset",
            "buf",
            "length"
          ],
          "line": 2050
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "300-306",
          "snippet": "void *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "p"
          ],
          "line": 2049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc_to_page",
          "args": [
            "addr"
          ],
          "line": 2036
        },
        "resolved": true,
        "details": {
          "function_name": "vmalloc_to_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "266-311",
          "snippet": "struct page *vmalloc_to_page(const void *vmalloc_addr)\n{\n\tunsigned long addr = (unsigned long) vmalloc_addr;\n\tstruct page *page = NULL;\n\tpgd_t *pgd = pgd_offset_k(addr);\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *ptep, pte;\n\n\t/*\n\t * XXX we might need to change this if we add VIRTUAL_BUG_ON for\n\t * architectures that do not vmalloc module space\n\t */\n\tVIRTUAL_BUG_ON(!is_vmalloc_or_module_addr(vmalloc_addr));\n\n\tif (pgd_none(*pgd))\n\t\treturn NULL;\n\tp4d = p4d_offset(pgd, addr);\n\tif (p4d_none(*p4d))\n\t\treturn NULL;\n\tpud = pud_offset(p4d, addr);\n\n\t/*\n\t * Don't dereference bad PUD or PMD (below) entries. This will also\n\t * identify huge mappings, which we may encounter on architectures\n\t * that define CONFIG_HAVE_ARCH_HUGE_VMAP=y. Such regions will be\n\t * identified as vmalloc addresses by is_vmalloc_addr(), but are\n\t * not [unambiguously] associated with a struct page, so there is\n\t * no correct value to return for them.\n\t */\n\tWARN_ON_ONCE(pud_bad(*pud));\n\tif (pud_none(*pud) || pud_bad(*pud))\n\t\treturn NULL;\n\tpmd = pmd_offset(pud, addr);\n\tWARN_ON_ONCE(pmd_bad(*pmd));\n\tif (pmd_none(*pmd) || pmd_bad(*pmd))\n\t\treturn NULL;\n\n\tptep = pte_offset_map(pmd, addr);\n\tpte = *ptep;\n\tif (pte_present(pte))\n\t\tpage = pte_page(pte);\n\tpte_unmap(ptep);\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstruct page *vmalloc_to_page(const void *vmalloc_addr)\n{\n\tunsigned long addr = (unsigned long) vmalloc_addr;\n\tstruct page *page = NULL;\n\tpgd_t *pgd = pgd_offset_k(addr);\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *ptep, pte;\n\n\t/*\n\t * XXX we might need to change this if we add VIRTUAL_BUG_ON for\n\t * architectures that do not vmalloc module space\n\t */\n\tVIRTUAL_BUG_ON(!is_vmalloc_or_module_addr(vmalloc_addr));\n\n\tif (pgd_none(*pgd))\n\t\treturn NULL;\n\tp4d = p4d_offset(pgd, addr);\n\tif (p4d_none(*p4d))\n\t\treturn NULL;\n\tpud = pud_offset(p4d, addr);\n\n\t/*\n\t * Don't dereference bad PUD or PMD (below) entries. This will also\n\t * identify huge mappings, which we may encounter on architectures\n\t * that define CONFIG_HAVE_ARCH_HUGE_VMAP=y. Such regions will be\n\t * identified as vmalloc addresses by is_vmalloc_addr(), but are\n\t * not [unambiguously] associated with a struct page, so there is\n\t * no correct value to return for them.\n\t */\n\tWARN_ON_ONCE(pud_bad(*pud));\n\tif (pud_none(*pud) || pud_bad(*pud))\n\t\treturn NULL;\n\tpmd = pmd_offset(pud, addr);\n\tWARN_ON_ONCE(pmd_bad(*pmd));\n\tif (pmd_none(*pmd) || pmd_bad(*pmd))\n\t\treturn NULL;\n\n\tptep = pte_offset_map(pmd, addr);\n\tpte = *ptep;\n\tif (pte_present(pte))\n\t\tpage = pte_page(pte);\n\tpte_unmap(ptep);\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "addr"
          ],
          "line": 2032
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic int aligned_vwrite(char *buf, char *addr, unsigned long count)\n{\n\tstruct page *p;\n\tint copied = 0;\n\n\twhile (count) {\n\t\tunsigned long offset, length;\n\n\t\toffset = offset_in_page(addr);\n\t\tlength = PAGE_SIZE - offset;\n\t\tif (length > count)\n\t\t\tlength = count;\n\t\tp = vmalloc_to_page(addr);\n\t\t/*\n\t\t * To do safe access to this _mapped_ area, we need\n\t\t * lock. But adding lock here means that we need to add\n\t\t * overhead of vmalloc()/vfree() calles for this _debug_\n\t\t * interface, rarely used. Instead of that, we'll use\n\t\t * kmap() and get small overhead in this access function.\n\t\t */\n\t\tif (p) {\n\t\t\t/*\n\t\t\t * we can expect USER0 is not used (see vread/vwrite's\n\t\t\t * function description)\n\t\t\t */\n\t\t\tvoid *map = kmap_atomic(p);\n\t\t\tmemcpy(map + offset, buf, length);\n\t\t\tkunmap_atomic(map);\n\t\t}\n\t\taddr += length;\n\t\tbuf += length;\n\t\tcopied += length;\n\t\tcount -= length;\n\t}\n\treturn copied;\n}"
  },
  {
    "function_name": "aligned_vread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "1985-2022",
    "snippet": "static int aligned_vread(char *buf, char *addr, unsigned long count)\n{\n\tstruct page *p;\n\tint copied = 0;\n\n\twhile (count) {\n\t\tunsigned long offset, length;\n\n\t\toffset = offset_in_page(addr);\n\t\tlength = PAGE_SIZE - offset;\n\t\tif (length > count)\n\t\t\tlength = count;\n\t\tp = vmalloc_to_page(addr);\n\t\t/*\n\t\t * To do safe access to this _mapped_ area, we need\n\t\t * lock. But adding lock here means that we need to add\n\t\t * overhead of vmalloc()/vfree() calles for this _debug_\n\t\t * interface, rarely used. Instead of that, we'll use\n\t\t * kmap() and get small overhead in this access function.\n\t\t */\n\t\tif (p) {\n\t\t\t/*\n\t\t\t * we can expect USER0 is not used (see vread/vwrite's\n\t\t\t * function description)\n\t\t\t */\n\t\t\tvoid *map = kmap_atomic(p);\n\t\t\tmemcpy(buf, map + offset, length);\n\t\t\tkunmap_atomic(map);\n\t\t} else\n\t\t\tmemset(buf, 0, length);\n\n\t\taddr += length;\n\t\tbuf += length;\n\t\tcopied += length;\n\t\tcount -= length;\n\t}\n\treturn copied;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf",
            "0",
            "length"
          ],
          "line": 2014
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "map"
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "map + offset",
            "length"
          ],
          "line": 2011
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "300-306",
          "snippet": "void *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "p"
          ],
          "line": 2010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc_to_page",
          "args": [
            "addr"
          ],
          "line": 1997
        },
        "resolved": true,
        "details": {
          "function_name": "vmalloc_to_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "266-311",
          "snippet": "struct page *vmalloc_to_page(const void *vmalloc_addr)\n{\n\tunsigned long addr = (unsigned long) vmalloc_addr;\n\tstruct page *page = NULL;\n\tpgd_t *pgd = pgd_offset_k(addr);\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *ptep, pte;\n\n\t/*\n\t * XXX we might need to change this if we add VIRTUAL_BUG_ON for\n\t * architectures that do not vmalloc module space\n\t */\n\tVIRTUAL_BUG_ON(!is_vmalloc_or_module_addr(vmalloc_addr));\n\n\tif (pgd_none(*pgd))\n\t\treturn NULL;\n\tp4d = p4d_offset(pgd, addr);\n\tif (p4d_none(*p4d))\n\t\treturn NULL;\n\tpud = pud_offset(p4d, addr);\n\n\t/*\n\t * Don't dereference bad PUD or PMD (below) entries. This will also\n\t * identify huge mappings, which we may encounter on architectures\n\t * that define CONFIG_HAVE_ARCH_HUGE_VMAP=y. Such regions will be\n\t * identified as vmalloc addresses by is_vmalloc_addr(), but are\n\t * not [unambiguously] associated with a struct page, so there is\n\t * no correct value to return for them.\n\t */\n\tWARN_ON_ONCE(pud_bad(*pud));\n\tif (pud_none(*pud) || pud_bad(*pud))\n\t\treturn NULL;\n\tpmd = pmd_offset(pud, addr);\n\tWARN_ON_ONCE(pmd_bad(*pmd));\n\tif (pmd_none(*pmd) || pmd_bad(*pmd))\n\t\treturn NULL;\n\n\tptep = pte_offset_map(pmd, addr);\n\tpte = *ptep;\n\tif (pte_present(pte))\n\t\tpage = pte_page(pte);\n\tpte_unmap(ptep);\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstruct page *vmalloc_to_page(const void *vmalloc_addr)\n{\n\tunsigned long addr = (unsigned long) vmalloc_addr;\n\tstruct page *page = NULL;\n\tpgd_t *pgd = pgd_offset_k(addr);\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *ptep, pte;\n\n\t/*\n\t * XXX we might need to change this if we add VIRTUAL_BUG_ON for\n\t * architectures that do not vmalloc module space\n\t */\n\tVIRTUAL_BUG_ON(!is_vmalloc_or_module_addr(vmalloc_addr));\n\n\tif (pgd_none(*pgd))\n\t\treturn NULL;\n\tp4d = p4d_offset(pgd, addr);\n\tif (p4d_none(*p4d))\n\t\treturn NULL;\n\tpud = pud_offset(p4d, addr);\n\n\t/*\n\t * Don't dereference bad PUD or PMD (below) entries. This will also\n\t * identify huge mappings, which we may encounter on architectures\n\t * that define CONFIG_HAVE_ARCH_HUGE_VMAP=y. Such regions will be\n\t * identified as vmalloc addresses by is_vmalloc_addr(), but are\n\t * not [unambiguously] associated with a struct page, so there is\n\t * no correct value to return for them.\n\t */\n\tWARN_ON_ONCE(pud_bad(*pud));\n\tif (pud_none(*pud) || pud_bad(*pud))\n\t\treturn NULL;\n\tpmd = pmd_offset(pud, addr);\n\tWARN_ON_ONCE(pmd_bad(*pmd));\n\tif (pmd_none(*pmd) || pmd_bad(*pmd))\n\t\treturn NULL;\n\n\tptep = pte_offset_map(pmd, addr);\n\tpte = *ptep;\n\tif (pte_present(pte))\n\t\tpage = pte_page(pte);\n\tpte_unmap(ptep);\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "addr"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic int aligned_vread(char *buf, char *addr, unsigned long count)\n{\n\tstruct page *p;\n\tint copied = 0;\n\n\twhile (count) {\n\t\tunsigned long offset, length;\n\n\t\toffset = offset_in_page(addr);\n\t\tlength = PAGE_SIZE - offset;\n\t\tif (length > count)\n\t\t\tlength = count;\n\t\tp = vmalloc_to_page(addr);\n\t\t/*\n\t\t * To do safe access to this _mapped_ area, we need\n\t\t * lock. But adding lock here means that we need to add\n\t\t * overhead of vmalloc()/vfree() calles for this _debug_\n\t\t * interface, rarely used. Instead of that, we'll use\n\t\t * kmap() and get small overhead in this access function.\n\t\t */\n\t\tif (p) {\n\t\t\t/*\n\t\t\t * we can expect USER0 is not used (see vread/vwrite's\n\t\t\t * function description)\n\t\t\t */\n\t\t\tvoid *map = kmap_atomic(p);\n\t\t\tmemcpy(buf, map + offset, length);\n\t\t\tkunmap_atomic(map);\n\t\t} else\n\t\t\tmemset(buf, 0, length);\n\n\t\taddr += length;\n\t\tbuf += length;\n\t\tcopied += length;\n\t\tcount -= length;\n\t}\n\treturn copied;\n}"
  },
  {
    "function_name": "vmalloc_32_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "1965-1977",
    "snippet": "void *vmalloc_32_user(unsigned long size)\n{\n\tstruct vm_struct *area;\n\tvoid *ret;\n\n\tret = __vmalloc_node(size, 1, GFP_VMALLOC32 | __GFP_ZERO, PAGE_KERNEL,\n\t\t\t     NUMA_NO_NODE, __builtin_return_address(0));\n\tif (ret) {\n\t\tarea = find_vm_area(ret);\n\t\tarea->flags |= VM_USERMAP;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [
      "#define GFP_VMALLOC32 GFP_DMA32 | GFP_KERNEL",
      "#define GFP_VMALLOC32 (GFP_DMA | GFP_KERNEL)",
      "#define GFP_VMALLOC32 (GFP_DMA32 | GFP_KERNEL)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_vm_area",
          "args": [
            "ret"
          ],
          "line": 1973
        },
        "resolved": true,
        "details": {
          "function_name": "find_vm_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1454-1463",
          "snippet": "struct vm_struct *find_vm_area(const void *addr)\n{\n\tstruct vmap_area *va;\n\n\tva = find_vmap_area((unsigned long)addr);\n\tif (va && va->flags & VM_VM_AREA)\n\t\treturn va->vm;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [
            "#define VM_VM_AREA\t0x04"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\n#define VM_VM_AREA\t0x04\n\nstruct vm_struct *find_vm_area(const void *addr)\n{\n\tstruct vmap_area *va;\n\n\tva = find_vmap_area((unsigned long)addr);\n\tif (va && va->flags & VM_VM_AREA)\n\t\treturn va->vm;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__vmalloc_node",
          "args": [
            "size",
            "1",
            "GFP_VMALLOC32 | __GFP_ZERO",
            "PAGE_KERNEL",
            "NUMA_NO_NODE",
            "__builtin_return_address(0)"
          ],
          "line": 1970
        },
        "resolved": true,
        "details": {
          "function_name": "__vmalloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1791-1797",
          "snippet": "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller)\n{\n\treturn __vmalloc_node_range(size, align, VMALLOC_START, VMALLOC_END,\n\t\t\t\tgfp_mask, prot, 0, node, caller);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);\n\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller)\n{\n\treturn __vmalloc_node_range(size, align, VMALLOC_START, VMALLOC_END,\n\t\t\t\tgfp_mask, prot, 0, node, caller);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__builtin_return_address",
          "args": [
            "0"
          ],
          "line": 1971
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\n#define GFP_VMALLOC32 GFP_DMA32 | GFP_KERNEL\n#define GFP_VMALLOC32 (GFP_DMA | GFP_KERNEL)\n#define GFP_VMALLOC32 (GFP_DMA32 | GFP_KERNEL)\n\nvoid *vmalloc_32_user(unsigned long size)\n{\n\tstruct vm_struct *area;\n\tvoid *ret;\n\n\tret = __vmalloc_node(size, 1, GFP_VMALLOC32 | __GFP_ZERO, PAGE_KERNEL,\n\t\t\t     NUMA_NO_NODE, __builtin_return_address(0));\n\tif (ret) {\n\t\tarea = find_vm_area(ret);\n\t\tarea->flags |= VM_USERMAP;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "vmalloc_32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "1951-1955",
    "snippet": "void *vmalloc_32(unsigned long size)\n{\n\treturn __vmalloc_node(size, 1, GFP_VMALLOC32, PAGE_KERNEL,\n\t\t\t      NUMA_NO_NODE, __builtin_return_address(0));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [
      "#define GFP_VMALLOC32 GFP_DMA32 | GFP_KERNEL",
      "#define GFP_VMALLOC32 (GFP_DMA | GFP_KERNEL)",
      "#define GFP_VMALLOC32 (GFP_DMA32 | GFP_KERNEL)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vmalloc_node",
          "args": [
            "size",
            "1",
            "GFP_VMALLOC32",
            "PAGE_KERNEL",
            "NUMA_NO_NODE",
            "__builtin_return_address(0)"
          ],
          "line": 1953
        },
        "resolved": true,
        "details": {
          "function_name": "__vmalloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1791-1797",
          "snippet": "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller)\n{\n\treturn __vmalloc_node_range(size, align, VMALLOC_START, VMALLOC_END,\n\t\t\t\tgfp_mask, prot, 0, node, caller);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);\n\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller)\n{\n\treturn __vmalloc_node_range(size, align, VMALLOC_START, VMALLOC_END,\n\t\t\t\tgfp_mask, prot, 0, node, caller);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__builtin_return_address",
          "args": [
            "0"
          ],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\n#define GFP_VMALLOC32 GFP_DMA32 | GFP_KERNEL\n#define GFP_VMALLOC32 (GFP_DMA | GFP_KERNEL)\n#define GFP_VMALLOC32 (GFP_DMA32 | GFP_KERNEL)\n\nvoid *vmalloc_32(unsigned long size)\n{\n\treturn __vmalloc_node(size, 1, GFP_VMALLOC32, PAGE_KERNEL,\n\t\t\t      NUMA_NO_NODE, __builtin_return_address(0));\n}"
  },
  {
    "function_name": "vmalloc_exec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "1926-1930",
    "snippet": "void *vmalloc_exec(unsigned long size)\n{\n\treturn __vmalloc_node(size, 1, GFP_KERNEL, PAGE_KERNEL_EXEC,\n\t\t\t      NUMA_NO_NODE, __builtin_return_address(0));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vmalloc_node",
          "args": [
            "size",
            "1",
            "GFP_KERNEL",
            "PAGE_KERNEL_EXEC",
            "NUMA_NO_NODE",
            "__builtin_return_address(0)"
          ],
          "line": 1928
        },
        "resolved": true,
        "details": {
          "function_name": "__vmalloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1791-1797",
          "snippet": "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller)\n{\n\treturn __vmalloc_node_range(size, align, VMALLOC_START, VMALLOC_END,\n\t\t\t\tgfp_mask, prot, 0, node, caller);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);\n\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller)\n{\n\treturn __vmalloc_node_range(size, align, VMALLOC_START, VMALLOC_END,\n\t\t\t\tgfp_mask, prot, 0, node, caller);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__builtin_return_address",
          "args": [
            "0"
          ],
          "line": 1929
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nvoid *vmalloc_exec(unsigned long size)\n{\n\treturn __vmalloc_node(size, 1, GFP_KERNEL, PAGE_KERNEL_EXEC,\n\t\t\t      NUMA_NO_NODE, __builtin_return_address(0));\n}"
  },
  {
    "function_name": "vzalloc_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "1907-1911",
    "snippet": "void *vzalloc_node(unsigned long size, int node)\n{\n\treturn __vmalloc_node_flags(size, node,\n\t\t\t GFP_KERNEL | __GFP_ZERO);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vmalloc_node_flags",
          "args": [
            "size",
            "node",
            "GFP_KERNEL | __GFP_ZERO"
          ],
          "line": 1909
        },
        "resolved": true,
        "details": {
          "function_name": "__vmalloc_node_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1806-1811",
          "snippet": "static inline void *__vmalloc_node_flags(unsigned long size,\n\t\t\t\t\tint node, gfp_t flags)\n{\n\treturn __vmalloc_node(size, 1, flags, PAGE_KERNEL,\n\t\t\t\t\tnode, __builtin_return_address(0));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic inline void *__vmalloc_node_flags(unsigned long size,\n\t\t\t\t\tint node, gfp_t flags)\n{\n\treturn __vmalloc_node(size, 1, flags, PAGE_KERNEL,\n\t\t\t\t\tnode, __builtin_return_address(0));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nvoid *vzalloc_node(unsigned long size, int node)\n{\n\treturn __vmalloc_node_flags(size, node,\n\t\t\t GFP_KERNEL | __GFP_ZERO);\n}"
  },
  {
    "function_name": "vmalloc_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "1888-1892",
    "snippet": "void *vmalloc_node(unsigned long size, int node)\n{\n\treturn __vmalloc_node(size, 1, GFP_KERNEL, PAGE_KERNEL,\n\t\t\t\t\tnode, __builtin_return_address(0));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vmalloc_node",
          "args": [
            "size",
            "1",
            "GFP_KERNEL",
            "PAGE_KERNEL",
            "node",
            "__builtin_return_address(0)"
          ],
          "line": 1890
        },
        "resolved": true,
        "details": {
          "function_name": "__vmalloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1791-1797",
          "snippet": "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller)\n{\n\treturn __vmalloc_node_range(size, align, VMALLOC_START, VMALLOC_END,\n\t\t\t\tgfp_mask, prot, 0, node, caller);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);\n\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller)\n{\n\treturn __vmalloc_node_range(size, align, VMALLOC_START, VMALLOC_END,\n\t\t\t\tgfp_mask, prot, 0, node, caller);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__builtin_return_address",
          "args": [
            "0"
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nvoid *vmalloc_node(unsigned long size, int node)\n{\n\treturn __vmalloc_node(size, 1, GFP_KERNEL, PAGE_KERNEL,\n\t\t\t\t\tnode, __builtin_return_address(0));\n}"
  },
  {
    "function_name": "vmalloc_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "1860-1874",
    "snippet": "void *vmalloc_user(unsigned long size)\n{\n\tstruct vm_struct *area;\n\tvoid *ret;\n\n\tret = __vmalloc_node(size, SHMLBA,\n\t\t\t     GFP_KERNEL | __GFP_ZERO,\n\t\t\t     PAGE_KERNEL, NUMA_NO_NODE,\n\t\t\t     __builtin_return_address(0));\n\tif (ret) {\n\t\tarea = find_vm_area(ret);\n\t\tarea->flags |= VM_USERMAP;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_vm_area",
          "args": [
            "ret"
          ],
          "line": 1870
        },
        "resolved": true,
        "details": {
          "function_name": "find_vm_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1454-1463",
          "snippet": "struct vm_struct *find_vm_area(const void *addr)\n{\n\tstruct vmap_area *va;\n\n\tva = find_vmap_area((unsigned long)addr);\n\tif (va && va->flags & VM_VM_AREA)\n\t\treturn va->vm;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [
            "#define VM_VM_AREA\t0x04"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\n#define VM_VM_AREA\t0x04\n\nstruct vm_struct *find_vm_area(const void *addr)\n{\n\tstruct vmap_area *va;\n\n\tva = find_vmap_area((unsigned long)addr);\n\tif (va && va->flags & VM_VM_AREA)\n\t\treturn va->vm;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__vmalloc_node",
          "args": [
            "size",
            "SHMLBA",
            "GFP_KERNEL | __GFP_ZERO",
            "PAGE_KERNEL",
            "NUMA_NO_NODE",
            "__builtin_return_address(0)"
          ],
          "line": 1865
        },
        "resolved": true,
        "details": {
          "function_name": "__vmalloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1791-1797",
          "snippet": "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller)\n{\n\treturn __vmalloc_node_range(size, align, VMALLOC_START, VMALLOC_END,\n\t\t\t\tgfp_mask, prot, 0, node, caller);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);\n\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller)\n{\n\treturn __vmalloc_node_range(size, align, VMALLOC_START, VMALLOC_END,\n\t\t\t\tgfp_mask, prot, 0, node, caller);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__builtin_return_address",
          "args": [
            "0"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nvoid *vmalloc_user(unsigned long size)\n{\n\tstruct vm_struct *area;\n\tvoid *ret;\n\n\tret = __vmalloc_node(size, SHMLBA,\n\t\t\t     GFP_KERNEL | __GFP_ZERO,\n\t\t\t     PAGE_KERNEL, NUMA_NO_NODE,\n\t\t\t     __builtin_return_address(0));\n\tif (ret) {\n\t\tarea = find_vm_area(ret);\n\t\tarea->flags |= VM_USERMAP;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "vzalloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "1846-1850",
    "snippet": "void *vzalloc(unsigned long size)\n{\n\treturn __vmalloc_node_flags(size, NUMA_NO_NODE,\n\t\t\t\tGFP_KERNEL | __GFP_ZERO);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vmalloc_node_flags",
          "args": [
            "size",
            "NUMA_NO_NODE",
            "GFP_KERNEL | __GFP_ZERO"
          ],
          "line": 1848
        },
        "resolved": true,
        "details": {
          "function_name": "__vmalloc_node_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1806-1811",
          "snippet": "static inline void *__vmalloc_node_flags(unsigned long size,\n\t\t\t\t\tint node, gfp_t flags)\n{\n\treturn __vmalloc_node(size, 1, flags, PAGE_KERNEL,\n\t\t\t\t\tnode, __builtin_return_address(0));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic inline void *__vmalloc_node_flags(unsigned long size,\n\t\t\t\t\tint node, gfp_t flags)\n{\n\treturn __vmalloc_node(size, 1, flags, PAGE_KERNEL,\n\t\t\t\t\tnode, __builtin_return_address(0));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nvoid *vzalloc(unsigned long size)\n{\n\treturn __vmalloc_node_flags(size, NUMA_NO_NODE,\n\t\t\t\tGFP_KERNEL | __GFP_ZERO);\n}"
  },
  {
    "function_name": "vmalloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "1829-1833",
    "snippet": "void *vmalloc(unsigned long size)\n{\n\treturn __vmalloc_node_flags(size, NUMA_NO_NODE,\n\t\t\t\t    GFP_KERNEL);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vmalloc_node_flags",
          "args": [
            "size",
            "NUMA_NO_NODE",
            "GFP_KERNEL"
          ],
          "line": 1831
        },
        "resolved": true,
        "details": {
          "function_name": "__vmalloc_node_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1806-1811",
          "snippet": "static inline void *__vmalloc_node_flags(unsigned long size,\n\t\t\t\t\tint node, gfp_t flags)\n{\n\treturn __vmalloc_node(size, 1, flags, PAGE_KERNEL,\n\t\t\t\t\tnode, __builtin_return_address(0));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic inline void *__vmalloc_node_flags(unsigned long size,\n\t\t\t\t\tint node, gfp_t flags)\n{\n\treturn __vmalloc_node(size, 1, flags, PAGE_KERNEL,\n\t\t\t\t\tnode, __builtin_return_address(0));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nvoid *vmalloc(unsigned long size)\n{\n\treturn __vmalloc_node_flags(size, NUMA_NO_NODE,\n\t\t\t\t    GFP_KERNEL);\n}"
  },
  {
    "function_name": "__vmalloc_node_flags_caller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "1814-1818",
    "snippet": "void *__vmalloc_node_flags_caller(unsigned long size, int node, gfp_t flags,\n\t\t\t\t  void *caller)\n{\n\treturn __vmalloc_node(size, 1, flags, PAGE_KERNEL, node, caller);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vmalloc_node",
          "args": [
            "size",
            "1",
            "flags",
            "PAGE_KERNEL",
            "node",
            "caller"
          ],
          "line": 1817
        },
        "resolved": true,
        "details": {
          "function_name": "__vmalloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1791-1797",
          "snippet": "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller)\n{\n\treturn __vmalloc_node_range(size, align, VMALLOC_START, VMALLOC_END,\n\t\t\t\tgfp_mask, prot, 0, node, caller);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);\n\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller)\n{\n\treturn __vmalloc_node_range(size, align, VMALLOC_START, VMALLOC_END,\n\t\t\t\tgfp_mask, prot, 0, node, caller);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);\n\nvoid *__vmalloc_node_flags_caller(unsigned long size, int node, gfp_t flags,\n\t\t\t\t  void *caller)\n{\n\treturn __vmalloc_node(size, 1, flags, PAGE_KERNEL, node, caller);\n}"
  },
  {
    "function_name": "__vmalloc_node_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "1806-1811",
    "snippet": "static inline void *__vmalloc_node_flags(unsigned long size,\n\t\t\t\t\tint node, gfp_t flags)\n{\n\treturn __vmalloc_node(size, 1, flags, PAGE_KERNEL,\n\t\t\t\t\tnode, __builtin_return_address(0));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vmalloc_node",
          "args": [
            "size",
            "1",
            "flags",
            "PAGE_KERNEL",
            "node",
            "__builtin_return_address(0)"
          ],
          "line": 1809
        },
        "resolved": true,
        "details": {
          "function_name": "__vmalloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1791-1797",
          "snippet": "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller)\n{\n\treturn __vmalloc_node_range(size, align, VMALLOC_START, VMALLOC_END,\n\t\t\t\tgfp_mask, prot, 0, node, caller);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);\n\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller)\n{\n\treturn __vmalloc_node_range(size, align, VMALLOC_START, VMALLOC_END,\n\t\t\t\tgfp_mask, prot, 0, node, caller);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__builtin_return_address",
          "args": [
            "0"
          ],
          "line": 1810
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic inline void *__vmalloc_node_flags(unsigned long size,\n\t\t\t\t\tint node, gfp_t flags)\n{\n\treturn __vmalloc_node(size, 1, flags, PAGE_KERNEL,\n\t\t\t\t\tnode, __builtin_return_address(0));\n}"
  },
  {
    "function_name": "__vmalloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "1799-1803",
    "snippet": "void *__vmalloc(unsigned long size, gfp_t gfp_mask, pgprot_t prot)\n{\n\treturn __vmalloc_node(size, 1, gfp_mask, prot, NUMA_NO_NODE,\n\t\t\t\t__builtin_return_address(0));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vmalloc_node",
          "args": [
            "size",
            "1",
            "gfp_mask",
            "prot",
            "NUMA_NO_NODE",
            "__builtin_return_address(0)"
          ],
          "line": 1801
        },
        "resolved": true,
        "details": {
          "function_name": "__vmalloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1791-1797",
          "snippet": "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller)\n{\n\treturn __vmalloc_node_range(size, align, VMALLOC_START, VMALLOC_END,\n\t\t\t\tgfp_mask, prot, 0, node, caller);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);\n\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller)\n{\n\treturn __vmalloc_node_range(size, align, VMALLOC_START, VMALLOC_END,\n\t\t\t\tgfp_mask, prot, 0, node, caller);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__builtin_return_address",
          "args": [
            "0"
          ],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nvoid *__vmalloc(unsigned long size, gfp_t gfp_mask, pgprot_t prot)\n{\n\treturn __vmalloc_node(size, 1, gfp_mask, prot, NUMA_NO_NODE,\n\t\t\t\t__builtin_return_address(0));\n}"
  },
  {
    "function_name": "__vmalloc_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "1791-1797",
    "snippet": "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller)\n{\n\treturn __vmalloc_node_range(size, align, VMALLOC_START, VMALLOC_END,\n\t\t\t\tgfp_mask, prot, 0, node, caller);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vmalloc_node_range",
          "args": [
            "size",
            "align",
            "VMALLOC_START",
            "VMALLOC_END",
            "gfp_mask",
            "prot",
            "0",
            "node",
            "caller"
          ],
          "line": 1795
        },
        "resolved": true,
        "details": {
          "function_name": "__vmalloc_node_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1732-1769",
          "snippet": "void *__vmalloc_node_range(unsigned long size, unsigned long align,\n\t\t\tunsigned long start, unsigned long end, gfp_t gfp_mask,\n\t\t\tpgprot_t prot, unsigned long vm_flags, int node,\n\t\t\tconst void *caller)\n{\n\tstruct vm_struct *area;\n\tvoid *addr;\n\tunsigned long real_size = size;\n\n\tsize = PAGE_ALIGN(size);\n\tif (!size || (size >> PAGE_SHIFT) > totalram_pages)\n\t\tgoto fail;\n\n\tarea = __get_vm_area_node(size, align, VM_ALLOC | VM_UNINITIALIZED |\n\t\t\t\tvm_flags, start, end, node, gfp_mask, caller);\n\tif (!area)\n\t\tgoto fail;\n\n\taddr = __vmalloc_area_node(area, gfp_mask, prot, node);\n\tif (!addr)\n\t\treturn NULL;\n\n\t/*\n\t * In this function, newly allocated vm_struct has VM_UNINITIALIZED\n\t * flag. It means that vm_struct is not fully initialized.\n\t * Now, it is fully initialized, so remove this flag here.\n\t */\n\tclear_vm_uninitialized_flag(area);\n\n\tkmemleak_vmalloc(area, size, gfp_mask);\n\n\treturn addr;\n\nfail:\n\twarn_alloc(gfp_mask, NULL,\n\t\t\t  \"vmalloc: allocation failure: %lu bytes\", real_size);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);\n\nvoid *__vmalloc_node_range(unsigned long size, unsigned long align,\n\t\t\tunsigned long start, unsigned long end, gfp_t gfp_mask,\n\t\t\tpgprot_t prot, unsigned long vm_flags, int node,\n\t\t\tconst void *caller)\n{\n\tstruct vm_struct *area;\n\tvoid *addr;\n\tunsigned long real_size = size;\n\n\tsize = PAGE_ALIGN(size);\n\tif (!size || (size >> PAGE_SHIFT) > totalram_pages)\n\t\tgoto fail;\n\n\tarea = __get_vm_area_node(size, align, VM_ALLOC | VM_UNINITIALIZED |\n\t\t\t\tvm_flags, start, end, node, gfp_mask, caller);\n\tif (!area)\n\t\tgoto fail;\n\n\taddr = __vmalloc_area_node(area, gfp_mask, prot, node);\n\tif (!addr)\n\t\treturn NULL;\n\n\t/*\n\t * In this function, newly allocated vm_struct has VM_UNINITIALIZED\n\t * flag. It means that vm_struct is not fully initialized.\n\t * Now, it is fully initialized, so remove this flag here.\n\t */\n\tclear_vm_uninitialized_flag(area);\n\n\tkmemleak_vmalloc(area, size, gfp_mask);\n\n\treturn addr;\n\nfail:\n\twarn_alloc(gfp_mask, NULL,\n\t\t\t  \"vmalloc: allocation failure: %lu bytes\", real_size);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);\n\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller)\n{\n\treturn __vmalloc_node_range(size, align, VMALLOC_START, VMALLOC_END,\n\t\t\t\tgfp_mask, prot, 0, node, caller);\n}"
  },
  {
    "function_name": "__vmalloc_node_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "1732-1769",
    "snippet": "void *__vmalloc_node_range(unsigned long size, unsigned long align,\n\t\t\tunsigned long start, unsigned long end, gfp_t gfp_mask,\n\t\t\tpgprot_t prot, unsigned long vm_flags, int node,\n\t\t\tconst void *caller)\n{\n\tstruct vm_struct *area;\n\tvoid *addr;\n\tunsigned long real_size = size;\n\n\tsize = PAGE_ALIGN(size);\n\tif (!size || (size >> PAGE_SHIFT) > totalram_pages)\n\t\tgoto fail;\n\n\tarea = __get_vm_area_node(size, align, VM_ALLOC | VM_UNINITIALIZED |\n\t\t\t\tvm_flags, start, end, node, gfp_mask, caller);\n\tif (!area)\n\t\tgoto fail;\n\n\taddr = __vmalloc_area_node(area, gfp_mask, prot, node);\n\tif (!addr)\n\t\treturn NULL;\n\n\t/*\n\t * In this function, newly allocated vm_struct has VM_UNINITIALIZED\n\t * flag. It means that vm_struct is not fully initialized.\n\t * Now, it is fully initialized, so remove this flag here.\n\t */\n\tclear_vm_uninitialized_flag(area);\n\n\tkmemleak_vmalloc(area, size, gfp_mask);\n\n\treturn addr;\n\nfail:\n\twarn_alloc(gfp_mask, NULL,\n\t\t\t  \"vmalloc: allocation failure: %lu bytes\", real_size);\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "warn_alloc",
          "args": [
            "gfp_mask",
            "NULL",
            "\"vmalloc: allocation failure: %lu bytes\"",
            "real_size"
          ],
          "line": 1766
        },
        "resolved": true,
        "details": {
          "function_name": "warn_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3403-3425",
          "snippet": "void warn_alloc(gfp_t gfp_mask, nodemask_t *nodemask, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstatic DEFINE_RATELIMIT_STATE(nopage_rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);\n\n\tif ((gfp_mask & __GFP_NOWARN) || !__ratelimit(&nopage_rs))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"%s: %pV, mode:%#x(%pGg), nodemask=%*pbl\\n\",\n\t\t\tcurrent->comm, &vaf, gfp_mask, &gfp_mask,\n\t\t\tnodemask_pr_args(nodemask));\n\tva_end(args);\n\n\tcpuset_print_current_mems_allowed();\n\n\tdump_stack();\n\twarn_alloc_show_mem(gfp_mask, nodemask);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid warn_alloc(gfp_t gfp_mask, nodemask_t *nodemask, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstatic DEFINE_RATELIMIT_STATE(nopage_rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);\n\n\tif ((gfp_mask & __GFP_NOWARN) || !__ratelimit(&nopage_rs))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"%s: %pV, mode:%#x(%pGg), nodemask=%*pbl\\n\",\n\t\t\tcurrent->comm, &vaf, gfp_mask, &gfp_mask,\n\t\t\tnodemask_pr_args(nodemask));\n\tva_end(args);\n\n\tcpuset_print_current_mems_allowed();\n\n\tdump_stack();\n\twarn_alloc_show_mem(gfp_mask, nodemask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemleak_vmalloc",
          "args": [
            "area",
            "size",
            "gfp_mask"
          ],
          "line": 1761
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_vmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1016-1034",
          "snippet": "void __ref kmemleak_vmalloc(const struct vm_struct *area, size_t size, gfp_t gfp)\n{\n\tpr_debug(\"%s(0x%p, %zu)\\n\", __func__, area, size);\n\n\t/*\n\t * A min_count = 2 is needed because vm_struct contains a reference to\n\t * the virtual address of the vmalloc'ed block.\n\t */\n\tif (kmemleak_enabled) {\n\t\tcreate_object((unsigned long)area->addr, size, 2, gfp);\n\t\tobject_set_excess_ref((unsigned long)area,\n\t\t\t\t      (unsigned long)area->addr);\n\t} else if (kmemleak_early_log) {\n\t\tlog_early(KMEMLEAK_ALLOC, area->addr, size, 2);\n\t\t/* reusing early_log.size for storing area->addr */\n\t\tlog_early(KMEMLEAK_SET_EXCESS_REF,\n\t\t\t  area, (unsigned long)area->addr, 0);\n\t}\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kmemleak_enabled;",
            "static int kmemleak_early_log = 1;",
            "static struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_enabled;\nstatic int kmemleak_early_log = 1;\nstatic struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE];\n\nvoid __ref kmemleak_vmalloc(const struct vm_struct *area, size_t size, gfp_t gfp)\n{\n\tpr_debug(\"%s(0x%p, %zu)\\n\", __func__, area, size);\n\n\t/*\n\t * A min_count = 2 is needed because vm_struct contains a reference to\n\t * the virtual address of the vmalloc'ed block.\n\t */\n\tif (kmemleak_enabled) {\n\t\tcreate_object((unsigned long)area->addr, size, 2, gfp);\n\t\tobject_set_excess_ref((unsigned long)area,\n\t\t\t\t      (unsigned long)area->addr);\n\t} else if (kmemleak_early_log) {\n\t\tlog_early(KMEMLEAK_ALLOC, area->addr, size, 2);\n\t\t/* reusing early_log.size for storing area->addr */\n\t\tlog_early(KMEMLEAK_SET_EXCESS_REF,\n\t\t\t  area, (unsigned long)area->addr, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_vm_uninitialized_flag",
          "args": [
            "area"
          ],
          "line": 1759
        },
        "resolved": true,
        "details": {
          "function_name": "clear_vm_uninitialized_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1362-1371",
          "snippet": "static void clear_vm_uninitialized_flag(struct vm_struct *vm)\n{\n\t/*\n\t * Before removing VM_UNINITIALIZED,\n\t * we should make sure that vm has proper values.\n\t * Pair with smp_rmb() in show_numa_info().\n\t */\n\tsmp_wmb();\n\tvm->flags &= ~VM_UNINITIALIZED;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void clear_vm_uninitialized_flag(struct vm_struct *vm)\n{\n\t/*\n\t * Before removing VM_UNINITIALIZED,\n\t * we should make sure that vm has proper values.\n\t * Pair with smp_rmb() in show_numa_info().\n\t */\n\tsmp_wmb();\n\tvm->flags &= ~VM_UNINITIALIZED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__vmalloc_area_node",
          "args": [
            "area",
            "gfp_mask",
            "prot",
            "node"
          ],
          "line": 1750
        },
        "resolved": true,
        "details": {
          "function_name": "__vmalloc_area_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1657-1714",
          "snippet": "static void *__vmalloc_area_node(struct vm_struct *area, gfp_t gfp_mask,\n\t\t\t\t pgprot_t prot, int node)\n{\n\tstruct page **pages;\n\tunsigned int nr_pages, array_size, i;\n\tconst gfp_t nested_gfp = (gfp_mask & GFP_RECLAIM_MASK) | __GFP_ZERO;\n\tconst gfp_t alloc_mask = gfp_mask | __GFP_NOWARN;\n\tconst gfp_t highmem_mask = (gfp_mask & (GFP_DMA | GFP_DMA32)) ?\n\t\t\t\t\t0 :\n\t\t\t\t\t__GFP_HIGHMEM;\n\n\tnr_pages = get_vm_area_size(area) >> PAGE_SHIFT;\n\tarray_size = (nr_pages * sizeof(struct page *));\n\n\tarea->nr_pages = nr_pages;\n\t/* Please note that the recursion is strictly bounded. */\n\tif (array_size > PAGE_SIZE) {\n\t\tpages = __vmalloc_node(array_size, 1, nested_gfp|highmem_mask,\n\t\t\t\tPAGE_KERNEL, node, area->caller);\n\t} else {\n\t\tpages = kmalloc_node(array_size, nested_gfp, node);\n\t}\n\tarea->pages = pages;\n\tif (!area->pages) {\n\t\tremove_vm_area(area->addr);\n\t\tkfree(area);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < area->nr_pages; i++) {\n\t\tstruct page *page;\n\n\t\tif (node == NUMA_NO_NODE)\n\t\t\tpage = alloc_page(alloc_mask|highmem_mask);\n\t\telse\n\t\t\tpage = alloc_pages_node(node, alloc_mask|highmem_mask, 0);\n\n\t\tif (unlikely(!page)) {\n\t\t\t/* Successfully allocated i pages, free them in __vunmap() */\n\t\t\tarea->nr_pages = i;\n\t\t\tgoto fail;\n\t\t}\n\t\tarea->pages[i] = page;\n\t\tif (gfpflags_allow_blocking(gfp_mask|highmem_mask))\n\t\t\tcond_resched();\n\t}\n\n\tif (map_vm_area(area, prot, pages))\n\t\tgoto fail;\n\treturn area->addr;\n\nfail:\n\twarn_alloc(gfp_mask, NULL,\n\t\t\t  \"vmalloc: allocation failure, allocated %ld of %ld bytes\",\n\t\t\t  (area->nr_pages*PAGE_SIZE), area->size);\n\tvfree(area->addr);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __vunmap(const void *, int);",
            "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void __vunmap(const void *, int);\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);\n\nstatic void *__vmalloc_area_node(struct vm_struct *area, gfp_t gfp_mask,\n\t\t\t\t pgprot_t prot, int node)\n{\n\tstruct page **pages;\n\tunsigned int nr_pages, array_size, i;\n\tconst gfp_t nested_gfp = (gfp_mask & GFP_RECLAIM_MASK) | __GFP_ZERO;\n\tconst gfp_t alloc_mask = gfp_mask | __GFP_NOWARN;\n\tconst gfp_t highmem_mask = (gfp_mask & (GFP_DMA | GFP_DMA32)) ?\n\t\t\t\t\t0 :\n\t\t\t\t\t__GFP_HIGHMEM;\n\n\tnr_pages = get_vm_area_size(area) >> PAGE_SHIFT;\n\tarray_size = (nr_pages * sizeof(struct page *));\n\n\tarea->nr_pages = nr_pages;\n\t/* Please note that the recursion is strictly bounded. */\n\tif (array_size > PAGE_SIZE) {\n\t\tpages = __vmalloc_node(array_size, 1, nested_gfp|highmem_mask,\n\t\t\t\tPAGE_KERNEL, node, area->caller);\n\t} else {\n\t\tpages = kmalloc_node(array_size, nested_gfp, node);\n\t}\n\tarea->pages = pages;\n\tif (!area->pages) {\n\t\tremove_vm_area(area->addr);\n\t\tkfree(area);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < area->nr_pages; i++) {\n\t\tstruct page *page;\n\n\t\tif (node == NUMA_NO_NODE)\n\t\t\tpage = alloc_page(alloc_mask|highmem_mask);\n\t\telse\n\t\t\tpage = alloc_pages_node(node, alloc_mask|highmem_mask, 0);\n\n\t\tif (unlikely(!page)) {\n\t\t\t/* Successfully allocated i pages, free them in __vunmap() */\n\t\t\tarea->nr_pages = i;\n\t\t\tgoto fail;\n\t\t}\n\t\tarea->pages[i] = page;\n\t\tif (gfpflags_allow_blocking(gfp_mask|highmem_mask))\n\t\t\tcond_resched();\n\t}\n\n\tif (map_vm_area(area, prot, pages))\n\t\tgoto fail;\n\treturn area->addr;\n\nfail:\n\twarn_alloc(gfp_mask, NULL,\n\t\t\t  \"vmalloc: allocation failure, allocated %ld of %ld bytes\",\n\t\t\t  (area->nr_pages*PAGE_SIZE), area->size);\n\tvfree(area->addr);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_vm_area_node",
          "args": [
            "size",
            "align",
            "VM_ALLOC | VM_UNINITIALIZED |\n\t\t\t\tvm_flags",
            "start",
            "end",
            "node",
            "gfp_mask",
            "caller"
          ],
          "line": 1745
        },
        "resolved": true,
        "details": {
          "function_name": "__get_vm_area_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1373-1405",
          "snippet": "static struct vm_struct *__get_vm_area_node(unsigned long size,\n\t\tunsigned long align, unsigned long flags, unsigned long start,\n\t\tunsigned long end, int node, gfp_t gfp_mask, const void *caller)\n{\n\tstruct vmap_area *va;\n\tstruct vm_struct *area;\n\n\tBUG_ON(in_interrupt());\n\tsize = PAGE_ALIGN(size);\n\tif (unlikely(!size))\n\t\treturn NULL;\n\n\tif (flags & VM_IOREMAP)\n\t\talign = 1ul << clamp_t(int, get_count_order_long(size),\n\t\t\t\t       PAGE_SHIFT, IOREMAP_MAX_ORDER);\n\n\tarea = kzalloc_node(sizeof(*area), gfp_mask & GFP_RECLAIM_MASK, node);\n\tif (unlikely(!area))\n\t\treturn NULL;\n\n\tif (!(flags & VM_NO_GUARD))\n\t\tsize += PAGE_SIZE;\n\n\tva = alloc_vmap_area(size, align, start, end, node, gfp_mask);\n\tif (IS_ERR(va)) {\n\t\tkfree(area);\n\t\treturn NULL;\n\t}\n\n\tsetup_vmalloc_vm(area, va, flags, caller);\n\n\treturn area;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);\n\nstatic struct vm_struct *__get_vm_area_node(unsigned long size,\n\t\tunsigned long align, unsigned long flags, unsigned long start,\n\t\tunsigned long end, int node, gfp_t gfp_mask, const void *caller)\n{\n\tstruct vmap_area *va;\n\tstruct vm_struct *area;\n\n\tBUG_ON(in_interrupt());\n\tsize = PAGE_ALIGN(size);\n\tif (unlikely(!size))\n\t\treturn NULL;\n\n\tif (flags & VM_IOREMAP)\n\t\talign = 1ul << clamp_t(int, get_count_order_long(size),\n\t\t\t\t       PAGE_SHIFT, IOREMAP_MAX_ORDER);\n\n\tarea = kzalloc_node(sizeof(*area), gfp_mask & GFP_RECLAIM_MASK, node);\n\tif (unlikely(!area))\n\t\treturn NULL;\n\n\tif (!(flags & VM_NO_GUARD))\n\t\tsize += PAGE_SIZE;\n\n\tva = alloc_vmap_area(size, align, start, end, node, gfp_mask);\n\tif (IS_ERR(va)) {\n\t\tkfree(area);\n\t\treturn NULL;\n\t}\n\n\tsetup_vmalloc_vm(area, va, flags, caller);\n\n\treturn area;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "size"
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);\n\nvoid *__vmalloc_node_range(unsigned long size, unsigned long align,\n\t\t\tunsigned long start, unsigned long end, gfp_t gfp_mask,\n\t\t\tpgprot_t prot, unsigned long vm_flags, int node,\n\t\t\tconst void *caller)\n{\n\tstruct vm_struct *area;\n\tvoid *addr;\n\tunsigned long real_size = size;\n\n\tsize = PAGE_ALIGN(size);\n\tif (!size || (size >> PAGE_SHIFT) > totalram_pages)\n\t\tgoto fail;\n\n\tarea = __get_vm_area_node(size, align, VM_ALLOC | VM_UNINITIALIZED |\n\t\t\t\tvm_flags, start, end, node, gfp_mask, caller);\n\tif (!area)\n\t\tgoto fail;\n\n\taddr = __vmalloc_area_node(area, gfp_mask, prot, node);\n\tif (!addr)\n\t\treturn NULL;\n\n\t/*\n\t * In this function, newly allocated vm_struct has VM_UNINITIALIZED\n\t * flag. It means that vm_struct is not fully initialized.\n\t * Now, it is fully initialized, so remove this flag here.\n\t */\n\tclear_vm_uninitialized_flag(area);\n\n\tkmemleak_vmalloc(area, size, gfp_mask);\n\n\treturn addr;\n\nfail:\n\twarn_alloc(gfp_mask, NULL,\n\t\t\t  \"vmalloc: allocation failure: %lu bytes\", real_size);\n\treturn NULL;\n}"
  },
  {
    "function_name": "__vmalloc_area_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "1657-1714",
    "snippet": "static void *__vmalloc_area_node(struct vm_struct *area, gfp_t gfp_mask,\n\t\t\t\t pgprot_t prot, int node)\n{\n\tstruct page **pages;\n\tunsigned int nr_pages, array_size, i;\n\tconst gfp_t nested_gfp = (gfp_mask & GFP_RECLAIM_MASK) | __GFP_ZERO;\n\tconst gfp_t alloc_mask = gfp_mask | __GFP_NOWARN;\n\tconst gfp_t highmem_mask = (gfp_mask & (GFP_DMA | GFP_DMA32)) ?\n\t\t\t\t\t0 :\n\t\t\t\t\t__GFP_HIGHMEM;\n\n\tnr_pages = get_vm_area_size(area) >> PAGE_SHIFT;\n\tarray_size = (nr_pages * sizeof(struct page *));\n\n\tarea->nr_pages = nr_pages;\n\t/* Please note that the recursion is strictly bounded. */\n\tif (array_size > PAGE_SIZE) {\n\t\tpages = __vmalloc_node(array_size, 1, nested_gfp|highmem_mask,\n\t\t\t\tPAGE_KERNEL, node, area->caller);\n\t} else {\n\t\tpages = kmalloc_node(array_size, nested_gfp, node);\n\t}\n\tarea->pages = pages;\n\tif (!area->pages) {\n\t\tremove_vm_area(area->addr);\n\t\tkfree(area);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < area->nr_pages; i++) {\n\t\tstruct page *page;\n\n\t\tif (node == NUMA_NO_NODE)\n\t\t\tpage = alloc_page(alloc_mask|highmem_mask);\n\t\telse\n\t\t\tpage = alloc_pages_node(node, alloc_mask|highmem_mask, 0);\n\n\t\tif (unlikely(!page)) {\n\t\t\t/* Successfully allocated i pages, free them in __vunmap() */\n\t\t\tarea->nr_pages = i;\n\t\t\tgoto fail;\n\t\t}\n\t\tarea->pages[i] = page;\n\t\tif (gfpflags_allow_blocking(gfp_mask|highmem_mask))\n\t\t\tcond_resched();\n\t}\n\n\tif (map_vm_area(area, prot, pages))\n\t\tgoto fail;\n\treturn area->addr;\n\nfail:\n\twarn_alloc(gfp_mask, NULL,\n\t\t\t  \"vmalloc: allocation failure, allocated %ld of %ld bytes\",\n\t\t\t  (area->nr_pages*PAGE_SIZE), area->size);\n\tvfree(area->addr);\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __vunmap(const void *, int);",
      "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "area->addr"
          ],
          "line": 1712
        },
        "resolved": true,
        "details": {
          "function_name": "vfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1584-1598",
          "snippet": "void vfree(const void *addr)\n{\n\tBUG_ON(in_nmi());\n\n\tkmemleak_free(addr);\n\n\tmight_sleep_if(!in_interrupt());\n\n\tif (!addr)\n\t\treturn;\n\tif (unlikely(in_interrupt()))\n\t\t__vfree_deferred(addr);\n\telse\n\t\t__vunmap(addr, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __vunmap(const void *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void __vunmap(const void *, int);\n\nvoid vfree(const void *addr)\n{\n\tBUG_ON(in_nmi());\n\n\tkmemleak_free(addr);\n\n\tmight_sleep_if(!in_interrupt());\n\n\tif (!addr)\n\t\treturn;\n\tif (unlikely(in_interrupt()))\n\t\t__vfree_deferred(addr);\n\telse\n\t\t__vunmap(addr, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "warn_alloc",
          "args": [
            "gfp_mask",
            "NULL",
            "\"vmalloc: allocation failure, allocated %ld of %ld bytes\"",
            "(area->nr_pages*PAGE_SIZE)",
            "area->size"
          ],
          "line": 1709
        },
        "resolved": true,
        "details": {
          "function_name": "warn_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3403-3425",
          "snippet": "void warn_alloc(gfp_t gfp_mask, nodemask_t *nodemask, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstatic DEFINE_RATELIMIT_STATE(nopage_rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);\n\n\tif ((gfp_mask & __GFP_NOWARN) || !__ratelimit(&nopage_rs))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"%s: %pV, mode:%#x(%pGg), nodemask=%*pbl\\n\",\n\t\t\tcurrent->comm, &vaf, gfp_mask, &gfp_mask,\n\t\t\tnodemask_pr_args(nodemask));\n\tva_end(args);\n\n\tcpuset_print_current_mems_allowed();\n\n\tdump_stack();\n\twarn_alloc_show_mem(gfp_mask, nodemask);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid warn_alloc(gfp_t gfp_mask, nodemask_t *nodemask, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstatic DEFINE_RATELIMIT_STATE(nopage_rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);\n\n\tif ((gfp_mask & __GFP_NOWARN) || !__ratelimit(&nopage_rs))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"%s: %pV, mode:%#x(%pGg), nodemask=%*pbl\\n\",\n\t\t\tcurrent->comm, &vaf, gfp_mask, &gfp_mask,\n\t\t\tnodemask_pr_args(nodemask));\n\tva_end(args);\n\n\tcpuset_print_current_mems_allowed();\n\n\tdump_stack();\n\twarn_alloc_show_mem(gfp_mask, nodemask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_vm_area",
          "args": [
            "area",
            "prot",
            "pages"
          ],
          "line": 1704
        },
        "resolved": true,
        "details": {
          "function_name": "map_vm_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1337-1346",
          "snippet": "int map_vm_area(struct vm_struct *area, pgprot_t prot, struct page **pages)\n{\n\tunsigned long addr = (unsigned long)area->addr;\n\tunsigned long end = addr + get_vm_area_size(area);\n\tint err;\n\n\terr = vmap_page_range(addr, end, prot, pages);\n\n\treturn err > 0 ? 0 : err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nint map_vm_area(struct vm_struct *area, pgprot_t prot, struct page **pages)\n{\n\tunsigned long addr = (unsigned long)area->addr;\n\tunsigned long end = addr + get_vm_area_size(area);\n\tint err;\n\n\terr = vmap_page_range(addr, end, prot, pages);\n\n\treturn err > 0 ? 0 : err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfpflags_allow_blocking",
          "args": [
            "gfp_mask|highmem_mask"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_pages_node",
          "args": [
            "node",
            "alloc_mask|highmem_mask",
            "0"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "alloc_mask|highmem_mask"
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_hstate_alloc_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "2163-2184",
          "snippet": "static void __init hugetlb_hstate_alloc_pages(struct hstate *h)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < h->max_huge_pages; ++i) {\n\t\tif (hstate_is_gigantic(h)) {\n\t\t\tif (!alloc_bootmem_huge_page(h))\n\t\t\t\tbreak;\n\t\t} else if (!alloc_pool_huge_page(h,\n\t\t\t\t\t &node_states[N_MEMORY]))\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n\tif (i < h->max_huge_pages) {\n\t\tchar buf[32];\n\n\t\tstring_get_size(huge_page_size(h), 1, STRING_UNITS_2, buf, 32);\n\t\tpr_warn(\"HugeTLB: allocating %lu of page size %s failed.  Only allocated %lu hugepages.\\n\",\n\t\t\th->max_huge_pages, buf, i);\n\t\th->max_huge_pages = i;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nstatic void __init hugetlb_hstate_alloc_pages(struct hstate *h)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < h->max_huge_pages; ++i) {\n\t\tif (hstate_is_gigantic(h)) {\n\t\t\tif (!alloc_bootmem_huge_page(h))\n\t\t\t\tbreak;\n\t\t} else if (!alloc_pool_huge_page(h,\n\t\t\t\t\t &node_states[N_MEMORY]))\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n\tif (i < h->max_huge_pages) {\n\t\tchar buf[32];\n\n\t\tstring_get_size(huge_page_size(h), 1, STRING_UNITS_2, buf, 32);\n\t\tpr_warn(\"HugeTLB: allocating %lu of page size %s failed.  Only allocated %lu hugepages.\\n\",\n\t\t\th->max_huge_pages, buf, i);\n\t\th->max_huge_pages = i;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "area"
          ],
          "line": 1682
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_vm_area",
          "args": [
            "area->addr"
          ],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "remove_vm_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1473-1495",
          "snippet": "struct vm_struct *remove_vm_area(const void *addr)\n{\n\tstruct vmap_area *va;\n\n\tmight_sleep();\n\n\tva = find_vmap_area((unsigned long)addr);\n\tif (va && va->flags & VM_VM_AREA) {\n\t\tstruct vm_struct *vm = va->vm;\n\n\t\tspin_lock(&vmap_area_lock);\n\t\tva->vm = NULL;\n\t\tva->flags &= ~VM_VM_AREA;\n\t\tva->flags |= VM_LAZY_FREE;\n\t\tspin_unlock(&vmap_area_lock);\n\n\t\tkasan_free_shadow(vm);\n\t\tfree_unmap_vmap_area(va);\n\n\t\treturn vm;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [
            "#define VM_VM_AREA\t0x04",
            "#define VM_LAZY_FREE\t0x02"
          ],
          "globals_used": [
            "static DEFINE_SPINLOCK(vmap_area_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\n#define VM_VM_AREA\t0x04\n#define VM_LAZY_FREE\t0x02\n\nstatic DEFINE_SPINLOCK(vmap_area_lock);\n\nstruct vm_struct *remove_vm_area(const void *addr)\n{\n\tstruct vmap_area *va;\n\n\tmight_sleep();\n\n\tva = find_vmap_area((unsigned long)addr);\n\tif (va && va->flags & VM_VM_AREA) {\n\t\tstruct vm_struct *vm = va->vm;\n\n\t\tspin_lock(&vmap_area_lock);\n\t\tva->vm = NULL;\n\t\tva->flags &= ~VM_VM_AREA;\n\t\tva->flags |= VM_LAZY_FREE;\n\t\tspin_unlock(&vmap_area_lock);\n\n\t\tkasan_free_shadow(vm);\n\t\tfree_unmap_vmap_area(va);\n\n\t\treturn vm;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc_node",
          "args": [
            "array_size",
            "nested_gfp",
            "node"
          ],
          "line": 1677
        },
        "resolved": true,
        "details": {
          "function_name": "__kmalloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3689-3692",
          "snippet": "void *__kmalloc_node(size_t size, gfp_t flags, int node)\n{\n\treturn __do_kmalloc_node(size, flags, node, _RET_IP_);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nvoid *__kmalloc_node(size_t size, gfp_t flags, int node)\n{\n\treturn __do_kmalloc_node(size, flags, node, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__vmalloc_node",
          "args": [
            "array_size",
            "1",
            "nested_gfp|highmem_mask",
            "PAGE_KERNEL",
            "node",
            "area->caller"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "__vmalloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1791-1797",
          "snippet": "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller)\n{\n\treturn __vmalloc_node_range(size, align, VMALLOC_START, VMALLOC_END,\n\t\t\t\tgfp_mask, prot, 0, node, caller);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);\n\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller)\n{\n\treturn __vmalloc_node_range(size, align, VMALLOC_START, VMALLOC_END,\n\t\t\t\tgfp_mask, prot, 0, node, caller);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_vm_area_size",
          "args": [
            "area"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void __vunmap(const void *, int);\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);\n\nstatic void *__vmalloc_area_node(struct vm_struct *area, gfp_t gfp_mask,\n\t\t\t\t pgprot_t prot, int node)\n{\n\tstruct page **pages;\n\tunsigned int nr_pages, array_size, i;\n\tconst gfp_t nested_gfp = (gfp_mask & GFP_RECLAIM_MASK) | __GFP_ZERO;\n\tconst gfp_t alloc_mask = gfp_mask | __GFP_NOWARN;\n\tconst gfp_t highmem_mask = (gfp_mask & (GFP_DMA | GFP_DMA32)) ?\n\t\t\t\t\t0 :\n\t\t\t\t\t__GFP_HIGHMEM;\n\n\tnr_pages = get_vm_area_size(area) >> PAGE_SHIFT;\n\tarray_size = (nr_pages * sizeof(struct page *));\n\n\tarea->nr_pages = nr_pages;\n\t/* Please note that the recursion is strictly bounded. */\n\tif (array_size > PAGE_SIZE) {\n\t\tpages = __vmalloc_node(array_size, 1, nested_gfp|highmem_mask,\n\t\t\t\tPAGE_KERNEL, node, area->caller);\n\t} else {\n\t\tpages = kmalloc_node(array_size, nested_gfp, node);\n\t}\n\tarea->pages = pages;\n\tif (!area->pages) {\n\t\tremove_vm_area(area->addr);\n\t\tkfree(area);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < area->nr_pages; i++) {\n\t\tstruct page *page;\n\n\t\tif (node == NUMA_NO_NODE)\n\t\t\tpage = alloc_page(alloc_mask|highmem_mask);\n\t\telse\n\t\t\tpage = alloc_pages_node(node, alloc_mask|highmem_mask, 0);\n\n\t\tif (unlikely(!page)) {\n\t\t\t/* Successfully allocated i pages, free them in __vunmap() */\n\t\t\tarea->nr_pages = i;\n\t\t\tgoto fail;\n\t\t}\n\t\tarea->pages[i] = page;\n\t\tif (gfpflags_allow_blocking(gfp_mask|highmem_mask))\n\t\t\tcond_resched();\n\t}\n\n\tif (map_vm_area(area, prot, pages))\n\t\tgoto fail;\n\treturn area->addr;\n\nfail:\n\twarn_alloc(gfp_mask, NULL,\n\t\t\t  \"vmalloc: allocation failure, allocated %ld of %ld bytes\",\n\t\t\t  (area->nr_pages*PAGE_SIZE), area->size);\n\tvfree(area->addr);\n\treturn NULL;\n}"
  },
  {
    "function_name": "vmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "1629-1651",
    "snippet": "void *vmap(struct page **pages, unsigned int count,\n\t\tunsigned long flags, pgprot_t prot)\n{\n\tstruct vm_struct *area;\n\tunsigned long size;\t\t/* In bytes */\n\n\tmight_sleep();\n\n\tif (count > totalram_pages)\n\t\treturn NULL;\n\n\tsize = (unsigned long)count << PAGE_SHIFT;\n\tarea = get_vm_area_caller(size, flags, __builtin_return_address(0));\n\tif (!area)\n\t\treturn NULL;\n\n\tif (map_vm_area(area, prot, pages)) {\n\t\tvunmap(area->addr);\n\t\treturn NULL;\n\t}\n\n\treturn area->addr;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vunmap",
          "args": [
            "area->addr"
          ],
          "line": 1646
        },
        "resolved": true,
        "details": {
          "function_name": "vunmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1610-1616",
          "snippet": "void vunmap(const void *addr)\n{\n\tBUG_ON(in_interrupt());\n\tmight_sleep();\n\tif (addr)\n\t\t__vunmap(addr, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __vunmap(const void *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void __vunmap(const void *, int);\n\nvoid vunmap(const void *addr)\n{\n\tBUG_ON(in_interrupt());\n\tmight_sleep();\n\tif (addr)\n\t\t__vunmap(addr, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_vm_area",
          "args": [
            "area",
            "prot",
            "pages"
          ],
          "line": 1645
        },
        "resolved": true,
        "details": {
          "function_name": "map_vm_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1337-1346",
          "snippet": "int map_vm_area(struct vm_struct *area, pgprot_t prot, struct page **pages)\n{\n\tunsigned long addr = (unsigned long)area->addr;\n\tunsigned long end = addr + get_vm_area_size(area);\n\tint err;\n\n\terr = vmap_page_range(addr, end, prot, pages);\n\n\treturn err > 0 ? 0 : err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nint map_vm_area(struct vm_struct *area, pgprot_t prot, struct page **pages)\n{\n\tunsigned long addr = (unsigned long)area->addr;\n\tunsigned long end = addr + get_vm_area_size(area);\n\tint err;\n\n\terr = vmap_page_range(addr, end, prot, pages);\n\n\treturn err > 0 ? 0 : err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_vm_area_caller",
          "args": [
            "size",
            "flags",
            "__builtin_return_address(0)"
          ],
          "line": 1641
        },
        "resolved": true,
        "details": {
          "function_name": "get_vm_area_caller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1439-1444",
          "snippet": "struct vm_struct *get_vm_area_caller(unsigned long size, unsigned long flags,\n\t\t\t\tconst void *caller)\n{\n\treturn __get_vm_area_node(size, 1, flags, VMALLOC_START, VMALLOC_END,\n\t\t\t\t  NUMA_NO_NODE, GFP_KERNEL, caller);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);\n\nstruct vm_struct *get_vm_area_caller(unsigned long size, unsigned long flags,\n\t\t\t\tconst void *caller)\n{\n\treturn __get_vm_area_node(size, 1, flags, VMALLOC_START, VMALLOC_END,\n\t\t\t\t  NUMA_NO_NODE, GFP_KERNEL, caller);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__builtin_return_address",
          "args": [
            "0"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nvoid *vmap(struct page **pages, unsigned int count,\n\t\tunsigned long flags, pgprot_t prot)\n{\n\tstruct vm_struct *area;\n\tunsigned long size;\t\t/* In bytes */\n\n\tmight_sleep();\n\n\tif (count > totalram_pages)\n\t\treturn NULL;\n\n\tsize = (unsigned long)count << PAGE_SHIFT;\n\tarea = get_vm_area_caller(size, flags, __builtin_return_address(0));\n\tif (!area)\n\t\treturn NULL;\n\n\tif (map_vm_area(area, prot, pages)) {\n\t\tvunmap(area->addr);\n\t\treturn NULL;\n\t}\n\n\treturn area->addr;\n}"
  },
  {
    "function_name": "vunmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "1610-1616",
    "snippet": "void vunmap(const void *addr)\n{\n\tBUG_ON(in_interrupt());\n\tmight_sleep();\n\tif (addr)\n\t\t__vunmap(addr, 0);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __vunmap(const void *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vunmap",
          "args": [
            "addr",
            "0"
          ],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "__vunmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1497-1534",
          "snippet": "static void __vunmap(const void *addr, int deallocate_pages)\n{\n\tstruct vm_struct *area;\n\n\tif (!addr)\n\t\treturn;\n\n\tif (WARN(!PAGE_ALIGNED(addr), \"Trying to vfree() bad address (%p)\\n\",\n\t\t\taddr))\n\t\treturn;\n\n\tarea = find_vmap_area((unsigned long)addr)->vm;\n\tif (unlikely(!area)) {\n\t\tWARN(1, KERN_ERR \"Trying to vfree() nonexistent vm area (%p)\\n\",\n\t\t\t\taddr);\n\t\treturn;\n\t}\n\n\tdebug_check_no_locks_freed(area->addr, get_vm_area_size(area));\n\tdebug_check_no_obj_freed(area->addr, get_vm_area_size(area));\n\n\tremove_vm_area(addr);\n\tif (deallocate_pages) {\n\t\tint i;\n\n\t\tfor (i = 0; i < area->nr_pages; i++) {\n\t\t\tstruct page *page = area->pages[i];\n\n\t\t\tBUG_ON(!page);\n\t\t\t__free_pages(page, 0);\n\t\t}\n\n\t\tkvfree(area->pages);\n\t}\n\n\tkfree(area);\n\treturn;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __vunmap(const void *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void __vunmap(const void *, int);\n\nstatic void __vunmap(const void *addr, int deallocate_pages)\n{\n\tstruct vm_struct *area;\n\n\tif (!addr)\n\t\treturn;\n\n\tif (WARN(!PAGE_ALIGNED(addr), \"Trying to vfree() bad address (%p)\\n\",\n\t\t\taddr))\n\t\treturn;\n\n\tarea = find_vmap_area((unsigned long)addr)->vm;\n\tif (unlikely(!area)) {\n\t\tWARN(1, KERN_ERR \"Trying to vfree() nonexistent vm area (%p)\\n\",\n\t\t\t\taddr);\n\t\treturn;\n\t}\n\n\tdebug_check_no_locks_freed(area->addr, get_vm_area_size(area));\n\tdebug_check_no_obj_freed(area->addr, get_vm_area_size(area));\n\n\tremove_vm_area(addr);\n\tif (deallocate_pages) {\n\t\tint i;\n\n\t\tfor (i = 0; i < area->nr_pages; i++) {\n\t\t\tstruct page *page = area->pages[i];\n\n\t\t\tBUG_ON(!page);\n\t\t\t__free_pages(page, 0);\n\t\t}\n\n\t\tkvfree(area->pages);\n\t}\n\n\tkfree(area);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "in_interrupt()"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_interrupt",
          "args": [],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void __vunmap(const void *, int);\n\nvoid vunmap(const void *addr)\n{\n\tBUG_ON(in_interrupt());\n\tmight_sleep();\n\tif (addr)\n\t\t__vunmap(addr, 0);\n}"
  },
  {
    "function_name": "vfree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "1584-1598",
    "snippet": "void vfree(const void *addr)\n{\n\tBUG_ON(in_nmi());\n\n\tkmemleak_free(addr);\n\n\tmight_sleep_if(!in_interrupt());\n\n\tif (!addr)\n\t\treturn;\n\tif (unlikely(in_interrupt()))\n\t\t__vfree_deferred(addr);\n\telse\n\t\t__vunmap(addr, 1);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __vunmap(const void *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vunmap",
          "args": [
            "addr",
            "1"
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "__vunmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1497-1534",
          "snippet": "static void __vunmap(const void *addr, int deallocate_pages)\n{\n\tstruct vm_struct *area;\n\n\tif (!addr)\n\t\treturn;\n\n\tif (WARN(!PAGE_ALIGNED(addr), \"Trying to vfree() bad address (%p)\\n\",\n\t\t\taddr))\n\t\treturn;\n\n\tarea = find_vmap_area((unsigned long)addr)->vm;\n\tif (unlikely(!area)) {\n\t\tWARN(1, KERN_ERR \"Trying to vfree() nonexistent vm area (%p)\\n\",\n\t\t\t\taddr);\n\t\treturn;\n\t}\n\n\tdebug_check_no_locks_freed(area->addr, get_vm_area_size(area));\n\tdebug_check_no_obj_freed(area->addr, get_vm_area_size(area));\n\n\tremove_vm_area(addr);\n\tif (deallocate_pages) {\n\t\tint i;\n\n\t\tfor (i = 0; i < area->nr_pages; i++) {\n\t\t\tstruct page *page = area->pages[i];\n\n\t\t\tBUG_ON(!page);\n\t\t\t__free_pages(page, 0);\n\t\t}\n\n\t\tkvfree(area->pages);\n\t}\n\n\tkfree(area);\n\treturn;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __vunmap(const void *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void __vunmap(const void *, int);\n\nstatic void __vunmap(const void *addr, int deallocate_pages)\n{\n\tstruct vm_struct *area;\n\n\tif (!addr)\n\t\treturn;\n\n\tif (WARN(!PAGE_ALIGNED(addr), \"Trying to vfree() bad address (%p)\\n\",\n\t\t\taddr))\n\t\treturn;\n\n\tarea = find_vmap_area((unsigned long)addr)->vm;\n\tif (unlikely(!area)) {\n\t\tWARN(1, KERN_ERR \"Trying to vfree() nonexistent vm area (%p)\\n\",\n\t\t\t\taddr);\n\t\treturn;\n\t}\n\n\tdebug_check_no_locks_freed(area->addr, get_vm_area_size(area));\n\tdebug_check_no_obj_freed(area->addr, get_vm_area_size(area));\n\n\tremove_vm_area(addr);\n\tif (deallocate_pages) {\n\t\tint i;\n\n\t\tfor (i = 0; i < area->nr_pages; i++) {\n\t\t\tstruct page *page = area->pages[i];\n\n\t\t\tBUG_ON(!page);\n\t\t\t__free_pages(page, 0);\n\t\t}\n\n\t\tkvfree(area->pages);\n\t}\n\n\tkfree(area);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__vfree_deferred",
          "args": [
            "addr"
          ],
          "line": 1595
        },
        "resolved": true,
        "details": {
          "function_name": "__vfree_deferred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1536-1548",
          "snippet": "static inline void __vfree_deferred(const void *addr)\n{\n\t/*\n\t * Use raw_cpu_ptr() because this can be called from preemptible\n\t * context. Preemption is absolutely fine here, because the llist_add()\n\t * implementation is lockless, so it works even if we are adding to\n\t * nother cpu's list.  schedule_work() should be fine with this too.\n\t */\n\tstruct vfree_deferred *p = raw_cpu_ptr(&vfree_deferred);\n\n\tif (llist_add((struct llist_node *)addr, &p->list))\n\t\tschedule_work(&p->wq);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct vfree_deferred, vfree_deferred);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic DEFINE_PER_CPU(struct vfree_deferred, vfree_deferred);\n\nstatic inline void __vfree_deferred(const void *addr)\n{\n\t/*\n\t * Use raw_cpu_ptr() because this can be called from preemptible\n\t * context. Preemption is absolutely fine here, because the llist_add()\n\t * implementation is lockless, so it works even if we are adding to\n\t * nother cpu's list.  schedule_work() should be fine with this too.\n\t */\n\tstruct vfree_deferred *p = raw_cpu_ptr(&vfree_deferred);\n\n\tif (llist_add((struct llist_node *)addr, &p->list))\n\t\tschedule_work(&p->wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "in_interrupt()"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_interrupt",
          "args": [],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep_if",
          "args": [
            "!in_interrupt()"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_interrupt",
          "args": [],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemleak_free",
          "args": [
            "addr"
          ],
          "line": 1588
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_free_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1082-1094",
          "snippet": "void __ref kmemleak_free_percpu(const void __percpu *ptr)\n{\n\tunsigned int cpu;\n\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (kmemleak_free_enabled && ptr && !IS_ERR(ptr))\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tdelete_object_full((unsigned long)per_cpu_ptr(ptr,\n\t\t\t\t\t\t\t\t      cpu));\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_FREE_PERCPU, ptr, 0, 0);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kmemleak_free_enabled;",
            "static int kmemleak_early_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_free_enabled;\nstatic int kmemleak_early_log = 1;\n\nvoid __ref kmemleak_free_percpu(const void __percpu *ptr)\n{\n\tunsigned int cpu;\n\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (kmemleak_free_enabled && ptr && !IS_ERR(ptr))\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tdelete_object_full((unsigned long)per_cpu_ptr(ptr,\n\t\t\t\t\t\t\t\t      cpu));\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_FREE_PERCPU, ptr, 0, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "in_nmi()"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void __vunmap(const void *, int);\n\nvoid vfree(const void *addr)\n{\n\tBUG_ON(in_nmi());\n\n\tkmemleak_free(addr);\n\n\tmight_sleep_if(!in_interrupt());\n\n\tif (!addr)\n\t\treturn;\n\tif (unlikely(in_interrupt()))\n\t\t__vfree_deferred(addr);\n\telse\n\t\t__vunmap(addr, 1);\n}"
  },
  {
    "function_name": "vfree_atomic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "1557-1566",
    "snippet": "void vfree_atomic(const void *addr)\n{\n\tBUG_ON(in_nmi());\n\n\tkmemleak_free(addr);\n\n\tif (!addr)\n\t\treturn;\n\t__vfree_deferred(addr);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vfree_deferred",
          "args": [
            "addr"
          ],
          "line": 1565
        },
        "resolved": true,
        "details": {
          "function_name": "__vfree_deferred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1536-1548",
          "snippet": "static inline void __vfree_deferred(const void *addr)\n{\n\t/*\n\t * Use raw_cpu_ptr() because this can be called from preemptible\n\t * context. Preemption is absolutely fine here, because the llist_add()\n\t * implementation is lockless, so it works even if we are adding to\n\t * nother cpu's list.  schedule_work() should be fine with this too.\n\t */\n\tstruct vfree_deferred *p = raw_cpu_ptr(&vfree_deferred);\n\n\tif (llist_add((struct llist_node *)addr, &p->list))\n\t\tschedule_work(&p->wq);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct vfree_deferred, vfree_deferred);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic DEFINE_PER_CPU(struct vfree_deferred, vfree_deferred);\n\nstatic inline void __vfree_deferred(const void *addr)\n{\n\t/*\n\t * Use raw_cpu_ptr() because this can be called from preemptible\n\t * context. Preemption is absolutely fine here, because the llist_add()\n\t * implementation is lockless, so it works even if we are adding to\n\t * nother cpu's list.  schedule_work() should be fine with this too.\n\t */\n\tstruct vfree_deferred *p = raw_cpu_ptr(&vfree_deferred);\n\n\tif (llist_add((struct llist_node *)addr, &p->list))\n\t\tschedule_work(&p->wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemleak_free",
          "args": [
            "addr"
          ],
          "line": 1561
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_free_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1082-1094",
          "snippet": "void __ref kmemleak_free_percpu(const void __percpu *ptr)\n{\n\tunsigned int cpu;\n\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (kmemleak_free_enabled && ptr && !IS_ERR(ptr))\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tdelete_object_full((unsigned long)per_cpu_ptr(ptr,\n\t\t\t\t\t\t\t\t      cpu));\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_FREE_PERCPU, ptr, 0, 0);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kmemleak_free_enabled;",
            "static int kmemleak_early_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_free_enabled;\nstatic int kmemleak_early_log = 1;\n\nvoid __ref kmemleak_free_percpu(const void __percpu *ptr)\n{\n\tunsigned int cpu;\n\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (kmemleak_free_enabled && ptr && !IS_ERR(ptr))\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tdelete_object_full((unsigned long)per_cpu_ptr(ptr,\n\t\t\t\t\t\t\t\t      cpu));\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_FREE_PERCPU, ptr, 0, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "in_nmi()"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nvoid vfree_atomic(const void *addr)\n{\n\tBUG_ON(in_nmi());\n\n\tkmemleak_free(addr);\n\n\tif (!addr)\n\t\treturn;\n\t__vfree_deferred(addr);\n}"
  },
  {
    "function_name": "__vfree_deferred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "1536-1548",
    "snippet": "static inline void __vfree_deferred(const void *addr)\n{\n\t/*\n\t * Use raw_cpu_ptr() because this can be called from preemptible\n\t * context. Preemption is absolutely fine here, because the llist_add()\n\t * implementation is lockless, so it works even if we are adding to\n\t * nother cpu's list.  schedule_work() should be fine with this too.\n\t */\n\tstruct vfree_deferred *p = raw_cpu_ptr(&vfree_deferred);\n\n\tif (llist_add((struct llist_node *)addr, &p->list))\n\t\tschedule_work(&p->wq);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct vfree_deferred, vfree_deferred);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&p->wq"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llist_add",
          "args": [
            "(struct llist_node *)addr",
            "&p->list"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_cpu_ptr",
          "args": [
            "&vfree_deferred"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic DEFINE_PER_CPU(struct vfree_deferred, vfree_deferred);\n\nstatic inline void __vfree_deferred(const void *addr)\n{\n\t/*\n\t * Use raw_cpu_ptr() because this can be called from preemptible\n\t * context. Preemption is absolutely fine here, because the llist_add()\n\t * implementation is lockless, so it works even if we are adding to\n\t * nother cpu's list.  schedule_work() should be fine with this too.\n\t */\n\tstruct vfree_deferred *p = raw_cpu_ptr(&vfree_deferred);\n\n\tif (llist_add((struct llist_node *)addr, &p->list))\n\t\tschedule_work(&p->wq);\n}"
  },
  {
    "function_name": "__vunmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "1497-1534",
    "snippet": "static void __vunmap(const void *addr, int deallocate_pages)\n{\n\tstruct vm_struct *area;\n\n\tif (!addr)\n\t\treturn;\n\n\tif (WARN(!PAGE_ALIGNED(addr), \"Trying to vfree() bad address (%p)\\n\",\n\t\t\taddr))\n\t\treturn;\n\n\tarea = find_vmap_area((unsigned long)addr)->vm;\n\tif (unlikely(!area)) {\n\t\tWARN(1, KERN_ERR \"Trying to vfree() nonexistent vm area (%p)\\n\",\n\t\t\t\taddr);\n\t\treturn;\n\t}\n\n\tdebug_check_no_locks_freed(area->addr, get_vm_area_size(area));\n\tdebug_check_no_obj_freed(area->addr, get_vm_area_size(area));\n\n\tremove_vm_area(addr);\n\tif (deallocate_pages) {\n\t\tint i;\n\n\t\tfor (i = 0; i < area->nr_pages; i++) {\n\t\t\tstruct page *page = area->pages[i];\n\n\t\t\tBUG_ON(!page);\n\t\t\t__free_pages(page, 0);\n\t\t}\n\n\t\tkvfree(area->pages);\n\t}\n\n\tkfree(area);\n\treturn;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __vunmap(const void *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "area"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "area->pages"
          ],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "kvfree_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "395-401",
          "snippet": "static void kvfree_rcu(struct rcu_head *head)\n{\n\tstruct list_lru_memcg *mlru;\n\n\tmlru = container_of(head, struct list_lru_memcg, rcu);\n\tkvfree(mlru);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void kvfree_rcu(struct rcu_head *head)\n{\n\tstruct list_lru_memcg *mlru;\n\n\tmlru = container_of(head, struct list_lru_memcg, rcu);\n\tkvfree(mlru);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_pages",
          "args": [
            "page",
            "0"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "__free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4430-4438",
          "snippet": "void __free_pages(struct page *page, unsigned int order)\n{\n\tif (put_page_testzero(page)) {\n\t\tif (order == 0)\n\t\t\tfree_unref_page(page);\n\t\telse\n\t\t\t__free_pages_ok(page, order);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid __free_pages(struct page *page, unsigned int order)\n{\n\tif (put_page_testzero(page)) {\n\t\tif (order == 0)\n\t\t\tfree_unref_page(page);\n\t\telse\n\t\t\t__free_pages_ok(page, order);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!page"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_vm_area",
          "args": [
            "addr"
          ],
          "line": 1518
        },
        "resolved": true,
        "details": {
          "function_name": "remove_vm_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1473-1495",
          "snippet": "struct vm_struct *remove_vm_area(const void *addr)\n{\n\tstruct vmap_area *va;\n\n\tmight_sleep();\n\n\tva = find_vmap_area((unsigned long)addr);\n\tif (va && va->flags & VM_VM_AREA) {\n\t\tstruct vm_struct *vm = va->vm;\n\n\t\tspin_lock(&vmap_area_lock);\n\t\tva->vm = NULL;\n\t\tva->flags &= ~VM_VM_AREA;\n\t\tva->flags |= VM_LAZY_FREE;\n\t\tspin_unlock(&vmap_area_lock);\n\n\t\tkasan_free_shadow(vm);\n\t\tfree_unmap_vmap_area(va);\n\n\t\treturn vm;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [
            "#define VM_VM_AREA\t0x04",
            "#define VM_LAZY_FREE\t0x02"
          ],
          "globals_used": [
            "static DEFINE_SPINLOCK(vmap_area_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\n#define VM_VM_AREA\t0x04\n#define VM_LAZY_FREE\t0x02\n\nstatic DEFINE_SPINLOCK(vmap_area_lock);\n\nstruct vm_struct *remove_vm_area(const void *addr)\n{\n\tstruct vmap_area *va;\n\n\tmight_sleep();\n\n\tva = find_vmap_area((unsigned long)addr);\n\tif (va && va->flags & VM_VM_AREA) {\n\t\tstruct vm_struct *vm = va->vm;\n\n\t\tspin_lock(&vmap_area_lock);\n\t\tva->vm = NULL;\n\t\tva->flags &= ~VM_VM_AREA;\n\t\tva->flags |= VM_LAZY_FREE;\n\t\tspin_unlock(&vmap_area_lock);\n\n\t\tkasan_free_shadow(vm);\n\t\tfree_unmap_vmap_area(va);\n\n\t\treturn vm;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_check_no_obj_freed",
          "args": [
            "area->addr",
            "get_vm_area_size(area)"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_vm_area_size",
          "args": [
            "area"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_check_no_locks_freed",
          "args": [
            "area->addr",
            "get_vm_area_size(area)"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_vm_area_size",
          "args": [
            "area"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "KERN_ERR \"Trying to vfree() nonexistent vm area (%p)\\n\"",
            "addr"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!area"
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_vmap_area",
          "args": [
            "(unsigned long)addr"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "find_vmap_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "745-754",
          "snippet": "static struct vmap_area *find_vmap_area(unsigned long addr)\n{\n\tstruct vmap_area *va;\n\n\tspin_lock(&vmap_area_lock);\n\tva = __find_vmap_area(addr);\n\tspin_unlock(&vmap_area_lock);\n\n\treturn va;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(vmap_area_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic DEFINE_SPINLOCK(vmap_area_lock);\n\nstatic struct vmap_area *find_vmap_area(unsigned long addr)\n{\n\tstruct vmap_area *va;\n\n\tspin_lock(&vmap_area_lock);\n\tva = __find_vmap_area(addr);\n\tspin_unlock(&vmap_area_lock);\n\n\treturn va;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "!PAGE_ALIGNED(addr)",
            "\"Trying to vfree() bad address (%p)\\n\"",
            "addr"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGNED",
          "args": [
            "addr"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void __vunmap(const void *, int);\n\nstatic void __vunmap(const void *addr, int deallocate_pages)\n{\n\tstruct vm_struct *area;\n\n\tif (!addr)\n\t\treturn;\n\n\tif (WARN(!PAGE_ALIGNED(addr), \"Trying to vfree() bad address (%p)\\n\",\n\t\t\taddr))\n\t\treturn;\n\n\tarea = find_vmap_area((unsigned long)addr)->vm;\n\tif (unlikely(!area)) {\n\t\tWARN(1, KERN_ERR \"Trying to vfree() nonexistent vm area (%p)\\n\",\n\t\t\t\taddr);\n\t\treturn;\n\t}\n\n\tdebug_check_no_locks_freed(area->addr, get_vm_area_size(area));\n\tdebug_check_no_obj_freed(area->addr, get_vm_area_size(area));\n\n\tremove_vm_area(addr);\n\tif (deallocate_pages) {\n\t\tint i;\n\n\t\tfor (i = 0; i < area->nr_pages; i++) {\n\t\t\tstruct page *page = area->pages[i];\n\n\t\t\tBUG_ON(!page);\n\t\t\t__free_pages(page, 0);\n\t\t}\n\n\t\tkvfree(area->pages);\n\t}\n\n\tkfree(area);\n\treturn;\n}"
  },
  {
    "function_name": "remove_vm_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "1473-1495",
    "snippet": "struct vm_struct *remove_vm_area(const void *addr)\n{\n\tstruct vmap_area *va;\n\n\tmight_sleep();\n\n\tva = find_vmap_area((unsigned long)addr);\n\tif (va && va->flags & VM_VM_AREA) {\n\t\tstruct vm_struct *vm = va->vm;\n\n\t\tspin_lock(&vmap_area_lock);\n\t\tva->vm = NULL;\n\t\tva->flags &= ~VM_VM_AREA;\n\t\tva->flags |= VM_LAZY_FREE;\n\t\tspin_unlock(&vmap_area_lock);\n\n\t\tkasan_free_shadow(vm);\n\t\tfree_unmap_vmap_area(va);\n\n\t\treturn vm;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [
      "#define VM_VM_AREA\t0x04",
      "#define VM_LAZY_FREE\t0x02"
    ],
    "globals_used": [
      "static DEFINE_SPINLOCK(vmap_area_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_unmap_vmap_area",
          "args": [
            "va"
          ],
          "line": 1490
        },
        "resolved": true,
        "details": {
          "function_name": "free_unmap_vmap_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "735-743",
          "snippet": "static void free_unmap_vmap_area(struct vmap_area *va)\n{\n\tflush_cache_vunmap(va->va_start, va->va_end);\n\tunmap_vmap_area(va);\n\tif (debug_pagealloc_enabled())\n\t\tflush_tlb_kernel_range(va->va_start, va->va_end);\n\n\tfree_vmap_area_noflush(va);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void free_unmap_vmap_area(struct vmap_area *va)\n{\n\tflush_cache_vunmap(va->va_start, va->va_end);\n\tunmap_vmap_area(va);\n\tif (debug_pagealloc_enabled())\n\t\tflush_tlb_kernel_range(va->va_start, va->va_end);\n\n\tfree_vmap_area_noflush(va);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kasan_free_shadow",
          "args": [
            "vm"
          ],
          "line": 1489
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_free_shadow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "648-652",
          "snippet": "void kasan_free_shadow(const struct vm_struct *vm)\n{\n\tif (vm->flags & VM_KASAN)\n\t\tvfree(kasan_mem_to_shadow(vm->addr));\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\nvoid kasan_free_shadow(const struct vm_struct *vm)\n{\n\tif (vm->flags & VM_KASAN)\n\t\tvfree(kasan_mem_to_shadow(vm->addr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vmap_area_lock"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vmap_area_lock"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_vmap_area",
          "args": [
            "(unsigned long)addr"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "find_vmap_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "745-754",
          "snippet": "static struct vmap_area *find_vmap_area(unsigned long addr)\n{\n\tstruct vmap_area *va;\n\n\tspin_lock(&vmap_area_lock);\n\tva = __find_vmap_area(addr);\n\tspin_unlock(&vmap_area_lock);\n\n\treturn va;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(vmap_area_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic DEFINE_SPINLOCK(vmap_area_lock);\n\nstatic struct vmap_area *find_vmap_area(unsigned long addr)\n{\n\tstruct vmap_area *va;\n\n\tspin_lock(&vmap_area_lock);\n\tva = __find_vmap_area(addr);\n\tspin_unlock(&vmap_area_lock);\n\n\treturn va;\n}"
        }
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\n#define VM_VM_AREA\t0x04\n#define VM_LAZY_FREE\t0x02\n\nstatic DEFINE_SPINLOCK(vmap_area_lock);\n\nstruct vm_struct *remove_vm_area(const void *addr)\n{\n\tstruct vmap_area *va;\n\n\tmight_sleep();\n\n\tva = find_vmap_area((unsigned long)addr);\n\tif (va && va->flags & VM_VM_AREA) {\n\t\tstruct vm_struct *vm = va->vm;\n\n\t\tspin_lock(&vmap_area_lock);\n\t\tva->vm = NULL;\n\t\tva->flags &= ~VM_VM_AREA;\n\t\tva->flags |= VM_LAZY_FREE;\n\t\tspin_unlock(&vmap_area_lock);\n\n\t\tkasan_free_shadow(vm);\n\t\tfree_unmap_vmap_area(va);\n\n\t\treturn vm;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "find_vm_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "1454-1463",
    "snippet": "struct vm_struct *find_vm_area(const void *addr)\n{\n\tstruct vmap_area *va;\n\n\tva = find_vmap_area((unsigned long)addr);\n\tif (va && va->flags & VM_VM_AREA)\n\t\treturn va->vm;\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [
      "#define VM_VM_AREA\t0x04"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_vmap_area",
          "args": [
            "(unsigned long)addr"
          ],
          "line": 1458
        },
        "resolved": true,
        "details": {
          "function_name": "find_vmap_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "745-754",
          "snippet": "static struct vmap_area *find_vmap_area(unsigned long addr)\n{\n\tstruct vmap_area *va;\n\n\tspin_lock(&vmap_area_lock);\n\tva = __find_vmap_area(addr);\n\tspin_unlock(&vmap_area_lock);\n\n\treturn va;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(vmap_area_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic DEFINE_SPINLOCK(vmap_area_lock);\n\nstatic struct vmap_area *find_vmap_area(unsigned long addr)\n{\n\tstruct vmap_area *va;\n\n\tspin_lock(&vmap_area_lock);\n\tva = __find_vmap_area(addr);\n\tspin_unlock(&vmap_area_lock);\n\n\treturn va;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\n#define VM_VM_AREA\t0x04\n\nstruct vm_struct *find_vm_area(const void *addr)\n{\n\tstruct vmap_area *va;\n\n\tva = find_vmap_area((unsigned long)addr);\n\tif (va && va->flags & VM_VM_AREA)\n\t\treturn va->vm;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "get_vm_area_caller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "1439-1444",
    "snippet": "struct vm_struct *get_vm_area_caller(unsigned long size, unsigned long flags,\n\t\t\t\tconst void *caller)\n{\n\treturn __get_vm_area_node(size, 1, flags, VMALLOC_START, VMALLOC_END,\n\t\t\t\t  NUMA_NO_NODE, GFP_KERNEL, caller);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_vm_area_node",
          "args": [
            "size",
            "1",
            "flags",
            "VMALLOC_START",
            "VMALLOC_END",
            "NUMA_NO_NODE",
            "GFP_KERNEL",
            "caller"
          ],
          "line": 1442
        },
        "resolved": true,
        "details": {
          "function_name": "__get_vm_area_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1373-1405",
          "snippet": "static struct vm_struct *__get_vm_area_node(unsigned long size,\n\t\tunsigned long align, unsigned long flags, unsigned long start,\n\t\tunsigned long end, int node, gfp_t gfp_mask, const void *caller)\n{\n\tstruct vmap_area *va;\n\tstruct vm_struct *area;\n\n\tBUG_ON(in_interrupt());\n\tsize = PAGE_ALIGN(size);\n\tif (unlikely(!size))\n\t\treturn NULL;\n\n\tif (flags & VM_IOREMAP)\n\t\talign = 1ul << clamp_t(int, get_count_order_long(size),\n\t\t\t\t       PAGE_SHIFT, IOREMAP_MAX_ORDER);\n\n\tarea = kzalloc_node(sizeof(*area), gfp_mask & GFP_RECLAIM_MASK, node);\n\tif (unlikely(!area))\n\t\treturn NULL;\n\n\tif (!(flags & VM_NO_GUARD))\n\t\tsize += PAGE_SIZE;\n\n\tva = alloc_vmap_area(size, align, start, end, node, gfp_mask);\n\tif (IS_ERR(va)) {\n\t\tkfree(area);\n\t\treturn NULL;\n\t}\n\n\tsetup_vmalloc_vm(area, va, flags, caller);\n\n\treturn area;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);\n\nstatic struct vm_struct *__get_vm_area_node(unsigned long size,\n\t\tunsigned long align, unsigned long flags, unsigned long start,\n\t\tunsigned long end, int node, gfp_t gfp_mask, const void *caller)\n{\n\tstruct vmap_area *va;\n\tstruct vm_struct *area;\n\n\tBUG_ON(in_interrupt());\n\tsize = PAGE_ALIGN(size);\n\tif (unlikely(!size))\n\t\treturn NULL;\n\n\tif (flags & VM_IOREMAP)\n\t\talign = 1ul << clamp_t(int, get_count_order_long(size),\n\t\t\t\t       PAGE_SHIFT, IOREMAP_MAX_ORDER);\n\n\tarea = kzalloc_node(sizeof(*area), gfp_mask & GFP_RECLAIM_MASK, node);\n\tif (unlikely(!area))\n\t\treturn NULL;\n\n\tif (!(flags & VM_NO_GUARD))\n\t\tsize += PAGE_SIZE;\n\n\tva = alloc_vmap_area(size, align, start, end, node, gfp_mask);\n\tif (IS_ERR(va)) {\n\t\tkfree(area);\n\t\treturn NULL;\n\t}\n\n\tsetup_vmalloc_vm(area, va, flags, caller);\n\n\treturn area;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);\n\nstruct vm_struct *get_vm_area_caller(unsigned long size, unsigned long flags,\n\t\t\t\tconst void *caller)\n{\n\treturn __get_vm_area_node(size, 1, flags, VMALLOC_START, VMALLOC_END,\n\t\t\t\t  NUMA_NO_NODE, GFP_KERNEL, caller);\n}"
  },
  {
    "function_name": "get_vm_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "1432-1437",
    "snippet": "struct vm_struct *get_vm_area(unsigned long size, unsigned long flags)\n{\n\treturn __get_vm_area_node(size, 1, flags, VMALLOC_START, VMALLOC_END,\n\t\t\t\t  NUMA_NO_NODE, GFP_KERNEL,\n\t\t\t\t  __builtin_return_address(0));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_vm_area_node",
          "args": [
            "size",
            "1",
            "flags",
            "VMALLOC_START",
            "VMALLOC_END",
            "NUMA_NO_NODE",
            "GFP_KERNEL",
            "__builtin_return_address(0)"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "__get_vm_area_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1373-1405",
          "snippet": "static struct vm_struct *__get_vm_area_node(unsigned long size,\n\t\tunsigned long align, unsigned long flags, unsigned long start,\n\t\tunsigned long end, int node, gfp_t gfp_mask, const void *caller)\n{\n\tstruct vmap_area *va;\n\tstruct vm_struct *area;\n\n\tBUG_ON(in_interrupt());\n\tsize = PAGE_ALIGN(size);\n\tif (unlikely(!size))\n\t\treturn NULL;\n\n\tif (flags & VM_IOREMAP)\n\t\talign = 1ul << clamp_t(int, get_count_order_long(size),\n\t\t\t\t       PAGE_SHIFT, IOREMAP_MAX_ORDER);\n\n\tarea = kzalloc_node(sizeof(*area), gfp_mask & GFP_RECLAIM_MASK, node);\n\tif (unlikely(!area))\n\t\treturn NULL;\n\n\tif (!(flags & VM_NO_GUARD))\n\t\tsize += PAGE_SIZE;\n\n\tva = alloc_vmap_area(size, align, start, end, node, gfp_mask);\n\tif (IS_ERR(va)) {\n\t\tkfree(area);\n\t\treturn NULL;\n\t}\n\n\tsetup_vmalloc_vm(area, va, flags, caller);\n\n\treturn area;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);\n\nstatic struct vm_struct *__get_vm_area_node(unsigned long size,\n\t\tunsigned long align, unsigned long flags, unsigned long start,\n\t\tunsigned long end, int node, gfp_t gfp_mask, const void *caller)\n{\n\tstruct vmap_area *va;\n\tstruct vm_struct *area;\n\n\tBUG_ON(in_interrupt());\n\tsize = PAGE_ALIGN(size);\n\tif (unlikely(!size))\n\t\treturn NULL;\n\n\tif (flags & VM_IOREMAP)\n\t\talign = 1ul << clamp_t(int, get_count_order_long(size),\n\t\t\t\t       PAGE_SHIFT, IOREMAP_MAX_ORDER);\n\n\tarea = kzalloc_node(sizeof(*area), gfp_mask & GFP_RECLAIM_MASK, node);\n\tif (unlikely(!area))\n\t\treturn NULL;\n\n\tif (!(flags & VM_NO_GUARD))\n\t\tsize += PAGE_SIZE;\n\n\tva = alloc_vmap_area(size, align, start, end, node, gfp_mask);\n\tif (IS_ERR(va)) {\n\t\tkfree(area);\n\t\treturn NULL;\n\t}\n\n\tsetup_vmalloc_vm(area, va, flags, caller);\n\n\treturn area;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__builtin_return_address",
          "args": [
            "0"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstruct vm_struct *get_vm_area(unsigned long size, unsigned long flags)\n{\n\treturn __get_vm_area_node(size, 1, flags, VMALLOC_START, VMALLOC_END,\n\t\t\t\t  NUMA_NO_NODE, GFP_KERNEL,\n\t\t\t\t  __builtin_return_address(0));\n}"
  },
  {
    "function_name": "__get_vm_area_caller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "1415-1421",
    "snippet": "struct vm_struct *__get_vm_area_caller(unsigned long size, unsigned long flags,\n\t\t\t\t       unsigned long start, unsigned long end,\n\t\t\t\t       const void *caller)\n{\n\treturn __get_vm_area_node(size, 1, flags, start, end, NUMA_NO_NODE,\n\t\t\t\t  GFP_KERNEL, caller);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_vm_area_node",
          "args": [
            "size",
            "1",
            "flags",
            "start",
            "end",
            "NUMA_NO_NODE",
            "GFP_KERNEL",
            "caller"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "__get_vm_area_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1373-1405",
          "snippet": "static struct vm_struct *__get_vm_area_node(unsigned long size,\n\t\tunsigned long align, unsigned long flags, unsigned long start,\n\t\tunsigned long end, int node, gfp_t gfp_mask, const void *caller)\n{\n\tstruct vmap_area *va;\n\tstruct vm_struct *area;\n\n\tBUG_ON(in_interrupt());\n\tsize = PAGE_ALIGN(size);\n\tif (unlikely(!size))\n\t\treturn NULL;\n\n\tif (flags & VM_IOREMAP)\n\t\talign = 1ul << clamp_t(int, get_count_order_long(size),\n\t\t\t\t       PAGE_SHIFT, IOREMAP_MAX_ORDER);\n\n\tarea = kzalloc_node(sizeof(*area), gfp_mask & GFP_RECLAIM_MASK, node);\n\tif (unlikely(!area))\n\t\treturn NULL;\n\n\tif (!(flags & VM_NO_GUARD))\n\t\tsize += PAGE_SIZE;\n\n\tva = alloc_vmap_area(size, align, start, end, node, gfp_mask);\n\tif (IS_ERR(va)) {\n\t\tkfree(area);\n\t\treturn NULL;\n\t}\n\n\tsetup_vmalloc_vm(area, va, flags, caller);\n\n\treturn area;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);\n\nstatic struct vm_struct *__get_vm_area_node(unsigned long size,\n\t\tunsigned long align, unsigned long flags, unsigned long start,\n\t\tunsigned long end, int node, gfp_t gfp_mask, const void *caller)\n{\n\tstruct vmap_area *va;\n\tstruct vm_struct *area;\n\n\tBUG_ON(in_interrupt());\n\tsize = PAGE_ALIGN(size);\n\tif (unlikely(!size))\n\t\treturn NULL;\n\n\tif (flags & VM_IOREMAP)\n\t\talign = 1ul << clamp_t(int, get_count_order_long(size),\n\t\t\t\t       PAGE_SHIFT, IOREMAP_MAX_ORDER);\n\n\tarea = kzalloc_node(sizeof(*area), gfp_mask & GFP_RECLAIM_MASK, node);\n\tif (unlikely(!area))\n\t\treturn NULL;\n\n\tif (!(flags & VM_NO_GUARD))\n\t\tsize += PAGE_SIZE;\n\n\tva = alloc_vmap_area(size, align, start, end, node, gfp_mask);\n\tif (IS_ERR(va)) {\n\t\tkfree(area);\n\t\treturn NULL;\n\t}\n\n\tsetup_vmalloc_vm(area, va, flags, caller);\n\n\treturn area;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);\n\nstruct vm_struct *__get_vm_area_caller(unsigned long size, unsigned long flags,\n\t\t\t\t       unsigned long start, unsigned long end,\n\t\t\t\t       const void *caller)\n{\n\treturn __get_vm_area_node(size, 1, flags, start, end, NUMA_NO_NODE,\n\t\t\t\t  GFP_KERNEL, caller);\n}"
  },
  {
    "function_name": "__get_vm_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "1407-1412",
    "snippet": "struct vm_struct *__get_vm_area(unsigned long size, unsigned long flags,\n\t\t\t\tunsigned long start, unsigned long end)\n{\n\treturn __get_vm_area_node(size, 1, flags, start, end, NUMA_NO_NODE,\n\t\t\t\t  GFP_KERNEL, __builtin_return_address(0));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_vm_area_node",
          "args": [
            "size",
            "1",
            "flags",
            "start",
            "end",
            "NUMA_NO_NODE",
            "GFP_KERNEL",
            "__builtin_return_address(0)"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "__get_vm_area_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1373-1405",
          "snippet": "static struct vm_struct *__get_vm_area_node(unsigned long size,\n\t\tunsigned long align, unsigned long flags, unsigned long start,\n\t\tunsigned long end, int node, gfp_t gfp_mask, const void *caller)\n{\n\tstruct vmap_area *va;\n\tstruct vm_struct *area;\n\n\tBUG_ON(in_interrupt());\n\tsize = PAGE_ALIGN(size);\n\tif (unlikely(!size))\n\t\treturn NULL;\n\n\tif (flags & VM_IOREMAP)\n\t\talign = 1ul << clamp_t(int, get_count_order_long(size),\n\t\t\t\t       PAGE_SHIFT, IOREMAP_MAX_ORDER);\n\n\tarea = kzalloc_node(sizeof(*area), gfp_mask & GFP_RECLAIM_MASK, node);\n\tif (unlikely(!area))\n\t\treturn NULL;\n\n\tif (!(flags & VM_NO_GUARD))\n\t\tsize += PAGE_SIZE;\n\n\tva = alloc_vmap_area(size, align, start, end, node, gfp_mask);\n\tif (IS_ERR(va)) {\n\t\tkfree(area);\n\t\treturn NULL;\n\t}\n\n\tsetup_vmalloc_vm(area, va, flags, caller);\n\n\treturn area;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);\n\nstatic struct vm_struct *__get_vm_area_node(unsigned long size,\n\t\tunsigned long align, unsigned long flags, unsigned long start,\n\t\tunsigned long end, int node, gfp_t gfp_mask, const void *caller)\n{\n\tstruct vmap_area *va;\n\tstruct vm_struct *area;\n\n\tBUG_ON(in_interrupt());\n\tsize = PAGE_ALIGN(size);\n\tif (unlikely(!size))\n\t\treturn NULL;\n\n\tif (flags & VM_IOREMAP)\n\t\talign = 1ul << clamp_t(int, get_count_order_long(size),\n\t\t\t\t       PAGE_SHIFT, IOREMAP_MAX_ORDER);\n\n\tarea = kzalloc_node(sizeof(*area), gfp_mask & GFP_RECLAIM_MASK, node);\n\tif (unlikely(!area))\n\t\treturn NULL;\n\n\tif (!(flags & VM_NO_GUARD))\n\t\tsize += PAGE_SIZE;\n\n\tva = alloc_vmap_area(size, align, start, end, node, gfp_mask);\n\tif (IS_ERR(va)) {\n\t\tkfree(area);\n\t\treturn NULL;\n\t}\n\n\tsetup_vmalloc_vm(area, va, flags, caller);\n\n\treturn area;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__builtin_return_address",
          "args": [
            "0"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstruct vm_struct *__get_vm_area(unsigned long size, unsigned long flags,\n\t\t\t\tunsigned long start, unsigned long end)\n{\n\treturn __get_vm_area_node(size, 1, flags, start, end, NUMA_NO_NODE,\n\t\t\t\t  GFP_KERNEL, __builtin_return_address(0));\n}"
  },
  {
    "function_name": "__get_vm_area_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "1373-1405",
    "snippet": "static struct vm_struct *__get_vm_area_node(unsigned long size,\n\t\tunsigned long align, unsigned long flags, unsigned long start,\n\t\tunsigned long end, int node, gfp_t gfp_mask, const void *caller)\n{\n\tstruct vmap_area *va;\n\tstruct vm_struct *area;\n\n\tBUG_ON(in_interrupt());\n\tsize = PAGE_ALIGN(size);\n\tif (unlikely(!size))\n\t\treturn NULL;\n\n\tif (flags & VM_IOREMAP)\n\t\talign = 1ul << clamp_t(int, get_count_order_long(size),\n\t\t\t\t       PAGE_SHIFT, IOREMAP_MAX_ORDER);\n\n\tarea = kzalloc_node(sizeof(*area), gfp_mask & GFP_RECLAIM_MASK, node);\n\tif (unlikely(!area))\n\t\treturn NULL;\n\n\tif (!(flags & VM_NO_GUARD))\n\t\tsize += PAGE_SIZE;\n\n\tva = alloc_vmap_area(size, align, start, end, node, gfp_mask);\n\tif (IS_ERR(va)) {\n\t\tkfree(area);\n\t\treturn NULL;\n\t}\n\n\tsetup_vmalloc_vm(area, va, flags, caller);\n\n\treturn area;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "setup_vmalloc_vm",
          "args": [
            "area",
            "va",
            "flags",
            "caller"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "setup_vmalloc_vm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1349-1360",
          "snippet": "static void setup_vmalloc_vm(struct vm_struct *vm, struct vmap_area *va,\n\t\t\t      unsigned long flags, const void *caller)\n{\n\tspin_lock(&vmap_area_lock);\n\tvm->flags = flags;\n\tvm->addr = (void *)va->va_start;\n\tvm->size = va->va_end - va->va_start;\n\tvm->caller = caller;\n\tva->vm = vm;\n\tva->flags |= VM_VM_AREA;\n\tspin_unlock(&vmap_area_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [
            "#define VM_VM_AREA\t0x04"
          ],
          "globals_used": [
            "static DEFINE_SPINLOCK(vmap_area_lock);",
            "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\n#define VM_VM_AREA\t0x04\n\nstatic DEFINE_SPINLOCK(vmap_area_lock);\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);\n\nstatic void setup_vmalloc_vm(struct vm_struct *vm, struct vmap_area *va,\n\t\t\t      unsigned long flags, const void *caller)\n{\n\tspin_lock(&vmap_area_lock);\n\tvm->flags = flags;\n\tvm->addr = (void *)va->va_start;\n\tvm->size = va->va_end - va->va_start;\n\tvm->caller = caller;\n\tva->vm = vm;\n\tva->flags |= VM_VM_AREA;\n\tspin_unlock(&vmap_area_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "area"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "va"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_vmap_area",
          "args": [
            "size",
            "align",
            "start",
            "end",
            "node",
            "gfp_mask"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_vmap_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "402-539",
          "snippet": "static struct vmap_area *alloc_vmap_area(unsigned long size,\n\t\t\t\tunsigned long align,\n\t\t\t\tunsigned long vstart, unsigned long vend,\n\t\t\t\tint node, gfp_t gfp_mask)\n{\n\tstruct vmap_area *va;\n\tstruct rb_node *n;\n\tunsigned long addr;\n\tint purged = 0;\n\tstruct vmap_area *first;\n\n\tBUG_ON(!size);\n\tBUG_ON(offset_in_page(size));\n\tBUG_ON(!is_power_of_2(align));\n\n\tmight_sleep();\n\n\tva = kmalloc_node(sizeof(struct vmap_area),\n\t\t\tgfp_mask & GFP_RECLAIM_MASK, node);\n\tif (unlikely(!va))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/*\n\t * Only scan the relevant parts containing pointers to other objects\n\t * to avoid false negatives.\n\t */\n\tkmemleak_scan_area(&va->rb_node, SIZE_MAX, gfp_mask & GFP_RECLAIM_MASK);\n\nretry:\n\tspin_lock(&vmap_area_lock);\n\t/*\n\t * Invalidate cache if we have more permissive parameters.\n\t * cached_hole_size notes the largest hole noticed _below_\n\t * the vmap_area cached in free_vmap_cache: if size fits\n\t * into that hole, we want to scan from vstart to reuse\n\t * the hole instead of allocating above free_vmap_cache.\n\t * Note that __free_vmap_area may update free_vmap_cache\n\t * without updating cached_hole_size or cached_align.\n\t */\n\tif (!free_vmap_cache ||\n\t\t\tsize < cached_hole_size ||\n\t\t\tvstart < cached_vstart ||\n\t\t\talign < cached_align) {\nnocache:\n\t\tcached_hole_size = 0;\n\t\tfree_vmap_cache = NULL;\n\t}\n\t/* record if we encounter less permissive parameters */\n\tcached_vstart = vstart;\n\tcached_align = align;\n\n\t/* find starting point for our search */\n\tif (free_vmap_cache) {\n\t\tfirst = rb_entry(free_vmap_cache, struct vmap_area, rb_node);\n\t\taddr = ALIGN(first->va_end, align);\n\t\tif (addr < vstart)\n\t\t\tgoto nocache;\n\t\tif (addr + size < addr)\n\t\t\tgoto overflow;\n\n\t} else {\n\t\taddr = ALIGN(vstart, align);\n\t\tif (addr + size < addr)\n\t\t\tgoto overflow;\n\n\t\tn = vmap_area_root.rb_node;\n\t\tfirst = NULL;\n\n\t\twhile (n) {\n\t\t\tstruct vmap_area *tmp;\n\t\t\ttmp = rb_entry(n, struct vmap_area, rb_node);\n\t\t\tif (tmp->va_end >= addr) {\n\t\t\t\tfirst = tmp;\n\t\t\t\tif (tmp->va_start <= addr)\n\t\t\t\t\tbreak;\n\t\t\t\tn = n->rb_left;\n\t\t\t} else\n\t\t\t\tn = n->rb_right;\n\t\t}\n\n\t\tif (!first)\n\t\t\tgoto found;\n\t}\n\n\t/* from the starting point, walk areas until a suitable hole is found */\n\twhile (addr + size > first->va_start && addr + size <= vend) {\n\t\tif (addr + cached_hole_size < first->va_start)\n\t\t\tcached_hole_size = first->va_start - addr;\n\t\taddr = ALIGN(first->va_end, align);\n\t\tif (addr + size < addr)\n\t\t\tgoto overflow;\n\n\t\tif (list_is_last(&first->list, &vmap_area_list))\n\t\t\tgoto found;\n\n\t\tfirst = list_next_entry(first, list);\n\t}\n\nfound:\n\tif (addr + size > vend)\n\t\tgoto overflow;\n\n\tva->va_start = addr;\n\tva->va_end = addr + size;\n\tva->flags = 0;\n\t__insert_vmap_area(va);\n\tfree_vmap_cache = &va->rb_node;\n\tspin_unlock(&vmap_area_lock);\n\n\tBUG_ON(!IS_ALIGNED(va->va_start, align));\n\tBUG_ON(va->va_start < vstart);\n\tBUG_ON(va->va_end > vend);\n\n\treturn va;\n\noverflow:\n\tspin_unlock(&vmap_area_lock);\n\tif (!purged) {\n\t\tpurge_vmap_area_lazy();\n\t\tpurged = 1;\n\t\tgoto retry;\n\t}\n\n\tif (gfpflags_allow_blocking(gfp_mask)) {\n\t\tunsigned long freed = 0;\n\t\tblocking_notifier_call_chain(&vmap_notify_list, 0, &freed);\n\t\tif (freed > 0) {\n\t\t\tpurged = 0;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tif (!(gfp_mask & __GFP_NOWARN) && printk_ratelimit())\n\t\tpr_warn(\"vmap allocation for size %lu failed: use vmalloc=<size> to increase size\\n\",\n\t\t\tsize);\n\tkfree(va);\n\treturn ERR_PTR(-EBUSY);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(vmap_area_lock);",
            "static struct rb_root vmap_area_root = RB_ROOT;",
            "static struct rb_node *free_vmap_cache;",
            "static unsigned long cached_hole_size;",
            "static unsigned long cached_vstart;",
            "static unsigned long cached_align;",
            "static void purge_vmap_area_lazy(void);",
            "static BLOCKING_NOTIFIER_HEAD(vmap_notify_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic DEFINE_SPINLOCK(vmap_area_lock);\nstatic struct rb_root vmap_area_root = RB_ROOT;\nstatic struct rb_node *free_vmap_cache;\nstatic unsigned long cached_hole_size;\nstatic unsigned long cached_vstart;\nstatic unsigned long cached_align;\nstatic void purge_vmap_area_lazy(void);\nstatic BLOCKING_NOTIFIER_HEAD(vmap_notify_list);\n\nstatic struct vmap_area *alloc_vmap_area(unsigned long size,\n\t\t\t\tunsigned long align,\n\t\t\t\tunsigned long vstart, unsigned long vend,\n\t\t\t\tint node, gfp_t gfp_mask)\n{\n\tstruct vmap_area *va;\n\tstruct rb_node *n;\n\tunsigned long addr;\n\tint purged = 0;\n\tstruct vmap_area *first;\n\n\tBUG_ON(!size);\n\tBUG_ON(offset_in_page(size));\n\tBUG_ON(!is_power_of_2(align));\n\n\tmight_sleep();\n\n\tva = kmalloc_node(sizeof(struct vmap_area),\n\t\t\tgfp_mask & GFP_RECLAIM_MASK, node);\n\tif (unlikely(!va))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/*\n\t * Only scan the relevant parts containing pointers to other objects\n\t * to avoid false negatives.\n\t */\n\tkmemleak_scan_area(&va->rb_node, SIZE_MAX, gfp_mask & GFP_RECLAIM_MASK);\n\nretry:\n\tspin_lock(&vmap_area_lock);\n\t/*\n\t * Invalidate cache if we have more permissive parameters.\n\t * cached_hole_size notes the largest hole noticed _below_\n\t * the vmap_area cached in free_vmap_cache: if size fits\n\t * into that hole, we want to scan from vstart to reuse\n\t * the hole instead of allocating above free_vmap_cache.\n\t * Note that __free_vmap_area may update free_vmap_cache\n\t * without updating cached_hole_size or cached_align.\n\t */\n\tif (!free_vmap_cache ||\n\t\t\tsize < cached_hole_size ||\n\t\t\tvstart < cached_vstart ||\n\t\t\talign < cached_align) {\nnocache:\n\t\tcached_hole_size = 0;\n\t\tfree_vmap_cache = NULL;\n\t}\n\t/* record if we encounter less permissive parameters */\n\tcached_vstart = vstart;\n\tcached_align = align;\n\n\t/* find starting point for our search */\n\tif (free_vmap_cache) {\n\t\tfirst = rb_entry(free_vmap_cache, struct vmap_area, rb_node);\n\t\taddr = ALIGN(first->va_end, align);\n\t\tif (addr < vstart)\n\t\t\tgoto nocache;\n\t\tif (addr + size < addr)\n\t\t\tgoto overflow;\n\n\t} else {\n\t\taddr = ALIGN(vstart, align);\n\t\tif (addr + size < addr)\n\t\t\tgoto overflow;\n\n\t\tn = vmap_area_root.rb_node;\n\t\tfirst = NULL;\n\n\t\twhile (n) {\n\t\t\tstruct vmap_area *tmp;\n\t\t\ttmp = rb_entry(n, struct vmap_area, rb_node);\n\t\t\tif (tmp->va_end >= addr) {\n\t\t\t\tfirst = tmp;\n\t\t\t\tif (tmp->va_start <= addr)\n\t\t\t\t\tbreak;\n\t\t\t\tn = n->rb_left;\n\t\t\t} else\n\t\t\t\tn = n->rb_right;\n\t\t}\n\n\t\tif (!first)\n\t\t\tgoto found;\n\t}\n\n\t/* from the starting point, walk areas until a suitable hole is found */\n\twhile (addr + size > first->va_start && addr + size <= vend) {\n\t\tif (addr + cached_hole_size < first->va_start)\n\t\t\tcached_hole_size = first->va_start - addr;\n\t\taddr = ALIGN(first->va_end, align);\n\t\tif (addr + size < addr)\n\t\t\tgoto overflow;\n\n\t\tif (list_is_last(&first->list, &vmap_area_list))\n\t\t\tgoto found;\n\n\t\tfirst = list_next_entry(first, list);\n\t}\n\nfound:\n\tif (addr + size > vend)\n\t\tgoto overflow;\n\n\tva->va_start = addr;\n\tva->va_end = addr + size;\n\tva->flags = 0;\n\t__insert_vmap_area(va);\n\tfree_vmap_cache = &va->rb_node;\n\tspin_unlock(&vmap_area_lock);\n\n\tBUG_ON(!IS_ALIGNED(va->va_start, align));\n\tBUG_ON(va->va_start < vstart);\n\tBUG_ON(va->va_end > vend);\n\n\treturn va;\n\noverflow:\n\tspin_unlock(&vmap_area_lock);\n\tif (!purged) {\n\t\tpurge_vmap_area_lazy();\n\t\tpurged = 1;\n\t\tgoto retry;\n\t}\n\n\tif (gfpflags_allow_blocking(gfp_mask)) {\n\t\tunsigned long freed = 0;\n\t\tblocking_notifier_call_chain(&vmap_notify_list, 0, &freed);\n\t\tif (freed > 0) {\n\t\t\tpurged = 0;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tif (!(gfp_mask & __GFP_NOWARN) && printk_ratelimit())\n\t\tpr_warn(\"vmap allocation for size %lu failed: use vmalloc=<size> to increase size\\n\",\n\t\t\tsize);\n\tkfree(va);\n\treturn ERR_PTR(-EBUSY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!area"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc_node",
          "args": [
            "sizeof(*area)",
            "gfp_mask & GFP_RECLAIM_MASK",
            "node"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clamp_t",
          "args": [
            "int",
            "get_count_order_long(size)",
            "PAGE_SHIFT",
            "IOREMAP_MAX_ORDER"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_count_order_long",
          "args": [
            "size"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!size"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "size"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "in_interrupt()"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_interrupt",
          "args": [],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);\n\nstatic struct vm_struct *__get_vm_area_node(unsigned long size,\n\t\tunsigned long align, unsigned long flags, unsigned long start,\n\t\tunsigned long end, int node, gfp_t gfp_mask, const void *caller)\n{\n\tstruct vmap_area *va;\n\tstruct vm_struct *area;\n\n\tBUG_ON(in_interrupt());\n\tsize = PAGE_ALIGN(size);\n\tif (unlikely(!size))\n\t\treturn NULL;\n\n\tif (flags & VM_IOREMAP)\n\t\talign = 1ul << clamp_t(int, get_count_order_long(size),\n\t\t\t\t       PAGE_SHIFT, IOREMAP_MAX_ORDER);\n\n\tarea = kzalloc_node(sizeof(*area), gfp_mask & GFP_RECLAIM_MASK, node);\n\tif (unlikely(!area))\n\t\treturn NULL;\n\n\tif (!(flags & VM_NO_GUARD))\n\t\tsize += PAGE_SIZE;\n\n\tva = alloc_vmap_area(size, align, start, end, node, gfp_mask);\n\tif (IS_ERR(va)) {\n\t\tkfree(area);\n\t\treturn NULL;\n\t}\n\n\tsetup_vmalloc_vm(area, va, flags, caller);\n\n\treturn area;\n}"
  },
  {
    "function_name": "clear_vm_uninitialized_flag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "1362-1371",
    "snippet": "static void clear_vm_uninitialized_flag(struct vm_struct *vm)\n{\n\t/*\n\t * Before removing VM_UNINITIALIZED,\n\t * we should make sure that vm has proper values.\n\t * Pair with smp_rmb() in show_numa_info().\n\t */\n\tsmp_wmb();\n\tvm->flags &= ~VM_UNINITIALIZED;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void clear_vm_uninitialized_flag(struct vm_struct *vm)\n{\n\t/*\n\t * Before removing VM_UNINITIALIZED,\n\t * we should make sure that vm has proper values.\n\t * Pair with smp_rmb() in show_numa_info().\n\t */\n\tsmp_wmb();\n\tvm->flags &= ~VM_UNINITIALIZED;\n}"
  },
  {
    "function_name": "setup_vmalloc_vm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "1349-1360",
    "snippet": "static void setup_vmalloc_vm(struct vm_struct *vm, struct vmap_area *va,\n\t\t\t      unsigned long flags, const void *caller)\n{\n\tspin_lock(&vmap_area_lock);\n\tvm->flags = flags;\n\tvm->addr = (void *)va->va_start;\n\tvm->size = va->va_end - va->va_start;\n\tvm->caller = caller;\n\tva->vm = vm;\n\tva->flags |= VM_VM_AREA;\n\tspin_unlock(&vmap_area_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [
      "#define VM_VM_AREA\t0x04"
    ],
    "globals_used": [
      "static DEFINE_SPINLOCK(vmap_area_lock);",
      "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vmap_area_lock"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vmap_area_lock"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\n#define VM_VM_AREA\t0x04\n\nstatic DEFINE_SPINLOCK(vmap_area_lock);\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);\n\nstatic void setup_vmalloc_vm(struct vm_struct *vm, struct vmap_area *va,\n\t\t\t      unsigned long flags, const void *caller)\n{\n\tspin_lock(&vmap_area_lock);\n\tvm->flags = flags;\n\tvm->addr = (void *)va->va_start;\n\tvm->size = va->va_end - va->va_start;\n\tvm->caller = caller;\n\tva->vm = vm;\n\tva->flags |= VM_VM_AREA;\n\tspin_unlock(&vmap_area_lock);\n}"
  },
  {
    "function_name": "map_vm_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "1337-1346",
    "snippet": "int map_vm_area(struct vm_struct *area, pgprot_t prot, struct page **pages)\n{\n\tunsigned long addr = (unsigned long)area->addr;\n\tunsigned long end = addr + get_vm_area_size(area);\n\tint err;\n\n\terr = vmap_page_range(addr, end, prot, pages);\n\n\treturn err > 0 ? 0 : err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmap_page_range",
          "args": [
            "addr",
            "end",
            "prot",
            "pages"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "vmap_page_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "238-246",
          "snippet": "static int vmap_page_range(unsigned long start, unsigned long end,\n\t\t\t   pgprot_t prot, struct page **pages)\n{\n\tint ret;\n\n\tret = vmap_page_range_noflush(start, end, prot, pages);\n\tflush_cache_vmap(start, end);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic int vmap_page_range(unsigned long start, unsigned long end,\n\t\t\t   pgprot_t prot, struct page **pages)\n{\n\tint ret;\n\n\tret = vmap_page_range_noflush(start, end, prot, pages);\n\tflush_cache_vmap(start, end);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_vm_area_size",
          "args": [
            "area"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nint map_vm_area(struct vm_struct *area, pgprot_t prot, struct page **pages)\n{\n\tunsigned long addr = (unsigned long)area->addr;\n\tunsigned long end = addr + get_vm_area_size(area);\n\tint err;\n\n\terr = vmap_page_range(addr, end, prot, pages);\n\n\treturn err > 0 ? 0 : err;\n}"
  },
  {
    "function_name": "unmap_kernel_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "1327-1334",
    "snippet": "void unmap_kernel_range(unsigned long addr, unsigned long size)\n{\n\tunsigned long end = addr + size;\n\n\tflush_cache_vunmap(addr, end);\n\tvunmap_page_range(addr, end);\n\tflush_tlb_kernel_range(addr, end);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_tlb_kernel_range",
          "args": [
            "addr",
            "end"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vunmap_page_range",
          "args": [
            "addr",
            "end"
          ],
          "line": 1332
        },
        "resolved": true,
        "details": {
          "function_name": "vunmap_page_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "119-132",
          "snippet": "static void vunmap_page_range(unsigned long addr, unsigned long end)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\n\tBUG_ON(addr >= end);\n\tpgd = pgd_offset_k(addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(pgd))\n\t\t\tcontinue;\n\t\tvunmap_p4d_range(pgd, addr, next);\n\t} while (pgd++, addr = next, addr != end);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void vunmap_page_range(unsigned long addr, unsigned long end)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\n\tBUG_ON(addr >= end);\n\tpgd = pgd_offset_k(addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(pgd))\n\t\t\tcontinue;\n\t\tvunmap_p4d_range(pgd, addr, next);\n\t} while (pgd++, addr = next, addr != end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_cache_vunmap",
          "args": [
            "addr",
            "end"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nvoid unmap_kernel_range(unsigned long addr, unsigned long size)\n{\n\tunsigned long end = addr + size;\n\n\tflush_cache_vunmap(addr, end);\n\tvunmap_page_range(addr, end);\n\tflush_tlb_kernel_range(addr, end);\n}"
  },
  {
    "function_name": "unmap_kernel_range_noflush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "1313-1316",
    "snippet": "void unmap_kernel_range_noflush(unsigned long addr, unsigned long size)\n{\n\tvunmap_page_range(addr, addr + size);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vunmap_page_range",
          "args": [
            "addr",
            "addr + size"
          ],
          "line": 1315
        },
        "resolved": true,
        "details": {
          "function_name": "vunmap_page_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "119-132",
          "snippet": "static void vunmap_page_range(unsigned long addr, unsigned long end)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\n\tBUG_ON(addr >= end);\n\tpgd = pgd_offset_k(addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(pgd))\n\t\t\tcontinue;\n\t\tvunmap_p4d_range(pgd, addr, next);\n\t} while (pgd++, addr = next, addr != end);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void vunmap_page_range(unsigned long addr, unsigned long end)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\n\tBUG_ON(addr >= end);\n\tpgd = pgd_offset_k(addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(pgd))\n\t\t\tcontinue;\n\t\tvunmap_p4d_range(pgd, addr, next);\n\t} while (pgd++, addr = next, addr != end);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nvoid unmap_kernel_range_noflush(unsigned long addr, unsigned long size)\n{\n\tvunmap_page_range(addr, addr + size);\n}"
  },
  {
    "function_name": "map_kernel_range_noflush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "1293-1297",
    "snippet": "int map_kernel_range_noflush(unsigned long addr, unsigned long size,\n\t\t\t     pgprot_t prot, struct page **pages)\n{\n\treturn vmap_page_range_noflush(addr, addr + size, prot, pages);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmap_page_range_noflush",
          "args": [
            "addr",
            "addr + size",
            "prot",
            "pages"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "vmap_page_range_noflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "217-236",
          "snippet": "static int vmap_page_range_noflush(unsigned long start, unsigned long end,\n\t\t\t\t   pgprot_t prot, struct page **pages)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\tunsigned long addr = start;\n\tint err = 0;\n\tint nr = 0;\n\n\tBUG_ON(addr >= end);\n\tpgd = pgd_offset_k(addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\terr = vmap_p4d_range(pgd, addr, next, prot, pages, &nr);\n\t\tif (err)\n\t\t\treturn err;\n\t} while (pgd++, addr = next, addr != end);\n\n\treturn nr;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic int vmap_page_range_noflush(unsigned long start, unsigned long end,\n\t\t\t\t   pgprot_t prot, struct page **pages)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\tunsigned long addr = start;\n\tint err = 0;\n\tint nr = 0;\n\n\tBUG_ON(addr >= end);\n\tpgd = pgd_offset_k(addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\terr = vmap_p4d_range(pgd, addr, next, prot, pages, &nr);\n\t\tif (err)\n\t\t\treturn err;\n\t} while (pgd++, addr = next, addr != end);\n\n\treturn nr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nint map_kernel_range_noflush(unsigned long addr, unsigned long size,\n\t\t\t     pgprot_t prot, struct page **pages)\n{\n\treturn vmap_page_range_noflush(addr, addr + size, prot, pages);\n}"
  },
  {
    "function_name": "vmalloc_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "1241-1272",
    "snippet": "void __init vmalloc_init(void)\n{\n\tstruct vmap_area *va;\n\tstruct vm_struct *tmp;\n\tint i;\n\n\tfor_each_possible_cpu(i) {\n\t\tstruct vmap_block_queue *vbq;\n\t\tstruct vfree_deferred *p;\n\n\t\tvbq = &per_cpu(vmap_block_queue, i);\n\t\tspin_lock_init(&vbq->lock);\n\t\tINIT_LIST_HEAD(&vbq->free);\n\t\tp = &per_cpu(vfree_deferred, i);\n\t\tinit_llist_head(&p->list);\n\t\tINIT_WORK(&p->wq, free_work);\n\t}\n\n\t/* Import existing vmlist entries. */\n\tfor (tmp = vmlist; tmp; tmp = tmp->next) {\n\t\tva = kzalloc(sizeof(struct vmap_area), GFP_NOWAIT);\n\t\tva->flags = VM_VM_AREA;\n\t\tva->va_start = (unsigned long)tmp->addr;\n\t\tva->va_end = va->va_start + tmp->size;\n\t\tva->vm = tmp;\n\t\t__insert_vmap_area(va);\n\t}\n\n\tvmap_area_pcpu_hole = VMALLOC_END;\n\n\tvmap_initialized = true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [
      "#define VM_VM_AREA\t0x04"
    ],
    "globals_used": [
      "static DEFINE_PER_CPU(struct vfree_deferred, vfree_deferred);",
      "static unsigned long vmap_area_pcpu_hole;",
      "static bool vmap_initialized",
      "static DEFINE_PER_CPU(struct vmap_block_queue, vmap_block_queue);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__insert_vmap_area",
          "args": [
            "va"
          ],
          "line": 1266
        },
        "resolved": true,
        "details": {
          "function_name": "__insert_vmap_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "362-392",
          "snippet": "static void __insert_vmap_area(struct vmap_area *va)\n{\n\tstruct rb_node **p = &vmap_area_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct rb_node *tmp;\n\n\twhile (*p) {\n\t\tstruct vmap_area *tmp_va;\n\n\t\tparent = *p;\n\t\ttmp_va = rb_entry(parent, struct vmap_area, rb_node);\n\t\tif (va->va_start < tmp_va->va_end)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (va->va_end > tmp_va->va_start)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tBUG();\n\t}\n\n\trb_link_node(&va->rb_node, parent, p);\n\trb_insert_color(&va->rb_node, &vmap_area_root);\n\n\t/* address-sort this list */\n\ttmp = rb_prev(&va->rb_node);\n\tif (tmp) {\n\t\tstruct vmap_area *prev;\n\t\tprev = rb_entry(tmp, struct vmap_area, rb_node);\n\t\tlist_add_rcu(&va->list, &prev->list);\n\t} else\n\t\tlist_add_rcu(&va->list, &vmap_area_list);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root vmap_area_root = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic struct rb_root vmap_area_root = RB_ROOT;\n\nstatic void __insert_vmap_area(struct vmap_area *va)\n{\n\tstruct rb_node **p = &vmap_area_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct rb_node *tmp;\n\n\twhile (*p) {\n\t\tstruct vmap_area *tmp_va;\n\n\t\tparent = *p;\n\t\ttmp_va = rb_entry(parent, struct vmap_area, rb_node);\n\t\tif (va->va_start < tmp_va->va_end)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (va->va_end > tmp_va->va_start)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tBUG();\n\t}\n\n\trb_link_node(&va->rb_node, parent, p);\n\trb_insert_color(&va->rb_node, &vmap_area_root);\n\n\t/* address-sort this list */\n\ttmp = rb_prev(&va->rb_node);\n\tif (tmp) {\n\t\tstruct vmap_area *prev;\n\t\tprev = rb_entry(tmp, struct vmap_area, rb_node);\n\t\tlist_add_rcu(&va->list, &prev->list);\n\t} else\n\t\tlist_add_rcu(&va->list, &vmap_area_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct vmap_area)",
            "GFP_NOWAIT"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&p->wq",
            "free_work"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_llist_head",
          "args": [
            "&p->list"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "vfree_deferred",
            "i"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&vbq->free"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&vbq->lock"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "vmap_block_queue",
            "i"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\n#define VM_VM_AREA\t0x04\n\nstatic DEFINE_PER_CPU(struct vfree_deferred, vfree_deferred);\nstatic unsigned long vmap_area_pcpu_hole;\nstatic bool vmap_initialized;\nstatic DEFINE_PER_CPU(struct vmap_block_queue, vmap_block_queue);\n\nvoid __init vmalloc_init(void)\n{\n\tstruct vmap_area *va;\n\tstruct vm_struct *tmp;\n\tint i;\n\n\tfor_each_possible_cpu(i) {\n\t\tstruct vmap_block_queue *vbq;\n\t\tstruct vfree_deferred *p;\n\n\t\tvbq = &per_cpu(vmap_block_queue, i);\n\t\tspin_lock_init(&vbq->lock);\n\t\tINIT_LIST_HEAD(&vbq->free);\n\t\tp = &per_cpu(vfree_deferred, i);\n\t\tinit_llist_head(&p->list);\n\t\tINIT_WORK(&p->wq, free_work);\n\t}\n\n\t/* Import existing vmlist entries. */\n\tfor (tmp = vmlist; tmp; tmp = tmp->next) {\n\t\tva = kzalloc(sizeof(struct vmap_area), GFP_NOWAIT);\n\t\tva->flags = VM_VM_AREA;\n\t\tva->va_start = (unsigned long)tmp->addr;\n\t\tva->va_end = va->va_start + tmp->size;\n\t\tva->vm = tmp;\n\t\t__insert_vmap_area(va);\n\t}\n\n\tvmap_area_pcpu_hole = VMALLOC_END;\n\n\tvmap_initialized = true;\n}"
  },
  {
    "function_name": "vm_area_register_early",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "1228-1239",
    "snippet": "void __init vm_area_register_early(struct vm_struct *vm, size_t align)\n{\n\tstatic size_t vm_init_off __initdata;\n\tunsigned long addr;\n\n\taddr = ALIGN(VMALLOC_START + vm_init_off, align);\n\tvm_init_off = PFN_ALIGN(addr + vm->size) - VMALLOC_START;\n\n\tvm->addr = (void *)addr;\n\n\tvm_area_add_early(vm);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct vm_struct *vmlist __initdata;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vm_area_add_early",
          "args": [
            "vm"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "vm_area_add_early",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1200-1214",
          "snippet": "void __init vm_area_add_early(struct vm_struct *vm)\n{\n\tstruct vm_struct *tmp, **p;\n\n\tBUG_ON(vmap_initialized);\n\tfor (p = &vmlist; (tmp = *p) != NULL; p = &tmp->next) {\n\t\tif (tmp->addr >= vm->addr) {\n\t\t\tBUG_ON(tmp->addr < vm->addr + vm->size);\n\t\t\tbreak;\n\t\t} else\n\t\t\tBUG_ON(tmp->addr + tmp->size > vm->addr);\n\t}\n\tvm->next = *p;\n\t*p = vm;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool vmap_initialized"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic bool vmap_initialized;\n\nvoid __init vm_area_add_early(struct vm_struct *vm)\n{\n\tstruct vm_struct *tmp, **p;\n\n\tBUG_ON(vmap_initialized);\n\tfor (p = &vmlist; (tmp = *p) != NULL; p = &tmp->next) {\n\t\tif (tmp->addr >= vm->addr) {\n\t\t\tBUG_ON(tmp->addr < vm->addr + vm->size);\n\t\t\tbreak;\n\t\t} else\n\t\t\tBUG_ON(tmp->addr + tmp->size > vm->addr);\n\t}\n\tvm->next = *p;\n\t*p = vm;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PFN_ALIGN",
          "args": [
            "addr + vm->size"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "VMALLOC_START + vm_init_off",
            "align"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic struct vm_struct *vmlist __initdata;\n\nvoid __init vm_area_register_early(struct vm_struct *vm, size_t align)\n{\n\tstatic size_t vm_init_off __initdata;\n\tunsigned long addr;\n\n\taddr = ALIGN(VMALLOC_START + vm_init_off, align);\n\tvm_init_off = PFN_ALIGN(addr + vm->size) - VMALLOC_START;\n\n\tvm->addr = (void *)addr;\n\n\tvm_area_add_early(vm);\n}"
  },
  {
    "function_name": "vm_area_add_early",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "1200-1214",
    "snippet": "void __init vm_area_add_early(struct vm_struct *vm)\n{\n\tstruct vm_struct *tmp, **p;\n\n\tBUG_ON(vmap_initialized);\n\tfor (p = &vmlist; (tmp = *p) != NULL; p = &tmp->next) {\n\t\tif (tmp->addr >= vm->addr) {\n\t\t\tBUG_ON(tmp->addr < vm->addr + vm->size);\n\t\t\tbreak;\n\t\t} else\n\t\t\tBUG_ON(tmp->addr + tmp->size > vm->addr);\n\t}\n\tvm->next = *p;\n\t*p = vm;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool vmap_initialized"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "tmp->addr + tmp->size > vm->addr"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "tmp->addr < vm->addr + vm->size"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "vmap_initialized"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic bool vmap_initialized;\n\nvoid __init vm_area_add_early(struct vm_struct *vm)\n{\n\tstruct vm_struct *tmp, **p;\n\n\tBUG_ON(vmap_initialized);\n\tfor (p = &vmlist; (tmp = *p) != NULL; p = &tmp->next) {\n\t\tif (tmp->addr >= vm->addr) {\n\t\t\tBUG_ON(tmp->addr < vm->addr + vm->size);\n\t\t\tbreak;\n\t\t} else\n\t\t\tBUG_ON(tmp->addr + tmp->size > vm->addr);\n\t}\n\tvm->next = *p;\n\t*p = vm;\n}"
  },
  {
    "function_name": "vm_map_ram",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "1160-1186",
    "snippet": "void *vm_map_ram(struct page **pages, unsigned int count, int node, pgprot_t prot)\n{\n\tunsigned long size = (unsigned long)count << PAGE_SHIFT;\n\tunsigned long addr;\n\tvoid *mem;\n\n\tif (likely(count <= VMAP_MAX_ALLOC)) {\n\t\tmem = vb_alloc(size, GFP_KERNEL);\n\t\tif (IS_ERR(mem))\n\t\t\treturn NULL;\n\t\taddr = (unsigned long)mem;\n\t} else {\n\t\tstruct vmap_area *va;\n\t\tva = alloc_vmap_area(size, PAGE_SIZE,\n\t\t\t\tVMALLOC_START, VMALLOC_END, node, GFP_KERNEL);\n\t\tif (IS_ERR(va))\n\t\t\treturn NULL;\n\n\t\taddr = va->va_start;\n\t\tmem = (void *)addr;\n\t}\n\tif (vmap_page_range(addr, addr + size, prot, pages) < 0) {\n\t\tvm_unmap_ram(mem, count);\n\t\treturn NULL;\n\t}\n\treturn mem;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [
      "#define VMAP_MAX_ALLOC\t\tBITS_PER_LONG\t/* 256K with 4K pages */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vm_unmap_ram",
          "args": [
            "mem",
            "count"
          ],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "vm_unmap_ram",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1119-1142",
          "snippet": "void vm_unmap_ram(const void *mem, unsigned int count)\n{\n\tunsigned long size = (unsigned long)count << PAGE_SHIFT;\n\tunsigned long addr = (unsigned long)mem;\n\tstruct vmap_area *va;\n\n\tmight_sleep();\n\tBUG_ON(!addr);\n\tBUG_ON(addr < VMALLOC_START);\n\tBUG_ON(addr > VMALLOC_END);\n\tBUG_ON(!PAGE_ALIGNED(addr));\n\n\tif (likely(count <= VMAP_MAX_ALLOC)) {\n\t\tdebug_check_no_locks_freed(mem, size);\n\t\tvb_free(mem, size);\n\t\treturn;\n\t}\n\n\tva = find_vmap_area(addr);\n\tBUG_ON(!va);\n\tdebug_check_no_locks_freed((void *)va->va_start,\n\t\t\t\t    (va->va_end - va->va_start));\n\tfree_unmap_vmap_area(va);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [
            "#define VMAP_MAX_ALLOC\t\tBITS_PER_LONG\t/* 256K with 4K pages */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\n#define VMAP_MAX_ALLOC\t\tBITS_PER_LONG\t/* 256K with 4K pages */\n\nvoid vm_unmap_ram(const void *mem, unsigned int count)\n{\n\tunsigned long size = (unsigned long)count << PAGE_SHIFT;\n\tunsigned long addr = (unsigned long)mem;\n\tstruct vmap_area *va;\n\n\tmight_sleep();\n\tBUG_ON(!addr);\n\tBUG_ON(addr < VMALLOC_START);\n\tBUG_ON(addr > VMALLOC_END);\n\tBUG_ON(!PAGE_ALIGNED(addr));\n\n\tif (likely(count <= VMAP_MAX_ALLOC)) {\n\t\tdebug_check_no_locks_freed(mem, size);\n\t\tvb_free(mem, size);\n\t\treturn;\n\t}\n\n\tva = find_vmap_area(addr);\n\tBUG_ON(!va);\n\tdebug_check_no_locks_freed((void *)va->va_start,\n\t\t\t\t    (va->va_end - va->va_start));\n\tfree_unmap_vmap_area(va);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmap_page_range",
          "args": [
            "addr",
            "addr + size",
            "prot",
            "pages"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "vmap_page_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "238-246",
          "snippet": "static int vmap_page_range(unsigned long start, unsigned long end,\n\t\t\t   pgprot_t prot, struct page **pages)\n{\n\tint ret;\n\n\tret = vmap_page_range_noflush(start, end, prot, pages);\n\tflush_cache_vmap(start, end);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic int vmap_page_range(unsigned long start, unsigned long end,\n\t\t\t   pgprot_t prot, struct page **pages)\n{\n\tint ret;\n\n\tret = vmap_page_range_noflush(start, end, prot, pages);\n\tflush_cache_vmap(start, end);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "va"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_vmap_area",
          "args": [
            "size",
            "PAGE_SIZE",
            "VMALLOC_START",
            "VMALLOC_END",
            "node",
            "GFP_KERNEL"
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_vmap_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "402-539",
          "snippet": "static struct vmap_area *alloc_vmap_area(unsigned long size,\n\t\t\t\tunsigned long align,\n\t\t\t\tunsigned long vstart, unsigned long vend,\n\t\t\t\tint node, gfp_t gfp_mask)\n{\n\tstruct vmap_area *va;\n\tstruct rb_node *n;\n\tunsigned long addr;\n\tint purged = 0;\n\tstruct vmap_area *first;\n\n\tBUG_ON(!size);\n\tBUG_ON(offset_in_page(size));\n\tBUG_ON(!is_power_of_2(align));\n\n\tmight_sleep();\n\n\tva = kmalloc_node(sizeof(struct vmap_area),\n\t\t\tgfp_mask & GFP_RECLAIM_MASK, node);\n\tif (unlikely(!va))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/*\n\t * Only scan the relevant parts containing pointers to other objects\n\t * to avoid false negatives.\n\t */\n\tkmemleak_scan_area(&va->rb_node, SIZE_MAX, gfp_mask & GFP_RECLAIM_MASK);\n\nretry:\n\tspin_lock(&vmap_area_lock);\n\t/*\n\t * Invalidate cache if we have more permissive parameters.\n\t * cached_hole_size notes the largest hole noticed _below_\n\t * the vmap_area cached in free_vmap_cache: if size fits\n\t * into that hole, we want to scan from vstart to reuse\n\t * the hole instead of allocating above free_vmap_cache.\n\t * Note that __free_vmap_area may update free_vmap_cache\n\t * without updating cached_hole_size or cached_align.\n\t */\n\tif (!free_vmap_cache ||\n\t\t\tsize < cached_hole_size ||\n\t\t\tvstart < cached_vstart ||\n\t\t\talign < cached_align) {\nnocache:\n\t\tcached_hole_size = 0;\n\t\tfree_vmap_cache = NULL;\n\t}\n\t/* record if we encounter less permissive parameters */\n\tcached_vstart = vstart;\n\tcached_align = align;\n\n\t/* find starting point for our search */\n\tif (free_vmap_cache) {\n\t\tfirst = rb_entry(free_vmap_cache, struct vmap_area, rb_node);\n\t\taddr = ALIGN(first->va_end, align);\n\t\tif (addr < vstart)\n\t\t\tgoto nocache;\n\t\tif (addr + size < addr)\n\t\t\tgoto overflow;\n\n\t} else {\n\t\taddr = ALIGN(vstart, align);\n\t\tif (addr + size < addr)\n\t\t\tgoto overflow;\n\n\t\tn = vmap_area_root.rb_node;\n\t\tfirst = NULL;\n\n\t\twhile (n) {\n\t\t\tstruct vmap_area *tmp;\n\t\t\ttmp = rb_entry(n, struct vmap_area, rb_node);\n\t\t\tif (tmp->va_end >= addr) {\n\t\t\t\tfirst = tmp;\n\t\t\t\tif (tmp->va_start <= addr)\n\t\t\t\t\tbreak;\n\t\t\t\tn = n->rb_left;\n\t\t\t} else\n\t\t\t\tn = n->rb_right;\n\t\t}\n\n\t\tif (!first)\n\t\t\tgoto found;\n\t}\n\n\t/* from the starting point, walk areas until a suitable hole is found */\n\twhile (addr + size > first->va_start && addr + size <= vend) {\n\t\tif (addr + cached_hole_size < first->va_start)\n\t\t\tcached_hole_size = first->va_start - addr;\n\t\taddr = ALIGN(first->va_end, align);\n\t\tif (addr + size < addr)\n\t\t\tgoto overflow;\n\n\t\tif (list_is_last(&first->list, &vmap_area_list))\n\t\t\tgoto found;\n\n\t\tfirst = list_next_entry(first, list);\n\t}\n\nfound:\n\tif (addr + size > vend)\n\t\tgoto overflow;\n\n\tva->va_start = addr;\n\tva->va_end = addr + size;\n\tva->flags = 0;\n\t__insert_vmap_area(va);\n\tfree_vmap_cache = &va->rb_node;\n\tspin_unlock(&vmap_area_lock);\n\n\tBUG_ON(!IS_ALIGNED(va->va_start, align));\n\tBUG_ON(va->va_start < vstart);\n\tBUG_ON(va->va_end > vend);\n\n\treturn va;\n\noverflow:\n\tspin_unlock(&vmap_area_lock);\n\tif (!purged) {\n\t\tpurge_vmap_area_lazy();\n\t\tpurged = 1;\n\t\tgoto retry;\n\t}\n\n\tif (gfpflags_allow_blocking(gfp_mask)) {\n\t\tunsigned long freed = 0;\n\t\tblocking_notifier_call_chain(&vmap_notify_list, 0, &freed);\n\t\tif (freed > 0) {\n\t\t\tpurged = 0;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tif (!(gfp_mask & __GFP_NOWARN) && printk_ratelimit())\n\t\tpr_warn(\"vmap allocation for size %lu failed: use vmalloc=<size> to increase size\\n\",\n\t\t\tsize);\n\tkfree(va);\n\treturn ERR_PTR(-EBUSY);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(vmap_area_lock);",
            "static struct rb_root vmap_area_root = RB_ROOT;",
            "static struct rb_node *free_vmap_cache;",
            "static unsigned long cached_hole_size;",
            "static unsigned long cached_vstart;",
            "static unsigned long cached_align;",
            "static void purge_vmap_area_lazy(void);",
            "static BLOCKING_NOTIFIER_HEAD(vmap_notify_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic DEFINE_SPINLOCK(vmap_area_lock);\nstatic struct rb_root vmap_area_root = RB_ROOT;\nstatic struct rb_node *free_vmap_cache;\nstatic unsigned long cached_hole_size;\nstatic unsigned long cached_vstart;\nstatic unsigned long cached_align;\nstatic void purge_vmap_area_lazy(void);\nstatic BLOCKING_NOTIFIER_HEAD(vmap_notify_list);\n\nstatic struct vmap_area *alloc_vmap_area(unsigned long size,\n\t\t\t\tunsigned long align,\n\t\t\t\tunsigned long vstart, unsigned long vend,\n\t\t\t\tint node, gfp_t gfp_mask)\n{\n\tstruct vmap_area *va;\n\tstruct rb_node *n;\n\tunsigned long addr;\n\tint purged = 0;\n\tstruct vmap_area *first;\n\n\tBUG_ON(!size);\n\tBUG_ON(offset_in_page(size));\n\tBUG_ON(!is_power_of_2(align));\n\n\tmight_sleep();\n\n\tva = kmalloc_node(sizeof(struct vmap_area),\n\t\t\tgfp_mask & GFP_RECLAIM_MASK, node);\n\tif (unlikely(!va))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/*\n\t * Only scan the relevant parts containing pointers to other objects\n\t * to avoid false negatives.\n\t */\n\tkmemleak_scan_area(&va->rb_node, SIZE_MAX, gfp_mask & GFP_RECLAIM_MASK);\n\nretry:\n\tspin_lock(&vmap_area_lock);\n\t/*\n\t * Invalidate cache if we have more permissive parameters.\n\t * cached_hole_size notes the largest hole noticed _below_\n\t * the vmap_area cached in free_vmap_cache: if size fits\n\t * into that hole, we want to scan from vstart to reuse\n\t * the hole instead of allocating above free_vmap_cache.\n\t * Note that __free_vmap_area may update free_vmap_cache\n\t * without updating cached_hole_size or cached_align.\n\t */\n\tif (!free_vmap_cache ||\n\t\t\tsize < cached_hole_size ||\n\t\t\tvstart < cached_vstart ||\n\t\t\talign < cached_align) {\nnocache:\n\t\tcached_hole_size = 0;\n\t\tfree_vmap_cache = NULL;\n\t}\n\t/* record if we encounter less permissive parameters */\n\tcached_vstart = vstart;\n\tcached_align = align;\n\n\t/* find starting point for our search */\n\tif (free_vmap_cache) {\n\t\tfirst = rb_entry(free_vmap_cache, struct vmap_area, rb_node);\n\t\taddr = ALIGN(first->va_end, align);\n\t\tif (addr < vstart)\n\t\t\tgoto nocache;\n\t\tif (addr + size < addr)\n\t\t\tgoto overflow;\n\n\t} else {\n\t\taddr = ALIGN(vstart, align);\n\t\tif (addr + size < addr)\n\t\t\tgoto overflow;\n\n\t\tn = vmap_area_root.rb_node;\n\t\tfirst = NULL;\n\n\t\twhile (n) {\n\t\t\tstruct vmap_area *tmp;\n\t\t\ttmp = rb_entry(n, struct vmap_area, rb_node);\n\t\t\tif (tmp->va_end >= addr) {\n\t\t\t\tfirst = tmp;\n\t\t\t\tif (tmp->va_start <= addr)\n\t\t\t\t\tbreak;\n\t\t\t\tn = n->rb_left;\n\t\t\t} else\n\t\t\t\tn = n->rb_right;\n\t\t}\n\n\t\tif (!first)\n\t\t\tgoto found;\n\t}\n\n\t/* from the starting point, walk areas until a suitable hole is found */\n\twhile (addr + size > first->va_start && addr + size <= vend) {\n\t\tif (addr + cached_hole_size < first->va_start)\n\t\t\tcached_hole_size = first->va_start - addr;\n\t\taddr = ALIGN(first->va_end, align);\n\t\tif (addr + size < addr)\n\t\t\tgoto overflow;\n\n\t\tif (list_is_last(&first->list, &vmap_area_list))\n\t\t\tgoto found;\n\n\t\tfirst = list_next_entry(first, list);\n\t}\n\nfound:\n\tif (addr + size > vend)\n\t\tgoto overflow;\n\n\tva->va_start = addr;\n\tva->va_end = addr + size;\n\tva->flags = 0;\n\t__insert_vmap_area(va);\n\tfree_vmap_cache = &va->rb_node;\n\tspin_unlock(&vmap_area_lock);\n\n\tBUG_ON(!IS_ALIGNED(va->va_start, align));\n\tBUG_ON(va->va_start < vstart);\n\tBUG_ON(va->va_end > vend);\n\n\treturn va;\n\noverflow:\n\tspin_unlock(&vmap_area_lock);\n\tif (!purged) {\n\t\tpurge_vmap_area_lazy();\n\t\tpurged = 1;\n\t\tgoto retry;\n\t}\n\n\tif (gfpflags_allow_blocking(gfp_mask)) {\n\t\tunsigned long freed = 0;\n\t\tblocking_notifier_call_chain(&vmap_notify_list, 0, &freed);\n\t\tif (freed > 0) {\n\t\t\tpurged = 0;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tif (!(gfp_mask & __GFP_NOWARN) && printk_ratelimit())\n\t\tpr_warn(\"vmap allocation for size %lu failed: use vmalloc=<size> to increase size\\n\",\n\t\t\tsize);\n\tkfree(va);\n\treturn ERR_PTR(-EBUSY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mem"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vb_alloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "vb_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "961-1012",
          "snippet": "static void *vb_alloc(unsigned long size, gfp_t gfp_mask)\n{\n\tstruct vmap_block_queue *vbq;\n\tstruct vmap_block *vb;\n\tvoid *vaddr = NULL;\n\tunsigned int order;\n\n\tBUG_ON(offset_in_page(size));\n\tBUG_ON(size > PAGE_SIZE*VMAP_MAX_ALLOC);\n\tif (WARN_ON(size == 0)) {\n\t\t/*\n\t\t * Allocating 0 bytes isn't what caller wants since\n\t\t * get_order(0) returns funny result. Just warn and terminate\n\t\t * early.\n\t\t */\n\t\treturn NULL;\n\t}\n\torder = get_order(size);\n\n\trcu_read_lock();\n\tvbq = &get_cpu_var(vmap_block_queue);\n\tlist_for_each_entry_rcu(vb, &vbq->free, free_list) {\n\t\tunsigned long pages_off;\n\n\t\tspin_lock(&vb->lock);\n\t\tif (vb->free < (1UL << order)) {\n\t\t\tspin_unlock(&vb->lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpages_off = VMAP_BBMAP_BITS - vb->free;\n\t\tvaddr = vmap_block_vaddr(vb->va->va_start, pages_off);\n\t\tvb->free -= 1UL << order;\n\t\tif (vb->free == 0) {\n\t\t\tspin_lock(&vbq->lock);\n\t\t\tlist_del_rcu(&vb->free_list);\n\t\t\tspin_unlock(&vbq->lock);\n\t\t}\n\n\t\tspin_unlock(&vb->lock);\n\t\tbreak;\n\t}\n\n\tput_cpu_var(vmap_block_queue);\n\trcu_read_unlock();\n\n\t/* Allocate new block if nothing was found */\n\tif (!vaddr)\n\t\tvaddr = new_vmap_block(order, gfp_mask);\n\n\treturn vaddr;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [
            "#define VMAP_BBMAP_BITS\t\t\\\n\t\tVMAP_MIN(VMAP_BBMAP_BITS_MAX,\t\\\n\t\tVMAP_MAX(VMAP_BBMAP_BITS_MIN,\t\\\n\t\t\tVMALLOC_PAGES / roundup_pow_of_two(NR_CPUS) / 16))",
            "#define VMAP_MAX_ALLOC\t\tBITS_PER_LONG\t/* 256K with 4K pages */"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU(struct vmap_block_queue, vmap_block_queue);",
            "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\n#define VMAP_BBMAP_BITS\t\t\\\n\t\tVMAP_MIN(VMAP_BBMAP_BITS_MAX,\t\\\n\t\tVMAP_MAX(VMAP_BBMAP_BITS_MIN,\t\\\n\t\t\tVMALLOC_PAGES / roundup_pow_of_two(NR_CPUS) / 16))\n#define VMAP_MAX_ALLOC\t\tBITS_PER_LONG\t/* 256K with 4K pages */\n\nstatic DEFINE_PER_CPU(struct vmap_block_queue, vmap_block_queue);\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);\n\nstatic void *vb_alloc(unsigned long size, gfp_t gfp_mask)\n{\n\tstruct vmap_block_queue *vbq;\n\tstruct vmap_block *vb;\n\tvoid *vaddr = NULL;\n\tunsigned int order;\n\n\tBUG_ON(offset_in_page(size));\n\tBUG_ON(size > PAGE_SIZE*VMAP_MAX_ALLOC);\n\tif (WARN_ON(size == 0)) {\n\t\t/*\n\t\t * Allocating 0 bytes isn't what caller wants since\n\t\t * get_order(0) returns funny result. Just warn and terminate\n\t\t * early.\n\t\t */\n\t\treturn NULL;\n\t}\n\torder = get_order(size);\n\n\trcu_read_lock();\n\tvbq = &get_cpu_var(vmap_block_queue);\n\tlist_for_each_entry_rcu(vb, &vbq->free, free_list) {\n\t\tunsigned long pages_off;\n\n\t\tspin_lock(&vb->lock);\n\t\tif (vb->free < (1UL << order)) {\n\t\t\tspin_unlock(&vb->lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpages_off = VMAP_BBMAP_BITS - vb->free;\n\t\tvaddr = vmap_block_vaddr(vb->va->va_start, pages_off);\n\t\tvb->free -= 1UL << order;\n\t\tif (vb->free == 0) {\n\t\t\tspin_lock(&vbq->lock);\n\t\t\tlist_del_rcu(&vb->free_list);\n\t\t\tspin_unlock(&vbq->lock);\n\t\t}\n\n\t\tspin_unlock(&vb->lock);\n\t\tbreak;\n\t}\n\n\tput_cpu_var(vmap_block_queue);\n\trcu_read_unlock();\n\n\t/* Allocate new block if nothing was found */\n\tif (!vaddr)\n\t\tvaddr = new_vmap_block(order, gfp_mask);\n\n\treturn vaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "count <= VMAP_MAX_ALLOC"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\n#define VMAP_MAX_ALLOC\t\tBITS_PER_LONG\t/* 256K with 4K pages */\n\nvoid *vm_map_ram(struct page **pages, unsigned int count, int node, pgprot_t prot)\n{\n\tunsigned long size = (unsigned long)count << PAGE_SHIFT;\n\tunsigned long addr;\n\tvoid *mem;\n\n\tif (likely(count <= VMAP_MAX_ALLOC)) {\n\t\tmem = vb_alloc(size, GFP_KERNEL);\n\t\tif (IS_ERR(mem))\n\t\t\treturn NULL;\n\t\taddr = (unsigned long)mem;\n\t} else {\n\t\tstruct vmap_area *va;\n\t\tva = alloc_vmap_area(size, PAGE_SIZE,\n\t\t\t\tVMALLOC_START, VMALLOC_END, node, GFP_KERNEL);\n\t\tif (IS_ERR(va))\n\t\t\treturn NULL;\n\n\t\taddr = va->va_start;\n\t\tmem = (void *)addr;\n\t}\n\tif (vmap_page_range(addr, addr + size, prot, pages) < 0) {\n\t\tvm_unmap_ram(mem, count);\n\t\treturn NULL;\n\t}\n\treturn mem;\n}"
  },
  {
    "function_name": "vm_unmap_ram",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "1119-1142",
    "snippet": "void vm_unmap_ram(const void *mem, unsigned int count)\n{\n\tunsigned long size = (unsigned long)count << PAGE_SHIFT;\n\tunsigned long addr = (unsigned long)mem;\n\tstruct vmap_area *va;\n\n\tmight_sleep();\n\tBUG_ON(!addr);\n\tBUG_ON(addr < VMALLOC_START);\n\tBUG_ON(addr > VMALLOC_END);\n\tBUG_ON(!PAGE_ALIGNED(addr));\n\n\tif (likely(count <= VMAP_MAX_ALLOC)) {\n\t\tdebug_check_no_locks_freed(mem, size);\n\t\tvb_free(mem, size);\n\t\treturn;\n\t}\n\n\tva = find_vmap_area(addr);\n\tBUG_ON(!va);\n\tdebug_check_no_locks_freed((void *)va->va_start,\n\t\t\t\t    (va->va_end - va->va_start));\n\tfree_unmap_vmap_area(va);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [
      "#define VMAP_MAX_ALLOC\t\tBITS_PER_LONG\t/* 256K with 4K pages */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_unmap_vmap_area",
          "args": [
            "va"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "free_unmap_vmap_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "735-743",
          "snippet": "static void free_unmap_vmap_area(struct vmap_area *va)\n{\n\tflush_cache_vunmap(va->va_start, va->va_end);\n\tunmap_vmap_area(va);\n\tif (debug_pagealloc_enabled())\n\t\tflush_tlb_kernel_range(va->va_start, va->va_end);\n\n\tfree_vmap_area_noflush(va);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void free_unmap_vmap_area(struct vmap_area *va)\n{\n\tflush_cache_vunmap(va->va_start, va->va_end);\n\tunmap_vmap_area(va);\n\tif (debug_pagealloc_enabled())\n\t\tflush_tlb_kernel_range(va->va_start, va->va_end);\n\n\tfree_vmap_area_noflush(va);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_check_no_locks_freed",
          "args": [
            "(void *)va->va_start",
            "(va->va_end - va->va_start)"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!va"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_vmap_area",
          "args": [
            "addr"
          ],
          "line": 1137
        },
        "resolved": true,
        "details": {
          "function_name": "find_vmap_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "745-754",
          "snippet": "static struct vmap_area *find_vmap_area(unsigned long addr)\n{\n\tstruct vmap_area *va;\n\n\tspin_lock(&vmap_area_lock);\n\tva = __find_vmap_area(addr);\n\tspin_unlock(&vmap_area_lock);\n\n\treturn va;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(vmap_area_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic DEFINE_SPINLOCK(vmap_area_lock);\n\nstatic struct vmap_area *find_vmap_area(unsigned long addr)\n{\n\tstruct vmap_area *va;\n\n\tspin_lock(&vmap_area_lock);\n\tva = __find_vmap_area(addr);\n\tspin_unlock(&vmap_area_lock);\n\n\treturn va;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vb_free",
          "args": [
            "mem",
            "size"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "vb_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1014-1056",
          "snippet": "static void vb_free(const void *addr, unsigned long size)\n{\n\tunsigned long offset;\n\tunsigned long vb_idx;\n\tunsigned int order;\n\tstruct vmap_block *vb;\n\n\tBUG_ON(offset_in_page(size));\n\tBUG_ON(size > PAGE_SIZE*VMAP_MAX_ALLOC);\n\n\tflush_cache_vunmap((unsigned long)addr, (unsigned long)addr + size);\n\n\torder = get_order(size);\n\n\toffset = (unsigned long)addr & (VMAP_BLOCK_SIZE - 1);\n\toffset >>= PAGE_SHIFT;\n\n\tvb_idx = addr_to_vb_idx((unsigned long)addr);\n\trcu_read_lock();\n\tvb = radix_tree_lookup(&vmap_block_tree, vb_idx);\n\trcu_read_unlock();\n\tBUG_ON(!vb);\n\n\tvunmap_page_range((unsigned long)addr, (unsigned long)addr + size);\n\n\tif (debug_pagealloc_enabled())\n\t\tflush_tlb_kernel_range((unsigned long)addr,\n\t\t\t\t\t(unsigned long)addr + size);\n\n\tspin_lock(&vb->lock);\n\n\t/* Expand dirty range */\n\tvb->dirty_min = min(vb->dirty_min, offset);\n\tvb->dirty_max = max(vb->dirty_max, offset + (1UL << order));\n\n\tvb->dirty += 1UL << order;\n\tif (vb->dirty == VMAP_BBMAP_BITS) {\n\t\tBUG_ON(vb->free);\n\t\tspin_unlock(&vb->lock);\n\t\tfree_vmap_block(vb);\n\t} else\n\t\tspin_unlock(&vb->lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [
            "#define VMAP_BLOCK_SIZE\t\t(VMAP_BBMAP_BITS * PAGE_SIZE)",
            "#define VMAP_BBMAP_BITS\t\t\\\n\t\tVMAP_MIN(VMAP_BBMAP_BITS_MAX,\t\\\n\t\tVMAP_MAX(VMAP_BBMAP_BITS_MIN,\t\\\n\t\t\tVMALLOC_PAGES / roundup_pow_of_two(NR_CPUS) / 16))",
            "#define VMAP_MAX_ALLOC\t\tBITS_PER_LONG\t/* 256K with 4K pages */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\n#define VMAP_BLOCK_SIZE\t\t(VMAP_BBMAP_BITS * PAGE_SIZE)\n#define VMAP_BBMAP_BITS\t\t\\\n\t\tVMAP_MIN(VMAP_BBMAP_BITS_MAX,\t\\\n\t\tVMAP_MAX(VMAP_BBMAP_BITS_MIN,\t\\\n\t\t\tVMALLOC_PAGES / roundup_pow_of_two(NR_CPUS) / 16))\n#define VMAP_MAX_ALLOC\t\tBITS_PER_LONG\t/* 256K with 4K pages */\n\nstatic void vb_free(const void *addr, unsigned long size)\n{\n\tunsigned long offset;\n\tunsigned long vb_idx;\n\tunsigned int order;\n\tstruct vmap_block *vb;\n\n\tBUG_ON(offset_in_page(size));\n\tBUG_ON(size > PAGE_SIZE*VMAP_MAX_ALLOC);\n\n\tflush_cache_vunmap((unsigned long)addr, (unsigned long)addr + size);\n\n\torder = get_order(size);\n\n\toffset = (unsigned long)addr & (VMAP_BLOCK_SIZE - 1);\n\toffset >>= PAGE_SHIFT;\n\n\tvb_idx = addr_to_vb_idx((unsigned long)addr);\n\trcu_read_lock();\n\tvb = radix_tree_lookup(&vmap_block_tree, vb_idx);\n\trcu_read_unlock();\n\tBUG_ON(!vb);\n\n\tvunmap_page_range((unsigned long)addr, (unsigned long)addr + size);\n\n\tif (debug_pagealloc_enabled())\n\t\tflush_tlb_kernel_range((unsigned long)addr,\n\t\t\t\t\t(unsigned long)addr + size);\n\n\tspin_lock(&vb->lock);\n\n\t/* Expand dirty range */\n\tvb->dirty_min = min(vb->dirty_min, offset);\n\tvb->dirty_max = max(vb->dirty_max, offset + (1UL << order));\n\n\tvb->dirty += 1UL << order;\n\tif (vb->dirty == VMAP_BBMAP_BITS) {\n\t\tBUG_ON(vb->free);\n\t\tspin_unlock(&vb->lock);\n\t\tfree_vmap_block(vb);\n\t} else\n\t\tspin_unlock(&vb->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_check_no_locks_freed",
          "args": [
            "mem",
            "size"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "count <= VMAP_MAX_ALLOC"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PAGE_ALIGNED(addr)"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGNED",
          "args": [
            "addr"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "addr > VMALLOC_END"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "addr < VMALLOC_START"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!addr"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\n#define VMAP_MAX_ALLOC\t\tBITS_PER_LONG\t/* 256K with 4K pages */\n\nvoid vm_unmap_ram(const void *mem, unsigned int count)\n{\n\tunsigned long size = (unsigned long)count << PAGE_SHIFT;\n\tunsigned long addr = (unsigned long)mem;\n\tstruct vmap_area *va;\n\n\tmight_sleep();\n\tBUG_ON(!addr);\n\tBUG_ON(addr < VMALLOC_START);\n\tBUG_ON(addr > VMALLOC_END);\n\tBUG_ON(!PAGE_ALIGNED(addr));\n\n\tif (likely(count <= VMAP_MAX_ALLOC)) {\n\t\tdebug_check_no_locks_freed(mem, size);\n\t\tvb_free(mem, size);\n\t\treturn;\n\t}\n\n\tva = find_vmap_area(addr);\n\tBUG_ON(!va);\n\tdebug_check_no_locks_freed((void *)va->va_start,\n\t\t\t\t    (va->va_end - va->va_start));\n\tfree_unmap_vmap_area(va);\n}"
  },
  {
    "function_name": "vm_unmap_aliases",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "1071-1111",
    "snippet": "void vm_unmap_aliases(void)\n{\n\tunsigned long start = ULONG_MAX, end = 0;\n\tint cpu;\n\tint flush = 0;\n\n\tif (unlikely(!vmap_initialized))\n\t\treturn;\n\n\tmight_sleep();\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct vmap_block_queue *vbq = &per_cpu(vmap_block_queue, cpu);\n\t\tstruct vmap_block *vb;\n\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(vb, &vbq->free, free_list) {\n\t\t\tspin_lock(&vb->lock);\n\t\t\tif (vb->dirty) {\n\t\t\t\tunsigned long va_start = vb->va->va_start;\n\t\t\t\tunsigned long s, e;\n\n\t\t\t\ts = va_start + (vb->dirty_min << PAGE_SHIFT);\n\t\t\t\te = va_start + (vb->dirty_max << PAGE_SHIFT);\n\n\t\t\t\tstart = min(s, start);\n\t\t\t\tend   = max(e, end);\n\n\t\t\t\tflush = 1;\n\t\t\t}\n\t\t\tspin_unlock(&vb->lock);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tmutex_lock(&vmap_purge_lock);\n\tpurge_fragmented_blocks_allcpus();\n\tif (!__purge_vmap_area_lazy(start, end) && flush)\n\t\tflush_tlb_kernel_range(start, end);\n\tmutex_unlock(&vmap_purge_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(vmap_purge_lock);",
      "static void purge_fragmented_blocks_allcpus(void);",
      "static bool vmap_initialized",
      "static DEFINE_PER_CPU(struct vmap_block_queue, vmap_block_queue);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&vmap_purge_lock"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_tlb_kernel_range",
          "args": [
            "start",
            "end"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__purge_vmap_area_lazy",
          "args": [
            "start",
            "end"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "__purge_vmap_area_lazy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "655-688",
          "snippet": "static bool __purge_vmap_area_lazy(unsigned long start, unsigned long end)\n{\n\tstruct llist_node *valist;\n\tstruct vmap_area *va;\n\tstruct vmap_area *n_va;\n\tbool do_free = false;\n\n\tlockdep_assert_held(&vmap_purge_lock);\n\n\tvalist = llist_del_all(&vmap_purge_list);\n\tllist_for_each_entry(va, valist, purge_list) {\n\t\tif (va->va_start < start)\n\t\t\tstart = va->va_start;\n\t\tif (va->va_end > end)\n\t\t\tend = va->va_end;\n\t\tdo_free = true;\n\t}\n\n\tif (!do_free)\n\t\treturn false;\n\n\tflush_tlb_kernel_range(start, end);\n\n\tspin_lock(&vmap_area_lock);\n\tllist_for_each_entry_safe(va, n_va, valist, purge_list) {\n\t\tint nr = (va->va_end - va->va_start) >> PAGE_SHIFT;\n\n\t\t__free_vmap_area(va);\n\t\tatomic_sub(nr, &vmap_lazy_nr);\n\t\tcond_resched_lock(&vmap_area_lock);\n\t}\n\tspin_unlock(&vmap_area_lock);\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(vmap_area_lock);",
            "static LLIST_HEAD(vmap_purge_list);",
            "static atomic_t vmap_lazy_nr = ATOMIC_INIT(0);",
            "static DEFINE_MUTEX(vmap_purge_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic DEFINE_SPINLOCK(vmap_area_lock);\nstatic LLIST_HEAD(vmap_purge_list);\nstatic atomic_t vmap_lazy_nr = ATOMIC_INIT(0);\nstatic DEFINE_MUTEX(vmap_purge_lock);\n\nstatic bool __purge_vmap_area_lazy(unsigned long start, unsigned long end)\n{\n\tstruct llist_node *valist;\n\tstruct vmap_area *va;\n\tstruct vmap_area *n_va;\n\tbool do_free = false;\n\n\tlockdep_assert_held(&vmap_purge_lock);\n\n\tvalist = llist_del_all(&vmap_purge_list);\n\tllist_for_each_entry(va, valist, purge_list) {\n\t\tif (va->va_start < start)\n\t\t\tstart = va->va_start;\n\t\tif (va->va_end > end)\n\t\t\tend = va->va_end;\n\t\tdo_free = true;\n\t}\n\n\tif (!do_free)\n\t\treturn false;\n\n\tflush_tlb_kernel_range(start, end);\n\n\tspin_lock(&vmap_area_lock);\n\tllist_for_each_entry_safe(va, n_va, valist, purge_list) {\n\t\tint nr = (va->va_end - va->va_start) >> PAGE_SHIFT;\n\n\t\t__free_vmap_area(va);\n\t\tatomic_sub(nr, &vmap_lazy_nr);\n\t\tcond_resched_lock(&vmap_area_lock);\n\t}\n\tspin_unlock(&vmap_area_lock);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "purge_fragmented_blocks_allcpus",
          "args": [],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "purge_fragmented_blocks_allcpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "953-959",
          "snippet": "static void purge_fragmented_blocks_allcpus(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tpurge_fragmented_blocks(cpu);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void purge_fragmented_blocks_allcpus(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void purge_fragmented_blocks_allcpus(void);\n\nstatic void purge_fragmented_blocks_allcpus(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tpurge_fragmented_blocks(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&vmap_purge_lock"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vb->lock"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "e",
            "end"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "s",
            "start"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vb->lock"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "vb",
            "&vbq->free",
            "free_list"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "vmap_block_queue",
            "cpu"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!vmap_initialized"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic DEFINE_MUTEX(vmap_purge_lock);\nstatic void purge_fragmented_blocks_allcpus(void);\nstatic bool vmap_initialized;\nstatic DEFINE_PER_CPU(struct vmap_block_queue, vmap_block_queue);\n\nvoid vm_unmap_aliases(void)\n{\n\tunsigned long start = ULONG_MAX, end = 0;\n\tint cpu;\n\tint flush = 0;\n\n\tif (unlikely(!vmap_initialized))\n\t\treturn;\n\n\tmight_sleep();\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct vmap_block_queue *vbq = &per_cpu(vmap_block_queue, cpu);\n\t\tstruct vmap_block *vb;\n\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(vb, &vbq->free, free_list) {\n\t\t\tspin_lock(&vb->lock);\n\t\t\tif (vb->dirty) {\n\t\t\t\tunsigned long va_start = vb->va->va_start;\n\t\t\t\tunsigned long s, e;\n\n\t\t\t\ts = va_start + (vb->dirty_min << PAGE_SHIFT);\n\t\t\t\te = va_start + (vb->dirty_max << PAGE_SHIFT);\n\n\t\t\t\tstart = min(s, start);\n\t\t\t\tend   = max(e, end);\n\n\t\t\t\tflush = 1;\n\t\t\t}\n\t\t\tspin_unlock(&vb->lock);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tmutex_lock(&vmap_purge_lock);\n\tpurge_fragmented_blocks_allcpus();\n\tif (!__purge_vmap_area_lazy(start, end) && flush)\n\t\tflush_tlb_kernel_range(start, end);\n\tmutex_unlock(&vmap_purge_lock);\n}"
  },
  {
    "function_name": "vb_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "1014-1056",
    "snippet": "static void vb_free(const void *addr, unsigned long size)\n{\n\tunsigned long offset;\n\tunsigned long vb_idx;\n\tunsigned int order;\n\tstruct vmap_block *vb;\n\n\tBUG_ON(offset_in_page(size));\n\tBUG_ON(size > PAGE_SIZE*VMAP_MAX_ALLOC);\n\n\tflush_cache_vunmap((unsigned long)addr, (unsigned long)addr + size);\n\n\torder = get_order(size);\n\n\toffset = (unsigned long)addr & (VMAP_BLOCK_SIZE - 1);\n\toffset >>= PAGE_SHIFT;\n\n\tvb_idx = addr_to_vb_idx((unsigned long)addr);\n\trcu_read_lock();\n\tvb = radix_tree_lookup(&vmap_block_tree, vb_idx);\n\trcu_read_unlock();\n\tBUG_ON(!vb);\n\n\tvunmap_page_range((unsigned long)addr, (unsigned long)addr + size);\n\n\tif (debug_pagealloc_enabled())\n\t\tflush_tlb_kernel_range((unsigned long)addr,\n\t\t\t\t\t(unsigned long)addr + size);\n\n\tspin_lock(&vb->lock);\n\n\t/* Expand dirty range */\n\tvb->dirty_min = min(vb->dirty_min, offset);\n\tvb->dirty_max = max(vb->dirty_max, offset + (1UL << order));\n\n\tvb->dirty += 1UL << order;\n\tif (vb->dirty == VMAP_BBMAP_BITS) {\n\t\tBUG_ON(vb->free);\n\t\tspin_unlock(&vb->lock);\n\t\tfree_vmap_block(vb);\n\t} else\n\t\tspin_unlock(&vb->lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [
      "#define VMAP_BLOCK_SIZE\t\t(VMAP_BBMAP_BITS * PAGE_SIZE)",
      "#define VMAP_BBMAP_BITS\t\t\\\n\t\tVMAP_MIN(VMAP_BBMAP_BITS_MAX,\t\\\n\t\tVMAP_MAX(VMAP_BBMAP_BITS_MIN,\t\\\n\t\t\tVMALLOC_PAGES / roundup_pow_of_two(NR_CPUS) / 16))",
      "#define VMAP_MAX_ALLOC\t\tBITS_PER_LONG\t/* 256K with 4K pages */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vb->lock"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_vmap_block",
          "args": [
            "vb"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "free_vmap_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "903-916",
          "snippet": "static void free_vmap_block(struct vmap_block *vb)\n{\n\tstruct vmap_block *tmp;\n\tunsigned long vb_idx;\n\n\tvb_idx = addr_to_vb_idx(vb->va->va_start);\n\tspin_lock(&vmap_block_tree_lock);\n\ttmp = radix_tree_delete(&vmap_block_tree, vb_idx);\n\tspin_unlock(&vmap_block_tree_lock);\n\tBUG_ON(tmp != vb);\n\n\tfree_vmap_area_noflush(vb->va);\n\tkfree_rcu(vb, rcu_head);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(vmap_block_tree_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic DEFINE_SPINLOCK(vmap_block_tree_lock);\n\nstatic void free_vmap_block(struct vmap_block *vb)\n{\n\tstruct vmap_block *tmp;\n\tunsigned long vb_idx;\n\n\tvb_idx = addr_to_vb_idx(vb->va->va_start);\n\tspin_lock(&vmap_block_tree_lock);\n\ttmp = radix_tree_delete(&vmap_block_tree, vb_idx);\n\tspin_unlock(&vmap_block_tree_lock);\n\tBUG_ON(tmp != vb);\n\n\tfree_vmap_area_noflush(vb->va);\n\tkfree_rcu(vb, rcu_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vb->lock"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "vb->free"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "vb->dirty_max",
            "offset + (1UL << order)"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "vb->dirty_min",
            "offset"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vb->lock"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_tlb_kernel_range",
          "args": [
            "(unsigned long)addr",
            "(unsigned long)addr + size"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_pagealloc_enabled",
          "args": [],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vunmap_page_range",
          "args": [
            "(unsigned long)addr",
            "(unsigned long)addr + size"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "vunmap_page_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "119-132",
          "snippet": "static void vunmap_page_range(unsigned long addr, unsigned long end)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\n\tBUG_ON(addr >= end);\n\tpgd = pgd_offset_k(addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(pgd))\n\t\t\tcontinue;\n\t\tvunmap_p4d_range(pgd, addr, next);\n\t} while (pgd++, addr = next, addr != end);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void vunmap_page_range(unsigned long addr, unsigned long end)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\n\tBUG_ON(addr >= end);\n\tpgd = pgd_offset_k(addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(pgd))\n\t\t\tcontinue;\n\t\tvunmap_p4d_range(pgd, addr, next);\n\t} while (pgd++, addr = next, addr != end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!vb"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_lookup",
          "args": [
            "&vmap_block_tree",
            "vb_idx"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addr_to_vb_idx",
          "args": [
            "(unsigned long)addr"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "addr_to_vb_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "821-826",
          "snippet": "static unsigned long addr_to_vb_idx(unsigned long addr)\n{\n\taddr -= VMALLOC_START & ~(VMAP_BLOCK_SIZE-1);\n\taddr /= VMAP_BLOCK_SIZE;\n\treturn addr;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [
            "#define VMAP_BLOCK_SIZE\t\t(VMAP_BBMAP_BITS * PAGE_SIZE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\n#define VMAP_BLOCK_SIZE\t\t(VMAP_BBMAP_BITS * PAGE_SIZE)\n\nstatic unsigned long addr_to_vb_idx(unsigned long addr)\n{\n\taddr -= VMALLOC_START & ~(VMAP_BLOCK_SIZE-1);\n\taddr /= VMAP_BLOCK_SIZE;\n\treturn addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "size"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_cache_vunmap",
          "args": [
            "(unsigned long)addr",
            "(unsigned long)addr + size"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "size > PAGE_SIZE*VMAP_MAX_ALLOC"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "offset_in_page(size)"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "size"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\n#define VMAP_BLOCK_SIZE\t\t(VMAP_BBMAP_BITS * PAGE_SIZE)\n#define VMAP_BBMAP_BITS\t\t\\\n\t\tVMAP_MIN(VMAP_BBMAP_BITS_MAX,\t\\\n\t\tVMAP_MAX(VMAP_BBMAP_BITS_MIN,\t\\\n\t\t\tVMALLOC_PAGES / roundup_pow_of_two(NR_CPUS) / 16))\n#define VMAP_MAX_ALLOC\t\tBITS_PER_LONG\t/* 256K with 4K pages */\n\nstatic void vb_free(const void *addr, unsigned long size)\n{\n\tunsigned long offset;\n\tunsigned long vb_idx;\n\tunsigned int order;\n\tstruct vmap_block *vb;\n\n\tBUG_ON(offset_in_page(size));\n\tBUG_ON(size > PAGE_SIZE*VMAP_MAX_ALLOC);\n\n\tflush_cache_vunmap((unsigned long)addr, (unsigned long)addr + size);\n\n\torder = get_order(size);\n\n\toffset = (unsigned long)addr & (VMAP_BLOCK_SIZE - 1);\n\toffset >>= PAGE_SHIFT;\n\n\tvb_idx = addr_to_vb_idx((unsigned long)addr);\n\trcu_read_lock();\n\tvb = radix_tree_lookup(&vmap_block_tree, vb_idx);\n\trcu_read_unlock();\n\tBUG_ON(!vb);\n\n\tvunmap_page_range((unsigned long)addr, (unsigned long)addr + size);\n\n\tif (debug_pagealloc_enabled())\n\t\tflush_tlb_kernel_range((unsigned long)addr,\n\t\t\t\t\t(unsigned long)addr + size);\n\n\tspin_lock(&vb->lock);\n\n\t/* Expand dirty range */\n\tvb->dirty_min = min(vb->dirty_min, offset);\n\tvb->dirty_max = max(vb->dirty_max, offset + (1UL << order));\n\n\tvb->dirty += 1UL << order;\n\tif (vb->dirty == VMAP_BBMAP_BITS) {\n\t\tBUG_ON(vb->free);\n\t\tspin_unlock(&vb->lock);\n\t\tfree_vmap_block(vb);\n\t} else\n\t\tspin_unlock(&vb->lock);\n}"
  },
  {
    "function_name": "vb_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "961-1012",
    "snippet": "static void *vb_alloc(unsigned long size, gfp_t gfp_mask)\n{\n\tstruct vmap_block_queue *vbq;\n\tstruct vmap_block *vb;\n\tvoid *vaddr = NULL;\n\tunsigned int order;\n\n\tBUG_ON(offset_in_page(size));\n\tBUG_ON(size > PAGE_SIZE*VMAP_MAX_ALLOC);\n\tif (WARN_ON(size == 0)) {\n\t\t/*\n\t\t * Allocating 0 bytes isn't what caller wants since\n\t\t * get_order(0) returns funny result. Just warn and terminate\n\t\t * early.\n\t\t */\n\t\treturn NULL;\n\t}\n\torder = get_order(size);\n\n\trcu_read_lock();\n\tvbq = &get_cpu_var(vmap_block_queue);\n\tlist_for_each_entry_rcu(vb, &vbq->free, free_list) {\n\t\tunsigned long pages_off;\n\n\t\tspin_lock(&vb->lock);\n\t\tif (vb->free < (1UL << order)) {\n\t\t\tspin_unlock(&vb->lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpages_off = VMAP_BBMAP_BITS - vb->free;\n\t\tvaddr = vmap_block_vaddr(vb->va->va_start, pages_off);\n\t\tvb->free -= 1UL << order;\n\t\tif (vb->free == 0) {\n\t\t\tspin_lock(&vbq->lock);\n\t\t\tlist_del_rcu(&vb->free_list);\n\t\t\tspin_unlock(&vbq->lock);\n\t\t}\n\n\t\tspin_unlock(&vb->lock);\n\t\tbreak;\n\t}\n\n\tput_cpu_var(vmap_block_queue);\n\trcu_read_unlock();\n\n\t/* Allocate new block if nothing was found */\n\tif (!vaddr)\n\t\tvaddr = new_vmap_block(order, gfp_mask);\n\n\treturn vaddr;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [
      "#define VMAP_BBMAP_BITS\t\t\\\n\t\tVMAP_MIN(VMAP_BBMAP_BITS_MAX,\t\\\n\t\tVMAP_MAX(VMAP_BBMAP_BITS_MIN,\t\\\n\t\t\tVMALLOC_PAGES / roundup_pow_of_two(NR_CPUS) / 16))",
      "#define VMAP_MAX_ALLOC\t\tBITS_PER_LONG\t/* 256K with 4K pages */"
    ],
    "globals_used": [
      "static DEFINE_PER_CPU(struct vmap_block_queue, vmap_block_queue);",
      "static void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "new_vmap_block",
          "args": [
            "order",
            "gfp_mask"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "new_vmap_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "845-901",
          "snippet": "static void *new_vmap_block(unsigned int order, gfp_t gfp_mask)\n{\n\tstruct vmap_block_queue *vbq;\n\tstruct vmap_block *vb;\n\tstruct vmap_area *va;\n\tunsigned long vb_idx;\n\tint node, err;\n\tvoid *vaddr;\n\n\tnode = numa_node_id();\n\n\tvb = kmalloc_node(sizeof(struct vmap_block),\n\t\t\tgfp_mask & GFP_RECLAIM_MASK, node);\n\tif (unlikely(!vb))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tva = alloc_vmap_area(VMAP_BLOCK_SIZE, VMAP_BLOCK_SIZE,\n\t\t\t\t\tVMALLOC_START, VMALLOC_END,\n\t\t\t\t\tnode, gfp_mask);\n\tif (IS_ERR(va)) {\n\t\tkfree(vb);\n\t\treturn ERR_CAST(va);\n\t}\n\n\terr = radix_tree_preload(gfp_mask);\n\tif (unlikely(err)) {\n\t\tkfree(vb);\n\t\tfree_vmap_area(va);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tvaddr = vmap_block_vaddr(va->va_start, 0);\n\tspin_lock_init(&vb->lock);\n\tvb->va = va;\n\t/* At least something should be left free */\n\tBUG_ON(VMAP_BBMAP_BITS <= (1UL << order));\n\tvb->free = VMAP_BBMAP_BITS - (1UL << order);\n\tvb->dirty = 0;\n\tvb->dirty_min = VMAP_BBMAP_BITS;\n\tvb->dirty_max = 0;\n\tINIT_LIST_HEAD(&vb->free_list);\n\n\tvb_idx = addr_to_vb_idx(va->va_start);\n\tspin_lock(&vmap_block_tree_lock);\n\terr = radix_tree_insert(&vmap_block_tree, vb_idx, vb);\n\tspin_unlock(&vmap_block_tree_lock);\n\tBUG_ON(err);\n\tradix_tree_preload_end();\n\n\tvbq = &get_cpu_var(vmap_block_queue);\n\tspin_lock(&vbq->lock);\n\tlist_add_tail_rcu(&vb->free_list, &vbq->free);\n\tspin_unlock(&vbq->lock);\n\tput_cpu_var(vmap_block_queue);\n\n\treturn vaddr;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [
            "#define VMAP_BLOCK_SIZE\t\t(VMAP_BBMAP_BITS * PAGE_SIZE)",
            "#define VMAP_BBMAP_BITS\t\t\\\n\t\tVMAP_MIN(VMAP_BBMAP_BITS_MAX,\t\\\n\t\tVMAP_MAX(VMAP_BBMAP_BITS_MIN,\t\\\n\t\t\tVMALLOC_PAGES / roundup_pow_of_two(NR_CPUS) / 16))"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU(struct vmap_block_queue, vmap_block_queue);",
            "static DEFINE_SPINLOCK(vmap_block_tree_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\n#define VMAP_BLOCK_SIZE\t\t(VMAP_BBMAP_BITS * PAGE_SIZE)\n#define VMAP_BBMAP_BITS\t\t\\\n\t\tVMAP_MIN(VMAP_BBMAP_BITS_MAX,\t\\\n\t\tVMAP_MAX(VMAP_BBMAP_BITS_MIN,\t\\\n\t\t\tVMALLOC_PAGES / roundup_pow_of_two(NR_CPUS) / 16))\n\nstatic DEFINE_PER_CPU(struct vmap_block_queue, vmap_block_queue);\nstatic DEFINE_SPINLOCK(vmap_block_tree_lock);\n\nstatic void *new_vmap_block(unsigned int order, gfp_t gfp_mask)\n{\n\tstruct vmap_block_queue *vbq;\n\tstruct vmap_block *vb;\n\tstruct vmap_area *va;\n\tunsigned long vb_idx;\n\tint node, err;\n\tvoid *vaddr;\n\n\tnode = numa_node_id();\n\n\tvb = kmalloc_node(sizeof(struct vmap_block),\n\t\t\tgfp_mask & GFP_RECLAIM_MASK, node);\n\tif (unlikely(!vb))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tva = alloc_vmap_area(VMAP_BLOCK_SIZE, VMAP_BLOCK_SIZE,\n\t\t\t\t\tVMALLOC_START, VMALLOC_END,\n\t\t\t\t\tnode, gfp_mask);\n\tif (IS_ERR(va)) {\n\t\tkfree(vb);\n\t\treturn ERR_CAST(va);\n\t}\n\n\terr = radix_tree_preload(gfp_mask);\n\tif (unlikely(err)) {\n\t\tkfree(vb);\n\t\tfree_vmap_area(va);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tvaddr = vmap_block_vaddr(va->va_start, 0);\n\tspin_lock_init(&vb->lock);\n\tvb->va = va;\n\t/* At least something should be left free */\n\tBUG_ON(VMAP_BBMAP_BITS <= (1UL << order));\n\tvb->free = VMAP_BBMAP_BITS - (1UL << order);\n\tvb->dirty = 0;\n\tvb->dirty_min = VMAP_BBMAP_BITS;\n\tvb->dirty_max = 0;\n\tINIT_LIST_HEAD(&vb->free_list);\n\n\tvb_idx = addr_to_vb_idx(va->va_start);\n\tspin_lock(&vmap_block_tree_lock);\n\terr = radix_tree_insert(&vmap_block_tree, vb_idx, vb);\n\tspin_unlock(&vmap_block_tree_lock);\n\tBUG_ON(err);\n\tradix_tree_preload_end();\n\n\tvbq = &get_cpu_var(vmap_block_queue);\n\tspin_lock(&vbq->lock);\n\tlist_add_tail_rcu(&vb->free_list, &vbq->free);\n\tspin_unlock(&vbq->lock);\n\tput_cpu_var(vmap_block_queue);\n\n\treturn vaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_cpu_var",
          "args": [
            "vmap_block_queue"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vb->lock"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vbq->lock"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&vb->free_list"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vbq->lock"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmap_block_vaddr",
          "args": [
            "vb->va->va_start",
            "pages_off"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "vmap_block_vaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "828-835",
          "snippet": "static void *vmap_block_vaddr(unsigned long va_start, unsigned long pages_off)\n{\n\tunsigned long addr;\n\n\taddr = va_start + (pages_off << PAGE_SHIFT);\n\tBUG_ON(addr_to_vb_idx(addr) != addr_to_vb_idx(va_start));\n\treturn (void *)addr;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void *vmap_block_vaddr(unsigned long va_start, unsigned long pages_off)\n{\n\tunsigned long addr;\n\n\taddr = va_start + (pages_off << PAGE_SHIFT);\n\tBUG_ON(addr_to_vb_idx(addr) != addr_to_vb_idx(va_start));\n\treturn (void *)addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vb->lock"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vb->lock"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "vb",
            "&vbq->free",
            "free_list"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu_var",
          "args": [
            "vmap_block_queue"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "size"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "size == 0"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "size > PAGE_SIZE*VMAP_MAX_ALLOC"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "offset_in_page(size)"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "size"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\n#define VMAP_BBMAP_BITS\t\t\\\n\t\tVMAP_MIN(VMAP_BBMAP_BITS_MAX,\t\\\n\t\tVMAP_MAX(VMAP_BBMAP_BITS_MIN,\t\\\n\t\t\tVMALLOC_PAGES / roundup_pow_of_two(NR_CPUS) / 16))\n#define VMAP_MAX_ALLOC\t\tBITS_PER_LONG\t/* 256K with 4K pages */\n\nstatic DEFINE_PER_CPU(struct vmap_block_queue, vmap_block_queue);\nstatic void *__vmalloc_node(unsigned long size, unsigned long align,\n\t\t\t    gfp_t gfp_mask, pgprot_t prot,\n\t\t\t    int node, const void *caller);\n\nstatic void *vb_alloc(unsigned long size, gfp_t gfp_mask)\n{\n\tstruct vmap_block_queue *vbq;\n\tstruct vmap_block *vb;\n\tvoid *vaddr = NULL;\n\tunsigned int order;\n\n\tBUG_ON(offset_in_page(size));\n\tBUG_ON(size > PAGE_SIZE*VMAP_MAX_ALLOC);\n\tif (WARN_ON(size == 0)) {\n\t\t/*\n\t\t * Allocating 0 bytes isn't what caller wants since\n\t\t * get_order(0) returns funny result. Just warn and terminate\n\t\t * early.\n\t\t */\n\t\treturn NULL;\n\t}\n\torder = get_order(size);\n\n\trcu_read_lock();\n\tvbq = &get_cpu_var(vmap_block_queue);\n\tlist_for_each_entry_rcu(vb, &vbq->free, free_list) {\n\t\tunsigned long pages_off;\n\n\t\tspin_lock(&vb->lock);\n\t\tif (vb->free < (1UL << order)) {\n\t\t\tspin_unlock(&vb->lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpages_off = VMAP_BBMAP_BITS - vb->free;\n\t\tvaddr = vmap_block_vaddr(vb->va->va_start, pages_off);\n\t\tvb->free -= 1UL << order;\n\t\tif (vb->free == 0) {\n\t\t\tspin_lock(&vbq->lock);\n\t\t\tlist_del_rcu(&vb->free_list);\n\t\t\tspin_unlock(&vbq->lock);\n\t\t}\n\n\t\tspin_unlock(&vb->lock);\n\t\tbreak;\n\t}\n\n\tput_cpu_var(vmap_block_queue);\n\trcu_read_unlock();\n\n\t/* Allocate new block if nothing was found */\n\tif (!vaddr)\n\t\tvaddr = new_vmap_block(order, gfp_mask);\n\n\treturn vaddr;\n}"
  },
  {
    "function_name": "purge_fragmented_blocks_allcpus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "953-959",
    "snippet": "static void purge_fragmented_blocks_allcpus(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tpurge_fragmented_blocks(cpu);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void purge_fragmented_blocks_allcpus(void);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void purge_fragmented_blocks_allcpus(void);\n\nstatic void purge_fragmented_blocks_allcpus(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tpurge_fragmented_blocks(cpu);\n}"
  },
  {
    "function_name": "purge_fragmented_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "918-951",
    "snippet": "static void purge_fragmented_blocks(int cpu)\n{\n\tLIST_HEAD(purge);\n\tstruct vmap_block *vb;\n\tstruct vmap_block *n_vb;\n\tstruct vmap_block_queue *vbq = &per_cpu(vmap_block_queue, cpu);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(vb, &vbq->free, free_list) {\n\n\t\tif (!(vb->free + vb->dirty == VMAP_BBMAP_BITS && vb->dirty != VMAP_BBMAP_BITS))\n\t\t\tcontinue;\n\n\t\tspin_lock(&vb->lock);\n\t\tif (vb->free + vb->dirty == VMAP_BBMAP_BITS && vb->dirty != VMAP_BBMAP_BITS) {\n\t\t\tvb->free = 0; /* prevent further allocs after releasing lock */\n\t\t\tvb->dirty = VMAP_BBMAP_BITS; /* prevent purging it again */\n\t\t\tvb->dirty_min = 0;\n\t\t\tvb->dirty_max = VMAP_BBMAP_BITS;\n\t\t\tspin_lock(&vbq->lock);\n\t\t\tlist_del_rcu(&vb->free_list);\n\t\t\tspin_unlock(&vbq->lock);\n\t\t\tspin_unlock(&vb->lock);\n\t\t\tlist_add_tail(&vb->purge, &purge);\n\t\t} else\n\t\t\tspin_unlock(&vb->lock);\n\t}\n\trcu_read_unlock();\n\n\tlist_for_each_entry_safe(vb, n_vb, &purge, purge) {\n\t\tlist_del(&vb->purge);\n\t\tfree_vmap_block(vb);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [
      "#define VMAP_BBMAP_BITS\t\t\\\n\t\tVMAP_MIN(VMAP_BBMAP_BITS_MAX,\t\\\n\t\tVMAP_MAX(VMAP_BBMAP_BITS_MIN,\t\\\n\t\t\tVMALLOC_PAGES / roundup_pow_of_two(NR_CPUS) / 16))"
    ],
    "globals_used": [
      "static DEFINE_PER_CPU(struct vmap_block_queue, vmap_block_queue);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_vmap_block",
          "args": [
            "vb"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "free_vmap_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "903-916",
          "snippet": "static void free_vmap_block(struct vmap_block *vb)\n{\n\tstruct vmap_block *tmp;\n\tunsigned long vb_idx;\n\n\tvb_idx = addr_to_vb_idx(vb->va->va_start);\n\tspin_lock(&vmap_block_tree_lock);\n\ttmp = radix_tree_delete(&vmap_block_tree, vb_idx);\n\tspin_unlock(&vmap_block_tree_lock);\n\tBUG_ON(tmp != vb);\n\n\tfree_vmap_area_noflush(vb->va);\n\tkfree_rcu(vb, rcu_head);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(vmap_block_tree_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic DEFINE_SPINLOCK(vmap_block_tree_lock);\n\nstatic void free_vmap_block(struct vmap_block *vb)\n{\n\tstruct vmap_block *tmp;\n\tunsigned long vb_idx;\n\n\tvb_idx = addr_to_vb_idx(vb->va->va_start);\n\tspin_lock(&vmap_block_tree_lock);\n\ttmp = radix_tree_delete(&vmap_block_tree, vb_idx);\n\tspin_unlock(&vmap_block_tree_lock);\n\tBUG_ON(tmp != vb);\n\n\tfree_vmap_area_noflush(vb->va);\n\tkfree_rcu(vb, rcu_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&vb->purge"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "vb",
            "n_vb",
            "&purge",
            "purge"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vb->lock"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&vb->purge",
            "&purge"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vb->lock"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vbq->lock"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&vb->free_list"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vbq->lock"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vb->lock"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "vb",
            "&vbq->free",
            "free_list"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "vmap_block_queue",
            "cpu"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "purge"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\n#define VMAP_BBMAP_BITS\t\t\\\n\t\tVMAP_MIN(VMAP_BBMAP_BITS_MAX,\t\\\n\t\tVMAP_MAX(VMAP_BBMAP_BITS_MIN,\t\\\n\t\t\tVMALLOC_PAGES / roundup_pow_of_two(NR_CPUS) / 16))\n\nstatic DEFINE_PER_CPU(struct vmap_block_queue, vmap_block_queue);\n\nstatic void purge_fragmented_blocks(int cpu)\n{\n\tLIST_HEAD(purge);\n\tstruct vmap_block *vb;\n\tstruct vmap_block *n_vb;\n\tstruct vmap_block_queue *vbq = &per_cpu(vmap_block_queue, cpu);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(vb, &vbq->free, free_list) {\n\n\t\tif (!(vb->free + vb->dirty == VMAP_BBMAP_BITS && vb->dirty != VMAP_BBMAP_BITS))\n\t\t\tcontinue;\n\n\t\tspin_lock(&vb->lock);\n\t\tif (vb->free + vb->dirty == VMAP_BBMAP_BITS && vb->dirty != VMAP_BBMAP_BITS) {\n\t\t\tvb->free = 0; /* prevent further allocs after releasing lock */\n\t\t\tvb->dirty = VMAP_BBMAP_BITS; /* prevent purging it again */\n\t\t\tvb->dirty_min = 0;\n\t\t\tvb->dirty_max = VMAP_BBMAP_BITS;\n\t\t\tspin_lock(&vbq->lock);\n\t\t\tlist_del_rcu(&vb->free_list);\n\t\t\tspin_unlock(&vbq->lock);\n\t\t\tspin_unlock(&vb->lock);\n\t\t\tlist_add_tail(&vb->purge, &purge);\n\t\t} else\n\t\t\tspin_unlock(&vb->lock);\n\t}\n\trcu_read_unlock();\n\n\tlist_for_each_entry_safe(vb, n_vb, &purge, purge) {\n\t\tlist_del(&vb->purge);\n\t\tfree_vmap_block(vb);\n\t}\n}"
  },
  {
    "function_name": "free_vmap_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "903-916",
    "snippet": "static void free_vmap_block(struct vmap_block *vb)\n{\n\tstruct vmap_block *tmp;\n\tunsigned long vb_idx;\n\n\tvb_idx = addr_to_vb_idx(vb->va->va_start);\n\tspin_lock(&vmap_block_tree_lock);\n\ttmp = radix_tree_delete(&vmap_block_tree, vb_idx);\n\tspin_unlock(&vmap_block_tree_lock);\n\tBUG_ON(tmp != vb);\n\n\tfree_vmap_area_noflush(vb->va);\n\tkfree_rcu(vb, rcu_head);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(vmap_block_tree_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "vb",
            "rcu_head"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_vmap_area_noflush",
          "args": [
            "vb->va"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "free_vmap_area_noflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "718-730",
          "snippet": "static void free_vmap_area_noflush(struct vmap_area *va)\n{\n\tint nr_lazy;\n\n\tnr_lazy = atomic_add_return((va->va_end - va->va_start) >> PAGE_SHIFT,\n\t\t\t\t    &vmap_lazy_nr);\n\n\t/* After this point, we may free va at any time */\n\tllist_add(&va->purge_list, &vmap_purge_list);\n\n\tif (unlikely(nr_lazy > lazy_max_pages()))\n\t\ttry_purge_vmap_area_lazy();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LLIST_HEAD(vmap_purge_list);",
            "static atomic_t vmap_lazy_nr = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic LLIST_HEAD(vmap_purge_list);\nstatic atomic_t vmap_lazy_nr = ATOMIC_INIT(0);\n\nstatic void free_vmap_area_noflush(struct vmap_area *va)\n{\n\tint nr_lazy;\n\n\tnr_lazy = atomic_add_return((va->va_end - va->va_start) >> PAGE_SHIFT,\n\t\t\t\t    &vmap_lazy_nr);\n\n\t/* After this point, we may free va at any time */\n\tllist_add(&va->purge_list, &vmap_purge_list);\n\n\tif (unlikely(nr_lazy > lazy_max_pages()))\n\t\ttry_purge_vmap_area_lazy();\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "tmp != vb"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vmap_block_tree_lock"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_delete",
          "args": [
            "&vmap_block_tree",
            "vb_idx"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vmap_block_tree_lock"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addr_to_vb_idx",
          "args": [
            "vb->va->va_start"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "addr_to_vb_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "821-826",
          "snippet": "static unsigned long addr_to_vb_idx(unsigned long addr)\n{\n\taddr -= VMALLOC_START & ~(VMAP_BLOCK_SIZE-1);\n\taddr /= VMAP_BLOCK_SIZE;\n\treturn addr;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [
            "#define VMAP_BLOCK_SIZE\t\t(VMAP_BBMAP_BITS * PAGE_SIZE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\n#define VMAP_BLOCK_SIZE\t\t(VMAP_BBMAP_BITS * PAGE_SIZE)\n\nstatic unsigned long addr_to_vb_idx(unsigned long addr)\n{\n\taddr -= VMALLOC_START & ~(VMAP_BLOCK_SIZE-1);\n\taddr /= VMAP_BLOCK_SIZE;\n\treturn addr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic DEFINE_SPINLOCK(vmap_block_tree_lock);\n\nstatic void free_vmap_block(struct vmap_block *vb)\n{\n\tstruct vmap_block *tmp;\n\tunsigned long vb_idx;\n\n\tvb_idx = addr_to_vb_idx(vb->va->va_start);\n\tspin_lock(&vmap_block_tree_lock);\n\ttmp = radix_tree_delete(&vmap_block_tree, vb_idx);\n\tspin_unlock(&vmap_block_tree_lock);\n\tBUG_ON(tmp != vb);\n\n\tfree_vmap_area_noflush(vb->va);\n\tkfree_rcu(vb, rcu_head);\n}"
  },
  {
    "function_name": "new_vmap_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "845-901",
    "snippet": "static void *new_vmap_block(unsigned int order, gfp_t gfp_mask)\n{\n\tstruct vmap_block_queue *vbq;\n\tstruct vmap_block *vb;\n\tstruct vmap_area *va;\n\tunsigned long vb_idx;\n\tint node, err;\n\tvoid *vaddr;\n\n\tnode = numa_node_id();\n\n\tvb = kmalloc_node(sizeof(struct vmap_block),\n\t\t\tgfp_mask & GFP_RECLAIM_MASK, node);\n\tif (unlikely(!vb))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tva = alloc_vmap_area(VMAP_BLOCK_SIZE, VMAP_BLOCK_SIZE,\n\t\t\t\t\tVMALLOC_START, VMALLOC_END,\n\t\t\t\t\tnode, gfp_mask);\n\tif (IS_ERR(va)) {\n\t\tkfree(vb);\n\t\treturn ERR_CAST(va);\n\t}\n\n\terr = radix_tree_preload(gfp_mask);\n\tif (unlikely(err)) {\n\t\tkfree(vb);\n\t\tfree_vmap_area(va);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tvaddr = vmap_block_vaddr(va->va_start, 0);\n\tspin_lock_init(&vb->lock);\n\tvb->va = va;\n\t/* At least something should be left free */\n\tBUG_ON(VMAP_BBMAP_BITS <= (1UL << order));\n\tvb->free = VMAP_BBMAP_BITS - (1UL << order);\n\tvb->dirty = 0;\n\tvb->dirty_min = VMAP_BBMAP_BITS;\n\tvb->dirty_max = 0;\n\tINIT_LIST_HEAD(&vb->free_list);\n\n\tvb_idx = addr_to_vb_idx(va->va_start);\n\tspin_lock(&vmap_block_tree_lock);\n\terr = radix_tree_insert(&vmap_block_tree, vb_idx, vb);\n\tspin_unlock(&vmap_block_tree_lock);\n\tBUG_ON(err);\n\tradix_tree_preload_end();\n\n\tvbq = &get_cpu_var(vmap_block_queue);\n\tspin_lock(&vbq->lock);\n\tlist_add_tail_rcu(&vb->free_list, &vbq->free);\n\tspin_unlock(&vbq->lock);\n\tput_cpu_var(vmap_block_queue);\n\n\treturn vaddr;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [
      "#define VMAP_BLOCK_SIZE\t\t(VMAP_BBMAP_BITS * PAGE_SIZE)",
      "#define VMAP_BBMAP_BITS\t\t\\\n\t\tVMAP_MIN(VMAP_BBMAP_BITS_MAX,\t\\\n\t\tVMAP_MAX(VMAP_BBMAP_BITS_MIN,\t\\\n\t\t\tVMALLOC_PAGES / roundup_pow_of_two(NR_CPUS) / 16))"
    ],
    "globals_used": [
      "static DEFINE_PER_CPU(struct vmap_block_queue, vmap_block_queue);",
      "static DEFINE_SPINLOCK(vmap_block_tree_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cpu_var",
          "args": [
            "vmap_block_queue"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vbq->lock"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail_rcu",
          "args": [
            "&vb->free_list",
            "&vbq->free"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vbq->lock"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu_var",
          "args": [
            "vmap_block_queue"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_preload_end",
          "args": [],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vmap_block_tree_lock"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_insert",
          "args": [
            "&vmap_block_tree",
            "vb_idx",
            "vb"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vmap_block_tree_lock"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addr_to_vb_idx",
          "args": [
            "va->va_start"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "addr_to_vb_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "821-826",
          "snippet": "static unsigned long addr_to_vb_idx(unsigned long addr)\n{\n\taddr -= VMALLOC_START & ~(VMAP_BLOCK_SIZE-1);\n\taddr /= VMAP_BLOCK_SIZE;\n\treturn addr;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [
            "#define VMAP_BLOCK_SIZE\t\t(VMAP_BBMAP_BITS * PAGE_SIZE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\n#define VMAP_BLOCK_SIZE\t\t(VMAP_BBMAP_BITS * PAGE_SIZE)\n\nstatic unsigned long addr_to_vb_idx(unsigned long addr)\n{\n\taddr -= VMALLOC_START & ~(VMAP_BLOCK_SIZE-1);\n\taddr /= VMAP_BLOCK_SIZE;\n\treturn addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&vb->free_list"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "VMAP_BBMAP_BITS <= (1UL << order)"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&vb->lock"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmap_block_vaddr",
          "args": [
            "va->va_start",
            "0"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "vmap_block_vaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "828-835",
          "snippet": "static void *vmap_block_vaddr(unsigned long va_start, unsigned long pages_off)\n{\n\tunsigned long addr;\n\n\taddr = va_start + (pages_off << PAGE_SHIFT);\n\tBUG_ON(addr_to_vb_idx(addr) != addr_to_vb_idx(va_start));\n\treturn (void *)addr;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void *vmap_block_vaddr(unsigned long va_start, unsigned long pages_off)\n{\n\tunsigned long addr;\n\n\taddr = va_start + (pages_off << PAGE_SHIFT);\n\tBUG_ON(addr_to_vb_idx(addr) != addr_to_vb_idx(va_start));\n\treturn (void *)addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_vmap_area",
          "args": [
            "va"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "free_vmap_area_noflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "718-730",
          "snippet": "static void free_vmap_area_noflush(struct vmap_area *va)\n{\n\tint nr_lazy;\n\n\tnr_lazy = atomic_add_return((va->va_end - va->va_start) >> PAGE_SHIFT,\n\t\t\t\t    &vmap_lazy_nr);\n\n\t/* After this point, we may free va at any time */\n\tllist_add(&va->purge_list, &vmap_purge_list);\n\n\tif (unlikely(nr_lazy > lazy_max_pages()))\n\t\ttry_purge_vmap_area_lazy();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LLIST_HEAD(vmap_purge_list);",
            "static atomic_t vmap_lazy_nr = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic LLIST_HEAD(vmap_purge_list);\nstatic atomic_t vmap_lazy_nr = ATOMIC_INIT(0);\n\nstatic void free_vmap_area_noflush(struct vmap_area *va)\n{\n\tint nr_lazy;\n\n\tnr_lazy = atomic_add_return((va->va_end - va->va_start) >> PAGE_SHIFT,\n\t\t\t\t    &vmap_lazy_nr);\n\n\t/* After this point, we may free va at any time */\n\tllist_add(&va->purge_list, &vmap_purge_list);\n\n\tif (unlikely(nr_lazy > lazy_max_pages()))\n\t\ttry_purge_vmap_area_lazy();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "vb"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_preload",
          "args": [
            "gfp_mask"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "va"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "va"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_vmap_area",
          "args": [
            "VMAP_BLOCK_SIZE",
            "VMAP_BLOCK_SIZE",
            "VMALLOC_START",
            "VMALLOC_END",
            "node",
            "gfp_mask"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_vmap_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "402-539",
          "snippet": "static struct vmap_area *alloc_vmap_area(unsigned long size,\n\t\t\t\tunsigned long align,\n\t\t\t\tunsigned long vstart, unsigned long vend,\n\t\t\t\tint node, gfp_t gfp_mask)\n{\n\tstruct vmap_area *va;\n\tstruct rb_node *n;\n\tunsigned long addr;\n\tint purged = 0;\n\tstruct vmap_area *first;\n\n\tBUG_ON(!size);\n\tBUG_ON(offset_in_page(size));\n\tBUG_ON(!is_power_of_2(align));\n\n\tmight_sleep();\n\n\tva = kmalloc_node(sizeof(struct vmap_area),\n\t\t\tgfp_mask & GFP_RECLAIM_MASK, node);\n\tif (unlikely(!va))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/*\n\t * Only scan the relevant parts containing pointers to other objects\n\t * to avoid false negatives.\n\t */\n\tkmemleak_scan_area(&va->rb_node, SIZE_MAX, gfp_mask & GFP_RECLAIM_MASK);\n\nretry:\n\tspin_lock(&vmap_area_lock);\n\t/*\n\t * Invalidate cache if we have more permissive parameters.\n\t * cached_hole_size notes the largest hole noticed _below_\n\t * the vmap_area cached in free_vmap_cache: if size fits\n\t * into that hole, we want to scan from vstart to reuse\n\t * the hole instead of allocating above free_vmap_cache.\n\t * Note that __free_vmap_area may update free_vmap_cache\n\t * without updating cached_hole_size or cached_align.\n\t */\n\tif (!free_vmap_cache ||\n\t\t\tsize < cached_hole_size ||\n\t\t\tvstart < cached_vstart ||\n\t\t\talign < cached_align) {\nnocache:\n\t\tcached_hole_size = 0;\n\t\tfree_vmap_cache = NULL;\n\t}\n\t/* record if we encounter less permissive parameters */\n\tcached_vstart = vstart;\n\tcached_align = align;\n\n\t/* find starting point for our search */\n\tif (free_vmap_cache) {\n\t\tfirst = rb_entry(free_vmap_cache, struct vmap_area, rb_node);\n\t\taddr = ALIGN(first->va_end, align);\n\t\tif (addr < vstart)\n\t\t\tgoto nocache;\n\t\tif (addr + size < addr)\n\t\t\tgoto overflow;\n\n\t} else {\n\t\taddr = ALIGN(vstart, align);\n\t\tif (addr + size < addr)\n\t\t\tgoto overflow;\n\n\t\tn = vmap_area_root.rb_node;\n\t\tfirst = NULL;\n\n\t\twhile (n) {\n\t\t\tstruct vmap_area *tmp;\n\t\t\ttmp = rb_entry(n, struct vmap_area, rb_node);\n\t\t\tif (tmp->va_end >= addr) {\n\t\t\t\tfirst = tmp;\n\t\t\t\tif (tmp->va_start <= addr)\n\t\t\t\t\tbreak;\n\t\t\t\tn = n->rb_left;\n\t\t\t} else\n\t\t\t\tn = n->rb_right;\n\t\t}\n\n\t\tif (!first)\n\t\t\tgoto found;\n\t}\n\n\t/* from the starting point, walk areas until a suitable hole is found */\n\twhile (addr + size > first->va_start && addr + size <= vend) {\n\t\tif (addr + cached_hole_size < first->va_start)\n\t\t\tcached_hole_size = first->va_start - addr;\n\t\taddr = ALIGN(first->va_end, align);\n\t\tif (addr + size < addr)\n\t\t\tgoto overflow;\n\n\t\tif (list_is_last(&first->list, &vmap_area_list))\n\t\t\tgoto found;\n\n\t\tfirst = list_next_entry(first, list);\n\t}\n\nfound:\n\tif (addr + size > vend)\n\t\tgoto overflow;\n\n\tva->va_start = addr;\n\tva->va_end = addr + size;\n\tva->flags = 0;\n\t__insert_vmap_area(va);\n\tfree_vmap_cache = &va->rb_node;\n\tspin_unlock(&vmap_area_lock);\n\n\tBUG_ON(!IS_ALIGNED(va->va_start, align));\n\tBUG_ON(va->va_start < vstart);\n\tBUG_ON(va->va_end > vend);\n\n\treturn va;\n\noverflow:\n\tspin_unlock(&vmap_area_lock);\n\tif (!purged) {\n\t\tpurge_vmap_area_lazy();\n\t\tpurged = 1;\n\t\tgoto retry;\n\t}\n\n\tif (gfpflags_allow_blocking(gfp_mask)) {\n\t\tunsigned long freed = 0;\n\t\tblocking_notifier_call_chain(&vmap_notify_list, 0, &freed);\n\t\tif (freed > 0) {\n\t\t\tpurged = 0;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tif (!(gfp_mask & __GFP_NOWARN) && printk_ratelimit())\n\t\tpr_warn(\"vmap allocation for size %lu failed: use vmalloc=<size> to increase size\\n\",\n\t\t\tsize);\n\tkfree(va);\n\treturn ERR_PTR(-EBUSY);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(vmap_area_lock);",
            "static struct rb_root vmap_area_root = RB_ROOT;",
            "static struct rb_node *free_vmap_cache;",
            "static unsigned long cached_hole_size;",
            "static unsigned long cached_vstart;",
            "static unsigned long cached_align;",
            "static void purge_vmap_area_lazy(void);",
            "static BLOCKING_NOTIFIER_HEAD(vmap_notify_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic DEFINE_SPINLOCK(vmap_area_lock);\nstatic struct rb_root vmap_area_root = RB_ROOT;\nstatic struct rb_node *free_vmap_cache;\nstatic unsigned long cached_hole_size;\nstatic unsigned long cached_vstart;\nstatic unsigned long cached_align;\nstatic void purge_vmap_area_lazy(void);\nstatic BLOCKING_NOTIFIER_HEAD(vmap_notify_list);\n\nstatic struct vmap_area *alloc_vmap_area(unsigned long size,\n\t\t\t\tunsigned long align,\n\t\t\t\tunsigned long vstart, unsigned long vend,\n\t\t\t\tint node, gfp_t gfp_mask)\n{\n\tstruct vmap_area *va;\n\tstruct rb_node *n;\n\tunsigned long addr;\n\tint purged = 0;\n\tstruct vmap_area *first;\n\n\tBUG_ON(!size);\n\tBUG_ON(offset_in_page(size));\n\tBUG_ON(!is_power_of_2(align));\n\n\tmight_sleep();\n\n\tva = kmalloc_node(sizeof(struct vmap_area),\n\t\t\tgfp_mask & GFP_RECLAIM_MASK, node);\n\tif (unlikely(!va))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/*\n\t * Only scan the relevant parts containing pointers to other objects\n\t * to avoid false negatives.\n\t */\n\tkmemleak_scan_area(&va->rb_node, SIZE_MAX, gfp_mask & GFP_RECLAIM_MASK);\n\nretry:\n\tspin_lock(&vmap_area_lock);\n\t/*\n\t * Invalidate cache if we have more permissive parameters.\n\t * cached_hole_size notes the largest hole noticed _below_\n\t * the vmap_area cached in free_vmap_cache: if size fits\n\t * into that hole, we want to scan from vstart to reuse\n\t * the hole instead of allocating above free_vmap_cache.\n\t * Note that __free_vmap_area may update free_vmap_cache\n\t * without updating cached_hole_size or cached_align.\n\t */\n\tif (!free_vmap_cache ||\n\t\t\tsize < cached_hole_size ||\n\t\t\tvstart < cached_vstart ||\n\t\t\talign < cached_align) {\nnocache:\n\t\tcached_hole_size = 0;\n\t\tfree_vmap_cache = NULL;\n\t}\n\t/* record if we encounter less permissive parameters */\n\tcached_vstart = vstart;\n\tcached_align = align;\n\n\t/* find starting point for our search */\n\tif (free_vmap_cache) {\n\t\tfirst = rb_entry(free_vmap_cache, struct vmap_area, rb_node);\n\t\taddr = ALIGN(first->va_end, align);\n\t\tif (addr < vstart)\n\t\t\tgoto nocache;\n\t\tif (addr + size < addr)\n\t\t\tgoto overflow;\n\n\t} else {\n\t\taddr = ALIGN(vstart, align);\n\t\tif (addr + size < addr)\n\t\t\tgoto overflow;\n\n\t\tn = vmap_area_root.rb_node;\n\t\tfirst = NULL;\n\n\t\twhile (n) {\n\t\t\tstruct vmap_area *tmp;\n\t\t\ttmp = rb_entry(n, struct vmap_area, rb_node);\n\t\t\tif (tmp->va_end >= addr) {\n\t\t\t\tfirst = tmp;\n\t\t\t\tif (tmp->va_start <= addr)\n\t\t\t\t\tbreak;\n\t\t\t\tn = n->rb_left;\n\t\t\t} else\n\t\t\t\tn = n->rb_right;\n\t\t}\n\n\t\tif (!first)\n\t\t\tgoto found;\n\t}\n\n\t/* from the starting point, walk areas until a suitable hole is found */\n\twhile (addr + size > first->va_start && addr + size <= vend) {\n\t\tif (addr + cached_hole_size < first->va_start)\n\t\t\tcached_hole_size = first->va_start - addr;\n\t\taddr = ALIGN(first->va_end, align);\n\t\tif (addr + size < addr)\n\t\t\tgoto overflow;\n\n\t\tif (list_is_last(&first->list, &vmap_area_list))\n\t\t\tgoto found;\n\n\t\tfirst = list_next_entry(first, list);\n\t}\n\nfound:\n\tif (addr + size > vend)\n\t\tgoto overflow;\n\n\tva->va_start = addr;\n\tva->va_end = addr + size;\n\tva->flags = 0;\n\t__insert_vmap_area(va);\n\tfree_vmap_cache = &va->rb_node;\n\tspin_unlock(&vmap_area_lock);\n\n\tBUG_ON(!IS_ALIGNED(va->va_start, align));\n\tBUG_ON(va->va_start < vstart);\n\tBUG_ON(va->va_end > vend);\n\n\treturn va;\n\noverflow:\n\tspin_unlock(&vmap_area_lock);\n\tif (!purged) {\n\t\tpurge_vmap_area_lazy();\n\t\tpurged = 1;\n\t\tgoto retry;\n\t}\n\n\tif (gfpflags_allow_blocking(gfp_mask)) {\n\t\tunsigned long freed = 0;\n\t\tblocking_notifier_call_chain(&vmap_notify_list, 0, &freed);\n\t\tif (freed > 0) {\n\t\t\tpurged = 0;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tif (!(gfp_mask & __GFP_NOWARN) && printk_ratelimit())\n\t\tpr_warn(\"vmap allocation for size %lu failed: use vmalloc=<size> to increase size\\n\",\n\t\t\tsize);\n\tkfree(va);\n\treturn ERR_PTR(-EBUSY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!vb"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_node",
          "args": [
            "sizeof(struct vmap_block)",
            "gfp_mask & GFP_RECLAIM_MASK",
            "node"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "__kmalloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3689-3692",
          "snippet": "void *__kmalloc_node(size_t size, gfp_t flags, int node)\n{\n\treturn __do_kmalloc_node(size, flags, node, _RET_IP_);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nvoid *__kmalloc_node(size_t size, gfp_t flags, int node)\n{\n\treturn __do_kmalloc_node(size, flags, node, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "numa_node_id",
          "args": [],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\n#define VMAP_BLOCK_SIZE\t\t(VMAP_BBMAP_BITS * PAGE_SIZE)\n#define VMAP_BBMAP_BITS\t\t\\\n\t\tVMAP_MIN(VMAP_BBMAP_BITS_MAX,\t\\\n\t\tVMAP_MAX(VMAP_BBMAP_BITS_MIN,\t\\\n\t\t\tVMALLOC_PAGES / roundup_pow_of_two(NR_CPUS) / 16))\n\nstatic DEFINE_PER_CPU(struct vmap_block_queue, vmap_block_queue);\nstatic DEFINE_SPINLOCK(vmap_block_tree_lock);\n\nstatic void *new_vmap_block(unsigned int order, gfp_t gfp_mask)\n{\n\tstruct vmap_block_queue *vbq;\n\tstruct vmap_block *vb;\n\tstruct vmap_area *va;\n\tunsigned long vb_idx;\n\tint node, err;\n\tvoid *vaddr;\n\n\tnode = numa_node_id();\n\n\tvb = kmalloc_node(sizeof(struct vmap_block),\n\t\t\tgfp_mask & GFP_RECLAIM_MASK, node);\n\tif (unlikely(!vb))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tva = alloc_vmap_area(VMAP_BLOCK_SIZE, VMAP_BLOCK_SIZE,\n\t\t\t\t\tVMALLOC_START, VMALLOC_END,\n\t\t\t\t\tnode, gfp_mask);\n\tif (IS_ERR(va)) {\n\t\tkfree(vb);\n\t\treturn ERR_CAST(va);\n\t}\n\n\terr = radix_tree_preload(gfp_mask);\n\tif (unlikely(err)) {\n\t\tkfree(vb);\n\t\tfree_vmap_area(va);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tvaddr = vmap_block_vaddr(va->va_start, 0);\n\tspin_lock_init(&vb->lock);\n\tvb->va = va;\n\t/* At least something should be left free */\n\tBUG_ON(VMAP_BBMAP_BITS <= (1UL << order));\n\tvb->free = VMAP_BBMAP_BITS - (1UL << order);\n\tvb->dirty = 0;\n\tvb->dirty_min = VMAP_BBMAP_BITS;\n\tvb->dirty_max = 0;\n\tINIT_LIST_HEAD(&vb->free_list);\n\n\tvb_idx = addr_to_vb_idx(va->va_start);\n\tspin_lock(&vmap_block_tree_lock);\n\terr = radix_tree_insert(&vmap_block_tree, vb_idx, vb);\n\tspin_unlock(&vmap_block_tree_lock);\n\tBUG_ON(err);\n\tradix_tree_preload_end();\n\n\tvbq = &get_cpu_var(vmap_block_queue);\n\tspin_lock(&vbq->lock);\n\tlist_add_tail_rcu(&vb->free_list, &vbq->free);\n\tspin_unlock(&vbq->lock);\n\tput_cpu_var(vmap_block_queue);\n\n\treturn vaddr;\n}"
  },
  {
    "function_name": "vmap_block_vaddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "828-835",
    "snippet": "static void *vmap_block_vaddr(unsigned long va_start, unsigned long pages_off)\n{\n\tunsigned long addr;\n\n\taddr = va_start + (pages_off << PAGE_SHIFT);\n\tBUG_ON(addr_to_vb_idx(addr) != addr_to_vb_idx(va_start));\n\treturn (void *)addr;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "addr_to_vb_idx(addr) != addr_to_vb_idx(va_start)"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addr_to_vb_idx",
          "args": [
            "va_start"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "addr_to_vb_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "821-826",
          "snippet": "static unsigned long addr_to_vb_idx(unsigned long addr)\n{\n\taddr -= VMALLOC_START & ~(VMAP_BLOCK_SIZE-1);\n\taddr /= VMAP_BLOCK_SIZE;\n\treturn addr;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [
            "#define VMAP_BLOCK_SIZE\t\t(VMAP_BBMAP_BITS * PAGE_SIZE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\n#define VMAP_BLOCK_SIZE\t\t(VMAP_BBMAP_BITS * PAGE_SIZE)\n\nstatic unsigned long addr_to_vb_idx(unsigned long addr)\n{\n\taddr -= VMALLOC_START & ~(VMAP_BLOCK_SIZE-1);\n\taddr /= VMAP_BLOCK_SIZE;\n\treturn addr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void *vmap_block_vaddr(unsigned long va_start, unsigned long pages_off)\n{\n\tunsigned long addr;\n\n\taddr = va_start + (pages_off << PAGE_SHIFT);\n\tBUG_ON(addr_to_vb_idx(addr) != addr_to_vb_idx(va_start));\n\treturn (void *)addr;\n}"
  },
  {
    "function_name": "addr_to_vb_idx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "821-826",
    "snippet": "static unsigned long addr_to_vb_idx(unsigned long addr)\n{\n\taddr -= VMALLOC_START & ~(VMAP_BLOCK_SIZE-1);\n\taddr /= VMAP_BLOCK_SIZE;\n\treturn addr;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [
      "#define VMAP_BLOCK_SIZE\t\t(VMAP_BBMAP_BITS * PAGE_SIZE)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\n#define VMAP_BLOCK_SIZE\t\t(VMAP_BBMAP_BITS * PAGE_SIZE)\n\nstatic unsigned long addr_to_vb_idx(unsigned long addr)\n{\n\taddr -= VMALLOC_START & ~(VMAP_BLOCK_SIZE-1);\n\taddr /= VMAP_BLOCK_SIZE;\n\treturn addr;\n}"
  },
  {
    "function_name": "find_vmap_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "745-754",
    "snippet": "static struct vmap_area *find_vmap_area(unsigned long addr)\n{\n\tstruct vmap_area *va;\n\n\tspin_lock(&vmap_area_lock);\n\tva = __find_vmap_area(addr);\n\tspin_unlock(&vmap_area_lock);\n\n\treturn va;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(vmap_area_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vmap_area_lock"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__find_vmap_area",
          "args": [
            "addr"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "__find_vmap_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "343-360",
          "snippet": "static struct vmap_area *__find_vmap_area(unsigned long addr)\n{\n\tstruct rb_node *n = vmap_area_root.rb_node;\n\n\twhile (n) {\n\t\tstruct vmap_area *va;\n\n\t\tva = rb_entry(n, struct vmap_area, rb_node);\n\t\tif (addr < va->va_start)\n\t\t\tn = n->rb_left;\n\t\telse if (addr >= va->va_end)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn va;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root vmap_area_root = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic struct rb_root vmap_area_root = RB_ROOT;\n\nstatic struct vmap_area *__find_vmap_area(unsigned long addr)\n{\n\tstruct rb_node *n = vmap_area_root.rb_node;\n\n\twhile (n) {\n\t\tstruct vmap_area *va;\n\n\t\tva = rb_entry(n, struct vmap_area, rb_node);\n\t\tif (addr < va->va_start)\n\t\t\tn = n->rb_left;\n\t\telse if (addr >= va->va_end)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn va;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vmap_area_lock"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic DEFINE_SPINLOCK(vmap_area_lock);\n\nstatic struct vmap_area *find_vmap_area(unsigned long addr)\n{\n\tstruct vmap_area *va;\n\n\tspin_lock(&vmap_area_lock);\n\tva = __find_vmap_area(addr);\n\tspin_unlock(&vmap_area_lock);\n\n\treturn va;\n}"
  },
  {
    "function_name": "free_unmap_vmap_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "735-743",
    "snippet": "static void free_unmap_vmap_area(struct vmap_area *va)\n{\n\tflush_cache_vunmap(va->va_start, va->va_end);\n\tunmap_vmap_area(va);\n\tif (debug_pagealloc_enabled())\n\t\tflush_tlb_kernel_range(va->va_start, va->va_end);\n\n\tfree_vmap_area_noflush(va);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_vmap_area_noflush",
          "args": [
            "va"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "free_vmap_area_noflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "718-730",
          "snippet": "static void free_vmap_area_noflush(struct vmap_area *va)\n{\n\tint nr_lazy;\n\n\tnr_lazy = atomic_add_return((va->va_end - va->va_start) >> PAGE_SHIFT,\n\t\t\t\t    &vmap_lazy_nr);\n\n\t/* After this point, we may free va at any time */\n\tllist_add(&va->purge_list, &vmap_purge_list);\n\n\tif (unlikely(nr_lazy > lazy_max_pages()))\n\t\ttry_purge_vmap_area_lazy();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LLIST_HEAD(vmap_purge_list);",
            "static atomic_t vmap_lazy_nr = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic LLIST_HEAD(vmap_purge_list);\nstatic atomic_t vmap_lazy_nr = ATOMIC_INIT(0);\n\nstatic void free_vmap_area_noflush(struct vmap_area *va)\n{\n\tint nr_lazy;\n\n\tnr_lazy = atomic_add_return((va->va_end - va->va_start) >> PAGE_SHIFT,\n\t\t\t\t    &vmap_lazy_nr);\n\n\t/* After this point, we may free va at any time */\n\tllist_add(&va->purge_list, &vmap_purge_list);\n\n\tif (unlikely(nr_lazy > lazy_max_pages()))\n\t\ttry_purge_vmap_area_lazy();\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_tlb_kernel_range",
          "args": [
            "va->va_start",
            "va->va_end"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_pagealloc_enabled",
          "args": [],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_vmap_area",
          "args": [
            "va"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "free_unmap_vmap_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "735-743",
          "snippet": "static void free_unmap_vmap_area(struct vmap_area *va)\n{\n\tflush_cache_vunmap(va->va_start, va->va_end);\n\tunmap_vmap_area(va);\n\tif (debug_pagealloc_enabled())\n\t\tflush_tlb_kernel_range(va->va_start, va->va_end);\n\n\tfree_vmap_area_noflush(va);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "flush_cache_vunmap",
          "args": [
            "va->va_start",
            "va->va_end"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void free_unmap_vmap_area(struct vmap_area *va)\n{\n\tflush_cache_vunmap(va->va_start, va->va_end);\n\tunmap_vmap_area(va);\n\tif (debug_pagealloc_enabled())\n\t\tflush_tlb_kernel_range(va->va_start, va->va_end);\n\n\tfree_vmap_area_noflush(va);\n}"
  },
  {
    "function_name": "free_vmap_area_noflush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "718-730",
    "snippet": "static void free_vmap_area_noflush(struct vmap_area *va)\n{\n\tint nr_lazy;\n\n\tnr_lazy = atomic_add_return((va->va_end - va->va_start) >> PAGE_SHIFT,\n\t\t\t\t    &vmap_lazy_nr);\n\n\t/* After this point, we may free va at any time */\n\tllist_add(&va->purge_list, &vmap_purge_list);\n\n\tif (unlikely(nr_lazy > lazy_max_pages()))\n\t\ttry_purge_vmap_area_lazy();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LLIST_HEAD(vmap_purge_list);",
      "static atomic_t vmap_lazy_nr = ATOMIC_INIT(0);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "try_purge_vmap_area_lazy",
          "args": [],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "try_purge_vmap_area_lazy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "694-700",
          "snippet": "static void try_purge_vmap_area_lazy(void)\n{\n\tif (mutex_trylock(&vmap_purge_lock)) {\n\t\t__purge_vmap_area_lazy(ULONG_MAX, 0);\n\t\tmutex_unlock(&vmap_purge_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(vmap_purge_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic DEFINE_MUTEX(vmap_purge_lock);\n\nstatic void try_purge_vmap_area_lazy(void)\n{\n\tif (mutex_trylock(&vmap_purge_lock)) {\n\t\t__purge_vmap_area_lazy(ULONG_MAX, 0);\n\t\tmutex_unlock(&vmap_purge_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "nr_lazy > lazy_max_pages()"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lazy_max_pages",
          "args": [],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "lazy_max_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "622-629",
          "snippet": "static unsigned long lazy_max_pages(void)\n{\n\tunsigned int log;\n\n\tlog = fls(num_online_cpus());\n\n\treturn log * (32UL * 1024 * 1024 / PAGE_SIZE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic unsigned long lazy_max_pages(void)\n{\n\tunsigned int log;\n\n\tlog = fls(num_online_cpus());\n\n\treturn log * (32UL * 1024 * 1024 / PAGE_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "llist_add",
          "args": [
            "&va->purge_list",
            "&vmap_purge_list"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add_return",
          "args": [
            "(va->va_end - va->va_start) >> PAGE_SHIFT",
            "&vmap_lazy_nr"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic LLIST_HEAD(vmap_purge_list);\nstatic atomic_t vmap_lazy_nr = ATOMIC_INIT(0);\n\nstatic void free_vmap_area_noflush(struct vmap_area *va)\n{\n\tint nr_lazy;\n\n\tnr_lazy = atomic_add_return((va->va_end - va->va_start) >> PAGE_SHIFT,\n\t\t\t\t    &vmap_lazy_nr);\n\n\t/* After this point, we may free va at any time */\n\tllist_add(&va->purge_list, &vmap_purge_list);\n\n\tif (unlikely(nr_lazy > lazy_max_pages()))\n\t\ttry_purge_vmap_area_lazy();\n}"
  },
  {
    "function_name": "purge_vmap_area_lazy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "705-711",
    "snippet": "static void purge_vmap_area_lazy(void)\n{\n\tmutex_lock(&vmap_purge_lock);\n\tpurge_fragmented_blocks_allcpus();\n\t__purge_vmap_area_lazy(ULONG_MAX, 0);\n\tmutex_unlock(&vmap_purge_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void purge_vmap_area_lazy(void);",
      "static DEFINE_MUTEX(vmap_purge_lock);",
      "static void purge_fragmented_blocks_allcpus(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&vmap_purge_lock"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__purge_vmap_area_lazy",
          "args": [
            "ULONG_MAX",
            "0"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "__purge_vmap_area_lazy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "655-688",
          "snippet": "static bool __purge_vmap_area_lazy(unsigned long start, unsigned long end)\n{\n\tstruct llist_node *valist;\n\tstruct vmap_area *va;\n\tstruct vmap_area *n_va;\n\tbool do_free = false;\n\n\tlockdep_assert_held(&vmap_purge_lock);\n\n\tvalist = llist_del_all(&vmap_purge_list);\n\tllist_for_each_entry(va, valist, purge_list) {\n\t\tif (va->va_start < start)\n\t\t\tstart = va->va_start;\n\t\tif (va->va_end > end)\n\t\t\tend = va->va_end;\n\t\tdo_free = true;\n\t}\n\n\tif (!do_free)\n\t\treturn false;\n\n\tflush_tlb_kernel_range(start, end);\n\n\tspin_lock(&vmap_area_lock);\n\tllist_for_each_entry_safe(va, n_va, valist, purge_list) {\n\t\tint nr = (va->va_end - va->va_start) >> PAGE_SHIFT;\n\n\t\t__free_vmap_area(va);\n\t\tatomic_sub(nr, &vmap_lazy_nr);\n\t\tcond_resched_lock(&vmap_area_lock);\n\t}\n\tspin_unlock(&vmap_area_lock);\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(vmap_area_lock);",
            "static LLIST_HEAD(vmap_purge_list);",
            "static atomic_t vmap_lazy_nr = ATOMIC_INIT(0);",
            "static DEFINE_MUTEX(vmap_purge_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic DEFINE_SPINLOCK(vmap_area_lock);\nstatic LLIST_HEAD(vmap_purge_list);\nstatic atomic_t vmap_lazy_nr = ATOMIC_INIT(0);\nstatic DEFINE_MUTEX(vmap_purge_lock);\n\nstatic bool __purge_vmap_area_lazy(unsigned long start, unsigned long end)\n{\n\tstruct llist_node *valist;\n\tstruct vmap_area *va;\n\tstruct vmap_area *n_va;\n\tbool do_free = false;\n\n\tlockdep_assert_held(&vmap_purge_lock);\n\n\tvalist = llist_del_all(&vmap_purge_list);\n\tllist_for_each_entry(va, valist, purge_list) {\n\t\tif (va->va_start < start)\n\t\t\tstart = va->va_start;\n\t\tif (va->va_end > end)\n\t\t\tend = va->va_end;\n\t\tdo_free = true;\n\t}\n\n\tif (!do_free)\n\t\treturn false;\n\n\tflush_tlb_kernel_range(start, end);\n\n\tspin_lock(&vmap_area_lock);\n\tllist_for_each_entry_safe(va, n_va, valist, purge_list) {\n\t\tint nr = (va->va_end - va->va_start) >> PAGE_SHIFT;\n\n\t\t__free_vmap_area(va);\n\t\tatomic_sub(nr, &vmap_lazy_nr);\n\t\tcond_resched_lock(&vmap_area_lock);\n\t}\n\tspin_unlock(&vmap_area_lock);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "purge_fragmented_blocks_allcpus",
          "args": [],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "purge_fragmented_blocks_allcpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "953-959",
          "snippet": "static void purge_fragmented_blocks_allcpus(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tpurge_fragmented_blocks(cpu);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void purge_fragmented_blocks_allcpus(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void purge_fragmented_blocks_allcpus(void);\n\nstatic void purge_fragmented_blocks_allcpus(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tpurge_fragmented_blocks(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&vmap_purge_lock"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void purge_vmap_area_lazy(void);\nstatic DEFINE_MUTEX(vmap_purge_lock);\nstatic void purge_fragmented_blocks_allcpus(void);\n\nstatic void purge_vmap_area_lazy(void)\n{\n\tmutex_lock(&vmap_purge_lock);\n\tpurge_fragmented_blocks_allcpus();\n\t__purge_vmap_area_lazy(ULONG_MAX, 0);\n\tmutex_unlock(&vmap_purge_lock);\n}"
  },
  {
    "function_name": "try_purge_vmap_area_lazy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "694-700",
    "snippet": "static void try_purge_vmap_area_lazy(void)\n{\n\tif (mutex_trylock(&vmap_purge_lock)) {\n\t\t__purge_vmap_area_lazy(ULONG_MAX, 0);\n\t\tmutex_unlock(&vmap_purge_lock);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(vmap_purge_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&vmap_purge_lock"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__purge_vmap_area_lazy",
          "args": [
            "ULONG_MAX",
            "0"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "__purge_vmap_area_lazy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "655-688",
          "snippet": "static bool __purge_vmap_area_lazy(unsigned long start, unsigned long end)\n{\n\tstruct llist_node *valist;\n\tstruct vmap_area *va;\n\tstruct vmap_area *n_va;\n\tbool do_free = false;\n\n\tlockdep_assert_held(&vmap_purge_lock);\n\n\tvalist = llist_del_all(&vmap_purge_list);\n\tllist_for_each_entry(va, valist, purge_list) {\n\t\tif (va->va_start < start)\n\t\t\tstart = va->va_start;\n\t\tif (va->va_end > end)\n\t\t\tend = va->va_end;\n\t\tdo_free = true;\n\t}\n\n\tif (!do_free)\n\t\treturn false;\n\n\tflush_tlb_kernel_range(start, end);\n\n\tspin_lock(&vmap_area_lock);\n\tllist_for_each_entry_safe(va, n_va, valist, purge_list) {\n\t\tint nr = (va->va_end - va->va_start) >> PAGE_SHIFT;\n\n\t\t__free_vmap_area(va);\n\t\tatomic_sub(nr, &vmap_lazy_nr);\n\t\tcond_resched_lock(&vmap_area_lock);\n\t}\n\tspin_unlock(&vmap_area_lock);\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(vmap_area_lock);",
            "static LLIST_HEAD(vmap_purge_list);",
            "static atomic_t vmap_lazy_nr = ATOMIC_INIT(0);",
            "static DEFINE_MUTEX(vmap_purge_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic DEFINE_SPINLOCK(vmap_area_lock);\nstatic LLIST_HEAD(vmap_purge_list);\nstatic atomic_t vmap_lazy_nr = ATOMIC_INIT(0);\nstatic DEFINE_MUTEX(vmap_purge_lock);\n\nstatic bool __purge_vmap_area_lazy(unsigned long start, unsigned long end)\n{\n\tstruct llist_node *valist;\n\tstruct vmap_area *va;\n\tstruct vmap_area *n_va;\n\tbool do_free = false;\n\n\tlockdep_assert_held(&vmap_purge_lock);\n\n\tvalist = llist_del_all(&vmap_purge_list);\n\tllist_for_each_entry(va, valist, purge_list) {\n\t\tif (va->va_start < start)\n\t\t\tstart = va->va_start;\n\t\tif (va->va_end > end)\n\t\t\tend = va->va_end;\n\t\tdo_free = true;\n\t}\n\n\tif (!do_free)\n\t\treturn false;\n\n\tflush_tlb_kernel_range(start, end);\n\n\tspin_lock(&vmap_area_lock);\n\tllist_for_each_entry_safe(va, n_va, valist, purge_list) {\n\t\tint nr = (va->va_end - va->va_start) >> PAGE_SHIFT;\n\n\t\t__free_vmap_area(va);\n\t\tatomic_sub(nr, &vmap_lazy_nr);\n\t\tcond_resched_lock(&vmap_area_lock);\n\t}\n\tspin_unlock(&vmap_area_lock);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_trylock",
          "args": [
            "&vmap_purge_lock"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic DEFINE_MUTEX(vmap_purge_lock);\n\nstatic void try_purge_vmap_area_lazy(void)\n{\n\tif (mutex_trylock(&vmap_purge_lock)) {\n\t\t__purge_vmap_area_lazy(ULONG_MAX, 0);\n\t\tmutex_unlock(&vmap_purge_lock);\n\t}\n}"
  },
  {
    "function_name": "__purge_vmap_area_lazy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "655-688",
    "snippet": "static bool __purge_vmap_area_lazy(unsigned long start, unsigned long end)\n{\n\tstruct llist_node *valist;\n\tstruct vmap_area *va;\n\tstruct vmap_area *n_va;\n\tbool do_free = false;\n\n\tlockdep_assert_held(&vmap_purge_lock);\n\n\tvalist = llist_del_all(&vmap_purge_list);\n\tllist_for_each_entry(va, valist, purge_list) {\n\t\tif (va->va_start < start)\n\t\t\tstart = va->va_start;\n\t\tif (va->va_end > end)\n\t\t\tend = va->va_end;\n\t\tdo_free = true;\n\t}\n\n\tif (!do_free)\n\t\treturn false;\n\n\tflush_tlb_kernel_range(start, end);\n\n\tspin_lock(&vmap_area_lock);\n\tllist_for_each_entry_safe(va, n_va, valist, purge_list) {\n\t\tint nr = (va->va_end - va->va_start) >> PAGE_SHIFT;\n\n\t\t__free_vmap_area(va);\n\t\tatomic_sub(nr, &vmap_lazy_nr);\n\t\tcond_resched_lock(&vmap_area_lock);\n\t}\n\tspin_unlock(&vmap_area_lock);\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(vmap_area_lock);",
      "static LLIST_HEAD(vmap_purge_list);",
      "static atomic_t vmap_lazy_nr = ATOMIC_INIT(0);",
      "static DEFINE_MUTEX(vmap_purge_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vmap_area_lock"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched_lock",
          "args": [
            "&vmap_area_lock"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_sub",
          "args": [
            "nr",
            "&vmap_lazy_nr"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_vmap_area",
          "args": [
            "va"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "__free_vmap_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "553-586",
          "snippet": "static void __free_vmap_area(struct vmap_area *va)\n{\n\tBUG_ON(RB_EMPTY_NODE(&va->rb_node));\n\n\tif (free_vmap_cache) {\n\t\tif (va->va_end < cached_vstart) {\n\t\t\tfree_vmap_cache = NULL;\n\t\t} else {\n\t\t\tstruct vmap_area *cache;\n\t\t\tcache = rb_entry(free_vmap_cache, struct vmap_area, rb_node);\n\t\t\tif (va->va_start <= cache->va_start) {\n\t\t\t\tfree_vmap_cache = rb_prev(&va->rb_node);\n\t\t\t\t/*\n\t\t\t\t * We don't try to update cached_hole_size or\n\t\t\t\t * cached_align, but it won't go very wrong.\n\t\t\t\t */\n\t\t\t}\n\t\t}\n\t}\n\trb_erase(&va->rb_node, &vmap_area_root);\n\tRB_CLEAR_NODE(&va->rb_node);\n\tlist_del_rcu(&va->list);\n\n\t/*\n\t * Track the highest possible candidate for pcpu area\n\t * allocation.  Areas outside of vmalloc area can be returned\n\t * here too, consider only end addresses which fall inside\n\t * vmalloc area proper.\n\t */\n\tif (va->va_end > VMALLOC_START && va->va_end <= VMALLOC_END)\n\t\tvmap_area_pcpu_hole = max(vmap_area_pcpu_hole, va->va_end);\n\n\tkfree_rcu(va, rcu_head);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root vmap_area_root = RB_ROOT;",
            "static struct rb_node *free_vmap_cache;",
            "static unsigned long cached_hole_size;",
            "static unsigned long cached_vstart;",
            "static unsigned long cached_align;",
            "static unsigned long vmap_area_pcpu_hole;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic struct rb_root vmap_area_root = RB_ROOT;\nstatic struct rb_node *free_vmap_cache;\nstatic unsigned long cached_hole_size;\nstatic unsigned long cached_vstart;\nstatic unsigned long cached_align;\nstatic unsigned long vmap_area_pcpu_hole;\n\nstatic void __free_vmap_area(struct vmap_area *va)\n{\n\tBUG_ON(RB_EMPTY_NODE(&va->rb_node));\n\n\tif (free_vmap_cache) {\n\t\tif (va->va_end < cached_vstart) {\n\t\t\tfree_vmap_cache = NULL;\n\t\t} else {\n\t\t\tstruct vmap_area *cache;\n\t\t\tcache = rb_entry(free_vmap_cache, struct vmap_area, rb_node);\n\t\t\tif (va->va_start <= cache->va_start) {\n\t\t\t\tfree_vmap_cache = rb_prev(&va->rb_node);\n\t\t\t\t/*\n\t\t\t\t * We don't try to update cached_hole_size or\n\t\t\t\t * cached_align, but it won't go very wrong.\n\t\t\t\t */\n\t\t\t}\n\t\t}\n\t}\n\trb_erase(&va->rb_node, &vmap_area_root);\n\tRB_CLEAR_NODE(&va->rb_node);\n\tlist_del_rcu(&va->list);\n\n\t/*\n\t * Track the highest possible candidate for pcpu area\n\t * allocation.  Areas outside of vmalloc area can be returned\n\t * here too, consider only end addresses which fall inside\n\t * vmalloc area proper.\n\t */\n\tif (va->va_end > VMALLOC_START && va->va_end <= VMALLOC_END)\n\t\tvmap_area_pcpu_hole = max(vmap_area_pcpu_hole, va->va_end);\n\n\tkfree_rcu(va, rcu_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "llist_for_each_entry_safe",
          "args": [
            "va",
            "n_va",
            "valist",
            "purge_list"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vmap_area_lock"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_tlb_kernel_range",
          "args": [
            "start",
            "end"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llist_for_each_entry",
          "args": [
            "va",
            "valist",
            "purge_list"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llist_del_all",
          "args": [
            "&vmap_purge_list"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&vmap_purge_lock"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic DEFINE_SPINLOCK(vmap_area_lock);\nstatic LLIST_HEAD(vmap_purge_list);\nstatic atomic_t vmap_lazy_nr = ATOMIC_INIT(0);\nstatic DEFINE_MUTEX(vmap_purge_lock);\n\nstatic bool __purge_vmap_area_lazy(unsigned long start, unsigned long end)\n{\n\tstruct llist_node *valist;\n\tstruct vmap_area *va;\n\tstruct vmap_area *n_va;\n\tbool do_free = false;\n\n\tlockdep_assert_held(&vmap_purge_lock);\n\n\tvalist = llist_del_all(&vmap_purge_list);\n\tllist_for_each_entry(va, valist, purge_list) {\n\t\tif (va->va_start < start)\n\t\t\tstart = va->va_start;\n\t\tif (va->va_end > end)\n\t\t\tend = va->va_end;\n\t\tdo_free = true;\n\t}\n\n\tif (!do_free)\n\t\treturn false;\n\n\tflush_tlb_kernel_range(start, end);\n\n\tspin_lock(&vmap_area_lock);\n\tllist_for_each_entry_safe(va, n_va, valist, purge_list) {\n\t\tint nr = (va->va_end - va->va_start) >> PAGE_SHIFT;\n\n\t\t__free_vmap_area(va);\n\t\tatomic_sub(nr, &vmap_lazy_nr);\n\t\tcond_resched_lock(&vmap_area_lock);\n\t}\n\tspin_unlock(&vmap_area_lock);\n\treturn true;\n}"
  },
  {
    "function_name": "set_iounmap_nonlazy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "647-650",
    "snippet": "void set_iounmap_nonlazy(void)\n{\n\tatomic_set(&vmap_lazy_nr, lazy_max_pages()+1);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t vmap_lazy_nr = ATOMIC_INIT(0);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&vmap_lazy_nr",
            "lazy_max_pages()+1"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lazy_max_pages",
          "args": [],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "lazy_max_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "622-629",
          "snippet": "static unsigned long lazy_max_pages(void)\n{\n\tunsigned int log;\n\n\tlog = fls(num_online_cpus());\n\n\treturn log * (32UL * 1024 * 1024 / PAGE_SIZE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic unsigned long lazy_max_pages(void)\n{\n\tunsigned int log;\n\n\tlog = fls(num_online_cpus());\n\n\treturn log * (32UL * 1024 * 1024 / PAGE_SIZE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic atomic_t vmap_lazy_nr = ATOMIC_INIT(0);\n\nvoid set_iounmap_nonlazy(void)\n{\n\tatomic_set(&vmap_lazy_nr, lazy_max_pages()+1);\n}"
  },
  {
    "function_name": "lazy_max_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "622-629",
    "snippet": "static unsigned long lazy_max_pages(void)\n{\n\tunsigned int log;\n\n\tlog = fls(num_online_cpus());\n\n\treturn log * (32UL * 1024 * 1024 / PAGE_SIZE);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fls",
          "args": [
            "num_online_cpus()"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic unsigned long lazy_max_pages(void)\n{\n\tunsigned int log;\n\n\tlog = fls(num_online_cpus());\n\n\treturn log * (32UL * 1024 * 1024 / PAGE_SIZE);\n}"
  },
  {
    "function_name": "unmap_vmap_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "601-604",
    "snippet": "static void unmap_vmap_area(struct vmap_area *va)\n{\n\tvunmap_page_range(va->va_start, va->va_end);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vunmap_page_range",
          "args": [
            "va->va_start",
            "va->va_end"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "vunmap_page_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "119-132",
          "snippet": "static void vunmap_page_range(unsigned long addr, unsigned long end)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\n\tBUG_ON(addr >= end);\n\tpgd = pgd_offset_k(addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(pgd))\n\t\t\tcontinue;\n\t\tvunmap_p4d_range(pgd, addr, next);\n\t} while (pgd++, addr = next, addr != end);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void vunmap_page_range(unsigned long addr, unsigned long end)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\n\tBUG_ON(addr >= end);\n\tpgd = pgd_offset_k(addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(pgd))\n\t\t\tcontinue;\n\t\tvunmap_p4d_range(pgd, addr, next);\n\t} while (pgd++, addr = next, addr != end);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void unmap_vmap_area(struct vmap_area *va)\n{\n\tvunmap_page_range(va->va_start, va->va_end);\n}"
  },
  {
    "function_name": "free_vmap_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "591-596",
    "snippet": "static void free_vmap_area(struct vmap_area *va)\n{\n\tspin_lock(&vmap_area_lock);\n\t__free_vmap_area(va);\n\tspin_unlock(&vmap_area_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(vmap_area_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vmap_area_lock"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_vmap_area",
          "args": [
            "va"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "__free_vmap_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "553-586",
          "snippet": "static void __free_vmap_area(struct vmap_area *va)\n{\n\tBUG_ON(RB_EMPTY_NODE(&va->rb_node));\n\n\tif (free_vmap_cache) {\n\t\tif (va->va_end < cached_vstart) {\n\t\t\tfree_vmap_cache = NULL;\n\t\t} else {\n\t\t\tstruct vmap_area *cache;\n\t\t\tcache = rb_entry(free_vmap_cache, struct vmap_area, rb_node);\n\t\t\tif (va->va_start <= cache->va_start) {\n\t\t\t\tfree_vmap_cache = rb_prev(&va->rb_node);\n\t\t\t\t/*\n\t\t\t\t * We don't try to update cached_hole_size or\n\t\t\t\t * cached_align, but it won't go very wrong.\n\t\t\t\t */\n\t\t\t}\n\t\t}\n\t}\n\trb_erase(&va->rb_node, &vmap_area_root);\n\tRB_CLEAR_NODE(&va->rb_node);\n\tlist_del_rcu(&va->list);\n\n\t/*\n\t * Track the highest possible candidate for pcpu area\n\t * allocation.  Areas outside of vmalloc area can be returned\n\t * here too, consider only end addresses which fall inside\n\t * vmalloc area proper.\n\t */\n\tif (va->va_end > VMALLOC_START && va->va_end <= VMALLOC_END)\n\t\tvmap_area_pcpu_hole = max(vmap_area_pcpu_hole, va->va_end);\n\n\tkfree_rcu(va, rcu_head);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root vmap_area_root = RB_ROOT;",
            "static struct rb_node *free_vmap_cache;",
            "static unsigned long cached_hole_size;",
            "static unsigned long cached_vstart;",
            "static unsigned long cached_align;",
            "static unsigned long vmap_area_pcpu_hole;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic struct rb_root vmap_area_root = RB_ROOT;\nstatic struct rb_node *free_vmap_cache;\nstatic unsigned long cached_hole_size;\nstatic unsigned long cached_vstart;\nstatic unsigned long cached_align;\nstatic unsigned long vmap_area_pcpu_hole;\n\nstatic void __free_vmap_area(struct vmap_area *va)\n{\n\tBUG_ON(RB_EMPTY_NODE(&va->rb_node));\n\n\tif (free_vmap_cache) {\n\t\tif (va->va_end < cached_vstart) {\n\t\t\tfree_vmap_cache = NULL;\n\t\t} else {\n\t\t\tstruct vmap_area *cache;\n\t\t\tcache = rb_entry(free_vmap_cache, struct vmap_area, rb_node);\n\t\t\tif (va->va_start <= cache->va_start) {\n\t\t\t\tfree_vmap_cache = rb_prev(&va->rb_node);\n\t\t\t\t/*\n\t\t\t\t * We don't try to update cached_hole_size or\n\t\t\t\t * cached_align, but it won't go very wrong.\n\t\t\t\t */\n\t\t\t}\n\t\t}\n\t}\n\trb_erase(&va->rb_node, &vmap_area_root);\n\tRB_CLEAR_NODE(&va->rb_node);\n\tlist_del_rcu(&va->list);\n\n\t/*\n\t * Track the highest possible candidate for pcpu area\n\t * allocation.  Areas outside of vmalloc area can be returned\n\t * here too, consider only end addresses which fall inside\n\t * vmalloc area proper.\n\t */\n\tif (va->va_end > VMALLOC_START && va->va_end <= VMALLOC_END)\n\t\tvmap_area_pcpu_hole = max(vmap_area_pcpu_hole, va->va_end);\n\n\tkfree_rcu(va, rcu_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vmap_area_lock"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic DEFINE_SPINLOCK(vmap_area_lock);\n\nstatic void free_vmap_area(struct vmap_area *va)\n{\n\tspin_lock(&vmap_area_lock);\n\t__free_vmap_area(va);\n\tspin_unlock(&vmap_area_lock);\n}"
  },
  {
    "function_name": "__free_vmap_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "553-586",
    "snippet": "static void __free_vmap_area(struct vmap_area *va)\n{\n\tBUG_ON(RB_EMPTY_NODE(&va->rb_node));\n\n\tif (free_vmap_cache) {\n\t\tif (va->va_end < cached_vstart) {\n\t\t\tfree_vmap_cache = NULL;\n\t\t} else {\n\t\t\tstruct vmap_area *cache;\n\t\t\tcache = rb_entry(free_vmap_cache, struct vmap_area, rb_node);\n\t\t\tif (va->va_start <= cache->va_start) {\n\t\t\t\tfree_vmap_cache = rb_prev(&va->rb_node);\n\t\t\t\t/*\n\t\t\t\t * We don't try to update cached_hole_size or\n\t\t\t\t * cached_align, but it won't go very wrong.\n\t\t\t\t */\n\t\t\t}\n\t\t}\n\t}\n\trb_erase(&va->rb_node, &vmap_area_root);\n\tRB_CLEAR_NODE(&va->rb_node);\n\tlist_del_rcu(&va->list);\n\n\t/*\n\t * Track the highest possible candidate for pcpu area\n\t * allocation.  Areas outside of vmalloc area can be returned\n\t * here too, consider only end addresses which fall inside\n\t * vmalloc area proper.\n\t */\n\tif (va->va_end > VMALLOC_START && va->va_end <= VMALLOC_END)\n\t\tvmap_area_pcpu_hole = max(vmap_area_pcpu_hole, va->va_end);\n\n\tkfree_rcu(va, rcu_head);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rb_root vmap_area_root = RB_ROOT;",
      "static struct rb_node *free_vmap_cache;",
      "static unsigned long cached_hole_size;",
      "static unsigned long cached_vstart;",
      "static unsigned long cached_align;",
      "static unsigned long vmap_area_pcpu_hole;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "va",
            "rcu_head"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "vmap_area_pcpu_hole",
            "va->va_end"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&va->list"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_CLEAR_NODE",
          "args": [
            "&va->rb_node"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&va->rb_node",
            "&vmap_area_root"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "vma_rb_erase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "479-489",
          "snippet": "static __always_inline void vma_rb_erase(struct vm_area_struct *vma,\n\t\t\t\t\t struct rb_root *root)\n{\n\t/*\n\t * All rb_subtree_gap values must be consistent prior to erase,\n\t * with the possible exception of the vma being erased.\n\t */\n\tvalidate_mm_rb(root, vma);\n\n\t__vma_rb_erase(vma, root);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic __always_inline void vma_rb_erase(struct vm_area_struct *vma,\n\t\t\t\t\t struct rb_root *root)\n{\n\t/*\n\t * All rb_subtree_gap values must be consistent prior to erase,\n\t * with the possible exception of the vma being erased.\n\t */\n\tvalidate_mm_rb(root, vma);\n\n\t__vma_rb_erase(vma, root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_prev",
          "args": [
            "&va->rb_node"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "free_vmap_cache",
            "structvmap_area",
            "rb_node"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "RB_EMPTY_NODE(&va->rb_node)"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_NODE",
          "args": [
            "&va->rb_node"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic struct rb_root vmap_area_root = RB_ROOT;\nstatic struct rb_node *free_vmap_cache;\nstatic unsigned long cached_hole_size;\nstatic unsigned long cached_vstart;\nstatic unsigned long cached_align;\nstatic unsigned long vmap_area_pcpu_hole;\n\nstatic void __free_vmap_area(struct vmap_area *va)\n{\n\tBUG_ON(RB_EMPTY_NODE(&va->rb_node));\n\n\tif (free_vmap_cache) {\n\t\tif (va->va_end < cached_vstart) {\n\t\t\tfree_vmap_cache = NULL;\n\t\t} else {\n\t\t\tstruct vmap_area *cache;\n\t\t\tcache = rb_entry(free_vmap_cache, struct vmap_area, rb_node);\n\t\t\tif (va->va_start <= cache->va_start) {\n\t\t\t\tfree_vmap_cache = rb_prev(&va->rb_node);\n\t\t\t\t/*\n\t\t\t\t * We don't try to update cached_hole_size or\n\t\t\t\t * cached_align, but it won't go very wrong.\n\t\t\t\t */\n\t\t\t}\n\t\t}\n\t}\n\trb_erase(&va->rb_node, &vmap_area_root);\n\tRB_CLEAR_NODE(&va->rb_node);\n\tlist_del_rcu(&va->list);\n\n\t/*\n\t * Track the highest possible candidate for pcpu area\n\t * allocation.  Areas outside of vmalloc area can be returned\n\t * here too, consider only end addresses which fall inside\n\t * vmalloc area proper.\n\t */\n\tif (va->va_end > VMALLOC_START && va->va_end <= VMALLOC_END)\n\t\tvmap_area_pcpu_hole = max(vmap_area_pcpu_hole, va->va_end);\n\n\tkfree_rcu(va, rcu_head);\n}"
  },
  {
    "function_name": "unregister_vmap_purge_notifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "547-550",
    "snippet": "int unregister_vmap_purge_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&vmap_notify_list, nb);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static BLOCKING_NOTIFIER_HEAD(vmap_notify_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "blocking_notifier_chain_unregister",
          "args": [
            "&vmap_notify_list",
            "nb"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic BLOCKING_NOTIFIER_HEAD(vmap_notify_list);\n\nint unregister_vmap_purge_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&vmap_notify_list, nb);\n}"
  },
  {
    "function_name": "register_vmap_purge_notifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "541-544",
    "snippet": "int register_vmap_purge_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&vmap_notify_list, nb);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static BLOCKING_NOTIFIER_HEAD(vmap_notify_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "blocking_notifier_chain_register",
          "args": [
            "&vmap_notify_list",
            "nb"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic BLOCKING_NOTIFIER_HEAD(vmap_notify_list);\n\nint register_vmap_purge_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&vmap_notify_list, nb);\n}"
  },
  {
    "function_name": "alloc_vmap_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "402-539",
    "snippet": "static struct vmap_area *alloc_vmap_area(unsigned long size,\n\t\t\t\tunsigned long align,\n\t\t\t\tunsigned long vstart, unsigned long vend,\n\t\t\t\tint node, gfp_t gfp_mask)\n{\n\tstruct vmap_area *va;\n\tstruct rb_node *n;\n\tunsigned long addr;\n\tint purged = 0;\n\tstruct vmap_area *first;\n\n\tBUG_ON(!size);\n\tBUG_ON(offset_in_page(size));\n\tBUG_ON(!is_power_of_2(align));\n\n\tmight_sleep();\n\n\tva = kmalloc_node(sizeof(struct vmap_area),\n\t\t\tgfp_mask & GFP_RECLAIM_MASK, node);\n\tif (unlikely(!va))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/*\n\t * Only scan the relevant parts containing pointers to other objects\n\t * to avoid false negatives.\n\t */\n\tkmemleak_scan_area(&va->rb_node, SIZE_MAX, gfp_mask & GFP_RECLAIM_MASK);\n\nretry:\n\tspin_lock(&vmap_area_lock);\n\t/*\n\t * Invalidate cache if we have more permissive parameters.\n\t * cached_hole_size notes the largest hole noticed _below_\n\t * the vmap_area cached in free_vmap_cache: if size fits\n\t * into that hole, we want to scan from vstart to reuse\n\t * the hole instead of allocating above free_vmap_cache.\n\t * Note that __free_vmap_area may update free_vmap_cache\n\t * without updating cached_hole_size or cached_align.\n\t */\n\tif (!free_vmap_cache ||\n\t\t\tsize < cached_hole_size ||\n\t\t\tvstart < cached_vstart ||\n\t\t\talign < cached_align) {\nnocache:\n\t\tcached_hole_size = 0;\n\t\tfree_vmap_cache = NULL;\n\t}\n\t/* record if we encounter less permissive parameters */\n\tcached_vstart = vstart;\n\tcached_align = align;\n\n\t/* find starting point for our search */\n\tif (free_vmap_cache) {\n\t\tfirst = rb_entry(free_vmap_cache, struct vmap_area, rb_node);\n\t\taddr = ALIGN(first->va_end, align);\n\t\tif (addr < vstart)\n\t\t\tgoto nocache;\n\t\tif (addr + size < addr)\n\t\t\tgoto overflow;\n\n\t} else {\n\t\taddr = ALIGN(vstart, align);\n\t\tif (addr + size < addr)\n\t\t\tgoto overflow;\n\n\t\tn = vmap_area_root.rb_node;\n\t\tfirst = NULL;\n\n\t\twhile (n) {\n\t\t\tstruct vmap_area *tmp;\n\t\t\ttmp = rb_entry(n, struct vmap_area, rb_node);\n\t\t\tif (tmp->va_end >= addr) {\n\t\t\t\tfirst = tmp;\n\t\t\t\tif (tmp->va_start <= addr)\n\t\t\t\t\tbreak;\n\t\t\t\tn = n->rb_left;\n\t\t\t} else\n\t\t\t\tn = n->rb_right;\n\t\t}\n\n\t\tif (!first)\n\t\t\tgoto found;\n\t}\n\n\t/* from the starting point, walk areas until a suitable hole is found */\n\twhile (addr + size > first->va_start && addr + size <= vend) {\n\t\tif (addr + cached_hole_size < first->va_start)\n\t\t\tcached_hole_size = first->va_start - addr;\n\t\taddr = ALIGN(first->va_end, align);\n\t\tif (addr + size < addr)\n\t\t\tgoto overflow;\n\n\t\tif (list_is_last(&first->list, &vmap_area_list))\n\t\t\tgoto found;\n\n\t\tfirst = list_next_entry(first, list);\n\t}\n\nfound:\n\tif (addr + size > vend)\n\t\tgoto overflow;\n\n\tva->va_start = addr;\n\tva->va_end = addr + size;\n\tva->flags = 0;\n\t__insert_vmap_area(va);\n\tfree_vmap_cache = &va->rb_node;\n\tspin_unlock(&vmap_area_lock);\n\n\tBUG_ON(!IS_ALIGNED(va->va_start, align));\n\tBUG_ON(va->va_start < vstart);\n\tBUG_ON(va->va_end > vend);\n\n\treturn va;\n\noverflow:\n\tspin_unlock(&vmap_area_lock);\n\tif (!purged) {\n\t\tpurge_vmap_area_lazy();\n\t\tpurged = 1;\n\t\tgoto retry;\n\t}\n\n\tif (gfpflags_allow_blocking(gfp_mask)) {\n\t\tunsigned long freed = 0;\n\t\tblocking_notifier_call_chain(&vmap_notify_list, 0, &freed);\n\t\tif (freed > 0) {\n\t\t\tpurged = 0;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tif (!(gfp_mask & __GFP_NOWARN) && printk_ratelimit())\n\t\tpr_warn(\"vmap allocation for size %lu failed: use vmalloc=<size> to increase size\\n\",\n\t\t\tsize);\n\tkfree(va);\n\treturn ERR_PTR(-EBUSY);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(vmap_area_lock);",
      "static struct rb_root vmap_area_root = RB_ROOT;",
      "static struct rb_node *free_vmap_cache;",
      "static unsigned long cached_hole_size;",
      "static unsigned long cached_vstart;",
      "static unsigned long cached_align;",
      "static void purge_vmap_area_lazy(void);",
      "static BLOCKING_NOTIFIER_HEAD(vmap_notify_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EBUSY"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "va"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"vmap allocation for size %lu failed: use vmalloc=<size> to increase size\\n\"",
            "size"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_ratelimit",
          "args": [],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blocking_notifier_call_chain",
          "args": [
            "&vmap_notify_list",
            "0",
            "&freed"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfpflags_allow_blocking",
          "args": [
            "gfp_mask"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "purge_vmap_area_lazy",
          "args": [],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "purge_vmap_area_lazy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "705-711",
          "snippet": "static void purge_vmap_area_lazy(void)\n{\n\tmutex_lock(&vmap_purge_lock);\n\tpurge_fragmented_blocks_allcpus();\n\t__purge_vmap_area_lazy(ULONG_MAX, 0);\n\tmutex_unlock(&vmap_purge_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void purge_vmap_area_lazy(void);",
            "static DEFINE_MUTEX(vmap_purge_lock);",
            "static void purge_fragmented_blocks_allcpus(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void purge_vmap_area_lazy(void);\nstatic DEFINE_MUTEX(vmap_purge_lock);\nstatic void purge_fragmented_blocks_allcpus(void);\n\nstatic void purge_vmap_area_lazy(void)\n{\n\tmutex_lock(&vmap_purge_lock);\n\tpurge_fragmented_blocks_allcpus();\n\t__purge_vmap_area_lazy(ULONG_MAX, 0);\n\tmutex_unlock(&vmap_purge_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vmap_area_lock"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "va->va_end > vend"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "va->va_start < vstart"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!IS_ALIGNED(va->va_start, align)"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "va->va_start",
            "align"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vmap_area_lock"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__insert_vmap_area",
          "args": [
            "va"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "__insert_vmap_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "362-392",
          "snippet": "static void __insert_vmap_area(struct vmap_area *va)\n{\n\tstruct rb_node **p = &vmap_area_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct rb_node *tmp;\n\n\twhile (*p) {\n\t\tstruct vmap_area *tmp_va;\n\n\t\tparent = *p;\n\t\ttmp_va = rb_entry(parent, struct vmap_area, rb_node);\n\t\tif (va->va_start < tmp_va->va_end)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (va->va_end > tmp_va->va_start)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tBUG();\n\t}\n\n\trb_link_node(&va->rb_node, parent, p);\n\trb_insert_color(&va->rb_node, &vmap_area_root);\n\n\t/* address-sort this list */\n\ttmp = rb_prev(&va->rb_node);\n\tif (tmp) {\n\t\tstruct vmap_area *prev;\n\t\tprev = rb_entry(tmp, struct vmap_area, rb_node);\n\t\tlist_add_rcu(&va->list, &prev->list);\n\t} else\n\t\tlist_add_rcu(&va->list, &vmap_area_list);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root vmap_area_root = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic struct rb_root vmap_area_root = RB_ROOT;\n\nstatic void __insert_vmap_area(struct vmap_area *va)\n{\n\tstruct rb_node **p = &vmap_area_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct rb_node *tmp;\n\n\twhile (*p) {\n\t\tstruct vmap_area *tmp_va;\n\n\t\tparent = *p;\n\t\ttmp_va = rb_entry(parent, struct vmap_area, rb_node);\n\t\tif (va->va_start < tmp_va->va_end)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (va->va_end > tmp_va->va_start)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tBUG();\n\t}\n\n\trb_link_node(&va->rb_node, parent, p);\n\trb_insert_color(&va->rb_node, &vmap_area_root);\n\n\t/* address-sort this list */\n\ttmp = rb_prev(&va->rb_node);\n\tif (tmp) {\n\t\tstruct vmap_area *prev;\n\t\tprev = rb_entry(tmp, struct vmap_area, rb_node);\n\t\tlist_add_rcu(&va->list, &prev->list);\n\t} else\n\t\tlist_add_rcu(&va->list, &vmap_area_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_next_entry",
          "args": [
            "first",
            "list"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_is_last",
          "args": [
            "&first->list",
            "&vmap_area_list"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "first->va_end",
            "align"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structvmap_area",
            "rb_node"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "vstart",
            "align"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "first->va_end",
            "align"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "free_vmap_cache",
            "structvmap_area",
            "rb_node"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vmap_area_lock"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemleak_scan_area",
          "args": [
            "&va->rb_node",
            "SIZE_MAX",
            "gfp_mask & GFP_RECLAIM_MASK"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_scan_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1180-1188",
          "snippet": "void __ref kmemleak_scan_area(const void *ptr, size_t size, gfp_t gfp)\n{\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (kmemleak_enabled && ptr && size && !IS_ERR(ptr))\n\t\tadd_scan_area((unsigned long)ptr, size, gfp);\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_SCAN_AREA, ptr, size, 0);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kmemleak_enabled;",
            "static int kmemleak_early_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_enabled;\nstatic int kmemleak_early_log = 1;\n\nvoid __ref kmemleak_scan_area(const void *ptr, size_t size, gfp_t gfp)\n{\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (kmemleak_enabled && ptr && size && !IS_ERR(ptr))\n\t\tadd_scan_area((unsigned long)ptr, size, gfp);\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_SCAN_AREA, ptr, size, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!va"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_node",
          "args": [
            "sizeof(struct vmap_area)",
            "gfp_mask & GFP_RECLAIM_MASK",
            "node"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "__kmalloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3689-3692",
          "snippet": "void *__kmalloc_node(size_t size, gfp_t flags, int node)\n{\n\treturn __do_kmalloc_node(size, flags, node, _RET_IP_);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nvoid *__kmalloc_node(size_t size, gfp_t flags, int node)\n{\n\treturn __do_kmalloc_node(size, flags, node, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!is_power_of_2(align)"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_power_of_2",
          "args": [
            "align"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "offset_in_page(size)"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "size"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!size"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic DEFINE_SPINLOCK(vmap_area_lock);\nstatic struct rb_root vmap_area_root = RB_ROOT;\nstatic struct rb_node *free_vmap_cache;\nstatic unsigned long cached_hole_size;\nstatic unsigned long cached_vstart;\nstatic unsigned long cached_align;\nstatic void purge_vmap_area_lazy(void);\nstatic BLOCKING_NOTIFIER_HEAD(vmap_notify_list);\n\nstatic struct vmap_area *alloc_vmap_area(unsigned long size,\n\t\t\t\tunsigned long align,\n\t\t\t\tunsigned long vstart, unsigned long vend,\n\t\t\t\tint node, gfp_t gfp_mask)\n{\n\tstruct vmap_area *va;\n\tstruct rb_node *n;\n\tunsigned long addr;\n\tint purged = 0;\n\tstruct vmap_area *first;\n\n\tBUG_ON(!size);\n\tBUG_ON(offset_in_page(size));\n\tBUG_ON(!is_power_of_2(align));\n\n\tmight_sleep();\n\n\tva = kmalloc_node(sizeof(struct vmap_area),\n\t\t\tgfp_mask & GFP_RECLAIM_MASK, node);\n\tif (unlikely(!va))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/*\n\t * Only scan the relevant parts containing pointers to other objects\n\t * to avoid false negatives.\n\t */\n\tkmemleak_scan_area(&va->rb_node, SIZE_MAX, gfp_mask & GFP_RECLAIM_MASK);\n\nretry:\n\tspin_lock(&vmap_area_lock);\n\t/*\n\t * Invalidate cache if we have more permissive parameters.\n\t * cached_hole_size notes the largest hole noticed _below_\n\t * the vmap_area cached in free_vmap_cache: if size fits\n\t * into that hole, we want to scan from vstart to reuse\n\t * the hole instead of allocating above free_vmap_cache.\n\t * Note that __free_vmap_area may update free_vmap_cache\n\t * without updating cached_hole_size or cached_align.\n\t */\n\tif (!free_vmap_cache ||\n\t\t\tsize < cached_hole_size ||\n\t\t\tvstart < cached_vstart ||\n\t\t\talign < cached_align) {\nnocache:\n\t\tcached_hole_size = 0;\n\t\tfree_vmap_cache = NULL;\n\t}\n\t/* record if we encounter less permissive parameters */\n\tcached_vstart = vstart;\n\tcached_align = align;\n\n\t/* find starting point for our search */\n\tif (free_vmap_cache) {\n\t\tfirst = rb_entry(free_vmap_cache, struct vmap_area, rb_node);\n\t\taddr = ALIGN(first->va_end, align);\n\t\tif (addr < vstart)\n\t\t\tgoto nocache;\n\t\tif (addr + size < addr)\n\t\t\tgoto overflow;\n\n\t} else {\n\t\taddr = ALIGN(vstart, align);\n\t\tif (addr + size < addr)\n\t\t\tgoto overflow;\n\n\t\tn = vmap_area_root.rb_node;\n\t\tfirst = NULL;\n\n\t\twhile (n) {\n\t\t\tstruct vmap_area *tmp;\n\t\t\ttmp = rb_entry(n, struct vmap_area, rb_node);\n\t\t\tif (tmp->va_end >= addr) {\n\t\t\t\tfirst = tmp;\n\t\t\t\tif (tmp->va_start <= addr)\n\t\t\t\t\tbreak;\n\t\t\t\tn = n->rb_left;\n\t\t\t} else\n\t\t\t\tn = n->rb_right;\n\t\t}\n\n\t\tif (!first)\n\t\t\tgoto found;\n\t}\n\n\t/* from the starting point, walk areas until a suitable hole is found */\n\twhile (addr + size > first->va_start && addr + size <= vend) {\n\t\tif (addr + cached_hole_size < first->va_start)\n\t\t\tcached_hole_size = first->va_start - addr;\n\t\taddr = ALIGN(first->va_end, align);\n\t\tif (addr + size < addr)\n\t\t\tgoto overflow;\n\n\t\tif (list_is_last(&first->list, &vmap_area_list))\n\t\t\tgoto found;\n\n\t\tfirst = list_next_entry(first, list);\n\t}\n\nfound:\n\tif (addr + size > vend)\n\t\tgoto overflow;\n\n\tva->va_start = addr;\n\tva->va_end = addr + size;\n\tva->flags = 0;\n\t__insert_vmap_area(va);\n\tfree_vmap_cache = &va->rb_node;\n\tspin_unlock(&vmap_area_lock);\n\n\tBUG_ON(!IS_ALIGNED(va->va_start, align));\n\tBUG_ON(va->va_start < vstart);\n\tBUG_ON(va->va_end > vend);\n\n\treturn va;\n\noverflow:\n\tspin_unlock(&vmap_area_lock);\n\tif (!purged) {\n\t\tpurge_vmap_area_lazy();\n\t\tpurged = 1;\n\t\tgoto retry;\n\t}\n\n\tif (gfpflags_allow_blocking(gfp_mask)) {\n\t\tunsigned long freed = 0;\n\t\tblocking_notifier_call_chain(&vmap_notify_list, 0, &freed);\n\t\tif (freed > 0) {\n\t\t\tpurged = 0;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tif (!(gfp_mask & __GFP_NOWARN) && printk_ratelimit())\n\t\tpr_warn(\"vmap allocation for size %lu failed: use vmalloc=<size> to increase size\\n\",\n\t\t\tsize);\n\tkfree(va);\n\treturn ERR_PTR(-EBUSY);\n}"
  },
  {
    "function_name": "__insert_vmap_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "362-392",
    "snippet": "static void __insert_vmap_area(struct vmap_area *va)\n{\n\tstruct rb_node **p = &vmap_area_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct rb_node *tmp;\n\n\twhile (*p) {\n\t\tstruct vmap_area *tmp_va;\n\n\t\tparent = *p;\n\t\ttmp_va = rb_entry(parent, struct vmap_area, rb_node);\n\t\tif (va->va_start < tmp_va->va_end)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (va->va_end > tmp_va->va_start)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tBUG();\n\t}\n\n\trb_link_node(&va->rb_node, parent, p);\n\trb_insert_color(&va->rb_node, &vmap_area_root);\n\n\t/* address-sort this list */\n\ttmp = rb_prev(&va->rb_node);\n\tif (tmp) {\n\t\tstruct vmap_area *prev;\n\t\tprev = rb_entry(tmp, struct vmap_area, rb_node);\n\t\tlist_add_rcu(&va->list, &prev->list);\n\t} else\n\t\tlist_add_rcu(&va->list, &vmap_area_list);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rb_root vmap_area_root = RB_ROOT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&va->list",
            "&vmap_area_list"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&va->list",
            "&prev->list"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "tmp",
            "structvmap_area",
            "rb_node"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_prev",
          "args": [
            "&va->rb_node"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&va->rb_node",
            "&vmap_area_root"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&va->rb_node",
            "parent",
            "p"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structvmap_area",
            "rb_node"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic struct rb_root vmap_area_root = RB_ROOT;\n\nstatic void __insert_vmap_area(struct vmap_area *va)\n{\n\tstruct rb_node **p = &vmap_area_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct rb_node *tmp;\n\n\twhile (*p) {\n\t\tstruct vmap_area *tmp_va;\n\n\t\tparent = *p;\n\t\ttmp_va = rb_entry(parent, struct vmap_area, rb_node);\n\t\tif (va->va_start < tmp_va->va_end)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (va->va_end > tmp_va->va_start)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tBUG();\n\t}\n\n\trb_link_node(&va->rb_node, parent, p);\n\trb_insert_color(&va->rb_node, &vmap_area_root);\n\n\t/* address-sort this list */\n\ttmp = rb_prev(&va->rb_node);\n\tif (tmp) {\n\t\tstruct vmap_area *prev;\n\t\tprev = rb_entry(tmp, struct vmap_area, rb_node);\n\t\tlist_add_rcu(&va->list, &prev->list);\n\t} else\n\t\tlist_add_rcu(&va->list, &vmap_area_list);\n}"
  },
  {
    "function_name": "__find_vmap_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "343-360",
    "snippet": "static struct vmap_area *__find_vmap_area(unsigned long addr)\n{\n\tstruct rb_node *n = vmap_area_root.rb_node;\n\n\twhile (n) {\n\t\tstruct vmap_area *va;\n\n\t\tva = rb_entry(n, struct vmap_area, rb_node);\n\t\tif (addr < va->va_start)\n\t\t\tn = n->rb_left;\n\t\telse if (addr >= va->va_end)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn va;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rb_root vmap_area_root = RB_ROOT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structvmap_area",
            "rb_node"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic struct rb_root vmap_area_root = RB_ROOT;\n\nstatic struct vmap_area *__find_vmap_area(unsigned long addr)\n{\n\tstruct rb_node *n = vmap_area_root.rb_node;\n\n\twhile (n) {\n\t\tstruct vmap_area *va;\n\n\t\tva = rb_entry(n, struct vmap_area, rb_node);\n\t\tif (addr < va->va_start)\n\t\t\tn = n->rb_left;\n\t\telse if (addr >= va->va_end)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn va;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "vmalloc_to_pfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "317-320",
    "snippet": "unsigned long vmalloc_to_pfn(const void *vmalloc_addr)\n{\n\treturn page_to_pfn(vmalloc_to_page(vmalloc_addr));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "vmalloc_to_page(vmalloc_addr)"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc_to_page",
          "args": [
            "vmalloc_addr"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "vmalloc_to_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "266-311",
          "snippet": "struct page *vmalloc_to_page(const void *vmalloc_addr)\n{\n\tunsigned long addr = (unsigned long) vmalloc_addr;\n\tstruct page *page = NULL;\n\tpgd_t *pgd = pgd_offset_k(addr);\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *ptep, pte;\n\n\t/*\n\t * XXX we might need to change this if we add VIRTUAL_BUG_ON for\n\t * architectures that do not vmalloc module space\n\t */\n\tVIRTUAL_BUG_ON(!is_vmalloc_or_module_addr(vmalloc_addr));\n\n\tif (pgd_none(*pgd))\n\t\treturn NULL;\n\tp4d = p4d_offset(pgd, addr);\n\tif (p4d_none(*p4d))\n\t\treturn NULL;\n\tpud = pud_offset(p4d, addr);\n\n\t/*\n\t * Don't dereference bad PUD or PMD (below) entries. This will also\n\t * identify huge mappings, which we may encounter on architectures\n\t * that define CONFIG_HAVE_ARCH_HUGE_VMAP=y. Such regions will be\n\t * identified as vmalloc addresses by is_vmalloc_addr(), but are\n\t * not [unambiguously] associated with a struct page, so there is\n\t * no correct value to return for them.\n\t */\n\tWARN_ON_ONCE(pud_bad(*pud));\n\tif (pud_none(*pud) || pud_bad(*pud))\n\t\treturn NULL;\n\tpmd = pmd_offset(pud, addr);\n\tWARN_ON_ONCE(pmd_bad(*pmd));\n\tif (pmd_none(*pmd) || pmd_bad(*pmd))\n\t\treturn NULL;\n\n\tptep = pte_offset_map(pmd, addr);\n\tpte = *ptep;\n\tif (pte_present(pte))\n\t\tpage = pte_page(pte);\n\tpte_unmap(ptep);\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstruct page *vmalloc_to_page(const void *vmalloc_addr)\n{\n\tunsigned long addr = (unsigned long) vmalloc_addr;\n\tstruct page *page = NULL;\n\tpgd_t *pgd = pgd_offset_k(addr);\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *ptep, pte;\n\n\t/*\n\t * XXX we might need to change this if we add VIRTUAL_BUG_ON for\n\t * architectures that do not vmalloc module space\n\t */\n\tVIRTUAL_BUG_ON(!is_vmalloc_or_module_addr(vmalloc_addr));\n\n\tif (pgd_none(*pgd))\n\t\treturn NULL;\n\tp4d = p4d_offset(pgd, addr);\n\tif (p4d_none(*p4d))\n\t\treturn NULL;\n\tpud = pud_offset(p4d, addr);\n\n\t/*\n\t * Don't dereference bad PUD or PMD (below) entries. This will also\n\t * identify huge mappings, which we may encounter on architectures\n\t * that define CONFIG_HAVE_ARCH_HUGE_VMAP=y. Such regions will be\n\t * identified as vmalloc addresses by is_vmalloc_addr(), but are\n\t * not [unambiguously] associated with a struct page, so there is\n\t * no correct value to return for them.\n\t */\n\tWARN_ON_ONCE(pud_bad(*pud));\n\tif (pud_none(*pud) || pud_bad(*pud))\n\t\treturn NULL;\n\tpmd = pmd_offset(pud, addr);\n\tWARN_ON_ONCE(pmd_bad(*pmd));\n\tif (pmd_none(*pmd) || pmd_bad(*pmd))\n\t\treturn NULL;\n\n\tptep = pte_offset_map(pmd, addr);\n\tpte = *ptep;\n\tif (pte_present(pte))\n\t\tpage = pte_page(pte);\n\tpte_unmap(ptep);\n\treturn page;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nunsigned long vmalloc_to_pfn(const void *vmalloc_addr)\n{\n\treturn page_to_pfn(vmalloc_to_page(vmalloc_addr));\n}"
  },
  {
    "function_name": "vmalloc_to_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "266-311",
    "snippet": "struct page *vmalloc_to_page(const void *vmalloc_addr)\n{\n\tunsigned long addr = (unsigned long) vmalloc_addr;\n\tstruct page *page = NULL;\n\tpgd_t *pgd = pgd_offset_k(addr);\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *ptep, pte;\n\n\t/*\n\t * XXX we might need to change this if we add VIRTUAL_BUG_ON for\n\t * architectures that do not vmalloc module space\n\t */\n\tVIRTUAL_BUG_ON(!is_vmalloc_or_module_addr(vmalloc_addr));\n\n\tif (pgd_none(*pgd))\n\t\treturn NULL;\n\tp4d = p4d_offset(pgd, addr);\n\tif (p4d_none(*p4d))\n\t\treturn NULL;\n\tpud = pud_offset(p4d, addr);\n\n\t/*\n\t * Don't dereference bad PUD or PMD (below) entries. This will also\n\t * identify huge mappings, which we may encounter on architectures\n\t * that define CONFIG_HAVE_ARCH_HUGE_VMAP=y. Such regions will be\n\t * identified as vmalloc addresses by is_vmalloc_addr(), but are\n\t * not [unambiguously] associated with a struct page, so there is\n\t * no correct value to return for them.\n\t */\n\tWARN_ON_ONCE(pud_bad(*pud));\n\tif (pud_none(*pud) || pud_bad(*pud))\n\t\treturn NULL;\n\tpmd = pmd_offset(pud, addr);\n\tWARN_ON_ONCE(pmd_bad(*pmd));\n\tif (pmd_none(*pmd) || pmd_bad(*pmd))\n\t\treturn NULL;\n\n\tptep = pte_offset_map(pmd, addr);\n\tpte = *ptep;\n\tif (pte_present(pte))\n\t\tpage = pte_page(pte);\n\tpte_unmap(ptep);\n\treturn page;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_unmap",
          "args": [
            "ptep"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_page",
          "args": [
            "pte"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "release_pte_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "504-509",
          "snippet": "static void release_pte_page(struct page *page)\n{\n\tdec_node_page_state(page, NR_ISOLATED_ANON + page_is_file_cache(page));\n\tunlock_page(page);\n\tputback_lru_page(page);\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void release_pte_page(struct page *page)\n{\n\tdec_node_page_state(page, NR_ISOLATED_ANON + page_is_file_cache(page));\n\tunlock_page(page);\n\tputback_lru_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "pte"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_offset_map",
          "args": [
            "pmd",
            "addr"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_bad",
          "args": [
            "*pmd"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_none",
          "args": [
            "*pmd"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "pmd_bad(*pmd)"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_bad",
          "args": [
            "*pmd"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_offset",
          "args": [
            "pud",
            "addr"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_bad",
          "args": [
            "*pud"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_none",
          "args": [
            "*pud"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "pud_bad(*pud)"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_bad",
          "args": [
            "*pud"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_offset",
          "args": [
            "p4d",
            "addr"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_none",
          "args": [
            "*p4d"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_offset",
          "args": [
            "pgd",
            "addr"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_none",
          "args": [
            "*pgd"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIRTUAL_BUG_ON",
          "args": [
            "!is_vmalloc_or_module_addr(vmalloc_addr)"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vmalloc_or_module_addr",
          "args": [
            "vmalloc_addr"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "is_vmalloc_or_module_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "248-261",
          "snippet": "int is_vmalloc_or_module_addr(const void *x)\n{\n\t/*\n\t * ARM, x86-64 and sparc64 put modules in a special place,\n\t * and fall back on vmalloc() if that fails. Others\n\t * just put it in the vmalloc space.\n\t */\n#if defined(CONFIG_MODULES) && defined(MODULES_VADDR)\n\tunsigned long addr = (unsigned long)x;\n\tif (addr >= MODULES_VADDR && addr < MODULES_END)\n\t\treturn 1;\n#endif\n\treturn is_vmalloc_addr(x);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nint is_vmalloc_or_module_addr(const void *x)\n{\n\t/*\n\t * ARM, x86-64 and sparc64 put modules in a special place,\n\t * and fall back on vmalloc() if that fails. Others\n\t * just put it in the vmalloc space.\n\t */\n#if defined(CONFIG_MODULES) && defined(MODULES_VADDR)\n\tunsigned long addr = (unsigned long)x;\n\tif (addr >= MODULES_VADDR && addr < MODULES_END)\n\t\treturn 1;\n#endif\n\treturn is_vmalloc_addr(x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgd_offset_k",
          "args": [
            "addr"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstruct page *vmalloc_to_page(const void *vmalloc_addr)\n{\n\tunsigned long addr = (unsigned long) vmalloc_addr;\n\tstruct page *page = NULL;\n\tpgd_t *pgd = pgd_offset_k(addr);\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *ptep, pte;\n\n\t/*\n\t * XXX we might need to change this if we add VIRTUAL_BUG_ON for\n\t * architectures that do not vmalloc module space\n\t */\n\tVIRTUAL_BUG_ON(!is_vmalloc_or_module_addr(vmalloc_addr));\n\n\tif (pgd_none(*pgd))\n\t\treturn NULL;\n\tp4d = p4d_offset(pgd, addr);\n\tif (p4d_none(*p4d))\n\t\treturn NULL;\n\tpud = pud_offset(p4d, addr);\n\n\t/*\n\t * Don't dereference bad PUD or PMD (below) entries. This will also\n\t * identify huge mappings, which we may encounter on architectures\n\t * that define CONFIG_HAVE_ARCH_HUGE_VMAP=y. Such regions will be\n\t * identified as vmalloc addresses by is_vmalloc_addr(), but are\n\t * not [unambiguously] associated with a struct page, so there is\n\t * no correct value to return for them.\n\t */\n\tWARN_ON_ONCE(pud_bad(*pud));\n\tif (pud_none(*pud) || pud_bad(*pud))\n\t\treturn NULL;\n\tpmd = pmd_offset(pud, addr);\n\tWARN_ON_ONCE(pmd_bad(*pmd));\n\tif (pmd_none(*pmd) || pmd_bad(*pmd))\n\t\treturn NULL;\n\n\tptep = pte_offset_map(pmd, addr);\n\tpte = *ptep;\n\tif (pte_present(pte))\n\t\tpage = pte_page(pte);\n\tpte_unmap(ptep);\n\treturn page;\n}"
  },
  {
    "function_name": "is_vmalloc_or_module_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "248-261",
    "snippet": "int is_vmalloc_or_module_addr(const void *x)\n{\n\t/*\n\t * ARM, x86-64 and sparc64 put modules in a special place,\n\t * and fall back on vmalloc() if that fails. Others\n\t * just put it in the vmalloc space.\n\t */\n#if defined(CONFIG_MODULES) && defined(MODULES_VADDR)\n\tunsigned long addr = (unsigned long)x;\n\tif (addr >= MODULES_VADDR && addr < MODULES_END)\n\t\treturn 1;\n#endif\n\treturn is_vmalloc_addr(x);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_vmalloc_addr",
          "args": [
            "x"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nint is_vmalloc_or_module_addr(const void *x)\n{\n\t/*\n\t * ARM, x86-64 and sparc64 put modules in a special place,\n\t * and fall back on vmalloc() if that fails. Others\n\t * just put it in the vmalloc space.\n\t */\n#if defined(CONFIG_MODULES) && defined(MODULES_VADDR)\n\tunsigned long addr = (unsigned long)x;\n\tif (addr >= MODULES_VADDR && addr < MODULES_END)\n\t\treturn 1;\n#endif\n\treturn is_vmalloc_addr(x);\n}"
  },
  {
    "function_name": "vmap_page_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "238-246",
    "snippet": "static int vmap_page_range(unsigned long start, unsigned long end,\n\t\t\t   pgprot_t prot, struct page **pages)\n{\n\tint ret;\n\n\tret = vmap_page_range_noflush(start, end, prot, pages);\n\tflush_cache_vmap(start, end);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_cache_vmap",
          "args": [
            "start",
            "end"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmap_page_range_noflush",
          "args": [
            "start",
            "end",
            "prot",
            "pages"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "vmap_page_range_noflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "217-236",
          "snippet": "static int vmap_page_range_noflush(unsigned long start, unsigned long end,\n\t\t\t\t   pgprot_t prot, struct page **pages)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\tunsigned long addr = start;\n\tint err = 0;\n\tint nr = 0;\n\n\tBUG_ON(addr >= end);\n\tpgd = pgd_offset_k(addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\terr = vmap_p4d_range(pgd, addr, next, prot, pages, &nr);\n\t\tif (err)\n\t\t\treturn err;\n\t} while (pgd++, addr = next, addr != end);\n\n\treturn nr;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic int vmap_page_range_noflush(unsigned long start, unsigned long end,\n\t\t\t\t   pgprot_t prot, struct page **pages)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\tunsigned long addr = start;\n\tint err = 0;\n\tint nr = 0;\n\n\tBUG_ON(addr >= end);\n\tpgd = pgd_offset_k(addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\terr = vmap_p4d_range(pgd, addr, next, prot, pages, &nr);\n\t\tif (err)\n\t\t\treturn err;\n\t} while (pgd++, addr = next, addr != end);\n\n\treturn nr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic int vmap_page_range(unsigned long start, unsigned long end,\n\t\t\t   pgprot_t prot, struct page **pages)\n{\n\tint ret;\n\n\tret = vmap_page_range_noflush(start, end, prot, pages);\n\tflush_cache_vmap(start, end);\n\treturn ret;\n}"
  },
  {
    "function_name": "vmap_page_range_noflush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "217-236",
    "snippet": "static int vmap_page_range_noflush(unsigned long start, unsigned long end,\n\t\t\t\t   pgprot_t prot, struct page **pages)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\tunsigned long addr = start;\n\tint err = 0;\n\tint nr = 0;\n\n\tBUG_ON(addr >= end);\n\tpgd = pgd_offset_k(addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\terr = vmap_p4d_range(pgd, addr, next, prot, pages, &nr);\n\t\tif (err)\n\t\t\treturn err;\n\t} while (pgd++, addr = next, addr != end);\n\n\treturn nr;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmap_p4d_range",
          "args": [
            "pgd",
            "addr",
            "next",
            "prot",
            "pages",
            "&nr"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "vmap_p4d_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "194-209",
          "snippet": "static int vmap_p4d_range(pgd_t *pgd, unsigned long addr,\n\t\tunsigned long end, pgprot_t prot, struct page **pages, int *nr)\n{\n\tp4d_t *p4d;\n\tunsigned long next;\n\n\tp4d = p4d_alloc(&init_mm, pgd, addr);\n\tif (!p4d)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\tif (vmap_pud_range(p4d, addr, next, prot, pages, nr))\n\t\t\treturn -ENOMEM;\n\t} while (p4d++, addr = next, addr != end);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic int vmap_p4d_range(pgd_t *pgd, unsigned long addr,\n\t\tunsigned long end, pgprot_t prot, struct page **pages, int *nr)\n{\n\tp4d_t *p4d;\n\tunsigned long next;\n\n\tp4d = p4d_alloc(&init_mm, pgd, addr);\n\tif (!p4d)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\tif (vmap_pud_range(p4d, addr, next, prot, pages, nr))\n\t\t\treturn -ENOMEM;\n\t} while (p4d++, addr = next, addr != end);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgd_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_offset_k",
          "args": [
            "addr"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "addr >= end"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic int vmap_page_range_noflush(unsigned long start, unsigned long end,\n\t\t\t\t   pgprot_t prot, struct page **pages)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\tunsigned long addr = start;\n\tint err = 0;\n\tint nr = 0;\n\n\tBUG_ON(addr >= end);\n\tpgd = pgd_offset_k(addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\terr = vmap_p4d_range(pgd, addr, next, prot, pages, &nr);\n\t\tif (err)\n\t\t\treturn err;\n\t} while (pgd++, addr = next, addr != end);\n\n\treturn nr;\n}"
  },
  {
    "function_name": "vmap_p4d_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "194-209",
    "snippet": "static int vmap_p4d_range(pgd_t *pgd, unsigned long addr,\n\t\tunsigned long end, pgprot_t prot, struct page **pages, int *nr)\n{\n\tp4d_t *p4d;\n\tunsigned long next;\n\n\tp4d = p4d_alloc(&init_mm, pgd, addr);\n\tif (!p4d)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\tif (vmap_pud_range(p4d, addr, next, prot, pages, nr))\n\t\t\treturn -ENOMEM;\n\t} while (p4d++, addr = next, addr != end);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmap_pud_range",
          "args": [
            "p4d",
            "addr",
            "next",
            "prot",
            "pages",
            "nr"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "vmap_pud_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "177-192",
          "snippet": "static int vmap_pud_range(p4d_t *p4d, unsigned long addr,\n\t\tunsigned long end, pgprot_t prot, struct page **pages, int *nr)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\n\tpud = pud_alloc(&init_mm, p4d, addr);\n\tif (!pud)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (vmap_pmd_range(pud, addr, next, prot, pages, nr))\n\t\t\treturn -ENOMEM;\n\t} while (pud++, addr = next, addr != end);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic int vmap_pud_range(p4d_t *p4d, unsigned long addr,\n\t\tunsigned long end, pgprot_t prot, struct page **pages, int *nr)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\n\tpud = pud_alloc(&init_mm, p4d, addr);\n\tif (!pud)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (vmap_pmd_range(pud, addr, next, prot, pages, nr))\n\t\t\treturn -ENOMEM;\n\t} while (pud++, addr = next, addr != end);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p4d_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_alloc",
          "args": [
            "&init_mm",
            "pgd",
            "addr"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "__p4d_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3949-3964",
          "snippet": "int __p4d_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address)\n{\n\tp4d_t *new = p4d_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n\tif (pgd_present(*pgd))\t\t/* Another has populated it */\n\t\tp4d_free(mm, new);\n\telse\n\t\tpgd_populate(mm, pgd, new);\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __p4d_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address)\n{\n\tp4d_t *new = p4d_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n\tif (pgd_present(*pgd))\t\t/* Another has populated it */\n\t\tp4d_free(mm, new);\n\telse\n\t\tpgd_populate(mm, pgd, new);\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic int vmap_p4d_range(pgd_t *pgd, unsigned long addr,\n\t\tunsigned long end, pgprot_t prot, struct page **pages, int *nr)\n{\n\tp4d_t *p4d;\n\tunsigned long next;\n\n\tp4d = p4d_alloc(&init_mm, pgd, addr);\n\tif (!p4d)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\tif (vmap_pud_range(p4d, addr, next, prot, pages, nr))\n\t\t\treturn -ENOMEM;\n\t} while (p4d++, addr = next, addr != end);\n\treturn 0;\n}"
  },
  {
    "function_name": "vmap_pud_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "177-192",
    "snippet": "static int vmap_pud_range(p4d_t *p4d, unsigned long addr,\n\t\tunsigned long end, pgprot_t prot, struct page **pages, int *nr)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\n\tpud = pud_alloc(&init_mm, p4d, addr);\n\tif (!pud)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (vmap_pmd_range(pud, addr, next, prot, pages, nr))\n\t\t\treturn -ENOMEM;\n\t} while (pud++, addr = next, addr != end);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmap_pmd_range",
          "args": [
            "pud",
            "addr",
            "next",
            "prot",
            "pages",
            "nr"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "vmap_pmd_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "160-175",
          "snippet": "static int vmap_pmd_range(pud_t *pud, unsigned long addr,\n\t\tunsigned long end, pgprot_t prot, struct page **pages, int *nr)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\n\tpmd = pmd_alloc(&init_mm, pud, addr);\n\tif (!pmd)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (vmap_pte_range(pmd, addr, next, prot, pages, nr))\n\t\t\treturn -ENOMEM;\n\t} while (pmd++, addr = next, addr != end);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic int vmap_pmd_range(pud_t *pud, unsigned long addr,\n\t\tunsigned long end, pgprot_t prot, struct page **pages, int *nr)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\n\tpmd = pmd_alloc(&init_mm, pud, addr);\n\tif (!pmd)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (vmap_pte_range(pmd, addr, next, prot, pages, nr))\n\t\t\treturn -ENOMEM;\n\t} while (pmd++, addr = next, addr != end);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pud_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_alloc",
          "args": [
            "&init_mm",
            "p4d",
            "addr"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "__pud_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3972-3996",
          "snippet": "int __pud_alloc(struct mm_struct *mm, p4d_t *p4d, unsigned long address)\n{\n\tpud_t *new = pud_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n#ifndef __ARCH_HAS_5LEVEL_HACK\n\tif (!p4d_present(*p4d)) {\n\t\tmm_inc_nr_puds(mm);\n\t\tp4d_populate(mm, p4d, new);\n\t} else\t/* Another has populated it */\n\t\tpud_free(mm, new);\n#else\n\tif (!pgd_present(*p4d)) {\n\t\tmm_inc_nr_puds(mm);\n\t\tpgd_populate(mm, p4d, new);\n\t} else\t/* Another has populated it */\n\t\tpud_free(mm, new);\n#endif /* __ARCH_HAS_5LEVEL_HACK */\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __pud_alloc(struct mm_struct *mm, p4d_t *p4d, unsigned long address)\n{\n\tpud_t *new = pud_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n#ifndef __ARCH_HAS_5LEVEL_HACK\n\tif (!p4d_present(*p4d)) {\n\t\tmm_inc_nr_puds(mm);\n\t\tp4d_populate(mm, p4d, new);\n\t} else\t/* Another has populated it */\n\t\tpud_free(mm, new);\n#else\n\tif (!pgd_present(*p4d)) {\n\t\tmm_inc_nr_puds(mm);\n\t\tpgd_populate(mm, p4d, new);\n\t} else\t/* Another has populated it */\n\t\tpud_free(mm, new);\n#endif /* __ARCH_HAS_5LEVEL_HACK */\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic int vmap_pud_range(p4d_t *p4d, unsigned long addr,\n\t\tunsigned long end, pgprot_t prot, struct page **pages, int *nr)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\n\tpud = pud_alloc(&init_mm, p4d, addr);\n\tif (!pud)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (vmap_pmd_range(pud, addr, next, prot, pages, nr))\n\t\t\treturn -ENOMEM;\n\t} while (pud++, addr = next, addr != end);\n\treturn 0;\n}"
  },
  {
    "function_name": "vmap_pmd_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "160-175",
    "snippet": "static int vmap_pmd_range(pud_t *pud, unsigned long addr,\n\t\tunsigned long end, pgprot_t prot, struct page **pages, int *nr)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\n\tpmd = pmd_alloc(&init_mm, pud, addr);\n\tif (!pmd)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (vmap_pte_range(pmd, addr, next, prot, pages, nr))\n\t\t\treturn -ENOMEM;\n\t} while (pmd++, addr = next, addr != end);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmap_pte_range",
          "args": [
            "pmd",
            "addr",
            "next",
            "prot",
            "pages",
            "nr"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "vmap_pte_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "134-158",
          "snippet": "static int vmap_pte_range(pmd_t *pmd, unsigned long addr,\n\t\tunsigned long end, pgprot_t prot, struct page **pages, int *nr)\n{\n\tpte_t *pte;\n\n\t/*\n\t * nr is a running index into the array which helps higher level\n\t * callers keep track of where we're up to.\n\t */\n\n\tpte = pte_alloc_kernel(pmd, addr);\n\tif (!pte)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tstruct page *page = pages[*nr];\n\n\t\tif (WARN_ON(!pte_none(*pte)))\n\t\t\treturn -EBUSY;\n\t\tif (WARN_ON(!page))\n\t\t\treturn -ENOMEM;\n\t\tset_pte_at(&init_mm, addr, pte, mk_pte(page, prot));\n\t\t(*nr)++;\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic int vmap_pte_range(pmd_t *pmd, unsigned long addr,\n\t\tunsigned long end, pgprot_t prot, struct page **pages, int *nr)\n{\n\tpte_t *pte;\n\n\t/*\n\t * nr is a running index into the array which helps higher level\n\t * callers keep track of where we're up to.\n\t */\n\n\tpte = pte_alloc_kernel(pmd, addr);\n\tif (!pte)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tstruct page *page = pages[*nr];\n\n\t\tif (WARN_ON(!pte_none(*pte)))\n\t\t\treturn -EBUSY;\n\t\tif (WARN_ON(!page))\n\t\t\treturn -ENOMEM;\n\t\tset_pte_at(&init_mm, addr, pte, mk_pte(page, prot));\n\t\t(*nr)++;\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_alloc",
          "args": [
            "&init_mm",
            "pud",
            "addr"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "__pmd_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "4004-4029",
          "snippet": "int __pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)\n{\n\tspinlock_t *ptl;\n\tpmd_t *new = pmd_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tptl = pud_lock(mm, pud);\n#ifndef __ARCH_HAS_4LEVEL_HACK\n\tif (!pud_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpud_populate(mm, pud, new);\n\t} else\t/* Another has populated it */\n\t\tpmd_free(mm, new);\n#else\n\tif (!pgd_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpgd_populate(mm, pud, new);\n\t} else /* Another has populated it */\n\t\tpmd_free(mm, new);\n#endif /* __ARCH_HAS_4LEVEL_HACK */\n\tspin_unlock(ptl);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)\n{\n\tspinlock_t *ptl;\n\tpmd_t *new = pmd_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tptl = pud_lock(mm, pud);\n#ifndef __ARCH_HAS_4LEVEL_HACK\n\tif (!pud_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpud_populate(mm, pud, new);\n\t} else\t/* Another has populated it */\n\t\tpmd_free(mm, new);\n#else\n\tif (!pgd_present(*pud)) {\n\t\tmm_inc_nr_pmds(mm);\n\t\tpgd_populate(mm, pud, new);\n\t} else /* Another has populated it */\n\t\tpmd_free(mm, new);\n#endif /* __ARCH_HAS_4LEVEL_HACK */\n\tspin_unlock(ptl);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic int vmap_pmd_range(pud_t *pud, unsigned long addr,\n\t\tunsigned long end, pgprot_t prot, struct page **pages, int *nr)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\n\tpmd = pmd_alloc(&init_mm, pud, addr);\n\tif (!pmd)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (vmap_pte_range(pmd, addr, next, prot, pages, nr))\n\t\t\treturn -ENOMEM;\n\t} while (pmd++, addr = next, addr != end);\n\treturn 0;\n}"
  },
  {
    "function_name": "vmap_pte_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "134-158",
    "snippet": "static int vmap_pte_range(pmd_t *pmd, unsigned long addr,\n\t\tunsigned long end, pgprot_t prot, struct page **pages, int *nr)\n{\n\tpte_t *pte;\n\n\t/*\n\t * nr is a running index into the array which helps higher level\n\t * callers keep track of where we're up to.\n\t */\n\n\tpte = pte_alloc_kernel(pmd, addr);\n\tif (!pte)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tstruct page *page = pages[*nr];\n\n\t\tif (WARN_ON(!pte_none(*pte)))\n\t\t\treturn -EBUSY;\n\t\tif (WARN_ON(!page))\n\t\t\treturn -ENOMEM;\n\t\tset_pte_at(&init_mm, addr, pte, mk_pte(page, prot));\n\t\t(*nr)++;\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_pte_at",
          "args": [
            "&init_mm",
            "addr",
            "pte",
            "mk_pte(page, prot)"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mk_pte",
          "args": [
            "page",
            "prot"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!page"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!pte_none(*pte)"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_none",
          "args": [
            "*pte"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_alloc_kernel",
          "args": [
            "pmd",
            "addr"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "__pte_alloc_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "437-454",
          "snippet": "int __pte_alloc_kernel(pmd_t *pmd, unsigned long address)\n{\n\tpte_t *new = pte_alloc_one_kernel(&init_mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&init_mm.page_table_lock);\n\tif (likely(pmd_none(*pmd))) {\t/* Has another populated it ? */\n\t\tpmd_populate_kernel(&init_mm, pmd, new);\n\t\tnew = NULL;\n\t}\n\tspin_unlock(&init_mm.page_table_lock);\n\tif (new)\n\t\tpte_free_kernel(&init_mm, new);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nint __pte_alloc_kernel(pmd_t *pmd, unsigned long address)\n{\n\tpte_t *new = pte_alloc_one_kernel(&init_mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&init_mm.page_table_lock);\n\tif (likely(pmd_none(*pmd))) {\t/* Has another populated it ? */\n\t\tpmd_populate_kernel(&init_mm, pmd, new);\n\t\tnew = NULL;\n\t}\n\tspin_unlock(&init_mm.page_table_lock);\n\tif (new)\n\t\tpte_free_kernel(&init_mm, new);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic int vmap_pte_range(pmd_t *pmd, unsigned long addr,\n\t\tunsigned long end, pgprot_t prot, struct page **pages, int *nr)\n{\n\tpte_t *pte;\n\n\t/*\n\t * nr is a running index into the array which helps higher level\n\t * callers keep track of where we're up to.\n\t */\n\n\tpte = pte_alloc_kernel(pmd, addr);\n\tif (!pte)\n\t\treturn -ENOMEM;\n\tdo {\n\t\tstruct page *page = pages[*nr];\n\n\t\tif (WARN_ON(!pte_none(*pte)))\n\t\t\treturn -EBUSY;\n\t\tif (WARN_ON(!page))\n\t\t\treturn -ENOMEM;\n\t\tset_pte_at(&init_mm, addr, pte, mk_pte(page, prot));\n\t\t(*nr)++;\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n\treturn 0;\n}"
  },
  {
    "function_name": "vunmap_page_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "119-132",
    "snippet": "static void vunmap_page_range(unsigned long addr, unsigned long end)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\n\tBUG_ON(addr >= end);\n\tpgd = pgd_offset_k(addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(pgd))\n\t\t\tcontinue;\n\t\tvunmap_p4d_range(pgd, addr, next);\n\t} while (pgd++, addr = next, addr != end);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vunmap_p4d_range",
          "args": [
            "pgd",
            "addr",
            "next"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "vunmap_p4d_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "103-117",
          "snippet": "static void vunmap_p4d_range(pgd_t *pgd, unsigned long addr, unsigned long end)\n{\n\tp4d_t *p4d;\n\tunsigned long next;\n\n\tp4d = p4d_offset(pgd, addr);\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\tif (p4d_clear_huge(p4d))\n\t\t\tcontinue;\n\t\tif (p4d_none_or_clear_bad(p4d))\n\t\t\tcontinue;\n\t\tvunmap_pud_range(p4d, addr, next);\n\t} while (p4d++, addr = next, addr != end);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void vunmap_p4d_range(pgd_t *pgd, unsigned long addr, unsigned long end)\n{\n\tp4d_t *p4d;\n\tunsigned long next;\n\n\tp4d = p4d_offset(pgd, addr);\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\tif (p4d_clear_huge(p4d))\n\t\t\tcontinue;\n\t\tif (p4d_none_or_clear_bad(p4d))\n\t\t\tcontinue;\n\t\tvunmap_pud_range(p4d, addr, next);\n\t} while (p4d++, addr = next, addr != end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgd_none_or_clear_bad",
          "args": [
            "pgd"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_offset_k",
          "args": [
            "addr"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "addr >= end"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void vunmap_page_range(unsigned long addr, unsigned long end)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\n\tBUG_ON(addr >= end);\n\tpgd = pgd_offset_k(addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(pgd))\n\t\t\tcontinue;\n\t\tvunmap_p4d_range(pgd, addr, next);\n\t} while (pgd++, addr = next, addr != end);\n}"
  },
  {
    "function_name": "vunmap_p4d_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "103-117",
    "snippet": "static void vunmap_p4d_range(pgd_t *pgd, unsigned long addr, unsigned long end)\n{\n\tp4d_t *p4d;\n\tunsigned long next;\n\n\tp4d = p4d_offset(pgd, addr);\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\tif (p4d_clear_huge(p4d))\n\t\t\tcontinue;\n\t\tif (p4d_none_or_clear_bad(p4d))\n\t\t\tcontinue;\n\t\tvunmap_pud_range(p4d, addr, next);\n\t} while (p4d++, addr = next, addr != end);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vunmap_pud_range",
          "args": [
            "p4d",
            "addr",
            "next"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "vunmap_pud_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "87-101",
          "snippet": "static void vunmap_pud_range(p4d_t *p4d, unsigned long addr, unsigned long end)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\n\tpud = pud_offset(p4d, addr);\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (pud_clear_huge(pud))\n\t\t\tcontinue;\n\t\tif (pud_none_or_clear_bad(pud))\n\t\t\tcontinue;\n\t\tvunmap_pmd_range(pud, addr, next);\n\t} while (pud++, addr = next, addr != end);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void vunmap_pud_range(p4d_t *p4d, unsigned long addr, unsigned long end)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\n\tpud = pud_offset(p4d, addr);\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (pud_clear_huge(pud))\n\t\t\tcontinue;\n\t\tif (pud_none_or_clear_bad(pud))\n\t\t\tcontinue;\n\t\tvunmap_pmd_range(pud, addr, next);\n\t} while (pud++, addr = next, addr != end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p4d_none_or_clear_bad",
          "args": [
            "p4d"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_clear_huge",
          "args": [
            "p4d"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_offset",
          "args": [
            "pgd",
            "addr"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void vunmap_p4d_range(pgd_t *pgd, unsigned long addr, unsigned long end)\n{\n\tp4d_t *p4d;\n\tunsigned long next;\n\n\tp4d = p4d_offset(pgd, addr);\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\tif (p4d_clear_huge(p4d))\n\t\t\tcontinue;\n\t\tif (p4d_none_or_clear_bad(p4d))\n\t\t\tcontinue;\n\t\tvunmap_pud_range(p4d, addr, next);\n\t} while (p4d++, addr = next, addr != end);\n}"
  },
  {
    "function_name": "vunmap_pud_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "87-101",
    "snippet": "static void vunmap_pud_range(p4d_t *p4d, unsigned long addr, unsigned long end)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\n\tpud = pud_offset(p4d, addr);\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (pud_clear_huge(pud))\n\t\t\tcontinue;\n\t\tif (pud_none_or_clear_bad(pud))\n\t\t\tcontinue;\n\t\tvunmap_pmd_range(pud, addr, next);\n\t} while (pud++, addr = next, addr != end);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vunmap_pmd_range",
          "args": [
            "pud",
            "addr",
            "next"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "vunmap_pmd_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "71-85",
          "snippet": "static void vunmap_pmd_range(pud_t *pud, unsigned long addr, unsigned long end)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\n\tpmd = pmd_offset(pud, addr);\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (pmd_clear_huge(pmd))\n\t\t\tcontinue;\n\t\tif (pmd_none_or_clear_bad(pmd))\n\t\t\tcontinue;\n\t\tvunmap_pte_range(pmd, addr, next);\n\t} while (pmd++, addr = next, addr != end);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void vunmap_pmd_range(pud_t *pud, unsigned long addr, unsigned long end)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\n\tpmd = pmd_offset(pud, addr);\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (pmd_clear_huge(pmd))\n\t\t\tcontinue;\n\t\tif (pmd_none_or_clear_bad(pmd))\n\t\t\tcontinue;\n\t\tvunmap_pte_range(pmd, addr, next);\n\t} while (pmd++, addr = next, addr != end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pud_none_or_clear_bad",
          "args": [
            "pud"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_clear_huge",
          "args": [
            "pud"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_offset",
          "args": [
            "p4d",
            "addr"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void vunmap_pud_range(p4d_t *p4d, unsigned long addr, unsigned long end)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\n\tpud = pud_offset(p4d, addr);\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (pud_clear_huge(pud))\n\t\t\tcontinue;\n\t\tif (pud_none_or_clear_bad(pud))\n\t\t\tcontinue;\n\t\tvunmap_pmd_range(pud, addr, next);\n\t} while (pud++, addr = next, addr != end);\n}"
  },
  {
    "function_name": "vunmap_pmd_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "71-85",
    "snippet": "static void vunmap_pmd_range(pud_t *pud, unsigned long addr, unsigned long end)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\n\tpmd = pmd_offset(pud, addr);\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (pmd_clear_huge(pmd))\n\t\t\tcontinue;\n\t\tif (pmd_none_or_clear_bad(pmd))\n\t\t\tcontinue;\n\t\tvunmap_pte_range(pmd, addr, next);\n\t} while (pmd++, addr = next, addr != end);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vunmap_pte_range",
          "args": [
            "pmd",
            "addr",
            "next"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "vunmap_pte_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "60-69",
          "snippet": "static void vunmap_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end)\n{\n\tpte_t *pte;\n\n\tpte = pte_offset_kernel(pmd, addr);\n\tdo {\n\t\tpte_t ptent = ptep_get_and_clear(&init_mm, addr, pte);\n\t\tWARN_ON(!pte_none(ptent) && !pte_present(ptent));\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void vunmap_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end)\n{\n\tpte_t *pte;\n\n\tpte = pte_offset_kernel(pmd, addr);\n\tdo {\n\t\tpte_t ptent = ptep_get_and_clear(&init_mm, addr, pte);\n\t\tWARN_ON(!pte_none(ptent) && !pte_present(ptent));\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_none_or_clear_bad",
          "args": [
            "pmd"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_clear_huge",
          "args": [
            "pmd"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_offset",
          "args": [
            "pud",
            "addr"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void vunmap_pmd_range(pud_t *pud, unsigned long addr, unsigned long end)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\n\tpmd = pmd_offset(pud, addr);\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (pmd_clear_huge(pmd))\n\t\t\tcontinue;\n\t\tif (pmd_none_or_clear_bad(pmd))\n\t\t\tcontinue;\n\t\tvunmap_pte_range(pmd, addr, next);\n\t} while (pmd++, addr = next, addr != end);\n}"
  },
  {
    "function_name": "vunmap_pte_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "60-69",
    "snippet": "static void vunmap_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end)\n{\n\tpte_t *pte;\n\n\tpte = pte_offset_kernel(pmd, addr);\n\tdo {\n\t\tpte_t ptent = ptep_get_and_clear(&init_mm, addr, pte);\n\t\tWARN_ON(!pte_none(ptent) && !pte_present(ptent));\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!pte_none(ptent) && !pte_present(ptent)"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "ptent"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_none",
          "args": [
            "ptent"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptep_get_and_clear",
          "args": [
            "&init_mm",
            "addr",
            "pte"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_offset_kernel",
          "args": [
            "pmd",
            "addr"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void vunmap_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end)\n{\n\tpte_t *pte;\n\n\tpte = pte_offset_kernel(pmd, addr);\n\tdo {\n\t\tpte_t ptent = ptep_get_and_clear(&init_mm, addr, pte);\n\t\tWARN_ON(!pte_none(ptent) && !pte_present(ptent));\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n}"
  },
  {
    "function_name": "free_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
    "lines": "49-56",
    "snippet": "static void free_work(struct work_struct *w)\n{\n\tstruct vfree_deferred *p = container_of(w, struct vfree_deferred, wq);\n\tstruct llist_node *t, *llnode;\n\n\tllist_for_each_safe(llnode, t, llist_del_all(&p->list))\n\t\t__vunmap((void *)llnode, 1);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/shmparam.h>",
      "#include <asm/tlbflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bitops.h>",
      "#include <linux/llist.h>",
      "#include <linux/compiler.h>",
      "#include <linux/atomic.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/pfn.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/radix-tree.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct vfree_deferred, vfree_deferred);",
      "static void __vunmap(const void *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vunmap",
          "args": [
            "(void *)llnode",
            "1"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "__vunmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmalloc.c",
          "lines": "1497-1534",
          "snippet": "static void __vunmap(const void *addr, int deallocate_pages)\n{\n\tstruct vm_struct *area;\n\n\tif (!addr)\n\t\treturn;\n\n\tif (WARN(!PAGE_ALIGNED(addr), \"Trying to vfree() bad address (%p)\\n\",\n\t\t\taddr))\n\t\treturn;\n\n\tarea = find_vmap_area((unsigned long)addr)->vm;\n\tif (unlikely(!area)) {\n\t\tWARN(1, KERN_ERR \"Trying to vfree() nonexistent vm area (%p)\\n\",\n\t\t\t\taddr);\n\t\treturn;\n\t}\n\n\tdebug_check_no_locks_freed(area->addr, get_vm_area_size(area));\n\tdebug_check_no_obj_freed(area->addr, get_vm_area_size(area));\n\n\tremove_vm_area(addr);\n\tif (deallocate_pages) {\n\t\tint i;\n\n\t\tfor (i = 0; i < area->nr_pages; i++) {\n\t\t\tstruct page *page = area->pages[i];\n\n\t\t\tBUG_ON(!page);\n\t\t\t__free_pages(page, 0);\n\t\t}\n\n\t\tkvfree(area->pages);\n\t}\n\n\tkfree(area);\n\treturn;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/shmparam.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bitops.h>",
            "#include <linux/llist.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/pfn.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __vunmap(const void *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic void __vunmap(const void *, int);\n\nstatic void __vunmap(const void *addr, int deallocate_pages)\n{\n\tstruct vm_struct *area;\n\n\tif (!addr)\n\t\treturn;\n\n\tif (WARN(!PAGE_ALIGNED(addr), \"Trying to vfree() bad address (%p)\\n\",\n\t\t\taddr))\n\t\treturn;\n\n\tarea = find_vmap_area((unsigned long)addr)->vm;\n\tif (unlikely(!area)) {\n\t\tWARN(1, KERN_ERR \"Trying to vfree() nonexistent vm area (%p)\\n\",\n\t\t\t\taddr);\n\t\treturn;\n\t}\n\n\tdebug_check_no_locks_freed(area->addr, get_vm_area_size(area));\n\tdebug_check_no_obj_freed(area->addr, get_vm_area_size(area));\n\n\tremove_vm_area(addr);\n\tif (deallocate_pages) {\n\t\tint i;\n\n\t\tfor (i = 0; i < area->nr_pages; i++) {\n\t\t\tstruct page *page = area->pages[i];\n\n\t\t\tBUG_ON(!page);\n\t\t\t__free_pages(page, 0);\n\t\t}\n\n\t\tkvfree(area->pages);\n\t}\n\n\tkfree(area);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "llist_for_each_safe",
          "args": [
            "llnode",
            "t",
            "llist_del_all(&p->list)"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llist_del_all",
          "args": [
            "&p->list"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "w",
            "structvfree_deferred",
            "wq"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/shmparam.h>\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/llist.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/kmemleak.h>\n#include <linux/pfn.h>\n#include <linux/rcupdate.h>\n#include <linux/radix-tree.h>\n#include <linux/rbtree.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n\nstatic DEFINE_PER_CPU(struct vfree_deferred, vfree_deferred);\nstatic void __vunmap(const void *, int);\n\nstatic void free_work(struct work_struct *w)\n{\n\tstruct vfree_deferred *p = container_of(w, struct vfree_deferred, wq);\n\tstruct llist_node *t, *llnode;\n\n\tllist_for_each_safe(llnode, t, llist_del_all(&p->list))\n\t\t__vunmap((void *)llnode, 1);\n}"
  }
]