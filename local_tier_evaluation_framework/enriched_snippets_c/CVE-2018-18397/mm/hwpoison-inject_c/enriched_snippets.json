[
  {
    "function_name": "pfn_inject_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hwpoison-inject.c",
    "lines": "77-136",
    "snippet": "static int pfn_inject_init(void)\n{\n\tstruct dentry *dentry;\n\n\thwpoison_dir = debugfs_create_dir(\"hwpoison\", NULL);\n\tif (hwpoison_dir == NULL)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Note that the below poison/unpoison interfaces do not involve\n\t * hardware status change, hence do not require hardware support.\n\t * They are mainly for testing hwpoison in software level.\n\t */\n\tdentry = debugfs_create_file(\"corrupt-pfn\", 0200, hwpoison_dir,\n\t\t\t\t\t  NULL, &hwpoison_fops);\n\tif (!dentry)\n\t\tgoto fail;\n\n\tdentry = debugfs_create_file(\"unpoison-pfn\", 0200, hwpoison_dir,\n\t\t\t\t     NULL, &unpoison_fops);\n\tif (!dentry)\n\t\tgoto fail;\n\n\tdentry = debugfs_create_u32(\"corrupt-filter-enable\", 0600,\n\t\t\t\t    hwpoison_dir, &hwpoison_filter_enable);\n\tif (!dentry)\n\t\tgoto fail;\n\n\tdentry = debugfs_create_u32(\"corrupt-filter-dev-major\", 0600,\n\t\t\t\t    hwpoison_dir, &hwpoison_filter_dev_major);\n\tif (!dentry)\n\t\tgoto fail;\n\n\tdentry = debugfs_create_u32(\"corrupt-filter-dev-minor\", 0600,\n\t\t\t\t    hwpoison_dir, &hwpoison_filter_dev_minor);\n\tif (!dentry)\n\t\tgoto fail;\n\n\tdentry = debugfs_create_u64(\"corrupt-filter-flags-mask\", 0600,\n\t\t\t\t    hwpoison_dir, &hwpoison_filter_flags_mask);\n\tif (!dentry)\n\t\tgoto fail;\n\n\tdentry = debugfs_create_u64(\"corrupt-filter-flags-value\", 0600,\n\t\t\t\t    hwpoison_dir, &hwpoison_filter_flags_value);\n\tif (!dentry)\n\t\tgoto fail;\n\n#ifdef CONFIG_MEMCG\n\tdentry = debugfs_create_u64(\"corrupt-filter-memcg\", 0600,\n\t\t\t\t    hwpoison_dir, &hwpoison_filter_memcg);\n\tif (!dentry)\n\t\tgoto fail;\n#endif\n\n\treturn 0;\nfail:\n\tpfn_inject_exit();\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/hugetlb.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *hwpoison_dir;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfn_inject_exit",
          "args": [],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "pfn_inject_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hwpoison-inject.c",
          "lines": "72-75",
          "snippet": "static void pfn_inject_exit(void)\n{\n\tdebugfs_remove_recursive(hwpoison_dir);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/hugetlb.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *hwpoison_dir;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n\nstatic struct dentry *hwpoison_dir;\n\nstatic void pfn_inject_exit(void)\n{\n\tdebugfs_remove_recursive(hwpoison_dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_create_u64",
          "args": [
            "\"corrupt-filter-memcg\"",
            "0600",
            "hwpoison_dir",
            "&hwpoison_filter_memcg"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_u64",
          "args": [
            "\"corrupt-filter-flags-value\"",
            "0600",
            "hwpoison_dir",
            "&hwpoison_filter_flags_value"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_u64",
          "args": [
            "\"corrupt-filter-flags-mask\"",
            "0600",
            "hwpoison_dir",
            "&hwpoison_filter_flags_mask"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_u32",
          "args": [
            "\"corrupt-filter-dev-minor\"",
            "0600",
            "hwpoison_dir",
            "&hwpoison_filter_dev_minor"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_u32",
          "args": [
            "\"corrupt-filter-dev-major\"",
            "0600",
            "hwpoison_dir",
            "&hwpoison_filter_dev_major"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_u32",
          "args": [
            "\"corrupt-filter-enable\"",
            "0600",
            "hwpoison_dir",
            "&hwpoison_filter_enable"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"unpoison-pfn\"",
            "0200",
            "hwpoison_dir",
            "NULL",
            "&unpoison_fops"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"corrupt-pfn\"",
            "0200",
            "hwpoison_dir",
            "NULL",
            "&hwpoison_fops"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_dir",
          "args": [
            "\"hwpoison\"",
            "NULL"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n\nstatic struct dentry *hwpoison_dir;\n\nstatic int pfn_inject_init(void)\n{\n\tstruct dentry *dentry;\n\n\thwpoison_dir = debugfs_create_dir(\"hwpoison\", NULL);\n\tif (hwpoison_dir == NULL)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Note that the below poison/unpoison interfaces do not involve\n\t * hardware status change, hence do not require hardware support.\n\t * They are mainly for testing hwpoison in software level.\n\t */\n\tdentry = debugfs_create_file(\"corrupt-pfn\", 0200, hwpoison_dir,\n\t\t\t\t\t  NULL, &hwpoison_fops);\n\tif (!dentry)\n\t\tgoto fail;\n\n\tdentry = debugfs_create_file(\"unpoison-pfn\", 0200, hwpoison_dir,\n\t\t\t\t     NULL, &unpoison_fops);\n\tif (!dentry)\n\t\tgoto fail;\n\n\tdentry = debugfs_create_u32(\"corrupt-filter-enable\", 0600,\n\t\t\t\t    hwpoison_dir, &hwpoison_filter_enable);\n\tif (!dentry)\n\t\tgoto fail;\n\n\tdentry = debugfs_create_u32(\"corrupt-filter-dev-major\", 0600,\n\t\t\t\t    hwpoison_dir, &hwpoison_filter_dev_major);\n\tif (!dentry)\n\t\tgoto fail;\n\n\tdentry = debugfs_create_u32(\"corrupt-filter-dev-minor\", 0600,\n\t\t\t\t    hwpoison_dir, &hwpoison_filter_dev_minor);\n\tif (!dentry)\n\t\tgoto fail;\n\n\tdentry = debugfs_create_u64(\"corrupt-filter-flags-mask\", 0600,\n\t\t\t\t    hwpoison_dir, &hwpoison_filter_flags_mask);\n\tif (!dentry)\n\t\tgoto fail;\n\n\tdentry = debugfs_create_u64(\"corrupt-filter-flags-value\", 0600,\n\t\t\t\t    hwpoison_dir, &hwpoison_filter_flags_value);\n\tif (!dentry)\n\t\tgoto fail;\n\n#ifdef CONFIG_MEMCG\n\tdentry = debugfs_create_u64(\"corrupt-filter-memcg\", 0600,\n\t\t\t\t    hwpoison_dir, &hwpoison_filter_memcg);\n\tif (!dentry)\n\t\tgoto fail;\n#endif\n\n\treturn 0;\nfail:\n\tpfn_inject_exit();\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "pfn_inject_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hwpoison-inject.c",
    "lines": "72-75",
    "snippet": "static void pfn_inject_exit(void)\n{\n\tdebugfs_remove_recursive(hwpoison_dir);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/hugetlb.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *hwpoison_dir;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_remove_recursive",
          "args": [
            "hwpoison_dir"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n\nstatic struct dentry *hwpoison_dir;\n\nstatic void pfn_inject_exit(void)\n{\n\tdebugfs_remove_recursive(hwpoison_dir);\n}"
  },
  {
    "function_name": "hwpoison_unpoison",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hwpoison-inject.c",
    "lines": "61-67",
    "snippet": "static int hwpoison_unpoison(void *data, u64 val)\n{\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn unpoison_memory(val);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/hugetlb.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unpoison_memory",
          "args": [
            "val"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "unpoison_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "1531-1608",
          "snippet": "int unpoison_memory(unsigned long pfn)\n{\n\tstruct page *page;\n\tstruct page *p;\n\tint freeit = 0;\n\tstatic DEFINE_RATELIMIT_STATE(unpoison_rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t\tDEFAULT_RATELIMIT_BURST);\n\n\tif (!pfn_valid(pfn))\n\t\treturn -ENXIO;\n\n\tp = pfn_to_page(pfn);\n\tpage = compound_head(p);\n\n\tif (!PageHWPoison(p)) {\n\t\tunpoison_pr_info(\"Unpoison: Page was already unpoisoned %#lx\\n\",\n\t\t\t\t pfn, &unpoison_rs);\n\t\treturn 0;\n\t}\n\n\tif (page_count(page) > 1) {\n\t\tunpoison_pr_info(\"Unpoison: Someone grabs the hwpoison page %#lx\\n\",\n\t\t\t\t pfn, &unpoison_rs);\n\t\treturn 0;\n\t}\n\n\tif (page_mapped(page)) {\n\t\tunpoison_pr_info(\"Unpoison: Someone maps the hwpoison page %#lx\\n\",\n\t\t\t\t pfn, &unpoison_rs);\n\t\treturn 0;\n\t}\n\n\tif (page_mapping(page)) {\n\t\tunpoison_pr_info(\"Unpoison: the hwpoison page has non-NULL mapping %#lx\\n\",\n\t\t\t\t pfn, &unpoison_rs);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * unpoison_memory() can encounter thp only when the thp is being\n\t * worked by memory_failure() and the page lock is not held yet.\n\t * In such case, we yield to memory_failure() and make unpoison fail.\n\t */\n\tif (!PageHuge(page) && PageTransHuge(page)) {\n\t\tunpoison_pr_info(\"Unpoison: Memory failure is now running on %#lx\\n\",\n\t\t\t\t pfn, &unpoison_rs);\n\t\treturn 0;\n\t}\n\n\tif (!get_hwpoison_page(p)) {\n\t\tif (TestClearPageHWPoison(p))\n\t\t\tnum_poisoned_pages_dec();\n\t\tunpoison_pr_info(\"Unpoison: Software-unpoisoned free page %#lx\\n\",\n\t\t\t\t pfn, &unpoison_rs);\n\t\treturn 0;\n\t}\n\n\tlock_page(page);\n\t/*\n\t * This test is racy because PG_hwpoison is set outside of page lock.\n\t * That's acceptable because that won't trigger kernel panic. Instead,\n\t * the PG_hwpoison page will be caught and isolated on the entrance to\n\t * the free buddy page pool.\n\t */\n\tif (TestClearPageHWPoison(page)) {\n\t\tunpoison_pr_info(\"Unpoison: Software-unpoisoned page %#lx\\n\",\n\t\t\t\t pfn, &unpoison_rs);\n\t\tnum_poisoned_pages_dec();\n\t\tfreeit = 1;\n\t}\n\tunlock_page(page);\n\n\tput_hwpoison_page(page);\n\tif (freeit && !(pfn == my_zero_pfn(0) && page_count(p) == 1))\n\t\tput_hwpoison_page(page);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint unpoison_memory(unsigned long pfn)\n{\n\tstruct page *page;\n\tstruct page *p;\n\tint freeit = 0;\n\tstatic DEFINE_RATELIMIT_STATE(unpoison_rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t\tDEFAULT_RATELIMIT_BURST);\n\n\tif (!pfn_valid(pfn))\n\t\treturn -ENXIO;\n\n\tp = pfn_to_page(pfn);\n\tpage = compound_head(p);\n\n\tif (!PageHWPoison(p)) {\n\t\tunpoison_pr_info(\"Unpoison: Page was already unpoisoned %#lx\\n\",\n\t\t\t\t pfn, &unpoison_rs);\n\t\treturn 0;\n\t}\n\n\tif (page_count(page) > 1) {\n\t\tunpoison_pr_info(\"Unpoison: Someone grabs the hwpoison page %#lx\\n\",\n\t\t\t\t pfn, &unpoison_rs);\n\t\treturn 0;\n\t}\n\n\tif (page_mapped(page)) {\n\t\tunpoison_pr_info(\"Unpoison: Someone maps the hwpoison page %#lx\\n\",\n\t\t\t\t pfn, &unpoison_rs);\n\t\treturn 0;\n\t}\n\n\tif (page_mapping(page)) {\n\t\tunpoison_pr_info(\"Unpoison: the hwpoison page has non-NULL mapping %#lx\\n\",\n\t\t\t\t pfn, &unpoison_rs);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * unpoison_memory() can encounter thp only when the thp is being\n\t * worked by memory_failure() and the page lock is not held yet.\n\t * In such case, we yield to memory_failure() and make unpoison fail.\n\t */\n\tif (!PageHuge(page) && PageTransHuge(page)) {\n\t\tunpoison_pr_info(\"Unpoison: Memory failure is now running on %#lx\\n\",\n\t\t\t\t pfn, &unpoison_rs);\n\t\treturn 0;\n\t}\n\n\tif (!get_hwpoison_page(p)) {\n\t\tif (TestClearPageHWPoison(p))\n\t\t\tnum_poisoned_pages_dec();\n\t\tunpoison_pr_info(\"Unpoison: Software-unpoisoned free page %#lx\\n\",\n\t\t\t\t pfn, &unpoison_rs);\n\t\treturn 0;\n\t}\n\n\tlock_page(page);\n\t/*\n\t * This test is racy because PG_hwpoison is set outside of page lock.\n\t * That's acceptable because that won't trigger kernel panic. Instead,\n\t * the PG_hwpoison page will be caught and isolated on the entrance to\n\t * the free buddy page pool.\n\t */\n\tif (TestClearPageHWPoison(page)) {\n\t\tunpoison_pr_info(\"Unpoison: Software-unpoisoned page %#lx\\n\",\n\t\t\t\t pfn, &unpoison_rs);\n\t\tnum_poisoned_pages_dec();\n\t\tfreeit = 1;\n\t}\n\tunlock_page(page);\n\n\tput_hwpoison_page(page);\n\tif (freeit && !(pfn == my_zero_pfn(0) && page_count(p) == 1))\n\t\tput_hwpoison_page(page);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n\nstatic int hwpoison_unpoison(void *data, u64 val)\n{\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn unpoison_memory(val);\n}"
  },
  {
    "function_name": "hwpoison_inject",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hwpoison-inject.c",
    "lines": "13-59",
    "snippet": "static int hwpoison_inject(void *data, u64 val)\n{\n\tunsigned long pfn = val;\n\tstruct page *p;\n\tstruct page *hpage;\n\tint err;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!pfn_valid(pfn))\n\t\treturn -ENXIO;\n\n\tp = pfn_to_page(pfn);\n\thpage = compound_head(p);\n\t/*\n\t * This implies unable to support free buddy pages.\n\t */\n\tif (!get_hwpoison_page(p))\n\t\treturn 0;\n\n\tif (!hwpoison_filter_enable)\n\t\tgoto inject;\n\n\tshake_page(hpage, 0);\n\t/*\n\t * This implies unable to support non-LRU pages.\n\t */\n\tif (!PageLRU(hpage) && !PageHuge(p))\n\t\tgoto put_out;\n\n\t/*\n\t * do a racy check with elevated page count, to make sure PG_hwpoison\n\t * will only be set for the targeted owner (or on a free page).\n\t * memory_failure() will redo the check reliably inside page lock.\n\t */\n\terr = hwpoison_filter(hpage);\n\tif (err)\n\t\tgoto put_out;\n\ninject:\n\tpr_info(\"Injecting memory failure at pfn %#lx\\n\", pfn);\n\treturn memory_failure(pfn, MF_COUNT_INCREASED);\nput_out:\n\tput_hwpoison_page(p);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/hugetlb.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_hwpoison_page",
          "args": [
            "p"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memory_failure",
          "args": [
            "pfn",
            "MF_COUNT_INCREASED"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "memory_failure_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "1455-1473",
          "snippet": "void memory_failure_queue(unsigned long pfn, int flags)\n{\n\tstruct memory_failure_cpu *mf_cpu;\n\tunsigned long proc_flags;\n\tstruct memory_failure_entry entry = {\n\t\t.pfn =\t\tpfn,\n\t\t.flags =\tflags,\n\t};\n\n\tmf_cpu = &get_cpu_var(memory_failure_cpu);\n\tspin_lock_irqsave(&mf_cpu->lock, proc_flags);\n\tif (kfifo_put(&mf_cpu->fifo, entry))\n\t\tschedule_work_on(smp_processor_id(), &mf_cpu->work);\n\telse\n\t\tpr_err(\"Memory failure: buffer overflow when queuing memory failure at %#lx\\n\",\n\t\t       pfn);\n\tspin_unlock_irqrestore(&mf_cpu->lock, proc_flags);\n\tput_cpu_var(memory_failure_cpu);\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct memory_failure_cpu, memory_failure_cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_PER_CPU(struct memory_failure_cpu, memory_failure_cpu);\n\nvoid memory_failure_queue(unsigned long pfn, int flags)\n{\n\tstruct memory_failure_cpu *mf_cpu;\n\tunsigned long proc_flags;\n\tstruct memory_failure_entry entry = {\n\t\t.pfn =\t\tpfn,\n\t\t.flags =\tflags,\n\t};\n\n\tmf_cpu = &get_cpu_var(memory_failure_cpu);\n\tspin_lock_irqsave(&mf_cpu->lock, proc_flags);\n\tif (kfifo_put(&mf_cpu->fifo, entry))\n\t\tschedule_work_on(smp_processor_id(), &mf_cpu->work);\n\telse\n\t\tpr_err(\"Memory failure: buffer overflow when queuing memory failure at %#lx\\n\",\n\t\t       pfn);\n\tspin_unlock_irqrestore(&mf_cpu->lock, proc_flags);\n\tput_cpu_var(memory_failure_cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Injecting memory failure at pfn %#lx\\n\"",
            "pfn"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hwpoison_filter",
          "args": [
            "hpage"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "hwpoison_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "170-173",
          "snippet": "int hwpoison_filter(struct page *p)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint hwpoison_filter(struct page *p)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "p"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "PageHugeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "225-228",
          "snippet": "static int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "hpage"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shake_page",
          "args": [
            "hpage",
            "0"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "shake_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "245-265",
          "snippet": "void shake_page(struct page *p, int access)\n{\n\tif (PageHuge(p))\n\t\treturn;\n\n\tif (!PageSlab(p)) {\n\t\tlru_add_drain_all();\n\t\tif (PageLRU(p))\n\t\t\treturn;\n\t\tdrain_all_pages(page_zone(p));\n\t\tif (PageLRU(p) || is_free_buddy_page(p))\n\t\t\treturn;\n\t}\n\n\t/*\n\t * Only call shrink_node_slabs here (which would also shrink\n\t * other caches) if access is not potentially fatal.\n\t */\n\tif (access)\n\t\tdrop_slab_node(page_to_nid(p));\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nvoid shake_page(struct page *p, int access)\n{\n\tif (PageHuge(p))\n\t\treturn;\n\n\tif (!PageSlab(p)) {\n\t\tlru_add_drain_all();\n\t\tif (PageLRU(p))\n\t\t\treturn;\n\t\tdrain_all_pages(page_zone(p));\n\t\tif (PageLRU(p) || is_free_buddy_page(p))\n\t\t\treturn;\n\t}\n\n\t/*\n\t * Only call shrink_node_slabs here (which would also shrink\n\t * other caches) if access is not potentially fatal.\n\t */\n\tif (access)\n\t\tdrop_slab_node(page_to_nid(p));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_hwpoison_page",
          "args": [
            "p"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "get_hwpoison_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "928-956",
          "snippet": "int get_hwpoison_page(struct page *page)\n{\n\tstruct page *head = compound_head(page);\n\n\tif (!PageHuge(head) && PageTransHuge(head)) {\n\t\t/*\n\t\t * Non anonymous thp exists only in allocation/free time. We\n\t\t * can't handle such a case correctly, so let's give it up.\n\t\t * This should be better than triggering BUG_ON when kernel\n\t\t * tries to touch the \"partially handled\" page.\n\t\t */\n\t\tif (!PageAnon(head)) {\n\t\t\tpr_err(\"Memory failure: %#lx: non anonymous thp\\n\",\n\t\t\t\tpage_to_pfn(page));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (get_page_unless_zero(head)) {\n\t\tif (head == compound_head(page))\n\t\t\treturn 1;\n\n\t\tpr_info(\"Memory failure: %#lx cannot catch tail\\n\",\n\t\t\tpage_to_pfn(page));\n\t\tput_page(head);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define head\t\t(1UL << PG_head)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define head\t\t(1UL << PG_head)\n\nint get_hwpoison_page(struct page *page)\n{\n\tstruct page *head = compound_head(page);\n\n\tif (!PageHuge(head) && PageTransHuge(head)) {\n\t\t/*\n\t\t * Non anonymous thp exists only in allocation/free time. We\n\t\t * can't handle such a case correctly, so let's give it up.\n\t\t * This should be better than triggering BUG_ON when kernel\n\t\t * tries to touch the \"partially handled\" page.\n\t\t */\n\t\tif (!PageAnon(head)) {\n\t\t\tpr_err(\"Memory failure: %#lx: non anonymous thp\\n\",\n\t\t\t\tpage_to_pfn(page));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (get_page_unless_zero(head)) {\n\t\tif (head == compound_head(page))\n\t\t\treturn 1;\n\n\t\tpr_info(\"Memory failure: %#lx cannot catch tail\\n\",\n\t\t\tpage_to_pfn(page));\n\t\tput_page(head);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "p"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "pfn"
          ],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 20
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n\nstatic int hwpoison_inject(void *data, u64 val)\n{\n\tunsigned long pfn = val;\n\tstruct page *p;\n\tstruct page *hpage;\n\tint err;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!pfn_valid(pfn))\n\t\treturn -ENXIO;\n\n\tp = pfn_to_page(pfn);\n\thpage = compound_head(p);\n\t/*\n\t * This implies unable to support free buddy pages.\n\t */\n\tif (!get_hwpoison_page(p))\n\t\treturn 0;\n\n\tif (!hwpoison_filter_enable)\n\t\tgoto inject;\n\n\tshake_page(hpage, 0);\n\t/*\n\t * This implies unable to support non-LRU pages.\n\t */\n\tif (!PageLRU(hpage) && !PageHuge(p))\n\t\tgoto put_out;\n\n\t/*\n\t * do a racy check with elevated page count, to make sure PG_hwpoison\n\t * will only be set for the targeted owner (or on a free page).\n\t * memory_failure() will redo the check reliably inside page lock.\n\t */\n\terr = hwpoison_filter(hpage);\n\tif (err)\n\t\tgoto put_out;\n\ninject:\n\tpr_info(\"Injecting memory failure at pfn %#lx\\n\", pfn);\n\treturn memory_failure(pfn, MF_COUNT_INCREASED);\nput_out:\n\tput_hwpoison_page(p);\n\treturn 0;\n}"
  }
]