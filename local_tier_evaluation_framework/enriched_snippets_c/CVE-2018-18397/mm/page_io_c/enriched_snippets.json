[
  {
    "function_name": "swap_set_page_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_io.c",
    "lines": "422-434",
    "snippet": "int swap_set_page_dirty(struct page *page)\n{\n\tstruct swap_info_struct *sis = page_swap_info(page);\n\n\tif (sis->flags & SWP_FS) {\n\t\tstruct address_space *mapping = sis->swap_file->f_mapping;\n\n\t\tVM_BUG_ON_PAGE(!PageSwapCache(page), page);\n\t\treturn mapping->a_ops->set_page_dirty(page);\n\t} else {\n\t\treturn __set_page_dirty_no_writeback(page);\n\t}\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/uio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/swapops.h>",
      "#include <linux/bio.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_page_dirty_no_writeback",
          "args": [
            "page"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "__set_page_dirty_no_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2380-2385",
          "snippet": "int __set_page_dirty_no_writeback(struct page *page)\n{\n\tif (!PageDirty(page))\n\t\treturn !TestSetPageDirty(page);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint __set_page_dirty_no_writeback(struct page *page)\n{\n\tif (!PageDirty(page))\n\t\treturn !TestSetPageDirty(page);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping->a_ops->set_page_dirty",
          "args": [
            "page"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2530-2560",
          "snippet": "int set_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\n\tpage = compound_head(page);\n\tif (likely(mapping)) {\n\t\tint (*spd)(struct page *) = mapping->a_ops->set_page_dirty;\n\t\t/*\n\t\t * readahead/lru_deactivate_page could remain\n\t\t * PG_readahead/PG_reclaim due to race with end_page_writeback\n\t\t * About readahead, if the page is written, the flags would be\n\t\t * reset. So no problem.\n\t\t * About lru_deactivate_page, if the page is redirty, the flag\n\t\t * will be reset. So no problem. but if the page is used by readahead\n\t\t * it will confuse readahead and make it restart the size rampup\n\t\t * process. But it's a trivial problem.\n\t\t */\n\t\tif (PageReclaim(page))\n\t\t\tClearPageReclaim(page);\n#ifdef CONFIG_BLOCK\n\t\tif (!spd)\n\t\t\tspd = __set_page_dirty_buffers;\n#endif\n\t\treturn (*spd)(page);\n\t}\n\tif (!PageDirty(page)) {\n\t\tif (!TestSetPageDirty(page))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint set_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page_mapping(page);\n\n\tpage = compound_head(page);\n\tif (likely(mapping)) {\n\t\tint (*spd)(struct page *) = mapping->a_ops->set_page_dirty;\n\t\t/*\n\t\t * readahead/lru_deactivate_page could remain\n\t\t * PG_readahead/PG_reclaim due to race with end_page_writeback\n\t\t * About readahead, if the page is written, the flags would be\n\t\t * reset. So no problem.\n\t\t * About lru_deactivate_page, if the page is redirty, the flag\n\t\t * will be reset. So no problem. but if the page is used by readahead\n\t\t * it will confuse readahead and make it restart the size rampup\n\t\t * process. But it's a trivial problem.\n\t\t */\n\t\tif (PageReclaim(page))\n\t\t\tClearPageReclaim(page);\n#ifdef CONFIG_BLOCK\n\t\tif (!spd)\n\t\t\tspd = __set_page_dirty_buffers;\n#endif\n\t\treturn (*spd)(page);\n\t}\n\tif (!PageDirty(page)) {\n\t\tif (!TestSetPageDirty(page))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageSwapCache(page)",
            "page"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_swap_info",
          "args": [
            "page"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "page_swap_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "3470-3474",
          "snippet": "struct swap_info_struct *page_swap_info(struct page *page)\n{\n\tswp_entry_t entry = { .val = page_private(page) };\n\treturn swp_swap_info(entry);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstruct swap_info_struct *page_swap_info(struct page *page)\n{\n\tswp_entry_t entry = { .val = page_private(page) };\n\treturn swp_swap_info(entry);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/sched/task.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/frontswap.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swapops.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/mm.h>\n\nint swap_set_page_dirty(struct page *page)\n{\n\tstruct swap_info_struct *sis = page_swap_info(page);\n\n\tif (sis->flags & SWP_FS) {\n\t\tstruct address_space *mapping = sis->swap_file->f_mapping;\n\n\t\tVM_BUG_ON_PAGE(!PageSwapCache(page), page);\n\t\treturn mapping->a_ops->set_page_dirty(page);\n\t} else {\n\t\treturn __set_page_dirty_no_writeback(page);\n\t}\n}"
  },
  {
    "function_name": "swap_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_io.c",
    "lines": "351-420",
    "snippet": "int swap_readpage(struct page *page, bool synchronous)\n{\n\tstruct bio *bio;\n\tint ret = 0;\n\tstruct swap_info_struct *sis = page_swap_info(page);\n\tblk_qc_t qc;\n\tstruct gendisk *disk;\n\n\tVM_BUG_ON_PAGE(!PageSwapCache(page) && !synchronous, page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(PageUptodate(page), page);\n\tif (frontswap_load(page) == 0) {\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\tgoto out;\n\t}\n\n\tif (sis->flags & SWP_FS) {\n\t\tstruct file *swap_file = sis->swap_file;\n\t\tstruct address_space *mapping = swap_file->f_mapping;\n\n\t\tret = mapping->a_ops->readpage(swap_file, page);\n\t\tif (!ret)\n\t\t\tcount_vm_event(PSWPIN);\n\t\treturn ret;\n\t}\n\n\tret = bdev_read_page(sis->bdev, swap_page_sector(page), page);\n\tif (!ret) {\n\t\tif (trylock_page(page)) {\n\t\t\tswap_slot_free_notify(page);\n\t\t\tunlock_page(page);\n\t\t}\n\n\t\tcount_vm_event(PSWPIN);\n\t\treturn 0;\n\t}\n\n\tret = 0;\n\tbio = get_swap_bio(GFP_KERNEL, page, end_swap_bio_read);\n\tif (bio == NULL) {\n\t\tunlock_page(page);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tdisk = bio->bi_disk;\n\t/*\n\t * Keep this task valid during swap readpage because the oom killer may\n\t * attempt to access it in the page fault retry time check.\n\t */\n\tget_task_struct(current);\n\tbio->bi_private = current;\n\tbio_set_op_attrs(bio, REQ_OP_READ, 0);\n\tcount_vm_event(PSWPIN);\n\tbio_get(bio);\n\tqc = submit_bio(bio);\n\twhile (synchronous) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (!READ_ONCE(bio->bi_private))\n\t\t\tbreak;\n\n\t\tif (!blk_poll(disk->queue, qc))\n\t\t\tbreak;\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tbio_put(bio);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/uio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/swapops.h>",
      "#include <linux/bio.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_poll",
          "args": [
            "disk->queue",
            "qc"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "bio->bi_private"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "submit_bio",
          "args": [
            "bio"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_get",
          "args": [
            "bio"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "PSWPIN"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_set_op_attrs",
          "args": [
            "bio",
            "REQ_OP_READ",
            "0"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "current"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_swap_bio",
          "args": [
            "GFP_KERNEL",
            "page",
            "end_swap_bio_read"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "get_swap_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_io.c",
          "lines": "29-49",
          "snippet": "static struct bio *get_swap_bio(gfp_t gfp_flags,\n\t\t\t\tstruct page *page, bio_end_io_t end_io)\n{\n\tint i, nr = hpage_nr_pages(page);\n\tstruct bio *bio;\n\n\tbio = bio_alloc(gfp_flags, nr);\n\tif (bio) {\n\t\tstruct block_device *bdev;\n\n\t\tbio->bi_iter.bi_sector = map_swap_page(page, &bdev);\n\t\tbio_set_dev(bio, bdev);\n\t\tbio->bi_iter.bi_sector <<= PAGE_SHIFT - 9;\n\t\tbio->bi_end_io = end_io;\n\n\t\tfor (i = 0; i < nr; i++)\n\t\t\tbio_add_page(bio, page + i, PAGE_SIZE, 0);\n\t\tVM_BUG_ON(bio->bi_iter.bi_size != PAGE_SIZE * nr);\n\t}\n\treturn bio;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/swapops.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/sched/task.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/frontswap.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swapops.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/mm.h>\n\nstatic struct bio *get_swap_bio(gfp_t gfp_flags,\n\t\t\t\tstruct page *page, bio_end_io_t end_io)\n{\n\tint i, nr = hpage_nr_pages(page);\n\tstruct bio *bio;\n\n\tbio = bio_alloc(gfp_flags, nr);\n\tif (bio) {\n\t\tstruct block_device *bdev;\n\n\t\tbio->bi_iter.bi_sector = map_swap_page(page, &bdev);\n\t\tbio_set_dev(bio, bdev);\n\t\tbio->bi_iter.bi_sector <<= PAGE_SHIFT - 9;\n\t\tbio->bi_end_io = end_io;\n\n\t\tfor (i = 0; i < nr; i++)\n\t\t\tbio_add_page(bio, page + i, PAGE_SIZE, 0);\n\t\tVM_BUG_ON(bio->bi_iter.bi_size != PAGE_SIZE * nr);\n\t}\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "PSWPIN"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_slot_free_notify",
          "args": [
            "page"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "swap_slot_free_notify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_io.c",
          "lines": "75-121",
          "snippet": "static void swap_slot_free_notify(struct page *page)\n{\n\tstruct swap_info_struct *sis;\n\tstruct gendisk *disk;\n\n\t/*\n\t * There is no guarantee that the page is in swap cache - the software\n\t * suspend code (at least) uses end_swap_bio_read() against a non-\n\t * swapcache page.  So we must check PG_swapcache before proceeding with\n\t * this optimization.\n\t */\n\tif (unlikely(!PageSwapCache(page)))\n\t\treturn;\n\n\tsis = page_swap_info(page);\n\tif (!(sis->flags & SWP_BLKDEV))\n\t\treturn;\n\n\t/*\n\t * The swap subsystem performs lazy swap slot freeing,\n\t * expecting that the page will be swapped out again.\n\t * So we can avoid an unnecessary write if the page\n\t * isn't redirtied.\n\t * This is good for real swap storage because we can\n\t * reduce unnecessary I/O and enhance wear-leveling\n\t * if an SSD is used as the as swap device.\n\t * But if in-memory swap device (eg zram) is used,\n\t * this causes a duplicated copy between uncompressed\n\t * data in VM-owned memory and compressed data in\n\t * zram-owned memory.  So let's free zram-owned memory\n\t * and make the VM-owned decompressed page *dirty*,\n\t * so the page should be swapped out somewhere again if\n\t * we again wish to reclaim it.\n\t */\n\tdisk = sis->bdev->bd_disk;\n\tif (disk->fops->swap_slot_free_notify) {\n\t\tswp_entry_t entry;\n\t\tunsigned long offset;\n\n\t\tentry.val = page_private(page);\n\t\toffset = swp_offset(entry);\n\n\t\tSetPageDirty(page);\n\t\tdisk->fops->swap_slot_free_notify(sis->bdev,\n\t\t\t\toffset);\n\t}\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/swapops.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/sched/task.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/frontswap.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swapops.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/mm.h>\n\nstatic void swap_slot_free_notify(struct page *page)\n{\n\tstruct swap_info_struct *sis;\n\tstruct gendisk *disk;\n\n\t/*\n\t * There is no guarantee that the page is in swap cache - the software\n\t * suspend code (at least) uses end_swap_bio_read() against a non-\n\t * swapcache page.  So we must check PG_swapcache before proceeding with\n\t * this optimization.\n\t */\n\tif (unlikely(!PageSwapCache(page)))\n\t\treturn;\n\n\tsis = page_swap_info(page);\n\tif (!(sis->flags & SWP_BLKDEV))\n\t\treturn;\n\n\t/*\n\t * The swap subsystem performs lazy swap slot freeing,\n\t * expecting that the page will be swapped out again.\n\t * So we can avoid an unnecessary write if the page\n\t * isn't redirtied.\n\t * This is good for real swap storage because we can\n\t * reduce unnecessary I/O and enhance wear-leveling\n\t * if an SSD is used as the as swap device.\n\t * But if in-memory swap device (eg zram) is used,\n\t * this causes a duplicated copy between uncompressed\n\t * data in VM-owned memory and compressed data in\n\t * zram-owned memory.  So let's free zram-owned memory\n\t * and make the VM-owned decompressed page *dirty*,\n\t * so the page should be swapped out somewhere again if\n\t * we again wish to reclaim it.\n\t */\n\tdisk = sis->bdev->bd_disk;\n\tif (disk->fops->swap_slot_free_notify) {\n\t\tswp_entry_t entry;\n\t\tunsigned long offset;\n\n\t\tentry.val = page_private(page);\n\t\toffset = swp_offset(entry);\n\n\t\tSetPageDirty(page);\n\t\tdisk->fops->swap_slot_free_notify(sis->bdev,\n\t\t\t\toffset);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_read_page",
          "args": [
            "sis->bdev",
            "swap_page_sector(page)",
            "page"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_page_sector",
          "args": [
            "page"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "swap_page_sector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_io.c",
          "lines": "264-267",
          "snippet": "static sector_t swap_page_sector(struct page *page)\n{\n\treturn (sector_t)__page_file_index(page) << (PAGE_SHIFT - 9);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/swapops.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/sched/task.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/frontswap.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swapops.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/mm.h>\n\nstatic sector_t swap_page_sector(struct page *page)\n{\n\treturn (sector_t)__page_file_index(page) << (PAGE_SHIFT - 9);\n}"
        }
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "PSWPIN"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping->a_ops->readpage",
          "args": [
            "swap_file",
            "page"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "frontswap_load",
          "args": [
            "page"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "__frontswap_load",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
          "lines": "295-325",
          "snippet": "int __frontswap_load(struct page *page)\n{\n\tint ret = -1;\n\tswp_entry_t entry = { .val = page_private(page), };\n\tint type = swp_type(entry);\n\tstruct swap_info_struct *sis = swap_info[type];\n\tpgoff_t offset = swp_offset(entry);\n\tstruct frontswap_ops *ops;\n\n\tVM_BUG_ON(!frontswap_ops);\n\tVM_BUG_ON(!PageLocked(page));\n\tVM_BUG_ON(sis == NULL);\n\n\tif (!__frontswap_test(sis, offset))\n\t\treturn -1;\n\n\t/* Try loading from each implementation, until one succeeds. */\n\tfor_each_frontswap_ops(ops) {\n\t\tret = ops->load(type, offset, page);\n\t\tif (!ret) /* successful load */\n\t\t\tbreak;\n\t}\n\tif (ret == 0) {\n\t\tinc_frontswap_loads();\n\t\tif (frontswap_tmem_exclusive_gets_enabled) {\n\t\t\tSetPageDirty(page);\n\t\t\t__frontswap_clear(sis, offset);\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct frontswap_ops *frontswap_ops",
            "static bool frontswap_tmem_exclusive_gets_enabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nstatic struct frontswap_ops *frontswap_ops;\nstatic bool frontswap_tmem_exclusive_gets_enabled;\n\nint __frontswap_load(struct page *page)\n{\n\tint ret = -1;\n\tswp_entry_t entry = { .val = page_private(page), };\n\tint type = swp_type(entry);\n\tstruct swap_info_struct *sis = swap_info[type];\n\tpgoff_t offset = swp_offset(entry);\n\tstruct frontswap_ops *ops;\n\n\tVM_BUG_ON(!frontswap_ops);\n\tVM_BUG_ON(!PageLocked(page));\n\tVM_BUG_ON(sis == NULL);\n\n\tif (!__frontswap_test(sis, offset))\n\t\treturn -1;\n\n\t/* Try loading from each implementation, until one succeeds. */\n\tfor_each_frontswap_ops(ops) {\n\t\tret = ops->load(type, offset, page);\n\t\tif (!ret) /* successful load */\n\t\t\tbreak;\n\t}\n\tif (ret == 0) {\n\t\tinc_frontswap_loads();\n\t\tif (frontswap_tmem_exclusive_gets_enabled) {\n\t\t\tSetPageDirty(page);\n\t\t\t__frontswap_clear(sis, offset);\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageUptodate(page)",
            "page"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLocked(page)",
            "page"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageSwapCache(page) && !synchronous",
            "page"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_swap_info",
          "args": [
            "page"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "page_swap_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "3470-3474",
          "snippet": "struct swap_info_struct *page_swap_info(struct page *page)\n{\n\tswp_entry_t entry = { .val = page_private(page) };\n\treturn swp_swap_info(entry);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstruct swap_info_struct *page_swap_info(struct page *page)\n{\n\tswp_entry_t entry = { .val = page_private(page) };\n\treturn swp_swap_info(entry);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/sched/task.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/frontswap.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swapops.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/mm.h>\n\nint swap_readpage(struct page *page, bool synchronous)\n{\n\tstruct bio *bio;\n\tint ret = 0;\n\tstruct swap_info_struct *sis = page_swap_info(page);\n\tblk_qc_t qc;\n\tstruct gendisk *disk;\n\n\tVM_BUG_ON_PAGE(!PageSwapCache(page) && !synchronous, page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(PageUptodate(page), page);\n\tif (frontswap_load(page) == 0) {\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\tgoto out;\n\t}\n\n\tif (sis->flags & SWP_FS) {\n\t\tstruct file *swap_file = sis->swap_file;\n\t\tstruct address_space *mapping = swap_file->f_mapping;\n\n\t\tret = mapping->a_ops->readpage(swap_file, page);\n\t\tif (!ret)\n\t\t\tcount_vm_event(PSWPIN);\n\t\treturn ret;\n\t}\n\n\tret = bdev_read_page(sis->bdev, swap_page_sector(page), page);\n\tif (!ret) {\n\t\tif (trylock_page(page)) {\n\t\t\tswap_slot_free_notify(page);\n\t\t\tunlock_page(page);\n\t\t}\n\n\t\tcount_vm_event(PSWPIN);\n\t\treturn 0;\n\t}\n\n\tret = 0;\n\tbio = get_swap_bio(GFP_KERNEL, page, end_swap_bio_read);\n\tif (bio == NULL) {\n\t\tunlock_page(page);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tdisk = bio->bi_disk;\n\t/*\n\t * Keep this task valid during swap readpage because the oom killer may\n\t * attempt to access it in the page fault retry time check.\n\t */\n\tget_task_struct(current);\n\tbio->bi_private = current;\n\tbio_set_op_attrs(bio, REQ_OP_READ, 0);\n\tcount_vm_event(PSWPIN);\n\tbio_get(bio);\n\tqc = submit_bio(bio);\n\twhile (synchronous) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (!READ_ONCE(bio->bi_private))\n\t\t\tbreak;\n\n\t\tif (!blk_poll(disk->queue, qc))\n\t\t\tbreak;\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tbio_put(bio);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "__swap_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_io.c",
    "lines": "278-349",
    "snippet": "int __swap_writepage(struct page *page, struct writeback_control *wbc,\n\t\tbio_end_io_t end_write_func)\n{\n\tstruct bio *bio;\n\tint ret;\n\tstruct swap_info_struct *sis = page_swap_info(page);\n\n\tVM_BUG_ON_PAGE(!PageSwapCache(page), page);\n\tif (sis->flags & SWP_FS) {\n\t\tstruct kiocb kiocb;\n\t\tstruct file *swap_file = sis->swap_file;\n\t\tstruct address_space *mapping = swap_file->f_mapping;\n\t\tstruct bio_vec bv = {\n\t\t\t.bv_page = page,\n\t\t\t.bv_len  = PAGE_SIZE,\n\t\t\t.bv_offset = 0\n\t\t};\n\t\tstruct iov_iter from;\n\n\t\tiov_iter_bvec(&from, WRITE, &bv, 1, PAGE_SIZE);\n\t\tinit_sync_kiocb(&kiocb, swap_file);\n\t\tkiocb.ki_pos = page_file_offset(page);\n\n\t\tset_page_writeback(page);\n\t\tunlock_page(page);\n\t\tret = mapping->a_ops->direct_IO(&kiocb, &from);\n\t\tif (ret == PAGE_SIZE) {\n\t\t\tcount_vm_event(PSWPOUT);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * In the case of swap-over-nfs, this can be a\n\t\t\t * temporary failure if the system has limited\n\t\t\t * memory for allocating transmit buffers.\n\t\t\t * Mark the page dirty and avoid\n\t\t\t * rotate_reclaimable_page but rate-limit the\n\t\t\t * messages but do not flag PageError like\n\t\t\t * the normal direct-to-bio case as it could\n\t\t\t * be temporary.\n\t\t\t */\n\t\t\tset_page_dirty(page);\n\t\t\tClearPageReclaim(page);\n\t\t\tpr_err_ratelimited(\"Write error on dio swapfile (%llu)\\n\",\n\t\t\t\t\t   page_file_offset(page));\n\t\t}\n\t\tend_page_writeback(page);\n\t\treturn ret;\n\t}\n\n\tret = bdev_write_page(sis->bdev, swap_page_sector(page), page, wbc);\n\tif (!ret) {\n\t\tcount_swpout_vm_event(page);\n\t\treturn 0;\n\t}\n\n\tret = 0;\n\tbio = get_swap_bio(GFP_NOIO, page, end_write_func);\n\tif (bio == NULL) {\n\t\tset_page_dirty(page);\n\t\tunlock_page(page);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tbio->bi_opf = REQ_OP_WRITE | REQ_SWAP | wbc_to_write_flags(wbc);\n\tbio_associate_blkcg_from_page(bio, page);\n\tcount_swpout_vm_event(page);\n\tset_page_writeback(page);\n\tunlock_page(page);\n\tsubmit_bio(bio);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/uio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/swapops.h>",
      "#include <linux/bio.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "submit_bio",
          "args": [
            "bio"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_writeback",
          "args": [
            "page"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_swpout_vm_event",
          "args": [
            "page"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "count_swpout_vm_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_io.c",
          "lines": "269-276",
          "snippet": "static inline void count_swpout_vm_event(struct page *page)\n{\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tif (unlikely(PageTransHuge(page)))\n\t\tcount_vm_event(THP_SWPOUT);\n#endif\n\tcount_vm_events(PSWPOUT, hpage_nr_pages(page));\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/swapops.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/sched/task.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/frontswap.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swapops.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/mm.h>\n\nstatic inline void count_swpout_vm_event(struct page *page)\n{\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tif (unlikely(PageTransHuge(page)))\n\t\tcount_vm_event(THP_SWPOUT);\n#endif\n\tcount_vm_events(PSWPOUT, hpage_nr_pages(page));\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_associate_blkcg_from_page",
          "args": [
            "bio",
            "page"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wbc_to_write_flags",
          "args": [
            "wbc"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "swap_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_io.c",
          "lines": "422-434",
          "snippet": "int swap_set_page_dirty(struct page *page)\n{\n\tstruct swap_info_struct *sis = page_swap_info(page);\n\n\tif (sis->flags & SWP_FS) {\n\t\tstruct address_space *mapping = sis->swap_file->f_mapping;\n\n\t\tVM_BUG_ON_PAGE(!PageSwapCache(page), page);\n\t\treturn mapping->a_ops->set_page_dirty(page);\n\t} else {\n\t\treturn __set_page_dirty_no_writeback(page);\n\t}\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/swapops.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/sched/task.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/frontswap.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swapops.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/mm.h>\n\nint swap_set_page_dirty(struct page *page)\n{\n\tstruct swap_info_struct *sis = page_swap_info(page);\n\n\tif (sis->flags & SWP_FS) {\n\t\tstruct address_space *mapping = sis->swap_file->f_mapping;\n\n\t\tVM_BUG_ON_PAGE(!PageSwapCache(page), page);\n\t\treturn mapping->a_ops->set_page_dirty(page);\n\t} else {\n\t\treturn __set_page_dirty_no_writeback(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_swap_bio",
          "args": [
            "GFP_NOIO",
            "page",
            "end_write_func"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "get_swap_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_io.c",
          "lines": "29-49",
          "snippet": "static struct bio *get_swap_bio(gfp_t gfp_flags,\n\t\t\t\tstruct page *page, bio_end_io_t end_io)\n{\n\tint i, nr = hpage_nr_pages(page);\n\tstruct bio *bio;\n\n\tbio = bio_alloc(gfp_flags, nr);\n\tif (bio) {\n\t\tstruct block_device *bdev;\n\n\t\tbio->bi_iter.bi_sector = map_swap_page(page, &bdev);\n\t\tbio_set_dev(bio, bdev);\n\t\tbio->bi_iter.bi_sector <<= PAGE_SHIFT - 9;\n\t\tbio->bi_end_io = end_io;\n\n\t\tfor (i = 0; i < nr; i++)\n\t\t\tbio_add_page(bio, page + i, PAGE_SIZE, 0);\n\t\tVM_BUG_ON(bio->bi_iter.bi_size != PAGE_SIZE * nr);\n\t}\n\treturn bio;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/swapops.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/sched/task.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/frontswap.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swapops.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/mm.h>\n\nstatic struct bio *get_swap_bio(gfp_t gfp_flags,\n\t\t\t\tstruct page *page, bio_end_io_t end_io)\n{\n\tint i, nr = hpage_nr_pages(page);\n\tstruct bio *bio;\n\n\tbio = bio_alloc(gfp_flags, nr);\n\tif (bio) {\n\t\tstruct block_device *bdev;\n\n\t\tbio->bi_iter.bi_sector = map_swap_page(page, &bdev);\n\t\tbio_set_dev(bio, bdev);\n\t\tbio->bi_iter.bi_sector <<= PAGE_SHIFT - 9;\n\t\tbio->bi_end_io = end_io;\n\n\t\tfor (i = 0; i < nr; i++)\n\t\t\tbio_add_page(bio, page + i, PAGE_SIZE, 0);\n\t\tVM_BUG_ON(bio->bi_iter.bi_size != PAGE_SIZE * nr);\n\t}\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_write_page",
          "args": [
            "sis->bdev",
            "swap_page_sector(page)",
            "page",
            "wbc"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_page_sector",
          "args": [
            "page"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "swap_page_sector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_io.c",
          "lines": "264-267",
          "snippet": "static sector_t swap_page_sector(struct page *page)\n{\n\treturn (sector_t)__page_file_index(page) << (PAGE_SHIFT - 9);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/swapops.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/sched/task.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/frontswap.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swapops.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/mm.h>\n\nstatic sector_t swap_page_sector(struct page *page)\n{\n\treturn (sector_t)__page_file_index(page) << (PAGE_SHIFT - 9);\n}"
        }
      },
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "page"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1209-1228",
          "snippet": "void end_page_writeback(struct page *page)\n{\n\t/*\n\t * TestClearPageReclaim could be used here but it is an atomic\n\t * operation and overkill in this particular case. Failing to\n\t * shuffle a page marked for immediate reclaim is too mild to\n\t * justify taking an atomic operation penalty at the end of\n\t * ever page writeback.\n\t */\n\tif (PageReclaim(page)) {\n\t\tClearPageReclaim(page);\n\t\trotate_reclaimable_page(page);\n\t}\n\n\tif (!test_clear_page_writeback(page))\n\t\tBUG();\n\n\tsmp_mb__after_atomic();\n\twake_up_page(page, PG_writeback);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nvoid end_page_writeback(struct page *page)\n{\n\t/*\n\t * TestClearPageReclaim could be used here but it is an atomic\n\t * operation and overkill in this particular case. Failing to\n\t * shuffle a page marked for immediate reclaim is too mild to\n\t * justify taking an atomic operation penalty at the end of\n\t * ever page writeback.\n\t */\n\tif (PageReclaim(page)) {\n\t\tClearPageReclaim(page);\n\t\trotate_reclaimable_page(page);\n\t}\n\n\tif (!test_clear_page_writeback(page))\n\t\tBUG();\n\n\tsmp_mb__after_atomic();\n\twake_up_page(page, PG_writeback);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err_ratelimited",
          "args": [
            "\"Write error on dio swapfile (%llu)\\n\"",
            "page_file_offset(page)"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_file_offset",
          "args": [
            "page"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageReclaim",
          "args": [
            "page"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "PSWPOUT"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping->a_ops->direct_IO",
          "args": [
            "&kiocb",
            "&from"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_writeback",
          "args": [
            "page"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_file_offset",
          "args": [
            "page"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_sync_kiocb",
          "args": [
            "&kiocb",
            "swap_file"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_bvec",
          "args": [
            "&from",
            "WRITE",
            "&bv",
            "1",
            "PAGE_SIZE"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageSwapCache(page)",
            "page"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_swap_info",
          "args": [
            "page"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "page_swap_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "3470-3474",
          "snippet": "struct swap_info_struct *page_swap_info(struct page *page)\n{\n\tswp_entry_t entry = { .val = page_private(page) };\n\treturn swp_swap_info(entry);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstruct swap_info_struct *page_swap_info(struct page *page)\n{\n\tswp_entry_t entry = { .val = page_private(page) };\n\treturn swp_swap_info(entry);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/sched/task.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/frontswap.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swapops.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/mm.h>\n\nint __swap_writepage(struct page *page, struct writeback_control *wbc,\n\t\tbio_end_io_t end_write_func)\n{\n\tstruct bio *bio;\n\tint ret;\n\tstruct swap_info_struct *sis = page_swap_info(page);\n\n\tVM_BUG_ON_PAGE(!PageSwapCache(page), page);\n\tif (sis->flags & SWP_FS) {\n\t\tstruct kiocb kiocb;\n\t\tstruct file *swap_file = sis->swap_file;\n\t\tstruct address_space *mapping = swap_file->f_mapping;\n\t\tstruct bio_vec bv = {\n\t\t\t.bv_page = page,\n\t\t\t.bv_len  = PAGE_SIZE,\n\t\t\t.bv_offset = 0\n\t\t};\n\t\tstruct iov_iter from;\n\n\t\tiov_iter_bvec(&from, WRITE, &bv, 1, PAGE_SIZE);\n\t\tinit_sync_kiocb(&kiocb, swap_file);\n\t\tkiocb.ki_pos = page_file_offset(page);\n\n\t\tset_page_writeback(page);\n\t\tunlock_page(page);\n\t\tret = mapping->a_ops->direct_IO(&kiocb, &from);\n\t\tif (ret == PAGE_SIZE) {\n\t\t\tcount_vm_event(PSWPOUT);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * In the case of swap-over-nfs, this can be a\n\t\t\t * temporary failure if the system has limited\n\t\t\t * memory for allocating transmit buffers.\n\t\t\t * Mark the page dirty and avoid\n\t\t\t * rotate_reclaimable_page but rate-limit the\n\t\t\t * messages but do not flag PageError like\n\t\t\t * the normal direct-to-bio case as it could\n\t\t\t * be temporary.\n\t\t\t */\n\t\t\tset_page_dirty(page);\n\t\t\tClearPageReclaim(page);\n\t\t\tpr_err_ratelimited(\"Write error on dio swapfile (%llu)\\n\",\n\t\t\t\t\t   page_file_offset(page));\n\t\t}\n\t\tend_page_writeback(page);\n\t\treturn ret;\n\t}\n\n\tret = bdev_write_page(sis->bdev, swap_page_sector(page), page, wbc);\n\tif (!ret) {\n\t\tcount_swpout_vm_event(page);\n\t\treturn 0;\n\t}\n\n\tret = 0;\n\tbio = get_swap_bio(GFP_NOIO, page, end_write_func);\n\tif (bio == NULL) {\n\t\tset_page_dirty(page);\n\t\tunlock_page(page);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tbio->bi_opf = REQ_OP_WRITE | REQ_SWAP | wbc_to_write_flags(wbc);\n\tbio_associate_blkcg_from_page(bio, page);\n\tcount_swpout_vm_event(page);\n\tset_page_writeback(page);\n\tunlock_page(page);\n\tsubmit_bio(bio);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "count_swpout_vm_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_io.c",
    "lines": "269-276",
    "snippet": "static inline void count_swpout_vm_event(struct page *page)\n{\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tif (unlikely(PageTransHuge(page)))\n\t\tcount_vm_event(THP_SWPOUT);\n#endif\n\tcount_vm_events(PSWPOUT, hpage_nr_pages(page));\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/uio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/swapops.h>",
      "#include <linux/bio.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "count_vm_events",
          "args": [
            "PSWPOUT",
            "hpage_nr_pages(page)"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "page"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "THP_SWPOUT"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "PageTransHuge(page)"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "page"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/sched/task.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/frontswap.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swapops.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/mm.h>\n\nstatic inline void count_swpout_vm_event(struct page *page)\n{\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tif (unlikely(PageTransHuge(page)))\n\t\tcount_vm_event(THP_SWPOUT);\n#endif\n\tcount_vm_events(PSWPOUT, hpage_nr_pages(page));\n}"
  },
  {
    "function_name": "swap_page_sector",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_io.c",
    "lines": "264-267",
    "snippet": "static sector_t swap_page_sector(struct page *page)\n{\n\treturn (sector_t)__page_file_index(page) << (PAGE_SHIFT - 9);\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/uio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/swapops.h>",
      "#include <linux/bio.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__page_file_index",
          "args": [
            "page"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "__page_file_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "3485-3489",
          "snippet": "pgoff_t __page_file_index(struct page *page)\n{\n\tswp_entry_t swap = { .val = page_private(page) };\n\treturn swp_offset(swap);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic bool swap_count_continued(struct swap_info_struct *, pgoff_t,\n\t\t\t\t unsigned char);\n\npgoff_t __page_file_index(struct page *page)\n{\n\tswp_entry_t swap = { .val = page_private(page) };\n\treturn swp_offset(swap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/sched/task.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/frontswap.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swapops.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/mm.h>\n\nstatic sector_t swap_page_sector(struct page *page)\n{\n\treturn (sector_t)__page_file_index(page) << (PAGE_SHIFT - 9);\n}"
  },
  {
    "function_name": "swap_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_io.c",
    "lines": "245-262",
    "snippet": "int swap_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tint ret = 0;\n\n\tif (try_to_free_swap(page)) {\n\t\tunlock_page(page);\n\t\tgoto out;\n\t}\n\tif (frontswap_store(page) == 0) {\n\t\tset_page_writeback(page);\n\t\tunlock_page(page);\n\t\tend_page_writeback(page);\n\t\tgoto out;\n\t}\n\tret = __swap_writepage(page, wbc, end_swap_bio_write);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/uio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/swapops.h>",
      "#include <linux/bio.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__swap_writepage",
          "args": [
            "page",
            "wbc",
            "end_swap_bio_write"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "__swap_writepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_io.c",
          "lines": "278-349",
          "snippet": "int __swap_writepage(struct page *page, struct writeback_control *wbc,\n\t\tbio_end_io_t end_write_func)\n{\n\tstruct bio *bio;\n\tint ret;\n\tstruct swap_info_struct *sis = page_swap_info(page);\n\n\tVM_BUG_ON_PAGE(!PageSwapCache(page), page);\n\tif (sis->flags & SWP_FS) {\n\t\tstruct kiocb kiocb;\n\t\tstruct file *swap_file = sis->swap_file;\n\t\tstruct address_space *mapping = swap_file->f_mapping;\n\t\tstruct bio_vec bv = {\n\t\t\t.bv_page = page,\n\t\t\t.bv_len  = PAGE_SIZE,\n\t\t\t.bv_offset = 0\n\t\t};\n\t\tstruct iov_iter from;\n\n\t\tiov_iter_bvec(&from, WRITE, &bv, 1, PAGE_SIZE);\n\t\tinit_sync_kiocb(&kiocb, swap_file);\n\t\tkiocb.ki_pos = page_file_offset(page);\n\n\t\tset_page_writeback(page);\n\t\tunlock_page(page);\n\t\tret = mapping->a_ops->direct_IO(&kiocb, &from);\n\t\tif (ret == PAGE_SIZE) {\n\t\t\tcount_vm_event(PSWPOUT);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * In the case of swap-over-nfs, this can be a\n\t\t\t * temporary failure if the system has limited\n\t\t\t * memory for allocating transmit buffers.\n\t\t\t * Mark the page dirty and avoid\n\t\t\t * rotate_reclaimable_page but rate-limit the\n\t\t\t * messages but do not flag PageError like\n\t\t\t * the normal direct-to-bio case as it could\n\t\t\t * be temporary.\n\t\t\t */\n\t\t\tset_page_dirty(page);\n\t\t\tClearPageReclaim(page);\n\t\t\tpr_err_ratelimited(\"Write error on dio swapfile (%llu)\\n\",\n\t\t\t\t\t   page_file_offset(page));\n\t\t}\n\t\tend_page_writeback(page);\n\t\treturn ret;\n\t}\n\n\tret = bdev_write_page(sis->bdev, swap_page_sector(page), page, wbc);\n\tif (!ret) {\n\t\tcount_swpout_vm_event(page);\n\t\treturn 0;\n\t}\n\n\tret = 0;\n\tbio = get_swap_bio(GFP_NOIO, page, end_write_func);\n\tif (bio == NULL) {\n\t\tset_page_dirty(page);\n\t\tunlock_page(page);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tbio->bi_opf = REQ_OP_WRITE | REQ_SWAP | wbc_to_write_flags(wbc);\n\tbio_associate_blkcg_from_page(bio, page);\n\tcount_swpout_vm_event(page);\n\tset_page_writeback(page);\n\tunlock_page(page);\n\tsubmit_bio(bio);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/swapops.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/sched/task.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/frontswap.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swapops.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/mm.h>\n\nint __swap_writepage(struct page *page, struct writeback_control *wbc,\n\t\tbio_end_io_t end_write_func)\n{\n\tstruct bio *bio;\n\tint ret;\n\tstruct swap_info_struct *sis = page_swap_info(page);\n\n\tVM_BUG_ON_PAGE(!PageSwapCache(page), page);\n\tif (sis->flags & SWP_FS) {\n\t\tstruct kiocb kiocb;\n\t\tstruct file *swap_file = sis->swap_file;\n\t\tstruct address_space *mapping = swap_file->f_mapping;\n\t\tstruct bio_vec bv = {\n\t\t\t.bv_page = page,\n\t\t\t.bv_len  = PAGE_SIZE,\n\t\t\t.bv_offset = 0\n\t\t};\n\t\tstruct iov_iter from;\n\n\t\tiov_iter_bvec(&from, WRITE, &bv, 1, PAGE_SIZE);\n\t\tinit_sync_kiocb(&kiocb, swap_file);\n\t\tkiocb.ki_pos = page_file_offset(page);\n\n\t\tset_page_writeback(page);\n\t\tunlock_page(page);\n\t\tret = mapping->a_ops->direct_IO(&kiocb, &from);\n\t\tif (ret == PAGE_SIZE) {\n\t\t\tcount_vm_event(PSWPOUT);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * In the case of swap-over-nfs, this can be a\n\t\t\t * temporary failure if the system has limited\n\t\t\t * memory for allocating transmit buffers.\n\t\t\t * Mark the page dirty and avoid\n\t\t\t * rotate_reclaimable_page but rate-limit the\n\t\t\t * messages but do not flag PageError like\n\t\t\t * the normal direct-to-bio case as it could\n\t\t\t * be temporary.\n\t\t\t */\n\t\t\tset_page_dirty(page);\n\t\t\tClearPageReclaim(page);\n\t\t\tpr_err_ratelimited(\"Write error on dio swapfile (%llu)\\n\",\n\t\t\t\t\t   page_file_offset(page));\n\t\t}\n\t\tend_page_writeback(page);\n\t\treturn ret;\n\t}\n\n\tret = bdev_write_page(sis->bdev, swap_page_sector(page), page, wbc);\n\tif (!ret) {\n\t\tcount_swpout_vm_event(page);\n\t\treturn 0;\n\t}\n\n\tret = 0;\n\tbio = get_swap_bio(GFP_NOIO, page, end_write_func);\n\tif (bio == NULL) {\n\t\tset_page_dirty(page);\n\t\tunlock_page(page);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tbio->bi_opf = REQ_OP_WRITE | REQ_SWAP | wbc_to_write_flags(wbc);\n\tbio_associate_blkcg_from_page(bio, page);\n\tcount_swpout_vm_event(page);\n\tset_page_writeback(page);\n\tunlock_page(page);\n\tsubmit_bio(bio);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "page"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1209-1228",
          "snippet": "void end_page_writeback(struct page *page)\n{\n\t/*\n\t * TestClearPageReclaim could be used here but it is an atomic\n\t * operation and overkill in this particular case. Failing to\n\t * shuffle a page marked for immediate reclaim is too mild to\n\t * justify taking an atomic operation penalty at the end of\n\t * ever page writeback.\n\t */\n\tif (PageReclaim(page)) {\n\t\tClearPageReclaim(page);\n\t\trotate_reclaimable_page(page);\n\t}\n\n\tif (!test_clear_page_writeback(page))\n\t\tBUG();\n\n\tsmp_mb__after_atomic();\n\twake_up_page(page, PG_writeback);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nvoid end_page_writeback(struct page *page)\n{\n\t/*\n\t * TestClearPageReclaim could be used here but it is an atomic\n\t * operation and overkill in this particular case. Failing to\n\t * shuffle a page marked for immediate reclaim is too mild to\n\t * justify taking an atomic operation penalty at the end of\n\t * ever page writeback.\n\t */\n\tif (PageReclaim(page)) {\n\t\tClearPageReclaim(page);\n\t\trotate_reclaimable_page(page);\n\t}\n\n\tif (!test_clear_page_writeback(page))\n\t\tBUG();\n\n\tsmp_mb__after_atomic();\n\twake_up_page(page, PG_writeback);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_writeback",
          "args": [
            "page"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "frontswap_store",
          "args": [
            "page"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "__frontswap_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/frontswap.c",
          "lines": "246-287",
          "snippet": "int __frontswap_store(struct page *page)\n{\n\tint ret = -1;\n\tswp_entry_t entry = { .val = page_private(page), };\n\tint type = swp_type(entry);\n\tstruct swap_info_struct *sis = swap_info[type];\n\tpgoff_t offset = swp_offset(entry);\n\tstruct frontswap_ops *ops;\n\n\tVM_BUG_ON(!frontswap_ops);\n\tVM_BUG_ON(!PageLocked(page));\n\tVM_BUG_ON(sis == NULL);\n\n\t/*\n\t * If a dup, we must remove the old page first; we can't leave the\n\t * old page no matter if the store of the new page succeeds or fails,\n\t * and we can't rely on the new page replacing the old page as we may\n\t * not store to the same implementation that contains the old page.\n\t */\n\tif (__frontswap_test(sis, offset)) {\n\t\t__frontswap_clear(sis, offset);\n\t\tfor_each_frontswap_ops(ops)\n\t\t\tops->invalidate_page(type, offset);\n\t}\n\n\t/* Try to store in each implementation, until one succeeds. */\n\tfor_each_frontswap_ops(ops) {\n\t\tret = ops->store(type, offset, page);\n\t\tif (!ret) /* successful store */\n\t\t\tbreak;\n\t}\n\tif (ret == 0) {\n\t\t__frontswap_set(sis, offset);\n\t\tinc_frontswap_succ_stores();\n\t} else {\n\t\tinc_frontswap_failed_stores();\n\t}\n\tif (frontswap_writethrough_enabled)\n\t\t/* report failure so swap also writes to swap device */\n\t\tret = -1;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct frontswap_ops *frontswap_ops",
            "static bool frontswap_writethrough_enabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/security.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n\nstatic struct frontswap_ops *frontswap_ops;\nstatic bool frontswap_writethrough_enabled;\n\nint __frontswap_store(struct page *page)\n{\n\tint ret = -1;\n\tswp_entry_t entry = { .val = page_private(page), };\n\tint type = swp_type(entry);\n\tstruct swap_info_struct *sis = swap_info[type];\n\tpgoff_t offset = swp_offset(entry);\n\tstruct frontswap_ops *ops;\n\n\tVM_BUG_ON(!frontswap_ops);\n\tVM_BUG_ON(!PageLocked(page));\n\tVM_BUG_ON(sis == NULL);\n\n\t/*\n\t * If a dup, we must remove the old page first; we can't leave the\n\t * old page no matter if the store of the new page succeeds or fails,\n\t * and we can't rely on the new page replacing the old page as we may\n\t * not store to the same implementation that contains the old page.\n\t */\n\tif (__frontswap_test(sis, offset)) {\n\t\t__frontswap_clear(sis, offset);\n\t\tfor_each_frontswap_ops(ops)\n\t\t\tops->invalidate_page(type, offset);\n\t}\n\n\t/* Try to store in each implementation, until one succeeds. */\n\tfor_each_frontswap_ops(ops) {\n\t\tret = ops->store(type, offset, page);\n\t\tif (!ret) /* successful store */\n\t\t\tbreak;\n\t}\n\tif (ret == 0) {\n\t\t__frontswap_set(sis, offset);\n\t\tinc_frontswap_succ_stores();\n\t} else {\n\t\tinc_frontswap_failed_stores();\n\t}\n\tif (frontswap_writethrough_enabled)\n\t\t/* report failure so swap also writes to swap device */\n\t\tret = -1;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_free_swap",
          "args": [
            "page"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_free_swap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1584-1617",
          "snippet": "int try_to_free_swap(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tif (!PageSwapCache(page))\n\t\treturn 0;\n\tif (PageWriteback(page))\n\t\treturn 0;\n\tif (page_swapped(page))\n\t\treturn 0;\n\n\t/*\n\t * Once hibernation has begun to create its image of memory,\n\t * there's a danger that one of the calls to try_to_free_swap()\n\t * - most probably a call from __try_to_reclaim_swap() while\n\t * hibernation is allocating its own swap pages for the image,\n\t * but conceivably even a call from memory reclaim - will free\n\t * the swap from a page which has already been recorded in the\n\t * image as a clean swapcache page, and then reuse its swap for\n\t * another page of the image.  On waking from hibernation, the\n\t * original page might be freed under memory pressure, then\n\t * later read back in from swap, now with the wrong data.\n\t *\n\t * Hibernation suspends storage while it is writing the image\n\t * to disk so check that here.\n\t */\n\tif (pm_suspended_storage())\n\t\treturn 0;\n\n\tpage = compound_head(page);\n\tdelete_from_swap_cache(page);\n\tSetPageDirty(page);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint try_to_free_swap(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tif (!PageSwapCache(page))\n\t\treturn 0;\n\tif (PageWriteback(page))\n\t\treturn 0;\n\tif (page_swapped(page))\n\t\treturn 0;\n\n\t/*\n\t * Once hibernation has begun to create its image of memory,\n\t * there's a danger that one of the calls to try_to_free_swap()\n\t * - most probably a call from __try_to_reclaim_swap() while\n\t * hibernation is allocating its own swap pages for the image,\n\t * but conceivably even a call from memory reclaim - will free\n\t * the swap from a page which has already been recorded in the\n\t * image as a clean swapcache page, and then reuse its swap for\n\t * another page of the image.  On waking from hibernation, the\n\t * original page might be freed under memory pressure, then\n\t * later read back in from swap, now with the wrong data.\n\t *\n\t * Hibernation suspends storage while it is writing the image\n\t * to disk so check that here.\n\t */\n\tif (pm_suspended_storage())\n\t\treturn 0;\n\n\tpage = compound_head(page);\n\tdelete_from_swap_cache(page);\n\tSetPageDirty(page);\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/sched/task.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/frontswap.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swapops.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/mm.h>\n\nint swap_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tint ret = 0;\n\n\tif (try_to_free_swap(page)) {\n\t\tunlock_page(page);\n\t\tgoto out;\n\t}\n\tif (frontswap_store(page) == 0) {\n\t\tset_page_writeback(page);\n\t\tunlock_page(page);\n\t\tend_page_writeback(page);\n\t\tgoto out;\n\t}\n\tret = __swap_writepage(page, wbc, end_swap_bio_write);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "generic_swapfile_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_io.c",
    "lines": "147-239",
    "snippet": "int generic_swapfile_activate(struct swap_info_struct *sis,\n\t\t\t\tstruct file *swap_file,\n\t\t\t\tsector_t *span)\n{\n\tstruct address_space *mapping = swap_file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tunsigned blocks_per_page;\n\tunsigned long page_no;\n\tunsigned blkbits;\n\tsector_t probe_block;\n\tsector_t last_block;\n\tsector_t lowest_block = -1;\n\tsector_t highest_block = 0;\n\tint nr_extents = 0;\n\tint ret;\n\n\tblkbits = inode->i_blkbits;\n\tblocks_per_page = PAGE_SIZE >> blkbits;\n\n\t/*\n\t * Map all the blocks into the extent list.  This code doesn't try\n\t * to be very smart.\n\t */\n\tprobe_block = 0;\n\tpage_no = 0;\n\tlast_block = i_size_read(inode) >> blkbits;\n\twhile ((probe_block + blocks_per_page) <= last_block &&\n\t\t\tpage_no < sis->max) {\n\t\tunsigned block_in_page;\n\t\tsector_t first_block;\n\n\t\tcond_resched();\n\n\t\tfirst_block = bmap(inode, probe_block);\n\t\tif (first_block == 0)\n\t\t\tgoto bad_bmap;\n\n\t\t/*\n\t\t * It must be PAGE_SIZE aligned on-disk\n\t\t */\n\t\tif (first_block & (blocks_per_page - 1)) {\n\t\t\tprobe_block++;\n\t\t\tgoto reprobe;\n\t\t}\n\n\t\tfor (block_in_page = 1; block_in_page < blocks_per_page;\n\t\t\t\t\tblock_in_page++) {\n\t\t\tsector_t block;\n\n\t\t\tblock = bmap(inode, probe_block + block_in_page);\n\t\t\tif (block == 0)\n\t\t\t\tgoto bad_bmap;\n\t\t\tif (block != first_block + block_in_page) {\n\t\t\t\t/* Discontiguity */\n\t\t\t\tprobe_block++;\n\t\t\t\tgoto reprobe;\n\t\t\t}\n\t\t}\n\n\t\tfirst_block >>= (PAGE_SHIFT - blkbits);\n\t\tif (page_no) {\t/* exclude the header page */\n\t\t\tif (first_block < lowest_block)\n\t\t\t\tlowest_block = first_block;\n\t\t\tif (first_block > highest_block)\n\t\t\t\thighest_block = first_block;\n\t\t}\n\n\t\t/*\n\t\t * We found a PAGE_SIZE-length, PAGE_SIZE-aligned run of blocks\n\t\t */\n\t\tret = add_swap_extent(sis, page_no, 1, first_block);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tnr_extents += ret;\n\t\tpage_no++;\n\t\tprobe_block += blocks_per_page;\nreprobe:\n\t\tcontinue;\n\t}\n\tret = nr_extents;\n\t*span = 1 + highest_block - lowest_block;\n\tif (page_no == 0)\n\t\tpage_no = 1;\t/* force Empty message */\n\tsis->max = page_no;\n\tsis->pages = page_no - 1;\n\tsis->highest_bit = page_no - 1;\nout:\n\treturn ret;\nbad_bmap:\n\tpr_err(\"swapon: swapfile has holes\\n\");\n\tret = -EINVAL;\n\tgoto out;\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/uio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/swapops.h>",
      "#include <linux/bio.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"swapon: swapfile has holes\\n\""
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_swap_extent",
          "args": [
            "sis",
            "page_no",
            "1",
            "first_block"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "add_swap_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "2318-2356",
          "snippet": "int\nadd_swap_extent(struct swap_info_struct *sis, unsigned long start_page,\n\t\tunsigned long nr_pages, sector_t start_block)\n{\n\tstruct swap_extent *se;\n\tstruct swap_extent *new_se;\n\tstruct list_head *lh;\n\n\tif (start_page == 0) {\n\t\tse = &sis->first_swap_extent;\n\t\tsis->curr_swap_extent = se;\n\t\tse->start_page = 0;\n\t\tse->nr_pages = nr_pages;\n\t\tse->start_block = start_block;\n\t\treturn 1;\n\t} else {\n\t\tlh = sis->first_swap_extent.list.prev;\t/* Highest extent */\n\t\tse = list_entry(lh, struct swap_extent, list);\n\t\tBUG_ON(se->start_page + se->nr_pages != start_page);\n\t\tif (se->start_block + se->nr_pages == start_block) {\n\t\t\t/* Merge it */\n\t\t\tse->nr_pages += nr_pages;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * No merge.  Insert a new extent, preserving ordering.\n\t */\n\tnew_se = kmalloc(sizeof(*se), GFP_KERNEL);\n\tif (new_se == NULL)\n\t\treturn -ENOMEM;\n\tnew_se->start_page = start_page;\n\tnew_se->nr_pages = nr_pages;\n\tnew_se->start_block = start_block;\n\n\tlist_add_tail(&new_se->list, &sis->first_swap_extent.list);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nint\nadd_swap_extent(struct swap_info_struct *sis, unsigned long start_page,\n\t\tunsigned long nr_pages, sector_t start_block)\n{\n\tstruct swap_extent *se;\n\tstruct swap_extent *new_se;\n\tstruct list_head *lh;\n\n\tif (start_page == 0) {\n\t\tse = &sis->first_swap_extent;\n\t\tsis->curr_swap_extent = se;\n\t\tse->start_page = 0;\n\t\tse->nr_pages = nr_pages;\n\t\tse->start_block = start_block;\n\t\treturn 1;\n\t} else {\n\t\tlh = sis->first_swap_extent.list.prev;\t/* Highest extent */\n\t\tse = list_entry(lh, struct swap_extent, list);\n\t\tBUG_ON(se->start_page + se->nr_pages != start_page);\n\t\tif (se->start_block + se->nr_pages == start_block) {\n\t\t\t/* Merge it */\n\t\t\tse->nr_pages += nr_pages;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * No merge.  Insert a new extent, preserving ordering.\n\t */\n\tnew_se = kmalloc(sizeof(*se), GFP_KERNEL);\n\tif (new_se == NULL)\n\t\treturn -ENOMEM;\n\tnew_se->start_page = start_page;\n\tnew_se->nr_pages = nr_pages;\n\tnew_se->start_block = start_block;\n\n\tlist_add_tail(&new_se->list, &sis->first_swap_extent.list);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bmap",
          "args": [
            "inode",
            "probe_block + block_in_page"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bmap",
          "args": [
            "inode",
            "probe_block"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/sched/task.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/frontswap.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swapops.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/mm.h>\n\nint generic_swapfile_activate(struct swap_info_struct *sis,\n\t\t\t\tstruct file *swap_file,\n\t\t\t\tsector_t *span)\n{\n\tstruct address_space *mapping = swap_file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tunsigned blocks_per_page;\n\tunsigned long page_no;\n\tunsigned blkbits;\n\tsector_t probe_block;\n\tsector_t last_block;\n\tsector_t lowest_block = -1;\n\tsector_t highest_block = 0;\n\tint nr_extents = 0;\n\tint ret;\n\n\tblkbits = inode->i_blkbits;\n\tblocks_per_page = PAGE_SIZE >> blkbits;\n\n\t/*\n\t * Map all the blocks into the extent list.  This code doesn't try\n\t * to be very smart.\n\t */\n\tprobe_block = 0;\n\tpage_no = 0;\n\tlast_block = i_size_read(inode) >> blkbits;\n\twhile ((probe_block + blocks_per_page) <= last_block &&\n\t\t\tpage_no < sis->max) {\n\t\tunsigned block_in_page;\n\t\tsector_t first_block;\n\n\t\tcond_resched();\n\n\t\tfirst_block = bmap(inode, probe_block);\n\t\tif (first_block == 0)\n\t\t\tgoto bad_bmap;\n\n\t\t/*\n\t\t * It must be PAGE_SIZE aligned on-disk\n\t\t */\n\t\tif (first_block & (blocks_per_page - 1)) {\n\t\t\tprobe_block++;\n\t\t\tgoto reprobe;\n\t\t}\n\n\t\tfor (block_in_page = 1; block_in_page < blocks_per_page;\n\t\t\t\t\tblock_in_page++) {\n\t\t\tsector_t block;\n\n\t\t\tblock = bmap(inode, probe_block + block_in_page);\n\t\t\tif (block == 0)\n\t\t\t\tgoto bad_bmap;\n\t\t\tif (block != first_block + block_in_page) {\n\t\t\t\t/* Discontiguity */\n\t\t\t\tprobe_block++;\n\t\t\t\tgoto reprobe;\n\t\t\t}\n\t\t}\n\n\t\tfirst_block >>= (PAGE_SHIFT - blkbits);\n\t\tif (page_no) {\t/* exclude the header page */\n\t\t\tif (first_block < lowest_block)\n\t\t\t\tlowest_block = first_block;\n\t\t\tif (first_block > highest_block)\n\t\t\t\thighest_block = first_block;\n\t\t}\n\n\t\t/*\n\t\t * We found a PAGE_SIZE-length, PAGE_SIZE-aligned run of blocks\n\t\t */\n\t\tret = add_swap_extent(sis, page_no, 1, first_block);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tnr_extents += ret;\n\t\tpage_no++;\n\t\tprobe_block += blocks_per_page;\nreprobe:\n\t\tcontinue;\n\t}\n\tret = nr_extents;\n\t*span = 1 + highest_block - lowest_block;\n\tif (page_no == 0)\n\t\tpage_no = 1;\t/* force Empty message */\n\tsis->max = page_no;\n\tsis->pages = page_no - 1;\n\tsis->highest_bit = page_no - 1;\nout:\n\treturn ret;\nbad_bmap:\n\tpr_err(\"swapon: swapfile has holes\\n\");\n\tret = -EINVAL;\n\tgoto out;\n}"
  },
  {
    "function_name": "end_swap_bio_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_io.c",
    "lines": "123-145",
    "snippet": "static void end_swap_bio_read(struct bio *bio)\n{\n\tstruct page *page = bio_first_page_all(bio);\n\tstruct task_struct *waiter = bio->bi_private;\n\n\tif (bio->bi_status) {\n\t\tSetPageError(page);\n\t\tClearPageUptodate(page);\n\t\tpr_alert(\"Read-error on swap-device (%u:%u:%llu)\\n\",\n\t\t\t MAJOR(bio_dev(bio)), MINOR(bio_dev(bio)),\n\t\t\t (unsigned long long)bio->bi_iter.bi_sector);\n\t\tgoto out;\n\t}\n\n\tSetPageUptodate(page);\n\tswap_slot_free_notify(page);\nout:\n\tunlock_page(page);\n\tWRITE_ONCE(bio->bi_private, NULL);\n\tbio_put(bio);\n\twake_up_process(waiter);\n\tput_task_struct(waiter);\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/uio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/swapops.h>",
      "#include <linux/bio.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "waiter"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "waiter"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "bio->bi_private",
            "NULL"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap_slot_free_notify",
          "args": [
            "page"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "swap_slot_free_notify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_io.c",
          "lines": "75-121",
          "snippet": "static void swap_slot_free_notify(struct page *page)\n{\n\tstruct swap_info_struct *sis;\n\tstruct gendisk *disk;\n\n\t/*\n\t * There is no guarantee that the page is in swap cache - the software\n\t * suspend code (at least) uses end_swap_bio_read() against a non-\n\t * swapcache page.  So we must check PG_swapcache before proceeding with\n\t * this optimization.\n\t */\n\tif (unlikely(!PageSwapCache(page)))\n\t\treturn;\n\n\tsis = page_swap_info(page);\n\tif (!(sis->flags & SWP_BLKDEV))\n\t\treturn;\n\n\t/*\n\t * The swap subsystem performs lazy swap slot freeing,\n\t * expecting that the page will be swapped out again.\n\t * So we can avoid an unnecessary write if the page\n\t * isn't redirtied.\n\t * This is good for real swap storage because we can\n\t * reduce unnecessary I/O and enhance wear-leveling\n\t * if an SSD is used as the as swap device.\n\t * But if in-memory swap device (eg zram) is used,\n\t * this causes a duplicated copy between uncompressed\n\t * data in VM-owned memory and compressed data in\n\t * zram-owned memory.  So let's free zram-owned memory\n\t * and make the VM-owned decompressed page *dirty*,\n\t * so the page should be swapped out somewhere again if\n\t * we again wish to reclaim it.\n\t */\n\tdisk = sis->bdev->bd_disk;\n\tif (disk->fops->swap_slot_free_notify) {\n\t\tswp_entry_t entry;\n\t\tunsigned long offset;\n\n\t\tentry.val = page_private(page);\n\t\toffset = swp_offset(entry);\n\n\t\tSetPageDirty(page);\n\t\tdisk->fops->swap_slot_free_notify(sis->bdev,\n\t\t\t\toffset);\n\t}\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/swapops.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/sched/task.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/frontswap.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swapops.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/mm.h>\n\nstatic void swap_slot_free_notify(struct page *page)\n{\n\tstruct swap_info_struct *sis;\n\tstruct gendisk *disk;\n\n\t/*\n\t * There is no guarantee that the page is in swap cache - the software\n\t * suspend code (at least) uses end_swap_bio_read() against a non-\n\t * swapcache page.  So we must check PG_swapcache before proceeding with\n\t * this optimization.\n\t */\n\tif (unlikely(!PageSwapCache(page)))\n\t\treturn;\n\n\tsis = page_swap_info(page);\n\tif (!(sis->flags & SWP_BLKDEV))\n\t\treturn;\n\n\t/*\n\t * The swap subsystem performs lazy swap slot freeing,\n\t * expecting that the page will be swapped out again.\n\t * So we can avoid an unnecessary write if the page\n\t * isn't redirtied.\n\t * This is good for real swap storage because we can\n\t * reduce unnecessary I/O and enhance wear-leveling\n\t * if an SSD is used as the as swap device.\n\t * But if in-memory swap device (eg zram) is used,\n\t * this causes a duplicated copy between uncompressed\n\t * data in VM-owned memory and compressed data in\n\t * zram-owned memory.  So let's free zram-owned memory\n\t * and make the VM-owned decompressed page *dirty*,\n\t * so the page should be swapped out somewhere again if\n\t * we again wish to reclaim it.\n\t */\n\tdisk = sis->bdev->bd_disk;\n\tif (disk->fops->swap_slot_free_notify) {\n\t\tswp_entry_t entry;\n\t\tunsigned long offset;\n\n\t\tentry.val = page_private(page);\n\t\toffset = swp_offset(entry);\n\n\t\tSetPageDirty(page);\n\t\tdisk->fops->swap_slot_free_notify(sis->bdev,\n\t\t\t\toffset);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"Read-error on swap-device (%u:%u:%llu)\\n\"",
            "MAJOR(bio_dev(bio))",
            "MINOR(bio_dev(bio))",
            "(unsigned long long)bio->bi_iter.bi_sector"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "bio_dev(bio)"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_dev",
          "args": [
            "bio"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "bio_dev(bio)"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_dev",
          "args": [
            "bio"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageUptodate",
          "args": [
            "page"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_first_page_all",
          "args": [
            "bio"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/sched/task.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/frontswap.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swapops.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/mm.h>\n\nstatic void end_swap_bio_read(struct bio *bio)\n{\n\tstruct page *page = bio_first_page_all(bio);\n\tstruct task_struct *waiter = bio->bi_private;\n\n\tif (bio->bi_status) {\n\t\tSetPageError(page);\n\t\tClearPageUptodate(page);\n\t\tpr_alert(\"Read-error on swap-device (%u:%u:%llu)\\n\",\n\t\t\t MAJOR(bio_dev(bio)), MINOR(bio_dev(bio)),\n\t\t\t (unsigned long long)bio->bi_iter.bi_sector);\n\t\tgoto out;\n\t}\n\n\tSetPageUptodate(page);\n\tswap_slot_free_notify(page);\nout:\n\tunlock_page(page);\n\tWRITE_ONCE(bio->bi_private, NULL);\n\tbio_put(bio);\n\twake_up_process(waiter);\n\tput_task_struct(waiter);\n}"
  },
  {
    "function_name": "swap_slot_free_notify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_io.c",
    "lines": "75-121",
    "snippet": "static void swap_slot_free_notify(struct page *page)\n{\n\tstruct swap_info_struct *sis;\n\tstruct gendisk *disk;\n\n\t/*\n\t * There is no guarantee that the page is in swap cache - the software\n\t * suspend code (at least) uses end_swap_bio_read() against a non-\n\t * swapcache page.  So we must check PG_swapcache before proceeding with\n\t * this optimization.\n\t */\n\tif (unlikely(!PageSwapCache(page)))\n\t\treturn;\n\n\tsis = page_swap_info(page);\n\tif (!(sis->flags & SWP_BLKDEV))\n\t\treturn;\n\n\t/*\n\t * The swap subsystem performs lazy swap slot freeing,\n\t * expecting that the page will be swapped out again.\n\t * So we can avoid an unnecessary write if the page\n\t * isn't redirtied.\n\t * This is good for real swap storage because we can\n\t * reduce unnecessary I/O and enhance wear-leveling\n\t * if an SSD is used as the as swap device.\n\t * But if in-memory swap device (eg zram) is used,\n\t * this causes a duplicated copy between uncompressed\n\t * data in VM-owned memory and compressed data in\n\t * zram-owned memory.  So let's free zram-owned memory\n\t * and make the VM-owned decompressed page *dirty*,\n\t * so the page should be swapped out somewhere again if\n\t * we again wish to reclaim it.\n\t */\n\tdisk = sis->bdev->bd_disk;\n\tif (disk->fops->swap_slot_free_notify) {\n\t\tswp_entry_t entry;\n\t\tunsigned long offset;\n\n\t\tentry.val = page_private(page);\n\t\toffset = swp_offset(entry);\n\n\t\tSetPageDirty(page);\n\t\tdisk->fops->swap_slot_free_notify(sis->bdev,\n\t\t\t\toffset);\n\t}\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/uio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/swapops.h>",
      "#include <linux/bio.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "disk->fops->swap_slot_free_notify",
          "args": [
            "sis->bdev",
            "offset"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageDirty",
          "args": [
            "page"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_offset",
          "args": [
            "entry"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "page"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_swap_info",
          "args": [
            "page"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "page_swap_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "3470-3474",
          "snippet": "struct swap_info_struct *page_swap_info(struct page *page)\n{\n\tswp_entry_t entry = { .val = page_private(page) };\n\treturn swp_swap_info(entry);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nstruct swap_info_struct *page_swap_info(struct page *page)\n{\n\tswp_entry_t entry = { .val = page_private(page) };\n\treturn swp_swap_info(entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!PageSwapCache(page)"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/sched/task.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/frontswap.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swapops.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/mm.h>\n\nstatic void swap_slot_free_notify(struct page *page)\n{\n\tstruct swap_info_struct *sis;\n\tstruct gendisk *disk;\n\n\t/*\n\t * There is no guarantee that the page is in swap cache - the software\n\t * suspend code (at least) uses end_swap_bio_read() against a non-\n\t * swapcache page.  So we must check PG_swapcache before proceeding with\n\t * this optimization.\n\t */\n\tif (unlikely(!PageSwapCache(page)))\n\t\treturn;\n\n\tsis = page_swap_info(page);\n\tif (!(sis->flags & SWP_BLKDEV))\n\t\treturn;\n\n\t/*\n\t * The swap subsystem performs lazy swap slot freeing,\n\t * expecting that the page will be swapped out again.\n\t * So we can avoid an unnecessary write if the page\n\t * isn't redirtied.\n\t * This is good for real swap storage because we can\n\t * reduce unnecessary I/O and enhance wear-leveling\n\t * if an SSD is used as the as swap device.\n\t * But if in-memory swap device (eg zram) is used,\n\t * this causes a duplicated copy between uncompressed\n\t * data in VM-owned memory and compressed data in\n\t * zram-owned memory.  So let's free zram-owned memory\n\t * and make the VM-owned decompressed page *dirty*,\n\t * so the page should be swapped out somewhere again if\n\t * we again wish to reclaim it.\n\t */\n\tdisk = sis->bdev->bd_disk;\n\tif (disk->fops->swap_slot_free_notify) {\n\t\tswp_entry_t entry;\n\t\tunsigned long offset;\n\n\t\tentry.val = page_private(page);\n\t\toffset = swp_offset(entry);\n\n\t\tSetPageDirty(page);\n\t\tdisk->fops->swap_slot_free_notify(sis->bdev,\n\t\t\t\toffset);\n\t}\n}"
  },
  {
    "function_name": "end_swap_bio_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_io.c",
    "lines": "51-73",
    "snippet": "void end_swap_bio_write(struct bio *bio)\n{\n\tstruct page *page = bio_first_page_all(bio);\n\n\tif (bio->bi_status) {\n\t\tSetPageError(page);\n\t\t/*\n\t\t * We failed to write the page out to swap-space.\n\t\t * Re-dirty the page in order to avoid it being reclaimed.\n\t\t * Also print a dire warning that things will go BAD (tm)\n\t\t * very quickly.\n\t\t *\n\t\t * Also clear PG_reclaim to avoid rotate_reclaimable_page()\n\t\t */\n\t\tset_page_dirty(page);\n\t\tpr_alert(\"Write-error on swap-device (%u:%u:%llu)\\n\",\n\t\t\t MAJOR(bio_dev(bio)), MINOR(bio_dev(bio)),\n\t\t\t (unsigned long long)bio->bi_iter.bi_sector);\n\t\tClearPageReclaim(page);\n\t}\n\tend_page_writeback(page);\n\tbio_put(bio);\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/uio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/swapops.h>",
      "#include <linux/bio.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "page"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1209-1228",
          "snippet": "void end_page_writeback(struct page *page)\n{\n\t/*\n\t * TestClearPageReclaim could be used here but it is an atomic\n\t * operation and overkill in this particular case. Failing to\n\t * shuffle a page marked for immediate reclaim is too mild to\n\t * justify taking an atomic operation penalty at the end of\n\t * ever page writeback.\n\t */\n\tif (PageReclaim(page)) {\n\t\tClearPageReclaim(page);\n\t\trotate_reclaimable_page(page);\n\t}\n\n\tif (!test_clear_page_writeback(page))\n\t\tBUG();\n\n\tsmp_mb__after_atomic();\n\twake_up_page(page, PG_writeback);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nvoid end_page_writeback(struct page *page)\n{\n\t/*\n\t * TestClearPageReclaim could be used here but it is an atomic\n\t * operation and overkill in this particular case. Failing to\n\t * shuffle a page marked for immediate reclaim is too mild to\n\t * justify taking an atomic operation penalty at the end of\n\t * ever page writeback.\n\t */\n\tif (PageReclaim(page)) {\n\t\tClearPageReclaim(page);\n\t\trotate_reclaimable_page(page);\n\t}\n\n\tif (!test_clear_page_writeback(page))\n\t\tBUG();\n\n\tsmp_mb__after_atomic();\n\twake_up_page(page, PG_writeback);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPageReclaim",
          "args": [
            "page"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"Write-error on swap-device (%u:%u:%llu)\\n\"",
            "MAJOR(bio_dev(bio))",
            "MINOR(bio_dev(bio))",
            "(unsigned long long)bio->bi_iter.bi_sector"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "bio_dev(bio)"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_dev",
          "args": [
            "bio"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "bio_dev(bio)"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_dev",
          "args": [
            "bio"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "swap_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_io.c",
          "lines": "422-434",
          "snippet": "int swap_set_page_dirty(struct page *page)\n{\n\tstruct swap_info_struct *sis = page_swap_info(page);\n\n\tif (sis->flags & SWP_FS) {\n\t\tstruct address_space *mapping = sis->swap_file->f_mapping;\n\n\t\tVM_BUG_ON_PAGE(!PageSwapCache(page), page);\n\t\treturn mapping->a_ops->set_page_dirty(page);\n\t} else {\n\t\treturn __set_page_dirty_no_writeback(page);\n\t}\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/swapops.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/sched/task.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/frontswap.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swapops.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/mm.h>\n\nint swap_set_page_dirty(struct page *page)\n{\n\tstruct swap_info_struct *sis = page_swap_info(page);\n\n\tif (sis->flags & SWP_FS) {\n\t\tstruct address_space *mapping = sis->swap_file->f_mapping;\n\n\t\tVM_BUG_ON_PAGE(!PageSwapCache(page), page);\n\t\treturn mapping->a_ops->set_page_dirty(page);\n\t} else {\n\t\treturn __set_page_dirty_no_writeback(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_first_page_all",
          "args": [
            "bio"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/sched/task.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/frontswap.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swapops.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/mm.h>\n\nvoid end_swap_bio_write(struct bio *bio)\n{\n\tstruct page *page = bio_first_page_all(bio);\n\n\tif (bio->bi_status) {\n\t\tSetPageError(page);\n\t\t/*\n\t\t * We failed to write the page out to swap-space.\n\t\t * Re-dirty the page in order to avoid it being reclaimed.\n\t\t * Also print a dire warning that things will go BAD (tm)\n\t\t * very quickly.\n\t\t *\n\t\t * Also clear PG_reclaim to avoid rotate_reclaimable_page()\n\t\t */\n\t\tset_page_dirty(page);\n\t\tpr_alert(\"Write-error on swap-device (%u:%u:%llu)\\n\",\n\t\t\t MAJOR(bio_dev(bio)), MINOR(bio_dev(bio)),\n\t\t\t (unsigned long long)bio->bi_iter.bi_sector);\n\t\tClearPageReclaim(page);\n\t}\n\tend_page_writeback(page);\n\tbio_put(bio);\n}"
  },
  {
    "function_name": "get_swap_bio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_io.c",
    "lines": "29-49",
    "snippet": "static struct bio *get_swap_bio(gfp_t gfp_flags,\n\t\t\t\tstruct page *page, bio_end_io_t end_io)\n{\n\tint i, nr = hpage_nr_pages(page);\n\tstruct bio *bio;\n\n\tbio = bio_alloc(gfp_flags, nr);\n\tif (bio) {\n\t\tstruct block_device *bdev;\n\n\t\tbio->bi_iter.bi_sector = map_swap_page(page, &bdev);\n\t\tbio_set_dev(bio, bdev);\n\t\tbio->bi_iter.bi_sector <<= PAGE_SHIFT - 9;\n\t\tbio->bi_end_io = end_io;\n\n\t\tfor (i = 0; i < nr; i++)\n\t\t\tbio_add_page(bio, page + i, PAGE_SIZE, 0);\n\t\tVM_BUG_ON(bio->bi_iter.bi_size != PAGE_SIZE * nr);\n\t}\n\treturn bio;\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/uio.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/frontswap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/swapops.h>",
      "#include <linux/bio.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "bio->bi_iter.bi_size != PAGE_SIZE * nr"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_add_page",
          "args": [
            "bio",
            "page + i",
            "PAGE_SIZE",
            "0"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_set_dev",
          "args": [
            "bio",
            "bdev"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_swap_page",
          "args": [
            "page",
            "&bdev"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "map_swap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "2281-2286",
          "snippet": "sector_t map_swap_page(struct page *page, struct block_device **bdev)\n{\n\tswp_entry_t entry;\n\tentry.val = page_private(page);\n\treturn map_swap_entry(entry, bdev);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static sector_t map_swap_entry(swp_entry_t, struct block_device**);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic sector_t map_swap_entry(swp_entry_t, struct block_device**);\n\nsector_t map_swap_page(struct page *page, struct block_device **bdev)\n{\n\tswp_entry_t entry;\n\tentry.val = page_private(page);\n\treturn map_swap_entry(entry, bdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_alloc",
          "args": [
            "gfp_flags",
            "nr"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "page"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/sched/task.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/frontswap.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swapops.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/mm.h>\n\nstatic struct bio *get_swap_bio(gfp_t gfp_flags,\n\t\t\t\tstruct page *page, bio_end_io_t end_io)\n{\n\tint i, nr = hpage_nr_pages(page);\n\tstruct bio *bio;\n\n\tbio = bio_alloc(gfp_flags, nr);\n\tif (bio) {\n\t\tstruct block_device *bdev;\n\n\t\tbio->bi_iter.bi_sector = map_swap_page(page, &bdev);\n\t\tbio_set_dev(bio, bdev);\n\t\tbio->bi_iter.bi_sector <<= PAGE_SHIFT - 9;\n\t\tbio->bi_end_io = end_io;\n\n\t\tfor (i = 0; i < nr; i++)\n\t\t\tbio_add_page(bio, page + i, PAGE_SIZE, 0);\n\t\tVM_BUG_ON(bio->bi_iter.bi_size != PAGE_SIZE * nr);\n\t}\n\treturn bio;\n}"
  }
]