[
  {
    "function_name": "failslab_debugfs_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/failslab.c",
    "lines": "42-63",
    "snippet": "static int __init failslab_debugfs_init(void)\n{\n\tstruct dentry *dir;\n\tumode_t mode = S_IFREG | 0600;\n\n\tdir = fault_create_debugfs_attr(\"failslab\", NULL, &failslab.attr);\n\tif (IS_ERR(dir))\n\t\treturn PTR_ERR(dir);\n\n\tif (!debugfs_create_bool(\"ignore-gfp-wait\", mode, dir,\n\t\t\t\t&failslab.ignore_gfp_reclaim))\n\t\tgoto fail;\n\tif (!debugfs_create_bool(\"cache-filter\", mode, dir,\n\t\t\t\t&failslab.cache_filter))\n\t\tgoto fail;\n\n\treturn 0;\nfail:\n\tdebugfs_remove_recursive(dir);\n\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/fault-inject.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n\tstruct fault_attr attr;\n\tbool ignore_gfp_reclaim;\n\tbool cache_filter;\n} failslab = {\n\t.attr = FAULT_ATTR_INITIALIZER,\n\t.ignore_gfp_reclaim = true,\n\t.cache_filter = false,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_remove_recursive",
          "args": [
            "dir"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_bool",
          "args": [
            "\"cache-filter\"",
            "mode",
            "dir",
            "&failslab.cache_filter"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_bool",
          "args": [
            "\"ignore-gfp-wait\"",
            "mode",
            "dir",
            "&failslab.ignore_gfp_reclaim"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dir"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dir"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fault_create_debugfs_attr",
          "args": [
            "\"failslab\"",
            "NULL",
            "&failslab.attr"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/fault-inject.h>\n\nstatic struct {\n\tstruct fault_attr attr;\n\tbool ignore_gfp_reclaim;\n\tbool cache_filter;\n} failslab = {\n\t.attr = FAULT_ATTR_INITIALIZER,\n\t.ignore_gfp_reclaim = true,\n\t.cache_filter = false,\n};\n\nstatic int __init failslab_debugfs_init(void)\n{\n\tstruct dentry *dir;\n\tumode_t mode = S_IFREG | 0600;\n\n\tdir = fault_create_debugfs_attr(\"failslab\", NULL, &failslab.attr);\n\tif (IS_ERR(dir))\n\t\treturn PTR_ERR(dir);\n\n\tif (!debugfs_create_bool(\"ignore-gfp-wait\", mode, dir,\n\t\t\t\t&failslab.ignore_gfp_reclaim))\n\t\tgoto fail;\n\tif (!debugfs_create_bool(\"cache-filter\", mode, dir,\n\t\t\t\t&failslab.cache_filter))\n\t\tgoto fail;\n\n\treturn 0;\nfail:\n\tdebugfs_remove_recursive(dir);\n\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "setup_failslab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/failslab.c",
    "lines": "35-38",
    "snippet": "static int __init setup_failslab(char *str)\n{\n\treturn setup_fault_attr(&failslab.attr, str);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/fault-inject.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n\tstruct fault_attr attr;\n\tbool ignore_gfp_reclaim;\n\tbool cache_filter;\n} failslab = {\n\t.attr = FAULT_ATTR_INITIALIZER,\n\t.ignore_gfp_reclaim = true,\n\t.cache_filter = false,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "setup_fault_attr",
          "args": [
            "&failslab.attr",
            "str"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/fault-inject.h>\n\nstatic struct {\n\tstruct fault_attr attr;\n\tbool ignore_gfp_reclaim;\n\tbool cache_filter;\n} failslab = {\n\t.attr = FAULT_ATTR_INITIALIZER,\n\t.ignore_gfp_reclaim = true,\n\t.cache_filter = false,\n};\n\nstatic int __init setup_failslab(char *str)\n{\n\treturn setup_fault_attr(&failslab.attr, str);\n}"
  },
  {
    "function_name": "__should_failslab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/failslab.c",
    "lines": "17-33",
    "snippet": "bool __should_failslab(struct kmem_cache *s, gfp_t gfpflags)\n{\n\t/* No fault-injection for bootstrap cache */\n\tif (unlikely(s == kmem_cache))\n\t\treturn false;\n\n\tif (gfpflags & __GFP_NOFAIL)\n\t\treturn false;\n\n\tif (failslab.ignore_gfp_reclaim && (gfpflags & __GFP_RECLAIM))\n\t\treturn false;\n\n\tif (failslab.cache_filter && !(s->flags & SLAB_FAILSLAB))\n\t\treturn false;\n\n\treturn should_fail(&failslab.attr, s->object_size);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/fault-inject.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n\tstruct fault_attr attr;\n\tbool ignore_gfp_reclaim;\n\tbool cache_filter;\n} failslab = {\n\t.attr = FAULT_ATTR_INITIALIZER,\n\t.ignore_gfp_reclaim = true,\n\t.cache_filter = false,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "should_fail",
          "args": [
            "&failslab.attr",
            "s->object_size"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "__should_failslab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/failslab.c",
          "lines": "17-33",
          "snippet": "bool __should_failslab(struct kmem_cache *s, gfp_t gfpflags)\n{\n\t/* No fault-injection for bootstrap cache */\n\tif (unlikely(s == kmem_cache))\n\t\treturn false;\n\n\tif (gfpflags & __GFP_NOFAIL)\n\t\treturn false;\n\n\tif (failslab.ignore_gfp_reclaim && (gfpflags & __GFP_RECLAIM))\n\t\treturn false;\n\n\tif (failslab.cache_filter && !(s->flags & SLAB_FAILSLAB))\n\t\treturn false;\n\n\treturn should_fail(&failslab.attr, s->object_size);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "s == kmem_cache"
          ],
          "line": 20
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/fault-inject.h>\n\nstatic struct {\n\tstruct fault_attr attr;\n\tbool ignore_gfp_reclaim;\n\tbool cache_filter;\n} failslab = {\n\t.attr = FAULT_ATTR_INITIALIZER,\n\t.ignore_gfp_reclaim = true,\n\t.cache_filter = false,\n};\n\nbool __should_failslab(struct kmem_cache *s, gfp_t gfpflags)\n{\n\t/* No fault-injection for bootstrap cache */\n\tif (unlikely(s == kmem_cache))\n\t\treturn false;\n\n\tif (gfpflags & __GFP_NOFAIL)\n\t\treturn false;\n\n\tif (failslab.ignore_gfp_reclaim && (gfpflags & __GFP_RECLAIM))\n\t\treturn false;\n\n\tif (failslab.cache_filter && !(s->flags & SLAB_FAILSLAB))\n\t\treturn false;\n\n\treturn should_fail(&failslab.attr, s->object_size);\n}"
  }
]