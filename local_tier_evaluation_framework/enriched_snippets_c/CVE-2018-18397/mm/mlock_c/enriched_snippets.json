[
  {
    "function_name": "user_shm_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
    "lines": "862-868",
    "snippet": "void user_shm_unlock(size_t size, struct user_struct *user)\n{\n\tspin_lock(&shmlock_user_lock);\n\tuser->locked_shm -= (size + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tspin_unlock(&shmlock_user_lock);\n\tfree_uid(user);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/rmap.h>",
      "#include <linux/export.h>",
      "#include <linux/sched.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/mm.h>",
      "#include <linux/mman.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(shmlock_user_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_uid",
          "args": [
            "user"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&shmlock_user_lock"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&shmlock_user_lock"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(shmlock_user_lock);\n\nvoid user_shm_unlock(size_t size, struct user_struct *user)\n{\n\tspin_lock(&shmlock_user_lock);\n\tuser->locked_shm -= (size + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tspin_unlock(&shmlock_user_lock);\n\tfree_uid(user);\n}"
  },
  {
    "function_name": "user_shm_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
    "lines": "840-860",
    "snippet": "int user_shm_lock(size_t size, struct user_struct *user)\n{\n\tunsigned long lock_limit, locked;\n\tint allowed = 0;\n\n\tlocked = (size + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tlock_limit = rlimit(RLIMIT_MEMLOCK);\n\tif (lock_limit == RLIM_INFINITY)\n\t\tallowed = 1;\n\tlock_limit >>= PAGE_SHIFT;\n\tspin_lock(&shmlock_user_lock);\n\tif (!allowed &&\n\t    locked + user->locked_shm > lock_limit && !capable(CAP_IPC_LOCK))\n\t\tgoto out;\n\tget_uid(user);\n\tuser->locked_shm += locked;\n\tallowed = 1;\nout:\n\tspin_unlock(&shmlock_user_lock);\n\treturn allowed;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/rmap.h>",
      "#include <linux/export.h>",
      "#include <linux/sched.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/mm.h>",
      "#include <linux/mman.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(shmlock_user_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&shmlock_user_lock"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_uid",
          "args": [
            "user"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_IPC_LOCK"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&shmlock_user_lock"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rlimit",
          "args": [
            "RLIMIT_MEMLOCK"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(shmlock_user_lock);\n\nint user_shm_lock(size_t size, struct user_struct *user)\n{\n\tunsigned long lock_limit, locked;\n\tint allowed = 0;\n\n\tlocked = (size + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tlock_limit = rlimit(RLIMIT_MEMLOCK);\n\tif (lock_limit == RLIM_INFINITY)\n\t\tallowed = 1;\n\tlock_limit >>= PAGE_SHIFT;\n\tspin_lock(&shmlock_user_lock);\n\tif (!allowed &&\n\t    locked + user->locked_shm > lock_limit && !capable(CAP_IPC_LOCK))\n\t\tgoto out;\n\tget_uid(user);\n\tuser->locked_shm += locked;\n\tallowed = 1;\nout:\n\tspin_unlock(&shmlock_user_lock);\n\treturn allowed;\n}"
  },
  {
    "function_name": "apply_mlockall_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
    "lines": "759-793",
    "snippet": "static int apply_mlockall_flags(int flags)\n{\n\tstruct vm_area_struct * vma, * prev = NULL;\n\tvm_flags_t to_add = 0;\n\n\tcurrent->mm->def_flags &= VM_LOCKED_CLEAR_MASK;\n\tif (flags & MCL_FUTURE) {\n\t\tcurrent->mm->def_flags |= VM_LOCKED;\n\n\t\tif (flags & MCL_ONFAULT)\n\t\t\tcurrent->mm->def_flags |= VM_LOCKONFAULT;\n\n\t\tif (!(flags & MCL_CURRENT))\n\t\t\tgoto out;\n\t}\n\n\tif (flags & MCL_CURRENT) {\n\t\tto_add |= VM_LOCKED;\n\t\tif (flags & MCL_ONFAULT)\n\t\t\tto_add |= VM_LOCKONFAULT;\n\t}\n\n\tfor (vma = current->mm->mmap; vma ; vma = prev->vm_next) {\n\t\tvm_flags_t newflags;\n\n\t\tnewflags = vma->vm_flags & VM_LOCKED_CLEAR_MASK;\n\t\tnewflags |= to_add;\n\n\t\t/* Ignore errors */\n\t\tmlock_fixup(vma, &prev, vma->vm_start, vma->vm_end, newflags);\n\t\tcond_resched();\n\t}\nout:\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/rmap.h>",
      "#include <linux/export.h>",
      "#include <linux/sched.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/mm.h>",
      "#include <linux/mman.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlock_fixup",
          "args": [
            "vma",
            "&prev",
            "vma->vm_start",
            "vma->vm_end",
            "newflags"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "mlock_fixup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
          "lines": "519-581",
          "snippet": "static int mlock_fixup(struct vm_area_struct *vma, struct vm_area_struct **prev,\n\tunsigned long start, unsigned long end, vm_flags_t newflags)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpgoff_t pgoff;\n\tint nr_pages;\n\tint ret = 0;\n\tint lock = !!(newflags & VM_LOCKED);\n\tvm_flags_t old_flags = vma->vm_flags;\n\n\tif (newflags == vma->vm_flags || (vma->vm_flags & VM_SPECIAL) ||\n\t    is_vm_hugetlb_page(vma) || vma == get_gate_vma(current->mm) ||\n\t    vma_is_dax(vma))\n\t\t/* don't set VM_LOCKED or VM_LOCKONFAULT and don't count */\n\t\tgoto out;\n\n\tpgoff = vma->vm_pgoff + ((start - vma->vm_start) >> PAGE_SHIFT);\n\t*prev = vma_merge(mm, *prev, start, end, newflags, vma->anon_vma,\n\t\t\t  vma->vm_file, pgoff, vma_policy(vma),\n\t\t\t  vma->vm_userfaultfd_ctx);\n\tif (*prev) {\n\t\tvma = *prev;\n\t\tgoto success;\n\t}\n\n\tif (start != vma->vm_start) {\n\t\tret = split_vma(mm, vma, start, 1);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (end != vma->vm_end) {\n\t\tret = split_vma(mm, vma, end, 0);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\nsuccess:\n\t/*\n\t * Keep track of amount of locked VM.\n\t */\n\tnr_pages = (end - start) >> PAGE_SHIFT;\n\tif (!lock)\n\t\tnr_pages = -nr_pages;\n\telse if (old_flags & VM_LOCKED)\n\t\tnr_pages = 0;\n\tmm->locked_vm += nr_pages;\n\n\t/*\n\t * vm_flags is protected by the mmap_sem held in write mode.\n\t * It's okay if try_to_unmap_one unmaps a page just after we\n\t * set VM_LOCKED, populate_vma_page_range will bring it back.\n\t */\n\n\tif (lock)\n\t\tvma->vm_flags = newflags;\n\telse\n\t\tmunlock_vma_pages_range(vma, start, end);\n\nout:\n\t*prev = vma;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/rmap.h>",
            "#include <linux/export.h>",
            "#include <linux/sched.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/mm.h>",
            "#include <linux/mman.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nstatic int mlock_fixup(struct vm_area_struct *vma, struct vm_area_struct **prev,\n\tunsigned long start, unsigned long end, vm_flags_t newflags)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpgoff_t pgoff;\n\tint nr_pages;\n\tint ret = 0;\n\tint lock = !!(newflags & VM_LOCKED);\n\tvm_flags_t old_flags = vma->vm_flags;\n\n\tif (newflags == vma->vm_flags || (vma->vm_flags & VM_SPECIAL) ||\n\t    is_vm_hugetlb_page(vma) || vma == get_gate_vma(current->mm) ||\n\t    vma_is_dax(vma))\n\t\t/* don't set VM_LOCKED or VM_LOCKONFAULT and don't count */\n\t\tgoto out;\n\n\tpgoff = vma->vm_pgoff + ((start - vma->vm_start) >> PAGE_SHIFT);\n\t*prev = vma_merge(mm, *prev, start, end, newflags, vma->anon_vma,\n\t\t\t  vma->vm_file, pgoff, vma_policy(vma),\n\t\t\t  vma->vm_userfaultfd_ctx);\n\tif (*prev) {\n\t\tvma = *prev;\n\t\tgoto success;\n\t}\n\n\tif (start != vma->vm_start) {\n\t\tret = split_vma(mm, vma, start, 1);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (end != vma->vm_end) {\n\t\tret = split_vma(mm, vma, end, 0);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\nsuccess:\n\t/*\n\t * Keep track of amount of locked VM.\n\t */\n\tnr_pages = (end - start) >> PAGE_SHIFT;\n\tif (!lock)\n\t\tnr_pages = -nr_pages;\n\telse if (old_flags & VM_LOCKED)\n\t\tnr_pages = 0;\n\tmm->locked_vm += nr_pages;\n\n\t/*\n\t * vm_flags is protected by the mmap_sem held in write mode.\n\t * It's okay if try_to_unmap_one unmaps a page just after we\n\t * set VM_LOCKED, populate_vma_page_range will bring it back.\n\t */\n\n\tif (lock)\n\t\tvma->vm_flags = newflags;\n\telse\n\t\tmunlock_vma_pages_range(vma, start, end);\n\nout:\n\t*prev = vma;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nstatic int apply_mlockall_flags(int flags)\n{\n\tstruct vm_area_struct * vma, * prev = NULL;\n\tvm_flags_t to_add = 0;\n\n\tcurrent->mm->def_flags &= VM_LOCKED_CLEAR_MASK;\n\tif (flags & MCL_FUTURE) {\n\t\tcurrent->mm->def_flags |= VM_LOCKED;\n\n\t\tif (flags & MCL_ONFAULT)\n\t\t\tcurrent->mm->def_flags |= VM_LOCKONFAULT;\n\n\t\tif (!(flags & MCL_CURRENT))\n\t\t\tgoto out;\n\t}\n\n\tif (flags & MCL_CURRENT) {\n\t\tto_add |= VM_LOCKED;\n\t\tif (flags & MCL_ONFAULT)\n\t\t\tto_add |= VM_LOCKONFAULT;\n\t}\n\n\tfor (vma = current->mm->mmap; vma ; vma = prev->vm_next) {\n\t\tvm_flags_t newflags;\n\n\t\tnewflags = vma->vm_flags & VM_LOCKED_CLEAR_MASK;\n\t\tnewflags |= to_add;\n\n\t\t/* Ignore errors */\n\t\tmlock_fixup(vma, &prev, vma->vm_start, vma->vm_end, newflags);\n\t\tcond_resched();\n\t}\nout:\n\treturn 0;\n}"
  },
  {
    "function_name": "do_mlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
    "lines": "671-714",
    "snippet": "static __must_check int do_mlock(unsigned long start, size_t len, vm_flags_t flags)\n{\n\tunsigned long locked;\n\tunsigned long lock_limit;\n\tint error = -ENOMEM;\n\n\tif (!can_do_mlock())\n\t\treturn -EPERM;\n\n\tlen = PAGE_ALIGN(len + (offset_in_page(start)));\n\tstart &= PAGE_MASK;\n\n\tlock_limit = rlimit(RLIMIT_MEMLOCK);\n\tlock_limit >>= PAGE_SHIFT;\n\tlocked = len >> PAGE_SHIFT;\n\n\tif (down_write_killable(&current->mm->mmap_sem))\n\t\treturn -EINTR;\n\n\tlocked += current->mm->locked_vm;\n\tif ((locked > lock_limit) && (!capable(CAP_IPC_LOCK))) {\n\t\t/*\n\t\t * It is possible that the regions requested intersect with\n\t\t * previously mlocked areas, that part area in \"mm->locked_vm\"\n\t\t * should not be counted to new mlock increment count. So check\n\t\t * and adjust locked count if necessary.\n\t\t */\n\t\tlocked -= count_mm_mlocked_page_nr(current->mm,\n\t\t\t\tstart, len);\n\t}\n\n\t/* check against resource limits */\n\tif ((locked <= lock_limit) || capable(CAP_IPC_LOCK))\n\t\terror = apply_vma_lock_flags(start, len, flags);\n\n\tup_write(&current->mm->mmap_sem);\n\tif (error)\n\t\treturn error;\n\n\terror = __mm_populate(start, len, 0);\n\tif (error)\n\t\treturn __mlock_posix_error_return(error);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/rmap.h>",
      "#include <linux/export.h>",
      "#include <linux/sched.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/mm.h>",
      "#include <linux/mman.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mlock_posix_error_return",
          "args": [
            "error"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "__mlock_posix_error_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
          "lines": "225-232",
          "snippet": "static int __mlock_posix_error_return(long retval)\n{\n\tif (retval == -EFAULT)\n\t\tretval = -ENOMEM;\n\telse if (retval == -ENOMEM)\n\t\tretval = -EAGAIN;\n\treturn retval;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/rmap.h>",
            "#include <linux/export.h>",
            "#include <linux/sched.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/mm.h>",
            "#include <linux/mman.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nstatic int __mlock_posix_error_return(long retval)\n{\n\tif (retval == -EFAULT)\n\t\tretval = -ENOMEM;\n\telse if (retval == -ENOMEM)\n\t\tretval = -EAGAIN;\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mm_populate",
          "args": [
            "start",
            "len",
            "0"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "__mm_populate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "1258-1309",
          "snippet": "int __mm_populate(unsigned long start, unsigned long len, int ignore_errors)\n{\n\tstruct mm_struct *mm = current->mm;\n\tunsigned long end, nstart, nend;\n\tstruct vm_area_struct *vma = NULL;\n\tint locked = 0;\n\tlong ret = 0;\n\n\tend = start + len;\n\n\tfor (nstart = start; nstart < end; nstart = nend) {\n\t\t/*\n\t\t * We want to fault in pages for [nstart; end) address range.\n\t\t * Find first corresponding VMA.\n\t\t */\n\t\tif (!locked) {\n\t\t\tlocked = 1;\n\t\t\tdown_read(&mm->mmap_sem);\n\t\t\tvma = find_vma(mm, nstart);\n\t\t} else if (nstart >= vma->vm_end)\n\t\t\tvma = vma->vm_next;\n\t\tif (!vma || vma->vm_start >= end)\n\t\t\tbreak;\n\t\t/*\n\t\t * Set [nstart; nend) to intersection of desired address\n\t\t * range with the first VMA. Also, skip undesirable VMA types.\n\t\t */\n\t\tnend = min(end, vma->vm_end);\n\t\tif (vma->vm_flags & (VM_IO | VM_PFNMAP))\n\t\t\tcontinue;\n\t\tif (nstart < vma->vm_start)\n\t\t\tnstart = vma->vm_start;\n\t\t/*\n\t\t * Now fault in a range of pages. populate_vma_page_range()\n\t\t * double checks the vma flags, so that it won't mlock pages\n\t\t * if the vma was already munlocked.\n\t\t */\n\t\tret = populate_vma_page_range(vma, nstart, nend, &locked);\n\t\tif (ret < 0) {\n\t\t\tif (ignore_errors) {\n\t\t\t\tret = 0;\n\t\t\t\tcontinue;\t/* continue at next VMA */\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tnend = nstart + ret * PAGE_SIZE;\n\t\tret = 0;\n\t}\n\tif (locked)\n\t\tup_read(&mm->mmap_sem);\n\treturn ret;\t/* 0 or negative error code */\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nint __mm_populate(unsigned long start, unsigned long len, int ignore_errors)\n{\n\tstruct mm_struct *mm = current->mm;\n\tunsigned long end, nstart, nend;\n\tstruct vm_area_struct *vma = NULL;\n\tint locked = 0;\n\tlong ret = 0;\n\n\tend = start + len;\n\n\tfor (nstart = start; nstart < end; nstart = nend) {\n\t\t/*\n\t\t * We want to fault in pages for [nstart; end) address range.\n\t\t * Find first corresponding VMA.\n\t\t */\n\t\tif (!locked) {\n\t\t\tlocked = 1;\n\t\t\tdown_read(&mm->mmap_sem);\n\t\t\tvma = find_vma(mm, nstart);\n\t\t} else if (nstart >= vma->vm_end)\n\t\t\tvma = vma->vm_next;\n\t\tif (!vma || vma->vm_start >= end)\n\t\t\tbreak;\n\t\t/*\n\t\t * Set [nstart; nend) to intersection of desired address\n\t\t * range with the first VMA. Also, skip undesirable VMA types.\n\t\t */\n\t\tnend = min(end, vma->vm_end);\n\t\tif (vma->vm_flags & (VM_IO | VM_PFNMAP))\n\t\t\tcontinue;\n\t\tif (nstart < vma->vm_start)\n\t\t\tnstart = vma->vm_start;\n\t\t/*\n\t\t * Now fault in a range of pages. populate_vma_page_range()\n\t\t * double checks the vma flags, so that it won't mlock pages\n\t\t * if the vma was already munlocked.\n\t\t */\n\t\tret = populate_vma_page_range(vma, nstart, nend, &locked);\n\t\tif (ret < 0) {\n\t\t\tif (ignore_errors) {\n\t\t\t\tret = 0;\n\t\t\t\tcontinue;\t/* continue at next VMA */\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tnend = nstart + ret * PAGE_SIZE;\n\t\tret = 0;\n\t}\n\tif (locked)\n\t\tup_read(&mm->mmap_sem);\n\treturn ret;\t/* 0 or negative error code */\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&current->mm->mmap_sem"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apply_vma_lock_flags",
          "args": [
            "start",
            "len",
            "flags"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "apply_vma_lock_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
          "lines": "583-630",
          "snippet": "static int apply_vma_lock_flags(unsigned long start, size_t len,\n\t\t\t\tvm_flags_t flags)\n{\n\tunsigned long nstart, end, tmp;\n\tstruct vm_area_struct * vma, * prev;\n\tint error;\n\n\tVM_BUG_ON(offset_in_page(start));\n\tVM_BUG_ON(len != PAGE_ALIGN(len));\n\tend = start + len;\n\tif (end < start)\n\t\treturn -EINVAL;\n\tif (end == start)\n\t\treturn 0;\n\tvma = find_vma(current->mm, start);\n\tif (!vma || vma->vm_start > start)\n\t\treturn -ENOMEM;\n\n\tprev = vma->vm_prev;\n\tif (start > vma->vm_start)\n\t\tprev = vma;\n\n\tfor (nstart = start ; ; ) {\n\t\tvm_flags_t newflags = vma->vm_flags & VM_LOCKED_CLEAR_MASK;\n\n\t\tnewflags |= flags;\n\n\t\t/* Here we know that  vma->vm_start <= nstart < vma->vm_end. */\n\t\ttmp = vma->vm_end;\n\t\tif (tmp > end)\n\t\t\ttmp = end;\n\t\terror = mlock_fixup(vma, &prev, nstart, tmp, newflags);\n\t\tif (error)\n\t\t\tbreak;\n\t\tnstart = tmp;\n\t\tif (nstart < prev->vm_end)\n\t\t\tnstart = prev->vm_end;\n\t\tif (nstart >= end)\n\t\t\tbreak;\n\n\t\tvma = prev->vm_next;\n\t\tif (!vma || vma->vm_start != nstart) {\n\t\t\terror = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/rmap.h>",
            "#include <linux/export.h>",
            "#include <linux/sched.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/mm.h>",
            "#include <linux/mman.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nstatic int apply_vma_lock_flags(unsigned long start, size_t len,\n\t\t\t\tvm_flags_t flags)\n{\n\tunsigned long nstart, end, tmp;\n\tstruct vm_area_struct * vma, * prev;\n\tint error;\n\n\tVM_BUG_ON(offset_in_page(start));\n\tVM_BUG_ON(len != PAGE_ALIGN(len));\n\tend = start + len;\n\tif (end < start)\n\t\treturn -EINVAL;\n\tif (end == start)\n\t\treturn 0;\n\tvma = find_vma(current->mm, start);\n\tif (!vma || vma->vm_start > start)\n\t\treturn -ENOMEM;\n\n\tprev = vma->vm_prev;\n\tif (start > vma->vm_start)\n\t\tprev = vma;\n\n\tfor (nstart = start ; ; ) {\n\t\tvm_flags_t newflags = vma->vm_flags & VM_LOCKED_CLEAR_MASK;\n\n\t\tnewflags |= flags;\n\n\t\t/* Here we know that  vma->vm_start <= nstart < vma->vm_end. */\n\t\ttmp = vma->vm_end;\n\t\tif (tmp > end)\n\t\t\ttmp = end;\n\t\terror = mlock_fixup(vma, &prev, nstart, tmp, newflags);\n\t\tif (error)\n\t\t\tbreak;\n\t\tnstart = tmp;\n\t\tif (nstart < prev->vm_end)\n\t\t\tnstart = prev->vm_end;\n\t\tif (nstart >= end)\n\t\t\tbreak;\n\n\t\tvma = prev->vm_next;\n\t\tif (!vma || vma->vm_start != nstart) {\n\t\t\terror = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_IPC_LOCK"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_mm_mlocked_page_nr",
          "args": [
            "current->mm",
            "start",
            "len"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "count_mm_mlocked_page_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
          "lines": "639-669",
          "snippet": "static int count_mm_mlocked_page_nr(struct mm_struct *mm,\n\t\tunsigned long start, size_t len)\n{\n\tstruct vm_area_struct *vma;\n\tint count = 0;\n\n\tif (mm == NULL)\n\t\tmm = current->mm;\n\n\tvma = find_vma(mm, start);\n\tif (vma == NULL)\n\t\tvma = mm->mmap;\n\n\tfor (; vma ; vma = vma->vm_next) {\n\t\tif (start >= vma->vm_end)\n\t\t\tcontinue;\n\t\tif (start + len <=  vma->vm_start)\n\t\t\tbreak;\n\t\tif (vma->vm_flags & VM_LOCKED) {\n\t\t\tif (start > vma->vm_start)\n\t\t\t\tcount -= (start - vma->vm_start);\n\t\t\tif (start + len < vma->vm_end) {\n\t\t\t\tcount += start + len - vma->vm_start;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount += vma->vm_end - vma->vm_start;\n\t\t}\n\t}\n\n\treturn count >> PAGE_SHIFT;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/rmap.h>",
            "#include <linux/export.h>",
            "#include <linux/sched.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/mm.h>",
            "#include <linux/mman.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nstatic int count_mm_mlocked_page_nr(struct mm_struct *mm,\n\t\tunsigned long start, size_t len)\n{\n\tstruct vm_area_struct *vma;\n\tint count = 0;\n\n\tif (mm == NULL)\n\t\tmm = current->mm;\n\n\tvma = find_vma(mm, start);\n\tif (vma == NULL)\n\t\tvma = mm->mmap;\n\n\tfor (; vma ; vma = vma->vm_next) {\n\t\tif (start >= vma->vm_end)\n\t\t\tcontinue;\n\t\tif (start + len <=  vma->vm_start)\n\t\t\tbreak;\n\t\tif (vma->vm_flags & VM_LOCKED) {\n\t\t\tif (start > vma->vm_start)\n\t\t\t\tcount -= (start - vma->vm_start);\n\t\t\tif (start + len < vma->vm_end) {\n\t\t\t\tcount += start + len - vma->vm_start;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount += vma->vm_end - vma->vm_start;\n\t\t}\n\t}\n\n\treturn count >> PAGE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_IPC_LOCK"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write_killable",
          "args": [
            "&current->mm->mmap_sem"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rlimit",
          "args": [
            "RLIMIT_MEMLOCK"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "len + (offset_in_page(start))"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "start"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "can_do_mlock",
          "args": [],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "can_do_mlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
          "lines": "29-36",
          "snippet": "bool can_do_mlock(void)\n{\n\tif (rlimit(RLIMIT_MEMLOCK) != 0)\n\t\treturn true;\n\tif (capable(CAP_IPC_LOCK))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/rmap.h>",
            "#include <linux/export.h>",
            "#include <linux/sched.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/mm.h>",
            "#include <linux/mman.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nbool can_do_mlock(void)\n{\n\tif (rlimit(RLIMIT_MEMLOCK) != 0)\n\t\treturn true;\n\tif (capable(CAP_IPC_LOCK))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nstatic __must_check int do_mlock(unsigned long start, size_t len, vm_flags_t flags)\n{\n\tunsigned long locked;\n\tunsigned long lock_limit;\n\tint error = -ENOMEM;\n\n\tif (!can_do_mlock())\n\t\treturn -EPERM;\n\n\tlen = PAGE_ALIGN(len + (offset_in_page(start)));\n\tstart &= PAGE_MASK;\n\n\tlock_limit = rlimit(RLIMIT_MEMLOCK);\n\tlock_limit >>= PAGE_SHIFT;\n\tlocked = len >> PAGE_SHIFT;\n\n\tif (down_write_killable(&current->mm->mmap_sem))\n\t\treturn -EINTR;\n\n\tlocked += current->mm->locked_vm;\n\tif ((locked > lock_limit) && (!capable(CAP_IPC_LOCK))) {\n\t\t/*\n\t\t * It is possible that the regions requested intersect with\n\t\t * previously mlocked areas, that part area in \"mm->locked_vm\"\n\t\t * should not be counted to new mlock increment count. So check\n\t\t * and adjust locked count if necessary.\n\t\t */\n\t\tlocked -= count_mm_mlocked_page_nr(current->mm,\n\t\t\t\tstart, len);\n\t}\n\n\t/* check against resource limits */\n\tif ((locked <= lock_limit) || capable(CAP_IPC_LOCK))\n\t\terror = apply_vma_lock_flags(start, len, flags);\n\n\tup_write(&current->mm->mmap_sem);\n\tif (error)\n\t\treturn error;\n\n\terror = __mm_populate(start, len, 0);\n\tif (error)\n\t\treturn __mlock_posix_error_return(error);\n\treturn 0;\n}"
  },
  {
    "function_name": "count_mm_mlocked_page_nr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
    "lines": "639-669",
    "snippet": "static int count_mm_mlocked_page_nr(struct mm_struct *mm,\n\t\tunsigned long start, size_t len)\n{\n\tstruct vm_area_struct *vma;\n\tint count = 0;\n\n\tif (mm == NULL)\n\t\tmm = current->mm;\n\n\tvma = find_vma(mm, start);\n\tif (vma == NULL)\n\t\tvma = mm->mmap;\n\n\tfor (; vma ; vma = vma->vm_next) {\n\t\tif (start >= vma->vm_end)\n\t\t\tcontinue;\n\t\tif (start + len <=  vma->vm_start)\n\t\t\tbreak;\n\t\tif (vma->vm_flags & VM_LOCKED) {\n\t\t\tif (start > vma->vm_start)\n\t\t\t\tcount -= (start - vma->vm_start);\n\t\t\tif (start + len < vma->vm_end) {\n\t\t\t\tcount += start + len - vma->vm_start;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount += vma->vm_end - vma->vm_start;\n\t\t}\n\t}\n\n\treturn count >> PAGE_SHIFT;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/rmap.h>",
      "#include <linux/export.h>",
      "#include <linux/sched.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/mm.h>",
      "#include <linux/mman.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_vma",
          "args": [
            "mm",
            "start"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "find_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "775-796",
          "snippet": "struct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\n\t/* check the cache first */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\t/* trawl the list (there may be multiple mappings in which addr\n\t * resides) */\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_start > addr)\n\t\t\treturn NULL;\n\t\tif (vma->vm_end > addr) {\n\t\t\tvmacache_update(addr, vma);\n\t\t\treturn vma;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nstruct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\n\t/* check the cache first */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\t/* trawl the list (there may be multiple mappings in which addr\n\t * resides) */\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_start > addr)\n\t\t\treturn NULL;\n\t\tif (vma->vm_end > addr) {\n\t\t\tvmacache_update(addr, vma);\n\t\t\treturn vma;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nstatic int count_mm_mlocked_page_nr(struct mm_struct *mm,\n\t\tunsigned long start, size_t len)\n{\n\tstruct vm_area_struct *vma;\n\tint count = 0;\n\n\tif (mm == NULL)\n\t\tmm = current->mm;\n\n\tvma = find_vma(mm, start);\n\tif (vma == NULL)\n\t\tvma = mm->mmap;\n\n\tfor (; vma ; vma = vma->vm_next) {\n\t\tif (start >= vma->vm_end)\n\t\t\tcontinue;\n\t\tif (start + len <=  vma->vm_start)\n\t\t\tbreak;\n\t\tif (vma->vm_flags & VM_LOCKED) {\n\t\t\tif (start > vma->vm_start)\n\t\t\t\tcount -= (start - vma->vm_start);\n\t\t\tif (start + len < vma->vm_end) {\n\t\t\t\tcount += start + len - vma->vm_start;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount += vma->vm_end - vma->vm_start;\n\t\t}\n\t}\n\n\treturn count >> PAGE_SHIFT;\n}"
  },
  {
    "function_name": "apply_vma_lock_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
    "lines": "583-630",
    "snippet": "static int apply_vma_lock_flags(unsigned long start, size_t len,\n\t\t\t\tvm_flags_t flags)\n{\n\tunsigned long nstart, end, tmp;\n\tstruct vm_area_struct * vma, * prev;\n\tint error;\n\n\tVM_BUG_ON(offset_in_page(start));\n\tVM_BUG_ON(len != PAGE_ALIGN(len));\n\tend = start + len;\n\tif (end < start)\n\t\treturn -EINVAL;\n\tif (end == start)\n\t\treturn 0;\n\tvma = find_vma(current->mm, start);\n\tif (!vma || vma->vm_start > start)\n\t\treturn -ENOMEM;\n\n\tprev = vma->vm_prev;\n\tif (start > vma->vm_start)\n\t\tprev = vma;\n\n\tfor (nstart = start ; ; ) {\n\t\tvm_flags_t newflags = vma->vm_flags & VM_LOCKED_CLEAR_MASK;\n\n\t\tnewflags |= flags;\n\n\t\t/* Here we know that  vma->vm_start <= nstart < vma->vm_end. */\n\t\ttmp = vma->vm_end;\n\t\tif (tmp > end)\n\t\t\ttmp = end;\n\t\terror = mlock_fixup(vma, &prev, nstart, tmp, newflags);\n\t\tif (error)\n\t\t\tbreak;\n\t\tnstart = tmp;\n\t\tif (nstart < prev->vm_end)\n\t\t\tnstart = prev->vm_end;\n\t\tif (nstart >= end)\n\t\t\tbreak;\n\n\t\tvma = prev->vm_next;\n\t\tif (!vma || vma->vm_start != nstart) {\n\t\t\terror = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/rmap.h>",
      "#include <linux/export.h>",
      "#include <linux/sched.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/mm.h>",
      "#include <linux/mman.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlock_fixup",
          "args": [
            "vma",
            "&prev",
            "nstart",
            "tmp",
            "newflags"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "mlock_fixup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
          "lines": "519-581",
          "snippet": "static int mlock_fixup(struct vm_area_struct *vma, struct vm_area_struct **prev,\n\tunsigned long start, unsigned long end, vm_flags_t newflags)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpgoff_t pgoff;\n\tint nr_pages;\n\tint ret = 0;\n\tint lock = !!(newflags & VM_LOCKED);\n\tvm_flags_t old_flags = vma->vm_flags;\n\n\tif (newflags == vma->vm_flags || (vma->vm_flags & VM_SPECIAL) ||\n\t    is_vm_hugetlb_page(vma) || vma == get_gate_vma(current->mm) ||\n\t    vma_is_dax(vma))\n\t\t/* don't set VM_LOCKED or VM_LOCKONFAULT and don't count */\n\t\tgoto out;\n\n\tpgoff = vma->vm_pgoff + ((start - vma->vm_start) >> PAGE_SHIFT);\n\t*prev = vma_merge(mm, *prev, start, end, newflags, vma->anon_vma,\n\t\t\t  vma->vm_file, pgoff, vma_policy(vma),\n\t\t\t  vma->vm_userfaultfd_ctx);\n\tif (*prev) {\n\t\tvma = *prev;\n\t\tgoto success;\n\t}\n\n\tif (start != vma->vm_start) {\n\t\tret = split_vma(mm, vma, start, 1);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (end != vma->vm_end) {\n\t\tret = split_vma(mm, vma, end, 0);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\nsuccess:\n\t/*\n\t * Keep track of amount of locked VM.\n\t */\n\tnr_pages = (end - start) >> PAGE_SHIFT;\n\tif (!lock)\n\t\tnr_pages = -nr_pages;\n\telse if (old_flags & VM_LOCKED)\n\t\tnr_pages = 0;\n\tmm->locked_vm += nr_pages;\n\n\t/*\n\t * vm_flags is protected by the mmap_sem held in write mode.\n\t * It's okay if try_to_unmap_one unmaps a page just after we\n\t * set VM_LOCKED, populate_vma_page_range will bring it back.\n\t */\n\n\tif (lock)\n\t\tvma->vm_flags = newflags;\n\telse\n\t\tmunlock_vma_pages_range(vma, start, end);\n\nout:\n\t*prev = vma;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/rmap.h>",
            "#include <linux/export.h>",
            "#include <linux/sched.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/mm.h>",
            "#include <linux/mman.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nstatic int mlock_fixup(struct vm_area_struct *vma, struct vm_area_struct **prev,\n\tunsigned long start, unsigned long end, vm_flags_t newflags)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpgoff_t pgoff;\n\tint nr_pages;\n\tint ret = 0;\n\tint lock = !!(newflags & VM_LOCKED);\n\tvm_flags_t old_flags = vma->vm_flags;\n\n\tif (newflags == vma->vm_flags || (vma->vm_flags & VM_SPECIAL) ||\n\t    is_vm_hugetlb_page(vma) || vma == get_gate_vma(current->mm) ||\n\t    vma_is_dax(vma))\n\t\t/* don't set VM_LOCKED or VM_LOCKONFAULT and don't count */\n\t\tgoto out;\n\n\tpgoff = vma->vm_pgoff + ((start - vma->vm_start) >> PAGE_SHIFT);\n\t*prev = vma_merge(mm, *prev, start, end, newflags, vma->anon_vma,\n\t\t\t  vma->vm_file, pgoff, vma_policy(vma),\n\t\t\t  vma->vm_userfaultfd_ctx);\n\tif (*prev) {\n\t\tvma = *prev;\n\t\tgoto success;\n\t}\n\n\tif (start != vma->vm_start) {\n\t\tret = split_vma(mm, vma, start, 1);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (end != vma->vm_end) {\n\t\tret = split_vma(mm, vma, end, 0);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\nsuccess:\n\t/*\n\t * Keep track of amount of locked VM.\n\t */\n\tnr_pages = (end - start) >> PAGE_SHIFT;\n\tif (!lock)\n\t\tnr_pages = -nr_pages;\n\telse if (old_flags & VM_LOCKED)\n\t\tnr_pages = 0;\n\tmm->locked_vm += nr_pages;\n\n\t/*\n\t * vm_flags is protected by the mmap_sem held in write mode.\n\t * It's okay if try_to_unmap_one unmaps a page just after we\n\t * set VM_LOCKED, populate_vma_page_range will bring it back.\n\t */\n\n\tif (lock)\n\t\tvma->vm_flags = newflags;\n\telse\n\t\tmunlock_vma_pages_range(vma, start, end);\n\nout:\n\t*prev = vma;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_vma",
          "args": [
            "current->mm",
            "start"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "find_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "775-796",
          "snippet": "struct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\n\t/* check the cache first */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\t/* trawl the list (there may be multiple mappings in which addr\n\t * resides) */\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_start > addr)\n\t\t\treturn NULL;\n\t\tif (vma->vm_end > addr) {\n\t\t\tvmacache_update(addr, vma);\n\t\t\treturn vma;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nstruct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\n\t/* check the cache first */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\t/* trawl the list (there may be multiple mappings in which addr\n\t * resides) */\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_start > addr)\n\t\t\treturn NULL;\n\t\tif (vma->vm_end > addr) {\n\t\t\tvmacache_update(addr, vma);\n\t\t\treturn vma;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "len != PAGE_ALIGN(len)"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "len"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "offset_in_page(start)"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "start"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nstatic int apply_vma_lock_flags(unsigned long start, size_t len,\n\t\t\t\tvm_flags_t flags)\n{\n\tunsigned long nstart, end, tmp;\n\tstruct vm_area_struct * vma, * prev;\n\tint error;\n\n\tVM_BUG_ON(offset_in_page(start));\n\tVM_BUG_ON(len != PAGE_ALIGN(len));\n\tend = start + len;\n\tif (end < start)\n\t\treturn -EINVAL;\n\tif (end == start)\n\t\treturn 0;\n\tvma = find_vma(current->mm, start);\n\tif (!vma || vma->vm_start > start)\n\t\treturn -ENOMEM;\n\n\tprev = vma->vm_prev;\n\tif (start > vma->vm_start)\n\t\tprev = vma;\n\n\tfor (nstart = start ; ; ) {\n\t\tvm_flags_t newflags = vma->vm_flags & VM_LOCKED_CLEAR_MASK;\n\n\t\tnewflags |= flags;\n\n\t\t/* Here we know that  vma->vm_start <= nstart < vma->vm_end. */\n\t\ttmp = vma->vm_end;\n\t\tif (tmp > end)\n\t\t\ttmp = end;\n\t\terror = mlock_fixup(vma, &prev, nstart, tmp, newflags);\n\t\tif (error)\n\t\t\tbreak;\n\t\tnstart = tmp;\n\t\tif (nstart < prev->vm_end)\n\t\t\tnstart = prev->vm_end;\n\t\tif (nstart >= end)\n\t\t\tbreak;\n\n\t\tvma = prev->vm_next;\n\t\tif (!vma || vma->vm_start != nstart) {\n\t\t\terror = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "mlock_fixup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
    "lines": "519-581",
    "snippet": "static int mlock_fixup(struct vm_area_struct *vma, struct vm_area_struct **prev,\n\tunsigned long start, unsigned long end, vm_flags_t newflags)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpgoff_t pgoff;\n\tint nr_pages;\n\tint ret = 0;\n\tint lock = !!(newflags & VM_LOCKED);\n\tvm_flags_t old_flags = vma->vm_flags;\n\n\tif (newflags == vma->vm_flags || (vma->vm_flags & VM_SPECIAL) ||\n\t    is_vm_hugetlb_page(vma) || vma == get_gate_vma(current->mm) ||\n\t    vma_is_dax(vma))\n\t\t/* don't set VM_LOCKED or VM_LOCKONFAULT and don't count */\n\t\tgoto out;\n\n\tpgoff = vma->vm_pgoff + ((start - vma->vm_start) >> PAGE_SHIFT);\n\t*prev = vma_merge(mm, *prev, start, end, newflags, vma->anon_vma,\n\t\t\t  vma->vm_file, pgoff, vma_policy(vma),\n\t\t\t  vma->vm_userfaultfd_ctx);\n\tif (*prev) {\n\t\tvma = *prev;\n\t\tgoto success;\n\t}\n\n\tif (start != vma->vm_start) {\n\t\tret = split_vma(mm, vma, start, 1);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (end != vma->vm_end) {\n\t\tret = split_vma(mm, vma, end, 0);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\nsuccess:\n\t/*\n\t * Keep track of amount of locked VM.\n\t */\n\tnr_pages = (end - start) >> PAGE_SHIFT;\n\tif (!lock)\n\t\tnr_pages = -nr_pages;\n\telse if (old_flags & VM_LOCKED)\n\t\tnr_pages = 0;\n\tmm->locked_vm += nr_pages;\n\n\t/*\n\t * vm_flags is protected by the mmap_sem held in write mode.\n\t * It's okay if try_to_unmap_one unmaps a page just after we\n\t * set VM_LOCKED, populate_vma_page_range will bring it back.\n\t */\n\n\tif (lock)\n\t\tvma->vm_flags = newflags;\n\telse\n\t\tmunlock_vma_pages_range(vma, start, end);\n\nout:\n\t*prev = vma;\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/rmap.h>",
      "#include <linux/export.h>",
      "#include <linux/sched.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/mm.h>",
      "#include <linux/mman.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "munlock_vma_pages_range",
          "args": [
            "vma",
            "start",
            "end"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "munlock_vma_pages_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
          "lines": "445-508",
          "snippet": "void munlock_vma_pages_range(struct vm_area_struct *vma,\n\t\t\t     unsigned long start, unsigned long end)\n{\n\tvma->vm_flags &= VM_LOCKED_CLEAR_MASK;\n\n\twhile (start < end) {\n\t\tstruct page *page;\n\t\tunsigned int page_mask = 0;\n\t\tunsigned long page_increm;\n\t\tstruct pagevec pvec;\n\t\tstruct zone *zone;\n\n\t\tpagevec_init(&pvec);\n\t\t/*\n\t\t * Although FOLL_DUMP is intended for get_dump_page(),\n\t\t * it just so happens that its special treatment of the\n\t\t * ZERO_PAGE (returning an error instead of doing get_page)\n\t\t * suits munlock very well (and if somehow an abnormal page\n\t\t * has sneaked into the range, we won't oops here: great).\n\t\t */\n\t\tpage = follow_page(vma, start, FOLL_GET | FOLL_DUMP);\n\n\t\tif (page && !IS_ERR(page)) {\n\t\t\tif (PageTransTail(page)) {\n\t\t\t\tVM_BUG_ON_PAGE(PageMlocked(page), page);\n\t\t\t\tput_page(page); /* follow_page_mask() */\n\t\t\t} else if (PageTransHuge(page)) {\n\t\t\t\tlock_page(page);\n\t\t\t\t/*\n\t\t\t\t * Any THP page found by follow_page_mask() may\n\t\t\t\t * have gotten split before reaching\n\t\t\t\t * munlock_vma_page(), so we need to compute\n\t\t\t\t * the page_mask here instead.\n\t\t\t\t */\n\t\t\t\tpage_mask = munlock_vma_page(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tput_page(page); /* follow_page_mask() */\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Non-huge pages are handled in batches via\n\t\t\t\t * pagevec. The pin from follow_page_mask()\n\t\t\t\t * prevents them from collapsing by THP.\n\t\t\t\t */\n\t\t\t\tpagevec_add(&pvec, page);\n\t\t\t\tzone = page_zone(page);\n\n\t\t\t\t/*\n\t\t\t\t * Try to fill the rest of pagevec using fast\n\t\t\t\t * pte walk. This will also update start to\n\t\t\t\t * the next page to process. Then munlock the\n\t\t\t\t * pagevec.\n\t\t\t\t */\n\t\t\t\tstart = __munlock_pagevec_fill(&pvec, vma,\n\t\t\t\t\t\tzone, start, end);\n\t\t\t\t__munlock_pagevec(&pvec, zone);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\t\tpage_increm = 1 + page_mask;\n\t\tstart += page_increm * PAGE_SIZE;\nnext:\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/rmap.h>",
            "#include <linux/export.h>",
            "#include <linux/sched.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/mm.h>",
            "#include <linux/mman.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nvoid munlock_vma_pages_range(struct vm_area_struct *vma,\n\t\t\t     unsigned long start, unsigned long end)\n{\n\tvma->vm_flags &= VM_LOCKED_CLEAR_MASK;\n\n\twhile (start < end) {\n\t\tstruct page *page;\n\t\tunsigned int page_mask = 0;\n\t\tunsigned long page_increm;\n\t\tstruct pagevec pvec;\n\t\tstruct zone *zone;\n\n\t\tpagevec_init(&pvec);\n\t\t/*\n\t\t * Although FOLL_DUMP is intended for get_dump_page(),\n\t\t * it just so happens that its special treatment of the\n\t\t * ZERO_PAGE (returning an error instead of doing get_page)\n\t\t * suits munlock very well (and if somehow an abnormal page\n\t\t * has sneaked into the range, we won't oops here: great).\n\t\t */\n\t\tpage = follow_page(vma, start, FOLL_GET | FOLL_DUMP);\n\n\t\tif (page && !IS_ERR(page)) {\n\t\t\tif (PageTransTail(page)) {\n\t\t\t\tVM_BUG_ON_PAGE(PageMlocked(page), page);\n\t\t\t\tput_page(page); /* follow_page_mask() */\n\t\t\t} else if (PageTransHuge(page)) {\n\t\t\t\tlock_page(page);\n\t\t\t\t/*\n\t\t\t\t * Any THP page found by follow_page_mask() may\n\t\t\t\t * have gotten split before reaching\n\t\t\t\t * munlock_vma_page(), so we need to compute\n\t\t\t\t * the page_mask here instead.\n\t\t\t\t */\n\t\t\t\tpage_mask = munlock_vma_page(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tput_page(page); /* follow_page_mask() */\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Non-huge pages are handled in batches via\n\t\t\t\t * pagevec. The pin from follow_page_mask()\n\t\t\t\t * prevents them from collapsing by THP.\n\t\t\t\t */\n\t\t\t\tpagevec_add(&pvec, page);\n\t\t\t\tzone = page_zone(page);\n\n\t\t\t\t/*\n\t\t\t\t * Try to fill the rest of pagevec using fast\n\t\t\t\t * pte walk. This will also update start to\n\t\t\t\t * the next page to process. Then munlock the\n\t\t\t\t * pagevec.\n\t\t\t\t */\n\t\t\t\tstart = __munlock_pagevec_fill(&pvec, vma,\n\t\t\t\t\t\tzone, start, end);\n\t\t\t\t__munlock_pagevec(&pvec, zone);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\t\tpage_increm = 1 + page_mask;\n\t\tstart += page_increm * PAGE_SIZE;\nnext:\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "split_vma",
          "args": [
            "mm",
            "vma",
            "end",
            "0"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "split_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "1450-1507",
          "snippet": "int split_vma(struct mm_struct *mm, struct vm_area_struct *vma,\n\t      unsigned long addr, int new_below)\n{\n\tstruct vm_area_struct *new;\n\tstruct vm_region *region;\n\tunsigned long npages;\n\n\t/* we're only permitted to split anonymous regions (these should have\n\t * only a single usage on the region) */\n\tif (vma->vm_file)\n\t\treturn -ENOMEM;\n\n\tif (mm->map_count >= sysctl_max_map_count)\n\t\treturn -ENOMEM;\n\n\tregion = kmem_cache_alloc(vm_region_jar, GFP_KERNEL);\n\tif (!region)\n\t\treturn -ENOMEM;\n\n\tnew = vm_area_dup(vma);\n\tif (!new) {\n\t\tkmem_cache_free(vm_region_jar, region);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* most fields are the same, copy all, and then fixup */\n\t*region = *vma->vm_region;\n\tnew->vm_region = region;\n\n\tnpages = (addr - vma->vm_start) >> PAGE_SHIFT;\n\n\tif (new_below) {\n\t\tregion->vm_top = region->vm_end = new->vm_end = addr;\n\t} else {\n\t\tregion->vm_start = new->vm_start = addr;\n\t\tregion->vm_pgoff = new->vm_pgoff += npages;\n\t}\n\n\tif (new->vm_ops && new->vm_ops->open)\n\t\tnew->vm_ops->open(new);\n\n\tdelete_vma_from_mm(vma);\n\tdown_write(&nommu_region_sem);\n\tdelete_nommu_region(vma->vm_region);\n\tif (new_below) {\n\t\tvma->vm_region->vm_start = vma->vm_start = addr;\n\t\tvma->vm_region->vm_pgoff = vma->vm_pgoff += npages;\n\t} else {\n\t\tvma->vm_region->vm_end = vma->vm_end = addr;\n\t\tvma->vm_region->vm_top = addr;\n\t}\n\tadd_nommu_region(vma->vm_region);\n\tadd_nommu_region(new->vm_region);\n\tup_write(&nommu_region_sem);\n\tadd_vma_to_mm(mm, vma);\n\tadd_vma_to_mm(mm, new);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *vm_region_jar;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *vm_region_jar;\n\nint split_vma(struct mm_struct *mm, struct vm_area_struct *vma,\n\t      unsigned long addr, int new_below)\n{\n\tstruct vm_area_struct *new;\n\tstruct vm_region *region;\n\tunsigned long npages;\n\n\t/* we're only permitted to split anonymous regions (these should have\n\t * only a single usage on the region) */\n\tif (vma->vm_file)\n\t\treturn -ENOMEM;\n\n\tif (mm->map_count >= sysctl_max_map_count)\n\t\treturn -ENOMEM;\n\n\tregion = kmem_cache_alloc(vm_region_jar, GFP_KERNEL);\n\tif (!region)\n\t\treturn -ENOMEM;\n\n\tnew = vm_area_dup(vma);\n\tif (!new) {\n\t\tkmem_cache_free(vm_region_jar, region);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* most fields are the same, copy all, and then fixup */\n\t*region = *vma->vm_region;\n\tnew->vm_region = region;\n\n\tnpages = (addr - vma->vm_start) >> PAGE_SHIFT;\n\n\tif (new_below) {\n\t\tregion->vm_top = region->vm_end = new->vm_end = addr;\n\t} else {\n\t\tregion->vm_start = new->vm_start = addr;\n\t\tregion->vm_pgoff = new->vm_pgoff += npages;\n\t}\n\n\tif (new->vm_ops && new->vm_ops->open)\n\t\tnew->vm_ops->open(new);\n\n\tdelete_vma_from_mm(vma);\n\tdown_write(&nommu_region_sem);\n\tdelete_nommu_region(vma->vm_region);\n\tif (new_below) {\n\t\tvma->vm_region->vm_start = vma->vm_start = addr;\n\t\tvma->vm_region->vm_pgoff = vma->vm_pgoff += npages;\n\t} else {\n\t\tvma->vm_region->vm_end = vma->vm_end = addr;\n\t\tvma->vm_region->vm_top = addr;\n\t}\n\tadd_nommu_region(vma->vm_region);\n\tadd_nommu_region(new->vm_region);\n\tup_write(&nommu_region_sem);\n\tadd_vma_to_mm(mm, vma);\n\tadd_vma_to_mm(mm, new);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_merge",
          "args": [
            "mm",
            "*prev",
            "start",
            "end",
            "newflags",
            "vma->anon_vma",
            "vma->vm_file",
            "pgoff",
            "vma_policy(vma)",
            "vma->vm_userfaultfd_ctx"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "vma_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "1132-1223",
          "snippet": "struct vm_area_struct *vma_merge(struct mm_struct *mm,\n\t\t\tstruct vm_area_struct *prev, unsigned long addr,\n\t\t\tunsigned long end, unsigned long vm_flags,\n\t\t\tstruct anon_vma *anon_vma, struct file *file,\n\t\t\tpgoff_t pgoff, struct mempolicy *policy,\n\t\t\tstruct vm_userfaultfd_ctx vm_userfaultfd_ctx)\n{\n\tpgoff_t pglen = (end - addr) >> PAGE_SHIFT;\n\tstruct vm_area_struct *area, *next;\n\tint err;\n\n\t/*\n\t * We later require that vma->vm_flags == vm_flags,\n\t * so this tests vma->vm_flags & VM_SPECIAL, too.\n\t */\n\tif (vm_flags & VM_SPECIAL)\n\t\treturn NULL;\n\n\tif (prev)\n\t\tnext = prev->vm_next;\n\telse\n\t\tnext = mm->mmap;\n\tarea = next;\n\tif (area && area->vm_end == end)\t\t/* cases 6, 7, 8 */\n\t\tnext = next->vm_next;\n\n\t/* verify some invariant that must be enforced by the caller */\n\tVM_WARN_ON(prev && addr <= prev->vm_start);\n\tVM_WARN_ON(area && end > area->vm_end);\n\tVM_WARN_ON(addr >= end);\n\n\t/*\n\t * Can it merge with the predecessor?\n\t */\n\tif (prev && prev->vm_end == addr &&\n\t\t\tmpol_equal(vma_policy(prev), policy) &&\n\t\t\tcan_vma_merge_after(prev, vm_flags,\n\t\t\t\t\t    anon_vma, file, pgoff,\n\t\t\t\t\t    vm_userfaultfd_ctx)) {\n\t\t/*\n\t\t * OK, it can.  Can we now merge in the successor as well?\n\t\t */\n\t\tif (next && end == next->vm_start &&\n\t\t\t\tmpol_equal(policy, vma_policy(next)) &&\n\t\t\t\tcan_vma_merge_before(next, vm_flags,\n\t\t\t\t\t\t     anon_vma, file,\n\t\t\t\t\t\t     pgoff+pglen,\n\t\t\t\t\t\t     vm_userfaultfd_ctx) &&\n\t\t\t\tis_mergeable_anon_vma(prev->anon_vma,\n\t\t\t\t\t\t      next->anon_vma, NULL)) {\n\t\t\t\t\t\t\t/* cases 1, 6 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t next->vm_end, prev->vm_pgoff, NULL,\n\t\t\t\t\t prev);\n\t\t} else\t\t\t\t\t/* cases 2, 5, 7 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t end, prev->vm_pgoff, NULL, prev);\n\t\tif (err)\n\t\t\treturn NULL;\n\t\tkhugepaged_enter_vma_merge(prev, vm_flags);\n\t\treturn prev;\n\t}\n\n\t/*\n\t * Can this new request be merged in front of next?\n\t */\n\tif (next && end == next->vm_start &&\n\t\t\tmpol_equal(policy, vma_policy(next)) &&\n\t\t\tcan_vma_merge_before(next, vm_flags,\n\t\t\t\t\t     anon_vma, file, pgoff+pglen,\n\t\t\t\t\t     vm_userfaultfd_ctx)) {\n\t\tif (prev && addr < prev->vm_end)\t/* case 4 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t addr, prev->vm_pgoff, NULL, next);\n\t\telse {\t\t\t\t\t/* cases 3, 8 */\n\t\t\terr = __vma_adjust(area, addr, next->vm_end,\n\t\t\t\t\t next->vm_pgoff - pglen, NULL, next);\n\t\t\t/*\n\t\t\t * In case 3 area is already equal to next and\n\t\t\t * this is a noop, but in case 8 \"area\" has\n\t\t\t * been removed and next was expanded over it.\n\t\t\t */\n\t\t\tarea = next;\n\t\t}\n\t\tif (err)\n\t\t\treturn NULL;\n\t\tkhugepaged_enter_vma_merge(area, vm_flags);\n\t\treturn area;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);\n\nstruct vm_area_struct *vma_merge(struct mm_struct *mm,\n\t\t\tstruct vm_area_struct *prev, unsigned long addr,\n\t\t\tunsigned long end, unsigned long vm_flags,\n\t\t\tstruct anon_vma *anon_vma, struct file *file,\n\t\t\tpgoff_t pgoff, struct mempolicy *policy,\n\t\t\tstruct vm_userfaultfd_ctx vm_userfaultfd_ctx)\n{\n\tpgoff_t pglen = (end - addr) >> PAGE_SHIFT;\n\tstruct vm_area_struct *area, *next;\n\tint err;\n\n\t/*\n\t * We later require that vma->vm_flags == vm_flags,\n\t * so this tests vma->vm_flags & VM_SPECIAL, too.\n\t */\n\tif (vm_flags & VM_SPECIAL)\n\t\treturn NULL;\n\n\tif (prev)\n\t\tnext = prev->vm_next;\n\telse\n\t\tnext = mm->mmap;\n\tarea = next;\n\tif (area && area->vm_end == end)\t\t/* cases 6, 7, 8 */\n\t\tnext = next->vm_next;\n\n\t/* verify some invariant that must be enforced by the caller */\n\tVM_WARN_ON(prev && addr <= prev->vm_start);\n\tVM_WARN_ON(area && end > area->vm_end);\n\tVM_WARN_ON(addr >= end);\n\n\t/*\n\t * Can it merge with the predecessor?\n\t */\n\tif (prev && prev->vm_end == addr &&\n\t\t\tmpol_equal(vma_policy(prev), policy) &&\n\t\t\tcan_vma_merge_after(prev, vm_flags,\n\t\t\t\t\t    anon_vma, file, pgoff,\n\t\t\t\t\t    vm_userfaultfd_ctx)) {\n\t\t/*\n\t\t * OK, it can.  Can we now merge in the successor as well?\n\t\t */\n\t\tif (next && end == next->vm_start &&\n\t\t\t\tmpol_equal(policy, vma_policy(next)) &&\n\t\t\t\tcan_vma_merge_before(next, vm_flags,\n\t\t\t\t\t\t     anon_vma, file,\n\t\t\t\t\t\t     pgoff+pglen,\n\t\t\t\t\t\t     vm_userfaultfd_ctx) &&\n\t\t\t\tis_mergeable_anon_vma(prev->anon_vma,\n\t\t\t\t\t\t      next->anon_vma, NULL)) {\n\t\t\t\t\t\t\t/* cases 1, 6 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t next->vm_end, prev->vm_pgoff, NULL,\n\t\t\t\t\t prev);\n\t\t} else\t\t\t\t\t/* cases 2, 5, 7 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t end, prev->vm_pgoff, NULL, prev);\n\t\tif (err)\n\t\t\treturn NULL;\n\t\tkhugepaged_enter_vma_merge(prev, vm_flags);\n\t\treturn prev;\n\t}\n\n\t/*\n\t * Can this new request be merged in front of next?\n\t */\n\tif (next && end == next->vm_start &&\n\t\t\tmpol_equal(policy, vma_policy(next)) &&\n\t\t\tcan_vma_merge_before(next, vm_flags,\n\t\t\t\t\t     anon_vma, file, pgoff+pglen,\n\t\t\t\t\t     vm_userfaultfd_ctx)) {\n\t\tif (prev && addr < prev->vm_end)\t/* case 4 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t addr, prev->vm_pgoff, NULL, next);\n\t\telse {\t\t\t\t\t/* cases 3, 8 */\n\t\t\terr = __vma_adjust(area, addr, next->vm_end,\n\t\t\t\t\t next->vm_pgoff - pglen, NULL, next);\n\t\t\t/*\n\t\t\t * In case 3 area is already equal to next and\n\t\t\t * this is a noop, but in case 8 \"area\" has\n\t\t\t * been removed and next was expanded over it.\n\t\t\t */\n\t\t\tarea = next;\n\t\t}\n\t\tif (err)\n\t\t\treturn NULL;\n\t\tkhugepaged_enter_vma_merge(area, vm_flags);\n\t\treturn area;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_policy",
          "args": [
            "vma"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "vma_policy_mof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1676-1696",
          "snippet": "bool vma_policy_mof(struct vm_area_struct *vma)\n{\n\tstruct mempolicy *pol;\n\n\tif (vma->vm_ops && vma->vm_ops->get_policy) {\n\t\tbool ret = false;\n\n\t\tpol = vma->vm_ops->get_policy(vma, vma->vm_start);\n\t\tif (pol && (pol->flags & MPOL_F_MOF))\n\t\t\tret = true;\n\t\tmpol_cond_put(pol);\n\n\t\treturn ret;\n\t}\n\n\tpol = vma->vm_policy;\n\tif (!pol)\n\t\tpol = get_task_policy(current);\n\n\treturn pol->flags & MPOL_F_MOF;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nbool vma_policy_mof(struct vm_area_struct *vma)\n{\n\tstruct mempolicy *pol;\n\n\tif (vma->vm_ops && vma->vm_ops->get_policy) {\n\t\tbool ret = false;\n\n\t\tpol = vma->vm_ops->get_policy(vma, vma->vm_start);\n\t\tif (pol && (pol->flags & MPOL_F_MOF))\n\t\t\tret = true;\n\t\tmpol_cond_put(pol);\n\n\t\treturn ret;\n\t}\n\n\tpol = vma->vm_policy;\n\tif (!pol)\n\t\tpol = get_task_policy(current);\n\n\treturn pol->flags & MPOL_F_MOF;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_is_dax",
          "args": [
            "vma"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_gate_vma",
          "args": [
            "current->mm"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vm_hugetlb_page",
          "args": [
            "vma"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nstatic int mlock_fixup(struct vm_area_struct *vma, struct vm_area_struct **prev,\n\tunsigned long start, unsigned long end, vm_flags_t newflags)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpgoff_t pgoff;\n\tint nr_pages;\n\tint ret = 0;\n\tint lock = !!(newflags & VM_LOCKED);\n\tvm_flags_t old_flags = vma->vm_flags;\n\n\tif (newflags == vma->vm_flags || (vma->vm_flags & VM_SPECIAL) ||\n\t    is_vm_hugetlb_page(vma) || vma == get_gate_vma(current->mm) ||\n\t    vma_is_dax(vma))\n\t\t/* don't set VM_LOCKED or VM_LOCKONFAULT and don't count */\n\t\tgoto out;\n\n\tpgoff = vma->vm_pgoff + ((start - vma->vm_start) >> PAGE_SHIFT);\n\t*prev = vma_merge(mm, *prev, start, end, newflags, vma->anon_vma,\n\t\t\t  vma->vm_file, pgoff, vma_policy(vma),\n\t\t\t  vma->vm_userfaultfd_ctx);\n\tif (*prev) {\n\t\tvma = *prev;\n\t\tgoto success;\n\t}\n\n\tif (start != vma->vm_start) {\n\t\tret = split_vma(mm, vma, start, 1);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (end != vma->vm_end) {\n\t\tret = split_vma(mm, vma, end, 0);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\nsuccess:\n\t/*\n\t * Keep track of amount of locked VM.\n\t */\n\tnr_pages = (end - start) >> PAGE_SHIFT;\n\tif (!lock)\n\t\tnr_pages = -nr_pages;\n\telse if (old_flags & VM_LOCKED)\n\t\tnr_pages = 0;\n\tmm->locked_vm += nr_pages;\n\n\t/*\n\t * vm_flags is protected by the mmap_sem held in write mode.\n\t * It's okay if try_to_unmap_one unmaps a page just after we\n\t * set VM_LOCKED, populate_vma_page_range will bring it back.\n\t */\n\n\tif (lock)\n\t\tvma->vm_flags = newflags;\n\telse\n\t\tmunlock_vma_pages_range(vma, start, end);\n\nout:\n\t*prev = vma;\n\treturn ret;\n}"
  },
  {
    "function_name": "munlock_vma_pages_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
    "lines": "445-508",
    "snippet": "void munlock_vma_pages_range(struct vm_area_struct *vma,\n\t\t\t     unsigned long start, unsigned long end)\n{\n\tvma->vm_flags &= VM_LOCKED_CLEAR_MASK;\n\n\twhile (start < end) {\n\t\tstruct page *page;\n\t\tunsigned int page_mask = 0;\n\t\tunsigned long page_increm;\n\t\tstruct pagevec pvec;\n\t\tstruct zone *zone;\n\n\t\tpagevec_init(&pvec);\n\t\t/*\n\t\t * Although FOLL_DUMP is intended for get_dump_page(),\n\t\t * it just so happens that its special treatment of the\n\t\t * ZERO_PAGE (returning an error instead of doing get_page)\n\t\t * suits munlock very well (and if somehow an abnormal page\n\t\t * has sneaked into the range, we won't oops here: great).\n\t\t */\n\t\tpage = follow_page(vma, start, FOLL_GET | FOLL_DUMP);\n\n\t\tif (page && !IS_ERR(page)) {\n\t\t\tif (PageTransTail(page)) {\n\t\t\t\tVM_BUG_ON_PAGE(PageMlocked(page), page);\n\t\t\t\tput_page(page); /* follow_page_mask() */\n\t\t\t} else if (PageTransHuge(page)) {\n\t\t\t\tlock_page(page);\n\t\t\t\t/*\n\t\t\t\t * Any THP page found by follow_page_mask() may\n\t\t\t\t * have gotten split before reaching\n\t\t\t\t * munlock_vma_page(), so we need to compute\n\t\t\t\t * the page_mask here instead.\n\t\t\t\t */\n\t\t\t\tpage_mask = munlock_vma_page(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tput_page(page); /* follow_page_mask() */\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Non-huge pages are handled in batches via\n\t\t\t\t * pagevec. The pin from follow_page_mask()\n\t\t\t\t * prevents them from collapsing by THP.\n\t\t\t\t */\n\t\t\t\tpagevec_add(&pvec, page);\n\t\t\t\tzone = page_zone(page);\n\n\t\t\t\t/*\n\t\t\t\t * Try to fill the rest of pagevec using fast\n\t\t\t\t * pte walk. This will also update start to\n\t\t\t\t * the next page to process. Then munlock the\n\t\t\t\t * pagevec.\n\t\t\t\t */\n\t\t\t\tstart = __munlock_pagevec_fill(&pvec, vma,\n\t\t\t\t\t\tzone, start, end);\n\t\t\t\t__munlock_pagevec(&pvec, zone);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\t\tpage_increm = 1 + page_mask;\n\t\tstart += page_increm * PAGE_SIZE;\nnext:\n\t\tcond_resched();\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/rmap.h>",
      "#include <linux/export.h>",
      "#include <linux/sched.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/mm.h>",
      "#include <linux/mman.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__munlock_pagevec",
          "args": [
            "&pvec",
            "zone"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "__munlock_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
          "lines": "290-359",
          "snippet": "static void __munlock_pagevec(struct pagevec *pvec, struct zone *zone)\n{\n\tint i;\n\tint nr = pagevec_count(pvec);\n\tint delta_munlocked = -nr;\n\tstruct pagevec pvec_putback;\n\tint pgrescued = 0;\n\n\tpagevec_init(&pvec_putback);\n\n\t/* Phase 1: page isolation */\n\tspin_lock_irq(zone_lru_lock(zone));\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct page *page = pvec->pages[i];\n\n\t\tif (TestClearPageMlocked(page)) {\n\t\t\t/*\n\t\t\t * We already have pin from follow_page_mask()\n\t\t\t * so we can spare the get_page() here.\n\t\t\t */\n\t\t\tif (__munlock_isolate_lru_page(page, false))\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\t__munlock_isolation_failed(page);\n\t\t} else {\n\t\t\tdelta_munlocked++;\n\t\t}\n\n\t\t/*\n\t\t * We won't be munlocking this page in the next phase\n\t\t * but we still need to release the follow_page_mask()\n\t\t * pin. We cannot do it under lru_lock however. If it's\n\t\t * the last pin, __page_cache_release() would deadlock.\n\t\t */\n\t\tpagevec_add(&pvec_putback, pvec->pages[i]);\n\t\tpvec->pages[i] = NULL;\n\t}\n\t__mod_zone_page_state(zone, NR_MLOCK, delta_munlocked);\n\tspin_unlock_irq(zone_lru_lock(zone));\n\n\t/* Now we can release pins of pages that we are not munlocking */\n\tpagevec_release(&pvec_putback);\n\n\t/* Phase 2: page munlock */\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct page *page = pvec->pages[i];\n\n\t\tif (page) {\n\t\t\tlock_page(page);\n\t\t\tif (!__putback_lru_fast_prepare(page, &pvec_putback,\n\t\t\t\t\t&pgrescued)) {\n\t\t\t\t/*\n\t\t\t\t * Slow path. We don't want to lose the last\n\t\t\t\t * pin before unlock_page()\n\t\t\t\t */\n\t\t\t\tget_page(page); /* for putback_lru_page() */\n\t\t\t\t__munlock_isolated_page(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tput_page(page); /* from follow_page_mask() */\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Phase 3: page putback for pages that qualified for the fast path\n\t * This will also call put_page() to return pin from follow_page_mask()\n\t */\n\tif (pagevec_count(&pvec_putback))\n\t\t__putback_lru_fast(&pvec_putback, pgrescued);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/rmap.h>",
            "#include <linux/export.h>",
            "#include <linux/sched.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/mm.h>",
            "#include <linux/mman.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nstatic void __munlock_pagevec(struct pagevec *pvec, struct zone *zone)\n{\n\tint i;\n\tint nr = pagevec_count(pvec);\n\tint delta_munlocked = -nr;\n\tstruct pagevec pvec_putback;\n\tint pgrescued = 0;\n\n\tpagevec_init(&pvec_putback);\n\n\t/* Phase 1: page isolation */\n\tspin_lock_irq(zone_lru_lock(zone));\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct page *page = pvec->pages[i];\n\n\t\tif (TestClearPageMlocked(page)) {\n\t\t\t/*\n\t\t\t * We already have pin from follow_page_mask()\n\t\t\t * so we can spare the get_page() here.\n\t\t\t */\n\t\t\tif (__munlock_isolate_lru_page(page, false))\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\t__munlock_isolation_failed(page);\n\t\t} else {\n\t\t\tdelta_munlocked++;\n\t\t}\n\n\t\t/*\n\t\t * We won't be munlocking this page in the next phase\n\t\t * but we still need to release the follow_page_mask()\n\t\t * pin. We cannot do it under lru_lock however. If it's\n\t\t * the last pin, __page_cache_release() would deadlock.\n\t\t */\n\t\tpagevec_add(&pvec_putback, pvec->pages[i]);\n\t\tpvec->pages[i] = NULL;\n\t}\n\t__mod_zone_page_state(zone, NR_MLOCK, delta_munlocked);\n\tspin_unlock_irq(zone_lru_lock(zone));\n\n\t/* Now we can release pins of pages that we are not munlocking */\n\tpagevec_release(&pvec_putback);\n\n\t/* Phase 2: page munlock */\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct page *page = pvec->pages[i];\n\n\t\tif (page) {\n\t\t\tlock_page(page);\n\t\t\tif (!__putback_lru_fast_prepare(page, &pvec_putback,\n\t\t\t\t\t&pgrescued)) {\n\t\t\t\t/*\n\t\t\t\t * Slow path. We don't want to lose the last\n\t\t\t\t * pin before unlock_page()\n\t\t\t\t */\n\t\t\t\tget_page(page); /* for putback_lru_page() */\n\t\t\t\t__munlock_isolated_page(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tput_page(page); /* from follow_page_mask() */\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Phase 3: page putback for pages that qualified for the fast path\n\t * This will also call put_page() to return pin from follow_page_mask()\n\t */\n\tif (pagevec_count(&pvec_putback))\n\t\t__putback_lru_fast(&pvec_putback, pgrescued);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__munlock_pagevec_fill",
          "args": [
            "&pvec",
            "vma",
            "zone",
            "start",
            "end"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "__munlock_pagevec_fill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
          "lines": "374-425",
          "snippet": "static unsigned long __munlock_pagevec_fill(struct pagevec *pvec,\n\t\t\tstruct vm_area_struct *vma, struct zone *zone,\n\t\t\tunsigned long start, unsigned long end)\n{\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\n\t/*\n\t * Initialize pte walk starting at the already pinned page where we\n\t * are sure that there is a pte, as it was pinned under the same\n\t * mmap_sem write op.\n\t */\n\tpte = get_locked_pte(vma->vm_mm, start,\t&ptl);\n\t/* Make sure we do not cross the page table boundary */\n\tend = pgd_addr_end(start, end);\n\tend = p4d_addr_end(start, end);\n\tend = pud_addr_end(start, end);\n\tend = pmd_addr_end(start, end);\n\n\t/* The page next to the pinned page is the first we will try to get */\n\tstart += PAGE_SIZE;\n\twhile (start < end) {\n\t\tstruct page *page = NULL;\n\t\tpte++;\n\t\tif (pte_present(*pte))\n\t\t\tpage = vm_normal_page(vma, start, *pte);\n\t\t/*\n\t\t * Break if page could not be obtained or the page's node+zone does not\n\t\t * match\n\t\t */\n\t\tif (!page || page_zone(page) != zone)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Do not use pagevec for PTE-mapped THP,\n\t\t * munlock_vma_pages_range() will handle them.\n\t\t */\n\t\tif (PageTransCompound(page))\n\t\t\tbreak;\n\n\t\tget_page(page);\n\t\t/*\n\t\t * Increase the address that will be returned *before* the\n\t\t * eventual break due to pvec becoming full by adding the page\n\t\t */\n\t\tstart += PAGE_SIZE;\n\t\tif (pagevec_add(pvec, page) == 0)\n\t\t\tbreak;\n\t}\n\tpte_unmap_unlock(pte, ptl);\n\treturn start;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/rmap.h>",
            "#include <linux/export.h>",
            "#include <linux/sched.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/mm.h>",
            "#include <linux/mman.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nstatic unsigned long __munlock_pagevec_fill(struct pagevec *pvec,\n\t\t\tstruct vm_area_struct *vma, struct zone *zone,\n\t\t\tunsigned long start, unsigned long end)\n{\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\n\t/*\n\t * Initialize pte walk starting at the already pinned page where we\n\t * are sure that there is a pte, as it was pinned under the same\n\t * mmap_sem write op.\n\t */\n\tpte = get_locked_pte(vma->vm_mm, start,\t&ptl);\n\t/* Make sure we do not cross the page table boundary */\n\tend = pgd_addr_end(start, end);\n\tend = p4d_addr_end(start, end);\n\tend = pud_addr_end(start, end);\n\tend = pmd_addr_end(start, end);\n\n\t/* The page next to the pinned page is the first we will try to get */\n\tstart += PAGE_SIZE;\n\twhile (start < end) {\n\t\tstruct page *page = NULL;\n\t\tpte++;\n\t\tif (pte_present(*pte))\n\t\t\tpage = vm_normal_page(vma, start, *pte);\n\t\t/*\n\t\t * Break if page could not be obtained or the page's node+zone does not\n\t\t * match\n\t\t */\n\t\tif (!page || page_zone(page) != zone)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Do not use pagevec for PTE-mapped THP,\n\t\t * munlock_vma_pages_range() will handle them.\n\t\t */\n\t\tif (PageTransCompound(page))\n\t\t\tbreak;\n\n\t\tget_page(page);\n\t\t/*\n\t\t * Increase the address that will be returned *before* the\n\t\t * eventual break due to pvec becoming full by adding the page\n\t\t */\n\t\tstart += PAGE_SIZE;\n\t\tif (pagevec_add(pvec, page) == 0)\n\t\t\tbreak;\n\t}\n\tpte_unmap_unlock(pte, ptl);\n\treturn start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_add",
          "args": [
            "&pvec",
            "page"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "munlock_vma_page",
          "args": [
            "page"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "munlock_vma_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
          "lines": "182-220",
          "snippet": "unsigned int munlock_vma_page(struct page *page)\n{\n\tint nr_pages;\n\tstruct zone *zone = page_zone(page);\n\n\t/* For try_to_munlock() and to serialize with page migration */\n\tBUG_ON(!PageLocked(page));\n\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\n\t/*\n\t * Serialize with any parallel __split_huge_page_refcount() which\n\t * might otherwise copy PageMlocked to part of the tail pages before\n\t * we clear it in the head page. It also stabilizes hpage_nr_pages().\n\t */\n\tspin_lock_irq(zone_lru_lock(zone));\n\n\tif (!TestClearPageMlocked(page)) {\n\t\t/* Potentially, PTE-mapped THP: do not skip the rest PTEs */\n\t\tnr_pages = 1;\n\t\tgoto unlock_out;\n\t}\n\n\tnr_pages = hpage_nr_pages(page);\n\t__mod_zone_page_state(zone, NR_MLOCK, -nr_pages);\n\n\tif (__munlock_isolate_lru_page(page, true)) {\n\t\tspin_unlock_irq(zone_lru_lock(zone));\n\t\t__munlock_isolated_page(page);\n\t\tgoto out;\n\t}\n\t__munlock_isolation_failed(page);\n\nunlock_out:\n\tspin_unlock_irq(zone_lru_lock(zone));\n\nout:\n\treturn nr_pages - 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/rmap.h>",
            "#include <linux/export.h>",
            "#include <linux/sched.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/mm.h>",
            "#include <linux/mman.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nunsigned int munlock_vma_page(struct page *page)\n{\n\tint nr_pages;\n\tstruct zone *zone = page_zone(page);\n\n\t/* For try_to_munlock() and to serialize with page migration */\n\tBUG_ON(!PageLocked(page));\n\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\n\t/*\n\t * Serialize with any parallel __split_huge_page_refcount() which\n\t * might otherwise copy PageMlocked to part of the tail pages before\n\t * we clear it in the head page. It also stabilizes hpage_nr_pages().\n\t */\n\tspin_lock_irq(zone_lru_lock(zone));\n\n\tif (!TestClearPageMlocked(page)) {\n\t\t/* Potentially, PTE-mapped THP: do not skip the rest PTEs */\n\t\tnr_pages = 1;\n\t\tgoto unlock_out;\n\t}\n\n\tnr_pages = hpage_nr_pages(page);\n\t__mod_zone_page_state(zone, NR_MLOCK, -nr_pages);\n\n\tif (__munlock_isolate_lru_page(page, true)) {\n\t\tspin_unlock_irq(zone_lru_lock(zone));\n\t\t__munlock_isolated_page(page);\n\t\tgoto out;\n\t}\n\t__munlock_isolation_failed(page);\n\nunlock_out:\n\tspin_unlock_irq(zone_lru_lock(zone));\n\nout:\n\treturn nr_pages - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageTransHuge",
          "args": [
            "page"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageMlocked(page)",
            "page"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageMlocked",
          "args": [
            "page"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransTail",
          "args": [
            "page"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "follow_page",
          "args": [
            "vma",
            "start",
            "FOLL_GET | FOLL_DUMP"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "follow_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "1712-1716",
          "snippet": "struct page *follow_page(struct vm_area_struct *vma, unsigned long address,\n\t\t\t unsigned int foll_flags)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nstruct page *follow_page(struct vm_area_struct *vma, unsigned long address,\n\t\t\t unsigned int foll_flags)\n{\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagevec_init",
          "args": [
            "&pvec"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nvoid munlock_vma_pages_range(struct vm_area_struct *vma,\n\t\t\t     unsigned long start, unsigned long end)\n{\n\tvma->vm_flags &= VM_LOCKED_CLEAR_MASK;\n\n\twhile (start < end) {\n\t\tstruct page *page;\n\t\tunsigned int page_mask = 0;\n\t\tunsigned long page_increm;\n\t\tstruct pagevec pvec;\n\t\tstruct zone *zone;\n\n\t\tpagevec_init(&pvec);\n\t\t/*\n\t\t * Although FOLL_DUMP is intended for get_dump_page(),\n\t\t * it just so happens that its special treatment of the\n\t\t * ZERO_PAGE (returning an error instead of doing get_page)\n\t\t * suits munlock very well (and if somehow an abnormal page\n\t\t * has sneaked into the range, we won't oops here: great).\n\t\t */\n\t\tpage = follow_page(vma, start, FOLL_GET | FOLL_DUMP);\n\n\t\tif (page && !IS_ERR(page)) {\n\t\t\tif (PageTransTail(page)) {\n\t\t\t\tVM_BUG_ON_PAGE(PageMlocked(page), page);\n\t\t\t\tput_page(page); /* follow_page_mask() */\n\t\t\t} else if (PageTransHuge(page)) {\n\t\t\t\tlock_page(page);\n\t\t\t\t/*\n\t\t\t\t * Any THP page found by follow_page_mask() may\n\t\t\t\t * have gotten split before reaching\n\t\t\t\t * munlock_vma_page(), so we need to compute\n\t\t\t\t * the page_mask here instead.\n\t\t\t\t */\n\t\t\t\tpage_mask = munlock_vma_page(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tput_page(page); /* follow_page_mask() */\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Non-huge pages are handled in batches via\n\t\t\t\t * pagevec. The pin from follow_page_mask()\n\t\t\t\t * prevents them from collapsing by THP.\n\t\t\t\t */\n\t\t\t\tpagevec_add(&pvec, page);\n\t\t\t\tzone = page_zone(page);\n\n\t\t\t\t/*\n\t\t\t\t * Try to fill the rest of pagevec using fast\n\t\t\t\t * pte walk. This will also update start to\n\t\t\t\t * the next page to process. Then munlock the\n\t\t\t\t * pagevec.\n\t\t\t\t */\n\t\t\t\tstart = __munlock_pagevec_fill(&pvec, vma,\n\t\t\t\t\t\tzone, start, end);\n\t\t\t\t__munlock_pagevec(&pvec, zone);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\t\tpage_increm = 1 + page_mask;\n\t\tstart += page_increm * PAGE_SIZE;\nnext:\n\t\tcond_resched();\n\t}\n}"
  },
  {
    "function_name": "__munlock_pagevec_fill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
    "lines": "374-425",
    "snippet": "static unsigned long __munlock_pagevec_fill(struct pagevec *pvec,\n\t\t\tstruct vm_area_struct *vma, struct zone *zone,\n\t\t\tunsigned long start, unsigned long end)\n{\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\n\t/*\n\t * Initialize pte walk starting at the already pinned page where we\n\t * are sure that there is a pte, as it was pinned under the same\n\t * mmap_sem write op.\n\t */\n\tpte = get_locked_pte(vma->vm_mm, start,\t&ptl);\n\t/* Make sure we do not cross the page table boundary */\n\tend = pgd_addr_end(start, end);\n\tend = p4d_addr_end(start, end);\n\tend = pud_addr_end(start, end);\n\tend = pmd_addr_end(start, end);\n\n\t/* The page next to the pinned page is the first we will try to get */\n\tstart += PAGE_SIZE;\n\twhile (start < end) {\n\t\tstruct page *page = NULL;\n\t\tpte++;\n\t\tif (pte_present(*pte))\n\t\t\tpage = vm_normal_page(vma, start, *pte);\n\t\t/*\n\t\t * Break if page could not be obtained or the page's node+zone does not\n\t\t * match\n\t\t */\n\t\tif (!page || page_zone(page) != zone)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Do not use pagevec for PTE-mapped THP,\n\t\t * munlock_vma_pages_range() will handle them.\n\t\t */\n\t\tif (PageTransCompound(page))\n\t\t\tbreak;\n\n\t\tget_page(page);\n\t\t/*\n\t\t * Increase the address that will be returned *before* the\n\t\t * eventual break due to pvec becoming full by adding the page\n\t\t */\n\t\tstart += PAGE_SIZE;\n\t\tif (pagevec_add(pvec, page) == 0)\n\t\t\tbreak;\n\t}\n\tpte_unmap_unlock(pte, ptl);\n\treturn start;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/rmap.h>",
      "#include <linux/export.h>",
      "#include <linux/sched.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/mm.h>",
      "#include <linux/mman.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "pte",
            "ptl"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_add",
          "args": [
            "pvec",
            "page"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "page"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageTransCompound",
          "args": [
            "page"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_normal_page",
          "args": [
            "vma",
            "start",
            "*pte"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "vm_normal_page_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "651-689",
          "snippet": "struct page *vm_normal_page_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tpmd_t pmd)\n{\n\tunsigned long pfn = pmd_pfn(pmd);\n\n\t/*\n\t * There is no pmd_special() but there may be special pmds, e.g.\n\t * in a direct-access (dax) mapping, so let's just replicate the\n\t * !CONFIG_ARCH_HAS_PTE_SPECIAL case from vm_normal_page() here.\n\t */\n\tif (unlikely(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP))) {\n\t\tif (vma->vm_flags & VM_MIXEDMAP) {\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\treturn NULL;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tunsigned long off;\n\t\t\toff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\t\tif (pfn == vma->vm_pgoff + off)\n\t\t\t\treturn NULL;\n\t\t\tif (!is_cow_mapping(vma->vm_flags))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (pmd_devmap(pmd))\n\t\treturn NULL;\n\tif (is_zero_pfn(pfn))\n\t\treturn NULL;\n\tif (unlikely(pfn > highest_memmap_pfn))\n\t\treturn NULL;\n\n\t/*\n\t * NOTE! We still have PageReserved() pages in the page tables.\n\t * eg. VDSO mappings can cause them to exist.\n\t */\nout:\n\treturn pfn_to_page(pfn);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstruct page *vm_normal_page_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tpmd_t pmd)\n{\n\tunsigned long pfn = pmd_pfn(pmd);\n\n\t/*\n\t * There is no pmd_special() but there may be special pmds, e.g.\n\t * in a direct-access (dax) mapping, so let's just replicate the\n\t * !CONFIG_ARCH_HAS_PTE_SPECIAL case from vm_normal_page() here.\n\t */\n\tif (unlikely(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP))) {\n\t\tif (vma->vm_flags & VM_MIXEDMAP) {\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\treturn NULL;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tunsigned long off;\n\t\t\toff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\t\tif (pfn == vma->vm_pgoff + off)\n\t\t\t\treturn NULL;\n\t\t\tif (!is_cow_mapping(vma->vm_flags))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (pmd_devmap(pmd))\n\t\treturn NULL;\n\tif (is_zero_pfn(pfn))\n\t\treturn NULL;\n\tif (unlikely(pfn > highest_memmap_pfn))\n\t\treturn NULL;\n\n\t/*\n\t * NOTE! We still have PageReserved() pages in the page tables.\n\t * eg. VDSO mappings can cause them to exist.\n\t */\nout:\n\treturn pfn_to_page(pfn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "*pte"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_addr_end",
          "args": [
            "start",
            "end"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_addr_end",
          "args": [
            "start",
            "end"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_addr_end",
          "args": [
            "start",
            "end"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_addr_end",
          "args": [
            "start",
            "end"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_locked_pte",
          "args": [
            "vma->vm_mm",
            "start",
            "&ptl"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "__get_locked_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "1415-1436",
          "snippet": "pte_t *__get_locked_pte(struct mm_struct *mm, unsigned long addr,\n\t\t\tspinlock_t **ptl)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(mm, addr);\n\tp4d = p4d_alloc(mm, pgd, addr);\n\tif (!p4d)\n\t\treturn NULL;\n\tpud = pud_alloc(mm, p4d, addr);\n\tif (!pud)\n\t\treturn NULL;\n\tpmd = pmd_alloc(mm, pud, addr);\n\tif (!pmd)\n\t\treturn NULL;\n\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\treturn pte_alloc_map_lock(mm, pmd, addr, ptl);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\npte_t *__get_locked_pte(struct mm_struct *mm, unsigned long addr,\n\t\t\tspinlock_t **ptl)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(mm, addr);\n\tp4d = p4d_alloc(mm, pgd, addr);\n\tif (!p4d)\n\t\treturn NULL;\n\tpud = pud_alloc(mm, p4d, addr);\n\tif (!pud)\n\t\treturn NULL;\n\tpmd = pmd_alloc(mm, pud, addr);\n\tif (!pmd)\n\t\treturn NULL;\n\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\treturn pte_alloc_map_lock(mm, pmd, addr, ptl);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nstatic unsigned long __munlock_pagevec_fill(struct pagevec *pvec,\n\t\t\tstruct vm_area_struct *vma, struct zone *zone,\n\t\t\tunsigned long start, unsigned long end)\n{\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\n\t/*\n\t * Initialize pte walk starting at the already pinned page where we\n\t * are sure that there is a pte, as it was pinned under the same\n\t * mmap_sem write op.\n\t */\n\tpte = get_locked_pte(vma->vm_mm, start,\t&ptl);\n\t/* Make sure we do not cross the page table boundary */\n\tend = pgd_addr_end(start, end);\n\tend = p4d_addr_end(start, end);\n\tend = pud_addr_end(start, end);\n\tend = pmd_addr_end(start, end);\n\n\t/* The page next to the pinned page is the first we will try to get */\n\tstart += PAGE_SIZE;\n\twhile (start < end) {\n\t\tstruct page *page = NULL;\n\t\tpte++;\n\t\tif (pte_present(*pte))\n\t\t\tpage = vm_normal_page(vma, start, *pte);\n\t\t/*\n\t\t * Break if page could not be obtained or the page's node+zone does not\n\t\t * match\n\t\t */\n\t\tif (!page || page_zone(page) != zone)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Do not use pagevec for PTE-mapped THP,\n\t\t * munlock_vma_pages_range() will handle them.\n\t\t */\n\t\tif (PageTransCompound(page))\n\t\t\tbreak;\n\n\t\tget_page(page);\n\t\t/*\n\t\t * Increase the address that will be returned *before* the\n\t\t * eventual break due to pvec becoming full by adding the page\n\t\t */\n\t\tstart += PAGE_SIZE;\n\t\tif (pagevec_add(pvec, page) == 0)\n\t\t\tbreak;\n\t}\n\tpte_unmap_unlock(pte, ptl);\n\treturn start;\n}"
  },
  {
    "function_name": "__munlock_pagevec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
    "lines": "290-359",
    "snippet": "static void __munlock_pagevec(struct pagevec *pvec, struct zone *zone)\n{\n\tint i;\n\tint nr = pagevec_count(pvec);\n\tint delta_munlocked = -nr;\n\tstruct pagevec pvec_putback;\n\tint pgrescued = 0;\n\n\tpagevec_init(&pvec_putback);\n\n\t/* Phase 1: page isolation */\n\tspin_lock_irq(zone_lru_lock(zone));\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct page *page = pvec->pages[i];\n\n\t\tif (TestClearPageMlocked(page)) {\n\t\t\t/*\n\t\t\t * We already have pin from follow_page_mask()\n\t\t\t * so we can spare the get_page() here.\n\t\t\t */\n\t\t\tif (__munlock_isolate_lru_page(page, false))\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\t__munlock_isolation_failed(page);\n\t\t} else {\n\t\t\tdelta_munlocked++;\n\t\t}\n\n\t\t/*\n\t\t * We won't be munlocking this page in the next phase\n\t\t * but we still need to release the follow_page_mask()\n\t\t * pin. We cannot do it under lru_lock however. If it's\n\t\t * the last pin, __page_cache_release() would deadlock.\n\t\t */\n\t\tpagevec_add(&pvec_putback, pvec->pages[i]);\n\t\tpvec->pages[i] = NULL;\n\t}\n\t__mod_zone_page_state(zone, NR_MLOCK, delta_munlocked);\n\tspin_unlock_irq(zone_lru_lock(zone));\n\n\t/* Now we can release pins of pages that we are not munlocking */\n\tpagevec_release(&pvec_putback);\n\n\t/* Phase 2: page munlock */\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct page *page = pvec->pages[i];\n\n\t\tif (page) {\n\t\t\tlock_page(page);\n\t\t\tif (!__putback_lru_fast_prepare(page, &pvec_putback,\n\t\t\t\t\t&pgrescued)) {\n\t\t\t\t/*\n\t\t\t\t * Slow path. We don't want to lose the last\n\t\t\t\t * pin before unlock_page()\n\t\t\t\t */\n\t\t\t\tget_page(page); /* for putback_lru_page() */\n\t\t\t\t__munlock_isolated_page(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tput_page(page); /* from follow_page_mask() */\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Phase 3: page putback for pages that qualified for the fast path\n\t * This will also call put_page() to return pin from follow_page_mask()\n\t */\n\tif (pagevec_count(&pvec_putback))\n\t\t__putback_lru_fast(&pvec_putback, pgrescued);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/rmap.h>",
      "#include <linux/export.h>",
      "#include <linux/sched.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/mm.h>",
      "#include <linux/mman.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__putback_lru_fast",
          "args": [
            "&pvec_putback",
            "pgrescued"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "__putback_lru_fast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
          "lines": "269-278",
          "snippet": "static void __putback_lru_fast(struct pagevec *pvec, int pgrescued)\n{\n\tcount_vm_events(UNEVICTABLE_PGMUNLOCKED, pagevec_count(pvec));\n\t/*\n\t *__pagevec_lru_add() calls release_pages() so we don't call\n\t * put_page() explicitly\n\t */\n\t__pagevec_lru_add(pvec);\n\tcount_vm_events(UNEVICTABLE_PGRESCUED, pgrescued);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/rmap.h>",
            "#include <linux/export.h>",
            "#include <linux/sched.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/mm.h>",
            "#include <linux/mman.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nstatic void __putback_lru_fast(struct pagevec *pvec, int pgrescued)\n{\n\tcount_vm_events(UNEVICTABLE_PGMUNLOCKED, pagevec_count(pvec));\n\t/*\n\t *__pagevec_lru_add() calls release_pages() so we don't call\n\t * put_page() explicitly\n\t */\n\t__pagevec_lru_add(pvec);\n\tcount_vm_events(UNEVICTABLE_PGRESCUED, pgrescued);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "&pvec_putback"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__munlock_isolated_page",
          "args": [
            "page"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "__munlock_isolated_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
          "lines": "131-145",
          "snippet": "static void __munlock_isolated_page(struct page *page)\n{\n\t/*\n\t * Optimization: if the page was mapped just once, that's our mapping\n\t * and we don't need to check all the other vmas.\n\t */\n\tif (page_mapcount(page) > 1)\n\t\ttry_to_munlock(page);\n\n\t/* Did try_to_unlock() succeed or punt? */\n\tif (!PageMlocked(page))\n\t\tcount_vm_event(UNEVICTABLE_PGMUNLOCKED);\n\n\tputback_lru_page(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/rmap.h>",
            "#include <linux/export.h>",
            "#include <linux/sched.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/mm.h>",
            "#include <linux/mman.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nstatic void __munlock_isolated_page(struct page *page)\n{\n\t/*\n\t * Optimization: if the page was mapped just once, that's our mapping\n\t * and we don't need to check all the other vmas.\n\t */\n\tif (page_mapcount(page) > 1)\n\t\ttry_to_munlock(page);\n\n\t/* Did try_to_unlock() succeed or punt? */\n\tif (!PageMlocked(page))\n\t\tcount_vm_event(UNEVICTABLE_PGMUNLOCKED);\n\n\tputback_lru_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "page"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__putback_lru_fast_prepare",
          "args": [
            "page",
            "&pvec_putback",
            "&pgrescued"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "__putback_lru_fast_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
          "lines": "246-261",
          "snippet": "static bool __putback_lru_fast_prepare(struct page *page, struct pagevec *pvec,\n\t\tint *pgrescued)\n{\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tif (page_mapcount(page) <= 1 && page_evictable(page)) {\n\t\tpagevec_add(pvec, page);\n\t\tif (TestClearPageUnevictable(page))\n\t\t\t(*pgrescued)++;\n\t\tunlock_page(page);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/rmap.h>",
            "#include <linux/export.h>",
            "#include <linux/sched.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/mm.h>",
            "#include <linux/mman.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nstatic bool __putback_lru_fast_prepare(struct page *page, struct pagevec *pvec,\n\t\tint *pgrescued)\n{\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tif (page_mapcount(page) <= 1 && page_evictable(page)) {\n\t\tpagevec_add(pvec, page);\n\t\tif (TestClearPageUnevictable(page))\n\t\t\t(*pgrescued)++;\n\t\tunlock_page(page);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagevec_release",
          "args": [
            "&pvec_putback"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "__pagevec_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "805-813",
          "snippet": "void __pagevec_release(struct pagevec *pvec)\n{\n\tif (!pvec->percpu_pvec_drained) {\n\t\tlru_add_drain();\n\t\tpvec->percpu_pvec_drained = true;\n\t}\n\trelease_pages(pvec->pages, pagevec_count(pvec));\n\tpagevec_reinit(pvec);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid __pagevec_release(struct pagevec *pvec)\n{\n\tif (!pvec->percpu_pvec_drained) {\n\t\tlru_add_drain();\n\t\tpvec->percpu_pvec_drained = true;\n\t}\n\trelease_pages(pvec->pages, pagevec_count(pvec));\n\tpagevec_reinit(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "zone_lru_lock(zone)"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_lru_lock",
          "args": [
            "zone"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mod_zone_page_state",
          "args": [
            "zone",
            "NR_MLOCK",
            "delta_munlocked"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "__mod_zone_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "315-332",
          "snippet": "void __mod_zone_page_state(struct zone *zone, enum zone_stat_item item,\n\t\t\t   long delta)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\ts8 __percpu *p = pcp->vm_stat_diff + item;\n\tlong x;\n\tlong t;\n\n\tx = delta + __this_cpu_read(*p);\n\n\tt = __this_cpu_read(pcp->stat_threshold);\n\n\tif (unlikely(x > t || x < -t)) {\n\t\tzone_page_state_add(x, zone, item);\n\t\tx = 0;\n\t}\n\t__this_cpu_write(*p, x);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __mod_zone_page_state(struct zone *zone, enum zone_stat_item item,\n\t\t\t   long delta)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\ts8 __percpu *p = pcp->vm_stat_diff + item;\n\tlong x;\n\tlong t;\n\n\tx = delta + __this_cpu_read(*p);\n\n\tt = __this_cpu_read(pcp->stat_threshold);\n\n\tif (unlikely(x > t || x < -t)) {\n\t\tzone_page_state_add(x, zone, item);\n\t\tx = 0;\n\t}\n\t__this_cpu_write(*p, x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagevec_add",
          "args": [
            "&pvec_putback",
            "pvec->pages[i]"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__munlock_isolation_failed",
          "args": [
            "page"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "__munlock_isolation_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
          "lines": "156-162",
          "snippet": "static void __munlock_isolation_failed(struct page *page)\n{\n\tif (PageUnevictable(page))\n\t\t__count_vm_event(UNEVICTABLE_PGSTRANDED);\n\telse\n\t\t__count_vm_event(UNEVICTABLE_PGMUNLOCKED);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/rmap.h>",
            "#include <linux/export.h>",
            "#include <linux/sched.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/mm.h>",
            "#include <linux/mman.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nstatic void __munlock_isolation_failed(struct page *page)\n{\n\tif (PageUnevictable(page))\n\t\t__count_vm_event(UNEVICTABLE_PGSTRANDED);\n\telse\n\t\t__count_vm_event(UNEVICTABLE_PGMUNLOCKED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__munlock_isolate_lru_page",
          "args": [
            "page",
            "false"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "__munlock_isolate_lru_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
          "lines": "109-123",
          "snippet": "static bool __munlock_isolate_lru_page(struct page *page, bool getpage)\n{\n\tif (PageLRU(page)) {\n\t\tstruct lruvec *lruvec;\n\n\t\tlruvec = mem_cgroup_page_lruvec(page, page_pgdat(page));\n\t\tif (getpage)\n\t\t\tget_page(page);\n\t\tClearPageLRU(page);\n\t\tdel_page_from_lru_list(page, lruvec, page_lru(page));\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/rmap.h>",
            "#include <linux/export.h>",
            "#include <linux/sched.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/mm.h>",
            "#include <linux/mman.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nstatic bool __munlock_isolate_lru_page(struct page *page, bool getpage)\n{\n\tif (PageLRU(page)) {\n\t\tstruct lruvec *lruvec;\n\n\t\tlruvec = mem_cgroup_page_lruvec(page, page_pgdat(page));\n\t\tif (getpage)\n\t\t\tget_page(page);\n\t\tClearPageLRU(page);\n\t\tdel_page_from_lru_list(page, lruvec, page_lru(page));\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TestClearPageMlocked",
          "args": [
            "page"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "zone_lru_lock(zone)"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_lru_lock",
          "args": [
            "zone"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_init",
          "args": [
            "&pvec_putback"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "pvec"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nstatic void __munlock_pagevec(struct pagevec *pvec, struct zone *zone)\n{\n\tint i;\n\tint nr = pagevec_count(pvec);\n\tint delta_munlocked = -nr;\n\tstruct pagevec pvec_putback;\n\tint pgrescued = 0;\n\n\tpagevec_init(&pvec_putback);\n\n\t/* Phase 1: page isolation */\n\tspin_lock_irq(zone_lru_lock(zone));\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct page *page = pvec->pages[i];\n\n\t\tif (TestClearPageMlocked(page)) {\n\t\t\t/*\n\t\t\t * We already have pin from follow_page_mask()\n\t\t\t * so we can spare the get_page() here.\n\t\t\t */\n\t\t\tif (__munlock_isolate_lru_page(page, false))\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\t__munlock_isolation_failed(page);\n\t\t} else {\n\t\t\tdelta_munlocked++;\n\t\t}\n\n\t\t/*\n\t\t * We won't be munlocking this page in the next phase\n\t\t * but we still need to release the follow_page_mask()\n\t\t * pin. We cannot do it under lru_lock however. If it's\n\t\t * the last pin, __page_cache_release() would deadlock.\n\t\t */\n\t\tpagevec_add(&pvec_putback, pvec->pages[i]);\n\t\tpvec->pages[i] = NULL;\n\t}\n\t__mod_zone_page_state(zone, NR_MLOCK, delta_munlocked);\n\tspin_unlock_irq(zone_lru_lock(zone));\n\n\t/* Now we can release pins of pages that we are not munlocking */\n\tpagevec_release(&pvec_putback);\n\n\t/* Phase 2: page munlock */\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct page *page = pvec->pages[i];\n\n\t\tif (page) {\n\t\t\tlock_page(page);\n\t\t\tif (!__putback_lru_fast_prepare(page, &pvec_putback,\n\t\t\t\t\t&pgrescued)) {\n\t\t\t\t/*\n\t\t\t\t * Slow path. We don't want to lose the last\n\t\t\t\t * pin before unlock_page()\n\t\t\t\t */\n\t\t\t\tget_page(page); /* for putback_lru_page() */\n\t\t\t\t__munlock_isolated_page(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tput_page(page); /* from follow_page_mask() */\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Phase 3: page putback for pages that qualified for the fast path\n\t * This will also call put_page() to return pin from follow_page_mask()\n\t */\n\tif (pagevec_count(&pvec_putback))\n\t\t__putback_lru_fast(&pvec_putback, pgrescued);\n}"
  },
  {
    "function_name": "__putback_lru_fast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
    "lines": "269-278",
    "snippet": "static void __putback_lru_fast(struct pagevec *pvec, int pgrescued)\n{\n\tcount_vm_events(UNEVICTABLE_PGMUNLOCKED, pagevec_count(pvec));\n\t/*\n\t *__pagevec_lru_add() calls release_pages() so we don't call\n\t * put_page() explicitly\n\t */\n\t__pagevec_lru_add(pvec);\n\tcount_vm_events(UNEVICTABLE_PGRESCUED, pgrescued);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/rmap.h>",
      "#include <linux/export.h>",
      "#include <linux/sched.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/mm.h>",
      "#include <linux/mman.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "count_vm_events",
          "args": [
            "UNEVICTABLE_PGRESCUED",
            "pgrescued"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pagevec_lru_add",
          "args": [
            "pvec"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "__pagevec_lru_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "916-919",
          "snippet": "void __pagevec_lru_add(struct pagevec *pvec)\n{\n\tpagevec_lru_move_fn(pvec, __pagevec_lru_add_fn, NULL);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid __pagevec_lru_add(struct pagevec *pvec)\n{\n\tpagevec_lru_move_fn(pvec, __pagevec_lru_add_fn, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "count_vm_events",
          "args": [
            "UNEVICTABLE_PGMUNLOCKED",
            "pagevec_count(pvec)"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "pvec"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nstatic void __putback_lru_fast(struct pagevec *pvec, int pgrescued)\n{\n\tcount_vm_events(UNEVICTABLE_PGMUNLOCKED, pagevec_count(pvec));\n\t/*\n\t *__pagevec_lru_add() calls release_pages() so we don't call\n\t * put_page() explicitly\n\t */\n\t__pagevec_lru_add(pvec);\n\tcount_vm_events(UNEVICTABLE_PGRESCUED, pgrescued);\n}"
  },
  {
    "function_name": "__putback_lru_fast_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
    "lines": "246-261",
    "snippet": "static bool __putback_lru_fast_prepare(struct page *page, struct pagevec *pvec,\n\t\tint *pgrescued)\n{\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tif (page_mapcount(page) <= 1 && page_evictable(page)) {\n\t\tpagevec_add(pvec, page);\n\t\tif (TestClearPageUnevictable(page))\n\t\t\t(*pgrescued)++;\n\t\tunlock_page(page);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/rmap.h>",
      "#include <linux/export.h>",
      "#include <linux/sched.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/mm.h>",
      "#include <linux/mman.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TestClearPageUnevictable",
          "args": [
            "page"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_add",
          "args": [
            "pvec",
            "page"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_evictable",
          "args": [
            "page"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "page_evictable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "4174-4183",
          "snippet": "int page_evictable(struct page *page)\n{\n\tint ret;\n\n\t/* Prevent address_space of inode and swap cache from being freed */\n\trcu_read_lock();\n\tret = !mapping_unevictable(page_mapping(page)) && !PageMlocked(page);\n\trcu_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint page_evictable(struct page *page)\n{\n\tint ret;\n\n\t/* Prevent address_space of inode and swap cache from being freed */\n\trcu_read_lock();\n\tret = !mapping_unevictable(page_mapping(page)) && !PageMlocked(page);\n\trcu_read_unlock();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_mapcount",
          "args": [
            "page"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLocked(page)",
            "page"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageLRU(page)",
            "page"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nstatic bool __putback_lru_fast_prepare(struct page *page, struct pagevec *pvec,\n\t\tint *pgrescued)\n{\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tif (page_mapcount(page) <= 1 && page_evictable(page)) {\n\t\tpagevec_add(pvec, page);\n\t\tif (TestClearPageUnevictable(page))\n\t\t\t(*pgrescued)++;\n\t\tunlock_page(page);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "__mlock_posix_error_return",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
    "lines": "225-232",
    "snippet": "static int __mlock_posix_error_return(long retval)\n{\n\tif (retval == -EFAULT)\n\t\tretval = -ENOMEM;\n\telse if (retval == -ENOMEM)\n\t\tretval = -EAGAIN;\n\treturn retval;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/rmap.h>",
      "#include <linux/export.h>",
      "#include <linux/sched.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/mm.h>",
      "#include <linux/mman.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nstatic int __mlock_posix_error_return(long retval)\n{\n\tif (retval == -EFAULT)\n\t\tretval = -ENOMEM;\n\telse if (retval == -ENOMEM)\n\t\tretval = -EAGAIN;\n\treturn retval;\n}"
  },
  {
    "function_name": "munlock_vma_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
    "lines": "182-220",
    "snippet": "unsigned int munlock_vma_page(struct page *page)\n{\n\tint nr_pages;\n\tstruct zone *zone = page_zone(page);\n\n\t/* For try_to_munlock() and to serialize with page migration */\n\tBUG_ON(!PageLocked(page));\n\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\n\t/*\n\t * Serialize with any parallel __split_huge_page_refcount() which\n\t * might otherwise copy PageMlocked to part of the tail pages before\n\t * we clear it in the head page. It also stabilizes hpage_nr_pages().\n\t */\n\tspin_lock_irq(zone_lru_lock(zone));\n\n\tif (!TestClearPageMlocked(page)) {\n\t\t/* Potentially, PTE-mapped THP: do not skip the rest PTEs */\n\t\tnr_pages = 1;\n\t\tgoto unlock_out;\n\t}\n\n\tnr_pages = hpage_nr_pages(page);\n\t__mod_zone_page_state(zone, NR_MLOCK, -nr_pages);\n\n\tif (__munlock_isolate_lru_page(page, true)) {\n\t\tspin_unlock_irq(zone_lru_lock(zone));\n\t\t__munlock_isolated_page(page);\n\t\tgoto out;\n\t}\n\t__munlock_isolation_failed(page);\n\nunlock_out:\n\tspin_unlock_irq(zone_lru_lock(zone));\n\nout:\n\treturn nr_pages - 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/rmap.h>",
      "#include <linux/export.h>",
      "#include <linux/sched.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/mm.h>",
      "#include <linux/mman.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "zone_lru_lock(zone)"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_lru_lock",
          "args": [
            "zone"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__munlock_isolation_failed",
          "args": [
            "page"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "__munlock_isolation_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
          "lines": "156-162",
          "snippet": "static void __munlock_isolation_failed(struct page *page)\n{\n\tif (PageUnevictable(page))\n\t\t__count_vm_event(UNEVICTABLE_PGSTRANDED);\n\telse\n\t\t__count_vm_event(UNEVICTABLE_PGMUNLOCKED);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/rmap.h>",
            "#include <linux/export.h>",
            "#include <linux/sched.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/mm.h>",
            "#include <linux/mman.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nstatic void __munlock_isolation_failed(struct page *page)\n{\n\tif (PageUnevictable(page))\n\t\t__count_vm_event(UNEVICTABLE_PGSTRANDED);\n\telse\n\t\t__count_vm_event(UNEVICTABLE_PGMUNLOCKED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__munlock_isolated_page",
          "args": [
            "page"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "__munlock_isolated_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
          "lines": "131-145",
          "snippet": "static void __munlock_isolated_page(struct page *page)\n{\n\t/*\n\t * Optimization: if the page was mapped just once, that's our mapping\n\t * and we don't need to check all the other vmas.\n\t */\n\tif (page_mapcount(page) > 1)\n\t\ttry_to_munlock(page);\n\n\t/* Did try_to_unlock() succeed or punt? */\n\tif (!PageMlocked(page))\n\t\tcount_vm_event(UNEVICTABLE_PGMUNLOCKED);\n\n\tputback_lru_page(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/rmap.h>",
            "#include <linux/export.h>",
            "#include <linux/sched.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/mm.h>",
            "#include <linux/mman.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nstatic void __munlock_isolated_page(struct page *page)\n{\n\t/*\n\t * Optimization: if the page was mapped just once, that's our mapping\n\t * and we don't need to check all the other vmas.\n\t */\n\tif (page_mapcount(page) > 1)\n\t\ttry_to_munlock(page);\n\n\t/* Did try_to_unlock() succeed or punt? */\n\tif (!PageMlocked(page))\n\t\tcount_vm_event(UNEVICTABLE_PGMUNLOCKED);\n\n\tputback_lru_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "zone_lru_lock(zone)"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_lru_lock",
          "args": [
            "zone"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__munlock_isolate_lru_page",
          "args": [
            "page",
            "true"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "__munlock_isolate_lru_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
          "lines": "109-123",
          "snippet": "static bool __munlock_isolate_lru_page(struct page *page, bool getpage)\n{\n\tif (PageLRU(page)) {\n\t\tstruct lruvec *lruvec;\n\n\t\tlruvec = mem_cgroup_page_lruvec(page, page_pgdat(page));\n\t\tif (getpage)\n\t\t\tget_page(page);\n\t\tClearPageLRU(page);\n\t\tdel_page_from_lru_list(page, lruvec, page_lru(page));\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/rmap.h>",
            "#include <linux/export.h>",
            "#include <linux/sched.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/mm.h>",
            "#include <linux/mman.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nstatic bool __munlock_isolate_lru_page(struct page *page, bool getpage)\n{\n\tif (PageLRU(page)) {\n\t\tstruct lruvec *lruvec;\n\n\t\tlruvec = mem_cgroup_page_lruvec(page, page_pgdat(page));\n\t\tif (getpage)\n\t\t\tget_page(page);\n\t\tClearPageLRU(page);\n\t\tdel_page_from_lru_list(page, lruvec, page_lru(page));\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mod_zone_page_state",
          "args": [
            "zone",
            "NR_MLOCK",
            "-nr_pages"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "__mod_zone_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "315-332",
          "snippet": "void __mod_zone_page_state(struct zone *zone, enum zone_stat_item item,\n\t\t\t   long delta)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\ts8 __percpu *p = pcp->vm_stat_diff + item;\n\tlong x;\n\tlong t;\n\n\tx = delta + __this_cpu_read(*p);\n\n\tt = __this_cpu_read(pcp->stat_threshold);\n\n\tif (unlikely(x > t || x < -t)) {\n\t\tzone_page_state_add(x, zone, item);\n\t\tx = 0;\n\t}\n\t__this_cpu_write(*p, x);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __mod_zone_page_state(struct zone *zone, enum zone_stat_item item,\n\t\t\t   long delta)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\ts8 __percpu *p = pcp->vm_stat_diff + item;\n\tlong x;\n\tlong t;\n\n\tx = delta + __this_cpu_read(*p);\n\n\tt = __this_cpu_read(pcp->stat_threshold);\n\n\tif (unlikely(x > t || x < -t)) {\n\t\tzone_page_state_add(x, zone, item);\n\t\tx = 0;\n\t}\n\t__this_cpu_write(*p, x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "page"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestClearPageMlocked",
          "args": [
            "page"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "zone_lru_lock(zone)"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_lru_lock",
          "args": [
            "zone"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageTail(page)",
            "page"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTail",
          "args": [
            "page"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nunsigned int munlock_vma_page(struct page *page)\n{\n\tint nr_pages;\n\tstruct zone *zone = page_zone(page);\n\n\t/* For try_to_munlock() and to serialize with page migration */\n\tBUG_ON(!PageLocked(page));\n\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\n\t/*\n\t * Serialize with any parallel __split_huge_page_refcount() which\n\t * might otherwise copy PageMlocked to part of the tail pages before\n\t * we clear it in the head page. It also stabilizes hpage_nr_pages().\n\t */\n\tspin_lock_irq(zone_lru_lock(zone));\n\n\tif (!TestClearPageMlocked(page)) {\n\t\t/* Potentially, PTE-mapped THP: do not skip the rest PTEs */\n\t\tnr_pages = 1;\n\t\tgoto unlock_out;\n\t}\n\n\tnr_pages = hpage_nr_pages(page);\n\t__mod_zone_page_state(zone, NR_MLOCK, -nr_pages);\n\n\tif (__munlock_isolate_lru_page(page, true)) {\n\t\tspin_unlock_irq(zone_lru_lock(zone));\n\t\t__munlock_isolated_page(page);\n\t\tgoto out;\n\t}\n\t__munlock_isolation_failed(page);\n\nunlock_out:\n\tspin_unlock_irq(zone_lru_lock(zone));\n\nout:\n\treturn nr_pages - 1;\n}"
  },
  {
    "function_name": "__munlock_isolation_failed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
    "lines": "156-162",
    "snippet": "static void __munlock_isolation_failed(struct page *page)\n{\n\tif (PageUnevictable(page))\n\t\t__count_vm_event(UNEVICTABLE_PGSTRANDED);\n\telse\n\t\t__count_vm_event(UNEVICTABLE_PGMUNLOCKED);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/rmap.h>",
      "#include <linux/export.h>",
      "#include <linux/sched.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/mm.h>",
      "#include <linux/mman.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__count_vm_event",
          "args": [
            "UNEVICTABLE_PGMUNLOCKED"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__count_vm_event",
          "args": [
            "UNEVICTABLE_PGSTRANDED"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUnevictable",
          "args": [
            "page"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nstatic void __munlock_isolation_failed(struct page *page)\n{\n\tif (PageUnevictable(page))\n\t\t__count_vm_event(UNEVICTABLE_PGSTRANDED);\n\telse\n\t\t__count_vm_event(UNEVICTABLE_PGMUNLOCKED);\n}"
  },
  {
    "function_name": "__munlock_isolated_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
    "lines": "131-145",
    "snippet": "static void __munlock_isolated_page(struct page *page)\n{\n\t/*\n\t * Optimization: if the page was mapped just once, that's our mapping\n\t * and we don't need to check all the other vmas.\n\t */\n\tif (page_mapcount(page) > 1)\n\t\ttry_to_munlock(page);\n\n\t/* Did try_to_unlock() succeed or punt? */\n\tif (!PageMlocked(page))\n\t\tcount_vm_event(UNEVICTABLE_PGMUNLOCKED);\n\n\tputback_lru_page(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/rmap.h>",
      "#include <linux/export.h>",
      "#include <linux/sched.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/mm.h>",
      "#include <linux/mman.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "putback_lru_page",
          "args": [
            "page"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "putback_lru_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1005-1009",
          "snippet": "void putback_lru_page(struct page *page)\n{\n\tlru_cache_add(page);\n\tput_page(page);\t\t/* drop ref from isolate */\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid putback_lru_page(struct page *page)\n{\n\tlru_cache_add(page);\n\tput_page(page);\t\t/* drop ref from isolate */\n}"
        }
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "UNEVICTABLE_PGMUNLOCKED"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageMlocked",
          "args": [
            "page"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_munlock",
          "args": [
            "page"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_munlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1742-1756",
          "snippet": "void try_to_munlock(struct page *page)\n{\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = try_to_unmap_one,\n\t\t.arg = (void *)TTU_MUNLOCK,\n\t\t.done = page_not_mapped,\n\t\t.anon_lock = page_lock_anon_vma_read,\n\n\t};\n\n\tVM_BUG_ON_PAGE(!PageLocked(page) || PageLRU(page), page);\n\tVM_BUG_ON_PAGE(PageCompound(page) && PageDoubleMap(page), page);\n\n\trmap_walk(page, &rwc);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid try_to_munlock(struct page *page)\n{\n\tstruct rmap_walk_control rwc = {\n\t\t.rmap_one = try_to_unmap_one,\n\t\t.arg = (void *)TTU_MUNLOCK,\n\t\t.done = page_not_mapped,\n\t\t.anon_lock = page_lock_anon_vma_read,\n\n\t};\n\n\tVM_BUG_ON_PAGE(!PageLocked(page) || PageLRU(page), page);\n\tVM_BUG_ON_PAGE(PageCompound(page) && PageDoubleMap(page), page);\n\n\trmap_walk(page, &rwc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_mapcount",
          "args": [
            "page"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nstatic void __munlock_isolated_page(struct page *page)\n{\n\t/*\n\t * Optimization: if the page was mapped just once, that's our mapping\n\t * and we don't need to check all the other vmas.\n\t */\n\tif (page_mapcount(page) > 1)\n\t\ttry_to_munlock(page);\n\n\t/* Did try_to_unlock() succeed or punt? */\n\tif (!PageMlocked(page))\n\t\tcount_vm_event(UNEVICTABLE_PGMUNLOCKED);\n\n\tputback_lru_page(page);\n}"
  },
  {
    "function_name": "__munlock_isolate_lru_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
    "lines": "109-123",
    "snippet": "static bool __munlock_isolate_lru_page(struct page *page, bool getpage)\n{\n\tif (PageLRU(page)) {\n\t\tstruct lruvec *lruvec;\n\n\t\tlruvec = mem_cgroup_page_lruvec(page, page_pgdat(page));\n\t\tif (getpage)\n\t\t\tget_page(page);\n\t\tClearPageLRU(page);\n\t\tdel_page_from_lru_list(page, lruvec, page_lru(page));\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/rmap.h>",
      "#include <linux/export.h>",
      "#include <linux/sched.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/mm.h>",
      "#include <linux/mman.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "del_page_from_lru_list",
          "args": [
            "page",
            "lruvec",
            "page_lru(page)"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_lru",
          "args": [
            "page"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageLRU",
          "args": [
            "page"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "page"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_page_lruvec",
          "args": [
            "page",
            "page_pgdat(page)"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_page_lruvec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1100-1130",
          "snippet": "struct lruvec *mem_cgroup_page_lruvec(struct page *page, struct pglist_data *pgdat)\n{\n\tstruct mem_cgroup_per_node *mz;\n\tstruct mem_cgroup *memcg;\n\tstruct lruvec *lruvec;\n\n\tif (mem_cgroup_disabled()) {\n\t\tlruvec = &pgdat->lruvec;\n\t\tgoto out;\n\t}\n\n\tmemcg = page->mem_cgroup;\n\t/*\n\t * Swapcache readahead pages are added to the LRU - and\n\t * possibly migrated - before they are charged.\n\t */\n\tif (!memcg)\n\t\tmemcg = root_mem_cgroup;\n\n\tmz = mem_cgroup_page_nodeinfo(memcg, page);\n\tlruvec = &mz->lruvec;\nout:\n\t/*\n\t * Since a node can be onlined after the mem_cgroup was created,\n\t * we have to be prepared to initialize lruvec->zone here;\n\t * and if offlined then reonlined, we need to reinitialize it.\n\t */\n\tif (unlikely(lruvec->pgdat != pgdat))\n\t\tlruvec->pgdat = pgdat;\n\treturn lruvec;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstruct lruvec *mem_cgroup_page_lruvec(struct page *page, struct pglist_data *pgdat)\n{\n\tstruct mem_cgroup_per_node *mz;\n\tstruct mem_cgroup *memcg;\n\tstruct lruvec *lruvec;\n\n\tif (mem_cgroup_disabled()) {\n\t\tlruvec = &pgdat->lruvec;\n\t\tgoto out;\n\t}\n\n\tmemcg = page->mem_cgroup;\n\t/*\n\t * Swapcache readahead pages are added to the LRU - and\n\t * possibly migrated - before they are charged.\n\t */\n\tif (!memcg)\n\t\tmemcg = root_mem_cgroup;\n\n\tmz = mem_cgroup_page_nodeinfo(memcg, page);\n\tlruvec = &mz->lruvec;\nout:\n\t/*\n\t * Since a node can be onlined after the mem_cgroup was created,\n\t * we have to be prepared to initialize lruvec->zone here;\n\t * and if offlined then reonlined, we need to reinitialize it.\n\t */\n\tif (unlikely(lruvec->pgdat != pgdat))\n\t\tlruvec->pgdat = pgdat;\n\treturn lruvec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_pgdat",
          "args": [
            "page"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nstatic bool __munlock_isolate_lru_page(struct page *page, bool getpage)\n{\n\tif (PageLRU(page)) {\n\t\tstruct lruvec *lruvec;\n\n\t\tlruvec = mem_cgroup_page_lruvec(page, page_pgdat(page));\n\t\tif (getpage)\n\t\t\tget_page(page);\n\t\tClearPageLRU(page);\n\t\tdel_page_from_lru_list(page, lruvec, page_lru(page));\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "mlock_vma_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
    "lines": "88-103",
    "snippet": "void mlock_vma_page(struct page *page)\n{\n\t/* Serialize with page migration */\n\tBUG_ON(!PageLocked(page));\n\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tVM_BUG_ON_PAGE(PageCompound(page) && PageDoubleMap(page), page);\n\n\tif (!TestSetPageMlocked(page)) {\n\t\tmod_zone_page_state(page_zone(page), NR_MLOCK,\n\t\t\t\t    hpage_nr_pages(page));\n\t\tcount_vm_event(UNEVICTABLE_PGMLOCKED);\n\t\tif (!isolate_lru_page(page))\n\t\t\tputback_lru_page(page);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/rmap.h>",
      "#include <linux/export.h>",
      "#include <linux/sched.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/mm.h>",
      "#include <linux/mman.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "putback_lru_page",
          "args": [
            "page"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "putback_lru_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1005-1009",
          "snippet": "void putback_lru_page(struct page *page)\n{\n\tlru_cache_add(page);\n\tput_page(page);\t\t/* drop ref from isolate */\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid putback_lru_page(struct page *page)\n{\n\tlru_cache_add(page);\n\tput_page(page);\t\t/* drop ref from isolate */\n}"
        }
      },
      {
        "call_info": {
          "callee": "isolate_lru_page",
          "args": [
            "page"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "isolate_lru_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1772-1795",
          "snippet": "int isolate_lru_page(struct page *page)\n{\n\tint ret = -EBUSY;\n\n\tVM_BUG_ON_PAGE(!page_count(page), page);\n\tWARN_RATELIMIT(PageTail(page), \"trying to isolate tail page\");\n\n\tif (PageLRU(page)) {\n\t\tstruct zone *zone = page_zone(page);\n\t\tstruct lruvec *lruvec;\n\n\t\tspin_lock_irq(zone_lru_lock(zone));\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\t\tif (PageLRU(page)) {\n\t\t\tint lru = page_lru(page);\n\t\t\tget_page(page);\n\t\t\tClearPageLRU(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, lru);\n\t\t\tret = 0;\n\t\t}\n\t\tspin_unlock_irq(zone_lru_lock(zone));\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint isolate_lru_page(struct page *page)\n{\n\tint ret = -EBUSY;\n\n\tVM_BUG_ON_PAGE(!page_count(page), page);\n\tWARN_RATELIMIT(PageTail(page), \"trying to isolate tail page\");\n\n\tif (PageLRU(page)) {\n\t\tstruct zone *zone = page_zone(page);\n\t\tstruct lruvec *lruvec;\n\n\t\tspin_lock_irq(zone_lru_lock(zone));\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\t\tif (PageLRU(page)) {\n\t\t\tint lru = page_lru(page);\n\t\t\tget_page(page);\n\t\t\tClearPageLRU(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, lru);\n\t\t\tret = 0;\n\t\t}\n\t\tspin_unlock_irq(zone_lru_lock(zone));\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "UNEVICTABLE_PGMLOCKED"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mod_zone_page_state",
          "args": [
            "page_zone(page)",
            "NR_MLOCK",
            "hpage_nr_pages(page)"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "mod_zone_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "601-609",
          "snippet": "void mod_zone_page_state(struct zone *zone, enum zone_stat_item item,\n\t\t\t long delta)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__mod_zone_page_state(zone, item, delta);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid mod_zone_page_state(struct zone *zone, enum zone_stat_item item,\n\t\t\t long delta)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__mod_zone_page_state(zone, item, delta);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "page"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestSetPageMlocked",
          "args": [
            "page"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageCompound(page) && PageDoubleMap(page)",
            "page"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDoubleMap",
          "args": [
            "page"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "page"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageTail(page)",
            "page"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTail",
          "args": [
            "page"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nvoid mlock_vma_page(struct page *page)\n{\n\t/* Serialize with page migration */\n\tBUG_ON(!PageLocked(page));\n\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tVM_BUG_ON_PAGE(PageCompound(page) && PageDoubleMap(page), page);\n\n\tif (!TestSetPageMlocked(page)) {\n\t\tmod_zone_page_state(page_zone(page), NR_MLOCK,\n\t\t\t\t    hpage_nr_pages(page));\n\t\tcount_vm_event(UNEVICTABLE_PGMLOCKED);\n\t\tif (!isolate_lru_page(page))\n\t\t\tputback_lru_page(page);\n\t}\n}"
  },
  {
    "function_name": "clear_page_mlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
    "lines": "59-82",
    "snippet": "void clear_page_mlock(struct page *page)\n{\n\tif (!TestClearPageMlocked(page))\n\t\treturn;\n\n\tmod_zone_page_state(page_zone(page), NR_MLOCK,\n\t\t\t    -hpage_nr_pages(page));\n\tcount_vm_event(UNEVICTABLE_PGCLEARED);\n\t/*\n\t * The previous TestClearPageMlocked() corresponds to the smp_mb()\n\t * in __pagevec_lru_add_fn().\n\t *\n\t * See __pagevec_lru_add_fn for more explanation.\n\t */\n\tif (!isolate_lru_page(page)) {\n\t\tputback_lru_page(page);\n\t} else {\n\t\t/*\n\t\t * We lost the race. the page already moved to evictable list.\n\t\t */\n\t\tif (PageUnevictable(page))\n\t\t\tcount_vm_event(UNEVICTABLE_PGSTRANDED);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/rmap.h>",
      "#include <linux/export.h>",
      "#include <linux/sched.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/mm.h>",
      "#include <linux/mman.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "UNEVICTABLE_PGSTRANDED"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUnevictable",
          "args": [
            "page"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "putback_lru_page",
          "args": [
            "page"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "putback_lru_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1005-1009",
          "snippet": "void putback_lru_page(struct page *page)\n{\n\tlru_cache_add(page);\n\tput_page(page);\t\t/* drop ref from isolate */\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid putback_lru_page(struct page *page)\n{\n\tlru_cache_add(page);\n\tput_page(page);\t\t/* drop ref from isolate */\n}"
        }
      },
      {
        "call_info": {
          "callee": "isolate_lru_page",
          "args": [
            "page"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "isolate_lru_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1772-1795",
          "snippet": "int isolate_lru_page(struct page *page)\n{\n\tint ret = -EBUSY;\n\n\tVM_BUG_ON_PAGE(!page_count(page), page);\n\tWARN_RATELIMIT(PageTail(page), \"trying to isolate tail page\");\n\n\tif (PageLRU(page)) {\n\t\tstruct zone *zone = page_zone(page);\n\t\tstruct lruvec *lruvec;\n\n\t\tspin_lock_irq(zone_lru_lock(zone));\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\t\tif (PageLRU(page)) {\n\t\t\tint lru = page_lru(page);\n\t\t\tget_page(page);\n\t\t\tClearPageLRU(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, lru);\n\t\t\tret = 0;\n\t\t}\n\t\tspin_unlock_irq(zone_lru_lock(zone));\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint isolate_lru_page(struct page *page)\n{\n\tint ret = -EBUSY;\n\n\tVM_BUG_ON_PAGE(!page_count(page), page);\n\tWARN_RATELIMIT(PageTail(page), \"trying to isolate tail page\");\n\n\tif (PageLRU(page)) {\n\t\tstruct zone *zone = page_zone(page);\n\t\tstruct lruvec *lruvec;\n\n\t\tspin_lock_irq(zone_lru_lock(zone));\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\t\tif (PageLRU(page)) {\n\t\t\tint lru = page_lru(page);\n\t\t\tget_page(page);\n\t\t\tClearPageLRU(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, lru);\n\t\t\tret = 0;\n\t\t}\n\t\tspin_unlock_irq(zone_lru_lock(zone));\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "UNEVICTABLE_PGCLEARED"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mod_zone_page_state",
          "args": [
            "page_zone(page)",
            "NR_MLOCK",
            "-hpage_nr_pages(page)"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "mod_zone_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "601-609",
          "snippet": "void mod_zone_page_state(struct zone *zone, enum zone_stat_item item,\n\t\t\t long delta)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__mod_zone_page_state(zone, item, delta);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid mod_zone_page_state(struct zone *zone, enum zone_stat_item item,\n\t\t\t long delta)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__mod_zone_page_state(zone, item, delta);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "page"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestClearPageMlocked",
          "args": [
            "page"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nvoid clear_page_mlock(struct page *page)\n{\n\tif (!TestClearPageMlocked(page))\n\t\treturn;\n\n\tmod_zone_page_state(page_zone(page), NR_MLOCK,\n\t\t\t    -hpage_nr_pages(page));\n\tcount_vm_event(UNEVICTABLE_PGCLEARED);\n\t/*\n\t * The previous TestClearPageMlocked() corresponds to the smp_mb()\n\t * in __pagevec_lru_add_fn().\n\t *\n\t * See __pagevec_lru_add_fn for more explanation.\n\t */\n\tif (!isolate_lru_page(page)) {\n\t\tputback_lru_page(page);\n\t} else {\n\t\t/*\n\t\t * We lost the race. the page already moved to evictable list.\n\t\t */\n\t\tif (PageUnevictable(page))\n\t\t\tcount_vm_event(UNEVICTABLE_PGSTRANDED);\n\t}\n}"
  },
  {
    "function_name": "can_do_mlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
    "lines": "29-36",
    "snippet": "bool can_do_mlock(void)\n{\n\tif (rlimit(RLIMIT_MEMLOCK) != 0)\n\t\treturn true;\n\tif (capable(CAP_IPC_LOCK))\n\t\treturn true;\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/rmap.h>",
      "#include <linux/export.h>",
      "#include <linux/sched.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/mm.h>",
      "#include <linux/mman.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_IPC_LOCK"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rlimit",
          "args": [
            "RLIMIT_MEMLOCK"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nbool can_do_mlock(void)\n{\n\tif (rlimit(RLIMIT_MEMLOCK) != 0)\n\t\treturn true;\n\tif (capable(CAP_IPC_LOCK))\n\t\treturn true;\n\treturn false;\n}"
  },
  {
    "function_name": "mlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
    "lines": "716-719",
    "snippet": "SYSCALL_DEFINE2(mlock, unsigned long, start, size_t, len)\n{\n\treturn do_mlock(start, len, VM_LOCKED);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/rmap.h>",
      "#include <linux/export.h>",
      "#include <linux/sched.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/mm.h>",
      "#include <linux/mman.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nSYSCALL_DEFINE2(mlock, unsigned long, start, size_t, len)\n{\n\treturn do_mlock(start, len, VM_LOCKED);\n}"
  },
  {
    "function_name": "mlock2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
    "lines": "721-732",
    "snippet": "SYSCALL_DEFINE3(mlock2, unsigned long, start, size_t, len, int, flags)\n{\n\tvm_flags_t vm_flags = VM_LOCKED;\n\n\tif (flags & ~MLOCK_ONFAULT)\n\t\treturn -EINVAL;\n\n\tif (flags & MLOCK_ONFAULT)\n\t\tvm_flags |= VM_LOCKONFAULT;\n\n\treturn do_mlock(start, len, vm_flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/rmap.h>",
      "#include <linux/export.h>",
      "#include <linux/sched.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/mm.h>",
      "#include <linux/mman.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nSYSCALL_DEFINE3(mlock2, unsigned long, start, size_t, len, int, flags)\n{\n\tvm_flags_t vm_flags = VM_LOCKED;\n\n\tif (flags & ~MLOCK_ONFAULT)\n\t\treturn -EINVAL;\n\n\tif (flags & MLOCK_ONFAULT)\n\t\tvm_flags |= VM_LOCKONFAULT;\n\n\treturn do_mlock(start, len, vm_flags);\n}"
  },
  {
    "function_name": "munlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
    "lines": "734-747",
    "snippet": "SYSCALL_DEFINE2(munlock, unsigned long, start, size_t, len)\n{\n\tint ret;\n\n\tlen = PAGE_ALIGN(len + (offset_in_page(start)));\n\tstart &= PAGE_MASK;\n\n\tif (down_write_killable(&current->mm->mmap_sem))\n\t\treturn -EINTR;\n\tret = apply_vma_lock_flags(start, len, 0);\n\tup_write(&current->mm->mmap_sem);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/rmap.h>",
      "#include <linux/export.h>",
      "#include <linux/sched.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/mm.h>",
      "#include <linux/mman.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nSYSCALL_DEFINE2(munlock, unsigned long, start, size_t, len)\n{\n\tint ret;\n\n\tlen = PAGE_ALIGN(len + (offset_in_page(start)));\n\tstart &= PAGE_MASK;\n\n\tif (down_write_killable(&current->mm->mmap_sem))\n\t\treturn -EINTR;\n\tret = apply_vma_lock_flags(start, len, 0);\n\tup_write(&current->mm->mmap_sem);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "mlockall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
    "lines": "795-821",
    "snippet": "SYSCALL_DEFINE1(mlockall, int, flags)\n{\n\tunsigned long lock_limit;\n\tint ret;\n\n\tif (!flags || (flags & ~(MCL_CURRENT | MCL_FUTURE | MCL_ONFAULT)))\n\t\treturn -EINVAL;\n\n\tif (!can_do_mlock())\n\t\treturn -EPERM;\n\n\tlock_limit = rlimit(RLIMIT_MEMLOCK);\n\tlock_limit >>= PAGE_SHIFT;\n\n\tif (down_write_killable(&current->mm->mmap_sem))\n\t\treturn -EINTR;\n\n\tret = -ENOMEM;\n\tif (!(flags & MCL_CURRENT) || (current->mm->total_vm <= lock_limit) ||\n\t    capable(CAP_IPC_LOCK))\n\t\tret = apply_mlockall_flags(flags);\n\tup_write(&current->mm->mmap_sem);\n\tif (!ret && (flags & MCL_CURRENT))\n\t\tmm_populate(0, TASK_SIZE);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/rmap.h>",
      "#include <linux/export.h>",
      "#include <linux/sched.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/mm.h>",
      "#include <linux/mman.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nSYSCALL_DEFINE1(mlockall, int, flags)\n{\n\tunsigned long lock_limit;\n\tint ret;\n\n\tif (!flags || (flags & ~(MCL_CURRENT | MCL_FUTURE | MCL_ONFAULT)))\n\t\treturn -EINVAL;\n\n\tif (!can_do_mlock())\n\t\treturn -EPERM;\n\n\tlock_limit = rlimit(RLIMIT_MEMLOCK);\n\tlock_limit >>= PAGE_SHIFT;\n\n\tif (down_write_killable(&current->mm->mmap_sem))\n\t\treturn -EINTR;\n\n\tret = -ENOMEM;\n\tif (!(flags & MCL_CURRENT) || (current->mm->total_vm <= lock_limit) ||\n\t    capable(CAP_IPC_LOCK))\n\t\tret = apply_mlockall_flags(flags);\n\tup_write(&current->mm->mmap_sem);\n\tif (!ret && (flags & MCL_CURRENT))\n\t\tmm_populate(0, TASK_SIZE);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "munlockall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mlock.c",
    "lines": "823-832",
    "snippet": "SYSCALL_DEFINE0(munlockall)\n{\n\tint ret;\n\n\tif (down_write_killable(&current->mm->mmap_sem))\n\t\treturn -EINTR;\n\tret = apply_mlockall_flags(0);\n\tup_write(&current->mm->mmap_sem);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/rmap.h>",
      "#include <linux/export.h>",
      "#include <linux/sched.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/mm.h>",
      "#include <linux/mman.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/mmzone.h>\n#include <linux/rmap.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/mempolicy.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/sched/user.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/capability.h>\n\nSYSCALL_DEFINE0(munlockall)\n{\n\tint ret;\n\n\tif (down_write_killable(&current->mm->mmap_sem))\n\t\treturn -EINTR;\n\tret = apply_mlockall_flags(0);\n\tup_write(&current->mm->mmap_sem);\n\treturn ret;\n}"
  }
]