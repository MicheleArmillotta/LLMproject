[
  {
    "function_name": "should_failslab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "1576-1581",
    "snippet": "int should_failslab(struct kmem_cache *s, gfp_t gfpflags)\n{\n\tif (__should_failslab(s, gfpflags))\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__should_failslab",
          "args": [
            "s",
            "gfpflags"
          ],
          "line": 1578
        },
        "resolved": true,
        "details": {
          "function_name": "__should_failslab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/failslab.c",
          "lines": "17-33",
          "snippet": "bool __should_failslab(struct kmem_cache *s, gfp_t gfpflags)\n{\n\t/* No fault-injection for bootstrap cache */\n\tif (unlikely(s == kmem_cache))\n\t\treturn false;\n\n\tif (gfpflags & __GFP_NOFAIL)\n\t\treturn false;\n\n\tif (failslab.ignore_gfp_reclaim && (gfpflags & __GFP_RECLAIM))\n\t\treturn false;\n\n\tif (failslab.cache_filter && !(s->flags & SLAB_FAILSLAB))\n\t\treturn false;\n\n\treturn should_fail(&failslab.attr, s->object_size);\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/fault-inject.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tstruct fault_attr attr;\n\tbool ignore_gfp_reclaim;\n\tbool cache_filter;\n} failslab = {\n\t.attr = FAULT_ATTR_INITIALIZER,\n\t.ignore_gfp_reclaim = true,\n\t.cache_filter = false,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/fault-inject.h>\n\nstatic struct {\n\tstruct fault_attr attr;\n\tbool ignore_gfp_reclaim;\n\tbool cache_filter;\n} failslab = {\n\t.attr = FAULT_ATTR_INITIALIZER,\n\t.ignore_gfp_reclaim = true,\n\t.cache_filter = false,\n};\n\nbool __should_failslab(struct kmem_cache *s, gfp_t gfpflags)\n{\n\t/* No fault-injection for bootstrap cache */\n\tif (unlikely(s == kmem_cache))\n\t\treturn false;\n\n\tif (gfpflags & __GFP_NOFAIL)\n\t\treturn false;\n\n\tif (failslab.ignore_gfp_reclaim && (gfpflags & __GFP_RECLAIM))\n\t\treturn false;\n\n\tif (failslab.cache_filter && !(s->flags & SLAB_FAILSLAB))\n\t\treturn false;\n\n\treturn should_fail(&failslab.attr, s->object_size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nint should_failslab(struct kmem_cache *s, gfp_t gfpflags)\n{\n\tif (__should_failslab(s, gfpflags))\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "kzfree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "1555-1565",
    "snippet": "void kzfree(const void *p)\n{\n\tsize_t ks;\n\tvoid *mem = (void *)p;\n\n\tif (unlikely(ZERO_OR_NULL_PTR(mem)))\n\t\treturn;\n\tks = ksize(mem);\n\tmemset(mem, 0, ks);\n\tkfree(mem);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mem"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "mem",
            "0",
            "ks"
          ],
          "line": 1563
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ksize",
          "args": [
            "mem"
          ],
          "line": 1562
        },
        "resolved": true,
        "details": {
          "function_name": "ksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "4465-4480",
          "snippet": "size_t ksize(const void *objp)\n{\n\tsize_t size;\n\n\tBUG_ON(!objp);\n\tif (unlikely(objp == ZERO_SIZE_PTR))\n\t\treturn 0;\n\n\tsize = virt_to_cache(objp)->object_size;\n\t/* We assume that ksize callers could use the whole allocated area,\n\t * so we need to unpoison this area.\n\t */\n\tkasan_unpoison_shadow(objp, size);\n\n\treturn size;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nsize_t ksize(const void *objp)\n{\n\tsize_t size;\n\n\tBUG_ON(!objp);\n\tif (unlikely(objp == ZERO_SIZE_PTR))\n\t\treturn 0;\n\n\tsize = virt_to_cache(objp)->object_size;\n\t/* We assume that ksize callers could use the whole allocated area,\n\t * so we need to unpoison this area.\n\t */\n\tkasan_unpoison_shadow(objp, size);\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ZERO_OR_NULL_PTR(mem)"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ZERO_OR_NULL_PTR",
          "args": [
            "mem"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nvoid kzfree(const void *p)\n{\n\tsize_t ks;\n\tvoid *mem = (void *)p;\n\n\tif (unlikely(ZERO_OR_NULL_PTR(mem)))\n\t\treturn;\n\tks = ksize(mem);\n\tmemset(mem, 0, ks);\n\tkfree(mem);\n}"
  },
  {
    "function_name": "krealloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "1527-1541",
    "snippet": "void *krealloc(const void *p, size_t new_size, gfp_t flags)\n{\n\tvoid *ret;\n\n\tif (unlikely(!new_size)) {\n\t\tkfree(p);\n\t\treturn ZERO_SIZE_PTR;\n\t}\n\n\tret = __do_krealloc(p, new_size, flags);\n\tif (ret && p != ret)\n\t\tkfree(p);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "p"
          ],
          "line": 1538
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__do_krealloc",
          "args": [
            "p",
            "new_size",
            "flags"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "__do_krealloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "1475-1494",
          "snippet": "static __always_inline void *__do_krealloc(const void *p, size_t new_size,\n\t\t\t\t\t   gfp_t flags)\n{\n\tvoid *ret;\n\tsize_t ks = 0;\n\n\tif (p)\n\t\tks = ksize(p);\n\n\tif (ks >= new_size) {\n\t\tkasan_krealloc((void *)p, new_size, flags);\n\t\treturn (void *)p;\n\t}\n\n\tret = kmalloc_track_caller(new_size, flags);\n\tif (ret && p)\n\t\tmemcpy(ret, p, ks);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstatic __always_inline void *__do_krealloc(const void *p, size_t new_size,\n\t\t\t\t\t   gfp_t flags)\n{\n\tvoid *ret;\n\tsize_t ks = 0;\n\n\tif (p)\n\t\tks = ksize(p);\n\n\tif (ks >= new_size) {\n\t\tkasan_krealloc((void *)p, new_size, flags);\n\t\treturn (void *)p;\n\t}\n\n\tret = kmalloc_track_caller(new_size, flags);\n\tif (ret && p)\n\t\tmemcpy(ret, p, ks);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!new_size"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nvoid *krealloc(const void *p, size_t new_size, gfp_t flags)\n{\n\tvoid *ret;\n\n\tif (unlikely(!new_size)) {\n\t\tkfree(p);\n\t\treturn ZERO_SIZE_PTR;\n\t}\n\n\tret = __do_krealloc(p, new_size, flags);\n\tif (ret && p != ret)\n\t\tkfree(p);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__krealloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "1506-1513",
    "snippet": "void *__krealloc(const void *p, size_t new_size, gfp_t flags)\n{\n\tif (unlikely(!new_size))\n\t\treturn ZERO_SIZE_PTR;\n\n\treturn __do_krealloc(p, new_size, flags);\n\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__do_krealloc",
          "args": [
            "p",
            "new_size",
            "flags"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "__do_krealloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "1475-1494",
          "snippet": "static __always_inline void *__do_krealloc(const void *p, size_t new_size,\n\t\t\t\t\t   gfp_t flags)\n{\n\tvoid *ret;\n\tsize_t ks = 0;\n\n\tif (p)\n\t\tks = ksize(p);\n\n\tif (ks >= new_size) {\n\t\tkasan_krealloc((void *)p, new_size, flags);\n\t\treturn (void *)p;\n\t}\n\n\tret = kmalloc_track_caller(new_size, flags);\n\tif (ret && p)\n\t\tmemcpy(ret, p, ks);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstatic __always_inline void *__do_krealloc(const void *p, size_t new_size,\n\t\t\t\t\t   gfp_t flags)\n{\n\tvoid *ret;\n\tsize_t ks = 0;\n\n\tif (p)\n\t\tks = ksize(p);\n\n\tif (ks >= new_size) {\n\t\tkasan_krealloc((void *)p, new_size, flags);\n\t\treturn (void *)p;\n\t}\n\n\tret = kmalloc_track_caller(new_size, flags);\n\tif (ret && p)\n\t\tmemcpy(ret, p, ks);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!new_size"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nvoid *__krealloc(const void *p, size_t new_size, gfp_t flags)\n{\n\tif (unlikely(!new_size))\n\t\treturn ZERO_SIZE_PTR;\n\n\treturn __do_krealloc(p, new_size, flags);\n\n}"
  },
  {
    "function_name": "__do_krealloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "1475-1494",
    "snippet": "static __always_inline void *__do_krealloc(const void *p, size_t new_size,\n\t\t\t\t\t   gfp_t flags)\n{\n\tvoid *ret;\n\tsize_t ks = 0;\n\n\tif (p)\n\t\tks = ksize(p);\n\n\tif (ks >= new_size) {\n\t\tkasan_krealloc((void *)p, new_size, flags);\n\t\treturn (void *)p;\n\t}\n\n\tret = kmalloc_track_caller(new_size, flags);\n\tif (ret && p)\n\t\tmemcpy(ret, p, ks);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ret",
            "p",
            "ks"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "300-306",
          "snippet": "void *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc_track_caller",
          "args": [
            "new_size",
            "flags"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasan_krealloc",
          "args": [
            "(void *)p",
            "new_size",
            "flags"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_krealloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "579-592",
          "snippet": "void kasan_krealloc(const void *object, size_t size, gfp_t flags)\n{\n\tstruct page *page;\n\n\tif (unlikely(object == ZERO_SIZE_PTR))\n\t\treturn;\n\n\tpage = virt_to_head_page(object);\n\n\tif (unlikely(!PageSlab(page)))\n\t\tkasan_kmalloc_large(object, size, flags);\n\telse\n\t\tkasan_kmalloc(page->slab_cache, object, size, flags);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid kasan_krealloc(const void *object, size_t size, gfp_t flags)\n{\n\tstruct page *page;\n\n\tif (unlikely(object == ZERO_SIZE_PTR))\n\t\treturn;\n\n\tpage = virt_to_head_page(object);\n\n\tif (unlikely(!PageSlab(page)))\n\t\tkasan_kmalloc_large(object, size, flags);\n\telse\n\t\tkasan_kmalloc(page->slab_cache, object, size, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ksize",
          "args": [
            "p"
          ],
          "line": 1482
        },
        "resolved": true,
        "details": {
          "function_name": "ksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "4465-4480",
          "snippet": "size_t ksize(const void *objp)\n{\n\tsize_t size;\n\n\tBUG_ON(!objp);\n\tif (unlikely(objp == ZERO_SIZE_PTR))\n\t\treturn 0;\n\n\tsize = virt_to_cache(objp)->object_size;\n\t/* We assume that ksize callers could use the whole allocated area,\n\t * so we need to unpoison this area.\n\t */\n\tkasan_unpoison_shadow(objp, size);\n\n\treturn size;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nsize_t ksize(const void *objp)\n{\n\tsize_t size;\n\n\tBUG_ON(!objp);\n\tif (unlikely(objp == ZERO_SIZE_PTR))\n\t\treturn 0;\n\n\tsize = virt_to_cache(objp)->object_size;\n\t/* We assume that ksize callers could use the whole allocated area,\n\t * so we need to unpoison this area.\n\t */\n\tkasan_unpoison_shadow(objp, size);\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstatic __always_inline void *__do_krealloc(const void *p, size_t new_size,\n\t\t\t\t\t   gfp_t flags)\n{\n\tvoid *ret;\n\tsize_t ks = 0;\n\n\tif (p)\n\t\tks = ksize(p);\n\n\tif (ks >= new_size) {\n\t\tkasan_krealloc((void *)p, new_size, flags);\n\t\treturn (void *)p;\n\t}\n\n\tret = kmalloc_track_caller(new_size, flags);\n\tif (ret && p)\n\t\tmemcpy(ret, p, ks);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "slab_proc_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "1466-1471",
    "snippet": "static int __init slab_proc_init(void)\n{\n\tproc_create(\"slabinfo\", SLABINFO_RIGHTS, NULL,\n\t\t\t\t\t\t&proc_slabinfo_operations);\n\treturn 0;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define SLABINFO_RIGHTS (0400)",
      "#define SLABINFO_RIGHTS (0600)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"slabinfo\"",
            "SLABINFO_RIGHTS",
            "NULL",
            "&proc_slabinfo_operations"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\n#define SLABINFO_RIGHTS (0400)\n#define SLABINFO_RIGHTS (0600)\n\nstatic int __init slab_proc_init(void)\n{\n\tproc_create(\"slabinfo\", SLABINFO_RIGHTS, NULL,\n\t\t\t\t\t\t&proc_slabinfo_operations);\n\treturn 0;\n}"
  },
  {
    "function_name": "slabinfo_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "1453-1456",
    "snippet": "static int slabinfo_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &slabinfo_op);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&slabinfo_op"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstatic int slabinfo_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &slabinfo_op);\n}"
  },
  {
    "function_name": "memcg_slab_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "1420-1430",
    "snippet": "int memcg_slab_show(struct seq_file *m, void *p)\n{\n\tstruct kmem_cache *s = list_entry(p, struct kmem_cache,\n\t\t\t\t\t  memcg_params.kmem_caches_node);\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(m));\n\n\tif (p == memcg->kmem_caches.next)\n\t\tprint_slabinfo_header(m);\n\tcache_show(s, m);\n\treturn 0;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cache_show",
          "args": [
            "s",
            "m"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "cache_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "1334-1353",
          "snippet": "static void cache_show(struct kmem_cache *s, struct seq_file *m)\n{\n\tstruct slabinfo sinfo;\n\n\tmemset(&sinfo, 0, sizeof(sinfo));\n\tget_slabinfo(s, &sinfo);\n\n\tmemcg_accumulate_slabinfo(s, &sinfo);\n\n\tseq_printf(m, \"%-17s %6lu %6lu %6u %4u %4d\",\n\t\t   cache_name(s), sinfo.active_objs, sinfo.num_objs, s->size,\n\t\t   sinfo.objects_per_slab, (1 << sinfo.cache_order));\n\n\tseq_printf(m, \" : tunables %4u %4u %4u\",\n\t\t   sinfo.limit, sinfo.batchcount, sinfo.shared);\n\tseq_printf(m, \" : slabdata %6lu %6lu %6lu\",\n\t\t   sinfo.active_slabs, sinfo.num_slabs, sinfo.shared_avail);\n\tslabinfo_show_stats(m, s);\n\tseq_putc(m, '\\n');\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstatic void cache_show(struct kmem_cache *s, struct seq_file *m)\n{\n\tstruct slabinfo sinfo;\n\n\tmemset(&sinfo, 0, sizeof(sinfo));\n\tget_slabinfo(s, &sinfo);\n\n\tmemcg_accumulate_slabinfo(s, &sinfo);\n\n\tseq_printf(m, \"%-17s %6lu %6lu %6u %4u %4d\",\n\t\t   cache_name(s), sinfo.active_objs, sinfo.num_objs, s->size,\n\t\t   sinfo.objects_per_slab, (1 << sinfo.cache_order));\n\n\tseq_printf(m, \" : tunables %4u %4u %4u\",\n\t\t   sinfo.limit, sinfo.batchcount, sinfo.shared);\n\tseq_printf(m, \" : slabdata %6lu %6lu %6lu\",\n\t\t   sinfo.active_slabs, sinfo.num_slabs, sinfo.shared_avail);\n\tslabinfo_show_stats(m, s);\n\tseq_putc(m, '\\n');\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_slabinfo_header",
          "args": [
            "m"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "print_slabinfo_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "1276-1295",
          "snippet": "static void print_slabinfo_header(struct seq_file *m)\n{\n\t/*\n\t * Output format version, so at least we can change it\n\t * without _too_ many complaints.\n\t */\n#ifdef CONFIG_DEBUG_SLAB\n\tseq_puts(m, \"slabinfo - version: 2.1 (statistics)\\n\");\n#else\n\tseq_puts(m, \"slabinfo - version: 2.1\\n\");\n#endif\n\tseq_puts(m, \"# name            <active_objs> <num_objs> <objsize> <objperslab> <pagesperslab>\");\n\tseq_puts(m, \" : tunables <limit> <batchcount> <sharedfactor>\");\n\tseq_puts(m, \" : slabdata <active_slabs> <num_slabs> <sharedavail>\");\n#ifdef CONFIG_DEBUG_SLAB\n\tseq_puts(m, \" : globalstat <listallocs> <maxobjs> <grown> <reaped> <error> <maxfreeable> <nodeallocs> <remotefrees> <alienoverflow>\");\n\tseq_puts(m, \" : cpustat <allochit> <allocmiss> <freehit> <freemiss>\");\n#endif\n\tseq_putc(m, '\\n');\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstatic void print_slabinfo_header(struct seq_file *m)\n{\n\t/*\n\t * Output format version, so at least we can change it\n\t * without _too_ many complaints.\n\t */\n#ifdef CONFIG_DEBUG_SLAB\n\tseq_puts(m, \"slabinfo - version: 2.1 (statistics)\\n\");\n#else\n\tseq_puts(m, \"slabinfo - version: 2.1\\n\");\n#endif\n\tseq_puts(m, \"# name            <active_objs> <num_objs> <objsize> <objperslab> <pagesperslab>\");\n\tseq_puts(m, \" : tunables <limit> <batchcount> <sharedfactor>\");\n\tseq_puts(m, \" : slabdata <active_slabs> <num_slabs> <sharedavail>\");\n#ifdef CONFIG_DEBUG_SLAB\n\tseq_puts(m, \" : globalstat <listallocs> <maxobjs> <grown> <reaped> <error> <maxfreeable> <nodeallocs> <remotefrees> <alienoverflow>\");\n\tseq_puts(m, \" : cpustat <allochit> <allocmiss> <freehit> <freemiss>\");\n#endif\n\tseq_putc(m, '\\n');\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "seq_css(m)"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "m"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "p",
            "structkmem_cache",
            "memcg_params.kmem_caches_node"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nint memcg_slab_show(struct seq_file *m, void *p)\n{\n\tstruct kmem_cache *s = list_entry(p, struct kmem_cache,\n\t\t\t\t\t  memcg_params.kmem_caches_node);\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(m));\n\n\tif (p == memcg->kmem_caches.next)\n\t\tprint_slabinfo_header(m);\n\tcache_show(s, m);\n\treturn 0;\n}"
  },
  {
    "function_name": "memcg_slab_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "1415-1418",
    "snippet": "void memcg_slab_stop(struct seq_file *m, void *p)\n{\n\tmutex_unlock(&slab_mutex);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&slab_mutex"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nvoid memcg_slab_stop(struct seq_file *m, void *p)\n{\n\tmutex_unlock(&slab_mutex);\n}"
  },
  {
    "function_name": "memcg_slab_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "1408-1413",
    "snippet": "void *memcg_slab_next(struct seq_file *m, void *p, loff_t *pos)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(m));\n\n\treturn seq_list_next(p, &memcg->kmem_caches, pos);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_list_next",
          "args": [
            "p",
            "&memcg->kmem_caches",
            "pos"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "seq_css(m)"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "m"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nvoid *memcg_slab_next(struct seq_file *m, void *p, loff_t *pos)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(m));\n\n\treturn seq_list_next(p, &memcg->kmem_caches, pos);\n}"
  },
  {
    "function_name": "memcg_slab_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "1400-1406",
    "snippet": "void *memcg_slab_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(m));\n\n\tmutex_lock(&slab_mutex);\n\treturn seq_list_start(&memcg->kmem_caches, *pos);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_list_start",
          "args": [
            "&memcg->kmem_caches",
            "*pos"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&slab_mutex"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_css",
          "args": [
            "seq_css(m)"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "m"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nvoid *memcg_slab_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(seq_css(m));\n\n\tmutex_lock(&slab_mutex);\n\treturn seq_list_start(&memcg->kmem_caches, *pos);\n}"
  },
  {
    "function_name": "dump_unreclaimable_slab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "1365-1397",
    "snippet": "void dump_unreclaimable_slab(void)\n{\n\tstruct kmem_cache *s, *s2;\n\tstruct slabinfo sinfo;\n\n\t/*\n\t * Here acquiring slab_mutex is risky since we don't prefer to get\n\t * sleep in oom path. But, without mutex hold, it may introduce a\n\t * risk of crash.\n\t * Use mutex_trylock to protect the list traverse, dump nothing\n\t * without acquiring the mutex.\n\t */\n\tif (!mutex_trylock(&slab_mutex)) {\n\t\tpr_warn(\"excessive unreclaimable slab but cannot dump stats\\n\");\n\t\treturn;\n\t}\n\n\tpr_info(\"Unreclaimable slab info:\\n\");\n\tpr_info(\"Name                      Used          Total\\n\");\n\n\tlist_for_each_entry_safe(s, s2, &slab_caches, list) {\n\t\tif (!is_root_cache(s) || (s->flags & SLAB_RECLAIM_ACCOUNT))\n\t\t\tcontinue;\n\n\t\tget_slabinfo(s, &sinfo);\n\n\t\tif (sinfo.num_objs > 0)\n\t\t\tpr_info(\"%-17s %10luKB %10luKB\\n\", cache_name(s),\n\t\t\t\t(sinfo.active_objs * s->size) / 1024,\n\t\t\t\t(sinfo.num_objs * s->size) / 1024);\n\t}\n\tmutex_unlock(&slab_mutex);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&slab_mutex"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%-17s %10luKB %10luKB\\n\"",
            "cache_name(s)",
            "(sinfo.active_objs * s->size) / 1024",
            "(sinfo.num_objs * s->size) / 1024"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_name",
          "args": [
            "s"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "cache_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "319-322",
          "snippet": "static inline const char *cache_name(struct kmem_cache *s)\n{\n\treturn s->name;\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline const char *cache_name(struct kmem_cache *s)\n{\n\treturn s->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_slabinfo",
          "args": [
            "s",
            "&sinfo"
          ],
          "line": 1389
        },
        "resolved": true,
        "details": {
          "function_name": "get_slabinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "4097-4132",
          "snippet": "void get_slabinfo(struct kmem_cache *cachep, struct slabinfo *sinfo)\n{\n\tunsigned long active_objs, num_objs, active_slabs;\n\tunsigned long total_slabs = 0, free_objs = 0, shared_avail = 0;\n\tunsigned long free_slabs = 0;\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tfor_each_kmem_cache_node(cachep, node, n) {\n\t\tcheck_irq_on();\n\t\tspin_lock_irq(&n->list_lock);\n\n\t\ttotal_slabs += n->total_slabs;\n\t\tfree_slabs += n->free_slabs;\n\t\tfree_objs += n->free_objects;\n\n\t\tif (n->shared)\n\t\t\tshared_avail += n->shared->avail;\n\n\t\tspin_unlock_irq(&n->list_lock);\n\t}\n\tnum_objs = total_slabs * cachep->num;\n\tactive_slabs = total_slabs - free_slabs;\n\tactive_objs = num_objs - free_objs;\n\n\tsinfo->active_objs = active_objs;\n\tsinfo->num_objs = num_objs;\n\tsinfo->active_slabs = active_slabs;\n\tsinfo->num_slabs = total_slabs;\n\tsinfo->shared_avail = shared_avail;\n\tsinfo->limit = cachep->limit;\n\tsinfo->batchcount = cachep->batchcount;\n\tsinfo->shared = cachep->shared;\n\tsinfo->objects_per_slab = cachep->num;\n\tsinfo->cache_order = cachep->gfporder;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid get_slabinfo(struct kmem_cache *cachep, struct slabinfo *sinfo)\n{\n\tunsigned long active_objs, num_objs, active_slabs;\n\tunsigned long total_slabs = 0, free_objs = 0, shared_avail = 0;\n\tunsigned long free_slabs = 0;\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tfor_each_kmem_cache_node(cachep, node, n) {\n\t\tcheck_irq_on();\n\t\tspin_lock_irq(&n->list_lock);\n\n\t\ttotal_slabs += n->total_slabs;\n\t\tfree_slabs += n->free_slabs;\n\t\tfree_objs += n->free_objects;\n\n\t\tif (n->shared)\n\t\t\tshared_avail += n->shared->avail;\n\n\t\tspin_unlock_irq(&n->list_lock);\n\t}\n\tnum_objs = total_slabs * cachep->num;\n\tactive_slabs = total_slabs - free_slabs;\n\tactive_objs = num_objs - free_objs;\n\n\tsinfo->active_objs = active_objs;\n\tsinfo->num_objs = num_objs;\n\tsinfo->active_slabs = active_slabs;\n\tsinfo->num_slabs = total_slabs;\n\tsinfo->shared_avail = shared_avail;\n\tsinfo->limit = cachep->limit;\n\tsinfo->batchcount = cachep->batchcount;\n\tsinfo->shared = cachep->shared;\n\tsinfo->objects_per_slab = cachep->num;\n\tsinfo->cache_order = cachep->gfporder;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_root_cache",
          "args": [
            "s"
          ],
          "line": 1386
        },
        "resolved": true,
        "details": {
          "function_name": "is_root_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "308-311",
          "snippet": "static inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn true;\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "s",
            "s2",
            "&slab_caches",
            "list"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Name                      Used          Total\\n\""
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Unreclaimable slab info:\\n\""
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"excessive unreclaimable slab but cannot dump stats\\n\""
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_trylock",
          "args": [
            "&slab_mutex"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nvoid dump_unreclaimable_slab(void)\n{\n\tstruct kmem_cache *s, *s2;\n\tstruct slabinfo sinfo;\n\n\t/*\n\t * Here acquiring slab_mutex is risky since we don't prefer to get\n\t * sleep in oom path. But, without mutex hold, it may introduce a\n\t * risk of crash.\n\t * Use mutex_trylock to protect the list traverse, dump nothing\n\t * without acquiring the mutex.\n\t */\n\tif (!mutex_trylock(&slab_mutex)) {\n\t\tpr_warn(\"excessive unreclaimable slab but cannot dump stats\\n\");\n\t\treturn;\n\t}\n\n\tpr_info(\"Unreclaimable slab info:\\n\");\n\tpr_info(\"Name                      Used          Total\\n\");\n\n\tlist_for_each_entry_safe(s, s2, &slab_caches, list) {\n\t\tif (!is_root_cache(s) || (s->flags & SLAB_RECLAIM_ACCOUNT))\n\t\t\tcontinue;\n\n\t\tget_slabinfo(s, &sinfo);\n\n\t\tif (sinfo.num_objs > 0)\n\t\t\tpr_info(\"%-17s %10luKB %10luKB\\n\", cache_name(s),\n\t\t\t\t(sinfo.active_objs * s->size) / 1024,\n\t\t\t\t(sinfo.num_objs * s->size) / 1024);\n\t}\n\tmutex_unlock(&slab_mutex);\n}"
  },
  {
    "function_name": "slab_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "1355-1363",
    "snippet": "static int slab_show(struct seq_file *m, void *p)\n{\n\tstruct kmem_cache *s = list_entry(p, struct kmem_cache, root_caches_node);\n\n\tif (p == slab_root_caches.next)\n\t\tprint_slabinfo_header(m);\n\tcache_show(s, m);\n\treturn 0;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cache_show",
          "args": [
            "s",
            "m"
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "cache_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "1334-1353",
          "snippet": "static void cache_show(struct kmem_cache *s, struct seq_file *m)\n{\n\tstruct slabinfo sinfo;\n\n\tmemset(&sinfo, 0, sizeof(sinfo));\n\tget_slabinfo(s, &sinfo);\n\n\tmemcg_accumulate_slabinfo(s, &sinfo);\n\n\tseq_printf(m, \"%-17s %6lu %6lu %6u %4u %4d\",\n\t\t   cache_name(s), sinfo.active_objs, sinfo.num_objs, s->size,\n\t\t   sinfo.objects_per_slab, (1 << sinfo.cache_order));\n\n\tseq_printf(m, \" : tunables %4u %4u %4u\",\n\t\t   sinfo.limit, sinfo.batchcount, sinfo.shared);\n\tseq_printf(m, \" : slabdata %6lu %6lu %6lu\",\n\t\t   sinfo.active_slabs, sinfo.num_slabs, sinfo.shared_avail);\n\tslabinfo_show_stats(m, s);\n\tseq_putc(m, '\\n');\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstatic void cache_show(struct kmem_cache *s, struct seq_file *m)\n{\n\tstruct slabinfo sinfo;\n\n\tmemset(&sinfo, 0, sizeof(sinfo));\n\tget_slabinfo(s, &sinfo);\n\n\tmemcg_accumulate_slabinfo(s, &sinfo);\n\n\tseq_printf(m, \"%-17s %6lu %6lu %6u %4u %4d\",\n\t\t   cache_name(s), sinfo.active_objs, sinfo.num_objs, s->size,\n\t\t   sinfo.objects_per_slab, (1 << sinfo.cache_order));\n\n\tseq_printf(m, \" : tunables %4u %4u %4u\",\n\t\t   sinfo.limit, sinfo.batchcount, sinfo.shared);\n\tseq_printf(m, \" : slabdata %6lu %6lu %6lu\",\n\t\t   sinfo.active_slabs, sinfo.num_slabs, sinfo.shared_avail);\n\tslabinfo_show_stats(m, s);\n\tseq_putc(m, '\\n');\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_slabinfo_header",
          "args": [
            "m"
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "print_slabinfo_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "1276-1295",
          "snippet": "static void print_slabinfo_header(struct seq_file *m)\n{\n\t/*\n\t * Output format version, so at least we can change it\n\t * without _too_ many complaints.\n\t */\n#ifdef CONFIG_DEBUG_SLAB\n\tseq_puts(m, \"slabinfo - version: 2.1 (statistics)\\n\");\n#else\n\tseq_puts(m, \"slabinfo - version: 2.1\\n\");\n#endif\n\tseq_puts(m, \"# name            <active_objs> <num_objs> <objsize> <objperslab> <pagesperslab>\");\n\tseq_puts(m, \" : tunables <limit> <batchcount> <sharedfactor>\");\n\tseq_puts(m, \" : slabdata <active_slabs> <num_slabs> <sharedavail>\");\n#ifdef CONFIG_DEBUG_SLAB\n\tseq_puts(m, \" : globalstat <listallocs> <maxobjs> <grown> <reaped> <error> <maxfreeable> <nodeallocs> <remotefrees> <alienoverflow>\");\n\tseq_puts(m, \" : cpustat <allochit> <allocmiss> <freehit> <freemiss>\");\n#endif\n\tseq_putc(m, '\\n');\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstatic void print_slabinfo_header(struct seq_file *m)\n{\n\t/*\n\t * Output format version, so at least we can change it\n\t * without _too_ many complaints.\n\t */\n#ifdef CONFIG_DEBUG_SLAB\n\tseq_puts(m, \"slabinfo - version: 2.1 (statistics)\\n\");\n#else\n\tseq_puts(m, \"slabinfo - version: 2.1\\n\");\n#endif\n\tseq_puts(m, \"# name            <active_objs> <num_objs> <objsize> <objperslab> <pagesperslab>\");\n\tseq_puts(m, \" : tunables <limit> <batchcount> <sharedfactor>\");\n\tseq_puts(m, \" : slabdata <active_slabs> <num_slabs> <sharedavail>\");\n#ifdef CONFIG_DEBUG_SLAB\n\tseq_puts(m, \" : globalstat <listallocs> <maxobjs> <grown> <reaped> <error> <maxfreeable> <nodeallocs> <remotefrees> <alienoverflow>\");\n\tseq_puts(m, \" : cpustat <allochit> <allocmiss> <freehit> <freemiss>\");\n#endif\n\tseq_putc(m, '\\n');\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "p",
            "structkmem_cache",
            "root_caches_node"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstatic int slab_show(struct seq_file *m, void *p)\n{\n\tstruct kmem_cache *s = list_entry(p, struct kmem_cache, root_caches_node);\n\n\tif (p == slab_root_caches.next)\n\t\tprint_slabinfo_header(m);\n\tcache_show(s, m);\n\treturn 0;\n}"
  },
  {
    "function_name": "cache_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "1334-1353",
    "snippet": "static void cache_show(struct kmem_cache *s, struct seq_file *m)\n{\n\tstruct slabinfo sinfo;\n\n\tmemset(&sinfo, 0, sizeof(sinfo));\n\tget_slabinfo(s, &sinfo);\n\n\tmemcg_accumulate_slabinfo(s, &sinfo);\n\n\tseq_printf(m, \"%-17s %6lu %6lu %6u %4u %4d\",\n\t\t   cache_name(s), sinfo.active_objs, sinfo.num_objs, s->size,\n\t\t   sinfo.objects_per_slab, (1 << sinfo.cache_order));\n\n\tseq_printf(m, \" : tunables %4u %4u %4u\",\n\t\t   sinfo.limit, sinfo.batchcount, sinfo.shared);\n\tseq_printf(m, \" : slabdata %6lu %6lu %6lu\",\n\t\t   sinfo.active_slabs, sinfo.num_slabs, sinfo.shared_avail);\n\tslabinfo_show_stats(m, s);\n\tseq_putc(m, '\\n');\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slabinfo_show_stats",
          "args": [
            "m",
            "s"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "slabinfo_show_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "4134-4164",
          "snippet": "void slabinfo_show_stats(struct seq_file *m, struct kmem_cache *cachep)\n{\n#if STATS\n\t{\t\t\t/* node stats */\n\t\tunsigned long high = cachep->high_mark;\n\t\tunsigned long allocs = cachep->num_allocations;\n\t\tunsigned long grown = cachep->grown;\n\t\tunsigned long reaped = cachep->reaped;\n\t\tunsigned long errors = cachep->errors;\n\t\tunsigned long max_freeable = cachep->max_freeable;\n\t\tunsigned long node_allocs = cachep->node_allocs;\n\t\tunsigned long node_frees = cachep->node_frees;\n\t\tunsigned long overflows = cachep->node_overflow;\n\n\t\tseq_printf(m, \" : globalstat %7lu %6lu %5lu %4lu %4lu %4lu %4lu %4lu %4lu\",\n\t\t\t   allocs, high, grown,\n\t\t\t   reaped, errors, max_freeable, node_allocs,\n\t\t\t   node_frees, overflows);\n\t}\n\t/* cpu stats */\n\t{\n\t\tunsigned long allochit = atomic_read(&cachep->allochit);\n\t\tunsigned long allocmiss = atomic_read(&cachep->allocmiss);\n\t\tunsigned long freehit = atomic_read(&cachep->freehit);\n\t\tunsigned long freemiss = atomic_read(&cachep->freemiss);\n\n\t\tseq_printf(m, \" : cpustat %6lu %6lu %6lu %6lu\",\n\t\t\t   allochit, allocmiss, freehit, freemiss);\n\t}\n#endif\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define\tSTATS\t\t0",
            "#define\tSTATS\t\t1"
          ],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define\tSTATS\t\t0\n#define\tSTATS\t\t1\n\nstatic noinline struct;\n\nvoid slabinfo_show_stats(struct seq_file *m, struct kmem_cache *cachep)\n{\n#if STATS\n\t{\t\t\t/* node stats */\n\t\tunsigned long high = cachep->high_mark;\n\t\tunsigned long allocs = cachep->num_allocations;\n\t\tunsigned long grown = cachep->grown;\n\t\tunsigned long reaped = cachep->reaped;\n\t\tunsigned long errors = cachep->errors;\n\t\tunsigned long max_freeable = cachep->max_freeable;\n\t\tunsigned long node_allocs = cachep->node_allocs;\n\t\tunsigned long node_frees = cachep->node_frees;\n\t\tunsigned long overflows = cachep->node_overflow;\n\n\t\tseq_printf(m, \" : globalstat %7lu %6lu %5lu %4lu %4lu %4lu %4lu %4lu %4lu\",\n\t\t\t   allocs, high, grown,\n\t\t\t   reaped, errors, max_freeable, node_allocs,\n\t\t\t   node_frees, overflows);\n\t}\n\t/* cpu stats */\n\t{\n\t\tunsigned long allochit = atomic_read(&cachep->allochit);\n\t\tunsigned long allocmiss = atomic_read(&cachep->allocmiss);\n\t\tunsigned long freehit = atomic_read(&cachep->freehit);\n\t\tunsigned long freemiss = atomic_read(&cachep->freemiss);\n\n\t\tseq_printf(m, \" : cpustat %6lu %6lu %6lu %6lu\",\n\t\t\t   allochit, allocmiss, freehit, freemiss);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" : slabdata %6lu %6lu %6lu\"",
            "sinfo.active_slabs",
            "sinfo.num_slabs",
            "sinfo.shared_avail"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" : tunables %4u %4u %4u\"",
            "sinfo.limit",
            "sinfo.batchcount",
            "sinfo.shared"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%-17s %6lu %6lu %6u %4u %4d\"",
            "cache_name(s)",
            "sinfo.active_objs",
            "sinfo.num_objs",
            "s->size",
            "sinfo.objects_per_slab",
            "(1 << sinfo.cache_order)"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_name",
          "args": [
            "s"
          ],
          "line": 1344
        },
        "resolved": true,
        "details": {
          "function_name": "cache_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "319-322",
          "snippet": "static inline const char *cache_name(struct kmem_cache *s)\n{\n\treturn s->name;\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline const char *cache_name(struct kmem_cache *s)\n{\n\treturn s->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_accumulate_slabinfo",
          "args": [
            "s",
            "&sinfo"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_accumulate_slabinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "1313-1332",
          "snippet": "static void\nmemcg_accumulate_slabinfo(struct kmem_cache *s, struct slabinfo *info)\n{\n\tstruct kmem_cache *c;\n\tstruct slabinfo sinfo;\n\n\tif (!is_root_cache(s))\n\t\treturn;\n\n\tfor_each_memcg_cache(c, s) {\n\t\tmemset(&sinfo, 0, sizeof(sinfo));\n\t\tget_slabinfo(c, &sinfo);\n\n\t\tinfo->active_slabs += sinfo.active_slabs;\n\t\tinfo->num_slabs += sinfo.num_slabs;\n\t\tinfo->shared_avail += sinfo.shared_avail;\n\t\tinfo->active_objs += sinfo.active_objs;\n\t\tinfo->num_objs += sinfo.num_objs;\n\t}\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstatic void\nmemcg_accumulate_slabinfo(struct kmem_cache *s, struct slabinfo *info)\n{\n\tstruct kmem_cache *c;\n\tstruct slabinfo sinfo;\n\n\tif (!is_root_cache(s))\n\t\treturn;\n\n\tfor_each_memcg_cache(c, s) {\n\t\tmemset(&sinfo, 0, sizeof(sinfo));\n\t\tget_slabinfo(c, &sinfo);\n\n\t\tinfo->active_slabs += sinfo.active_slabs;\n\t\tinfo->num_slabs += sinfo.num_slabs;\n\t\tinfo->shared_avail += sinfo.shared_avail;\n\t\tinfo->active_objs += sinfo.active_objs;\n\t\tinfo->num_objs += sinfo.num_objs;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_slabinfo",
          "args": [
            "s",
            "&sinfo"
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "get_slabinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "4097-4132",
          "snippet": "void get_slabinfo(struct kmem_cache *cachep, struct slabinfo *sinfo)\n{\n\tunsigned long active_objs, num_objs, active_slabs;\n\tunsigned long total_slabs = 0, free_objs = 0, shared_avail = 0;\n\tunsigned long free_slabs = 0;\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tfor_each_kmem_cache_node(cachep, node, n) {\n\t\tcheck_irq_on();\n\t\tspin_lock_irq(&n->list_lock);\n\n\t\ttotal_slabs += n->total_slabs;\n\t\tfree_slabs += n->free_slabs;\n\t\tfree_objs += n->free_objects;\n\n\t\tif (n->shared)\n\t\t\tshared_avail += n->shared->avail;\n\n\t\tspin_unlock_irq(&n->list_lock);\n\t}\n\tnum_objs = total_slabs * cachep->num;\n\tactive_slabs = total_slabs - free_slabs;\n\tactive_objs = num_objs - free_objs;\n\n\tsinfo->active_objs = active_objs;\n\tsinfo->num_objs = num_objs;\n\tsinfo->active_slabs = active_slabs;\n\tsinfo->num_slabs = total_slabs;\n\tsinfo->shared_avail = shared_avail;\n\tsinfo->limit = cachep->limit;\n\tsinfo->batchcount = cachep->batchcount;\n\tsinfo->shared = cachep->shared;\n\tsinfo->objects_per_slab = cachep->num;\n\tsinfo->cache_order = cachep->gfporder;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid get_slabinfo(struct kmem_cache *cachep, struct slabinfo *sinfo)\n{\n\tunsigned long active_objs, num_objs, active_slabs;\n\tunsigned long total_slabs = 0, free_objs = 0, shared_avail = 0;\n\tunsigned long free_slabs = 0;\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tfor_each_kmem_cache_node(cachep, node, n) {\n\t\tcheck_irq_on();\n\t\tspin_lock_irq(&n->list_lock);\n\n\t\ttotal_slabs += n->total_slabs;\n\t\tfree_slabs += n->free_slabs;\n\t\tfree_objs += n->free_objects;\n\n\t\tif (n->shared)\n\t\t\tshared_avail += n->shared->avail;\n\n\t\tspin_unlock_irq(&n->list_lock);\n\t}\n\tnum_objs = total_slabs * cachep->num;\n\tactive_slabs = total_slabs - free_slabs;\n\tactive_objs = num_objs - free_objs;\n\n\tsinfo->active_objs = active_objs;\n\tsinfo->num_objs = num_objs;\n\tsinfo->active_slabs = active_slabs;\n\tsinfo->num_slabs = total_slabs;\n\tsinfo->shared_avail = shared_avail;\n\tsinfo->limit = cachep->limit;\n\tsinfo->batchcount = cachep->batchcount;\n\tsinfo->shared = cachep->shared;\n\tsinfo->objects_per_slab = cachep->num;\n\tsinfo->cache_order = cachep->gfporder;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&sinfo",
            "0",
            "sizeof(sinfo)"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstatic void cache_show(struct kmem_cache *s, struct seq_file *m)\n{\n\tstruct slabinfo sinfo;\n\n\tmemset(&sinfo, 0, sizeof(sinfo));\n\tget_slabinfo(s, &sinfo);\n\n\tmemcg_accumulate_slabinfo(s, &sinfo);\n\n\tseq_printf(m, \"%-17s %6lu %6lu %6u %4u %4d\",\n\t\t   cache_name(s), sinfo.active_objs, sinfo.num_objs, s->size,\n\t\t   sinfo.objects_per_slab, (1 << sinfo.cache_order));\n\n\tseq_printf(m, \" : tunables %4u %4u %4u\",\n\t\t   sinfo.limit, sinfo.batchcount, sinfo.shared);\n\tseq_printf(m, \" : slabdata %6lu %6lu %6lu\",\n\t\t   sinfo.active_slabs, sinfo.num_slabs, sinfo.shared_avail);\n\tslabinfo_show_stats(m, s);\n\tseq_putc(m, '\\n');\n}"
  },
  {
    "function_name": "memcg_accumulate_slabinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "1313-1332",
    "snippet": "static void\nmemcg_accumulate_slabinfo(struct kmem_cache *s, struct slabinfo *info)\n{\n\tstruct kmem_cache *c;\n\tstruct slabinfo sinfo;\n\n\tif (!is_root_cache(s))\n\t\treturn;\n\n\tfor_each_memcg_cache(c, s) {\n\t\tmemset(&sinfo, 0, sizeof(sinfo));\n\t\tget_slabinfo(c, &sinfo);\n\n\t\tinfo->active_slabs += sinfo.active_slabs;\n\t\tinfo->num_slabs += sinfo.num_slabs;\n\t\tinfo->shared_avail += sinfo.shared_avail;\n\t\tinfo->active_objs += sinfo.active_objs;\n\t\tinfo->num_objs += sinfo.num_objs;\n\t}\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_slabinfo",
          "args": [
            "c",
            "&sinfo"
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "get_slabinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "4097-4132",
          "snippet": "void get_slabinfo(struct kmem_cache *cachep, struct slabinfo *sinfo)\n{\n\tunsigned long active_objs, num_objs, active_slabs;\n\tunsigned long total_slabs = 0, free_objs = 0, shared_avail = 0;\n\tunsigned long free_slabs = 0;\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tfor_each_kmem_cache_node(cachep, node, n) {\n\t\tcheck_irq_on();\n\t\tspin_lock_irq(&n->list_lock);\n\n\t\ttotal_slabs += n->total_slabs;\n\t\tfree_slabs += n->free_slabs;\n\t\tfree_objs += n->free_objects;\n\n\t\tif (n->shared)\n\t\t\tshared_avail += n->shared->avail;\n\n\t\tspin_unlock_irq(&n->list_lock);\n\t}\n\tnum_objs = total_slabs * cachep->num;\n\tactive_slabs = total_slabs - free_slabs;\n\tactive_objs = num_objs - free_objs;\n\n\tsinfo->active_objs = active_objs;\n\tsinfo->num_objs = num_objs;\n\tsinfo->active_slabs = active_slabs;\n\tsinfo->num_slabs = total_slabs;\n\tsinfo->shared_avail = shared_avail;\n\tsinfo->limit = cachep->limit;\n\tsinfo->batchcount = cachep->batchcount;\n\tsinfo->shared = cachep->shared;\n\tsinfo->objects_per_slab = cachep->num;\n\tsinfo->cache_order = cachep->gfporder;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid get_slabinfo(struct kmem_cache *cachep, struct slabinfo *sinfo)\n{\n\tunsigned long active_objs, num_objs, active_slabs;\n\tunsigned long total_slabs = 0, free_objs = 0, shared_avail = 0;\n\tunsigned long free_slabs = 0;\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tfor_each_kmem_cache_node(cachep, node, n) {\n\t\tcheck_irq_on();\n\t\tspin_lock_irq(&n->list_lock);\n\n\t\ttotal_slabs += n->total_slabs;\n\t\tfree_slabs += n->free_slabs;\n\t\tfree_objs += n->free_objects;\n\n\t\tif (n->shared)\n\t\t\tshared_avail += n->shared->avail;\n\n\t\tspin_unlock_irq(&n->list_lock);\n\t}\n\tnum_objs = total_slabs * cachep->num;\n\tactive_slabs = total_slabs - free_slabs;\n\tactive_objs = num_objs - free_objs;\n\n\tsinfo->active_objs = active_objs;\n\tsinfo->num_objs = num_objs;\n\tsinfo->active_slabs = active_slabs;\n\tsinfo->num_slabs = total_slabs;\n\tsinfo->shared_avail = shared_avail;\n\tsinfo->limit = cachep->limit;\n\tsinfo->batchcount = cachep->batchcount;\n\tsinfo->shared = cachep->shared;\n\tsinfo->objects_per_slab = cachep->num;\n\tsinfo->cache_order = cachep->gfporder;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&sinfo",
            "0",
            "sizeof(sinfo)"
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_memcg_cache",
          "args": [
            "c",
            "s"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_root_cache",
          "args": [
            "s"
          ],
          "line": 1319
        },
        "resolved": true,
        "details": {
          "function_name": "is_root_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "308-311",
          "snippet": "static inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn true;\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstatic void\nmemcg_accumulate_slabinfo(struct kmem_cache *s, struct slabinfo *info)\n{\n\tstruct kmem_cache *c;\n\tstruct slabinfo sinfo;\n\n\tif (!is_root_cache(s))\n\t\treturn;\n\n\tfor_each_memcg_cache(c, s) {\n\t\tmemset(&sinfo, 0, sizeof(sinfo));\n\t\tget_slabinfo(c, &sinfo);\n\n\t\tinfo->active_slabs += sinfo.active_slabs;\n\t\tinfo->num_slabs += sinfo.num_slabs;\n\t\tinfo->shared_avail += sinfo.shared_avail;\n\t\tinfo->active_objs += sinfo.active_objs;\n\t\tinfo->num_objs += sinfo.num_objs;\n\t}\n}"
  },
  {
    "function_name": "slab_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "1308-1311",
    "snippet": "void slab_stop(struct seq_file *m, void *p)\n{\n\tmutex_unlock(&slab_mutex);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&slab_mutex"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nvoid slab_stop(struct seq_file *m, void *p)\n{\n\tmutex_unlock(&slab_mutex);\n}"
  },
  {
    "function_name": "slab_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "1303-1306",
    "snippet": "void *slab_next(struct seq_file *m, void *p, loff_t *pos)\n{\n\treturn seq_list_next(p, &slab_root_caches, pos);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_list_next",
          "args": [
            "p",
            "&slab_root_caches",
            "pos"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nvoid *slab_next(struct seq_file *m, void *p, loff_t *pos)\n{\n\treturn seq_list_next(p, &slab_root_caches, pos);\n}"
  },
  {
    "function_name": "slab_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "1297-1301",
    "snippet": "void *slab_start(struct seq_file *m, loff_t *pos)\n{\n\tmutex_lock(&slab_mutex);\n\treturn seq_list_start(&slab_root_caches, *pos);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_list_start",
          "args": [
            "&slab_root_caches",
            "*pos"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&slab_mutex"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nvoid *slab_start(struct seq_file *m, loff_t *pos)\n{\n\tmutex_lock(&slab_mutex);\n\treturn seq_list_start(&slab_root_caches, *pos);\n}"
  },
  {
    "function_name": "print_slabinfo_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "1276-1295",
    "snippet": "static void print_slabinfo_header(struct seq_file *m)\n{\n\t/*\n\t * Output format version, so at least we can change it\n\t * without _too_ many complaints.\n\t */\n#ifdef CONFIG_DEBUG_SLAB\n\tseq_puts(m, \"slabinfo - version: 2.1 (statistics)\\n\");\n#else\n\tseq_puts(m, \"slabinfo - version: 2.1\\n\");\n#endif\n\tseq_puts(m, \"# name            <active_objs> <num_objs> <objsize> <objperslab> <pagesperslab>\");\n\tseq_puts(m, \" : tunables <limit> <batchcount> <sharedfactor>\");\n\tseq_puts(m, \" : slabdata <active_slabs> <num_slabs> <sharedavail>\");\n#ifdef CONFIG_DEBUG_SLAB\n\tseq_puts(m, \" : globalstat <listallocs> <maxobjs> <grown> <reaped> <error> <maxfreeable> <nodeallocs> <remotefrees> <alienoverflow>\");\n\tseq_puts(m, \" : cpustat <allochit> <allocmiss> <freehit> <freemiss>\");\n#endif\n\tseq_putc(m, '\\n');\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\" : cpustat <allochit> <allocmiss> <freehit> <freemiss>\""
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\" : globalstat <listallocs> <maxobjs> <grown> <reaped> <error> <maxfreeable> <nodeallocs> <remotefrees> <alienoverflow>\""
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\" : slabdata <active_slabs> <num_slabs> <sharedavail>\""
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\" : tunables <limit> <batchcount> <sharedfactor>\""
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"# name            <active_objs> <num_objs> <objsize> <objperslab> <pagesperslab>\""
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"slabinfo - version: 2.1\\n\""
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"slabinfo - version: 2.1 (statistics)\\n\""
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstatic void print_slabinfo_header(struct seq_file *m)\n{\n\t/*\n\t * Output format version, so at least we can change it\n\t * without _too_ many complaints.\n\t */\n#ifdef CONFIG_DEBUG_SLAB\n\tseq_puts(m, \"slabinfo - version: 2.1 (statistics)\\n\");\n#else\n\tseq_puts(m, \"slabinfo - version: 2.1\\n\");\n#endif\n\tseq_puts(m, \"# name            <active_objs> <num_objs> <objsize> <objperslab> <pagesperslab>\");\n\tseq_puts(m, \" : tunables <limit> <batchcount> <sharedfactor>\");\n\tseq_puts(m, \" : slabdata <active_slabs> <num_slabs> <sharedavail>\");\n#ifdef CONFIG_DEBUG_SLAB\n\tseq_puts(m, \" : globalstat <listallocs> <maxobjs> <grown> <reaped> <error> <maxfreeable> <nodeallocs> <remotefrees> <alienoverflow>\");\n\tseq_puts(m, \" : cpustat <allochit> <allocmiss> <freehit> <freemiss>\");\n#endif\n\tseq_putc(m, '\\n');\n}"
  },
  {
    "function_name": "cache_random_seq_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "1262-1266",
    "snippet": "void cache_random_seq_destroy(struct kmem_cache *cachep)\n{\n\tkfree(cachep->random_seq);\n\tcachep->random_seq = NULL;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cachep->random_seq"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nvoid cache_random_seq_destroy(struct kmem_cache *cachep)\n{\n\tkfree(cachep->random_seq);\n\tcachep->random_seq = NULL;\n}"
  },
  {
    "function_name": "cache_random_seq_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "1242-1259",
    "snippet": "int cache_random_seq_create(struct kmem_cache *cachep, unsigned int count,\n\t\t\t\t    gfp_t gfp)\n{\n\tstruct rnd_state state;\n\n\tif (count < 2 || cachep->random_seq)\n\t\treturn 0;\n\n\tcachep->random_seq = kcalloc(count, sizeof(unsigned int), gfp);\n\tif (!cachep->random_seq)\n\t\treturn -ENOMEM;\n\n\t/* Get best entropy at this stage of boot */\n\tprandom_seed_state(&state, get_random_long());\n\n\tfreelist_randomize(&state, cachep->random_seq, count);\n\treturn 0;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "freelist_randomize",
          "args": [
            "&state",
            "cachep->random_seq",
            "count"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "freelist_randomize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "1224-1239",
          "snippet": "static void freelist_randomize(struct rnd_state *state, unsigned int *list,\n\t\t\t       unsigned int count)\n{\n\tunsigned int rand;\n\tunsigned int i;\n\n\tfor (i = 0; i < count; i++)\n\t\tlist[i] = i;\n\n\t/* Fisher-Yates shuffle */\n\tfor (i = count - 1; i > 0; i--) {\n\t\trand = prandom_u32_state(state);\n\t\trand %= (i + 1);\n\t\tswap(list[i], list[rand]);\n\t}\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstatic void freelist_randomize(struct rnd_state *state, unsigned int *list,\n\t\t\t       unsigned int count)\n{\n\tunsigned int rand;\n\tunsigned int i;\n\n\tfor (i = 0; i < count; i++)\n\t\tlist[i] = i;\n\n\t/* Fisher-Yates shuffle */\n\tfor (i = count - 1; i > 0; i--) {\n\t\trand = prandom_u32_state(state);\n\t\trand %= (i + 1);\n\t\tswap(list[i], list[rand]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "prandom_seed_state",
          "args": [
            "&state",
            "get_random_long()"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_random_long",
          "args": [],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "count",
            "sizeof(unsigned int)",
            "gfp"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nint cache_random_seq_create(struct kmem_cache *cachep, unsigned int count,\n\t\t\t\t    gfp_t gfp)\n{\n\tstruct rnd_state state;\n\n\tif (count < 2 || cachep->random_seq)\n\t\treturn 0;\n\n\tcachep->random_seq = kcalloc(count, sizeof(unsigned int), gfp);\n\tif (!cachep->random_seq)\n\t\treturn -ENOMEM;\n\n\t/* Get best entropy at this stage of boot */\n\tprandom_seed_state(&state, get_random_long());\n\n\tfreelist_randomize(&state, cachep->random_seq, count);\n\treturn 0;\n}"
  },
  {
    "function_name": "freelist_randomize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "1224-1239",
    "snippet": "static void freelist_randomize(struct rnd_state *state, unsigned int *list,\n\t\t\t       unsigned int count)\n{\n\tunsigned int rand;\n\tunsigned int i;\n\n\tfor (i = 0; i < count; i++)\n\t\tlist[i] = i;\n\n\t/* Fisher-Yates shuffle */\n\tfor (i = count - 1; i > 0; i--) {\n\t\trand = prandom_u32_state(state);\n\t\trand %= (i + 1);\n\t\tswap(list[i], list[rand]);\n\t}\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "swap",
          "args": [
            "list[i]",
            "list[rand]"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "me_swapcache_clean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "765-773",
          "snippet": "static int me_swapcache_clean(struct page *p, unsigned long pfn)\n{\n\tdelete_from_swap_cache(p);\n\n\tif (!delete_from_lru_cache(p))\n\t\treturn MF_RECOVERED;\n\telse\n\t\treturn MF_FAILED;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int me_swapcache_clean(struct page *p, unsigned long pfn)\n{\n\tdelete_from_swap_cache(p);\n\n\tif (!delete_from_lru_cache(p))\n\t\treturn MF_RECOVERED;\n\telse\n\t\treturn MF_FAILED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prandom_u32_state",
          "args": [
            "state"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstatic void freelist_randomize(struct rnd_state *state, unsigned int *list,\n\t\t\t       unsigned int count)\n{\n\tunsigned int rand;\n\tunsigned int i;\n\n\tfor (i = 0; i < count; i++)\n\t\tlist[i] = i;\n\n\t/* Fisher-Yates shuffle */\n\tfor (i = count - 1; i > 0; i--) {\n\t\trand = prandom_u32_state(state);\n\t\trand %= (i + 1);\n\t\tswap(list[i], list[rand]);\n\t}\n}"
  },
  {
    "function_name": "kmalloc_order_trace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "1213-1218",
    "snippet": "void *kmalloc_order_trace(size_t size, gfp_t flags, unsigned int order)\n{\n\tvoid *ret = kmalloc_order(size, flags, order);\n\ttrace_kmalloc(_RET_IP_, ret, size, PAGE_SIZE << order, flags);\n\treturn ret;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kmalloc",
          "args": [
            "_RET_IP_",
            "ret",
            "size",
            "PAGE_SIZE << order",
            "flags"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_order",
          "args": [
            "size",
            "flags",
            "order"
          ],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "kmalloc_order_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "1213-1218",
          "snippet": "void *kmalloc_order_trace(size_t size, gfp_t flags, unsigned int order)\n{\n\tvoid *ret = kmalloc_order(size, flags, order);\n\ttrace_kmalloc(_RET_IP_, ret, size, PAGE_SIZE << order, flags);\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nvoid *kmalloc_order_trace(size_t size, gfp_t flags, unsigned int order)\n{\n\tvoid *ret = kmalloc_order(size, flags, order);\n\ttrace_kmalloc(_RET_IP_, ret, size, PAGE_SIZE << order, flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "kmalloc_order",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "1198-1209",
    "snippet": "void *kmalloc_order(size_t size, gfp_t flags, unsigned int order)\n{\n\tvoid *ret;\n\tstruct page *page;\n\n\tflags |= __GFP_COMP;\n\tpage = alloc_pages(flags, order);\n\tret = page ? page_address(page) : NULL;\n\tkmemleak_alloc(ret, size, 1, flags);\n\tkasan_kmalloc_large(ret, size, flags);\n\treturn ret;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kasan_kmalloc_large",
          "args": [
            "ret",
            "size",
            "flags"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_kmalloc_large",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "557-577",
          "snippet": "void kasan_kmalloc_large(const void *ptr, size_t size, gfp_t flags)\n{\n\tstruct page *page;\n\tunsigned long redzone_start;\n\tunsigned long redzone_end;\n\n\tif (gfpflags_allow_blocking(flags))\n\t\tquarantine_reduce();\n\n\tif (unlikely(ptr == NULL))\n\t\treturn;\n\n\tpage = virt_to_page(ptr);\n\tredzone_start = round_up((unsigned long)(ptr + size),\n\t\t\t\tKASAN_SHADOW_SCALE_SIZE);\n\tredzone_end = (unsigned long)ptr + (PAGE_SIZE << compound_order(page));\n\n\tkasan_unpoison_shadow(ptr, size);\n\tkasan_poison_shadow((void *)redzone_start, redzone_end - redzone_start,\n\t\tKASAN_PAGE_REDZONE);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid kasan_kmalloc_large(const void *ptr, size_t size, gfp_t flags)\n{\n\tstruct page *page;\n\tunsigned long redzone_start;\n\tunsigned long redzone_end;\n\n\tif (gfpflags_allow_blocking(flags))\n\t\tquarantine_reduce();\n\n\tif (unlikely(ptr == NULL))\n\t\treturn;\n\n\tpage = virt_to_page(ptr);\n\tredzone_start = round_up((unsigned long)(ptr + size),\n\t\t\t\tKASAN_SHADOW_SCALE_SIZE);\n\tredzone_end = (unsigned long)ptr + (PAGE_SIZE << compound_order(page));\n\n\tkasan_unpoison_shadow(ptr, size);\n\tkasan_poison_shadow((void *)redzone_start, redzone_end - redzone_start,\n\t\tKASAN_PAGE_REDZONE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemleak_alloc",
          "args": [
            "ret",
            "size",
            "1",
            "flags"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_alloc_phys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1220-1225",
          "snippet": "void __ref kmemleak_alloc_phys(phys_addr_t phys, size_t size, int min_count,\n\t\t\t       gfp_t gfp)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_alloc(__va(phys), size, min_count, gfp);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nvoid __ref kmemleak_alloc_phys(phys_addr_t phys, size_t size, int min_count,\n\t\t\t       gfp_t gfp)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_alloc(__va(phys), size, min_count, gfp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "page_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "409-434",
          "snippet": "void *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_pages",
          "args": [
            "flags",
            "order"
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_pages_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4594-4601",
          "snippet": "void *alloc_pages_exact(size_t size, gfp_t gfp_mask)\n{\n\tunsigned int order = get_order(size);\n\tunsigned long addr;\n\n\taddr = __get_free_pages(gfp_mask, order);\n\treturn make_alloc_exact(addr, order, size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\n\nvoid *alloc_pages_exact(size_t size, gfp_t gfp_mask)\n{\n\tunsigned int order = get_order(size);\n\tunsigned long addr;\n\n\taddr = __get_free_pages(gfp_mask, order);\n\treturn make_alloc_exact(addr, order, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nvoid *kmalloc_order(size_t size, gfp_t flags, unsigned int order)\n{\n\tvoid *ret;\n\tstruct page *page;\n\n\tflags |= __GFP_COMP;\n\tpage = alloc_pages(flags, order);\n\tret = page ? page_address(page) : NULL;\n\tkmemleak_alloc(ret, size, 1, flags);\n\tkasan_kmalloc_large(ret, size, flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "create_kmalloc_caches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "1150-1190",
    "snippet": "void __init create_kmalloc_caches(slab_flags_t flags)\n{\n\tint i, type;\n\n\tfor (type = KMALLOC_NORMAL; type <= KMALLOC_RECLAIM; type++) {\n\t\tfor (i = KMALLOC_SHIFT_LOW; i <= KMALLOC_SHIFT_HIGH; i++) {\n\t\t\tif (!kmalloc_caches[type][i])\n\t\t\t\tnew_kmalloc_cache(i, type, flags);\n\n\t\t\t/*\n\t\t\t * Caches that are not of the two-to-the-power-of size.\n\t\t\t * These have to be created immediately after the\n\t\t\t * earlier power of two caches\n\t\t\t */\n\t\t\tif (KMALLOC_MIN_SIZE <= 32 && i == 6 &&\n\t\t\t\t\t!kmalloc_caches[type][1])\n\t\t\t\tnew_kmalloc_cache(1, type, flags);\n\t\t\tif (KMALLOC_MIN_SIZE <= 64 && i == 7 &&\n\t\t\t\t\t!kmalloc_caches[type][2])\n\t\t\t\tnew_kmalloc_cache(2, type, flags);\n\t\t}\n\t}\n\n\t/* Kmalloc array is now usable */\n\tslab_state = UP;\n\n#ifdef CONFIG_ZONE_DMA\n\tfor (i = 0; i <= KMALLOC_SHIFT_HIGH; i++) {\n\t\tstruct kmem_cache *s = kmalloc_caches[KMALLOC_NORMAL][i];\n\n\t\tif (s) {\n\t\t\tunsigned int size = kmalloc_size(i);\n\t\t\tconst char *n = kmalloc_cache_name(\"dma-kmalloc\", size);\n\n\t\t\tBUG_ON(!n);\n\t\t\tkmalloc_caches[KMALLOC_DMA][i] = create_kmalloc_cache(\n\t\t\t\tn, size, SLAB_CACHE_DMA | flags, 0, 0);\n\t\t}\n\t}\n#endif\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum slab_state slab_state;",
      "struct kmem_cache *kmem_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_kmalloc_cache",
          "args": [
            "n",
            "size",
            "SLAB_CACHE_DMA | flags",
            "0",
            "0"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "create_kmalloc_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "960-974",
          "snippet": "struct kmem_cache *__init create_kmalloc_cache(const char *name,\n\t\tunsigned int size, slab_flags_t flags,\n\t\tunsigned int useroffset, unsigned int usersize)\n{\n\tstruct kmem_cache *s = kmem_cache_zalloc(kmem_cache, GFP_NOWAIT);\n\n\tif (!s)\n\t\tpanic(\"Out of memory when creating slab %s\\n\", name);\n\n\tcreate_boot_cache(s, name, size, flags, useroffset, usersize);\n\tlist_add(&s->list, &slab_caches);\n\tmemcg_link_cache(s);\n\ts->refcount = 1;\n\treturn s;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstruct kmem_cache *__init create_kmalloc_cache(const char *name,\n\t\tunsigned int size, slab_flags_t flags,\n\t\tunsigned int useroffset, unsigned int usersize)\n{\n\tstruct kmem_cache *s = kmem_cache_zalloc(kmem_cache, GFP_NOWAIT);\n\n\tif (!s)\n\t\tpanic(\"Out of memory when creating slab %s\\n\", name);\n\n\tcreate_boot_cache(s, name, size, flags, useroffset, usersize);\n\tlist_add(&s->list, &slab_caches);\n\tmemcg_link_cache(s);\n\ts->refcount = 1;\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!n"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_cache_name",
          "args": [
            "\"dma-kmalloc\"",
            "size"
          ],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "kmalloc_cache_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "1111-1124",
          "snippet": "static const char *\nkmalloc_cache_name(const char *prefix, unsigned int size)\n{\n\n\tstatic const char units[3] = \"\\0kM\";\n\tint idx = 0;\n\n\twhile (size >= 1024 && (size % 1024 == 0)) {\n\t\tsize /= 1024;\n\t\tidx++;\n\t}\n\n\treturn kasprintf(GFP_NOWAIT, \"%s-%u%c\", prefix, size, units[idx]);\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstatic const char *\nkmalloc_cache_name(const char *prefix, unsigned int size)\n{\n\n\tstatic const char units[3] = \"\\0kM\";\n\tint idx = 0;\n\n\twhile (size >= 1024 && (size % 1024 == 0)) {\n\t\tsize /= 1024;\n\t\tidx++;\n\t}\n\n\treturn kasprintf(GFP_NOWAIT, \"%s-%u%c\", prefix, size, units[idx]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc_size",
          "args": [
            "i"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_kmalloc_cache",
          "args": [
            "2",
            "type",
            "flags"
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "new_kmalloc_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "1126-1143",
          "snippet": "static void __init\nnew_kmalloc_cache(int idx, int type, slab_flags_t flags)\n{\n\tconst char *name;\n\n\tif (type == KMALLOC_RECLAIM) {\n\t\tflags |= SLAB_RECLAIM_ACCOUNT;\n\t\tname = kmalloc_cache_name(\"kmalloc-rcl\",\n\t\t\t\t\t\tkmalloc_info[idx].size);\n\t\tBUG_ON(!name);\n\t} else {\n\t\tname = kmalloc_info[idx].name;\n\t}\n\n\tkmalloc_caches[type][idx] = create_kmalloc_cache(name,\n\t\t\t\t\tkmalloc_info[idx].size, flags, 0,\n\t\t\t\t\tkmalloc_info[idx].size);\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstatic void __init\nnew_kmalloc_cache(int idx, int type, slab_flags_t flags)\n{\n\tconst char *name;\n\n\tif (type == KMALLOC_RECLAIM) {\n\t\tflags |= SLAB_RECLAIM_ACCOUNT;\n\t\tname = kmalloc_cache_name(\"kmalloc-rcl\",\n\t\t\t\t\t\tkmalloc_info[idx].size);\n\t\tBUG_ON(!name);\n\t} else {\n\t\tname = kmalloc_info[idx].name;\n\t}\n\n\tkmalloc_caches[type][idx] = create_kmalloc_cache(name,\n\t\t\t\t\tkmalloc_info[idx].size, flags, 0,\n\t\t\t\t\tkmalloc_info[idx].size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nenum slab_state slab_state;\nstruct kmem_cache *kmem_cache;\n\nvoid __init create_kmalloc_caches(slab_flags_t flags)\n{\n\tint i, type;\n\n\tfor (type = KMALLOC_NORMAL; type <= KMALLOC_RECLAIM; type++) {\n\t\tfor (i = KMALLOC_SHIFT_LOW; i <= KMALLOC_SHIFT_HIGH; i++) {\n\t\t\tif (!kmalloc_caches[type][i])\n\t\t\t\tnew_kmalloc_cache(i, type, flags);\n\n\t\t\t/*\n\t\t\t * Caches that are not of the two-to-the-power-of size.\n\t\t\t * These have to be created immediately after the\n\t\t\t * earlier power of two caches\n\t\t\t */\n\t\t\tif (KMALLOC_MIN_SIZE <= 32 && i == 6 &&\n\t\t\t\t\t!kmalloc_caches[type][1])\n\t\t\t\tnew_kmalloc_cache(1, type, flags);\n\t\t\tif (KMALLOC_MIN_SIZE <= 64 && i == 7 &&\n\t\t\t\t\t!kmalloc_caches[type][2])\n\t\t\t\tnew_kmalloc_cache(2, type, flags);\n\t\t}\n\t}\n\n\t/* Kmalloc array is now usable */\n\tslab_state = UP;\n\n#ifdef CONFIG_ZONE_DMA\n\tfor (i = 0; i <= KMALLOC_SHIFT_HIGH; i++) {\n\t\tstruct kmem_cache *s = kmalloc_caches[KMALLOC_NORMAL][i];\n\n\t\tif (s) {\n\t\t\tunsigned int size = kmalloc_size(i);\n\t\t\tconst char *n = kmalloc_cache_name(\"dma-kmalloc\", size);\n\n\t\t\tBUG_ON(!n);\n\t\t\tkmalloc_caches[KMALLOC_DMA][i] = create_kmalloc_cache(\n\t\t\t\tn, size, SLAB_CACHE_DMA | flags, 0, 0);\n\t\t}\n\t}\n#endif\n}"
  },
  {
    "function_name": "new_kmalloc_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "1126-1143",
    "snippet": "static void __init\nnew_kmalloc_cache(int idx, int type, slab_flags_t flags)\n{\n\tconst char *name;\n\n\tif (type == KMALLOC_RECLAIM) {\n\t\tflags |= SLAB_RECLAIM_ACCOUNT;\n\t\tname = kmalloc_cache_name(\"kmalloc-rcl\",\n\t\t\t\t\t\tkmalloc_info[idx].size);\n\t\tBUG_ON(!name);\n\t} else {\n\t\tname = kmalloc_info[idx].name;\n\t}\n\n\tkmalloc_caches[type][idx] = create_kmalloc_cache(name,\n\t\t\t\t\tkmalloc_info[idx].size, flags, 0,\n\t\t\t\t\tkmalloc_info[idx].size);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_kmalloc_cache",
          "args": [
            "name",
            "kmalloc_info[idx].size",
            "flags",
            "0",
            "kmalloc_info[idx].size"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "create_kmalloc_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "960-974",
          "snippet": "struct kmem_cache *__init create_kmalloc_cache(const char *name,\n\t\tunsigned int size, slab_flags_t flags,\n\t\tunsigned int useroffset, unsigned int usersize)\n{\n\tstruct kmem_cache *s = kmem_cache_zalloc(kmem_cache, GFP_NOWAIT);\n\n\tif (!s)\n\t\tpanic(\"Out of memory when creating slab %s\\n\", name);\n\n\tcreate_boot_cache(s, name, size, flags, useroffset, usersize);\n\tlist_add(&s->list, &slab_caches);\n\tmemcg_link_cache(s);\n\ts->refcount = 1;\n\treturn s;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstruct kmem_cache *__init create_kmalloc_cache(const char *name,\n\t\tunsigned int size, slab_flags_t flags,\n\t\tunsigned int useroffset, unsigned int usersize)\n{\n\tstruct kmem_cache *s = kmem_cache_zalloc(kmem_cache, GFP_NOWAIT);\n\n\tif (!s)\n\t\tpanic(\"Out of memory when creating slab %s\\n\", name);\n\n\tcreate_boot_cache(s, name, size, flags, useroffset, usersize);\n\tlist_add(&s->list, &slab_caches);\n\tmemcg_link_cache(s);\n\ts->refcount = 1;\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!name"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_cache_name",
          "args": [
            "\"kmalloc-rcl\"",
            "kmalloc_info[idx].size"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "kmalloc_cache_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "1111-1124",
          "snippet": "static const char *\nkmalloc_cache_name(const char *prefix, unsigned int size)\n{\n\n\tstatic const char units[3] = \"\\0kM\";\n\tint idx = 0;\n\n\twhile (size >= 1024 && (size % 1024 == 0)) {\n\t\tsize /= 1024;\n\t\tidx++;\n\t}\n\n\treturn kasprintf(GFP_NOWAIT, \"%s-%u%c\", prefix, size, units[idx]);\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstatic const char *\nkmalloc_cache_name(const char *prefix, unsigned int size)\n{\n\n\tstatic const char units[3] = \"\\0kM\";\n\tint idx = 0;\n\n\twhile (size >= 1024 && (size % 1024 == 0)) {\n\t\tsize /= 1024;\n\t\tidx++;\n\t}\n\n\treturn kasprintf(GFP_NOWAIT, \"%s-%u%c\", prefix, size, units[idx]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstatic void __init\nnew_kmalloc_cache(int idx, int type, slab_flags_t flags)\n{\n\tconst char *name;\n\n\tif (type == KMALLOC_RECLAIM) {\n\t\tflags |= SLAB_RECLAIM_ACCOUNT;\n\t\tname = kmalloc_cache_name(\"kmalloc-rcl\",\n\t\t\t\t\t\tkmalloc_info[idx].size);\n\t\tBUG_ON(!name);\n\t} else {\n\t\tname = kmalloc_info[idx].name;\n\t}\n\n\tkmalloc_caches[type][idx] = create_kmalloc_cache(name,\n\t\t\t\t\tkmalloc_info[idx].size, flags, 0,\n\t\t\t\t\tkmalloc_info[idx].size);\n}"
  },
  {
    "function_name": "kmalloc_cache_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "1111-1124",
    "snippet": "static const char *\nkmalloc_cache_name(const char *prefix, unsigned int size)\n{\n\n\tstatic const char units[3] = \"\\0kM\";\n\tint idx = 0;\n\n\twhile (size >= 1024 && (size % 1024 == 0)) {\n\t\tsize /= 1024;\n\t\tidx++;\n\t}\n\n\treturn kasprintf(GFP_NOWAIT, \"%s-%u%c\", prefix, size, units[idx]);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kasprintf",
          "args": [
            "GFP_NOWAIT",
            "\"%s-%u%c\"",
            "prefix",
            "size",
            "units[idx]"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstatic const char *\nkmalloc_cache_name(const char *prefix, unsigned int size)\n{\n\n\tstatic const char units[3] = \"\\0kM\";\n\tint idx = 0;\n\n\twhile (size >= 1024 && (size % 1024 == 0)) {\n\t\tsize /= 1024;\n\t\tidx++;\n\t}\n\n\treturn kasprintf(GFP_NOWAIT, \"%s-%u%c\", prefix, size, units[idx]);\n}"
  },
  {
    "function_name": "setup_kmalloc_cache_index_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "1075-1109",
    "snippet": "void __init setup_kmalloc_cache_index_table(void)\n{\n\tunsigned int i;\n\n\tBUILD_BUG_ON(KMALLOC_MIN_SIZE > 256 ||\n\t\t(KMALLOC_MIN_SIZE & (KMALLOC_MIN_SIZE - 1)));\n\n\tfor (i = 8; i < KMALLOC_MIN_SIZE; i += 8) {\n\t\tunsigned int elem = size_index_elem(i);\n\n\t\tif (elem >= ARRAY_SIZE(size_index))\n\t\t\tbreak;\n\t\tsize_index[elem] = KMALLOC_SHIFT_LOW;\n\t}\n\n\tif (KMALLOC_MIN_SIZE >= 64) {\n\t\t/*\n\t\t * The 96 byte size cache is not used if the alignment\n\t\t * is 64 byte.\n\t\t */\n\t\tfor (i = 64 + 8; i <= 96; i += 8)\n\t\t\tsize_index[size_index_elem(i)] = 7;\n\n\t}\n\n\tif (KMALLOC_MIN_SIZE >= 128) {\n\t\t/*\n\t\t * The 192 byte sized cache is not used if the alignment\n\t\t * is 128 byte. Redirect kmalloc to use the 256 byte cache\n\t\t * instead.\n\t\t */\n\t\tfor (i = 128 + 8; i <= 192; i += 8)\n\t\t\tsize_index[size_index_elem(i)] = 8;\n\t}\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "size_index_elem",
          "args": [
            "i"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "size_index_elem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "1013-1016",
          "snippet": "static inline unsigned int size_index_elem(unsigned int bytes)\n{\n\treturn (bytes - 1) / 8;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int size_index_elem(unsigned int bytes)\n{\n\treturn (bytes - 1) / 8;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "size_index"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "KMALLOC_MIN_SIZE > 256 ||\n\t\t(KMALLOC_MIN_SIZE & (KMALLOC_MIN_SIZE - 1))"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nvoid __init setup_kmalloc_cache_index_table(void)\n{\n\tunsigned int i;\n\n\tBUILD_BUG_ON(KMALLOC_MIN_SIZE > 256 ||\n\t\t(KMALLOC_MIN_SIZE & (KMALLOC_MIN_SIZE - 1)));\n\n\tfor (i = 8; i < KMALLOC_MIN_SIZE; i += 8) {\n\t\tunsigned int elem = size_index_elem(i);\n\n\t\tif (elem >= ARRAY_SIZE(size_index))\n\t\t\tbreak;\n\t\tsize_index[elem] = KMALLOC_SHIFT_LOW;\n\t}\n\n\tif (KMALLOC_MIN_SIZE >= 64) {\n\t\t/*\n\t\t * The 96 byte size cache is not used if the alignment\n\t\t * is 64 byte.\n\t\t */\n\t\tfor (i = 64 + 8; i <= 96; i += 8)\n\t\t\tsize_index[size_index_elem(i)] = 7;\n\n\t}\n\n\tif (KMALLOC_MIN_SIZE >= 128) {\n\t\t/*\n\t\t * The 192 byte sized cache is not used if the alignment\n\t\t * is 128 byte. Redirect kmalloc to use the 256 byte cache\n\t\t * instead.\n\t\t */\n\t\tfor (i = 128 + 8; i <= 192; i += 8)\n\t\t\tsize_index[size_index_elem(i)] = 8;\n\t}\n}"
  },
  {
    "function_name": "kmalloc_slab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "1022-1040",
    "snippet": "struct kmem_cache *kmalloc_slab(size_t size, gfp_t flags)\n{\n\tunsigned int index;\n\n\tif (size <= 192) {\n\t\tif (!size)\n\t\t\treturn ZERO_SIZE_PTR;\n\n\t\tindex = size_index[size_index_elem(size)];\n\t} else {\n\t\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE)) {\n\t\t\tWARN_ON(1);\n\t\t\treturn NULL;\n\t\t}\n\t\tindex = fls(size - 1);\n\t}\n\n\treturn kmalloc_caches[kmalloc_type(flags)][index];\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmalloc_type",
          "args": [
            "flags"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fls",
          "args": [
            "size - 1"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "size > KMALLOC_MAX_CACHE_SIZE"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "size_index_elem",
          "args": [
            "size"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "size_index_elem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "1013-1016",
          "snippet": "static inline unsigned int size_index_elem(unsigned int bytes)\n{\n\treturn (bytes - 1) / 8;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int size_index_elem(unsigned int bytes)\n{\n\treturn (bytes - 1) / 8;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstruct kmem_cache *kmalloc_slab(size_t size, gfp_t flags)\n{\n\tunsigned int index;\n\n\tif (size <= 192) {\n\t\tif (!size)\n\t\t\treturn ZERO_SIZE_PTR;\n\n\t\tindex = size_index[size_index_elem(size)];\n\t} else {\n\t\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE)) {\n\t\t\tWARN_ON(1);\n\t\t\treturn NULL;\n\t\t}\n\t\tindex = fls(size - 1);\n\t}\n\n\treturn kmalloc_caches[kmalloc_type(flags)][index];\n}"
  },
  {
    "function_name": "size_index_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "1013-1016",
    "snippet": "static inline unsigned int size_index_elem(unsigned int bytes)\n{\n\treturn (bytes - 1) / 8;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int size_index_elem(unsigned int bytes)\n{\n\treturn (bytes - 1) / 8;\n}"
  },
  {
    "function_name": "create_kmalloc_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "960-974",
    "snippet": "struct kmem_cache *__init create_kmalloc_cache(const char *name,\n\t\tunsigned int size, slab_flags_t flags,\n\t\tunsigned int useroffset, unsigned int usersize)\n{\n\tstruct kmem_cache *s = kmem_cache_zalloc(kmem_cache, GFP_NOWAIT);\n\n\tif (!s)\n\t\tpanic(\"Out of memory when creating slab %s\\n\", name);\n\n\tcreate_boot_cache(s, name, size, flags, useroffset, usersize);\n\tlist_add(&s->list, &slab_caches);\n\tmemcg_link_cache(s);\n\ts->refcount = 1;\n\treturn s;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcg_link_cache",
          "args": [
            "s"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_link_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "224-234",
          "snippet": "void memcg_link_cache(struct kmem_cache *s)\n{\n\tif (is_root_cache(s)) {\n\t\tlist_add(&s->root_caches_node, &slab_root_caches);\n\t} else {\n\t\tlist_add(&s->memcg_params.children_node,\n\t\t\t &s->memcg_params.root_cache->memcg_params.children);\n\t\tlist_add(&s->memcg_params.kmem_caches_node,\n\t\t\t &s->memcg_params.memcg->kmem_caches);\n\t}\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nvoid memcg_link_cache(struct kmem_cache *s)\n{\n\tif (is_root_cache(s)) {\n\t\tlist_add(&s->root_caches_node, &slab_root_caches);\n\t} else {\n\t\tlist_add(&s->memcg_params.children_node,\n\t\t\t &s->memcg_params.root_cache->memcg_params.children);\n\t\tlist_add(&s->memcg_params.kmem_caches_node,\n\t\t\t &s->memcg_params.memcg->kmem_caches);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&s->list",
            "&slab_caches"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_boot_cache",
          "args": [
            "s",
            "name",
            "size",
            "flags",
            "useroffset",
            "usersize"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "create_boot_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "937-958",
          "snippet": "void __init create_boot_cache(struct kmem_cache *s, const char *name,\n\t\tunsigned int size, slab_flags_t flags,\n\t\tunsigned int useroffset, unsigned int usersize)\n{\n\tint err;\n\n\ts->name = name;\n\ts->size = s->object_size = size;\n\ts->align = calculate_alignment(flags, ARCH_KMALLOC_MINALIGN, size);\n\ts->useroffset = useroffset;\n\ts->usersize = usersize;\n\n\tslab_init_memcg_params(s);\n\n\terr = __kmem_cache_create(s, flags);\n\n\tif (err)\n\t\tpanic(\"Creation of kmalloc slab %s size=%u failed. Reason %d\\n\",\n\t\t\t\t\tname, size, err);\n\n\ts->refcount = -1;\t/* Exempt from merging for now */\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nvoid __init create_boot_cache(struct kmem_cache *s, const char *name,\n\t\tunsigned int size, slab_flags_t flags,\n\t\tunsigned int useroffset, unsigned int usersize)\n{\n\tint err;\n\n\ts->name = name;\n\ts->size = s->object_size = size;\n\ts->align = calculate_alignment(flags, ARCH_KMALLOC_MINALIGN, size);\n\ts->useroffset = useroffset;\n\ts->usersize = usersize;\n\n\tslab_init_memcg_params(s);\n\n\terr = __kmem_cache_create(s, flags);\n\n\tif (err)\n\t\tpanic(\"Creation of kmalloc slab %s size=%u failed. Reason %d\\n\",\n\t\t\t\t\tname, size, err);\n\n\ts->refcount = -1;\t/* Exempt from merging for now */\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Out of memory when creating slab %s\\n\"",
            "name"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "check_panic_on_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "1008-1028",
          "snippet": "static void check_panic_on_oom(struct oom_control *oc,\n\t\t\t       enum oom_constraint constraint)\n{\n\tif (likely(!sysctl_panic_on_oom))\n\t\treturn;\n\tif (sysctl_panic_on_oom != 2) {\n\t\t/*\n\t\t * panic_on_oom == 1 only affects CONSTRAINT_NONE, the kernel\n\t\t * does not panic for cpuset, mempolicy, or memcg allocation\n\t\t * failures.\n\t\t */\n\t\tif (constraint != CONSTRAINT_NONE)\n\t\t\treturn;\n\t}\n\t/* Do not panic for oom kills triggered by sysrq */\n\tif (is_sysrq_oom(oc))\n\t\treturn;\n\tdump_header(oc, NULL);\n\tpanic(\"Out of memory: %s panic_on_oom is enabled\\n\",\n\t\tsysctl_panic_on_oom == 2 ? \"compulsory\" : \"system-wide\");\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int sysctl_panic_on_oom;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nint sysctl_panic_on_oom;\n\nstatic void check_panic_on_oom(struct oom_control *oc,\n\t\t\t       enum oom_constraint constraint)\n{\n\tif (likely(!sysctl_panic_on_oom))\n\t\treturn;\n\tif (sysctl_panic_on_oom != 2) {\n\t\t/*\n\t\t * panic_on_oom == 1 only affects CONSTRAINT_NONE, the kernel\n\t\t * does not panic for cpuset, mempolicy, or memcg allocation\n\t\t * failures.\n\t\t */\n\t\tif (constraint != CONSTRAINT_NONE)\n\t\t\treturn;\n\t}\n\t/* Do not panic for oom kills triggered by sysrq */\n\tif (is_sysrq_oom(oc))\n\t\treturn;\n\tdump_header(oc, NULL);\n\tpanic(\"Out of memory: %s panic_on_oom is enabled\\n\",\n\t\tsysctl_panic_on_oom == 2 ? \"compulsory\" : \"system-wide\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "kmem_cache",
            "GFP_NOWAIT"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstruct kmem_cache *__init create_kmalloc_cache(const char *name,\n\t\tunsigned int size, slab_flags_t flags,\n\t\tunsigned int useroffset, unsigned int usersize)\n{\n\tstruct kmem_cache *s = kmem_cache_zalloc(kmem_cache, GFP_NOWAIT);\n\n\tif (!s)\n\t\tpanic(\"Out of memory when creating slab %s\\n\", name);\n\n\tcreate_boot_cache(s, name, size, flags, useroffset, usersize);\n\tlist_add(&s->list, &slab_caches);\n\tmemcg_link_cache(s);\n\ts->refcount = 1;\n\treturn s;\n}"
  },
  {
    "function_name": "create_boot_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "937-958",
    "snippet": "void __init create_boot_cache(struct kmem_cache *s, const char *name,\n\t\tunsigned int size, slab_flags_t flags,\n\t\tunsigned int useroffset, unsigned int usersize)\n{\n\tint err;\n\n\ts->name = name;\n\ts->size = s->object_size = size;\n\ts->align = calculate_alignment(flags, ARCH_KMALLOC_MINALIGN, size);\n\ts->useroffset = useroffset;\n\ts->usersize = usersize;\n\n\tslab_init_memcg_params(s);\n\n\terr = __kmem_cache_create(s, flags);\n\n\tif (err)\n\t\tpanic(\"Creation of kmalloc slab %s size=%u failed. Reason %d\\n\",\n\t\t\t\t\tname, size, err);\n\n\ts->refcount = -1;\t/* Exempt from merging for now */\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Creation of kmalloc slab %s size=%u failed. Reason %d\\n\"",
            "name",
            "size",
            "err"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kmem_cache_create",
          "args": [
            "s",
            "flags"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "__kmem_cache_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1990-2154",
          "snippet": "int __kmem_cache_create(struct kmem_cache *cachep, slab_flags_t flags)\n{\n\tsize_t ralign = BYTES_PER_WORD;\n\tgfp_t gfp;\n\tint err;\n\tunsigned int size = cachep->size;\n\n#if DEBUG\n#if FORCED_DEBUG\n\t/*\n\t * Enable redzoning and last user accounting, except for caches with\n\t * large objects, if the increased size would increase the object size\n\t * above the next power of two: caches with object sizes just above a\n\t * power of two have a significant amount of internal fragmentation.\n\t */\n\tif (size < 4096 || fls(size - 1) == fls(size-1 + REDZONE_ALIGN +\n\t\t\t\t\t\t2 * sizeof(unsigned long long)))\n\t\tflags |= SLAB_RED_ZONE | SLAB_STORE_USER;\n\tif (!(flags & SLAB_TYPESAFE_BY_RCU))\n\t\tflags |= SLAB_POISON;\n#endif\n#endif\n\n\t/*\n\t * Check that size is in terms of words.  This is needed to avoid\n\t * unaligned accesses for some archs when redzoning is used, and makes\n\t * sure any on-slab bufctl's are also correctly aligned.\n\t */\n\tsize = ALIGN(size, BYTES_PER_WORD);\n\n\tif (flags & SLAB_RED_ZONE) {\n\t\tralign = REDZONE_ALIGN;\n\t\t/* If redzoning, ensure that the second redzone is suitably\n\t\t * aligned, by adjusting the object size accordingly. */\n\t\tsize = ALIGN(size, REDZONE_ALIGN);\n\t}\n\n\t/* 3) caller mandated alignment */\n\tif (ralign < cachep->align) {\n\t\tralign = cachep->align;\n\t}\n\t/* disable debug if necessary */\n\tif (ralign > __alignof__(unsigned long long))\n\t\tflags &= ~(SLAB_RED_ZONE | SLAB_STORE_USER);\n\t/*\n\t * 4) Store it.\n\t */\n\tcachep->align = ralign;\n\tcachep->colour_off = cache_line_size();\n\t/* Offset must be a multiple of the alignment. */\n\tif (cachep->colour_off < cachep->align)\n\t\tcachep->colour_off = cachep->align;\n\n\tif (slab_is_available())\n\t\tgfp = GFP_KERNEL;\n\telse\n\t\tgfp = GFP_NOWAIT;\n\n#if DEBUG\n\n\t/*\n\t * Both debugging options require word-alignment which is calculated\n\t * into align above.\n\t */\n\tif (flags & SLAB_RED_ZONE) {\n\t\t/* add space for red zone words */\n\t\tcachep->obj_offset += sizeof(unsigned long long);\n\t\tsize += 2 * sizeof(unsigned long long);\n\t}\n\tif (flags & SLAB_STORE_USER) {\n\t\t/* user store requires one word storage behind the end of\n\t\t * the real object. But if the second red zone needs to be\n\t\t * aligned to 64 bits, we must allow that much space.\n\t\t */\n\t\tif (flags & SLAB_RED_ZONE)\n\t\t\tsize += REDZONE_ALIGN;\n\t\telse\n\t\t\tsize += BYTES_PER_WORD;\n\t}\n#endif\n\n\tkasan_cache_create(cachep, &size, &flags);\n\n\tsize = ALIGN(size, cachep->align);\n\t/*\n\t * We should restrict the number of objects in a slab to implement\n\t * byte sized index. Refer comment on SLAB_OBJ_MIN_SIZE definition.\n\t */\n\tif (FREELIST_BYTE_INDEX && size < SLAB_OBJ_MIN_SIZE)\n\t\tsize = ALIGN(SLAB_OBJ_MIN_SIZE, cachep->align);\n\n#if DEBUG\n\t/*\n\t * To activate debug pagealloc, off-slab management is necessary\n\t * requirement. In early phase of initialization, small sized slab\n\t * doesn't get initialized so it would not be possible. So, we need\n\t * to check size >= 256. It guarantees that all necessary small\n\t * sized slab is initialized in current slab initialization sequence.\n\t */\n\tif (debug_pagealloc_enabled() && (flags & SLAB_POISON) &&\n\t\tsize >= 256 && cachep->object_size > cache_line_size()) {\n\t\tif (size < PAGE_SIZE || size % PAGE_SIZE == 0) {\n\t\t\tsize_t tmp_size = ALIGN(size, PAGE_SIZE);\n\n\t\t\tif (set_off_slab_cache(cachep, tmp_size, flags)) {\n\t\t\t\tflags |= CFLGS_OFF_SLAB;\n\t\t\t\tcachep->obj_offset += tmp_size - size;\n\t\t\t\tsize = tmp_size;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (set_objfreelist_slab_cache(cachep, size, flags)) {\n\t\tflags |= CFLGS_OBJFREELIST_SLAB;\n\t\tgoto done;\n\t}\n\n\tif (set_off_slab_cache(cachep, size, flags)) {\n\t\tflags |= CFLGS_OFF_SLAB;\n\t\tgoto done;\n\t}\n\n\tif (set_on_slab_cache(cachep, size, flags))\n\t\tgoto done;\n\n\treturn -E2BIG;\n\ndone:\n\tcachep->freelist_size = cachep->num * sizeof(freelist_idx_t);\n\tcachep->flags = flags;\n\tcachep->allocflags = __GFP_COMP;\n\tif (flags & SLAB_CACHE_DMA)\n\t\tcachep->allocflags |= GFP_DMA;\n\tif (flags & SLAB_RECLAIM_ACCOUNT)\n\t\tcachep->allocflags |= __GFP_RECLAIMABLE;\n\tcachep->size = size;\n\tcachep->reciprocal_buffer_size = reciprocal_value(size);\n\n#if DEBUG\n\t/*\n\t * If we're going to use the generic kernel_map_pages()\n\t * poisoning, then it's going to smash the contents of\n\t * the redzone and userword anyhow, so switch them off.\n\t */\n\tif (IS_ENABLED(CONFIG_PAGE_POISONING) &&\n\t\t(cachep->flags & SLAB_POISON) &&\n\t\tis_debug_pagealloc_cache(cachep))\n\t\tcachep->flags &= ~(SLAB_RED_ZONE | SLAB_STORE_USER);\n#endif\n\n\tif (OFF_SLAB(cachep)) {\n\t\tcachep->freelist_cache =\n\t\t\tkmalloc_slab(cachep->freelist_size, 0u);\n\t}\n\n\terr = setup_cpu_cache(cachep, gfp);\n\tif (err) {\n\t\t__kmem_cache_release(cachep);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define CFLGS_OFF_SLAB\t\t((slab_flags_t __force)0x80000000U)",
            "#define CFLGS_OBJFREELIST_SLAB\t((slab_flags_t __force)0x40000000U)",
            "#define FREELIST_BYTE_INDEX (((PAGE_SIZE >> BITS_PER_BYTE) \\\n\t\t\t\t<= SLAB_OBJ_MIN_SIZE) ? 1 : 0)",
            "#define\tREDZONE_ALIGN\t\tmax(BYTES_PER_WORD, __alignof__(unsigned long long))",
            "#define\tBYTES_PER_WORD\t\tsizeof(void *)",
            "#define\tFORCED_DEBUG\t0",
            "#define\tDEBUG\t\t0",
            "#define\tFORCED_DEBUG\t1",
            "#define\tDEBUG\t\t1"
          ],
          "globals_used": [
            "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define CFLGS_OFF_SLAB\t\t((slab_flags_t __force)0x80000000U)\n#define CFLGS_OBJFREELIST_SLAB\t((slab_flags_t __force)0x40000000U)\n#define FREELIST_BYTE_INDEX (((PAGE_SIZE >> BITS_PER_BYTE) \\\n\t\t\t\t<= SLAB_OBJ_MIN_SIZE) ? 1 : 0)\n#define\tREDZONE_ALIGN\t\tmax(BYTES_PER_WORD, __alignof__(unsigned long long))\n#define\tBYTES_PER_WORD\t\tsizeof(void *)\n#define\tFORCED_DEBUG\t0\n#define\tDEBUG\t\t0\n#define\tFORCED_DEBUG\t1\n#define\tDEBUG\t\t1\n\nstatic int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);\nstatic noinline struct;\n\nint __kmem_cache_create(struct kmem_cache *cachep, slab_flags_t flags)\n{\n\tsize_t ralign = BYTES_PER_WORD;\n\tgfp_t gfp;\n\tint err;\n\tunsigned int size = cachep->size;\n\n#if DEBUG\n#if FORCED_DEBUG\n\t/*\n\t * Enable redzoning and last user accounting, except for caches with\n\t * large objects, if the increased size would increase the object size\n\t * above the next power of two: caches with object sizes just above a\n\t * power of two have a significant amount of internal fragmentation.\n\t */\n\tif (size < 4096 || fls(size - 1) == fls(size-1 + REDZONE_ALIGN +\n\t\t\t\t\t\t2 * sizeof(unsigned long long)))\n\t\tflags |= SLAB_RED_ZONE | SLAB_STORE_USER;\n\tif (!(flags & SLAB_TYPESAFE_BY_RCU))\n\t\tflags |= SLAB_POISON;\n#endif\n#endif\n\n\t/*\n\t * Check that size is in terms of words.  This is needed to avoid\n\t * unaligned accesses for some archs when redzoning is used, and makes\n\t * sure any on-slab bufctl's are also correctly aligned.\n\t */\n\tsize = ALIGN(size, BYTES_PER_WORD);\n\n\tif (flags & SLAB_RED_ZONE) {\n\t\tralign = REDZONE_ALIGN;\n\t\t/* If redzoning, ensure that the second redzone is suitably\n\t\t * aligned, by adjusting the object size accordingly. */\n\t\tsize = ALIGN(size, REDZONE_ALIGN);\n\t}\n\n\t/* 3) caller mandated alignment */\n\tif (ralign < cachep->align) {\n\t\tralign = cachep->align;\n\t}\n\t/* disable debug if necessary */\n\tif (ralign > __alignof__(unsigned long long))\n\t\tflags &= ~(SLAB_RED_ZONE | SLAB_STORE_USER);\n\t/*\n\t * 4) Store it.\n\t */\n\tcachep->align = ralign;\n\tcachep->colour_off = cache_line_size();\n\t/* Offset must be a multiple of the alignment. */\n\tif (cachep->colour_off < cachep->align)\n\t\tcachep->colour_off = cachep->align;\n\n\tif (slab_is_available())\n\t\tgfp = GFP_KERNEL;\n\telse\n\t\tgfp = GFP_NOWAIT;\n\n#if DEBUG\n\n\t/*\n\t * Both debugging options require word-alignment which is calculated\n\t * into align above.\n\t */\n\tif (flags & SLAB_RED_ZONE) {\n\t\t/* add space for red zone words */\n\t\tcachep->obj_offset += sizeof(unsigned long long);\n\t\tsize += 2 * sizeof(unsigned long long);\n\t}\n\tif (flags & SLAB_STORE_USER) {\n\t\t/* user store requires one word storage behind the end of\n\t\t * the real object. But if the second red zone needs to be\n\t\t * aligned to 64 bits, we must allow that much space.\n\t\t */\n\t\tif (flags & SLAB_RED_ZONE)\n\t\t\tsize += REDZONE_ALIGN;\n\t\telse\n\t\t\tsize += BYTES_PER_WORD;\n\t}\n#endif\n\n\tkasan_cache_create(cachep, &size, &flags);\n\n\tsize = ALIGN(size, cachep->align);\n\t/*\n\t * We should restrict the number of objects in a slab to implement\n\t * byte sized index. Refer comment on SLAB_OBJ_MIN_SIZE definition.\n\t */\n\tif (FREELIST_BYTE_INDEX && size < SLAB_OBJ_MIN_SIZE)\n\t\tsize = ALIGN(SLAB_OBJ_MIN_SIZE, cachep->align);\n\n#if DEBUG\n\t/*\n\t * To activate debug pagealloc, off-slab management is necessary\n\t * requirement. In early phase of initialization, small sized slab\n\t * doesn't get initialized so it would not be possible. So, we need\n\t * to check size >= 256. It guarantees that all necessary small\n\t * sized slab is initialized in current slab initialization sequence.\n\t */\n\tif (debug_pagealloc_enabled() && (flags & SLAB_POISON) &&\n\t\tsize >= 256 && cachep->object_size > cache_line_size()) {\n\t\tif (size < PAGE_SIZE || size % PAGE_SIZE == 0) {\n\t\t\tsize_t tmp_size = ALIGN(size, PAGE_SIZE);\n\n\t\t\tif (set_off_slab_cache(cachep, tmp_size, flags)) {\n\t\t\t\tflags |= CFLGS_OFF_SLAB;\n\t\t\t\tcachep->obj_offset += tmp_size - size;\n\t\t\t\tsize = tmp_size;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (set_objfreelist_slab_cache(cachep, size, flags)) {\n\t\tflags |= CFLGS_OBJFREELIST_SLAB;\n\t\tgoto done;\n\t}\n\n\tif (set_off_slab_cache(cachep, size, flags)) {\n\t\tflags |= CFLGS_OFF_SLAB;\n\t\tgoto done;\n\t}\n\n\tif (set_on_slab_cache(cachep, size, flags))\n\t\tgoto done;\n\n\treturn -E2BIG;\n\ndone:\n\tcachep->freelist_size = cachep->num * sizeof(freelist_idx_t);\n\tcachep->flags = flags;\n\tcachep->allocflags = __GFP_COMP;\n\tif (flags & SLAB_CACHE_DMA)\n\t\tcachep->allocflags |= GFP_DMA;\n\tif (flags & SLAB_RECLAIM_ACCOUNT)\n\t\tcachep->allocflags |= __GFP_RECLAIMABLE;\n\tcachep->size = size;\n\tcachep->reciprocal_buffer_size = reciprocal_value(size);\n\n#if DEBUG\n\t/*\n\t * If we're going to use the generic kernel_map_pages()\n\t * poisoning, then it's going to smash the contents of\n\t * the redzone and userword anyhow, so switch them off.\n\t */\n\tif (IS_ENABLED(CONFIG_PAGE_POISONING) &&\n\t\t(cachep->flags & SLAB_POISON) &&\n\t\tis_debug_pagealloc_cache(cachep))\n\t\tcachep->flags &= ~(SLAB_RED_ZONE | SLAB_STORE_USER);\n#endif\n\n\tif (OFF_SLAB(cachep)) {\n\t\tcachep->freelist_cache =\n\t\t\tkmalloc_slab(cachep->freelist_size, 0u);\n\t}\n\n\terr = setup_cpu_cache(cachep, gfp);\n\tif (err) {\n\t\t__kmem_cache_release(cachep);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "slab_init_memcg_params",
          "args": [
            "s"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "slab_init_memcg_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "134-140",
          "snippet": "void slab_init_memcg_params(struct kmem_cache *s)\n{\n\ts->memcg_params.root_cache = NULL;\n\tRCU_INIT_POINTER(s->memcg_params.memcg_caches, NULL);\n\tINIT_LIST_HEAD(&s->memcg_params.children);\n\ts->memcg_params.dying = false;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nvoid slab_init_memcg_params(struct kmem_cache *s)\n{\n\ts->memcg_params.root_cache = NULL;\n\tRCU_INIT_POINTER(s->memcg_params.memcg_caches, NULL);\n\tINIT_LIST_HEAD(&s->memcg_params.children);\n\ts->memcg_params.dying = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calculate_alignment",
          "args": [
            "flags",
            "ARCH_KMALLOC_MINALIGN",
            "size"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "calculate_alignment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "265-288",
          "snippet": "static unsigned int calculate_alignment(slab_flags_t flags,\n\t\tunsigned int align, unsigned int size)\n{\n\t/*\n\t * If the user wants hardware cache aligned objects then follow that\n\t * suggestion if the object is sufficiently large.\n\t *\n\t * The hardware cache alignment cannot override the specified\n\t * alignment though. If that is greater then use it.\n\t */\n\tif (flags & SLAB_HWCACHE_ALIGN) {\n\t\tunsigned int ralign;\n\n\t\tralign = cache_line_size();\n\t\twhile (size <= ralign / 2)\n\t\t\tralign /= 2;\n\t\talign = max(align, ralign);\n\t}\n\n\tif (align < ARCH_SLAB_MINALIGN)\n\t\talign = ARCH_SLAB_MINALIGN;\n\n\treturn ALIGN(align, sizeof(void *));\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstatic unsigned int calculate_alignment(slab_flags_t flags,\n\t\tunsigned int align, unsigned int size)\n{\n\t/*\n\t * If the user wants hardware cache aligned objects then follow that\n\t * suggestion if the object is sufficiently large.\n\t *\n\t * The hardware cache alignment cannot override the specified\n\t * alignment though. If that is greater then use it.\n\t */\n\tif (flags & SLAB_HWCACHE_ALIGN) {\n\t\tunsigned int ralign;\n\n\t\tralign = cache_line_size();\n\t\twhile (size <= ralign / 2)\n\t\t\tralign /= 2;\n\t\talign = max(align, ralign);\n\t}\n\n\tif (align < ARCH_SLAB_MINALIGN)\n\t\talign = ARCH_SLAB_MINALIGN;\n\n\treturn ALIGN(align, sizeof(void *));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nvoid __init create_boot_cache(struct kmem_cache *s, const char *name,\n\t\tunsigned int size, slab_flags_t flags,\n\t\tunsigned int useroffset, unsigned int usersize)\n{\n\tint err;\n\n\ts->name = name;\n\ts->size = s->object_size = size;\n\ts->align = calculate_alignment(flags, ARCH_KMALLOC_MINALIGN, size);\n\ts->useroffset = useroffset;\n\ts->usersize = usersize;\n\n\tslab_init_memcg_params(s);\n\n\terr = __kmem_cache_create(s, flags);\n\n\tif (err)\n\t\tpanic(\"Creation of kmalloc slab %s size=%u failed. Reason %d\\n\",\n\t\t\t\t\tname, size, err);\n\n\ts->refcount = -1;\t/* Exempt from merging for now */\n}"
  },
  {
    "function_name": "slab_is_available",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "930-933",
    "snippet": "bool slab_is_available(void)\n{\n\treturn slab_state >= UP;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "enum slab_state slab_state;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nenum slab_state slab_state;\n\nbool slab_is_available(void)\n{\n\treturn slab_state >= UP;\n}"
  },
  {
    "function_name": "kmem_cache_shrink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "916-927",
    "snippet": "int kmem_cache_shrink(struct kmem_cache *cachep)\n{\n\tint ret;\n\n\tget_online_cpus();\n\tget_online_mems();\n\tkasan_cache_shrink(cachep);\n\tret = __kmem_cache_shrink(cachep);\n\tput_online_mems();\n\tput_online_cpus();\n\treturn ret;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_online_cpus",
          "args": [],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_online_mems",
          "args": [],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "put_online_mems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "61-64",
          "snippet": "void put_online_mems(void)\n{\n\tpercpu_up_read(&mem_hotplug_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid put_online_mems(void)\n{\n\tpercpu_up_read(&mem_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__kmem_cache_shrink",
          "args": [
            "cachep"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "__kmem_cache_shrink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2304-2320",
          "snippet": "int __kmem_cache_shrink(struct kmem_cache *cachep)\n{\n\tint ret = 0;\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tdrain_cpu_caches(cachep);\n\n\tcheck_irq_on();\n\tfor_each_kmem_cache_node(cachep, node, n) {\n\t\tdrain_freelist(cachep, n, INT_MAX);\n\n\t\tret += !list_empty(&n->slabs_full) ||\n\t\t\t!list_empty(&n->slabs_partial);\n\t}\n\treturn (ret ? 1 : 0);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nint __kmem_cache_shrink(struct kmem_cache *cachep)\n{\n\tint ret = 0;\n\tint node;\n\tstruct kmem_cache_node *n;\n\n\tdrain_cpu_caches(cachep);\n\n\tcheck_irq_on();\n\tfor_each_kmem_cache_node(cachep, node, n) {\n\t\tdrain_freelist(cachep, n, INT_MAX);\n\n\t\tret += !list_empty(&n->slabs_full) ||\n\t\t\t!list_empty(&n->slabs_partial);\n\t}\n\treturn (ret ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kasan_cache_shrink",
          "args": [
            "cachep"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_cache_shrink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "378-381",
          "snippet": "void kasan_cache_shrink(struct kmem_cache *cache)\n{\n\tquarantine_remove_cache(cache);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\nvoid kasan_cache_shrink(struct kmem_cache *cache)\n{\n\tquarantine_remove_cache(cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_online_mems",
          "args": [],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "get_online_mems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "56-59",
          "snippet": "void get_online_mems(void)\n{\n\tpercpu_down_read(&mem_hotplug_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid get_online_mems(void)\n{\n\tpercpu_down_read(&mem_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_online_cpus",
          "args": [],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nint kmem_cache_shrink(struct kmem_cache *cachep)\n{\n\tint ret;\n\n\tget_online_cpus();\n\tget_online_mems();\n\tkasan_cache_shrink(cachep);\n\tret = __kmem_cache_shrink(cachep);\n\tput_online_mems();\n\tput_online_cpus();\n\treturn ret;\n}"
  },
  {
    "function_name": "kmem_cache_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "874-906",
    "snippet": "void kmem_cache_destroy(struct kmem_cache *s)\n{\n\tint err;\n\n\tif (unlikely(!s))\n\t\treturn;\n\n\tflush_memcg_workqueue(s);\n\n\tget_online_cpus();\n\tget_online_mems();\n\n\tmutex_lock(&slab_mutex);\n\n\ts->refcount--;\n\tif (s->refcount)\n\t\tgoto out_unlock;\n\n\terr = shutdown_memcg_caches(s);\n\tif (!err)\n\t\terr = shutdown_cache(s);\n\n\tif (err) {\n\t\tpr_err(\"kmem_cache_destroy %s: Slab cache still has objects\\n\",\n\t\t       s->name);\n\t\tdump_stack();\n\t}\nout_unlock:\n\tmutex_unlock(&slab_mutex);\n\n\tput_online_mems();\n\tput_online_cpus();\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_online_cpus",
          "args": [],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_online_mems",
          "args": [],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "put_online_mems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "61-64",
          "snippet": "void put_online_mems(void)\n{\n\tpercpu_up_read(&mem_hotplug_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid put_online_mems(void)\n{\n\tpercpu_up_read(&mem_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&slab_mutex"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"kmem_cache_destroy %s: Slab cache still has objects\\n\"",
            "s->name"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shutdown_cache",
          "args": [
            "s"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "shutdown_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "558-585",
          "snippet": "static int shutdown_cache(struct kmem_cache *s)\n{\n\t/* free asan quarantined objects */\n\tkasan_cache_shutdown(s);\n\n\tif (__kmem_cache_shutdown(s) != 0)\n\t\treturn -EBUSY;\n\n\tmemcg_unlink_cache(s);\n\tlist_del(&s->list);\n\n\tif (s->flags & SLAB_TYPESAFE_BY_RCU) {\n#ifdef SLAB_SUPPORTS_SYSFS\n\t\tsysfs_slab_unlink(s);\n#endif\n\t\tlist_add_tail(&s->list, &slab_caches_to_rcu_destroy);\n\t\tschedule_work(&slab_caches_to_rcu_destroy_work);\n\t} else {\n#ifdef SLAB_SUPPORTS_SYSFS\n\t\tsysfs_slab_unlink(s);\n\t\tsysfs_slab_release(s);\n#else\n\t\tslab_kmem_cache_release(s);\n#endif\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;",
            "static LIST_HEAD(slab_caches_to_rcu_destroy);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\nstatic LIST_HEAD(slab_caches_to_rcu_destroy);\n\nstatic int shutdown_cache(struct kmem_cache *s)\n{\n\t/* free asan quarantined objects */\n\tkasan_cache_shutdown(s);\n\n\tif (__kmem_cache_shutdown(s) != 0)\n\t\treturn -EBUSY;\n\n\tmemcg_unlink_cache(s);\n\tlist_del(&s->list);\n\n\tif (s->flags & SLAB_TYPESAFE_BY_RCU) {\n#ifdef SLAB_SUPPORTS_SYSFS\n\t\tsysfs_slab_unlink(s);\n#endif\n\t\tlist_add_tail(&s->list, &slab_caches_to_rcu_destroy);\n\t\tschedule_work(&slab_caches_to_rcu_destroy_work);\n\t} else {\n#ifdef SLAB_SUPPORTS_SYSFS\n\t\tsysfs_slab_unlink(s);\n\t\tsysfs_slab_release(s);\n#else\n\t\tslab_kmem_cache_release(s);\n#endif\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "shutdown_memcg_caches",
          "args": [
            "s"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "shutdown_memcg_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "856-859",
          "snippet": "static inline int shutdown_memcg_caches(struct kmem_cache *s)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstatic inline int shutdown_memcg_caches(struct kmem_cache *s)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&slab_mutex"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_online_mems",
          "args": [],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "get_online_mems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "56-59",
          "snippet": "void get_online_mems(void)\n{\n\tpercpu_down_read(&mem_hotplug_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid get_online_mems(void)\n{\n\tpercpu_down_read(&mem_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_online_cpus",
          "args": [],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_memcg_workqueue",
          "args": [
            "s"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "flush_memcg_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "861-863",
          "snippet": "static inline void flush_memcg_workqueue(struct kmem_cache *s)\n{\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstatic inline void flush_memcg_workqueue(struct kmem_cache *s)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!s"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nvoid kmem_cache_destroy(struct kmem_cache *s)\n{\n\tint err;\n\n\tif (unlikely(!s))\n\t\treturn;\n\n\tflush_memcg_workqueue(s);\n\n\tget_online_cpus();\n\tget_online_mems();\n\n\tmutex_lock(&slab_mutex);\n\n\ts->refcount--;\n\tif (s->refcount)\n\t\tgoto out_unlock;\n\n\terr = shutdown_memcg_caches(s);\n\tif (!err)\n\t\terr = shutdown_cache(s);\n\n\tif (err) {\n\t\tpr_err(\"kmem_cache_destroy %s: Slab cache still has objects\\n\",\n\t\t       s->name);\n\t\tdump_stack();\n\t}\nout_unlock:\n\tmutex_unlock(&slab_mutex);\n\n\tput_online_mems();\n\tput_online_cpus();\n}"
  },
  {
    "function_name": "slab_kmem_cache_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "866-872",
    "snippet": "void slab_kmem_cache_release(struct kmem_cache *s)\n{\n\t__kmem_cache_release(s);\n\tdestroy_memcg_params(s);\n\tkfree_const(s->name);\n\tkmem_cache_free(kmem_cache, s);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "kmem_cache",
            "s"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3749-3764",
          "snippet": "void kmem_cache_free(struct kmem_cache *cachep, void *objp)\n{\n\tunsigned long flags;\n\tcachep = cache_from_obj(cachep, objp);\n\tif (!cachep)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tdebug_check_no_locks_freed(objp, cachep->object_size);\n\tif (!(cachep->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(objp, cachep->object_size);\n\t__cache_free(cachep, objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n\n\ttrace_kmem_cache_free(_RET_IP_, objp);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid kmem_cache_free(struct kmem_cache *cachep, void *objp)\n{\n\tunsigned long flags;\n\tcachep = cache_from_obj(cachep, objp);\n\tif (!cachep)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tdebug_check_no_locks_freed(objp, cachep->object_size);\n\tif (!(cachep->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(objp, cachep->object_size);\n\t__cache_free(cachep, objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n\n\ttrace_kmem_cache_free(_RET_IP_, objp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree_const",
          "args": [
            "s->name"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_const",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "28-32",
          "snippet": "void kfree_const(const void *x)\n{\n\tif (!is_kernel_rodata((unsigned long)x))\n\t\tkfree(x);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid kfree_const(const void *x)\n{\n\tif (!is_kernel_rodata((unsigned long)x))\n\t\tkfree(x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_memcg_params",
          "args": [
            "s"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_memcg_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "252-254",
          "snippet": "static inline void destroy_memcg_params(struct kmem_cache *s)\n{\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstatic inline void destroy_memcg_params(struct kmem_cache *s)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "__kmem_cache_release",
          "args": [
            "s"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "__kmem_cache_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2334-2350",
          "snippet": "void __kmem_cache_release(struct kmem_cache *cachep)\n{\n\tint i;\n\tstruct kmem_cache_node *n;\n\n\tcache_random_seq_destroy(cachep);\n\n\tfree_percpu(cachep->cpu_cache);\n\n\t/* NUMA: free the node structures */\n\tfor_each_kmem_cache_node(cachep, i, n) {\n\t\tkfree(n->shared);\n\t\tfree_alien_cache(n->alien);\n\t\tkfree(n);\n\t\tcachep->node[i] = NULL;\n\t}\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid __kmem_cache_release(struct kmem_cache *cachep)\n{\n\tint i;\n\tstruct kmem_cache_node *n;\n\n\tcache_random_seq_destroy(cachep);\n\n\tfree_percpu(cachep->cpu_cache);\n\n\t/* NUMA: free the node structures */\n\tfor_each_kmem_cache_node(cachep, i, n) {\n\t\tkfree(n->shared);\n\t\tfree_alien_cache(n->alien);\n\t\tkfree(n);\n\t\tcachep->node[i] = NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nvoid slab_kmem_cache_release(struct kmem_cache *s)\n{\n\t__kmem_cache_release(s);\n\tdestroy_memcg_params(s);\n\tkfree_const(s->name);\n\tkmem_cache_free(kmem_cache, s);\n}"
  },
  {
    "function_name": "flush_memcg_workqueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "861-863",
    "snippet": "static inline void flush_memcg_workqueue(struct kmem_cache *s)\n{\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstatic inline void flush_memcg_workqueue(struct kmem_cache *s)\n{\n}"
  },
  {
    "function_name": "shutdown_memcg_caches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "856-859",
    "snippet": "static inline int shutdown_memcg_caches(struct kmem_cache *s)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstatic inline int shutdown_memcg_caches(struct kmem_cache *s)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "flush_memcg_workqueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "835-854",
    "snippet": "static void flush_memcg_workqueue(struct kmem_cache *s)\n{\n\tmutex_lock(&slab_mutex);\n\ts->memcg_params.dying = true;\n\tmutex_unlock(&slab_mutex);\n\n\t/*\n\t * SLUB deactivates the kmem_caches through call_rcu_sched. Make\n\t * sure all registered rcu callbacks have been invoked.\n\t */\n\tif (IS_ENABLED(CONFIG_SLUB))\n\t\trcu_barrier_sched();\n\n\t/*\n\t * SLAB and SLUB create memcg kmem_caches through workqueue and SLUB\n\t * deactivates the memcg kmem_caches through workqueue. Make sure all\n\t * previous workitems on workqueue are processed.\n\t */\n\tflush_workqueue(memcg_kmem_cache_wq);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_workqueue",
          "args": [
            "memcg_kmem_cache_wq"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier_sched",
          "args": [],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_SLUB"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&slab_mutex"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&slab_mutex"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstatic void flush_memcg_workqueue(struct kmem_cache *s)\n{\n\tmutex_lock(&slab_mutex);\n\ts->memcg_params.dying = true;\n\tmutex_unlock(&slab_mutex);\n\n\t/*\n\t * SLUB deactivates the kmem_caches through call_rcu_sched. Make\n\t * sure all registered rcu callbacks have been invoked.\n\t */\n\tif (IS_ENABLED(CONFIG_SLUB))\n\t\trcu_barrier_sched();\n\n\t/*\n\t * SLAB and SLUB create memcg kmem_caches through workqueue and SLUB\n\t * deactivates the memcg kmem_caches through workqueue. Make sure all\n\t * previous workitems on workqueue are processed.\n\t */\n\tflush_workqueue(memcg_kmem_cache_wq);\n}"
  },
  {
    "function_name": "shutdown_memcg_caches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "780-833",
    "snippet": "static int shutdown_memcg_caches(struct kmem_cache *s)\n{\n\tstruct memcg_cache_array *arr;\n\tstruct kmem_cache *c, *c2;\n\tLIST_HEAD(busy);\n\tint i;\n\n\tBUG_ON(!is_root_cache(s));\n\n\t/*\n\t * First, shutdown active caches, i.e. caches that belong to online\n\t * memory cgroups.\n\t */\n\tarr = rcu_dereference_protected(s->memcg_params.memcg_caches,\n\t\t\t\t\tlockdep_is_held(&slab_mutex));\n\tfor_each_memcg_cache_index(i) {\n\t\tc = arr->entries[i];\n\t\tif (!c)\n\t\t\tcontinue;\n\t\tif (shutdown_cache(c))\n\t\t\t/*\n\t\t\t * The cache still has objects. Move it to a temporary\n\t\t\t * list so as not to try to destroy it for a second\n\t\t\t * time while iterating over inactive caches below.\n\t\t\t */\n\t\t\tlist_move(&c->memcg_params.children_node, &busy);\n\t\telse\n\t\t\t/*\n\t\t\t * The cache is empty and will be destroyed soon. Clear\n\t\t\t * the pointer to it in the memcg_caches array so that\n\t\t\t * it will never be accessed even if the root cache\n\t\t\t * stays alive.\n\t\t\t */\n\t\t\tarr->entries[i] = NULL;\n\t}\n\n\t/*\n\t * Second, shutdown all caches left from memory cgroups that are now\n\t * offline.\n\t */\n\tlist_for_each_entry_safe(c, c2, &s->memcg_params.children,\n\t\t\t\t memcg_params.children_node)\n\t\tshutdown_cache(c);\n\n\tlist_splice(&busy, &s->memcg_params.children);\n\n\t/*\n\t * A cache being destroyed must be empty. In particular, this means\n\t * that all per memcg caches attached to it must be empty too.\n\t */\n\tif (!list_empty(&s->memcg_params.children))\n\t\treturn -EBUSY;\n\treturn 0;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&s->memcg_params.children"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice",
          "args": [
            "&busy",
            "&s->memcg_params.children"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shutdown_cache",
          "args": [
            "c"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "shutdown_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "558-585",
          "snippet": "static int shutdown_cache(struct kmem_cache *s)\n{\n\t/* free asan quarantined objects */\n\tkasan_cache_shutdown(s);\n\n\tif (__kmem_cache_shutdown(s) != 0)\n\t\treturn -EBUSY;\n\n\tmemcg_unlink_cache(s);\n\tlist_del(&s->list);\n\n\tif (s->flags & SLAB_TYPESAFE_BY_RCU) {\n#ifdef SLAB_SUPPORTS_SYSFS\n\t\tsysfs_slab_unlink(s);\n#endif\n\t\tlist_add_tail(&s->list, &slab_caches_to_rcu_destroy);\n\t\tschedule_work(&slab_caches_to_rcu_destroy_work);\n\t} else {\n#ifdef SLAB_SUPPORTS_SYSFS\n\t\tsysfs_slab_unlink(s);\n\t\tsysfs_slab_release(s);\n#else\n\t\tslab_kmem_cache_release(s);\n#endif\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;",
            "static LIST_HEAD(slab_caches_to_rcu_destroy);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\nstatic LIST_HEAD(slab_caches_to_rcu_destroy);\n\nstatic int shutdown_cache(struct kmem_cache *s)\n{\n\t/* free asan quarantined objects */\n\tkasan_cache_shutdown(s);\n\n\tif (__kmem_cache_shutdown(s) != 0)\n\t\treturn -EBUSY;\n\n\tmemcg_unlink_cache(s);\n\tlist_del(&s->list);\n\n\tif (s->flags & SLAB_TYPESAFE_BY_RCU) {\n#ifdef SLAB_SUPPORTS_SYSFS\n\t\tsysfs_slab_unlink(s);\n#endif\n\t\tlist_add_tail(&s->list, &slab_caches_to_rcu_destroy);\n\t\tschedule_work(&slab_caches_to_rcu_destroy_work);\n\t} else {\n#ifdef SLAB_SUPPORTS_SYSFS\n\t\tsysfs_slab_unlink(s);\n\t\tsysfs_slab_release(s);\n#else\n\t\tslab_kmem_cache_release(s);\n#endif\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "c",
            "c2",
            "&s->memcg_params.children",
            "memcg_params.children_node"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&c->memcg_params.children_node",
            "&busy"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "qlist_move_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/quarantine.c",
          "lines": "72-88",
          "snippet": "static void qlist_move_all(struct qlist_head *from, struct qlist_head *to)\n{\n\tif (unlikely(qlist_empty(from)))\n\t\treturn;\n\n\tif (qlist_empty(to)) {\n\t\t*to = *from;\n\t\tqlist_init(from);\n\t\treturn;\n\t}\n\n\tto->tail->next = from->head;\n\tto->tail = from->tail;\n\tto->bytes += from->bytes;\n\n\tqlist_init(from);\n}",
          "includes": [
            "#include \"kasan.h\"",
            "#include \"../slab.h\"",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/srcu.h>",
            "#include <linux/slab.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/printk.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hash.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kasan.h\"\n#include \"../slab.h\"\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/srcu.h>\n#include <linux/slab.h>\n#include <linux/shrinker.h>\n#include <linux/printk.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/hash.h>\n#include <linux/gfp.h>\n\nstatic void qlist_move_all(struct qlist_head *from, struct qlist_head *to)\n{\n\tif (unlikely(qlist_empty(from)))\n\t\treturn;\n\n\tif (qlist_empty(to)) {\n\t\t*to = *from;\n\t\tqlist_init(from);\n\t\treturn;\n\t}\n\n\tto->tail->next = from->head;\n\tto->tail = from->tail;\n\tto->bytes += from->bytes;\n\n\tqlist_init(from);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "s->memcg_params.memcg_caches",
            "lockdep_is_held(&slab_mutex)"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&slab_mutex"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!is_root_cache(s)"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_root_cache",
          "args": [
            "s"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "is_root_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "308-311",
          "snippet": "static inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn true;\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "busy"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstatic int shutdown_memcg_caches(struct kmem_cache *s)\n{\n\tstruct memcg_cache_array *arr;\n\tstruct kmem_cache *c, *c2;\n\tLIST_HEAD(busy);\n\tint i;\n\n\tBUG_ON(!is_root_cache(s));\n\n\t/*\n\t * First, shutdown active caches, i.e. caches that belong to online\n\t * memory cgroups.\n\t */\n\tarr = rcu_dereference_protected(s->memcg_params.memcg_caches,\n\t\t\t\t\tlockdep_is_held(&slab_mutex));\n\tfor_each_memcg_cache_index(i) {\n\t\tc = arr->entries[i];\n\t\tif (!c)\n\t\t\tcontinue;\n\t\tif (shutdown_cache(c))\n\t\t\t/*\n\t\t\t * The cache still has objects. Move it to a temporary\n\t\t\t * list so as not to try to destroy it for a second\n\t\t\t * time while iterating over inactive caches below.\n\t\t\t */\n\t\t\tlist_move(&c->memcg_params.children_node, &busy);\n\t\telse\n\t\t\t/*\n\t\t\t * The cache is empty and will be destroyed soon. Clear\n\t\t\t * the pointer to it in the memcg_caches array so that\n\t\t\t * it will never be accessed even if the root cache\n\t\t\t * stays alive.\n\t\t\t */\n\t\t\tarr->entries[i] = NULL;\n\t}\n\n\t/*\n\t * Second, shutdown all caches left from memory cgroups that are now\n\t * offline.\n\t */\n\tlist_for_each_entry_safe(c, c2, &s->memcg_params.children,\n\t\t\t\t memcg_params.children_node)\n\t\tshutdown_cache(c);\n\n\tlist_splice(&busy, &s->memcg_params.children);\n\n\t/*\n\t * A cache being destroyed must be empty. In particular, this means\n\t * that all per memcg caches attached to it must be empty too.\n\t */\n\tif (!list_empty(&s->memcg_params.children))\n\t\treturn -EBUSY;\n\treturn 0;\n}"
  },
  {
    "function_name": "memcg_destroy_kmem_caches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "758-778",
    "snippet": "void memcg_destroy_kmem_caches(struct mem_cgroup *memcg)\n{\n\tstruct kmem_cache *s, *s2;\n\n\tget_online_cpus();\n\tget_online_mems();\n\n\tmutex_lock(&slab_mutex);\n\tlist_for_each_entry_safe(s, s2, &memcg->kmem_caches,\n\t\t\t\t memcg_params.kmem_caches_node) {\n\t\t/*\n\t\t * The cgroup is about to be freed and therefore has no charges\n\t\t * left. Hence, all its caches must be empty by now.\n\t\t */\n\t\tBUG_ON(shutdown_cache(s));\n\t}\n\tmutex_unlock(&slab_mutex);\n\n\tput_online_mems();\n\tput_online_cpus();\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_online_cpus",
          "args": [],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_online_mems",
          "args": [],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "put_online_mems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "61-64",
          "snippet": "void put_online_mems(void)\n{\n\tpercpu_up_read(&mem_hotplug_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid put_online_mems(void)\n{\n\tpercpu_up_read(&mem_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&slab_mutex"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "shutdown_cache(s)"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shutdown_cache",
          "args": [
            "s"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "shutdown_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "558-585",
          "snippet": "static int shutdown_cache(struct kmem_cache *s)\n{\n\t/* free asan quarantined objects */\n\tkasan_cache_shutdown(s);\n\n\tif (__kmem_cache_shutdown(s) != 0)\n\t\treturn -EBUSY;\n\n\tmemcg_unlink_cache(s);\n\tlist_del(&s->list);\n\n\tif (s->flags & SLAB_TYPESAFE_BY_RCU) {\n#ifdef SLAB_SUPPORTS_SYSFS\n\t\tsysfs_slab_unlink(s);\n#endif\n\t\tlist_add_tail(&s->list, &slab_caches_to_rcu_destroy);\n\t\tschedule_work(&slab_caches_to_rcu_destroy_work);\n\t} else {\n#ifdef SLAB_SUPPORTS_SYSFS\n\t\tsysfs_slab_unlink(s);\n\t\tsysfs_slab_release(s);\n#else\n\t\tslab_kmem_cache_release(s);\n#endif\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;",
            "static LIST_HEAD(slab_caches_to_rcu_destroy);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\nstatic LIST_HEAD(slab_caches_to_rcu_destroy);\n\nstatic int shutdown_cache(struct kmem_cache *s)\n{\n\t/* free asan quarantined objects */\n\tkasan_cache_shutdown(s);\n\n\tif (__kmem_cache_shutdown(s) != 0)\n\t\treturn -EBUSY;\n\n\tmemcg_unlink_cache(s);\n\tlist_del(&s->list);\n\n\tif (s->flags & SLAB_TYPESAFE_BY_RCU) {\n#ifdef SLAB_SUPPORTS_SYSFS\n\t\tsysfs_slab_unlink(s);\n#endif\n\t\tlist_add_tail(&s->list, &slab_caches_to_rcu_destroy);\n\t\tschedule_work(&slab_caches_to_rcu_destroy_work);\n\t} else {\n#ifdef SLAB_SUPPORTS_SYSFS\n\t\tsysfs_slab_unlink(s);\n\t\tsysfs_slab_release(s);\n#else\n\t\tslab_kmem_cache_release(s);\n#endif\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "s",
            "s2",
            "&memcg->kmem_caches",
            "memcg_params.kmem_caches_node"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&slab_mutex"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_online_mems",
          "args": [],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "get_online_mems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "56-59",
          "snippet": "void get_online_mems(void)\n{\n\tpercpu_down_read(&mem_hotplug_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid get_online_mems(void)\n{\n\tpercpu_down_read(&mem_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_online_cpus",
          "args": [],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nvoid memcg_destroy_kmem_caches(struct mem_cgroup *memcg)\n{\n\tstruct kmem_cache *s, *s2;\n\n\tget_online_cpus();\n\tget_online_mems();\n\n\tmutex_lock(&slab_mutex);\n\tlist_for_each_entry_safe(s, s2, &memcg->kmem_caches,\n\t\t\t\t memcg_params.kmem_caches_node) {\n\t\t/*\n\t\t * The cgroup is about to be freed and therefore has no charges\n\t\t * left. Hence, all its caches must be empty by now.\n\t\t */\n\t\tBUG_ON(shutdown_cache(s));\n\t}\n\tmutex_unlock(&slab_mutex);\n\n\tput_online_mems();\n\tput_online_cpus();\n}"
  },
  {
    "function_name": "memcg_deactivate_kmem_caches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "730-756",
    "snippet": "void memcg_deactivate_kmem_caches(struct mem_cgroup *memcg)\n{\n\tint idx;\n\tstruct memcg_cache_array *arr;\n\tstruct kmem_cache *s, *c;\n\n\tidx = memcg_cache_id(memcg);\n\n\tget_online_cpus();\n\tget_online_mems();\n\n\tmutex_lock(&slab_mutex);\n\tlist_for_each_entry(s, &slab_root_caches, root_caches_node) {\n\t\tarr = rcu_dereference_protected(s->memcg_params.memcg_caches,\n\t\t\t\t\t\tlockdep_is_held(&slab_mutex));\n\t\tc = arr->entries[idx];\n\t\tif (!c)\n\t\t\tcontinue;\n\n\t\t__kmemcg_cache_deactivate(c);\n\t\tarr->entries[idx] = NULL;\n\t}\n\tmutex_unlock(&slab_mutex);\n\n\tput_online_mems();\n\tput_online_cpus();\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_online_cpus",
          "args": [],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_online_mems",
          "args": [],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "put_online_mems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "61-64",
          "snippet": "void put_online_mems(void)\n{\n\tpercpu_up_read(&mem_hotplug_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid put_online_mems(void)\n{\n\tpercpu_up_read(&mem_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&slab_mutex"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kmemcg_cache_deactivate",
          "args": [
            "c"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "__kmemcg_cache_deactivate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2323-2326",
          "snippet": "void __kmemcg_cache_deactivate(struct kmem_cache *cachep)\n{\n\t__kmem_cache_shrink(cachep);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid __kmemcg_cache_deactivate(struct kmem_cache *cachep)\n{\n\t__kmem_cache_shrink(cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "s->memcg_params.memcg_caches",
            "lockdep_is_held(&slab_mutex)"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&slab_mutex"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "s",
            "&slab_root_caches",
            "root_caches_node"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&slab_mutex"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_online_mems",
          "args": [],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "get_online_mems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "56-59",
          "snippet": "void get_online_mems(void)\n{\n\tpercpu_down_read(&mem_hotplug_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid get_online_mems(void)\n{\n\tpercpu_down_read(&mem_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_online_cpus",
          "args": [],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_cache_id",
          "args": [
            "memcg"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nvoid memcg_deactivate_kmem_caches(struct mem_cgroup *memcg)\n{\n\tint idx;\n\tstruct memcg_cache_array *arr;\n\tstruct kmem_cache *s, *c;\n\n\tidx = memcg_cache_id(memcg);\n\n\tget_online_cpus();\n\tget_online_mems();\n\n\tmutex_lock(&slab_mutex);\n\tlist_for_each_entry(s, &slab_root_caches, root_caches_node) {\n\t\tarr = rcu_dereference_protected(s->memcg_params.memcg_caches,\n\t\t\t\t\t\tlockdep_is_held(&slab_mutex));\n\t\tc = arr->entries[idx];\n\t\tif (!c)\n\t\t\tcontinue;\n\n\t\t__kmemcg_cache_deactivate(c);\n\t\tarr->entries[idx] = NULL;\n\t}\n\tmutex_unlock(&slab_mutex);\n\n\tput_online_mems();\n\tput_online_cpus();\n}"
  },
  {
    "function_name": "slab_deactivate_memcg_cache_rcu_sched",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "713-728",
    "snippet": "void slab_deactivate_memcg_cache_rcu_sched(struct kmem_cache *s,\n\t\t\t\t\t   void (*deact_fn)(struct kmem_cache *))\n{\n\tif (WARN_ON_ONCE(is_root_cache(s)) ||\n\t    WARN_ON_ONCE(s->memcg_params.deact_fn))\n\t\treturn;\n\n\tif (s->memcg_params.root_cache->memcg_params.dying)\n\t\treturn;\n\n\t/* pin memcg so that @s doesn't get destroyed in the middle */\n\tcss_get(&s->memcg_params.memcg->css);\n\n\ts->memcg_params.deact_fn = deact_fn;\n\tcall_rcu_sched(&s->memcg_params.deact_rcu_head, kmemcg_deactivate_rcufn);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu_sched",
          "args": [
            "&s->memcg_params.deact_rcu_head",
            "kmemcg_deactivate_rcufn"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_get",
          "args": [
            "&s->memcg_params.memcg->css"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "s->memcg_params.deact_fn"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "is_root_cache(s)"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_root_cache",
          "args": [
            "s"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "is_root_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "308-311",
          "snippet": "static inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn true;\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nvoid slab_deactivate_memcg_cache_rcu_sched(struct kmem_cache *s,\n\t\t\t\t\t   void (*deact_fn)(struct kmem_cache *))\n{\n\tif (WARN_ON_ONCE(is_root_cache(s)) ||\n\t    WARN_ON_ONCE(s->memcg_params.deact_fn))\n\t\treturn;\n\n\tif (s->memcg_params.root_cache->memcg_params.dying)\n\t\treturn;\n\n\t/* pin memcg so that @s doesn't get destroyed in the middle */\n\tcss_get(&s->memcg_params.memcg->css);\n\n\ts->memcg_params.deact_fn = deact_fn;\n\tcall_rcu_sched(&s->memcg_params.deact_rcu_head, kmemcg_deactivate_rcufn);\n}"
  },
  {
    "function_name": "kmemcg_deactivate_rcufn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "688-700",
    "snippet": "static void kmemcg_deactivate_rcufn(struct rcu_head *head)\n{\n\tstruct kmem_cache *s = container_of(head, struct kmem_cache,\n\t\t\t\t\t    memcg_params.deact_rcu_head);\n\n\t/*\n\t * We need to grab blocking locks.  Bounce to ->deact_work.  The\n\t * work item shares the space with the RCU head and can't be\n\t * initialized eariler.\n\t */\n\tINIT_WORK(&s->memcg_params.deact_work, kmemcg_deactivate_workfn);\n\tqueue_work(memcg_kmem_cache_wq, &s->memcg_params.deact_work);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;",
      "static void slab_caches_to_rcu_destroy_workfn(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "memcg_kmem_cache_wq",
            "&s->memcg_params.deact_work"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&s->memcg_params.deact_work",
            "kmemcg_deactivate_workfn"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structkmem_cache",
            "memcg_params.deact_rcu_head"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\nstatic void slab_caches_to_rcu_destroy_workfn(struct work_struct *work);\n\nstatic void kmemcg_deactivate_rcufn(struct rcu_head *head)\n{\n\tstruct kmem_cache *s = container_of(head, struct kmem_cache,\n\t\t\t\t\t    memcg_params.deact_rcu_head);\n\n\t/*\n\t * We need to grab blocking locks.  Bounce to ->deact_work.  The\n\t * work item shares the space with the RCU head and can't be\n\t * initialized eariler.\n\t */\n\tINIT_WORK(&s->memcg_params.deact_work, kmemcg_deactivate_workfn);\n\tqueue_work(memcg_kmem_cache_wq, &s->memcg_params.deact_work);\n}"
  },
  {
    "function_name": "kmemcg_deactivate_workfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "667-686",
    "snippet": "static void kmemcg_deactivate_workfn(struct work_struct *work)\n{\n\tstruct kmem_cache *s = container_of(work, struct kmem_cache,\n\t\t\t\t\t    memcg_params.deact_work);\n\n\tget_online_cpus();\n\tget_online_mems();\n\n\tmutex_lock(&slab_mutex);\n\n\ts->memcg_params.deact_fn(s);\n\n\tmutex_unlock(&slab_mutex);\n\n\tput_online_mems();\n\tput_online_cpus();\n\n\t/* done, put the ref from slab_deactivate_memcg_cache_rcu_sched() */\n\tcss_put(&s->memcg_params.memcg->css);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;",
      "static void slab_caches_to_rcu_destroy_workfn(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_put",
          "args": [
            "&s->memcg_params.memcg->css"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_online_cpus",
          "args": [],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_online_mems",
          "args": [],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "put_online_mems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "61-64",
          "snippet": "void put_online_mems(void)\n{\n\tpercpu_up_read(&mem_hotplug_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid put_online_mems(void)\n{\n\tpercpu_up_read(&mem_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&slab_mutex"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s->memcg_params.deact_fn",
          "args": [
            "s"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&slab_mutex"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_online_mems",
          "args": [],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "get_online_mems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "56-59",
          "snippet": "void get_online_mems(void)\n{\n\tpercpu_down_read(&mem_hotplug_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid get_online_mems(void)\n{\n\tpercpu_down_read(&mem_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_online_cpus",
          "args": [],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structkmem_cache",
            "memcg_params.deact_work"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\nstatic void slab_caches_to_rcu_destroy_workfn(struct work_struct *work);\n\nstatic void kmemcg_deactivate_workfn(struct work_struct *work)\n{\n\tstruct kmem_cache *s = container_of(work, struct kmem_cache,\n\t\t\t\t\t    memcg_params.deact_work);\n\n\tget_online_cpus();\n\tget_online_mems();\n\n\tmutex_lock(&slab_mutex);\n\n\ts->memcg_params.deact_fn(s);\n\n\tmutex_unlock(&slab_mutex);\n\n\tput_online_mems();\n\tput_online_cpus();\n\n\t/* done, put the ref from slab_deactivate_memcg_cache_rcu_sched() */\n\tcss_put(&s->memcg_params.memcg->css);\n}"
  },
  {
    "function_name": "memcg_create_kmem_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "597-665",
    "snippet": "void memcg_create_kmem_cache(struct mem_cgroup *memcg,\n\t\t\t     struct kmem_cache *root_cache)\n{\n\tstatic char memcg_name_buf[NAME_MAX + 1]; /* protected by slab_mutex */\n\tstruct cgroup_subsys_state *css = &memcg->css;\n\tstruct memcg_cache_array *arr;\n\tstruct kmem_cache *s = NULL;\n\tchar *cache_name;\n\tint idx;\n\n\tget_online_cpus();\n\tget_online_mems();\n\n\tmutex_lock(&slab_mutex);\n\n\t/*\n\t * The memory cgroup could have been offlined while the cache\n\t * creation work was pending.\n\t */\n\tif (memcg->kmem_state != KMEM_ONLINE || root_cache->memcg_params.dying)\n\t\tgoto out_unlock;\n\n\tidx = memcg_cache_id(memcg);\n\tarr = rcu_dereference_protected(root_cache->memcg_params.memcg_caches,\n\t\t\t\t\tlockdep_is_held(&slab_mutex));\n\n\t/*\n\t * Since per-memcg caches are created asynchronously on first\n\t * allocation (see memcg_kmem_get_cache()), several threads can try to\n\t * create the same cache, but only one of them may succeed.\n\t */\n\tif (arr->entries[idx])\n\t\tgoto out_unlock;\n\n\tcgroup_name(css->cgroup, memcg_name_buf, sizeof(memcg_name_buf));\n\tcache_name = kasprintf(GFP_KERNEL, \"%s(%llu:%s)\", root_cache->name,\n\t\t\t       css->serial_nr, memcg_name_buf);\n\tif (!cache_name)\n\t\tgoto out_unlock;\n\n\ts = create_cache(cache_name, root_cache->object_size,\n\t\t\t root_cache->align,\n\t\t\t root_cache->flags & CACHE_CREATE_MASK,\n\t\t\t root_cache->useroffset, root_cache->usersize,\n\t\t\t root_cache->ctor, memcg, root_cache);\n\t/*\n\t * If we could not create a memcg cache, do not complain, because\n\t * that's not critical at all as we can always proceed with the root\n\t * cache.\n\t */\n\tif (IS_ERR(s)) {\n\t\tkfree(cache_name);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Since readers won't lock (see cache_from_memcg_idx()), we need a\n\t * barrier here to ensure nobody will see the kmem_cache partially\n\t * initialized.\n\t */\n\tsmp_wmb();\n\tarr->entries[idx] = s;\n\nout_unlock:\n\tmutex_unlock(&slab_mutex);\n\n\tput_online_mems();\n\tput_online_cpus();\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;",
      "static void slab_caches_to_rcu_destroy_workfn(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_online_cpus",
          "args": [],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_online_mems",
          "args": [],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "put_online_mems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "61-64",
          "snippet": "void put_online_mems(void)\n{\n\tpercpu_up_read(&mem_hotplug_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid put_online_mems(void)\n{\n\tpercpu_up_read(&mem_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&slab_mutex"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cache_name"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "s"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_cache",
          "args": [
            "cache_name",
            "root_cache->object_size",
            "root_cache->align",
            "root_cache->flags & CACHE_CREATE_MASK",
            "root_cache->useroffset",
            "root_cache->usersize",
            "root_cache->ctor",
            "memcg",
            "root_cache"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "create_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "363-407",
          "snippet": "static struct kmem_cache *create_cache(const char *name,\n\t\tunsigned int object_size, unsigned int align,\n\t\tslab_flags_t flags, unsigned int useroffset,\n\t\tunsigned int usersize, void (*ctor)(void *),\n\t\tstruct mem_cgroup *memcg, struct kmem_cache *root_cache)\n{\n\tstruct kmem_cache *s;\n\tint err;\n\n\tif (WARN_ON(useroffset + usersize > object_size))\n\t\tuseroffset = usersize = 0;\n\n\terr = -ENOMEM;\n\ts = kmem_cache_zalloc(kmem_cache, GFP_KERNEL);\n\tif (!s)\n\t\tgoto out;\n\n\ts->name = name;\n\ts->size = s->object_size = object_size;\n\ts->align = align;\n\ts->ctor = ctor;\n\ts->useroffset = useroffset;\n\ts->usersize = usersize;\n\n\terr = init_memcg_params(s, memcg, root_cache);\n\tif (err)\n\t\tgoto out_free_cache;\n\n\terr = __kmem_cache_create(s, flags);\n\tif (err)\n\t\tgoto out_free_cache;\n\n\ts->refcount = 1;\n\tlist_add(&s->list, &slab_caches);\n\tmemcg_link_cache(s);\nout:\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn s;\n\nout_free_cache:\n\tdestroy_memcg_params(s);\n\tkmem_cache_free(kmem_cache, s);\n\tgoto out;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstatic struct kmem_cache *create_cache(const char *name,\n\t\tunsigned int object_size, unsigned int align,\n\t\tslab_flags_t flags, unsigned int useroffset,\n\t\tunsigned int usersize, void (*ctor)(void *),\n\t\tstruct mem_cgroup *memcg, struct kmem_cache *root_cache)\n{\n\tstruct kmem_cache *s;\n\tint err;\n\n\tif (WARN_ON(useroffset + usersize > object_size))\n\t\tuseroffset = usersize = 0;\n\n\terr = -ENOMEM;\n\ts = kmem_cache_zalloc(kmem_cache, GFP_KERNEL);\n\tif (!s)\n\t\tgoto out;\n\n\ts->name = name;\n\ts->size = s->object_size = object_size;\n\ts->align = align;\n\ts->ctor = ctor;\n\ts->useroffset = useroffset;\n\ts->usersize = usersize;\n\n\terr = init_memcg_params(s, memcg, root_cache);\n\tif (err)\n\t\tgoto out_free_cache;\n\n\terr = __kmem_cache_create(s, flags);\n\tif (err)\n\t\tgoto out_free_cache;\n\n\ts->refcount = 1;\n\tlist_add(&s->list, &slab_caches);\n\tmemcg_link_cache(s);\nout:\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn s;\n\nout_free_cache:\n\tdestroy_memcg_params(s);\n\tkmem_cache_free(kmem_cache, s);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kasprintf",
          "args": [
            "GFP_KERNEL",
            "\"%s(%llu:%s)\"",
            "root_cache->name",
            "css->serial_nr",
            "memcg_name_buf"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_name",
          "args": [
            "css->cgroup",
            "memcg_name_buf",
            "sizeof(memcg_name_buf)"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "root_cache->memcg_params.memcg_caches",
            "lockdep_is_held(&slab_mutex)"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&slab_mutex"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_cache_id",
          "args": [
            "memcg"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&slab_mutex"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_online_mems",
          "args": [],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "get_online_mems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "56-59",
          "snippet": "void get_online_mems(void)\n{\n\tpercpu_down_read(&mem_hotplug_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid get_online_mems(void)\n{\n\tpercpu_down_read(&mem_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_online_cpus",
          "args": [],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\nstatic void slab_caches_to_rcu_destroy_workfn(struct work_struct *work);\n\nvoid memcg_create_kmem_cache(struct mem_cgroup *memcg,\n\t\t\t     struct kmem_cache *root_cache)\n{\n\tstatic char memcg_name_buf[NAME_MAX + 1]; /* protected by slab_mutex */\n\tstruct cgroup_subsys_state *css = &memcg->css;\n\tstruct memcg_cache_array *arr;\n\tstruct kmem_cache *s = NULL;\n\tchar *cache_name;\n\tint idx;\n\n\tget_online_cpus();\n\tget_online_mems();\n\n\tmutex_lock(&slab_mutex);\n\n\t/*\n\t * The memory cgroup could have been offlined while the cache\n\t * creation work was pending.\n\t */\n\tif (memcg->kmem_state != KMEM_ONLINE || root_cache->memcg_params.dying)\n\t\tgoto out_unlock;\n\n\tidx = memcg_cache_id(memcg);\n\tarr = rcu_dereference_protected(root_cache->memcg_params.memcg_caches,\n\t\t\t\t\tlockdep_is_held(&slab_mutex));\n\n\t/*\n\t * Since per-memcg caches are created asynchronously on first\n\t * allocation (see memcg_kmem_get_cache()), several threads can try to\n\t * create the same cache, but only one of them may succeed.\n\t */\n\tif (arr->entries[idx])\n\t\tgoto out_unlock;\n\n\tcgroup_name(css->cgroup, memcg_name_buf, sizeof(memcg_name_buf));\n\tcache_name = kasprintf(GFP_KERNEL, \"%s(%llu:%s)\", root_cache->name,\n\t\t\t       css->serial_nr, memcg_name_buf);\n\tif (!cache_name)\n\t\tgoto out_unlock;\n\n\ts = create_cache(cache_name, root_cache->object_size,\n\t\t\t root_cache->align,\n\t\t\t root_cache->flags & CACHE_CREATE_MASK,\n\t\t\t root_cache->useroffset, root_cache->usersize,\n\t\t\t root_cache->ctor, memcg, root_cache);\n\t/*\n\t * If we could not create a memcg cache, do not complain, because\n\t * that's not critical at all as we can always proceed with the root\n\t * cache.\n\t */\n\tif (IS_ERR(s)) {\n\t\tkfree(cache_name);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Since readers won't lock (see cache_from_memcg_idx()), we need a\n\t * barrier here to ensure nobody will see the kmem_cache partially\n\t * initialized.\n\t */\n\tsmp_wmb();\n\tarr->entries[idx] = s;\n\nout_unlock:\n\tmutex_unlock(&slab_mutex);\n\n\tput_online_mems();\n\tput_online_cpus();\n}"
  },
  {
    "function_name": "shutdown_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "558-585",
    "snippet": "static int shutdown_cache(struct kmem_cache *s)\n{\n\t/* free asan quarantined objects */\n\tkasan_cache_shutdown(s);\n\n\tif (__kmem_cache_shutdown(s) != 0)\n\t\treturn -EBUSY;\n\n\tmemcg_unlink_cache(s);\n\tlist_del(&s->list);\n\n\tif (s->flags & SLAB_TYPESAFE_BY_RCU) {\n#ifdef SLAB_SUPPORTS_SYSFS\n\t\tsysfs_slab_unlink(s);\n#endif\n\t\tlist_add_tail(&s->list, &slab_caches_to_rcu_destroy);\n\t\tschedule_work(&slab_caches_to_rcu_destroy_work);\n\t} else {\n#ifdef SLAB_SUPPORTS_SYSFS\n\t\tsysfs_slab_unlink(s);\n\t\tsysfs_slab_release(s);\n#else\n\t\tslab_kmem_cache_release(s);\n#endif\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;",
      "static LIST_HEAD(slab_caches_to_rcu_destroy);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slab_kmem_cache_release",
          "args": [
            "s"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "slab_kmem_cache_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "866-872",
          "snippet": "void slab_kmem_cache_release(struct kmem_cache *s)\n{\n\t__kmem_cache_release(s);\n\tdestroy_memcg_params(s);\n\tkfree_const(s->name);\n\tkmem_cache_free(kmem_cache, s);\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nvoid slab_kmem_cache_release(struct kmem_cache *s)\n{\n\t__kmem_cache_release(s);\n\tdestroy_memcg_params(s);\n\tkfree_const(s->name);\n\tkmem_cache_free(kmem_cache, s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysfs_slab_release",
          "args": [
            "s"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_slab_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "5791-5795",
          "snippet": "void sysfs_slab_release(struct kmem_cache *s)\n{\n\tif (slab_state >= FULL)\n\t\tkobject_put(&s->kobj);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid sysfs_slab_release(struct kmem_cache *s)\n{\n\tif (slab_state >= FULL)\n\t\tkobject_put(&s->kobj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysfs_slab_unlink",
          "args": [
            "s"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_slab_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "5785-5789",
          "snippet": "void sysfs_slab_unlink(struct kmem_cache *s)\n{\n\tif (slab_state >= FULL)\n\t\tkobject_del(&s->kobj);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid sysfs_slab_unlink(struct kmem_cache *s)\n{\n\tif (slab_state >= FULL)\n\t\tkobject_del(&s->kobj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&slab_caches_to_rcu_destroy_work"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&s->list",
            "&slab_caches_to_rcu_destroy"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&s->list"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_unlink_cache",
          "args": [
            "s"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_unlink_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "256-258",
          "snippet": "static inline void memcg_unlink_cache(struct kmem_cache *s)\n{\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstatic inline void memcg_unlink_cache(struct kmem_cache *s)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "__kmem_cache_shutdown",
          "args": [
            "s"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "__kmem_cache_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "2329-2332",
          "snippet": "int __kmem_cache_shutdown(struct kmem_cache *cachep)\n{\n\treturn __kmem_cache_shrink(cachep);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nint __kmem_cache_shutdown(struct kmem_cache *cachep)\n{\n\treturn __kmem_cache_shrink(cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kasan_cache_shutdown",
          "args": [
            "s"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_cache_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "383-387",
          "snippet": "void kasan_cache_shutdown(struct kmem_cache *cache)\n{\n\tif (!__kmem_cache_empty(cache))\n\t\tquarantine_remove_cache(cache);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\nvoid kasan_cache_shutdown(struct kmem_cache *cache)\n{\n\tif (!__kmem_cache_empty(cache))\n\t\tquarantine_remove_cache(cache);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\nstatic LIST_HEAD(slab_caches_to_rcu_destroy);\n\nstatic int shutdown_cache(struct kmem_cache *s)\n{\n\t/* free asan quarantined objects */\n\tkasan_cache_shutdown(s);\n\n\tif (__kmem_cache_shutdown(s) != 0)\n\t\treturn -EBUSY;\n\n\tmemcg_unlink_cache(s);\n\tlist_del(&s->list);\n\n\tif (s->flags & SLAB_TYPESAFE_BY_RCU) {\n#ifdef SLAB_SUPPORTS_SYSFS\n\t\tsysfs_slab_unlink(s);\n#endif\n\t\tlist_add_tail(&s->list, &slab_caches_to_rcu_destroy);\n\t\tschedule_work(&slab_caches_to_rcu_destroy_work);\n\t} else {\n#ifdef SLAB_SUPPORTS_SYSFS\n\t\tsysfs_slab_unlink(s);\n\t\tsysfs_slab_release(s);\n#else\n\t\tslab_kmem_cache_release(s);\n#endif\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "slab_caches_to_rcu_destroy_workfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "526-556",
    "snippet": "static void slab_caches_to_rcu_destroy_workfn(struct work_struct *work)\n{\n\tLIST_HEAD(to_destroy);\n\tstruct kmem_cache *s, *s2;\n\n\t/*\n\t * On destruction, SLAB_TYPESAFE_BY_RCU kmem_caches are put on the\n\t * @slab_caches_to_rcu_destroy list.  The slab pages are freed\n\t * through RCU and and the associated kmem_cache are dereferenced\n\t * while freeing the pages, so the kmem_caches should be freed only\n\t * after the pending RCU operations are finished.  As rcu_barrier()\n\t * is a pretty slow operation, we batch all pending destructions\n\t * asynchronously.\n\t */\n\tmutex_lock(&slab_mutex);\n\tlist_splice_init(&slab_caches_to_rcu_destroy, &to_destroy);\n\tmutex_unlock(&slab_mutex);\n\n\tif (list_empty(&to_destroy))\n\t\treturn;\n\n\trcu_barrier();\n\n\tlist_for_each_entry_safe(s, s2, &to_destroy, list) {\n#ifdef SLAB_SUPPORTS_SYSFS\n\t\tsysfs_slab_release(s);\n#else\n\t\tslab_kmem_cache_release(s);\n#endif\n\t}\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;",
      "static LIST_HEAD(slab_caches_to_rcu_destroy);",
      "static void slab_caches_to_rcu_destroy_workfn(struct work_struct *work);",
      "static DECLARE_WORK(slab_caches_to_rcu_destroy_work,\n\t\t    slab_caches_to_rcu_destroy_workfn);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slab_kmem_cache_release",
          "args": [
            "s"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "slab_kmem_cache_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "866-872",
          "snippet": "void slab_kmem_cache_release(struct kmem_cache *s)\n{\n\t__kmem_cache_release(s);\n\tdestroy_memcg_params(s);\n\tkfree_const(s->name);\n\tkmem_cache_free(kmem_cache, s);\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nvoid slab_kmem_cache_release(struct kmem_cache *s)\n{\n\t__kmem_cache_release(s);\n\tdestroy_memcg_params(s);\n\tkfree_const(s->name);\n\tkmem_cache_free(kmem_cache, s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysfs_slab_release",
          "args": [
            "s"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_slab_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "5791-5795",
          "snippet": "void sysfs_slab_release(struct kmem_cache *s)\n{\n\tif (slab_state >= FULL)\n\t\tkobject_put(&s->kobj);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nvoid sysfs_slab_release(struct kmem_cache *s)\n{\n\tif (slab_state >= FULL)\n\t\tkobject_put(&s->kobj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "s",
            "s2",
            "&to_destroy",
            "list"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&to_destroy"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&slab_mutex"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice_init",
          "args": [
            "&slab_caches_to_rcu_destroy",
            "&to_destroy"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&slab_mutex"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "to_destroy"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\nstatic LIST_HEAD(slab_caches_to_rcu_destroy);\nstatic void slab_caches_to_rcu_destroy_workfn(struct work_struct *work);\nstatic DECLARE_WORK(slab_caches_to_rcu_destroy_work,\n\t\t    slab_caches_to_rcu_destroy_workfn);\n\nstatic void slab_caches_to_rcu_destroy_workfn(struct work_struct *work)\n{\n\tLIST_HEAD(to_destroy);\n\tstruct kmem_cache *s, *s2;\n\n\t/*\n\t * On destruction, SLAB_TYPESAFE_BY_RCU kmem_caches are put on the\n\t * @slab_caches_to_rcu_destroy list.  The slab pages are freed\n\t * through RCU and and the associated kmem_cache are dereferenced\n\t * while freeing the pages, so the kmem_caches should be freed only\n\t * after the pending RCU operations are finished.  As rcu_barrier()\n\t * is a pretty slow operation, we batch all pending destructions\n\t * asynchronously.\n\t */\n\tmutex_lock(&slab_mutex);\n\tlist_splice_init(&slab_caches_to_rcu_destroy, &to_destroy);\n\tmutex_unlock(&slab_mutex);\n\n\tif (list_empty(&to_destroy))\n\t\treturn;\n\n\trcu_barrier();\n\n\tlist_for_each_entry_safe(s, s2, &to_destroy, list) {\n#ifdef SLAB_SUPPORTS_SYSFS\n\t\tsysfs_slab_release(s);\n#else\n\t\tslab_kmem_cache_release(s);\n#endif\n\t}\n}"
  },
  {
    "function_name": "kmem_cache_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "517-523",
    "snippet": "struct kmem_cache *\nkmem_cache_create(const char *name, unsigned int size, unsigned int align,\n\t\tslab_flags_t flags, void (*ctor)(void *))\n{\n\treturn kmem_cache_create_usercopy(name, size, align, flags, 0, 0,\n\t\t\t\t\t  ctor);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create_usercopy",
          "args": [
            "name",
            "size",
            "align",
            "flags",
            "0",
            "0",
            "ctor"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_create_usercopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "435-514",
          "snippet": "struct kmem_cache *\nkmem_cache_create_usercopy(const char *name,\n\t\t  unsigned int size, unsigned int align,\n\t\t  slab_flags_t flags,\n\t\t  unsigned int useroffset, unsigned int usersize,\n\t\t  void (*ctor)(void *))\n{\n\tstruct kmem_cache *s = NULL;\n\tconst char *cache_name;\n\tint err;\n\n\tget_online_cpus();\n\tget_online_mems();\n\tmemcg_get_cache_ids();\n\n\tmutex_lock(&slab_mutex);\n\n\terr = kmem_cache_sanity_check(name, size);\n\tif (err) {\n\t\tgoto out_unlock;\n\t}\n\n\t/* Refuse requests with allocator specific flags */\n\tif (flags & ~SLAB_FLAGS_PERMITTED) {\n\t\terr = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Some allocators will constraint the set of valid flags to a subset\n\t * of all flags. We expect them to define CACHE_CREATE_MASK in this\n\t * case, and we'll just provide them with a sanitized version of the\n\t * passed flags.\n\t */\n\tflags &= CACHE_CREATE_MASK;\n\n\t/* Fail closed on bad usersize of useroffset values. */\n\tif (WARN_ON(!usersize && useroffset) ||\n\t    WARN_ON(size < usersize || size - usersize < useroffset))\n\t\tusersize = useroffset = 0;\n\n\tif (!usersize)\n\t\ts = __kmem_cache_alias(name, size, align, flags, ctor);\n\tif (s)\n\t\tgoto out_unlock;\n\n\tcache_name = kstrdup_const(name, GFP_KERNEL);\n\tif (!cache_name) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\ts = create_cache(cache_name, size,\n\t\t\t calculate_alignment(flags, align, size),\n\t\t\t flags, useroffset, usersize, ctor, NULL, NULL);\n\tif (IS_ERR(s)) {\n\t\terr = PTR_ERR(s);\n\t\tkfree_const(cache_name);\n\t}\n\nout_unlock:\n\tmutex_unlock(&slab_mutex);\n\n\tmemcg_put_cache_ids();\n\tput_online_mems();\n\tput_online_cpus();\n\n\tif (err) {\n\t\tif (flags & SLAB_PANIC)\n\t\t\tpanic(\"kmem_cache_create: Failed to create slab '%s'. Error %d\\n\",\n\t\t\t\tname, err);\n\t\telse {\n\t\t\tpr_warn(\"kmem_cache_create(%s) failed with error %d\\n\",\n\t\t\t\tname, err);\n\t\t\tdump_stack();\n\t\t}\n\t\treturn NULL;\n\t}\n\treturn s;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstruct kmem_cache *\nkmem_cache_create_usercopy(const char *name,\n\t\t  unsigned int size, unsigned int align,\n\t\t  slab_flags_t flags,\n\t\t  unsigned int useroffset, unsigned int usersize,\n\t\t  void (*ctor)(void *))\n{\n\tstruct kmem_cache *s = NULL;\n\tconst char *cache_name;\n\tint err;\n\n\tget_online_cpus();\n\tget_online_mems();\n\tmemcg_get_cache_ids();\n\n\tmutex_lock(&slab_mutex);\n\n\terr = kmem_cache_sanity_check(name, size);\n\tif (err) {\n\t\tgoto out_unlock;\n\t}\n\n\t/* Refuse requests with allocator specific flags */\n\tif (flags & ~SLAB_FLAGS_PERMITTED) {\n\t\terr = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Some allocators will constraint the set of valid flags to a subset\n\t * of all flags. We expect them to define CACHE_CREATE_MASK in this\n\t * case, and we'll just provide them with a sanitized version of the\n\t * passed flags.\n\t */\n\tflags &= CACHE_CREATE_MASK;\n\n\t/* Fail closed on bad usersize of useroffset values. */\n\tif (WARN_ON(!usersize && useroffset) ||\n\t    WARN_ON(size < usersize || size - usersize < useroffset))\n\t\tusersize = useroffset = 0;\n\n\tif (!usersize)\n\t\ts = __kmem_cache_alias(name, size, align, flags, ctor);\n\tif (s)\n\t\tgoto out_unlock;\n\n\tcache_name = kstrdup_const(name, GFP_KERNEL);\n\tif (!cache_name) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\ts = create_cache(cache_name, size,\n\t\t\t calculate_alignment(flags, align, size),\n\t\t\t flags, useroffset, usersize, ctor, NULL, NULL);\n\tif (IS_ERR(s)) {\n\t\terr = PTR_ERR(s);\n\t\tkfree_const(cache_name);\n\t}\n\nout_unlock:\n\tmutex_unlock(&slab_mutex);\n\n\tmemcg_put_cache_ids();\n\tput_online_mems();\n\tput_online_cpus();\n\n\tif (err) {\n\t\tif (flags & SLAB_PANIC)\n\t\t\tpanic(\"kmem_cache_create: Failed to create slab '%s'. Error %d\\n\",\n\t\t\t\tname, err);\n\t\telse {\n\t\t\tpr_warn(\"kmem_cache_create(%s) failed with error %d\\n\",\n\t\t\t\tname, err);\n\t\t\tdump_stack();\n\t\t}\n\t\treturn NULL;\n\t}\n\treturn s;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstruct kmem_cache *\nkmem_cache_create(const char *name, unsigned int size, unsigned int align,\n\t\tslab_flags_t flags, void (*ctor)(void *))\n{\n\treturn kmem_cache_create_usercopy(name, size, align, flags, 0, 0,\n\t\t\t\t\t  ctor);\n}"
  },
  {
    "function_name": "kmem_cache_create_usercopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "435-514",
    "snippet": "struct kmem_cache *\nkmem_cache_create_usercopy(const char *name,\n\t\t  unsigned int size, unsigned int align,\n\t\t  slab_flags_t flags,\n\t\t  unsigned int useroffset, unsigned int usersize,\n\t\t  void (*ctor)(void *))\n{\n\tstruct kmem_cache *s = NULL;\n\tconst char *cache_name;\n\tint err;\n\n\tget_online_cpus();\n\tget_online_mems();\n\tmemcg_get_cache_ids();\n\n\tmutex_lock(&slab_mutex);\n\n\terr = kmem_cache_sanity_check(name, size);\n\tif (err) {\n\t\tgoto out_unlock;\n\t}\n\n\t/* Refuse requests with allocator specific flags */\n\tif (flags & ~SLAB_FLAGS_PERMITTED) {\n\t\terr = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Some allocators will constraint the set of valid flags to a subset\n\t * of all flags. We expect them to define CACHE_CREATE_MASK in this\n\t * case, and we'll just provide them with a sanitized version of the\n\t * passed flags.\n\t */\n\tflags &= CACHE_CREATE_MASK;\n\n\t/* Fail closed on bad usersize of useroffset values. */\n\tif (WARN_ON(!usersize && useroffset) ||\n\t    WARN_ON(size < usersize || size - usersize < useroffset))\n\t\tusersize = useroffset = 0;\n\n\tif (!usersize)\n\t\ts = __kmem_cache_alias(name, size, align, flags, ctor);\n\tif (s)\n\t\tgoto out_unlock;\n\n\tcache_name = kstrdup_const(name, GFP_KERNEL);\n\tif (!cache_name) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\ts = create_cache(cache_name, size,\n\t\t\t calculate_alignment(flags, align, size),\n\t\t\t flags, useroffset, usersize, ctor, NULL, NULL);\n\tif (IS_ERR(s)) {\n\t\terr = PTR_ERR(s);\n\t\tkfree_const(cache_name);\n\t}\n\nout_unlock:\n\tmutex_unlock(&slab_mutex);\n\n\tmemcg_put_cache_ids();\n\tput_online_mems();\n\tput_online_cpus();\n\n\tif (err) {\n\t\tif (flags & SLAB_PANIC)\n\t\t\tpanic(\"kmem_cache_create: Failed to create slab '%s'. Error %d\\n\",\n\t\t\t\tname, err);\n\t\telse {\n\t\t\tpr_warn(\"kmem_cache_create(%s) failed with error %d\\n\",\n\t\t\t\tname, err);\n\t\t\tdump_stack();\n\t\t}\n\t\treturn NULL;\n\t}\n\treturn s;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"kmem_cache_create(%s) failed with error %d\\n\"",
            "name",
            "err"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"kmem_cache_create: Failed to create slab '%s'. Error %d\\n\"",
            "name",
            "err"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_online_cpus",
          "args": [],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_online_mems",
          "args": [],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "put_online_mems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "61-64",
          "snippet": "void put_online_mems(void)\n{\n\tpercpu_up_read(&mem_hotplug_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid put_online_mems(void)\n{\n\tpercpu_up_read(&mem_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_put_cache_ids",
          "args": [],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_put_cache_ids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "287-290",
          "snippet": "void memcg_put_cache_ids(void)\n{\n\tup_read(&memcg_cache_ids_sem);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nvoid memcg_put_cache_ids(void)\n{\n\tup_read(&memcg_cache_ids_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&slab_mutex"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree_const",
          "args": [
            "cache_name"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_const",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "28-32",
          "snippet": "void kfree_const(const void *x)\n{\n\tif (!is_kernel_rodata((unsigned long)x))\n\t\tkfree(x);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid kfree_const(const void *x)\n{\n\tif (!is_kernel_rodata((unsigned long)x))\n\t\tkfree(x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "s"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "s"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_cache",
          "args": [
            "cache_name",
            "size",
            "calculate_alignment(flags, align, size)",
            "flags",
            "useroffset",
            "usersize",
            "ctor",
            "NULL",
            "NULL"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "create_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "363-407",
          "snippet": "static struct kmem_cache *create_cache(const char *name,\n\t\tunsigned int object_size, unsigned int align,\n\t\tslab_flags_t flags, unsigned int useroffset,\n\t\tunsigned int usersize, void (*ctor)(void *),\n\t\tstruct mem_cgroup *memcg, struct kmem_cache *root_cache)\n{\n\tstruct kmem_cache *s;\n\tint err;\n\n\tif (WARN_ON(useroffset + usersize > object_size))\n\t\tuseroffset = usersize = 0;\n\n\terr = -ENOMEM;\n\ts = kmem_cache_zalloc(kmem_cache, GFP_KERNEL);\n\tif (!s)\n\t\tgoto out;\n\n\ts->name = name;\n\ts->size = s->object_size = object_size;\n\ts->align = align;\n\ts->ctor = ctor;\n\ts->useroffset = useroffset;\n\ts->usersize = usersize;\n\n\terr = init_memcg_params(s, memcg, root_cache);\n\tif (err)\n\t\tgoto out_free_cache;\n\n\terr = __kmem_cache_create(s, flags);\n\tif (err)\n\t\tgoto out_free_cache;\n\n\ts->refcount = 1;\n\tlist_add(&s->list, &slab_caches);\n\tmemcg_link_cache(s);\nout:\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn s;\n\nout_free_cache:\n\tdestroy_memcg_params(s);\n\tkmem_cache_free(kmem_cache, s);\n\tgoto out;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstatic struct kmem_cache *create_cache(const char *name,\n\t\tunsigned int object_size, unsigned int align,\n\t\tslab_flags_t flags, unsigned int useroffset,\n\t\tunsigned int usersize, void (*ctor)(void *),\n\t\tstruct mem_cgroup *memcg, struct kmem_cache *root_cache)\n{\n\tstruct kmem_cache *s;\n\tint err;\n\n\tif (WARN_ON(useroffset + usersize > object_size))\n\t\tuseroffset = usersize = 0;\n\n\terr = -ENOMEM;\n\ts = kmem_cache_zalloc(kmem_cache, GFP_KERNEL);\n\tif (!s)\n\t\tgoto out;\n\n\ts->name = name;\n\ts->size = s->object_size = object_size;\n\ts->align = align;\n\ts->ctor = ctor;\n\ts->useroffset = useroffset;\n\ts->usersize = usersize;\n\n\terr = init_memcg_params(s, memcg, root_cache);\n\tif (err)\n\t\tgoto out_free_cache;\n\n\terr = __kmem_cache_create(s, flags);\n\tif (err)\n\t\tgoto out_free_cache;\n\n\ts->refcount = 1;\n\tlist_add(&s->list, &slab_caches);\n\tmemcg_link_cache(s);\nout:\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn s;\n\nout_free_cache:\n\tdestroy_memcg_params(s);\n\tkmem_cache_free(kmem_cache, s);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calculate_alignment",
          "args": [
            "flags",
            "align",
            "size"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "calculate_alignment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "265-288",
          "snippet": "static unsigned int calculate_alignment(slab_flags_t flags,\n\t\tunsigned int align, unsigned int size)\n{\n\t/*\n\t * If the user wants hardware cache aligned objects then follow that\n\t * suggestion if the object is sufficiently large.\n\t *\n\t * The hardware cache alignment cannot override the specified\n\t * alignment though. If that is greater then use it.\n\t */\n\tif (flags & SLAB_HWCACHE_ALIGN) {\n\t\tunsigned int ralign;\n\n\t\tralign = cache_line_size();\n\t\twhile (size <= ralign / 2)\n\t\t\tralign /= 2;\n\t\talign = max(align, ralign);\n\t}\n\n\tif (align < ARCH_SLAB_MINALIGN)\n\t\talign = ARCH_SLAB_MINALIGN;\n\n\treturn ALIGN(align, sizeof(void *));\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstatic unsigned int calculate_alignment(slab_flags_t flags,\n\t\tunsigned int align, unsigned int size)\n{\n\t/*\n\t * If the user wants hardware cache aligned objects then follow that\n\t * suggestion if the object is sufficiently large.\n\t *\n\t * The hardware cache alignment cannot override the specified\n\t * alignment though. If that is greater then use it.\n\t */\n\tif (flags & SLAB_HWCACHE_ALIGN) {\n\t\tunsigned int ralign;\n\n\t\tralign = cache_line_size();\n\t\twhile (size <= ralign / 2)\n\t\t\tralign /= 2;\n\t\talign = max(align, ralign);\n\t}\n\n\tif (align < ARCH_SLAB_MINALIGN)\n\t\talign = ARCH_SLAB_MINALIGN;\n\n\treturn ALIGN(align, sizeof(void *));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup_const",
          "args": [
            "name",
            "GFP_KERNEL"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "kstrdup_const",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "65-71",
          "snippet": "const char *kstrdup_const(const char *s, gfp_t gfp)\n{\n\tif (is_kernel_rodata((unsigned long)s))\n\t\treturn s;\n\n\treturn kstrdup(s, gfp);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nconst char *kstrdup_const(const char *s, gfp_t gfp)\n{\n\tif (is_kernel_rodata((unsigned long)s))\n\t\treturn s;\n\n\treturn kstrdup(s, gfp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__kmem_cache_alias",
          "args": [
            "name",
            "size",
            "align",
            "flags",
            "ctor"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "__kmem_cache_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1877-1894",
          "snippet": "struct kmem_cache *\n__kmem_cache_alias(const char *name, unsigned int size, unsigned int align,\n\t\t   slab_flags_t flags, void (*ctor)(void *))\n{\n\tstruct kmem_cache *cachep;\n\n\tcachep = find_mergeable(size, align, flags, name, ctor);\n\tif (cachep) {\n\t\tcachep->refcount++;\n\n\t\t/*\n\t\t * Adjust the object sizes so that we clear\n\t\t * the complete object on kzalloc.\n\t\t */\n\t\tcachep->object_size = max_t(int, cachep->object_size, size);\n\t}\n\treturn cachep;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nstruct kmem_cache *\n__kmem_cache_alias(const char *name, unsigned int size, unsigned int align,\n\t\t   slab_flags_t flags, void (*ctor)(void *))\n{\n\tstruct kmem_cache *cachep;\n\n\tcachep = find_mergeable(size, align, flags, name, ctor);\n\tif (cachep) {\n\t\tcachep->refcount++;\n\n\t\t/*\n\t\t * Adjust the object sizes so that we clear\n\t\t * the complete object on kzalloc.\n\t\t */\n\t\tcachep->object_size = max_t(int, cachep->object_size, size);\n\t}\n\treturn cachep;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "size < usersize || size - usersize < useroffset"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!usersize && useroffset"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_sanity_check",
          "args": [
            "name",
            "size"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_sanity_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "97-100",
          "snippet": "static inline int kmem_cache_sanity_check(const char *name, unsigned int size)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstatic inline int kmem_cache_sanity_check(const char *name, unsigned int size)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&slab_mutex"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_get_cache_ids",
          "args": [],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_get_cache_ids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "282-285",
          "snippet": "void memcg_get_cache_ids(void)\n{\n\tdown_read(&memcg_cache_ids_sem);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nvoid memcg_get_cache_ids(void)\n{\n\tdown_read(&memcg_cache_ids_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_online_mems",
          "args": [],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "get_online_mems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "56-59",
          "snippet": "void get_online_mems(void)\n{\n\tpercpu_down_read(&mem_hotplug_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid get_online_mems(void)\n{\n\tpercpu_down_read(&mem_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_online_cpus",
          "args": [],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstruct kmem_cache *\nkmem_cache_create_usercopy(const char *name,\n\t\t  unsigned int size, unsigned int align,\n\t\t  slab_flags_t flags,\n\t\t  unsigned int useroffset, unsigned int usersize,\n\t\t  void (*ctor)(void *))\n{\n\tstruct kmem_cache *s = NULL;\n\tconst char *cache_name;\n\tint err;\n\n\tget_online_cpus();\n\tget_online_mems();\n\tmemcg_get_cache_ids();\n\n\tmutex_lock(&slab_mutex);\n\n\terr = kmem_cache_sanity_check(name, size);\n\tif (err) {\n\t\tgoto out_unlock;\n\t}\n\n\t/* Refuse requests with allocator specific flags */\n\tif (flags & ~SLAB_FLAGS_PERMITTED) {\n\t\terr = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Some allocators will constraint the set of valid flags to a subset\n\t * of all flags. We expect them to define CACHE_CREATE_MASK in this\n\t * case, and we'll just provide them with a sanitized version of the\n\t * passed flags.\n\t */\n\tflags &= CACHE_CREATE_MASK;\n\n\t/* Fail closed on bad usersize of useroffset values. */\n\tif (WARN_ON(!usersize && useroffset) ||\n\t    WARN_ON(size < usersize || size - usersize < useroffset))\n\t\tusersize = useroffset = 0;\n\n\tif (!usersize)\n\t\ts = __kmem_cache_alias(name, size, align, flags, ctor);\n\tif (s)\n\t\tgoto out_unlock;\n\n\tcache_name = kstrdup_const(name, GFP_KERNEL);\n\tif (!cache_name) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\ts = create_cache(cache_name, size,\n\t\t\t calculate_alignment(flags, align, size),\n\t\t\t flags, useroffset, usersize, ctor, NULL, NULL);\n\tif (IS_ERR(s)) {\n\t\terr = PTR_ERR(s);\n\t\tkfree_const(cache_name);\n\t}\n\nout_unlock:\n\tmutex_unlock(&slab_mutex);\n\n\tmemcg_put_cache_ids();\n\tput_online_mems();\n\tput_online_cpus();\n\n\tif (err) {\n\t\tif (flags & SLAB_PANIC)\n\t\t\tpanic(\"kmem_cache_create: Failed to create slab '%s'. Error %d\\n\",\n\t\t\t\tname, err);\n\t\telse {\n\t\t\tpr_warn(\"kmem_cache_create(%s) failed with error %d\\n\",\n\t\t\t\tname, err);\n\t\t\tdump_stack();\n\t\t}\n\t\treturn NULL;\n\t}\n\treturn s;\n}"
  },
  {
    "function_name": "create_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "363-407",
    "snippet": "static struct kmem_cache *create_cache(const char *name,\n\t\tunsigned int object_size, unsigned int align,\n\t\tslab_flags_t flags, unsigned int useroffset,\n\t\tunsigned int usersize, void (*ctor)(void *),\n\t\tstruct mem_cgroup *memcg, struct kmem_cache *root_cache)\n{\n\tstruct kmem_cache *s;\n\tint err;\n\n\tif (WARN_ON(useroffset + usersize > object_size))\n\t\tuseroffset = usersize = 0;\n\n\terr = -ENOMEM;\n\ts = kmem_cache_zalloc(kmem_cache, GFP_KERNEL);\n\tif (!s)\n\t\tgoto out;\n\n\ts->name = name;\n\ts->size = s->object_size = object_size;\n\ts->align = align;\n\ts->ctor = ctor;\n\ts->useroffset = useroffset;\n\ts->usersize = usersize;\n\n\terr = init_memcg_params(s, memcg, root_cache);\n\tif (err)\n\t\tgoto out_free_cache;\n\n\terr = __kmem_cache_create(s, flags);\n\tif (err)\n\t\tgoto out_free_cache;\n\n\ts->refcount = 1;\n\tlist_add(&s->list, &slab_caches);\n\tmemcg_link_cache(s);\nout:\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn s;\n\nout_free_cache:\n\tdestroy_memcg_params(s);\n\tkmem_cache_free(kmem_cache, s);\n\tgoto out;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "kmem_cache",
            "s"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3749-3764",
          "snippet": "void kmem_cache_free(struct kmem_cache *cachep, void *objp)\n{\n\tunsigned long flags;\n\tcachep = cache_from_obj(cachep, objp);\n\tif (!cachep)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tdebug_check_no_locks_freed(objp, cachep->object_size);\n\tif (!(cachep->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(objp, cachep->object_size);\n\t__cache_free(cachep, objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n\n\ttrace_kmem_cache_free(_RET_IP_, objp);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid kmem_cache_free(struct kmem_cache *cachep, void *objp)\n{\n\tunsigned long flags;\n\tcachep = cache_from_obj(cachep, objp);\n\tif (!cachep)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tdebug_check_no_locks_freed(objp, cachep->object_size);\n\tif (!(cachep->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(objp, cachep->object_size);\n\t__cache_free(cachep, objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n\n\ttrace_kmem_cache_free(_RET_IP_, objp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_memcg_params",
          "args": [
            "s"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_memcg_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "252-254",
          "snippet": "static inline void destroy_memcg_params(struct kmem_cache *s)\n{\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstatic inline void destroy_memcg_params(struct kmem_cache *s)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_link_cache",
          "args": [
            "s"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_link_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "224-234",
          "snippet": "void memcg_link_cache(struct kmem_cache *s)\n{\n\tif (is_root_cache(s)) {\n\t\tlist_add(&s->root_caches_node, &slab_root_caches);\n\t} else {\n\t\tlist_add(&s->memcg_params.children_node,\n\t\t\t &s->memcg_params.root_cache->memcg_params.children);\n\t\tlist_add(&s->memcg_params.kmem_caches_node,\n\t\t\t &s->memcg_params.memcg->kmem_caches);\n\t}\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nvoid memcg_link_cache(struct kmem_cache *s)\n{\n\tif (is_root_cache(s)) {\n\t\tlist_add(&s->root_caches_node, &slab_root_caches);\n\t} else {\n\t\tlist_add(&s->memcg_params.children_node,\n\t\t\t &s->memcg_params.root_cache->memcg_params.children);\n\t\tlist_add(&s->memcg_params.kmem_caches_node,\n\t\t\t &s->memcg_params.memcg->kmem_caches);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&s->list",
            "&slab_caches"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kmem_cache_create",
          "args": [
            "s",
            "flags"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "__kmem_cache_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1990-2154",
          "snippet": "int __kmem_cache_create(struct kmem_cache *cachep, slab_flags_t flags)\n{\n\tsize_t ralign = BYTES_PER_WORD;\n\tgfp_t gfp;\n\tint err;\n\tunsigned int size = cachep->size;\n\n#if DEBUG\n#if FORCED_DEBUG\n\t/*\n\t * Enable redzoning and last user accounting, except for caches with\n\t * large objects, if the increased size would increase the object size\n\t * above the next power of two: caches with object sizes just above a\n\t * power of two have a significant amount of internal fragmentation.\n\t */\n\tif (size < 4096 || fls(size - 1) == fls(size-1 + REDZONE_ALIGN +\n\t\t\t\t\t\t2 * sizeof(unsigned long long)))\n\t\tflags |= SLAB_RED_ZONE | SLAB_STORE_USER;\n\tif (!(flags & SLAB_TYPESAFE_BY_RCU))\n\t\tflags |= SLAB_POISON;\n#endif\n#endif\n\n\t/*\n\t * Check that size is in terms of words.  This is needed to avoid\n\t * unaligned accesses for some archs when redzoning is used, and makes\n\t * sure any on-slab bufctl's are also correctly aligned.\n\t */\n\tsize = ALIGN(size, BYTES_PER_WORD);\n\n\tif (flags & SLAB_RED_ZONE) {\n\t\tralign = REDZONE_ALIGN;\n\t\t/* If redzoning, ensure that the second redzone is suitably\n\t\t * aligned, by adjusting the object size accordingly. */\n\t\tsize = ALIGN(size, REDZONE_ALIGN);\n\t}\n\n\t/* 3) caller mandated alignment */\n\tif (ralign < cachep->align) {\n\t\tralign = cachep->align;\n\t}\n\t/* disable debug if necessary */\n\tif (ralign > __alignof__(unsigned long long))\n\t\tflags &= ~(SLAB_RED_ZONE | SLAB_STORE_USER);\n\t/*\n\t * 4) Store it.\n\t */\n\tcachep->align = ralign;\n\tcachep->colour_off = cache_line_size();\n\t/* Offset must be a multiple of the alignment. */\n\tif (cachep->colour_off < cachep->align)\n\t\tcachep->colour_off = cachep->align;\n\n\tif (slab_is_available())\n\t\tgfp = GFP_KERNEL;\n\telse\n\t\tgfp = GFP_NOWAIT;\n\n#if DEBUG\n\n\t/*\n\t * Both debugging options require word-alignment which is calculated\n\t * into align above.\n\t */\n\tif (flags & SLAB_RED_ZONE) {\n\t\t/* add space for red zone words */\n\t\tcachep->obj_offset += sizeof(unsigned long long);\n\t\tsize += 2 * sizeof(unsigned long long);\n\t}\n\tif (flags & SLAB_STORE_USER) {\n\t\t/* user store requires one word storage behind the end of\n\t\t * the real object. But if the second red zone needs to be\n\t\t * aligned to 64 bits, we must allow that much space.\n\t\t */\n\t\tif (flags & SLAB_RED_ZONE)\n\t\t\tsize += REDZONE_ALIGN;\n\t\telse\n\t\t\tsize += BYTES_PER_WORD;\n\t}\n#endif\n\n\tkasan_cache_create(cachep, &size, &flags);\n\n\tsize = ALIGN(size, cachep->align);\n\t/*\n\t * We should restrict the number of objects in a slab to implement\n\t * byte sized index. Refer comment on SLAB_OBJ_MIN_SIZE definition.\n\t */\n\tif (FREELIST_BYTE_INDEX && size < SLAB_OBJ_MIN_SIZE)\n\t\tsize = ALIGN(SLAB_OBJ_MIN_SIZE, cachep->align);\n\n#if DEBUG\n\t/*\n\t * To activate debug pagealloc, off-slab management is necessary\n\t * requirement. In early phase of initialization, small sized slab\n\t * doesn't get initialized so it would not be possible. So, we need\n\t * to check size >= 256. It guarantees that all necessary small\n\t * sized slab is initialized in current slab initialization sequence.\n\t */\n\tif (debug_pagealloc_enabled() && (flags & SLAB_POISON) &&\n\t\tsize >= 256 && cachep->object_size > cache_line_size()) {\n\t\tif (size < PAGE_SIZE || size % PAGE_SIZE == 0) {\n\t\t\tsize_t tmp_size = ALIGN(size, PAGE_SIZE);\n\n\t\t\tif (set_off_slab_cache(cachep, tmp_size, flags)) {\n\t\t\t\tflags |= CFLGS_OFF_SLAB;\n\t\t\t\tcachep->obj_offset += tmp_size - size;\n\t\t\t\tsize = tmp_size;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (set_objfreelist_slab_cache(cachep, size, flags)) {\n\t\tflags |= CFLGS_OBJFREELIST_SLAB;\n\t\tgoto done;\n\t}\n\n\tif (set_off_slab_cache(cachep, size, flags)) {\n\t\tflags |= CFLGS_OFF_SLAB;\n\t\tgoto done;\n\t}\n\n\tif (set_on_slab_cache(cachep, size, flags))\n\t\tgoto done;\n\n\treturn -E2BIG;\n\ndone:\n\tcachep->freelist_size = cachep->num * sizeof(freelist_idx_t);\n\tcachep->flags = flags;\n\tcachep->allocflags = __GFP_COMP;\n\tif (flags & SLAB_CACHE_DMA)\n\t\tcachep->allocflags |= GFP_DMA;\n\tif (flags & SLAB_RECLAIM_ACCOUNT)\n\t\tcachep->allocflags |= __GFP_RECLAIMABLE;\n\tcachep->size = size;\n\tcachep->reciprocal_buffer_size = reciprocal_value(size);\n\n#if DEBUG\n\t/*\n\t * If we're going to use the generic kernel_map_pages()\n\t * poisoning, then it's going to smash the contents of\n\t * the redzone and userword anyhow, so switch them off.\n\t */\n\tif (IS_ENABLED(CONFIG_PAGE_POISONING) &&\n\t\t(cachep->flags & SLAB_POISON) &&\n\t\tis_debug_pagealloc_cache(cachep))\n\t\tcachep->flags &= ~(SLAB_RED_ZONE | SLAB_STORE_USER);\n#endif\n\n\tif (OFF_SLAB(cachep)) {\n\t\tcachep->freelist_cache =\n\t\t\tkmalloc_slab(cachep->freelist_size, 0u);\n\t}\n\n\terr = setup_cpu_cache(cachep, gfp);\n\tif (err) {\n\t\t__kmem_cache_release(cachep);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [
            "#define CFLGS_OFF_SLAB\t\t((slab_flags_t __force)0x80000000U)",
            "#define CFLGS_OBJFREELIST_SLAB\t((slab_flags_t __force)0x40000000U)",
            "#define FREELIST_BYTE_INDEX (((PAGE_SIZE >> BITS_PER_BYTE) \\\n\t\t\t\t<= SLAB_OBJ_MIN_SIZE) ? 1 : 0)",
            "#define\tREDZONE_ALIGN\t\tmax(BYTES_PER_WORD, __alignof__(unsigned long long))",
            "#define\tBYTES_PER_WORD\t\tsizeof(void *)",
            "#define\tFORCED_DEBUG\t0",
            "#define\tDEBUG\t\t0",
            "#define\tFORCED_DEBUG\t1",
            "#define\tDEBUG\t\t1"
          ],
          "globals_used": [
            "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\n#define CFLGS_OFF_SLAB\t\t((slab_flags_t __force)0x80000000U)\n#define CFLGS_OBJFREELIST_SLAB\t((slab_flags_t __force)0x40000000U)\n#define FREELIST_BYTE_INDEX (((PAGE_SIZE >> BITS_PER_BYTE) \\\n\t\t\t\t<= SLAB_OBJ_MIN_SIZE) ? 1 : 0)\n#define\tREDZONE_ALIGN\t\tmax(BYTES_PER_WORD, __alignof__(unsigned long long))\n#define\tBYTES_PER_WORD\t\tsizeof(void *)\n#define\tFORCED_DEBUG\t0\n#define\tDEBUG\t\t0\n#define\tFORCED_DEBUG\t1\n#define\tDEBUG\t\t1\n\nstatic int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp);\nstatic noinline struct;\n\nint __kmem_cache_create(struct kmem_cache *cachep, slab_flags_t flags)\n{\n\tsize_t ralign = BYTES_PER_WORD;\n\tgfp_t gfp;\n\tint err;\n\tunsigned int size = cachep->size;\n\n#if DEBUG\n#if FORCED_DEBUG\n\t/*\n\t * Enable redzoning and last user accounting, except for caches with\n\t * large objects, if the increased size would increase the object size\n\t * above the next power of two: caches with object sizes just above a\n\t * power of two have a significant amount of internal fragmentation.\n\t */\n\tif (size < 4096 || fls(size - 1) == fls(size-1 + REDZONE_ALIGN +\n\t\t\t\t\t\t2 * sizeof(unsigned long long)))\n\t\tflags |= SLAB_RED_ZONE | SLAB_STORE_USER;\n\tif (!(flags & SLAB_TYPESAFE_BY_RCU))\n\t\tflags |= SLAB_POISON;\n#endif\n#endif\n\n\t/*\n\t * Check that size is in terms of words.  This is needed to avoid\n\t * unaligned accesses for some archs when redzoning is used, and makes\n\t * sure any on-slab bufctl's are also correctly aligned.\n\t */\n\tsize = ALIGN(size, BYTES_PER_WORD);\n\n\tif (flags & SLAB_RED_ZONE) {\n\t\tralign = REDZONE_ALIGN;\n\t\t/* If redzoning, ensure that the second redzone is suitably\n\t\t * aligned, by adjusting the object size accordingly. */\n\t\tsize = ALIGN(size, REDZONE_ALIGN);\n\t}\n\n\t/* 3) caller mandated alignment */\n\tif (ralign < cachep->align) {\n\t\tralign = cachep->align;\n\t}\n\t/* disable debug if necessary */\n\tif (ralign > __alignof__(unsigned long long))\n\t\tflags &= ~(SLAB_RED_ZONE | SLAB_STORE_USER);\n\t/*\n\t * 4) Store it.\n\t */\n\tcachep->align = ralign;\n\tcachep->colour_off = cache_line_size();\n\t/* Offset must be a multiple of the alignment. */\n\tif (cachep->colour_off < cachep->align)\n\t\tcachep->colour_off = cachep->align;\n\n\tif (slab_is_available())\n\t\tgfp = GFP_KERNEL;\n\telse\n\t\tgfp = GFP_NOWAIT;\n\n#if DEBUG\n\n\t/*\n\t * Both debugging options require word-alignment which is calculated\n\t * into align above.\n\t */\n\tif (flags & SLAB_RED_ZONE) {\n\t\t/* add space for red zone words */\n\t\tcachep->obj_offset += sizeof(unsigned long long);\n\t\tsize += 2 * sizeof(unsigned long long);\n\t}\n\tif (flags & SLAB_STORE_USER) {\n\t\t/* user store requires one word storage behind the end of\n\t\t * the real object. But if the second red zone needs to be\n\t\t * aligned to 64 bits, we must allow that much space.\n\t\t */\n\t\tif (flags & SLAB_RED_ZONE)\n\t\t\tsize += REDZONE_ALIGN;\n\t\telse\n\t\t\tsize += BYTES_PER_WORD;\n\t}\n#endif\n\n\tkasan_cache_create(cachep, &size, &flags);\n\n\tsize = ALIGN(size, cachep->align);\n\t/*\n\t * We should restrict the number of objects in a slab to implement\n\t * byte sized index. Refer comment on SLAB_OBJ_MIN_SIZE definition.\n\t */\n\tif (FREELIST_BYTE_INDEX && size < SLAB_OBJ_MIN_SIZE)\n\t\tsize = ALIGN(SLAB_OBJ_MIN_SIZE, cachep->align);\n\n#if DEBUG\n\t/*\n\t * To activate debug pagealloc, off-slab management is necessary\n\t * requirement. In early phase of initialization, small sized slab\n\t * doesn't get initialized so it would not be possible. So, we need\n\t * to check size >= 256. It guarantees that all necessary small\n\t * sized slab is initialized in current slab initialization sequence.\n\t */\n\tif (debug_pagealloc_enabled() && (flags & SLAB_POISON) &&\n\t\tsize >= 256 && cachep->object_size > cache_line_size()) {\n\t\tif (size < PAGE_SIZE || size % PAGE_SIZE == 0) {\n\t\t\tsize_t tmp_size = ALIGN(size, PAGE_SIZE);\n\n\t\t\tif (set_off_slab_cache(cachep, tmp_size, flags)) {\n\t\t\t\tflags |= CFLGS_OFF_SLAB;\n\t\t\t\tcachep->obj_offset += tmp_size - size;\n\t\t\t\tsize = tmp_size;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (set_objfreelist_slab_cache(cachep, size, flags)) {\n\t\tflags |= CFLGS_OBJFREELIST_SLAB;\n\t\tgoto done;\n\t}\n\n\tif (set_off_slab_cache(cachep, size, flags)) {\n\t\tflags |= CFLGS_OFF_SLAB;\n\t\tgoto done;\n\t}\n\n\tif (set_on_slab_cache(cachep, size, flags))\n\t\tgoto done;\n\n\treturn -E2BIG;\n\ndone:\n\tcachep->freelist_size = cachep->num * sizeof(freelist_idx_t);\n\tcachep->flags = flags;\n\tcachep->allocflags = __GFP_COMP;\n\tif (flags & SLAB_CACHE_DMA)\n\t\tcachep->allocflags |= GFP_DMA;\n\tif (flags & SLAB_RECLAIM_ACCOUNT)\n\t\tcachep->allocflags |= __GFP_RECLAIMABLE;\n\tcachep->size = size;\n\tcachep->reciprocal_buffer_size = reciprocal_value(size);\n\n#if DEBUG\n\t/*\n\t * If we're going to use the generic kernel_map_pages()\n\t * poisoning, then it's going to smash the contents of\n\t * the redzone and userword anyhow, so switch them off.\n\t */\n\tif (IS_ENABLED(CONFIG_PAGE_POISONING) &&\n\t\t(cachep->flags & SLAB_POISON) &&\n\t\tis_debug_pagealloc_cache(cachep))\n\t\tcachep->flags &= ~(SLAB_RED_ZONE | SLAB_STORE_USER);\n#endif\n\n\tif (OFF_SLAB(cachep)) {\n\t\tcachep->freelist_cache =\n\t\t\tkmalloc_slab(cachep->freelist_size, 0u);\n\t}\n\n\terr = setup_cpu_cache(cachep, gfp);\n\tif (err) {\n\t\t__kmem_cache_release(cachep);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_memcg_params",
          "args": [
            "s",
            "memcg",
            "root_cache"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "init_memcg_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "246-250",
          "snippet": "static inline int init_memcg_params(struct kmem_cache *s,\n\t\tstruct mem_cgroup *memcg, struct kmem_cache *root_cache)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstatic inline int init_memcg_params(struct kmem_cache *s,\n\t\tstruct mem_cgroup *memcg, struct kmem_cache *root_cache)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "kmem_cache",
            "GFP_KERNEL"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "useroffset + usersize > object_size"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstatic struct kmem_cache *create_cache(const char *name,\n\t\tunsigned int object_size, unsigned int align,\n\t\tslab_flags_t flags, unsigned int useroffset,\n\t\tunsigned int usersize, void (*ctor)(void *),\n\t\tstruct mem_cgroup *memcg, struct kmem_cache *root_cache)\n{\n\tstruct kmem_cache *s;\n\tint err;\n\n\tif (WARN_ON(useroffset + usersize > object_size))\n\t\tuseroffset = usersize = 0;\n\n\terr = -ENOMEM;\n\ts = kmem_cache_zalloc(kmem_cache, GFP_KERNEL);\n\tif (!s)\n\t\tgoto out;\n\n\ts->name = name;\n\ts->size = s->object_size = object_size;\n\ts->align = align;\n\ts->ctor = ctor;\n\ts->useroffset = useroffset;\n\ts->usersize = usersize;\n\n\terr = init_memcg_params(s, memcg, root_cache);\n\tif (err)\n\t\tgoto out_free_cache;\n\n\terr = __kmem_cache_create(s, flags);\n\tif (err)\n\t\tgoto out_free_cache;\n\n\ts->refcount = 1;\n\tlist_add(&s->list, &slab_caches);\n\tmemcg_link_cache(s);\nout:\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn s;\n\nout_free_cache:\n\tdestroy_memcg_params(s);\n\tkmem_cache_free(kmem_cache, s);\n\tgoto out;\n}"
  },
  {
    "function_name": "find_mergeable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "316-361",
    "snippet": "struct kmem_cache *find_mergeable(unsigned int size, unsigned int align,\n\t\tslab_flags_t flags, const char *name, void (*ctor)(void *))\n{\n\tstruct kmem_cache *s;\n\n\tif (slab_nomerge)\n\t\treturn NULL;\n\n\tif (ctor)\n\t\treturn NULL;\n\n\tsize = ALIGN(size, sizeof(void *));\n\talign = calculate_alignment(flags, align, size);\n\tsize = ALIGN(size, align);\n\tflags = kmem_cache_flags(size, flags, name, NULL);\n\n\tif (flags & SLAB_NEVER_MERGE)\n\t\treturn NULL;\n\n\tlist_for_each_entry_reverse(s, &slab_root_caches, root_caches_node) {\n\t\tif (slab_unmergeable(s))\n\t\t\tcontinue;\n\n\t\tif (size > s->size)\n\t\t\tcontinue;\n\n\t\tif ((flags & SLAB_MERGE_SAME) != (s->flags & SLAB_MERGE_SAME))\n\t\t\tcontinue;\n\t\t/*\n\t\t * Check if alignment is compatible.\n\t\t * Courtesy of Adrian Drzewiecki\n\t\t */\n\t\tif ((s->size & ~(align - 1)) != s->size)\n\t\t\tcontinue;\n\n\t\tif (s->size - size >= sizeof(void *))\n\t\t\tcontinue;\n\n\t\tif (IS_ENABLED(CONFIG_SLAB) && align &&\n\t\t\t(align > s->align || s->align % align))\n\t\t\tcontinue;\n\n\t\treturn s;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define SLAB_MERGE_SAME (SLAB_RECLAIM_ACCOUNT | SLAB_CACHE_DMA | \\\n\t\t\t SLAB_ACCOUNT)",
      "#define SLAB_NEVER_MERGE (SLAB_RED_ZONE | SLAB_POISON | SLAB_STORE_USER | \\\n\t\tSLAB_TRACE | SLAB_TYPESAFE_BY_RCU | SLAB_NOLEAKTRACE | \\\n\t\tSLAB_FAILSLAB | SLAB_KASAN)"
    ],
    "globals_used": [
      "struct kmem_cache *kmem_cache;",
      "static bool slab_nomerge = !IS_ENABLED(CONFIG_SLAB_MERGE_DEFAULT);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_SLAB"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_unmergeable",
          "args": [
            "s"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "slab_unmergeable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "293-314",
          "snippet": "int slab_unmergeable(struct kmem_cache *s)\n{\n\tif (slab_nomerge || (s->flags & SLAB_NEVER_MERGE))\n\t\treturn 1;\n\n\tif (!is_root_cache(s))\n\t\treturn 1;\n\n\tif (s->ctor)\n\t\treturn 1;\n\n\tif (s->usersize)\n\t\treturn 1;\n\n\t/*\n\t * We may have set a slab to be unmergeable during bootstrap.\n\t */\n\tif (s->refcount < 0)\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define SLAB_NEVER_MERGE (SLAB_RED_ZONE | SLAB_POISON | SLAB_STORE_USER | \\\n\t\tSLAB_TRACE | SLAB_TYPESAFE_BY_RCU | SLAB_NOLEAKTRACE | \\\n\t\tSLAB_FAILSLAB | SLAB_KASAN)"
          ],
          "globals_used": [
            "struct kmem_cache *kmem_cache;",
            "static bool slab_nomerge = !IS_ENABLED(CONFIG_SLAB_MERGE_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\n#define SLAB_NEVER_MERGE (SLAB_RED_ZONE | SLAB_POISON | SLAB_STORE_USER | \\\n\t\tSLAB_TRACE | SLAB_TYPESAFE_BY_RCU | SLAB_NOLEAKTRACE | \\\n\t\tSLAB_FAILSLAB | SLAB_KASAN)\n\nstruct kmem_cache *kmem_cache;\nstatic bool slab_nomerge = !IS_ENABLED(CONFIG_SLAB_MERGE_DEFAULT);\n\nint slab_unmergeable(struct kmem_cache *s)\n{\n\tif (slab_nomerge || (s->flags & SLAB_NEVER_MERGE))\n\t\treturn 1;\n\n\tif (!is_root_cache(s))\n\t\treturn 1;\n\n\tif (s->ctor)\n\t\treturn 1;\n\n\tif (s->usersize)\n\t\treturn 1;\n\n\t/*\n\t * We may have set a slab to be unmergeable during bootstrap.\n\t */\n\tif (s->refcount < 0)\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_reverse",
          "args": [
            "s",
            "&slab_root_caches",
            "root_caches_node"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_flags",
          "args": [
            "size",
            "flags",
            "name",
            "NULL"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "1870-1875",
          "snippet": "slab_flags_t kmem_cache_flags(unsigned int object_size,\n\tslab_flags_t flags, const char *name,\n\tvoid (*ctor)(void *))\n{\n\treturn flags;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nslab_flags_t kmem_cache_flags(unsigned int object_size,\n\tslab_flags_t flags, const char *name,\n\tvoid (*ctor)(void *))\n{\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "size",
            "align"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calculate_alignment",
          "args": [
            "flags",
            "align",
            "size"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "calculate_alignment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "265-288",
          "snippet": "static unsigned int calculate_alignment(slab_flags_t flags,\n\t\tunsigned int align, unsigned int size)\n{\n\t/*\n\t * If the user wants hardware cache aligned objects then follow that\n\t * suggestion if the object is sufficiently large.\n\t *\n\t * The hardware cache alignment cannot override the specified\n\t * alignment though. If that is greater then use it.\n\t */\n\tif (flags & SLAB_HWCACHE_ALIGN) {\n\t\tunsigned int ralign;\n\n\t\tralign = cache_line_size();\n\t\twhile (size <= ralign / 2)\n\t\t\tralign /= 2;\n\t\talign = max(align, ralign);\n\t}\n\n\tif (align < ARCH_SLAB_MINALIGN)\n\t\talign = ARCH_SLAB_MINALIGN;\n\n\treturn ALIGN(align, sizeof(void *));\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstatic unsigned int calculate_alignment(slab_flags_t flags,\n\t\tunsigned int align, unsigned int size)\n{\n\t/*\n\t * If the user wants hardware cache aligned objects then follow that\n\t * suggestion if the object is sufficiently large.\n\t *\n\t * The hardware cache alignment cannot override the specified\n\t * alignment though. If that is greater then use it.\n\t */\n\tif (flags & SLAB_HWCACHE_ALIGN) {\n\t\tunsigned int ralign;\n\n\t\tralign = cache_line_size();\n\t\twhile (size <= ralign / 2)\n\t\t\tralign /= 2;\n\t\talign = max(align, ralign);\n\t}\n\n\tif (align < ARCH_SLAB_MINALIGN)\n\t\talign = ARCH_SLAB_MINALIGN;\n\n\treturn ALIGN(align, sizeof(void *));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "size",
            "sizeof(void *)"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\n#define SLAB_MERGE_SAME (SLAB_RECLAIM_ACCOUNT | SLAB_CACHE_DMA | \\\n\t\t\t SLAB_ACCOUNT)\n#define SLAB_NEVER_MERGE (SLAB_RED_ZONE | SLAB_POISON | SLAB_STORE_USER | \\\n\t\tSLAB_TRACE | SLAB_TYPESAFE_BY_RCU | SLAB_NOLEAKTRACE | \\\n\t\tSLAB_FAILSLAB | SLAB_KASAN)\n\nstruct kmem_cache *kmem_cache;\nstatic bool slab_nomerge = !IS_ENABLED(CONFIG_SLAB_MERGE_DEFAULT);\n\nstruct kmem_cache *find_mergeable(unsigned int size, unsigned int align,\n\t\tslab_flags_t flags, const char *name, void (*ctor)(void *))\n{\n\tstruct kmem_cache *s;\n\n\tif (slab_nomerge)\n\t\treturn NULL;\n\n\tif (ctor)\n\t\treturn NULL;\n\n\tsize = ALIGN(size, sizeof(void *));\n\talign = calculate_alignment(flags, align, size);\n\tsize = ALIGN(size, align);\n\tflags = kmem_cache_flags(size, flags, name, NULL);\n\n\tif (flags & SLAB_NEVER_MERGE)\n\t\treturn NULL;\n\n\tlist_for_each_entry_reverse(s, &slab_root_caches, root_caches_node) {\n\t\tif (slab_unmergeable(s))\n\t\t\tcontinue;\n\n\t\tif (size > s->size)\n\t\t\tcontinue;\n\n\t\tif ((flags & SLAB_MERGE_SAME) != (s->flags & SLAB_MERGE_SAME))\n\t\t\tcontinue;\n\t\t/*\n\t\t * Check if alignment is compatible.\n\t\t * Courtesy of Adrian Drzewiecki\n\t\t */\n\t\tif ((s->size & ~(align - 1)) != s->size)\n\t\t\tcontinue;\n\n\t\tif (s->size - size >= sizeof(void *))\n\t\t\tcontinue;\n\n\t\tif (IS_ENABLED(CONFIG_SLAB) && align &&\n\t\t\t(align > s->align || s->align % align))\n\t\t\tcontinue;\n\n\t\treturn s;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "slab_unmergeable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "293-314",
    "snippet": "int slab_unmergeable(struct kmem_cache *s)\n{\n\tif (slab_nomerge || (s->flags & SLAB_NEVER_MERGE))\n\t\treturn 1;\n\n\tif (!is_root_cache(s))\n\t\treturn 1;\n\n\tif (s->ctor)\n\t\treturn 1;\n\n\tif (s->usersize)\n\t\treturn 1;\n\n\t/*\n\t * We may have set a slab to be unmergeable during bootstrap.\n\t */\n\tif (s->refcount < 0)\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define SLAB_NEVER_MERGE (SLAB_RED_ZONE | SLAB_POISON | SLAB_STORE_USER | \\\n\t\tSLAB_TRACE | SLAB_TYPESAFE_BY_RCU | SLAB_NOLEAKTRACE | \\\n\t\tSLAB_FAILSLAB | SLAB_KASAN)"
    ],
    "globals_used": [
      "struct kmem_cache *kmem_cache;",
      "static bool slab_nomerge = !IS_ENABLED(CONFIG_SLAB_MERGE_DEFAULT);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_root_cache",
          "args": [
            "s"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "is_root_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "308-311",
          "snippet": "static inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn true;\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\n#define SLAB_NEVER_MERGE (SLAB_RED_ZONE | SLAB_POISON | SLAB_STORE_USER | \\\n\t\tSLAB_TRACE | SLAB_TYPESAFE_BY_RCU | SLAB_NOLEAKTRACE | \\\n\t\tSLAB_FAILSLAB | SLAB_KASAN)\n\nstruct kmem_cache *kmem_cache;\nstatic bool slab_nomerge = !IS_ENABLED(CONFIG_SLAB_MERGE_DEFAULT);\n\nint slab_unmergeable(struct kmem_cache *s)\n{\n\tif (slab_nomerge || (s->flags & SLAB_NEVER_MERGE))\n\t\treturn 1;\n\n\tif (!is_root_cache(s))\n\t\treturn 1;\n\n\tif (s->ctor)\n\t\treturn 1;\n\n\tif (s->usersize)\n\t\treturn 1;\n\n\t/*\n\t * We may have set a slab to be unmergeable during bootstrap.\n\t */\n\tif (s->refcount < 0)\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "calculate_alignment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "265-288",
    "snippet": "static unsigned int calculate_alignment(slab_flags_t flags,\n\t\tunsigned int align, unsigned int size)\n{\n\t/*\n\t * If the user wants hardware cache aligned objects then follow that\n\t * suggestion if the object is sufficiently large.\n\t *\n\t * The hardware cache alignment cannot override the specified\n\t * alignment though. If that is greater then use it.\n\t */\n\tif (flags & SLAB_HWCACHE_ALIGN) {\n\t\tunsigned int ralign;\n\n\t\tralign = cache_line_size();\n\t\twhile (size <= ralign / 2)\n\t\t\tralign /= 2;\n\t\talign = max(align, ralign);\n\t}\n\n\tif (align < ARCH_SLAB_MINALIGN)\n\t\talign = ARCH_SLAB_MINALIGN;\n\n\treturn ALIGN(align, sizeof(void *));\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "align",
            "sizeof(void *)"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "align",
            "ralign"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_line_size",
          "args": [],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstatic unsigned int calculate_alignment(slab_flags_t flags,\n\t\tunsigned int align, unsigned int size)\n{\n\t/*\n\t * If the user wants hardware cache aligned objects then follow that\n\t * suggestion if the object is sufficiently large.\n\t *\n\t * The hardware cache alignment cannot override the specified\n\t * alignment though. If that is greater then use it.\n\t */\n\tif (flags & SLAB_HWCACHE_ALIGN) {\n\t\tunsigned int ralign;\n\n\t\tralign = cache_line_size();\n\t\twhile (size <= ralign / 2)\n\t\t\tralign /= 2;\n\t\talign = max(align, ralign);\n\t}\n\n\tif (align < ARCH_SLAB_MINALIGN)\n\t\talign = ARCH_SLAB_MINALIGN;\n\n\treturn ALIGN(align, sizeof(void *));\n}"
  },
  {
    "function_name": "memcg_unlink_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "256-258",
    "snippet": "static inline void memcg_unlink_cache(struct kmem_cache *s)\n{\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstatic inline void memcg_unlink_cache(struct kmem_cache *s)\n{\n}"
  },
  {
    "function_name": "destroy_memcg_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "252-254",
    "snippet": "static inline void destroy_memcg_params(struct kmem_cache *s)\n{\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstatic inline void destroy_memcg_params(struct kmem_cache *s)\n{\n}"
  },
  {
    "function_name": "init_memcg_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "246-250",
    "snippet": "static inline int init_memcg_params(struct kmem_cache *s,\n\t\tstruct mem_cgroup *memcg, struct kmem_cache *root_cache)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstatic inline int init_memcg_params(struct kmem_cache *s,\n\t\tstruct mem_cgroup *memcg, struct kmem_cache *root_cache)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "memcg_unlink_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "236-244",
    "snippet": "static void memcg_unlink_cache(struct kmem_cache *s)\n{\n\tif (is_root_cache(s)) {\n\t\tlist_del(&s->root_caches_node);\n\t} else {\n\t\tlist_del(&s->memcg_params.children_node);\n\t\tlist_del(&s->memcg_params.kmem_caches_node);\n\t}\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&s->memcg_params.kmem_caches_node"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&s->memcg_params.children_node"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&s->root_caches_node"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_root_cache",
          "args": [
            "s"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "is_root_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "308-311",
          "snippet": "static inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn true;\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstatic void memcg_unlink_cache(struct kmem_cache *s)\n{\n\tif (is_root_cache(s)) {\n\t\tlist_del(&s->root_caches_node);\n\t} else {\n\t\tlist_del(&s->memcg_params.children_node);\n\t\tlist_del(&s->memcg_params.kmem_caches_node);\n\t}\n}"
  },
  {
    "function_name": "memcg_link_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "224-234",
    "snippet": "void memcg_link_cache(struct kmem_cache *s)\n{\n\tif (is_root_cache(s)) {\n\t\tlist_add(&s->root_caches_node, &slab_root_caches);\n\t} else {\n\t\tlist_add(&s->memcg_params.children_node,\n\t\t\t &s->memcg_params.root_cache->memcg_params.children);\n\t\tlist_add(&s->memcg_params.kmem_caches_node,\n\t\t\t &s->memcg_params.memcg->kmem_caches);\n\t}\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&s->memcg_params.kmem_caches_node",
            "&s->memcg_params.memcg->kmem_caches"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&s->memcg_params.children_node",
            "&s->memcg_params.root_cache->memcg_params.children"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&s->root_caches_node",
            "&slab_root_caches"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_root_cache",
          "args": [
            "s"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "is_root_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "308-311",
          "snippet": "static inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn true;\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nvoid memcg_link_cache(struct kmem_cache *s)\n{\n\tif (is_root_cache(s)) {\n\t\tlist_add(&s->root_caches_node, &slab_root_caches);\n\t} else {\n\t\tlist_add(&s->memcg_params.children_node,\n\t\t\t &s->memcg_params.root_cache->memcg_params.children);\n\t\tlist_add(&s->memcg_params.kmem_caches_node,\n\t\t\t &s->memcg_params.memcg->kmem_caches);\n\t}\n}"
  },
  {
    "function_name": "memcg_update_all_caches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "205-222",
    "snippet": "int memcg_update_all_caches(int num_memcgs)\n{\n\tstruct kmem_cache *s;\n\tint ret = 0;\n\n\tmutex_lock(&slab_mutex);\n\tlist_for_each_entry(s, &slab_root_caches, root_caches_node) {\n\t\tret = update_memcg_params(s, num_memcgs);\n\t\t/*\n\t\t * Instead of freeing the memory, we'll just leave the caches\n\t\t * up to this point in an updated state.\n\t\t */\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&slab_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&slab_mutex"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_memcg_params",
          "args": [
            "s",
            "num_memcgs"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "update_memcg_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "184-203",
          "snippet": "static int update_memcg_params(struct kmem_cache *s, int new_array_size)\n{\n\tstruct memcg_cache_array *old, *new;\n\n\tnew = kvzalloc(sizeof(struct memcg_cache_array) +\n\t\t       new_array_size * sizeof(void *), GFP_KERNEL);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\told = rcu_dereference_protected(s->memcg_params.memcg_caches,\n\t\t\t\t\tlockdep_is_held(&slab_mutex));\n\tif (old)\n\t\tmemcpy(new->entries, old->entries,\n\t\t       memcg_nr_cache_ids * sizeof(void *));\n\n\trcu_assign_pointer(s->memcg_params.memcg_caches, new);\n\tif (old)\n\t\tcall_rcu(&old->rcu, free_memcg_params);\n\treturn 0;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstatic int update_memcg_params(struct kmem_cache *s, int new_array_size)\n{\n\tstruct memcg_cache_array *old, *new;\n\n\tnew = kvzalloc(sizeof(struct memcg_cache_array) +\n\t\t       new_array_size * sizeof(void *), GFP_KERNEL);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\told = rcu_dereference_protected(s->memcg_params.memcg_caches,\n\t\t\t\t\tlockdep_is_held(&slab_mutex));\n\tif (old)\n\t\tmemcpy(new->entries, old->entries,\n\t\t       memcg_nr_cache_ids * sizeof(void *));\n\n\trcu_assign_pointer(s->memcg_params.memcg_caches, new);\n\tif (old)\n\t\tcall_rcu(&old->rcu, free_memcg_params);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "s",
            "&slab_root_caches",
            "root_caches_node"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&slab_mutex"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nint memcg_update_all_caches(int num_memcgs)\n{\n\tstruct kmem_cache *s;\n\tint ret = 0;\n\n\tmutex_lock(&slab_mutex);\n\tlist_for_each_entry(s, &slab_root_caches, root_caches_node) {\n\t\tret = update_memcg_params(s, num_memcgs);\n\t\t/*\n\t\t * Instead of freeing the memory, we'll just leave the caches\n\t\t * up to this point in an updated state.\n\t\t */\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&slab_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "update_memcg_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "184-203",
    "snippet": "static int update_memcg_params(struct kmem_cache *s, int new_array_size)\n{\n\tstruct memcg_cache_array *old, *new;\n\n\tnew = kvzalloc(sizeof(struct memcg_cache_array) +\n\t\t       new_array_size * sizeof(void *), GFP_KERNEL);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\told = rcu_dereference_protected(s->memcg_params.memcg_caches,\n\t\t\t\t\tlockdep_is_held(&slab_mutex));\n\tif (old)\n\t\tmemcpy(new->entries, old->entries,\n\t\t       memcg_nr_cache_ids * sizeof(void *));\n\n\trcu_assign_pointer(s->memcg_params.memcg_caches, new);\n\tif (old)\n\t\tcall_rcu(&old->rcu, free_memcg_params);\n\treturn 0;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&old->rcu",
            "free_memcg_params"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "s->memcg_params.memcg_caches",
            "new"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new->entries",
            "old->entries",
            "memcg_nr_cache_ids * sizeof(void *)"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "300-306",
          "snippet": "void *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memcpy(void *dest, const void *src, size_t len)\n{\n\tcheck_memory_region((unsigned long)src, len, false, _RET_IP_);\n\tcheck_memory_region((unsigned long)dest, len, true, _RET_IP_);\n\n\treturn __memcpy(dest, src, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "s->memcg_params.memcg_caches",
            "lockdep_is_held(&slab_mutex)"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&slab_mutex"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvzalloc",
          "args": [
            "sizeof(struct memcg_cache_array) +\n\t\t       new_array_size * sizeof(void *)",
            "GFP_KERNEL"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstatic int update_memcg_params(struct kmem_cache *s, int new_array_size)\n{\n\tstruct memcg_cache_array *old, *new;\n\n\tnew = kvzalloc(sizeof(struct memcg_cache_array) +\n\t\t       new_array_size * sizeof(void *), GFP_KERNEL);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\told = rcu_dereference_protected(s->memcg_params.memcg_caches,\n\t\t\t\t\tlockdep_is_held(&slab_mutex));\n\tif (old)\n\t\tmemcpy(new->entries, old->entries,\n\t\t       memcg_nr_cache_ids * sizeof(void *));\n\n\trcu_assign_pointer(s->memcg_params.memcg_caches, new);\n\tif (old)\n\t\tcall_rcu(&old->rcu, free_memcg_params);\n\treturn 0;\n}"
  },
  {
    "function_name": "free_memcg_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "176-182",
    "snippet": "static void free_memcg_params(struct rcu_head *rcu)\n{\n\tstruct memcg_cache_array *old;\n\n\told = container_of(rcu, struct memcg_cache_array, rcu);\n\tkvfree(old);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "old"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "kvfree_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "395-401",
          "snippet": "static void kvfree_rcu(struct rcu_head *head)\n{\n\tstruct list_lru_memcg *mlru;\n\n\tmlru = container_of(head, struct list_lru_memcg, rcu);\n\tkvfree(mlru);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void kvfree_rcu(struct rcu_head *head)\n{\n\tstruct list_lru_memcg *mlru;\n\n\tmlru = container_of(head, struct list_lru_memcg, rcu);\n\tkvfree(mlru);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structmemcg_cache_array",
            "rcu"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstatic void free_memcg_params(struct rcu_head *rcu)\n{\n\tstruct memcg_cache_array *old;\n\n\told = container_of(rcu, struct memcg_cache_array, rcu);\n\tkvfree(old);\n}"
  },
  {
    "function_name": "destroy_memcg_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "170-174",
    "snippet": "static void destroy_memcg_params(struct kmem_cache *s)\n{\n\tif (is_root_cache(s))\n\t\tkvfree(rcu_access_pointer(s->memcg_params.memcg_caches));\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "rcu_access_pointer(s->memcg_params.memcg_caches)"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "kvfree_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "395-401",
          "snippet": "static void kvfree_rcu(struct rcu_head *head)\n{\n\tstruct list_lru_memcg *mlru;\n\n\tmlru = container_of(head, struct list_lru_memcg, rcu);\n\tkvfree(mlru);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void kvfree_rcu(struct rcu_head *head)\n{\n\tstruct list_lru_memcg *mlru;\n\n\tmlru = container_of(head, struct list_lru_memcg, rcu);\n\tkvfree(mlru);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "s->memcg_params.memcg_caches"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_root_cache",
          "args": [
            "s"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "is_root_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "308-311",
          "snippet": "static inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn true;\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline bool is_root_cache(struct kmem_cache *s)\n{\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstatic void destroy_memcg_params(struct kmem_cache *s)\n{\n\tif (is_root_cache(s))\n\t\tkvfree(rcu_access_pointer(s->memcg_params.memcg_caches));\n}"
  },
  {
    "function_name": "init_memcg_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "142-168",
    "snippet": "static int init_memcg_params(struct kmem_cache *s,\n\t\tstruct mem_cgroup *memcg, struct kmem_cache *root_cache)\n{\n\tstruct memcg_cache_array *arr;\n\n\tif (root_cache) {\n\t\ts->memcg_params.root_cache = root_cache;\n\t\ts->memcg_params.memcg = memcg;\n\t\tINIT_LIST_HEAD(&s->memcg_params.children_node);\n\t\tINIT_LIST_HEAD(&s->memcg_params.kmem_caches_node);\n\t\treturn 0;\n\t}\n\n\tslab_init_memcg_params(s);\n\n\tif (!memcg_nr_cache_ids)\n\t\treturn 0;\n\n\tarr = kvzalloc(sizeof(struct memcg_cache_array) +\n\t\t       memcg_nr_cache_ids * sizeof(void *),\n\t\t       GFP_KERNEL);\n\tif (!arr)\n\t\treturn -ENOMEM;\n\n\tRCU_INIT_POINTER(s->memcg_params.memcg_caches, arr);\n\treturn 0;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "s->memcg_params.memcg_caches",
            "arr"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvzalloc",
          "args": [
            "sizeof(struct memcg_cache_array) +\n\t\t       memcg_nr_cache_ids * sizeof(void *)",
            "GFP_KERNEL"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_init_memcg_params",
          "args": [
            "s"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "slab_init_memcg_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "134-140",
          "snippet": "void slab_init_memcg_params(struct kmem_cache *s)\n{\n\ts->memcg_params.root_cache = NULL;\n\tRCU_INIT_POINTER(s->memcg_params.memcg_caches, NULL);\n\tINIT_LIST_HEAD(&s->memcg_params.children);\n\ts->memcg_params.dying = false;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nvoid slab_init_memcg_params(struct kmem_cache *s)\n{\n\ts->memcg_params.root_cache = NULL;\n\tRCU_INIT_POINTER(s->memcg_params.memcg_caches, NULL);\n\tINIT_LIST_HEAD(&s->memcg_params.children);\n\ts->memcg_params.dying = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&s->memcg_params.kmem_caches_node"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&s->memcg_params.children_node"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstatic int init_memcg_params(struct kmem_cache *s,\n\t\tstruct mem_cgroup *memcg, struct kmem_cache *root_cache)\n{\n\tstruct memcg_cache_array *arr;\n\n\tif (root_cache) {\n\t\ts->memcg_params.root_cache = root_cache;\n\t\ts->memcg_params.memcg = memcg;\n\t\tINIT_LIST_HEAD(&s->memcg_params.children_node);\n\t\tINIT_LIST_HEAD(&s->memcg_params.kmem_caches_node);\n\t\treturn 0;\n\t}\n\n\tslab_init_memcg_params(s);\n\n\tif (!memcg_nr_cache_ids)\n\t\treturn 0;\n\n\tarr = kvzalloc(sizeof(struct memcg_cache_array) +\n\t\t       memcg_nr_cache_ids * sizeof(void *),\n\t\t       GFP_KERNEL);\n\tif (!arr)\n\t\treturn -ENOMEM;\n\n\tRCU_INIT_POINTER(s->memcg_params.memcg_caches, arr);\n\treturn 0;\n}"
  },
  {
    "function_name": "slab_init_memcg_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "134-140",
    "snippet": "void slab_init_memcg_params(struct kmem_cache *s)\n{\n\ts->memcg_params.root_cache = NULL;\n\tRCU_INIT_POINTER(s->memcg_params.memcg_caches, NULL);\n\tINIT_LIST_HEAD(&s->memcg_params.children);\n\ts->memcg_params.dying = false;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&s->memcg_params.children"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "s->memcg_params.memcg_caches",
            "NULL"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nvoid slab_init_memcg_params(struct kmem_cache *s)\n{\n\ts->memcg_params.root_cache = NULL;\n\tRCU_INIT_POINTER(s->memcg_params.memcg_caches, NULL);\n\tINIT_LIST_HEAD(&s->memcg_params.children);\n\ts->memcg_params.dying = false;\n}"
  },
  {
    "function_name": "__kmem_cache_alloc_bulk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "115-128",
    "snippet": "int __kmem_cache_alloc_bulk(struct kmem_cache *s, gfp_t flags, size_t nr,\n\t\t\t\t\t\t\t\tvoid **p)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tvoid *x = p[i] = kmem_cache_alloc(s, flags);\n\t\tif (!x) {\n\t\t\t__kmem_cache_free_bulk(s, i, p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn i;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__kmem_cache_free_bulk",
          "args": [
            "s",
            "i",
            "p"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "__kmem_cache_free_bulk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "103-113",
          "snippet": "void __kmem_cache_free_bulk(struct kmem_cache *s, size_t nr, void **p)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tif (s)\n\t\t\tkmem_cache_free(s, p[i]);\n\t\telse\n\t\t\tkfree(p[i]);\n\t}\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nvoid __kmem_cache_free_bulk(struct kmem_cache *s, size_t nr, void **p)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tif (s)\n\t\t\tkmem_cache_free(s, p[i]);\n\t\telse\n\t\t\tkfree(p[i]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "s",
            "flags"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3550-3559",
          "snippet": "void *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\tvoid *ret = slab_alloc(cachep, flags, _RET_IP_);\n\n\tkasan_slab_alloc(cachep, ret, flags);\n\ttrace_kmem_cache_alloc(_RET_IP_, ret,\n\t\t\t       cachep->object_size, cachep->size, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\tvoid *ret = slab_alloc(cachep, flags, _RET_IP_);\n\n\tkasan_slab_alloc(cachep, ret, flags);\n\ttrace_kmem_cache_alloc(_RET_IP_, ret,\n\t\t\t       cachep->object_size, cachep->size, flags);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nint __kmem_cache_alloc_bulk(struct kmem_cache *s, gfp_t flags, size_t nr,\n\t\t\t\t\t\t\t\tvoid **p)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tvoid *x = p[i] = kmem_cache_alloc(s, flags);\n\t\tif (!x) {\n\t\t\t__kmem_cache_free_bulk(s, i, p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn i;\n}"
  },
  {
    "function_name": "__kmem_cache_free_bulk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "103-113",
    "snippet": "void __kmem_cache_free_bulk(struct kmem_cache *s, size_t nr, void **p)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tif (s)\n\t\t\tkmem_cache_free(s, p[i]);\n\t\telse\n\t\t\tkfree(p[i]);\n\t}\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "p[i]"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "s",
            "p[i]"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3749-3764",
          "snippet": "void kmem_cache_free(struct kmem_cache *cachep, void *objp)\n{\n\tunsigned long flags;\n\tcachep = cache_from_obj(cachep, objp);\n\tif (!cachep)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tdebug_check_no_locks_freed(objp, cachep->object_size);\n\tif (!(cachep->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(objp, cachep->object_size);\n\t__cache_free(cachep, objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n\n\ttrace_kmem_cache_free(_RET_IP_, objp);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid kmem_cache_free(struct kmem_cache *cachep, void *objp)\n{\n\tunsigned long flags;\n\tcachep = cache_from_obj(cachep, objp);\n\tif (!cachep)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tdebug_check_no_locks_freed(objp, cachep->object_size);\n\tif (!(cachep->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(objp, cachep->object_size);\n\t__cache_free(cachep, objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n\n\ttrace_kmem_cache_free(_RET_IP_, objp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nvoid __kmem_cache_free_bulk(struct kmem_cache *s, size_t nr, void **p)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tif (s)\n\t\t\tkmem_cache_free(s, p[i]);\n\t\telse\n\t\t\tkfree(p[i]);\n\t}\n}"
  },
  {
    "function_name": "kmem_cache_sanity_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "97-100",
    "snippet": "static inline int kmem_cache_sanity_check(const char *name, unsigned int size)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstatic inline int kmem_cache_sanity_check(const char *name, unsigned int size)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "kmem_cache_sanity_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "85-95",
    "snippet": "static int kmem_cache_sanity_check(const char *name, unsigned int size)\n{\n\tif (!name || in_interrupt() || size < sizeof(void *) ||\n\t\tsize > KMALLOC_MAX_SIZE) {\n\t\tpr_err(\"kmem_cache_create(%s) integrity check failed\\n\", name);\n\t\treturn -EINVAL;\n\t}\n\n\tWARN_ON(strchr(name, ' '));\t/* It confuses parsers */\n\treturn 0;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "strchr(name, ' ')"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "name",
            "' '"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"kmem_cache_create(%s) integrity check failed\\n\"",
            "name"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_interrupt",
          "args": [],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstatic int kmem_cache_sanity_check(const char *name, unsigned int size)\n{\n\tif (!name || in_interrupt() || size < sizeof(void *) ||\n\t\tsize > KMALLOC_MAX_SIZE) {\n\t\tpr_err(\"kmem_cache_create(%s) integrity check failed\\n\", name);\n\t\treturn -EINVAL;\n\t}\n\n\tWARN_ON(strchr(name, ' '));\t/* It confuses parsers */\n\treturn 0;\n}"
  },
  {
    "function_name": "kmem_cache_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "78-81",
    "snippet": "unsigned int kmem_cache_size(struct kmem_cache *s)\n{\n\treturn s->object_size;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *kmem_cache;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nunsigned int kmem_cache_size(struct kmem_cache *s)\n{\n\treturn s->object_size;\n}"
  },
  {
    "function_name": "setup_slab_nomerge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
    "lines": "63-67",
    "snippet": "static int __init setup_slab_nomerge(char *str)\n{\n\tslab_nomerge = true;\n\treturn 1;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <trace/events/kmem.h>",
      "#include <linux/memcontrol.h>",
      "#include <asm/page.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cache.h>",
      "#include <linux/memory.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/poison.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool slab_nomerge = !IS_ENABLED(CONFIG_SLAB_MERGE_DEFAULT);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstatic bool slab_nomerge = !IS_ENABLED(CONFIG_SLAB_MERGE_DEFAULT);\n\nstatic int __init setup_slab_nomerge(char *str)\n{\n\tslab_nomerge = true;\n\treturn 1;\n}"
  }
]