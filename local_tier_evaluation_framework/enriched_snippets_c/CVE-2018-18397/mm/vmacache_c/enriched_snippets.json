[
  {
    "function_name": "vmacache_find_exact",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmacache.c",
    "lines": "93-117",
    "snippet": "struct vm_area_struct *vmacache_find_exact(struct mm_struct *mm,\n\t\t\t\t\t   unsigned long start,\n\t\t\t\t\t   unsigned long end)\n{\n\tint idx = VMACACHE_HASH(start);\n\tint i;\n\n\tcount_vm_vmacache_event(VMACACHE_FIND_CALLS);\n\n\tif (!vmacache_valid(mm))\n\t\treturn NULL;\n\n\tfor (i = 0; i < VMACACHE_SIZE; i++) {\n\t\tstruct vm_area_struct *vma = current->vmacache.vmas[idx];\n\n\t\tif (vma && vma->vm_start == start && vma->vm_end == end) {\n\t\t\tcount_vm_vmacache_event(VMACACHE_FIND_HITS);\n\t\t\treturn vma;\n\t\t}\n\t\tif (++idx == VMACACHE_SIZE)\n\t\t\tidx = 0;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "count_vm_vmacache_event",
          "args": [
            "VMACACHE_FIND_HITS"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmacache_valid",
          "args": [
            "mm"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "vmacache_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmacache.c",
          "lines": "42-60",
          "snippet": "static bool vmacache_valid(struct mm_struct *mm)\n{\n\tstruct task_struct *curr;\n\n\tif (!vmacache_valid_mm(mm))\n\t\treturn false;\n\n\tcurr = current;\n\tif (mm->vmacache_seqnum != curr->vmacache.seqnum) {\n\t\t/*\n\t\t * First attempt will always be invalid, initialize\n\t\t * the new cache for this task here.\n\t\t */\n\t\tcurr->vmacache.seqnum = mm->vmacache_seqnum;\n\t\tvmacache_flush(curr);\n\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n\nstatic bool vmacache_valid(struct mm_struct *mm)\n{\n\tstruct task_struct *curr;\n\n\tif (!vmacache_valid_mm(mm))\n\t\treturn false;\n\n\tcurr = current;\n\tif (mm->vmacache_seqnum != curr->vmacache.seqnum) {\n\t\t/*\n\t\t * First attempt will always be invalid, initialize\n\t\t * the new cache for this task here.\n\t\t */\n\t\tcurr->vmacache.seqnum = mm->vmacache_seqnum;\n\t\tvmacache_flush(curr);\n\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "count_vm_vmacache_event",
          "args": [
            "VMACACHE_FIND_CALLS"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMACACHE_HASH",
          "args": [
            "start"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n\nstruct vm_area_struct *vmacache_find_exact(struct mm_struct *mm,\n\t\t\t\t\t   unsigned long start,\n\t\t\t\t\t   unsigned long end)\n{\n\tint idx = VMACACHE_HASH(start);\n\tint i;\n\n\tcount_vm_vmacache_event(VMACACHE_FIND_CALLS);\n\n\tif (!vmacache_valid(mm))\n\t\treturn NULL;\n\n\tfor (i = 0; i < VMACACHE_SIZE; i++) {\n\t\tstruct vm_area_struct *vma = current->vmacache.vmas[idx];\n\n\t\tif (vma && vma->vm_start == start && vma->vm_end == end) {\n\t\t\tcount_vm_vmacache_event(VMACACHE_FIND_HITS);\n\t\t\treturn vma;\n\t\t}\n\t\tif (++idx == VMACACHE_SIZE)\n\t\t\tidx = 0;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "vmacache_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmacache.c",
    "lines": "62-90",
    "snippet": "struct vm_area_struct *vmacache_find(struct mm_struct *mm, unsigned long addr)\n{\n\tint idx = VMACACHE_HASH(addr);\n\tint i;\n\n\tcount_vm_vmacache_event(VMACACHE_FIND_CALLS);\n\n\tif (!vmacache_valid(mm))\n\t\treturn NULL;\n\n\tfor (i = 0; i < VMACACHE_SIZE; i++) {\n\t\tstruct vm_area_struct *vma = current->vmacache.vmas[idx];\n\n\t\tif (vma) {\n#ifdef CONFIG_DEBUG_VM_VMACACHE\n\t\t\tif (WARN_ON_ONCE(vma->vm_mm != mm))\n\t\t\t\tbreak;\n#endif\n\t\t\tif (vma->vm_start <= addr && vma->vm_end > addr) {\n\t\t\t\tcount_vm_vmacache_event(VMACACHE_FIND_HITS);\n\t\t\t\treturn vma;\n\t\t\t}\n\t\t}\n\t\tif (++idx == VMACACHE_SIZE)\n\t\t\tidx = 0;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "count_vm_vmacache_event",
          "args": [
            "VMACACHE_FIND_HITS"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "vma->vm_mm != mm"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmacache_valid",
          "args": [
            "mm"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "vmacache_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmacache.c",
          "lines": "42-60",
          "snippet": "static bool vmacache_valid(struct mm_struct *mm)\n{\n\tstruct task_struct *curr;\n\n\tif (!vmacache_valid_mm(mm))\n\t\treturn false;\n\n\tcurr = current;\n\tif (mm->vmacache_seqnum != curr->vmacache.seqnum) {\n\t\t/*\n\t\t * First attempt will always be invalid, initialize\n\t\t * the new cache for this task here.\n\t\t */\n\t\tcurr->vmacache.seqnum = mm->vmacache_seqnum;\n\t\tvmacache_flush(curr);\n\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n\nstatic bool vmacache_valid(struct mm_struct *mm)\n{\n\tstruct task_struct *curr;\n\n\tif (!vmacache_valid_mm(mm))\n\t\treturn false;\n\n\tcurr = current;\n\tif (mm->vmacache_seqnum != curr->vmacache.seqnum) {\n\t\t/*\n\t\t * First attempt will always be invalid, initialize\n\t\t * the new cache for this task here.\n\t\t */\n\t\tcurr->vmacache.seqnum = mm->vmacache_seqnum;\n\t\tvmacache_flush(curr);\n\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "count_vm_vmacache_event",
          "args": [
            "VMACACHE_FIND_CALLS"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMACACHE_HASH",
          "args": [
            "addr"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n\nstruct vm_area_struct *vmacache_find(struct mm_struct *mm, unsigned long addr)\n{\n\tint idx = VMACACHE_HASH(addr);\n\tint i;\n\n\tcount_vm_vmacache_event(VMACACHE_FIND_CALLS);\n\n\tif (!vmacache_valid(mm))\n\t\treturn NULL;\n\n\tfor (i = 0; i < VMACACHE_SIZE; i++) {\n\t\tstruct vm_area_struct *vma = current->vmacache.vmas[idx];\n\n\t\tif (vma) {\n#ifdef CONFIG_DEBUG_VM_VMACACHE\n\t\t\tif (WARN_ON_ONCE(vma->vm_mm != mm))\n\t\t\t\tbreak;\n#endif\n\t\t\tif (vma->vm_start <= addr && vma->vm_end > addr) {\n\t\t\t\tcount_vm_vmacache_event(VMACACHE_FIND_HITS);\n\t\t\t\treturn vma;\n\t\t\t}\n\t\t}\n\t\tif (++idx == VMACACHE_SIZE)\n\t\t\tidx = 0;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "vmacache_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmacache.c",
    "lines": "42-60",
    "snippet": "static bool vmacache_valid(struct mm_struct *mm)\n{\n\tstruct task_struct *curr;\n\n\tif (!vmacache_valid_mm(mm))\n\t\treturn false;\n\n\tcurr = current;\n\tif (mm->vmacache_seqnum != curr->vmacache.seqnum) {\n\t\t/*\n\t\t * First attempt will always be invalid, initialize\n\t\t * the new cache for this task here.\n\t\t */\n\t\tcurr->vmacache.seqnum = mm->vmacache_seqnum;\n\t\tvmacache_flush(curr);\n\t\treturn false;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmacache_flush",
          "args": [
            "curr"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmacache_valid_mm",
          "args": [
            "mm"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "vmacache_valid_mm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmacache.c",
          "lines": "31-34",
          "snippet": "static inline bool vmacache_valid_mm(struct mm_struct *mm)\n{\n\treturn current->mm == mm && !(current->flags & PF_KTHREAD);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n\nstatic inline bool vmacache_valid_mm(struct mm_struct *mm)\n{\n\treturn current->mm == mm && !(current->flags & PF_KTHREAD);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n\nstatic bool vmacache_valid(struct mm_struct *mm)\n{\n\tstruct task_struct *curr;\n\n\tif (!vmacache_valid_mm(mm))\n\t\treturn false;\n\n\tcurr = current;\n\tif (mm->vmacache_seqnum != curr->vmacache.seqnum) {\n\t\t/*\n\t\t * First attempt will always be invalid, initialize\n\t\t * the new cache for this task here.\n\t\t */\n\t\tcurr->vmacache.seqnum = mm->vmacache_seqnum;\n\t\tvmacache_flush(curr);\n\t\treturn false;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "vmacache_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmacache.c",
    "lines": "36-40",
    "snippet": "void vmacache_update(unsigned long addr, struct vm_area_struct *newvma)\n{\n\tif (vmacache_valid_mm(newvma->vm_mm))\n\t\tcurrent->vmacache.vmas[VMACACHE_HASH(addr)] = newvma;\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VMACACHE_HASH",
          "args": [
            "addr"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmacache_valid_mm",
          "args": [
            "newvma->vm_mm"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "vmacache_valid_mm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmacache.c",
          "lines": "31-34",
          "snippet": "static inline bool vmacache_valid_mm(struct mm_struct *mm)\n{\n\treturn current->mm == mm && !(current->flags & PF_KTHREAD);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n\nstatic inline bool vmacache_valid_mm(struct mm_struct *mm)\n{\n\treturn current->mm == mm && !(current->flags & PF_KTHREAD);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n\nvoid vmacache_update(unsigned long addr, struct vm_area_struct *newvma)\n{\n\tif (vmacache_valid_mm(newvma->vm_mm))\n\t\tcurrent->vmacache.vmas[VMACACHE_HASH(addr)] = newvma;\n}"
  },
  {
    "function_name": "vmacache_valid_mm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmacache.c",
    "lines": "31-34",
    "snippet": "static inline bool vmacache_valid_mm(struct mm_struct *mm)\n{\n\treturn current->mm == mm && !(current->flags & PF_KTHREAD);\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n\nstatic inline bool vmacache_valid_mm(struct mm_struct *mm)\n{\n\treturn current->mm == mm && !(current->flags & PF_KTHREAD);\n}"
  }
]