[
  {
    "function_name": "compat_process_vm_rw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/process_vm_access.c",
    "lines": "315-352",
    "snippet": "static ssize_t\ncompat_process_vm_rw(compat_pid_t pid,\n\t\t     const struct compat_iovec __user *lvec,\n\t\t     unsigned long liovcnt,\n\t\t     const struct compat_iovec __user *rvec,\n\t\t     unsigned long riovcnt,\n\t\t     unsigned long flags, int vm_write)\n{\n\tstruct iovec iovstack_l[UIO_FASTIOV];\n\tstruct iovec iovstack_r[UIO_FASTIOV];\n\tstruct iovec *iov_l = iovstack_l;\n\tstruct iovec *iov_r = iovstack_r;\n\tstruct iov_iter iter;\n\tssize_t rc = -EFAULT;\n\tint dir = vm_write ? WRITE : READ;\n\n\tif (flags != 0)\n\t\treturn -EINVAL;\n\n\trc = compat_import_iovec(dir, lvec, liovcnt, UIO_FASTIOV, &iov_l, &iter);\n\tif (rc < 0)\n\t\treturn rc;\n\tif (!iov_iter_count(&iter))\n\t\tgoto free_iovecs;\n\trc = compat_rw_copy_check_uvector(CHECK_IOVEC_ONLY, rvec, riovcnt,\n\t\t\t\t\t  UIO_FASTIOV, iovstack_r,\n\t\t\t\t\t  &iov_r);\n\tif (rc <= 0)\n\t\tgoto free_iovecs;\n\n\trc = process_vm_rw_core(pid, &iter, iov_r, riovcnt, flags, vm_write);\n\nfree_iovecs:\n\tif (iov_r != iovstack_r)\n\t\tkfree(iov_r);\n\tkfree(iov_l);\n\treturn rc;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "iov_l"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_vm_rw_core",
          "args": [
            "pid",
            "&iter",
            "iov_r",
            "riovcnt",
            "flags",
            "vm_write"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "process_vm_rw_core",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/process_vm_access.c",
          "lines": "155-242",
          "snippet": "static ssize_t process_vm_rw_core(pid_t pid, struct iov_iter *iter,\n\t\t\t\t  const struct iovec *rvec,\n\t\t\t\t  unsigned long riovcnt,\n\t\t\t\t  unsigned long flags, int vm_write)\n{\n\tstruct task_struct *task;\n\tstruct page *pp_stack[PVM_MAX_PP_ARRAY_COUNT];\n\tstruct page **process_pages = pp_stack;\n\tstruct mm_struct *mm;\n\tunsigned long i;\n\tssize_t rc = 0;\n\tunsigned long nr_pages = 0;\n\tunsigned long nr_pages_iov;\n\tssize_t iov_len;\n\tsize_t total_len = iov_iter_count(iter);\n\n\t/*\n\t * Work out how many pages of struct pages we're going to need\n\t * when eventually calling get_user_pages\n\t */\n\tfor (i = 0; i < riovcnt; i++) {\n\t\tiov_len = rvec[i].iov_len;\n\t\tif (iov_len > 0) {\n\t\t\tnr_pages_iov = ((unsigned long)rvec[i].iov_base\n\t\t\t\t\t+ iov_len)\n\t\t\t\t/ PAGE_SIZE - (unsigned long)rvec[i].iov_base\n\t\t\t\t/ PAGE_SIZE + 1;\n\t\t\tnr_pages = max(nr_pages, nr_pages_iov);\n\t\t}\n\t}\n\n\tif (nr_pages == 0)\n\t\treturn 0;\n\n\tif (nr_pages > PVM_MAX_PP_ARRAY_COUNT) {\n\t\t/* For reliability don't try to kmalloc more than\n\t\t   2 pages worth */\n\t\tprocess_pages = kmalloc(min_t(size_t, PVM_MAX_KMALLOC_PAGES,\n\t\t\t\t\t      sizeof(struct pages *)*nr_pages),\n\t\t\t\t\tGFP_KERNEL);\n\n\t\tif (!process_pages)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* Get process information */\n\ttask = find_get_task_by_vpid(pid);\n\tif (!task) {\n\t\trc = -ESRCH;\n\t\tgoto free_proc_pages;\n\t}\n\n\tmm = mm_access(task, PTRACE_MODE_ATTACH_REALCREDS);\n\tif (!mm || IS_ERR(mm)) {\n\t\trc = IS_ERR(mm) ? PTR_ERR(mm) : -ESRCH;\n\t\t/*\n\t\t * Explicitly map EACCES to EPERM as EPERM is a more a\n\t\t * appropriate error code for process_vw_readv/writev\n\t\t */\n\t\tif (rc == -EACCES)\n\t\t\trc = -EPERM;\n\t\tgoto put_task_struct;\n\t}\n\n\tfor (i = 0; i < riovcnt && iov_iter_count(iter) && !rc; i++)\n\t\trc = process_vm_rw_single_vec(\n\t\t\t(unsigned long)rvec[i].iov_base, rvec[i].iov_len,\n\t\t\titer, process_pages, mm, task, vm_write);\n\n\t/* copied = space before - space after */\n\ttotal_len -= iov_iter_count(iter);\n\n\t/* If we have managed to copy any data at all then\n\t   we return the number of bytes copied. Otherwise\n\t   we return the error code */\n\tif (total_len)\n\t\trc = total_len;\n\n\tmmput(mm);\n\nput_task_struct:\n\tput_task_struct(task);\n\nfree_proc_pages:\n\tif (process_pages != pp_stack)\n\t\tkfree(process_pages);\n\treturn rc;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define PVM_MAX_PP_ARRAY_COUNT 16",
            "#define PVM_MAX_KMALLOC_PAGES (PAGE_SIZE * 2)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/mm.h>\n\n#define PVM_MAX_PP_ARRAY_COUNT 16\n#define PVM_MAX_KMALLOC_PAGES (PAGE_SIZE * 2)\n\nstatic ssize_t process_vm_rw_core(pid_t pid, struct iov_iter *iter,\n\t\t\t\t  const struct iovec *rvec,\n\t\t\t\t  unsigned long riovcnt,\n\t\t\t\t  unsigned long flags, int vm_write)\n{\n\tstruct task_struct *task;\n\tstruct page *pp_stack[PVM_MAX_PP_ARRAY_COUNT];\n\tstruct page **process_pages = pp_stack;\n\tstruct mm_struct *mm;\n\tunsigned long i;\n\tssize_t rc = 0;\n\tunsigned long nr_pages = 0;\n\tunsigned long nr_pages_iov;\n\tssize_t iov_len;\n\tsize_t total_len = iov_iter_count(iter);\n\n\t/*\n\t * Work out how many pages of struct pages we're going to need\n\t * when eventually calling get_user_pages\n\t */\n\tfor (i = 0; i < riovcnt; i++) {\n\t\tiov_len = rvec[i].iov_len;\n\t\tif (iov_len > 0) {\n\t\t\tnr_pages_iov = ((unsigned long)rvec[i].iov_base\n\t\t\t\t\t+ iov_len)\n\t\t\t\t/ PAGE_SIZE - (unsigned long)rvec[i].iov_base\n\t\t\t\t/ PAGE_SIZE + 1;\n\t\t\tnr_pages = max(nr_pages, nr_pages_iov);\n\t\t}\n\t}\n\n\tif (nr_pages == 0)\n\t\treturn 0;\n\n\tif (nr_pages > PVM_MAX_PP_ARRAY_COUNT) {\n\t\t/* For reliability don't try to kmalloc more than\n\t\t   2 pages worth */\n\t\tprocess_pages = kmalloc(min_t(size_t, PVM_MAX_KMALLOC_PAGES,\n\t\t\t\t\t      sizeof(struct pages *)*nr_pages),\n\t\t\t\t\tGFP_KERNEL);\n\n\t\tif (!process_pages)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* Get process information */\n\ttask = find_get_task_by_vpid(pid);\n\tif (!task) {\n\t\trc = -ESRCH;\n\t\tgoto free_proc_pages;\n\t}\n\n\tmm = mm_access(task, PTRACE_MODE_ATTACH_REALCREDS);\n\tif (!mm || IS_ERR(mm)) {\n\t\trc = IS_ERR(mm) ? PTR_ERR(mm) : -ESRCH;\n\t\t/*\n\t\t * Explicitly map EACCES to EPERM as EPERM is a more a\n\t\t * appropriate error code for process_vw_readv/writev\n\t\t */\n\t\tif (rc == -EACCES)\n\t\t\trc = -EPERM;\n\t\tgoto put_task_struct;\n\t}\n\n\tfor (i = 0; i < riovcnt && iov_iter_count(iter) && !rc; i++)\n\t\trc = process_vm_rw_single_vec(\n\t\t\t(unsigned long)rvec[i].iov_base, rvec[i].iov_len,\n\t\t\titer, process_pages, mm, task, vm_write);\n\n\t/* copied = space before - space after */\n\ttotal_len -= iov_iter_count(iter);\n\n\t/* If we have managed to copy any data at all then\n\t   we return the number of bytes copied. Otherwise\n\t   we return the error code */\n\tif (total_len)\n\t\trc = total_len;\n\n\tmmput(mm);\n\nput_task_struct:\n\tput_task_struct(task);\n\nfree_proc_pages:\n\tif (process_pages != pp_stack)\n\t\tkfree(process_pages);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_rw_copy_check_uvector",
          "args": [
            "CHECK_IOVEC_ONLY",
            "rvec",
            "riovcnt",
            "UIO_FASTIOV",
            "iovstack_r",
            "&iov_r"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "&iter"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_import_iovec",
          "args": [
            "dir",
            "lvec",
            "liovcnt",
            "UIO_FASTIOV",
            "&iov_l",
            "&iter"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/mm.h>\n\nstatic ssize_t\ncompat_process_vm_rw(compat_pid_t pid,\n\t\t     const struct compat_iovec __user *lvec,\n\t\t     unsigned long liovcnt,\n\t\t     const struct compat_iovec __user *rvec,\n\t\t     unsigned long riovcnt,\n\t\t     unsigned long flags, int vm_write)\n{\n\tstruct iovec iovstack_l[UIO_FASTIOV];\n\tstruct iovec iovstack_r[UIO_FASTIOV];\n\tstruct iovec *iov_l = iovstack_l;\n\tstruct iovec *iov_r = iovstack_r;\n\tstruct iov_iter iter;\n\tssize_t rc = -EFAULT;\n\tint dir = vm_write ? WRITE : READ;\n\n\tif (flags != 0)\n\t\treturn -EINVAL;\n\n\trc = compat_import_iovec(dir, lvec, liovcnt, UIO_FASTIOV, &iov_l, &iter);\n\tif (rc < 0)\n\t\treturn rc;\n\tif (!iov_iter_count(&iter))\n\t\tgoto free_iovecs;\n\trc = compat_rw_copy_check_uvector(CHECK_IOVEC_ONLY, rvec, riovcnt,\n\t\t\t\t\t  UIO_FASTIOV, iovstack_r,\n\t\t\t\t\t  &iov_r);\n\tif (rc <= 0)\n\t\tgoto free_iovecs;\n\n\trc = process_vm_rw_core(pid, &iter, iov_r, riovcnt, flags, vm_write);\n\nfree_iovecs:\n\tif (iov_r != iovstack_r)\n\t\tkfree(iov_r);\n\tkfree(iov_l);\n\treturn rc;\n}"
  },
  {
    "function_name": "process_vm_rw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/process_vm_access.c",
    "lines": "258-296",
    "snippet": "static ssize_t process_vm_rw(pid_t pid,\n\t\t\t     const struct iovec __user *lvec,\n\t\t\t     unsigned long liovcnt,\n\t\t\t     const struct iovec __user *rvec,\n\t\t\t     unsigned long riovcnt,\n\t\t\t     unsigned long flags, int vm_write)\n{\n\tstruct iovec iovstack_l[UIO_FASTIOV];\n\tstruct iovec iovstack_r[UIO_FASTIOV];\n\tstruct iovec *iov_l = iovstack_l;\n\tstruct iovec *iov_r = iovstack_r;\n\tstruct iov_iter iter;\n\tssize_t rc;\n\tint dir = vm_write ? WRITE : READ;\n\n\tif (flags != 0)\n\t\treturn -EINVAL;\n\n\t/* Check iovecs */\n\trc = import_iovec(dir, lvec, liovcnt, UIO_FASTIOV, &iov_l, &iter);\n\tif (rc < 0)\n\t\treturn rc;\n\tif (!iov_iter_count(&iter))\n\t\tgoto free_iovecs;\n\n\trc = rw_copy_check_uvector(CHECK_IOVEC_ONLY, rvec, riovcnt, UIO_FASTIOV,\n\t\t\t\t   iovstack_r, &iov_r);\n\tif (rc <= 0)\n\t\tgoto free_iovecs;\n\n\trc = process_vm_rw_core(pid, &iter, iov_r, riovcnt, flags, vm_write);\n\nfree_iovecs:\n\tif (iov_r != iovstack_r)\n\t\tkfree(iov_r);\n\tkfree(iov_l);\n\n\treturn rc;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "iov_l"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_vm_rw_core",
          "args": [
            "pid",
            "&iter",
            "iov_r",
            "riovcnt",
            "flags",
            "vm_write"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "process_vm_rw_core",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/process_vm_access.c",
          "lines": "155-242",
          "snippet": "static ssize_t process_vm_rw_core(pid_t pid, struct iov_iter *iter,\n\t\t\t\t  const struct iovec *rvec,\n\t\t\t\t  unsigned long riovcnt,\n\t\t\t\t  unsigned long flags, int vm_write)\n{\n\tstruct task_struct *task;\n\tstruct page *pp_stack[PVM_MAX_PP_ARRAY_COUNT];\n\tstruct page **process_pages = pp_stack;\n\tstruct mm_struct *mm;\n\tunsigned long i;\n\tssize_t rc = 0;\n\tunsigned long nr_pages = 0;\n\tunsigned long nr_pages_iov;\n\tssize_t iov_len;\n\tsize_t total_len = iov_iter_count(iter);\n\n\t/*\n\t * Work out how many pages of struct pages we're going to need\n\t * when eventually calling get_user_pages\n\t */\n\tfor (i = 0; i < riovcnt; i++) {\n\t\tiov_len = rvec[i].iov_len;\n\t\tif (iov_len > 0) {\n\t\t\tnr_pages_iov = ((unsigned long)rvec[i].iov_base\n\t\t\t\t\t+ iov_len)\n\t\t\t\t/ PAGE_SIZE - (unsigned long)rvec[i].iov_base\n\t\t\t\t/ PAGE_SIZE + 1;\n\t\t\tnr_pages = max(nr_pages, nr_pages_iov);\n\t\t}\n\t}\n\n\tif (nr_pages == 0)\n\t\treturn 0;\n\n\tif (nr_pages > PVM_MAX_PP_ARRAY_COUNT) {\n\t\t/* For reliability don't try to kmalloc more than\n\t\t   2 pages worth */\n\t\tprocess_pages = kmalloc(min_t(size_t, PVM_MAX_KMALLOC_PAGES,\n\t\t\t\t\t      sizeof(struct pages *)*nr_pages),\n\t\t\t\t\tGFP_KERNEL);\n\n\t\tif (!process_pages)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* Get process information */\n\ttask = find_get_task_by_vpid(pid);\n\tif (!task) {\n\t\trc = -ESRCH;\n\t\tgoto free_proc_pages;\n\t}\n\n\tmm = mm_access(task, PTRACE_MODE_ATTACH_REALCREDS);\n\tif (!mm || IS_ERR(mm)) {\n\t\trc = IS_ERR(mm) ? PTR_ERR(mm) : -ESRCH;\n\t\t/*\n\t\t * Explicitly map EACCES to EPERM as EPERM is a more a\n\t\t * appropriate error code for process_vw_readv/writev\n\t\t */\n\t\tif (rc == -EACCES)\n\t\t\trc = -EPERM;\n\t\tgoto put_task_struct;\n\t}\n\n\tfor (i = 0; i < riovcnt && iov_iter_count(iter) && !rc; i++)\n\t\trc = process_vm_rw_single_vec(\n\t\t\t(unsigned long)rvec[i].iov_base, rvec[i].iov_len,\n\t\t\titer, process_pages, mm, task, vm_write);\n\n\t/* copied = space before - space after */\n\ttotal_len -= iov_iter_count(iter);\n\n\t/* If we have managed to copy any data at all then\n\t   we return the number of bytes copied. Otherwise\n\t   we return the error code */\n\tif (total_len)\n\t\trc = total_len;\n\n\tmmput(mm);\n\nput_task_struct:\n\tput_task_struct(task);\n\nfree_proc_pages:\n\tif (process_pages != pp_stack)\n\t\tkfree(process_pages);\n\treturn rc;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define PVM_MAX_PP_ARRAY_COUNT 16",
            "#define PVM_MAX_KMALLOC_PAGES (PAGE_SIZE * 2)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/mm.h>\n\n#define PVM_MAX_PP_ARRAY_COUNT 16\n#define PVM_MAX_KMALLOC_PAGES (PAGE_SIZE * 2)\n\nstatic ssize_t process_vm_rw_core(pid_t pid, struct iov_iter *iter,\n\t\t\t\t  const struct iovec *rvec,\n\t\t\t\t  unsigned long riovcnt,\n\t\t\t\t  unsigned long flags, int vm_write)\n{\n\tstruct task_struct *task;\n\tstruct page *pp_stack[PVM_MAX_PP_ARRAY_COUNT];\n\tstruct page **process_pages = pp_stack;\n\tstruct mm_struct *mm;\n\tunsigned long i;\n\tssize_t rc = 0;\n\tunsigned long nr_pages = 0;\n\tunsigned long nr_pages_iov;\n\tssize_t iov_len;\n\tsize_t total_len = iov_iter_count(iter);\n\n\t/*\n\t * Work out how many pages of struct pages we're going to need\n\t * when eventually calling get_user_pages\n\t */\n\tfor (i = 0; i < riovcnt; i++) {\n\t\tiov_len = rvec[i].iov_len;\n\t\tif (iov_len > 0) {\n\t\t\tnr_pages_iov = ((unsigned long)rvec[i].iov_base\n\t\t\t\t\t+ iov_len)\n\t\t\t\t/ PAGE_SIZE - (unsigned long)rvec[i].iov_base\n\t\t\t\t/ PAGE_SIZE + 1;\n\t\t\tnr_pages = max(nr_pages, nr_pages_iov);\n\t\t}\n\t}\n\n\tif (nr_pages == 0)\n\t\treturn 0;\n\n\tif (nr_pages > PVM_MAX_PP_ARRAY_COUNT) {\n\t\t/* For reliability don't try to kmalloc more than\n\t\t   2 pages worth */\n\t\tprocess_pages = kmalloc(min_t(size_t, PVM_MAX_KMALLOC_PAGES,\n\t\t\t\t\t      sizeof(struct pages *)*nr_pages),\n\t\t\t\t\tGFP_KERNEL);\n\n\t\tif (!process_pages)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* Get process information */\n\ttask = find_get_task_by_vpid(pid);\n\tif (!task) {\n\t\trc = -ESRCH;\n\t\tgoto free_proc_pages;\n\t}\n\n\tmm = mm_access(task, PTRACE_MODE_ATTACH_REALCREDS);\n\tif (!mm || IS_ERR(mm)) {\n\t\trc = IS_ERR(mm) ? PTR_ERR(mm) : -ESRCH;\n\t\t/*\n\t\t * Explicitly map EACCES to EPERM as EPERM is a more a\n\t\t * appropriate error code for process_vw_readv/writev\n\t\t */\n\t\tif (rc == -EACCES)\n\t\t\trc = -EPERM;\n\t\tgoto put_task_struct;\n\t}\n\n\tfor (i = 0; i < riovcnt && iov_iter_count(iter) && !rc; i++)\n\t\trc = process_vm_rw_single_vec(\n\t\t\t(unsigned long)rvec[i].iov_base, rvec[i].iov_len,\n\t\t\titer, process_pages, mm, task, vm_write);\n\n\t/* copied = space before - space after */\n\ttotal_len -= iov_iter_count(iter);\n\n\t/* If we have managed to copy any data at all then\n\t   we return the number of bytes copied. Otherwise\n\t   we return the error code */\n\tif (total_len)\n\t\trc = total_len;\n\n\tmmput(mm);\n\nput_task_struct:\n\tput_task_struct(task);\n\nfree_proc_pages:\n\tif (process_pages != pp_stack)\n\t\tkfree(process_pages);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rw_copy_check_uvector",
          "args": [
            "CHECK_IOVEC_ONLY",
            "rvec",
            "riovcnt",
            "UIO_FASTIOV",
            "iovstack_r",
            "&iov_r"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "&iter"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "import_iovec",
          "args": [
            "dir",
            "lvec",
            "liovcnt",
            "UIO_FASTIOV",
            "&iov_l",
            "&iter"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/mm.h>\n\nstatic ssize_t process_vm_rw(pid_t pid,\n\t\t\t     const struct iovec __user *lvec,\n\t\t\t     unsigned long liovcnt,\n\t\t\t     const struct iovec __user *rvec,\n\t\t\t     unsigned long riovcnt,\n\t\t\t     unsigned long flags, int vm_write)\n{\n\tstruct iovec iovstack_l[UIO_FASTIOV];\n\tstruct iovec iovstack_r[UIO_FASTIOV];\n\tstruct iovec *iov_l = iovstack_l;\n\tstruct iovec *iov_r = iovstack_r;\n\tstruct iov_iter iter;\n\tssize_t rc;\n\tint dir = vm_write ? WRITE : READ;\n\n\tif (flags != 0)\n\t\treturn -EINVAL;\n\n\t/* Check iovecs */\n\trc = import_iovec(dir, lvec, liovcnt, UIO_FASTIOV, &iov_l, &iter);\n\tif (rc < 0)\n\t\treturn rc;\n\tif (!iov_iter_count(&iter))\n\t\tgoto free_iovecs;\n\n\trc = rw_copy_check_uvector(CHECK_IOVEC_ONLY, rvec, riovcnt, UIO_FASTIOV,\n\t\t\t\t   iovstack_r, &iov_r);\n\tif (rc <= 0)\n\t\tgoto free_iovecs;\n\n\trc = process_vm_rw_core(pid, &iter, iov_r, riovcnt, flags, vm_write);\n\nfree_iovecs:\n\tif (iov_r != iovstack_r)\n\t\tkfree(iov_r);\n\tkfree(iov_l);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "process_vm_rw_core",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/process_vm_access.c",
    "lines": "155-242",
    "snippet": "static ssize_t process_vm_rw_core(pid_t pid, struct iov_iter *iter,\n\t\t\t\t  const struct iovec *rvec,\n\t\t\t\t  unsigned long riovcnt,\n\t\t\t\t  unsigned long flags, int vm_write)\n{\n\tstruct task_struct *task;\n\tstruct page *pp_stack[PVM_MAX_PP_ARRAY_COUNT];\n\tstruct page **process_pages = pp_stack;\n\tstruct mm_struct *mm;\n\tunsigned long i;\n\tssize_t rc = 0;\n\tunsigned long nr_pages = 0;\n\tunsigned long nr_pages_iov;\n\tssize_t iov_len;\n\tsize_t total_len = iov_iter_count(iter);\n\n\t/*\n\t * Work out how many pages of struct pages we're going to need\n\t * when eventually calling get_user_pages\n\t */\n\tfor (i = 0; i < riovcnt; i++) {\n\t\tiov_len = rvec[i].iov_len;\n\t\tif (iov_len > 0) {\n\t\t\tnr_pages_iov = ((unsigned long)rvec[i].iov_base\n\t\t\t\t\t+ iov_len)\n\t\t\t\t/ PAGE_SIZE - (unsigned long)rvec[i].iov_base\n\t\t\t\t/ PAGE_SIZE + 1;\n\t\t\tnr_pages = max(nr_pages, nr_pages_iov);\n\t\t}\n\t}\n\n\tif (nr_pages == 0)\n\t\treturn 0;\n\n\tif (nr_pages > PVM_MAX_PP_ARRAY_COUNT) {\n\t\t/* For reliability don't try to kmalloc more than\n\t\t   2 pages worth */\n\t\tprocess_pages = kmalloc(min_t(size_t, PVM_MAX_KMALLOC_PAGES,\n\t\t\t\t\t      sizeof(struct pages *)*nr_pages),\n\t\t\t\t\tGFP_KERNEL);\n\n\t\tif (!process_pages)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* Get process information */\n\ttask = find_get_task_by_vpid(pid);\n\tif (!task) {\n\t\trc = -ESRCH;\n\t\tgoto free_proc_pages;\n\t}\n\n\tmm = mm_access(task, PTRACE_MODE_ATTACH_REALCREDS);\n\tif (!mm || IS_ERR(mm)) {\n\t\trc = IS_ERR(mm) ? PTR_ERR(mm) : -ESRCH;\n\t\t/*\n\t\t * Explicitly map EACCES to EPERM as EPERM is a more a\n\t\t * appropriate error code for process_vw_readv/writev\n\t\t */\n\t\tif (rc == -EACCES)\n\t\t\trc = -EPERM;\n\t\tgoto put_task_struct;\n\t}\n\n\tfor (i = 0; i < riovcnt && iov_iter_count(iter) && !rc; i++)\n\t\trc = process_vm_rw_single_vec(\n\t\t\t(unsigned long)rvec[i].iov_base, rvec[i].iov_len,\n\t\t\titer, process_pages, mm, task, vm_write);\n\n\t/* copied = space before - space after */\n\ttotal_len -= iov_iter_count(iter);\n\n\t/* If we have managed to copy any data at all then\n\t   we return the number of bytes copied. Otherwise\n\t   we return the error code */\n\tif (total_len)\n\t\trc = total_len;\n\n\tmmput(mm);\n\nput_task_struct:\n\tput_task_struct(task);\n\nfree_proc_pages:\n\tif (process_pages != pp_stack)\n\t\tkfree(process_pages);\n\treturn rc;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define PVM_MAX_PP_ARRAY_COUNT 16",
      "#define PVM_MAX_KMALLOC_PAGES (PAGE_SIZE * 2)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "process_pages"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "mm"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_vm_rw_single_vec",
          "args": [
            "(unsigned long)rvec[i].iov_base",
            "rvec[i].iov_len",
            "iter",
            "process_pages",
            "mm",
            "task",
            "vm_write"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "process_vm_rw_single_vec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/process_vm_access.c",
          "lines": "78-136",
          "snippet": "static int process_vm_rw_single_vec(unsigned long addr,\n\t\t\t\t    unsigned long len,\n\t\t\t\t    struct iov_iter *iter,\n\t\t\t\t    struct page **process_pages,\n\t\t\t\t    struct mm_struct *mm,\n\t\t\t\t    struct task_struct *task,\n\t\t\t\t    int vm_write)\n{\n\tunsigned long pa = addr & PAGE_MASK;\n\tunsigned long start_offset = addr - pa;\n\tunsigned long nr_pages;\n\tssize_t rc = 0;\n\tunsigned long max_pages_per_loop = PVM_MAX_KMALLOC_PAGES\n\t\t/ sizeof(struct pages *);\n\tunsigned int flags = 0;\n\n\t/* Work out address and page range required */\n\tif (len == 0)\n\t\treturn 0;\n\tnr_pages = (addr + len - 1) / PAGE_SIZE - addr / PAGE_SIZE + 1;\n\n\tif (vm_write)\n\t\tflags |= FOLL_WRITE;\n\n\twhile (!rc && nr_pages && iov_iter_count(iter)) {\n\t\tint pages = min(nr_pages, max_pages_per_loop);\n\t\tint locked = 1;\n\t\tsize_t bytes;\n\n\t\t/*\n\t\t * Get the pages we're interested in.  We must\n\t\t * access remotely because task/mm might not\n\t\t * current/current->mm\n\t\t */\n\t\tdown_read(&mm->mmap_sem);\n\t\tpages = get_user_pages_remote(task, mm, pa, pages, flags,\n\t\t\t\t\t      process_pages, NULL, &locked);\n\t\tif (locked)\n\t\t\tup_read(&mm->mmap_sem);\n\t\tif (pages <= 0)\n\t\t\treturn -EFAULT;\n\n\t\tbytes = pages * PAGE_SIZE - start_offset;\n\t\tif (bytes > len)\n\t\t\tbytes = len;\n\n\t\trc = process_vm_rw_pages(process_pages,\n\t\t\t\t\t start_offset, bytes, iter,\n\t\t\t\t\t vm_write);\n\t\tlen -= bytes;\n\t\tstart_offset = 0;\n\t\tnr_pages -= pages;\n\t\tpa += pages * PAGE_SIZE;\n\t\twhile (pages)\n\t\t\tput_page(process_pages[--pages]);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define PVM_MAX_KMALLOC_PAGES (PAGE_SIZE * 2)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/mm.h>\n\n#define PVM_MAX_KMALLOC_PAGES (PAGE_SIZE * 2)\n\nstatic int process_vm_rw_single_vec(unsigned long addr,\n\t\t\t\t    unsigned long len,\n\t\t\t\t    struct iov_iter *iter,\n\t\t\t\t    struct page **process_pages,\n\t\t\t\t    struct mm_struct *mm,\n\t\t\t\t    struct task_struct *task,\n\t\t\t\t    int vm_write)\n{\n\tunsigned long pa = addr & PAGE_MASK;\n\tunsigned long start_offset = addr - pa;\n\tunsigned long nr_pages;\n\tssize_t rc = 0;\n\tunsigned long max_pages_per_loop = PVM_MAX_KMALLOC_PAGES\n\t\t/ sizeof(struct pages *);\n\tunsigned int flags = 0;\n\n\t/* Work out address and page range required */\n\tif (len == 0)\n\t\treturn 0;\n\tnr_pages = (addr + len - 1) / PAGE_SIZE - addr / PAGE_SIZE + 1;\n\n\tif (vm_write)\n\t\tflags |= FOLL_WRITE;\n\n\twhile (!rc && nr_pages && iov_iter_count(iter)) {\n\t\tint pages = min(nr_pages, max_pages_per_loop);\n\t\tint locked = 1;\n\t\tsize_t bytes;\n\n\t\t/*\n\t\t * Get the pages we're interested in.  We must\n\t\t * access remotely because task/mm might not\n\t\t * current/current->mm\n\t\t */\n\t\tdown_read(&mm->mmap_sem);\n\t\tpages = get_user_pages_remote(task, mm, pa, pages, flags,\n\t\t\t\t\t      process_pages, NULL, &locked);\n\t\tif (locked)\n\t\t\tup_read(&mm->mmap_sem);\n\t\tif (pages <= 0)\n\t\t\treturn -EFAULT;\n\n\t\tbytes = pages * PAGE_SIZE - start_offset;\n\t\tif (bytes > len)\n\t\t\tbytes = len;\n\n\t\trc = process_vm_rw_pages(process_pages,\n\t\t\t\t\t start_offset, bytes, iter,\n\t\t\t\t\t vm_write);\n\t\tlen -= bytes;\n\t\tstart_offset = 0;\n\t\tnr_pages -= pages;\n\t\tpa += pages * PAGE_SIZE;\n\t\twhile (pages)\n\t\t\tput_page(process_pages[--pages]);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "mm"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mm"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mm"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_access",
          "args": [
            "task",
            "PTRACE_MODE_ATTACH_REALCREDS"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_task_by_vpid",
          "args": [
            "pid"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "min_t(size_t, PVM_MAX_KMALLOC_PAGES,\n\t\t\t\t\t      sizeof(struct pages *)*nr_pages)",
            "GFP_KERNEL"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "__kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3729-3732",
          "snippet": "void *__kmalloc(size_t size, gfp_t flags)\n{\n\treturn __do_kmalloc(size, flags, _RET_IP_);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nvoid *__kmalloc(size_t size, gfp_t flags)\n{\n\treturn __do_kmalloc(size, flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "PVM_MAX_KMALLOC_PAGES",
            "sizeof(struct pages *)*nr_pages"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "nr_pages",
            "nr_pages_iov"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/mm.h>\n\n#define PVM_MAX_PP_ARRAY_COUNT 16\n#define PVM_MAX_KMALLOC_PAGES (PAGE_SIZE * 2)\n\nstatic ssize_t process_vm_rw_core(pid_t pid, struct iov_iter *iter,\n\t\t\t\t  const struct iovec *rvec,\n\t\t\t\t  unsigned long riovcnt,\n\t\t\t\t  unsigned long flags, int vm_write)\n{\n\tstruct task_struct *task;\n\tstruct page *pp_stack[PVM_MAX_PP_ARRAY_COUNT];\n\tstruct page **process_pages = pp_stack;\n\tstruct mm_struct *mm;\n\tunsigned long i;\n\tssize_t rc = 0;\n\tunsigned long nr_pages = 0;\n\tunsigned long nr_pages_iov;\n\tssize_t iov_len;\n\tsize_t total_len = iov_iter_count(iter);\n\n\t/*\n\t * Work out how many pages of struct pages we're going to need\n\t * when eventually calling get_user_pages\n\t */\n\tfor (i = 0; i < riovcnt; i++) {\n\t\tiov_len = rvec[i].iov_len;\n\t\tif (iov_len > 0) {\n\t\t\tnr_pages_iov = ((unsigned long)rvec[i].iov_base\n\t\t\t\t\t+ iov_len)\n\t\t\t\t/ PAGE_SIZE - (unsigned long)rvec[i].iov_base\n\t\t\t\t/ PAGE_SIZE + 1;\n\t\t\tnr_pages = max(nr_pages, nr_pages_iov);\n\t\t}\n\t}\n\n\tif (nr_pages == 0)\n\t\treturn 0;\n\n\tif (nr_pages > PVM_MAX_PP_ARRAY_COUNT) {\n\t\t/* For reliability don't try to kmalloc more than\n\t\t   2 pages worth */\n\t\tprocess_pages = kmalloc(min_t(size_t, PVM_MAX_KMALLOC_PAGES,\n\t\t\t\t\t      sizeof(struct pages *)*nr_pages),\n\t\t\t\t\tGFP_KERNEL);\n\n\t\tif (!process_pages)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* Get process information */\n\ttask = find_get_task_by_vpid(pid);\n\tif (!task) {\n\t\trc = -ESRCH;\n\t\tgoto free_proc_pages;\n\t}\n\n\tmm = mm_access(task, PTRACE_MODE_ATTACH_REALCREDS);\n\tif (!mm || IS_ERR(mm)) {\n\t\trc = IS_ERR(mm) ? PTR_ERR(mm) : -ESRCH;\n\t\t/*\n\t\t * Explicitly map EACCES to EPERM as EPERM is a more a\n\t\t * appropriate error code for process_vw_readv/writev\n\t\t */\n\t\tif (rc == -EACCES)\n\t\t\trc = -EPERM;\n\t\tgoto put_task_struct;\n\t}\n\n\tfor (i = 0; i < riovcnt && iov_iter_count(iter) && !rc; i++)\n\t\trc = process_vm_rw_single_vec(\n\t\t\t(unsigned long)rvec[i].iov_base, rvec[i].iov_len,\n\t\t\titer, process_pages, mm, task, vm_write);\n\n\t/* copied = space before - space after */\n\ttotal_len -= iov_iter_count(iter);\n\n\t/* If we have managed to copy any data at all then\n\t   we return the number of bytes copied. Otherwise\n\t   we return the error code */\n\tif (total_len)\n\t\trc = total_len;\n\n\tmmput(mm);\n\nput_task_struct:\n\tput_task_struct(task);\n\nfree_proc_pages:\n\tif (process_pages != pp_stack)\n\t\tkfree(process_pages);\n\treturn rc;\n}"
  },
  {
    "function_name": "process_vm_rw_single_vec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/process_vm_access.c",
    "lines": "78-136",
    "snippet": "static int process_vm_rw_single_vec(unsigned long addr,\n\t\t\t\t    unsigned long len,\n\t\t\t\t    struct iov_iter *iter,\n\t\t\t\t    struct page **process_pages,\n\t\t\t\t    struct mm_struct *mm,\n\t\t\t\t    struct task_struct *task,\n\t\t\t\t    int vm_write)\n{\n\tunsigned long pa = addr & PAGE_MASK;\n\tunsigned long start_offset = addr - pa;\n\tunsigned long nr_pages;\n\tssize_t rc = 0;\n\tunsigned long max_pages_per_loop = PVM_MAX_KMALLOC_PAGES\n\t\t/ sizeof(struct pages *);\n\tunsigned int flags = 0;\n\n\t/* Work out address and page range required */\n\tif (len == 0)\n\t\treturn 0;\n\tnr_pages = (addr + len - 1) / PAGE_SIZE - addr / PAGE_SIZE + 1;\n\n\tif (vm_write)\n\t\tflags |= FOLL_WRITE;\n\n\twhile (!rc && nr_pages && iov_iter_count(iter)) {\n\t\tint pages = min(nr_pages, max_pages_per_loop);\n\t\tint locked = 1;\n\t\tsize_t bytes;\n\n\t\t/*\n\t\t * Get the pages we're interested in.  We must\n\t\t * access remotely because task/mm might not\n\t\t * current/current->mm\n\t\t */\n\t\tdown_read(&mm->mmap_sem);\n\t\tpages = get_user_pages_remote(task, mm, pa, pages, flags,\n\t\t\t\t\t      process_pages, NULL, &locked);\n\t\tif (locked)\n\t\t\tup_read(&mm->mmap_sem);\n\t\tif (pages <= 0)\n\t\t\treturn -EFAULT;\n\n\t\tbytes = pages * PAGE_SIZE - start_offset;\n\t\tif (bytes > len)\n\t\t\tbytes = len;\n\n\t\trc = process_vm_rw_pages(process_pages,\n\t\t\t\t\t start_offset, bytes, iter,\n\t\t\t\t\t vm_write);\n\t\tlen -= bytes;\n\t\tstart_offset = 0;\n\t\tnr_pages -= pages;\n\t\tpa += pages * PAGE_SIZE;\n\t\twhile (pages)\n\t\t\tput_page(process_pages[--pages]);\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define PVM_MAX_KMALLOC_PAGES (PAGE_SIZE * 2)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "process_pages[--pages]"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_vm_rw_pages",
          "args": [
            "process_pages",
            "start_offset",
            "bytes",
            "iter",
            "vm_write"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "process_vm_rw_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/process_vm_access.c",
          "lines": "34-61",
          "snippet": "static int process_vm_rw_pages(struct page **pages,\n\t\t\t       unsigned offset,\n\t\t\t       size_t len,\n\t\t\t       struct iov_iter *iter,\n\t\t\t       int vm_write)\n{\n\t/* Do the copy for each page */\n\twhile (len && iov_iter_count(iter)) {\n\t\tstruct page *page = *pages++;\n\t\tsize_t copy = PAGE_SIZE - offset;\n\t\tsize_t copied;\n\n\t\tif (copy > len)\n\t\t\tcopy = len;\n\n\t\tif (vm_write) {\n\t\t\tcopied = copy_page_from_iter(page, offset, copy, iter);\n\t\t\tset_page_dirty_lock(page);\n\t\t} else {\n\t\t\tcopied = copy_page_to_iter(page, offset, copy, iter);\n\t\t}\n\t\tlen -= copied;\n\t\tif (copied < copy && iov_iter_count(iter))\n\t\t\treturn -EFAULT;\n\t\toffset = 0;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/mm.h>\n\nstatic int process_vm_rw_pages(struct page **pages,\n\t\t\t       unsigned offset,\n\t\t\t       size_t len,\n\t\t\t       struct iov_iter *iter,\n\t\t\t       int vm_write)\n{\n\t/* Do the copy for each page */\n\twhile (len && iov_iter_count(iter)) {\n\t\tstruct page *page = *pages++;\n\t\tsize_t copy = PAGE_SIZE - offset;\n\t\tsize_t copied;\n\n\t\tif (copy > len)\n\t\t\tcopy = len;\n\n\t\tif (vm_write) {\n\t\t\tcopied = copy_page_from_iter(page, offset, copy, iter);\n\t\t\tset_page_dirty_lock(page);\n\t\t} else {\n\t\t\tcopied = copy_page_to_iter(page, offset, copy, iter);\n\t\t}\n\t\tlen -= copied;\n\t\tif (copied < copy && iov_iter_count(iter))\n\t\t\treturn -EFAULT;\n\t\toffset = 0;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_pages_remote",
          "args": [
            "task",
            "mm",
            "pa",
            "pages",
            "flags",
            "process_pages",
            "NULL",
            "&locked"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_pages_remote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "1101-1109",
          "snippet": "long get_user_pages_remote(struct task_struct *tsk, struct mm_struct *mm,\n\t\tunsigned long start, unsigned long nr_pages,\n\t\tunsigned int gup_flags, struct page **pages,\n\t\tstruct vm_area_struct **vmas, int *locked)\n{\n\treturn __get_user_pages_locked(tsk, mm, start, nr_pages, pages, vmas,\n\t\t\t\t       locked,\n\t\t\t\t       gup_flags | FOLL_TOUCH | FOLL_REMOTE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nlong get_user_pages_remote(struct task_struct *tsk, struct mm_struct *mm,\n\t\tunsigned long start, unsigned long nr_pages,\n\t\tunsigned int gup_flags, struct page **pages,\n\t\tstruct vm_area_struct **vmas, int *locked)\n{\n\treturn __get_user_pages_locked(tsk, mm, start, nr_pages, pages, vmas,\n\t\t\t\t       locked,\n\t\t\t\t       gup_flags | FOLL_TOUCH | FOLL_REMOTE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "nr_pages",
            "max_pages_per_loop"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/mm.h>\n\n#define PVM_MAX_KMALLOC_PAGES (PAGE_SIZE * 2)\n\nstatic int process_vm_rw_single_vec(unsigned long addr,\n\t\t\t\t    unsigned long len,\n\t\t\t\t    struct iov_iter *iter,\n\t\t\t\t    struct page **process_pages,\n\t\t\t\t    struct mm_struct *mm,\n\t\t\t\t    struct task_struct *task,\n\t\t\t\t    int vm_write)\n{\n\tunsigned long pa = addr & PAGE_MASK;\n\tunsigned long start_offset = addr - pa;\n\tunsigned long nr_pages;\n\tssize_t rc = 0;\n\tunsigned long max_pages_per_loop = PVM_MAX_KMALLOC_PAGES\n\t\t/ sizeof(struct pages *);\n\tunsigned int flags = 0;\n\n\t/* Work out address and page range required */\n\tif (len == 0)\n\t\treturn 0;\n\tnr_pages = (addr + len - 1) / PAGE_SIZE - addr / PAGE_SIZE + 1;\n\n\tif (vm_write)\n\t\tflags |= FOLL_WRITE;\n\n\twhile (!rc && nr_pages && iov_iter_count(iter)) {\n\t\tint pages = min(nr_pages, max_pages_per_loop);\n\t\tint locked = 1;\n\t\tsize_t bytes;\n\n\t\t/*\n\t\t * Get the pages we're interested in.  We must\n\t\t * access remotely because task/mm might not\n\t\t * current/current->mm\n\t\t */\n\t\tdown_read(&mm->mmap_sem);\n\t\tpages = get_user_pages_remote(task, mm, pa, pages, flags,\n\t\t\t\t\t      process_pages, NULL, &locked);\n\t\tif (locked)\n\t\t\tup_read(&mm->mmap_sem);\n\t\tif (pages <= 0)\n\t\t\treturn -EFAULT;\n\n\t\tbytes = pages * PAGE_SIZE - start_offset;\n\t\tif (bytes > len)\n\t\t\tbytes = len;\n\n\t\trc = process_vm_rw_pages(process_pages,\n\t\t\t\t\t start_offset, bytes, iter,\n\t\t\t\t\t vm_write);\n\t\tlen -= bytes;\n\t\tstart_offset = 0;\n\t\tnr_pages -= pages;\n\t\tpa += pages * PAGE_SIZE;\n\t\twhile (pages)\n\t\t\tput_page(process_pages[--pages]);\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "process_vm_rw_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/process_vm_access.c",
    "lines": "34-61",
    "snippet": "static int process_vm_rw_pages(struct page **pages,\n\t\t\t       unsigned offset,\n\t\t\t       size_t len,\n\t\t\t       struct iov_iter *iter,\n\t\t\t       int vm_write)\n{\n\t/* Do the copy for each page */\n\twhile (len && iov_iter_count(iter)) {\n\t\tstruct page *page = *pages++;\n\t\tsize_t copy = PAGE_SIZE - offset;\n\t\tsize_t copied;\n\n\t\tif (copy > len)\n\t\t\tcopy = len;\n\n\t\tif (vm_write) {\n\t\t\tcopied = copy_page_from_iter(page, offset, copy, iter);\n\t\t\tset_page_dirty_lock(page);\n\t\t} else {\n\t\t\tcopied = copy_page_to_iter(page, offset, copy, iter);\n\t\t}\n\t\tlen -= copied;\n\t\tif (copied < copy && iov_iter_count(iter))\n\t\t\treturn -EFAULT;\n\t\toffset = 0;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_page_to_iter",
          "args": [
            "page",
            "offset",
            "copy",
            "iter"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_dirty_lock",
          "args": [
            "page"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_dirty_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2573-2581",
          "snippet": "int set_page_dirty_lock(struct page *page)\n{\n\tint ret;\n\n\tlock_page(page);\n\tret = set_page_dirty(page);\n\tunlock_page(page);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint set_page_dirty_lock(struct page *page)\n{\n\tint ret;\n\n\tlock_page(page);\n\tret = set_page_dirty(page);\n\tunlock_page(page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_page_from_iter",
          "args": [
            "page",
            "offset",
            "copy",
            "iter"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/mm.h>\n\nstatic int process_vm_rw_pages(struct page **pages,\n\t\t\t       unsigned offset,\n\t\t\t       size_t len,\n\t\t\t       struct iov_iter *iter,\n\t\t\t       int vm_write)\n{\n\t/* Do the copy for each page */\n\twhile (len && iov_iter_count(iter)) {\n\t\tstruct page *page = *pages++;\n\t\tsize_t copy = PAGE_SIZE - offset;\n\t\tsize_t copied;\n\n\t\tif (copy > len)\n\t\t\tcopy = len;\n\n\t\tif (vm_write) {\n\t\t\tcopied = copy_page_from_iter(page, offset, copy, iter);\n\t\t\tset_page_dirty_lock(page);\n\t\t} else {\n\t\t\tcopied = copy_page_to_iter(page, offset, copy, iter);\n\t\t}\n\t\tlen -= copied;\n\t\tif (copied < copy && iov_iter_count(iter))\n\t\t\treturn -EFAULT;\n\t\toffset = 0;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "process_vm_readv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/process_vm_access.c",
    "lines": "298-303",
    "snippet": "SYSCALL_DEFINE6(process_vm_readv, pid_t, pid, const struct iovec __user *, lvec,\n\t\tunsigned long, liovcnt, const struct iovec __user *, rvec,\n\t\tunsigned long, riovcnt,\tunsigned long, flags)\n{\n\treturn process_vm_rw(pid, lvec, liovcnt, rvec, riovcnt, flags, 0);\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE6(process_vm_readv, pid_t, pid, const struct iovec __user *, lvec,\n\t\tunsigned long, liovcnt, const struct iovec __user *, rvec,\n\t\tunsigned long, riovcnt,\tunsigned long, flags)\n{\n\treturn process_vm_rw(pid, lvec, liovcnt, rvec, riovcnt, flags, 0);\n}"
  },
  {
    "function_name": "process_vm_writev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/process_vm_access.c",
    "lines": "305-311",
    "snippet": "SYSCALL_DEFINE6(process_vm_writev, pid_t, pid,\n\t\tconst struct iovec __user *, lvec,\n\t\tunsigned long, liovcnt, const struct iovec __user *, rvec,\n\t\tunsigned long, riovcnt,\tunsigned long, flags)\n{\n\treturn process_vm_rw(pid, lvec, liovcnt, rvec, riovcnt, flags, 1);\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE6(process_vm_writev, pid_t, pid,\n\t\tconst struct iovec __user *, lvec,\n\t\tunsigned long, liovcnt, const struct iovec __user *, rvec,\n\t\tunsigned long, riovcnt,\tunsigned long, flags)\n{\n\treturn process_vm_rw(pid, lvec, liovcnt, rvec, riovcnt, flags, 1);\n}"
  },
  {
    "function_name": "process_vm_readv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/process_vm_access.c",
    "lines": "354-363",
    "snippet": "SYSCALL_DEFINE6(process_vm_readv, compat_pid_t, pid,\n\t\t       const struct compat_iovec __user *, lvec,\n\t\t       compat_ulong_t, liovcnt,\n\t\t       const struct compat_iovec __user *, rvec,\n\t\t       compat_ulong_t, riovcnt,\n\t\t       compat_ulong_t, flags)\n{\n\treturn compat_process_vm_rw(pid, lvec, liovcnt, rvec,\n\t\t\t\t    riovcnt, flags, 0);\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE6(process_vm_readv, compat_pid_t, pid,\n\t\t       const struct compat_iovec __user *, lvec,\n\t\t       compat_ulong_t, liovcnt,\n\t\t       const struct compat_iovec __user *, rvec,\n\t\t       compat_ulong_t, riovcnt,\n\t\t       compat_ulong_t, flags)\n{\n\treturn compat_process_vm_rw(pid, lvec, liovcnt, rvec,\n\t\t\t\t    riovcnt, flags, 0);\n}"
  },
  {
    "function_name": "process_vm_writev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/process_vm_access.c",
    "lines": "365-374",
    "snippet": "SYSCALL_DEFINE6(process_vm_writev, compat_pid_t, pid,\n\t\t       const struct compat_iovec __user *, lvec,\n\t\t       compat_ulong_t, liovcnt,\n\t\t       const struct compat_iovec __user *, rvec,\n\t\t       compat_ulong_t, riovcnt,\n\t\t       compat_ulong_t, flags)\n{\n\treturn compat_process_vm_rw(pid, lvec, liovcnt, rvec,\n\t\t\t\t    riovcnt, flags, 1);\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE6(process_vm_writev, compat_pid_t, pid,\n\t\t       const struct compat_iovec __user *, lvec,\n\t\t       compat_ulong_t, liovcnt,\n\t\t       const struct compat_iovec __user *, rvec,\n\t\t       compat_ulong_t, riovcnt,\n\t\t       compat_ulong_t, flags)\n{\n\treturn compat_process_vm_rw(pid, lvec, liovcnt, rvec,\n\t\t\t\t    riovcnt, flags, 1);\n}"
  }
]