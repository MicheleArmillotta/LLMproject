[
  {
    "function_name": "init_cleancache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cleancache.c",
    "lines": "304-316",
    "snippet": "static int __init init_cleancache(void)\n{\n#ifdef CONFIG_DEBUG_FS\n\tstruct dentry *root = debugfs_create_dir(\"cleancache\", NULL);\n\tif (root == NULL)\n\t\treturn -ENXIO;\n\tdebugfs_create_u64(\"succ_gets\", 0444, root, &cleancache_succ_gets);\n\tdebugfs_create_u64(\"failed_gets\", 0444, root, &cleancache_failed_gets);\n\tdebugfs_create_u64(\"puts\", 0444, root, &cleancache_puts);\n\tdebugfs_create_u64(\"invalidates\", 0444, root, &cleancache_invalidates);\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include <linux/cleancache.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/mm.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 cleancache_succ_gets;",
      "static u64 cleancache_failed_gets;",
      "static u64 cleancache_puts;",
      "static u64 cleancache_invalidates;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_create_u64",
          "args": [
            "\"invalidates\"",
            "0444",
            "root",
            "&cleancache_invalidates"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_u64",
          "args": [
            "\"puts\"",
            "0444",
            "root",
            "&cleancache_puts"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_u64",
          "args": [
            "\"failed_gets\"",
            "0444",
            "root",
            "&cleancache_failed_gets"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_u64",
          "args": [
            "\"succ_gets\"",
            "0444",
            "root",
            "&cleancache_succ_gets"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_dir",
          "args": [
            "\"cleancache\"",
            "NULL"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cleancache.h>\n#include <linux/debugfs.h>\n#include <linux/mm.h>\n#include <linux/exportfs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u64 cleancache_succ_gets;\nstatic u64 cleancache_failed_gets;\nstatic u64 cleancache_puts;\nstatic u64 cleancache_invalidates;\n\nstatic int __init init_cleancache(void)\n{\n#ifdef CONFIG_DEBUG_FS\n\tstruct dentry *root = debugfs_create_dir(\"cleancache\", NULL);\n\tif (root == NULL)\n\t\treturn -ENXIO;\n\tdebugfs_create_u64(\"succ_gets\", 0444, root, &cleancache_succ_gets);\n\tdebugfs_create_u64(\"failed_gets\", 0444, root, &cleancache_failed_gets);\n\tdebugfs_create_u64(\"puts\", 0444, root, &cleancache_puts);\n\tdebugfs_create_u64(\"invalidates\", 0444, root, &cleancache_invalidates);\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "__cleancache_invalidate_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cleancache.c",
    "lines": "292-301",
    "snippet": "void __cleancache_invalidate_fs(struct super_block *sb)\n{\n\tint pool_id;\n\n\tpool_id = sb->cleancache_poolid;\n\tsb->cleancache_poolid = CLEANCACHE_NO_POOL;\n\n\tif (cleancache_ops && pool_id >= 0)\n\t\tcleancache_ops->invalidate_fs(pool_id);\n}",
    "includes": [
      "#include <linux/cleancache.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/mm.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct cleancache_ops *cleancache_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleancache_ops->invalidate_fs",
          "args": [
            "pool_id"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cleancache.h>\n#include <linux/debugfs.h>\n#include <linux/mm.h>\n#include <linux/exportfs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic const struct cleancache_ops *cleancache_ops;\n\nvoid __cleancache_invalidate_fs(struct super_block *sb)\n{\n\tint pool_id;\n\n\tpool_id = sb->cleancache_poolid;\n\tsb->cleancache_poolid = CLEANCACHE_NO_POOL;\n\n\tif (cleancache_ops && pool_id >= 0)\n\t\tcleancache_ops->invalidate_fs(pool_id);\n}"
  },
  {
    "function_name": "__cleancache_invalidate_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cleancache.c",
    "lines": "274-284",
    "snippet": "void __cleancache_invalidate_inode(struct address_space *mapping)\n{\n\tint pool_id = mapping->host->i_sb->cleancache_poolid;\n\tstruct cleancache_filekey key = { .u.key = { 0 } };\n\n\tif (!cleancache_ops)\n\t\treturn;\n\n\tif (pool_id >= 0 && cleancache_get_key(mapping->host, &key) >= 0)\n\t\tcleancache_ops->invalidate_inode(pool_id, key);\n}",
    "includes": [
      "#include <linux/cleancache.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/mm.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct cleancache_ops *cleancache_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleancache_ops->invalidate_inode",
          "args": [
            "pool_id",
            "key"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cleancache_get_key",
          "args": [
            "mapping->host",
            "&key"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "cleancache_get_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cleancache.c",
          "lines": "145-164",
          "snippet": "static int cleancache_get_key(struct inode *inode,\n\t\t\t      struct cleancache_filekey *key)\n{\n\tint (*fhfn)(struct inode *, __u32 *fh, int *, struct inode *);\n\tint len = 0, maxlen = CLEANCACHE_KEY_MAX;\n\tstruct super_block *sb = inode->i_sb;\n\n\tkey->u.ino = inode->i_ino;\n\tif (sb->s_export_op != NULL) {\n\t\tfhfn = sb->s_export_op->encode_fh;\n\t\tif  (fhfn) {\n\t\t\tlen = (*fhfn)(inode, &key->u.fh[0], &maxlen, NULL);\n\t\t\tif (len <= FILEID_ROOT || len == FILEID_INVALID)\n\t\t\t\treturn -1;\n\t\t\tif (maxlen > CLEANCACHE_KEY_MAX)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/cleancache.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/mm.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cleancache.h>\n#include <linux/debugfs.h>\n#include <linux/mm.h>\n#include <linux/exportfs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int cleancache_get_key(struct inode *inode,\n\t\t\t      struct cleancache_filekey *key)\n{\n\tint (*fhfn)(struct inode *, __u32 *fh, int *, struct inode *);\n\tint len = 0, maxlen = CLEANCACHE_KEY_MAX;\n\tstruct super_block *sb = inode->i_sb;\n\n\tkey->u.ino = inode->i_ino;\n\tif (sb->s_export_op != NULL) {\n\t\tfhfn = sb->s_export_op->encode_fh;\n\t\tif  (fhfn) {\n\t\t\tlen = (*fhfn)(inode, &key->u.fh[0], &maxlen, NULL);\n\t\t\tif (len <= FILEID_ROOT || len == FILEID_INVALID)\n\t\t\t\treturn -1;\n\t\t\tif (maxlen > CLEANCACHE_KEY_MAX)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cleancache.h>\n#include <linux/debugfs.h>\n#include <linux/mm.h>\n#include <linux/exportfs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic const struct cleancache_ops *cleancache_ops;\n\nvoid __cleancache_invalidate_inode(struct address_space *mapping)\n{\n\tint pool_id = mapping->host->i_sb->cleancache_poolid;\n\tstruct cleancache_filekey key = { .u.key = { 0 } };\n\n\tif (!cleancache_ops)\n\t\treturn;\n\n\tif (pool_id >= 0 && cleancache_get_key(mapping->host, &key) >= 0)\n\t\tcleancache_ops->invalidate_inode(pool_id, key);\n}"
  },
  {
    "function_name": "__cleancache_invalidate_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cleancache.c",
    "lines": "244-262",
    "snippet": "void __cleancache_invalidate_page(struct address_space *mapping,\n\t\t\t\t\tstruct page *page)\n{\n\t/* careful... page->mapping is NULL sometimes when this is called */\n\tint pool_id = mapping->host->i_sb->cleancache_poolid;\n\tstruct cleancache_filekey key = { .u.key = { 0 } };\n\n\tif (!cleancache_ops)\n\t\treturn;\n\n\tif (pool_id >= 0) {\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\t\tif (cleancache_get_key(mapping->host, &key) >= 0) {\n\t\t\tcleancache_ops->invalidate_page(pool_id,\n\t\t\t\t\tkey, page->index);\n\t\t\tcleancache_invalidates++;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/cleancache.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/mm.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct cleancache_ops *cleancache_ops",
      "static u64 cleancache_invalidates;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleancache_ops->invalidate_page",
          "args": [
            "pool_id",
            "key",
            "page->index"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cleancache_get_key",
          "args": [
            "mapping->host",
            "&key"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "cleancache_get_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cleancache.c",
          "lines": "145-164",
          "snippet": "static int cleancache_get_key(struct inode *inode,\n\t\t\t      struct cleancache_filekey *key)\n{\n\tint (*fhfn)(struct inode *, __u32 *fh, int *, struct inode *);\n\tint len = 0, maxlen = CLEANCACHE_KEY_MAX;\n\tstruct super_block *sb = inode->i_sb;\n\n\tkey->u.ino = inode->i_ino;\n\tif (sb->s_export_op != NULL) {\n\t\tfhfn = sb->s_export_op->encode_fh;\n\t\tif  (fhfn) {\n\t\t\tlen = (*fhfn)(inode, &key->u.fh[0], &maxlen, NULL);\n\t\t\tif (len <= FILEID_ROOT || len == FILEID_INVALID)\n\t\t\t\treturn -1;\n\t\t\tif (maxlen > CLEANCACHE_KEY_MAX)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/cleancache.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/mm.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cleancache.h>\n#include <linux/debugfs.h>\n#include <linux/mm.h>\n#include <linux/exportfs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int cleancache_get_key(struct inode *inode,\n\t\t\t      struct cleancache_filekey *key)\n{\n\tint (*fhfn)(struct inode *, __u32 *fh, int *, struct inode *);\n\tint len = 0, maxlen = CLEANCACHE_KEY_MAX;\n\tstruct super_block *sb = inode->i_sb;\n\n\tkey->u.ino = inode->i_ino;\n\tif (sb->s_export_op != NULL) {\n\t\tfhfn = sb->s_export_op->encode_fh;\n\t\tif  (fhfn) {\n\t\t\tlen = (*fhfn)(inode, &key->u.fh[0], &maxlen, NULL);\n\t\t\tif (len <= FILEID_ROOT || len == FILEID_INVALID)\n\t\t\t\treturn -1;\n\t\t\tif (maxlen > CLEANCACHE_KEY_MAX)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLocked(page)",
            "page"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cleancache.h>\n#include <linux/debugfs.h>\n#include <linux/mm.h>\n#include <linux/exportfs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic const struct cleancache_ops *cleancache_ops;\nstatic u64 cleancache_invalidates;\n\nvoid __cleancache_invalidate_page(struct address_space *mapping,\n\t\t\t\t\tstruct page *page)\n{\n\t/* careful... page->mapping is NULL sometimes when this is called */\n\tint pool_id = mapping->host->i_sb->cleancache_poolid;\n\tstruct cleancache_filekey key = { .u.key = { 0 } };\n\n\tif (!cleancache_ops)\n\t\treturn;\n\n\tif (pool_id >= 0) {\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\t\tif (cleancache_get_key(mapping->host, &key) >= 0) {\n\t\t\tcleancache_ops->invalidate_page(pool_id,\n\t\t\t\t\tkey, page->index);\n\t\t\tcleancache_invalidates++;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "__cleancache_put_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cleancache.c",
    "lines": "216-233",
    "snippet": "void __cleancache_put_page(struct page *page)\n{\n\tint pool_id;\n\tstruct cleancache_filekey key = { .u.key = { 0 } };\n\n\tif (!cleancache_ops) {\n\t\tcleancache_puts++;\n\t\treturn;\n\t}\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tpool_id = page->mapping->host->i_sb->cleancache_poolid;\n\tif (pool_id >= 0 &&\n\t\tcleancache_get_key(page->mapping->host, &key) >= 0) {\n\t\tcleancache_ops->put_page(pool_id, key, page->index, page);\n\t\tcleancache_puts++;\n\t}\n}",
    "includes": [
      "#include <linux/cleancache.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/mm.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct cleancache_ops *cleancache_ops",
      "static u64 cleancache_puts;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleancache_ops->put_page",
          "args": [
            "pool_id",
            "key",
            "page->index",
            "page"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cleancache_get_key",
          "args": [
            "page->mapping->host",
            "&key"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "cleancache_get_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cleancache.c",
          "lines": "145-164",
          "snippet": "static int cleancache_get_key(struct inode *inode,\n\t\t\t      struct cleancache_filekey *key)\n{\n\tint (*fhfn)(struct inode *, __u32 *fh, int *, struct inode *);\n\tint len = 0, maxlen = CLEANCACHE_KEY_MAX;\n\tstruct super_block *sb = inode->i_sb;\n\n\tkey->u.ino = inode->i_ino;\n\tif (sb->s_export_op != NULL) {\n\t\tfhfn = sb->s_export_op->encode_fh;\n\t\tif  (fhfn) {\n\t\t\tlen = (*fhfn)(inode, &key->u.fh[0], &maxlen, NULL);\n\t\t\tif (len <= FILEID_ROOT || len == FILEID_INVALID)\n\t\t\t\treturn -1;\n\t\t\tif (maxlen > CLEANCACHE_KEY_MAX)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/cleancache.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/mm.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cleancache.h>\n#include <linux/debugfs.h>\n#include <linux/mm.h>\n#include <linux/exportfs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int cleancache_get_key(struct inode *inode,\n\t\t\t      struct cleancache_filekey *key)\n{\n\tint (*fhfn)(struct inode *, __u32 *fh, int *, struct inode *);\n\tint len = 0, maxlen = CLEANCACHE_KEY_MAX;\n\tstruct super_block *sb = inode->i_sb;\n\n\tkey->u.ino = inode->i_ino;\n\tif (sb->s_export_op != NULL) {\n\t\tfhfn = sb->s_export_op->encode_fh;\n\t\tif  (fhfn) {\n\t\t\tlen = (*fhfn)(inode, &key->u.fh[0], &maxlen, NULL);\n\t\t\tif (len <= FILEID_ROOT || len == FILEID_INVALID)\n\t\t\t\treturn -1;\n\t\t\tif (maxlen > CLEANCACHE_KEY_MAX)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLocked(page)",
            "page"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cleancache.h>\n#include <linux/debugfs.h>\n#include <linux/mm.h>\n#include <linux/exportfs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic const struct cleancache_ops *cleancache_ops;\nstatic u64 cleancache_puts;\n\nvoid __cleancache_put_page(struct page *page)\n{\n\tint pool_id;\n\tstruct cleancache_filekey key = { .u.key = { 0 } };\n\n\tif (!cleancache_ops) {\n\t\tcleancache_puts++;\n\t\treturn;\n\t}\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tpool_id = page->mapping->host->i_sb->cleancache_poolid;\n\tif (pool_id >= 0 &&\n\t\tcleancache_get_key(page->mapping->host, &key) >= 0) {\n\t\tcleancache_ops->put_page(pool_id, key, page->index, page);\n\t\tcleancache_puts++;\n\t}\n}"
  },
  {
    "function_name": "__cleancache_get_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cleancache.c",
    "lines": "177-203",
    "snippet": "int __cleancache_get_page(struct page *page)\n{\n\tint ret = -1;\n\tint pool_id;\n\tstruct cleancache_filekey key = { .u.key = { 0 } };\n\n\tif (!cleancache_ops) {\n\t\tcleancache_failed_gets++;\n\t\tgoto out;\n\t}\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tpool_id = page->mapping->host->i_sb->cleancache_poolid;\n\tif (pool_id < 0)\n\t\tgoto out;\n\n\tif (cleancache_get_key(page->mapping->host, &key) < 0)\n\t\tgoto out;\n\n\tret = cleancache_ops->get_page(pool_id, key, page->index, page);\n\tif (ret == 0)\n\t\tcleancache_succ_gets++;\n\telse\n\t\tcleancache_failed_gets++;\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/cleancache.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/mm.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct cleancache_ops *cleancache_ops",
      "static u64 cleancache_succ_gets;",
      "static u64 cleancache_failed_gets;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleancache_ops->get_page",
          "args": [
            "pool_id",
            "key",
            "page->index",
            "page"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cleancache_get_key",
          "args": [
            "page->mapping->host",
            "&key"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "cleancache_get_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cleancache.c",
          "lines": "145-164",
          "snippet": "static int cleancache_get_key(struct inode *inode,\n\t\t\t      struct cleancache_filekey *key)\n{\n\tint (*fhfn)(struct inode *, __u32 *fh, int *, struct inode *);\n\tint len = 0, maxlen = CLEANCACHE_KEY_MAX;\n\tstruct super_block *sb = inode->i_sb;\n\n\tkey->u.ino = inode->i_ino;\n\tif (sb->s_export_op != NULL) {\n\t\tfhfn = sb->s_export_op->encode_fh;\n\t\tif  (fhfn) {\n\t\t\tlen = (*fhfn)(inode, &key->u.fh[0], &maxlen, NULL);\n\t\t\tif (len <= FILEID_ROOT || len == FILEID_INVALID)\n\t\t\t\treturn -1;\n\t\t\tif (maxlen > CLEANCACHE_KEY_MAX)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/cleancache.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/mm.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cleancache.h>\n#include <linux/debugfs.h>\n#include <linux/mm.h>\n#include <linux/exportfs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int cleancache_get_key(struct inode *inode,\n\t\t\t      struct cleancache_filekey *key)\n{\n\tint (*fhfn)(struct inode *, __u32 *fh, int *, struct inode *);\n\tint len = 0, maxlen = CLEANCACHE_KEY_MAX;\n\tstruct super_block *sb = inode->i_sb;\n\n\tkey->u.ino = inode->i_ino;\n\tif (sb->s_export_op != NULL) {\n\t\tfhfn = sb->s_export_op->encode_fh;\n\t\tif  (fhfn) {\n\t\t\tlen = (*fhfn)(inode, &key->u.fh[0], &maxlen, NULL);\n\t\t\tif (len <= FILEID_ROOT || len == FILEID_INVALID)\n\t\t\t\treturn -1;\n\t\t\tif (maxlen > CLEANCACHE_KEY_MAX)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLocked(page)",
            "page"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cleancache.h>\n#include <linux/debugfs.h>\n#include <linux/mm.h>\n#include <linux/exportfs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic const struct cleancache_ops *cleancache_ops;\nstatic u64 cleancache_succ_gets;\nstatic u64 cleancache_failed_gets;\n\nint __cleancache_get_page(struct page *page)\n{\n\tint ret = -1;\n\tint pool_id;\n\tstruct cleancache_filekey key = { .u.key = { 0 } };\n\n\tif (!cleancache_ops) {\n\t\tcleancache_failed_gets++;\n\t\tgoto out;\n\t}\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tpool_id = page->mapping->host->i_sb->cleancache_poolid;\n\tif (pool_id < 0)\n\t\tgoto out;\n\n\tif (cleancache_get_key(page->mapping->host, &key) < 0)\n\t\tgoto out;\n\n\tret = cleancache_ops->get_page(pool_id, key, page->index, page);\n\tif (ret == 0)\n\t\tcleancache_succ_gets++;\n\telse\n\t\tcleancache_failed_gets++;\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "cleancache_get_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cleancache.c",
    "lines": "145-164",
    "snippet": "static int cleancache_get_key(struct inode *inode,\n\t\t\t      struct cleancache_filekey *key)\n{\n\tint (*fhfn)(struct inode *, __u32 *fh, int *, struct inode *);\n\tint len = 0, maxlen = CLEANCACHE_KEY_MAX;\n\tstruct super_block *sb = inode->i_sb;\n\n\tkey->u.ino = inode->i_ino;\n\tif (sb->s_export_op != NULL) {\n\t\tfhfn = sb->s_export_op->encode_fh;\n\t\tif  (fhfn) {\n\t\t\tlen = (*fhfn)(inode, &key->u.fh[0], &maxlen, NULL);\n\t\t\tif (len <= FILEID_ROOT || len == FILEID_INVALID)\n\t\t\t\treturn -1;\n\t\t\tif (maxlen > CLEANCACHE_KEY_MAX)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/cleancache.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/mm.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "inode",
            "&key->u.fh[0]",
            "&maxlen",
            "NULL"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cleancache.h>\n#include <linux/debugfs.h>\n#include <linux/mm.h>\n#include <linux/exportfs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int cleancache_get_key(struct inode *inode,\n\t\t\t      struct cleancache_filekey *key)\n{\n\tint (*fhfn)(struct inode *, __u32 *fh, int *, struct inode *);\n\tint len = 0, maxlen = CLEANCACHE_KEY_MAX;\n\tstruct super_block *sb = inode->i_sb;\n\n\tkey->u.ino = inode->i_ino;\n\tif (sb->s_export_op != NULL) {\n\t\tfhfn = sb->s_export_op->encode_fh;\n\t\tif  (fhfn) {\n\t\t\tlen = (*fhfn)(inode, &key->u.fh[0], &maxlen, NULL);\n\t\t\tif (len <= FILEID_ROOT || len == FILEID_INVALID)\n\t\t\t\treturn -1;\n\t\t\tif (maxlen > CLEANCACHE_KEY_MAX)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "__cleancache_init_shared_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cleancache.c",
    "lines": "128-138",
    "snippet": "void __cleancache_init_shared_fs(struct super_block *sb)\n{\n\tint pool_id = CLEANCACHE_NO_BACKEND_SHARED;\n\n\tif (cleancache_ops) {\n\t\tpool_id = cleancache_ops->init_shared_fs(&sb->s_uuid, PAGE_SIZE);\n\t\tif (pool_id < 0)\n\t\t\tpool_id = CLEANCACHE_NO_POOL;\n\t}\n\tsb->cleancache_poolid = pool_id;\n}",
    "includes": [
      "#include <linux/cleancache.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/mm.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct cleancache_ops *cleancache_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleancache_ops->init_shared_fs",
          "args": [
            "&sb->s_uuid",
            "PAGE_SIZE"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cleancache.h>\n#include <linux/debugfs.h>\n#include <linux/mm.h>\n#include <linux/exportfs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic const struct cleancache_ops *cleancache_ops;\n\nvoid __cleancache_init_shared_fs(struct super_block *sb)\n{\n\tint pool_id = CLEANCACHE_NO_BACKEND_SHARED;\n\n\tif (cleancache_ops) {\n\t\tpool_id = cleancache_ops->init_shared_fs(&sb->s_uuid, PAGE_SIZE);\n\t\tif (pool_id < 0)\n\t\t\tpool_id = CLEANCACHE_NO_POOL;\n\t}\n\tsb->cleancache_poolid = pool_id;\n}"
  },
  {
    "function_name": "__cleancache_init_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cleancache.c",
    "lines": "114-124",
    "snippet": "void __cleancache_init_fs(struct super_block *sb)\n{\n\tint pool_id = CLEANCACHE_NO_BACKEND;\n\n\tif (cleancache_ops) {\n\t\tpool_id = cleancache_ops->init_fs(PAGE_SIZE);\n\t\tif (pool_id < 0)\n\t\t\tpool_id = CLEANCACHE_NO_POOL;\n\t}\n\tsb->cleancache_poolid = pool_id;\n}",
    "includes": [
      "#include <linux/cleancache.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/mm.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct cleancache_ops *cleancache_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleancache_ops->init_fs",
          "args": [
            "PAGE_SIZE"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cleancache.h>\n#include <linux/debugfs.h>\n#include <linux/mm.h>\n#include <linux/exportfs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic const struct cleancache_ops *cleancache_ops;\n\nvoid __cleancache_init_fs(struct super_block *sb)\n{\n\tint pool_id = CLEANCACHE_NO_BACKEND;\n\n\tif (cleancache_ops) {\n\t\tpool_id = cleancache_ops->init_fs(PAGE_SIZE);\n\t\tif (pool_id < 0)\n\t\t\tpool_id = CLEANCACHE_NO_POOL;\n\t}\n\tsb->cleancache_poolid = pool_id;\n}"
  },
  {
    "function_name": "cleancache_register_ops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cleancache.c",
    "lines": "52-110",
    "snippet": "int cleancache_register_ops(const struct cleancache_ops *ops)\n{\n\tif (cmpxchg(&cleancache_ops, NULL, ops))\n\t\treturn -EBUSY;\n\n\t/*\n\t * A cleancache backend can be built as a module and hence loaded after\n\t * a cleancache enabled filesystem has called cleancache_init_fs. To\n\t * handle such a scenario, here we call ->init_fs or ->init_shared_fs\n\t * for each active super block. To differentiate between local and\n\t * shared filesystems, we temporarily initialize sb->cleancache_poolid\n\t * to CLEANCACHE_NO_BACKEND or CLEANCACHE_NO_BACKEND_SHARED\n\t * respectively in case there is no backend registered at the time\n\t * cleancache_init_fs or cleancache_init_shared_fs is called.\n\t *\n\t * Since filesystems can be mounted concurrently with cleancache\n\t * backend registration, we have to be careful to guarantee that all\n\t * cleancache enabled filesystems that has been mounted by the time\n\t * cleancache_register_ops is called has got and all mounted later will\n\t * get cleancache_poolid. This is assured by the following statements\n\t * tied together:\n\t *\n\t * a) iterate_supers skips only those super blocks that has started\n\t *    ->kill_sb\n\t *\n\t * b) if iterate_supers encounters a super block that has not finished\n\t *    ->mount yet, it waits until it is finished\n\t *\n\t * c) cleancache_init_fs is called from ->mount and\n\t *    cleancache_invalidate_fs is called from ->kill_sb\n\t *\n\t * d) we call iterate_supers after cleancache_ops has been set\n\t *\n\t * From a) it follows that if iterate_supers skips a super block, then\n\t * either the super block is already dead, in which case we do not need\n\t * to bother initializing cleancache for it, or it was mounted after we\n\t * initiated iterate_supers. In the latter case, it must have seen\n\t * cleancache_ops set according to d) and initialized cleancache from\n\t * ->mount by itself according to c). This proves that we call\n\t * ->init_fs at least once for each active super block.\n\t *\n\t * From b) and c) it follows that if iterate_supers encounters a super\n\t * block that has already started ->init_fs, it will wait until ->mount\n\t * and hence ->init_fs has finished, then check cleancache_poolid, see\n\t * that it has already been set and therefore do nothing. This proves\n\t * that we call ->init_fs no more than once for each super block.\n\t *\n\t * Combined together, the last two paragraphs prove the function\n\t * correctness.\n\t *\n\t * Note that various cleancache callbacks may proceed before this\n\t * function is called or even concurrently with it, but since\n\t * CLEANCACHE_NO_BACKEND is negative, they will all result in a noop\n\t * until the corresponding ->init_fs has been actually called and\n\t * cleancache_ops has been set.\n\t */\n\titerate_supers(cleancache_register_ops_sb, NULL);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/cleancache.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/mm.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct cleancache_ops *cleancache_ops"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iterate_supers",
          "args": [
            "cleancache_register_ops_sb",
            "NULL"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&cleancache_ops",
            "NULL",
            "ops"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "note_cmpxchg_failure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1992-2014",
          "snippet": "static inline void note_cmpxchg_failure(const char *n,\n\t\tconst struct kmem_cache *s, unsigned long tid)\n{\n#ifdef SLUB_DEBUG_CMPXCHG\n\tunsigned long actual_tid = __this_cpu_read(s->cpu_slab->tid);\n\n\tpr_info(\"%s %s: cmpxchg redo \", n, s->name);\n\n#ifdef CONFIG_PREEMPT\n\tif (tid_to_cpu(tid) != tid_to_cpu(actual_tid))\n\t\tpr_warn(\"due to cpu change %d -> %d\\n\",\n\t\t\ttid_to_cpu(tid), tid_to_cpu(actual_tid));\n\telse\n#endif\n\tif (tid_to_event(tid) != tid_to_event(actual_tid))\n\t\tpr_warn(\"due to cpu running other code. Event %ld->%ld\\n\",\n\t\t\ttid_to_event(tid), tid_to_event(actual_tid));\n\telse\n\t\tpr_warn(\"for unknown reason: actual=%lx was=%lx target=%lx\\n\",\n\t\t\tactual_tid, tid, next_tid(tid));\n#endif\n\tstat(s, CMPXCHG_DOUBLE_CPU_FAIL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void note_cmpxchg_failure(const char *n,\n\t\tconst struct kmem_cache *s, unsigned long tid)\n{\n#ifdef SLUB_DEBUG_CMPXCHG\n\tunsigned long actual_tid = __this_cpu_read(s->cpu_slab->tid);\n\n\tpr_info(\"%s %s: cmpxchg redo \", n, s->name);\n\n#ifdef CONFIG_PREEMPT\n\tif (tid_to_cpu(tid) != tid_to_cpu(actual_tid))\n\t\tpr_warn(\"due to cpu change %d -> %d\\n\",\n\t\t\ttid_to_cpu(tid), tid_to_cpu(actual_tid));\n\telse\n#endif\n\tif (tid_to_event(tid) != tid_to_event(actual_tid))\n\t\tpr_warn(\"due to cpu running other code. Event %ld->%ld\\n\",\n\t\t\ttid_to_event(tid), tid_to_event(actual_tid));\n\telse\n\t\tpr_warn(\"for unknown reason: actual=%lx was=%lx target=%lx\\n\",\n\t\t\tactual_tid, tid, next_tid(tid));\n#endif\n\tstat(s, CMPXCHG_DOUBLE_CPU_FAIL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cleancache.h>\n#include <linux/debugfs.h>\n#include <linux/mm.h>\n#include <linux/exportfs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic const struct cleancache_ops *cleancache_ops;\n\nint cleancache_register_ops(const struct cleancache_ops *ops)\n{\n\tif (cmpxchg(&cleancache_ops, NULL, ops))\n\t\treturn -EBUSY;\n\n\t/*\n\t * A cleancache backend can be built as a module and hence loaded after\n\t * a cleancache enabled filesystem has called cleancache_init_fs. To\n\t * handle such a scenario, here we call ->init_fs or ->init_shared_fs\n\t * for each active super block. To differentiate between local and\n\t * shared filesystems, we temporarily initialize sb->cleancache_poolid\n\t * to CLEANCACHE_NO_BACKEND or CLEANCACHE_NO_BACKEND_SHARED\n\t * respectively in case there is no backend registered at the time\n\t * cleancache_init_fs or cleancache_init_shared_fs is called.\n\t *\n\t * Since filesystems can be mounted concurrently with cleancache\n\t * backend registration, we have to be careful to guarantee that all\n\t * cleancache enabled filesystems that has been mounted by the time\n\t * cleancache_register_ops is called has got and all mounted later will\n\t * get cleancache_poolid. This is assured by the following statements\n\t * tied together:\n\t *\n\t * a) iterate_supers skips only those super blocks that has started\n\t *    ->kill_sb\n\t *\n\t * b) if iterate_supers encounters a super block that has not finished\n\t *    ->mount yet, it waits until it is finished\n\t *\n\t * c) cleancache_init_fs is called from ->mount and\n\t *    cleancache_invalidate_fs is called from ->kill_sb\n\t *\n\t * d) we call iterate_supers after cleancache_ops has been set\n\t *\n\t * From a) it follows that if iterate_supers skips a super block, then\n\t * either the super block is already dead, in which case we do not need\n\t * to bother initializing cleancache for it, or it was mounted after we\n\t * initiated iterate_supers. In the latter case, it must have seen\n\t * cleancache_ops set according to d) and initialized cleancache from\n\t * ->mount by itself according to c). This proves that we call\n\t * ->init_fs at least once for each active super block.\n\t *\n\t * From b) and c) it follows that if iterate_supers encounters a super\n\t * block that has already started ->init_fs, it will wait until ->mount\n\t * and hence ->init_fs has finished, then check cleancache_poolid, see\n\t * that it has already been set and therefore do nothing. This proves\n\t * that we call ->init_fs no more than once for each super block.\n\t *\n\t * Combined together, the last two paragraphs prove the function\n\t * correctness.\n\t *\n\t * Note that various cleancache callbacks may proceed before this\n\t * function is called or even concurrently with it, but since\n\t * CLEANCACHE_NO_BACKEND is negative, they will all result in a noop\n\t * until the corresponding ->init_fs has been actually called and\n\t * cleancache_ops has been set.\n\t */\n\titerate_supers(cleancache_register_ops_sb, NULL);\n\treturn 0;\n}"
  },
  {
    "function_name": "cleancache_register_ops_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cleancache.c",
    "lines": "37-47",
    "snippet": "static void cleancache_register_ops_sb(struct super_block *sb, void *unused)\n{\n\tswitch (sb->cleancache_poolid) {\n\tcase CLEANCACHE_NO_BACKEND:\n\t\t__cleancache_init_fs(sb);\n\t\tbreak;\n\tcase CLEANCACHE_NO_BACKEND_SHARED:\n\t\t__cleancache_init_shared_fs(sb);\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include <linux/cleancache.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/mm.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cleancache_init_shared_fs",
          "args": [
            "sb"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "__cleancache_init_shared_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cleancache.c",
          "lines": "128-138",
          "snippet": "void __cleancache_init_shared_fs(struct super_block *sb)\n{\n\tint pool_id = CLEANCACHE_NO_BACKEND_SHARED;\n\n\tif (cleancache_ops) {\n\t\tpool_id = cleancache_ops->init_shared_fs(&sb->s_uuid, PAGE_SIZE);\n\t\tif (pool_id < 0)\n\t\t\tpool_id = CLEANCACHE_NO_POOL;\n\t}\n\tsb->cleancache_poolid = pool_id;\n}",
          "includes": [
            "#include <linux/cleancache.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/mm.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct cleancache_ops *cleancache_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cleancache.h>\n#include <linux/debugfs.h>\n#include <linux/mm.h>\n#include <linux/exportfs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic const struct cleancache_ops *cleancache_ops;\n\nvoid __cleancache_init_shared_fs(struct super_block *sb)\n{\n\tint pool_id = CLEANCACHE_NO_BACKEND_SHARED;\n\n\tif (cleancache_ops) {\n\t\tpool_id = cleancache_ops->init_shared_fs(&sb->s_uuid, PAGE_SIZE);\n\t\tif (pool_id < 0)\n\t\t\tpool_id = CLEANCACHE_NO_POOL;\n\t}\n\tsb->cleancache_poolid = pool_id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cleancache_init_fs",
          "args": [
            "sb"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "__cleancache_init_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cleancache.c",
          "lines": "114-124",
          "snippet": "void __cleancache_init_fs(struct super_block *sb)\n{\n\tint pool_id = CLEANCACHE_NO_BACKEND;\n\n\tif (cleancache_ops) {\n\t\tpool_id = cleancache_ops->init_fs(PAGE_SIZE);\n\t\tif (pool_id < 0)\n\t\t\tpool_id = CLEANCACHE_NO_POOL;\n\t}\n\tsb->cleancache_poolid = pool_id;\n}",
          "includes": [
            "#include <linux/cleancache.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/mm.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct cleancache_ops *cleancache_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cleancache.h>\n#include <linux/debugfs.h>\n#include <linux/mm.h>\n#include <linux/exportfs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic const struct cleancache_ops *cleancache_ops;\n\nvoid __cleancache_init_fs(struct super_block *sb)\n{\n\tint pool_id = CLEANCACHE_NO_BACKEND;\n\n\tif (cleancache_ops) {\n\t\tpool_id = cleancache_ops->init_fs(PAGE_SIZE);\n\t\tif (pool_id < 0)\n\t\t\tpool_id = CLEANCACHE_NO_POOL;\n\t}\n\tsb->cleancache_poolid = pool_id;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cleancache.h>\n#include <linux/debugfs.h>\n#include <linux/mm.h>\n#include <linux/exportfs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void cleancache_register_ops_sb(struct super_block *sb, void *unused)\n{\n\tswitch (sb->cleancache_poolid) {\n\tcase CLEANCACHE_NO_BACKEND:\n\t\t__cleancache_init_fs(sb);\n\t\tbreak;\n\tcase CLEANCACHE_NO_BACKEND_SHARED:\n\t\t__cleancache_init_shared_fs(sb);\n\t\tbreak;\n\t}\n}"
  }
]