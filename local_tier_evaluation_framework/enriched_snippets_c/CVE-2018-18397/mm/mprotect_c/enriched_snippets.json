[
  {
    "function_name": "do_mprotect_pkey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mprotect.c",
    "lines": "456-575",
    "snippet": "static int do_mprotect_pkey(unsigned long start, size_t len,\n\t\tunsigned long prot, int pkey)\n{\n\tunsigned long nstart, end, tmp, reqprot;\n\tstruct vm_area_struct *vma, *prev;\n\tint error = -EINVAL;\n\tconst int grows = prot & (PROT_GROWSDOWN|PROT_GROWSUP);\n\tconst bool rier = (current->personality & READ_IMPLIES_EXEC) &&\n\t\t\t\t(prot & PROT_READ);\n\n\tprot &= ~(PROT_GROWSDOWN|PROT_GROWSUP);\n\tif (grows == (PROT_GROWSDOWN|PROT_GROWSUP)) /* can't be both */\n\t\treturn -EINVAL;\n\n\tif (start & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\tif (!len)\n\t\treturn 0;\n\tlen = PAGE_ALIGN(len);\n\tend = start + len;\n\tif (end <= start)\n\t\treturn -ENOMEM;\n\tif (!arch_validate_prot(prot, start))\n\t\treturn -EINVAL;\n\n\treqprot = prot;\n\n\tif (down_write_killable(&current->mm->mmap_sem))\n\t\treturn -EINTR;\n\n\t/*\n\t * If userspace did not allocate the pkey, do not let\n\t * them use it here.\n\t */\n\terror = -EINVAL;\n\tif ((pkey != -1) && !mm_pkey_is_allocated(current->mm, pkey))\n\t\tgoto out;\n\n\tvma = find_vma(current->mm, start);\n\terror = -ENOMEM;\n\tif (!vma)\n\t\tgoto out;\n\tprev = vma->vm_prev;\n\tif (unlikely(grows & PROT_GROWSDOWN)) {\n\t\tif (vma->vm_start >= end)\n\t\t\tgoto out;\n\t\tstart = vma->vm_start;\n\t\terror = -EINVAL;\n\t\tif (!(vma->vm_flags & VM_GROWSDOWN))\n\t\t\tgoto out;\n\t} else {\n\t\tif (vma->vm_start > start)\n\t\t\tgoto out;\n\t\tif (unlikely(grows & PROT_GROWSUP)) {\n\t\t\tend = vma->vm_end;\n\t\t\terror = -EINVAL;\n\t\t\tif (!(vma->vm_flags & VM_GROWSUP))\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\tif (start > vma->vm_start)\n\t\tprev = vma;\n\n\tfor (nstart = start ; ; ) {\n\t\tunsigned long mask_off_old_flags;\n\t\tunsigned long newflags;\n\t\tint new_vma_pkey;\n\n\t\t/* Here we know that vma->vm_start <= nstart < vma->vm_end. */\n\n\t\t/* Does the application expect PROT_READ to imply PROT_EXEC */\n\t\tif (rier && (vma->vm_flags & VM_MAYEXEC))\n\t\t\tprot |= PROT_EXEC;\n\n\t\t/*\n\t\t * Each mprotect() call explicitly passes r/w/x permissions.\n\t\t * If a permission is not passed to mprotect(), it must be\n\t\t * cleared from the VMA.\n\t\t */\n\t\tmask_off_old_flags = VM_READ | VM_WRITE | VM_EXEC |\n\t\t\t\t\tVM_FLAGS_CLEAR;\n\n\t\tnew_vma_pkey = arch_override_mprotect_pkey(vma, prot, pkey);\n\t\tnewflags = calc_vm_prot_bits(prot, new_vma_pkey);\n\t\tnewflags |= (vma->vm_flags & ~mask_off_old_flags);\n\n\t\t/* newflags >> 4 shift VM_MAY% in place of VM_% */\n\t\tif ((newflags & ~(newflags >> 4)) & (VM_READ | VM_WRITE | VM_EXEC)) {\n\t\t\terror = -EACCES;\n\t\t\tgoto out;\n\t\t}\n\n\t\terror = security_file_mprotect(vma, reqprot, prot);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\ttmp = vma->vm_end;\n\t\tif (tmp > end)\n\t\t\ttmp = end;\n\t\terror = mprotect_fixup(vma, &prev, nstart, tmp, newflags);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tnstart = tmp;\n\n\t\tif (nstart < prev->vm_end)\n\t\t\tnstart = prev->vm_end;\n\t\tif (nstart >= end)\n\t\t\tgoto out;\n\n\t\tvma = prev->vm_next;\n\t\tif (!vma || vma->vm_start != nstart) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tprot = reqprot;\n\t}\nout:\n\tup_write(&current->mm->mmap_sem);\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/personality.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/security.h>",
      "#include <linux/highmem.h>",
      "#include <linux/fs.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&current->mm->mmap_sem"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mprotect_fixup",
          "args": [
            "vma",
            "&prev",
            "nstart",
            "tmp",
            "newflags"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "mprotect_fixup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mprotect.c",
          "lines": "345-451",
          "snippet": "int\nmprotect_fixup(struct vm_area_struct *vma, struct vm_area_struct **pprev,\n\tunsigned long start, unsigned long end, unsigned long newflags)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long oldflags = vma->vm_flags;\n\tlong nrpages = (end - start) >> PAGE_SHIFT;\n\tunsigned long charged = 0;\n\tpgoff_t pgoff;\n\tint error;\n\tint dirty_accountable = 0;\n\n\tif (newflags == oldflags) {\n\t\t*pprev = vma;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Do PROT_NONE PFN permission checks here when we can still\n\t * bail out without undoing a lot of state. This is a rather\n\t * uncommon case, so doesn't need to be very optimized.\n\t */\n\tif (arch_has_pfn_modify_check() &&\n\t    (vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)) &&\n\t    (newflags & (VM_READ|VM_WRITE|VM_EXEC)) == 0) {\n\t\terror = prot_none_walk(vma, start, end, newflags);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * If we make a private mapping writable we increase our commit;\n\t * but (without finer accounting) cannot reduce our commit if we\n\t * make it unwritable again. hugetlb mapping were accounted for\n\t * even if read-only so there is no need to account for them here\n\t */\n\tif (newflags & VM_WRITE) {\n\t\t/* Check space limits when area turns into data. */\n\t\tif (!may_expand_vm(mm, newflags, nrpages) &&\n\t\t\t\tmay_expand_vm(mm, oldflags, nrpages))\n\t\t\treturn -ENOMEM;\n\t\tif (!(oldflags & (VM_ACCOUNT|VM_WRITE|VM_HUGETLB|\n\t\t\t\t\t\tVM_SHARED|VM_NORESERVE))) {\n\t\t\tcharged = nrpages;\n\t\t\tif (security_vm_enough_memory_mm(mm, charged))\n\t\t\t\treturn -ENOMEM;\n\t\t\tnewflags |= VM_ACCOUNT;\n\t\t}\n\t}\n\n\t/*\n\t * First try to merge with previous and/or next vma.\n\t */\n\tpgoff = vma->vm_pgoff + ((start - vma->vm_start) >> PAGE_SHIFT);\n\t*pprev = vma_merge(mm, *pprev, start, end, newflags,\n\t\t\t   vma->anon_vma, vma->vm_file, pgoff, vma_policy(vma),\n\t\t\t   vma->vm_userfaultfd_ctx);\n\tif (*pprev) {\n\t\tvma = *pprev;\n\t\tVM_WARN_ON((vma->vm_flags ^ newflags) & ~VM_SOFTDIRTY);\n\t\tgoto success;\n\t}\n\n\t*pprev = vma;\n\n\tif (start != vma->vm_start) {\n\t\terror = split_vma(mm, vma, start, 1);\n\t\tif (error)\n\t\t\tgoto fail;\n\t}\n\n\tif (end != vma->vm_end) {\n\t\terror = split_vma(mm, vma, end, 0);\n\t\tif (error)\n\t\t\tgoto fail;\n\t}\n\nsuccess:\n\t/*\n\t * vm_flags and vm_page_prot are protected by the mmap_sem\n\t * held in write mode.\n\t */\n\tvma->vm_flags = newflags;\n\tdirty_accountable = vma_wants_writenotify(vma, vma->vm_page_prot);\n\tvma_set_page_prot(vma);\n\n\tchange_protection(vma, start, end, vma->vm_page_prot,\n\t\t\t  dirty_accountable, 0);\n\n\t/*\n\t * Private VM_LOCKED VMA becoming writable: trigger COW to avoid major\n\t * fault on access.\n\t */\n\tif ((oldflags & (VM_WRITE | VM_SHARED | VM_LOCKED)) == VM_LOCKED &&\n\t\t\t(newflags & VM_WRITE)) {\n\t\tpopulate_vma_page_range(vma, start, end, NULL);\n\t}\n\n\tvm_stat_account(mm, oldflags, -nrpages);\n\tvm_stat_account(mm, newflags, nrpages);\n\tperf_event_mmap(vma);\n\treturn 0;\n\nfail:\n\tvm_unacct_memory(charged);\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/personality.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/security.h>",
            "#include <linux/highmem.h>",
            "#include <linux/fs.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <asm/cacheflush.h>\n#include <asm/pgtable.h>\n#include <linux/mm_inline.h>\n#include <linux/uaccess.h>\n#include <linux/ksm.h>\n#include <linux/pkeys.h>\n#include <linux/perf_event.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/personality.h>\n#include <linux/mempolicy.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nint\nmprotect_fixup(struct vm_area_struct *vma, struct vm_area_struct **pprev,\n\tunsigned long start, unsigned long end, unsigned long newflags)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long oldflags = vma->vm_flags;\n\tlong nrpages = (end - start) >> PAGE_SHIFT;\n\tunsigned long charged = 0;\n\tpgoff_t pgoff;\n\tint error;\n\tint dirty_accountable = 0;\n\n\tif (newflags == oldflags) {\n\t\t*pprev = vma;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Do PROT_NONE PFN permission checks here when we can still\n\t * bail out without undoing a lot of state. This is a rather\n\t * uncommon case, so doesn't need to be very optimized.\n\t */\n\tif (arch_has_pfn_modify_check() &&\n\t    (vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)) &&\n\t    (newflags & (VM_READ|VM_WRITE|VM_EXEC)) == 0) {\n\t\terror = prot_none_walk(vma, start, end, newflags);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * If we make a private mapping writable we increase our commit;\n\t * but (without finer accounting) cannot reduce our commit if we\n\t * make it unwritable again. hugetlb mapping were accounted for\n\t * even if read-only so there is no need to account for them here\n\t */\n\tif (newflags & VM_WRITE) {\n\t\t/* Check space limits when area turns into data. */\n\t\tif (!may_expand_vm(mm, newflags, nrpages) &&\n\t\t\t\tmay_expand_vm(mm, oldflags, nrpages))\n\t\t\treturn -ENOMEM;\n\t\tif (!(oldflags & (VM_ACCOUNT|VM_WRITE|VM_HUGETLB|\n\t\t\t\t\t\tVM_SHARED|VM_NORESERVE))) {\n\t\t\tcharged = nrpages;\n\t\t\tif (security_vm_enough_memory_mm(mm, charged))\n\t\t\t\treturn -ENOMEM;\n\t\t\tnewflags |= VM_ACCOUNT;\n\t\t}\n\t}\n\n\t/*\n\t * First try to merge with previous and/or next vma.\n\t */\n\tpgoff = vma->vm_pgoff + ((start - vma->vm_start) >> PAGE_SHIFT);\n\t*pprev = vma_merge(mm, *pprev, start, end, newflags,\n\t\t\t   vma->anon_vma, vma->vm_file, pgoff, vma_policy(vma),\n\t\t\t   vma->vm_userfaultfd_ctx);\n\tif (*pprev) {\n\t\tvma = *pprev;\n\t\tVM_WARN_ON((vma->vm_flags ^ newflags) & ~VM_SOFTDIRTY);\n\t\tgoto success;\n\t}\n\n\t*pprev = vma;\n\n\tif (start != vma->vm_start) {\n\t\terror = split_vma(mm, vma, start, 1);\n\t\tif (error)\n\t\t\tgoto fail;\n\t}\n\n\tif (end != vma->vm_end) {\n\t\terror = split_vma(mm, vma, end, 0);\n\t\tif (error)\n\t\t\tgoto fail;\n\t}\n\nsuccess:\n\t/*\n\t * vm_flags and vm_page_prot are protected by the mmap_sem\n\t * held in write mode.\n\t */\n\tvma->vm_flags = newflags;\n\tdirty_accountable = vma_wants_writenotify(vma, vma->vm_page_prot);\n\tvma_set_page_prot(vma);\n\n\tchange_protection(vma, start, end, vma->vm_page_prot,\n\t\t\t  dirty_accountable, 0);\n\n\t/*\n\t * Private VM_LOCKED VMA becoming writable: trigger COW to avoid major\n\t * fault on access.\n\t */\n\tif ((oldflags & (VM_WRITE | VM_SHARED | VM_LOCKED)) == VM_LOCKED &&\n\t\t\t(newflags & VM_WRITE)) {\n\t\tpopulate_vma_page_range(vma, start, end, NULL);\n\t}\n\n\tvm_stat_account(mm, oldflags, -nrpages);\n\tvm_stat_account(mm, newflags, nrpages);\n\tperf_event_mmap(vma);\n\treturn 0;\n\nfail:\n\tvm_unacct_memory(charged);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_file_mprotect",
          "args": [
            "vma",
            "reqprot",
            "prot"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_vm_prot_bits",
          "args": [
            "prot",
            "new_vma_pkey"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_override_mprotect_pkey",
          "args": [
            "vma",
            "prot",
            "pkey"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "grows & PROT_GROWSUP"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "grows & PROT_GROWSDOWN"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_vma",
          "args": [
            "current->mm",
            "start"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "find_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "775-796",
          "snippet": "struct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\n\t/* check the cache first */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\t/* trawl the list (there may be multiple mappings in which addr\n\t * resides) */\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_start > addr)\n\t\t\treturn NULL;\n\t\tif (vma->vm_end > addr) {\n\t\t\tvmacache_update(addr, vma);\n\t\t\treturn vma;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nstruct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\n\t/* check the cache first */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\t/* trawl the list (there may be multiple mappings in which addr\n\t * resides) */\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_start > addr)\n\t\t\treturn NULL;\n\t\tif (vma->vm_end > addr) {\n\t\t\tvmacache_update(addr, vma);\n\t\t\treturn vma;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_pkey_is_allocated",
          "args": [
            "current->mm",
            "pkey"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write_killable",
          "args": [
            "&current->mm->mmap_sem"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_validate_prot",
          "args": [
            "prot",
            "start"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "len"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <asm/cacheflush.h>\n#include <asm/pgtable.h>\n#include <linux/mm_inline.h>\n#include <linux/uaccess.h>\n#include <linux/ksm.h>\n#include <linux/pkeys.h>\n#include <linux/perf_event.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/personality.h>\n#include <linux/mempolicy.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nstatic int do_mprotect_pkey(unsigned long start, size_t len,\n\t\tunsigned long prot, int pkey)\n{\n\tunsigned long nstart, end, tmp, reqprot;\n\tstruct vm_area_struct *vma, *prev;\n\tint error = -EINVAL;\n\tconst int grows = prot & (PROT_GROWSDOWN|PROT_GROWSUP);\n\tconst bool rier = (current->personality & READ_IMPLIES_EXEC) &&\n\t\t\t\t(prot & PROT_READ);\n\n\tprot &= ~(PROT_GROWSDOWN|PROT_GROWSUP);\n\tif (grows == (PROT_GROWSDOWN|PROT_GROWSUP)) /* can't be both */\n\t\treturn -EINVAL;\n\n\tif (start & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\tif (!len)\n\t\treturn 0;\n\tlen = PAGE_ALIGN(len);\n\tend = start + len;\n\tif (end <= start)\n\t\treturn -ENOMEM;\n\tif (!arch_validate_prot(prot, start))\n\t\treturn -EINVAL;\n\n\treqprot = prot;\n\n\tif (down_write_killable(&current->mm->mmap_sem))\n\t\treturn -EINTR;\n\n\t/*\n\t * If userspace did not allocate the pkey, do not let\n\t * them use it here.\n\t */\n\terror = -EINVAL;\n\tif ((pkey != -1) && !mm_pkey_is_allocated(current->mm, pkey))\n\t\tgoto out;\n\n\tvma = find_vma(current->mm, start);\n\terror = -ENOMEM;\n\tif (!vma)\n\t\tgoto out;\n\tprev = vma->vm_prev;\n\tif (unlikely(grows & PROT_GROWSDOWN)) {\n\t\tif (vma->vm_start >= end)\n\t\t\tgoto out;\n\t\tstart = vma->vm_start;\n\t\terror = -EINVAL;\n\t\tif (!(vma->vm_flags & VM_GROWSDOWN))\n\t\t\tgoto out;\n\t} else {\n\t\tif (vma->vm_start > start)\n\t\t\tgoto out;\n\t\tif (unlikely(grows & PROT_GROWSUP)) {\n\t\t\tend = vma->vm_end;\n\t\t\terror = -EINVAL;\n\t\t\tif (!(vma->vm_flags & VM_GROWSUP))\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\tif (start > vma->vm_start)\n\t\tprev = vma;\n\n\tfor (nstart = start ; ; ) {\n\t\tunsigned long mask_off_old_flags;\n\t\tunsigned long newflags;\n\t\tint new_vma_pkey;\n\n\t\t/* Here we know that vma->vm_start <= nstart < vma->vm_end. */\n\n\t\t/* Does the application expect PROT_READ to imply PROT_EXEC */\n\t\tif (rier && (vma->vm_flags & VM_MAYEXEC))\n\t\t\tprot |= PROT_EXEC;\n\n\t\t/*\n\t\t * Each mprotect() call explicitly passes r/w/x permissions.\n\t\t * If a permission is not passed to mprotect(), it must be\n\t\t * cleared from the VMA.\n\t\t */\n\t\tmask_off_old_flags = VM_READ | VM_WRITE | VM_EXEC |\n\t\t\t\t\tVM_FLAGS_CLEAR;\n\n\t\tnew_vma_pkey = arch_override_mprotect_pkey(vma, prot, pkey);\n\t\tnewflags = calc_vm_prot_bits(prot, new_vma_pkey);\n\t\tnewflags |= (vma->vm_flags & ~mask_off_old_flags);\n\n\t\t/* newflags >> 4 shift VM_MAY% in place of VM_% */\n\t\tif ((newflags & ~(newflags >> 4)) & (VM_READ | VM_WRITE | VM_EXEC)) {\n\t\t\terror = -EACCES;\n\t\t\tgoto out;\n\t\t}\n\n\t\terror = security_file_mprotect(vma, reqprot, prot);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\ttmp = vma->vm_end;\n\t\tif (tmp > end)\n\t\t\ttmp = end;\n\t\terror = mprotect_fixup(vma, &prev, nstart, tmp, newflags);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tnstart = tmp;\n\n\t\tif (nstart < prev->vm_end)\n\t\t\tnstart = prev->vm_end;\n\t\tif (nstart >= end)\n\t\t\tgoto out;\n\n\t\tvma = prev->vm_next;\n\t\tif (!vma || vma->vm_start != nstart) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tprot = reqprot;\n\t}\nout:\n\tup_write(&current->mm->mmap_sem);\n\treturn error;\n}"
  },
  {
    "function_name": "mprotect_fixup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mprotect.c",
    "lines": "345-451",
    "snippet": "int\nmprotect_fixup(struct vm_area_struct *vma, struct vm_area_struct **pprev,\n\tunsigned long start, unsigned long end, unsigned long newflags)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long oldflags = vma->vm_flags;\n\tlong nrpages = (end - start) >> PAGE_SHIFT;\n\tunsigned long charged = 0;\n\tpgoff_t pgoff;\n\tint error;\n\tint dirty_accountable = 0;\n\n\tif (newflags == oldflags) {\n\t\t*pprev = vma;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Do PROT_NONE PFN permission checks here when we can still\n\t * bail out without undoing a lot of state. This is a rather\n\t * uncommon case, so doesn't need to be very optimized.\n\t */\n\tif (arch_has_pfn_modify_check() &&\n\t    (vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)) &&\n\t    (newflags & (VM_READ|VM_WRITE|VM_EXEC)) == 0) {\n\t\terror = prot_none_walk(vma, start, end, newflags);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * If we make a private mapping writable we increase our commit;\n\t * but (without finer accounting) cannot reduce our commit if we\n\t * make it unwritable again. hugetlb mapping were accounted for\n\t * even if read-only so there is no need to account for them here\n\t */\n\tif (newflags & VM_WRITE) {\n\t\t/* Check space limits when area turns into data. */\n\t\tif (!may_expand_vm(mm, newflags, nrpages) &&\n\t\t\t\tmay_expand_vm(mm, oldflags, nrpages))\n\t\t\treturn -ENOMEM;\n\t\tif (!(oldflags & (VM_ACCOUNT|VM_WRITE|VM_HUGETLB|\n\t\t\t\t\t\tVM_SHARED|VM_NORESERVE))) {\n\t\t\tcharged = nrpages;\n\t\t\tif (security_vm_enough_memory_mm(mm, charged))\n\t\t\t\treturn -ENOMEM;\n\t\t\tnewflags |= VM_ACCOUNT;\n\t\t}\n\t}\n\n\t/*\n\t * First try to merge with previous and/or next vma.\n\t */\n\tpgoff = vma->vm_pgoff + ((start - vma->vm_start) >> PAGE_SHIFT);\n\t*pprev = vma_merge(mm, *pprev, start, end, newflags,\n\t\t\t   vma->anon_vma, vma->vm_file, pgoff, vma_policy(vma),\n\t\t\t   vma->vm_userfaultfd_ctx);\n\tif (*pprev) {\n\t\tvma = *pprev;\n\t\tVM_WARN_ON((vma->vm_flags ^ newflags) & ~VM_SOFTDIRTY);\n\t\tgoto success;\n\t}\n\n\t*pprev = vma;\n\n\tif (start != vma->vm_start) {\n\t\terror = split_vma(mm, vma, start, 1);\n\t\tif (error)\n\t\t\tgoto fail;\n\t}\n\n\tif (end != vma->vm_end) {\n\t\terror = split_vma(mm, vma, end, 0);\n\t\tif (error)\n\t\t\tgoto fail;\n\t}\n\nsuccess:\n\t/*\n\t * vm_flags and vm_page_prot are protected by the mmap_sem\n\t * held in write mode.\n\t */\n\tvma->vm_flags = newflags;\n\tdirty_accountable = vma_wants_writenotify(vma, vma->vm_page_prot);\n\tvma_set_page_prot(vma);\n\n\tchange_protection(vma, start, end, vma->vm_page_prot,\n\t\t\t  dirty_accountable, 0);\n\n\t/*\n\t * Private VM_LOCKED VMA becoming writable: trigger COW to avoid major\n\t * fault on access.\n\t */\n\tif ((oldflags & (VM_WRITE | VM_SHARED | VM_LOCKED)) == VM_LOCKED &&\n\t\t\t(newflags & VM_WRITE)) {\n\t\tpopulate_vma_page_range(vma, start, end, NULL);\n\t}\n\n\tvm_stat_account(mm, oldflags, -nrpages);\n\tvm_stat_account(mm, newflags, nrpages);\n\tperf_event_mmap(vma);\n\treturn 0;\n\nfail:\n\tvm_unacct_memory(charged);\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/personality.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/security.h>",
      "#include <linux/highmem.h>",
      "#include <linux/fs.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vm_unacct_memory",
          "args": [
            "charged"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_event_mmap",
          "args": [
            "vma"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_stat_account",
          "args": [
            "mm",
            "newflags",
            "nrpages"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "vm_stat_account",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "3306-3316",
          "snippet": "void vm_stat_account(struct mm_struct *mm, vm_flags_t flags, long npages)\n{\n\tmm->total_vm += npages;\n\n\tif (is_exec_mapping(flags))\n\t\tmm->exec_vm += npages;\n\telse if (is_stack_mapping(flags))\n\t\tmm->stack_vm += npages;\n\telse if (is_data_mapping(flags))\n\t\tmm->data_vm += npages;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid vm_stat_account(struct mm_struct *mm, vm_flags_t flags, long npages)\n{\n\tmm->total_vm += npages;\n\n\tif (is_exec_mapping(flags))\n\t\tmm->exec_vm += npages;\n\telse if (is_stack_mapping(flags))\n\t\tmm->stack_vm += npages;\n\telse if (is_data_mapping(flags))\n\t\tmm->data_vm += npages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "populate_vma_page_range",
          "args": [
            "vma",
            "start",
            "end",
            "NULL"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "populate_vma_page_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/gup.c",
          "lines": "1212-1249",
          "snippet": "long populate_vma_page_range(struct vm_area_struct *vma,\n\t\tunsigned long start, unsigned long end, int *nonblocking)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long nr_pages = (end - start) / PAGE_SIZE;\n\tint gup_flags;\n\n\tVM_BUG_ON(start & ~PAGE_MASK);\n\tVM_BUG_ON(end   & ~PAGE_MASK);\n\tVM_BUG_ON_VMA(start < vma->vm_start, vma);\n\tVM_BUG_ON_VMA(end   > vma->vm_end, vma);\n\tVM_BUG_ON_MM(!rwsem_is_locked(&mm->mmap_sem), mm);\n\n\tgup_flags = FOLL_TOUCH | FOLL_POPULATE | FOLL_MLOCK;\n\tif (vma->vm_flags & VM_LOCKONFAULT)\n\t\tgup_flags &= ~FOLL_POPULATE;\n\t/*\n\t * We want to touch writable mappings with a write fault in order\n\t * to break COW, except for shared mappings because these don't COW\n\t * and we would not want to dirty them for nothing.\n\t */\n\tif ((vma->vm_flags & (VM_WRITE | VM_SHARED)) == VM_WRITE)\n\t\tgup_flags |= FOLL_WRITE;\n\n\t/*\n\t * We want mlock to succeed for regions that have any permissions\n\t * other than PROT_NONE.\n\t */\n\tif (vma->vm_flags & (VM_READ | VM_WRITE | VM_EXEC))\n\t\tgup_flags |= FOLL_FORCE;\n\n\t/*\n\t * We made sure addr is within a VMA, so the following will\n\t * not result in a stack expansion that recurses back here.\n\t */\n\treturn __get_user_pages(current, mm, start, nr_pages, gup_flags,\n\t\t\t\tNULL, NULL, nonblocking);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/hugetlb.h>\n#include <linux/rwsem.h>\n#include <linux/sched/signal.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nlong populate_vma_page_range(struct vm_area_struct *vma,\n\t\tunsigned long start, unsigned long end, int *nonblocking)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long nr_pages = (end - start) / PAGE_SIZE;\n\tint gup_flags;\n\n\tVM_BUG_ON(start & ~PAGE_MASK);\n\tVM_BUG_ON(end   & ~PAGE_MASK);\n\tVM_BUG_ON_VMA(start < vma->vm_start, vma);\n\tVM_BUG_ON_VMA(end   > vma->vm_end, vma);\n\tVM_BUG_ON_MM(!rwsem_is_locked(&mm->mmap_sem), mm);\n\n\tgup_flags = FOLL_TOUCH | FOLL_POPULATE | FOLL_MLOCK;\n\tif (vma->vm_flags & VM_LOCKONFAULT)\n\t\tgup_flags &= ~FOLL_POPULATE;\n\t/*\n\t * We want to touch writable mappings with a write fault in order\n\t * to break COW, except for shared mappings because these don't COW\n\t * and we would not want to dirty them for nothing.\n\t */\n\tif ((vma->vm_flags & (VM_WRITE | VM_SHARED)) == VM_WRITE)\n\t\tgup_flags |= FOLL_WRITE;\n\n\t/*\n\t * We want mlock to succeed for regions that have any permissions\n\t * other than PROT_NONE.\n\t */\n\tif (vma->vm_flags & (VM_READ | VM_WRITE | VM_EXEC))\n\t\tgup_flags |= FOLL_FORCE;\n\n\t/*\n\t * We made sure addr is within a VMA, so the following will\n\t * not result in a stack expansion that recurses back here.\n\t */\n\treturn __get_user_pages(current, mm, start, nr_pages, gup_flags,\n\t\t\t\tNULL, NULL, nonblocking);\n}"
        }
      },
      {
        "call_info": {
          "callee": "change_protection",
          "args": [
            "vma",
            "start",
            "end",
            "vma->vm_page_prot",
            "dirty_accountable",
            "0"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "change_protection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mprotect.c",
          "lines": "295-307",
          "snippet": "unsigned long change_protection(struct vm_area_struct *vma, unsigned long start,\n\t\t       unsigned long end, pgprot_t newprot,\n\t\t       int dirty_accountable, int prot_numa)\n{\n\tunsigned long pages;\n\n\tif (is_vm_hugetlb_page(vma))\n\t\tpages = hugetlb_change_protection(vma, start, end, newprot);\n\telse\n\t\tpages = change_protection_range(vma, start, end, newprot, dirty_accountable, prot_numa);\n\n\treturn pages;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/personality.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/security.h>",
            "#include <linux/highmem.h>",
            "#include <linux/fs.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <asm/cacheflush.h>\n#include <asm/pgtable.h>\n#include <linux/mm_inline.h>\n#include <linux/uaccess.h>\n#include <linux/ksm.h>\n#include <linux/pkeys.h>\n#include <linux/perf_event.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/personality.h>\n#include <linux/mempolicy.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nunsigned long change_protection(struct vm_area_struct *vma, unsigned long start,\n\t\t       unsigned long end, pgprot_t newprot,\n\t\t       int dirty_accountable, int prot_numa)\n{\n\tunsigned long pages;\n\n\tif (is_vm_hugetlb_page(vma))\n\t\tpages = hugetlb_change_protection(vma, start, end, newprot);\n\telse\n\t\tpages = change_protection_range(vma, start, end, newprot, dirty_accountable, prot_numa);\n\n\treturn pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_set_page_prot",
          "args": [
            "vma"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "vma_set_page_prot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "126-138",
          "snippet": "void vma_set_page_prot(struct vm_area_struct *vma)\n{\n\tunsigned long vm_flags = vma->vm_flags;\n\tpgprot_t vm_page_prot;\n\n\tvm_page_prot = vm_pgprot_modify(vma->vm_page_prot, vm_flags);\n\tif (vma_wants_writenotify(vma, vm_page_prot)) {\n\t\tvm_flags &= ~VM_SHARED;\n\t\tvm_page_prot = vm_pgprot_modify(vm_page_prot, vm_flags);\n\t}\n\t/* remove_protection_ptes reads vma->vm_page_prot without mmap_sem */\n\tWRITE_ONCE(vma->vm_page_prot, vm_page_prot);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid vma_set_page_prot(struct vm_area_struct *vma)\n{\n\tunsigned long vm_flags = vma->vm_flags;\n\tpgprot_t vm_page_prot;\n\n\tvm_page_prot = vm_pgprot_modify(vma->vm_page_prot, vm_flags);\n\tif (vma_wants_writenotify(vma, vm_page_prot)) {\n\t\tvm_flags &= ~VM_SHARED;\n\t\tvm_page_prot = vm_pgprot_modify(vm_page_prot, vm_flags);\n\t}\n\t/* remove_protection_ptes reads vma->vm_page_prot without mmap_sem */\n\tWRITE_ONCE(vma->vm_page_prot, vm_page_prot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_wants_writenotify",
          "args": [
            "vma",
            "vma->vm_page_prot"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "vma_wants_writenotify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "1653-1683",
          "snippet": "int vma_wants_writenotify(struct vm_area_struct *vma, pgprot_t vm_page_prot)\n{\n\tvm_flags_t vm_flags = vma->vm_flags;\n\tconst struct vm_operations_struct *vm_ops = vma->vm_ops;\n\n\t/* If it was private or non-writable, the write bit is already clear */\n\tif ((vm_flags & (VM_WRITE|VM_SHARED)) != ((VM_WRITE|VM_SHARED)))\n\t\treturn 0;\n\n\t/* The backer wishes to know when pages are first written to? */\n\tif (vm_ops && (vm_ops->page_mkwrite || vm_ops->pfn_mkwrite))\n\t\treturn 1;\n\n\t/* The open routine did something to the protections that pgprot_modify\n\t * won't preserve? */\n\tif (pgprot_val(vm_page_prot) !=\n\t    pgprot_val(vm_pgprot_modify(vm_page_prot, vm_flags)))\n\t\treturn 0;\n\n\t/* Do we need to track softdirty? */\n\tif (IS_ENABLED(CONFIG_MEM_SOFT_DIRTY) && !(vm_flags & VM_SOFTDIRTY))\n\t\treturn 1;\n\n\t/* Specialty mapping? */\n\tif (vm_flags & VM_PFNMAP)\n\t\treturn 0;\n\n\t/* Can the mapping track the dirty pages? */\n\treturn vma->vm_file && vma->vm_file->f_mapping &&\n\t\tmapping_cap_account_dirty(vma->vm_file->f_mapping);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint vma_wants_writenotify(struct vm_area_struct *vma, pgprot_t vm_page_prot)\n{\n\tvm_flags_t vm_flags = vma->vm_flags;\n\tconst struct vm_operations_struct *vm_ops = vma->vm_ops;\n\n\t/* If it was private or non-writable, the write bit is already clear */\n\tif ((vm_flags & (VM_WRITE|VM_SHARED)) != ((VM_WRITE|VM_SHARED)))\n\t\treturn 0;\n\n\t/* The backer wishes to know when pages are first written to? */\n\tif (vm_ops && (vm_ops->page_mkwrite || vm_ops->pfn_mkwrite))\n\t\treturn 1;\n\n\t/* The open routine did something to the protections that pgprot_modify\n\t * won't preserve? */\n\tif (pgprot_val(vm_page_prot) !=\n\t    pgprot_val(vm_pgprot_modify(vm_page_prot, vm_flags)))\n\t\treturn 0;\n\n\t/* Do we need to track softdirty? */\n\tif (IS_ENABLED(CONFIG_MEM_SOFT_DIRTY) && !(vm_flags & VM_SOFTDIRTY))\n\t\treturn 1;\n\n\t/* Specialty mapping? */\n\tif (vm_flags & VM_PFNMAP)\n\t\treturn 0;\n\n\t/* Can the mapping track the dirty pages? */\n\treturn vma->vm_file && vma->vm_file->f_mapping &&\n\t\tmapping_cap_account_dirty(vma->vm_file->f_mapping);\n}"
        }
      },
      {
        "call_info": {
          "callee": "split_vma",
          "args": [
            "mm",
            "vma",
            "end",
            "0"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "split_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "1450-1507",
          "snippet": "int split_vma(struct mm_struct *mm, struct vm_area_struct *vma,\n\t      unsigned long addr, int new_below)\n{\n\tstruct vm_area_struct *new;\n\tstruct vm_region *region;\n\tunsigned long npages;\n\n\t/* we're only permitted to split anonymous regions (these should have\n\t * only a single usage on the region) */\n\tif (vma->vm_file)\n\t\treturn -ENOMEM;\n\n\tif (mm->map_count >= sysctl_max_map_count)\n\t\treturn -ENOMEM;\n\n\tregion = kmem_cache_alloc(vm_region_jar, GFP_KERNEL);\n\tif (!region)\n\t\treturn -ENOMEM;\n\n\tnew = vm_area_dup(vma);\n\tif (!new) {\n\t\tkmem_cache_free(vm_region_jar, region);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* most fields are the same, copy all, and then fixup */\n\t*region = *vma->vm_region;\n\tnew->vm_region = region;\n\n\tnpages = (addr - vma->vm_start) >> PAGE_SHIFT;\n\n\tif (new_below) {\n\t\tregion->vm_top = region->vm_end = new->vm_end = addr;\n\t} else {\n\t\tregion->vm_start = new->vm_start = addr;\n\t\tregion->vm_pgoff = new->vm_pgoff += npages;\n\t}\n\n\tif (new->vm_ops && new->vm_ops->open)\n\t\tnew->vm_ops->open(new);\n\n\tdelete_vma_from_mm(vma);\n\tdown_write(&nommu_region_sem);\n\tdelete_nommu_region(vma->vm_region);\n\tif (new_below) {\n\t\tvma->vm_region->vm_start = vma->vm_start = addr;\n\t\tvma->vm_region->vm_pgoff = vma->vm_pgoff += npages;\n\t} else {\n\t\tvma->vm_region->vm_end = vma->vm_end = addr;\n\t\tvma->vm_region->vm_top = addr;\n\t}\n\tadd_nommu_region(vma->vm_region);\n\tadd_nommu_region(new->vm_region);\n\tup_write(&nommu_region_sem);\n\tadd_vma_to_mm(mm, vma);\n\tadd_vma_to_mm(mm, new);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *vm_region_jar;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *vm_region_jar;\n\nint split_vma(struct mm_struct *mm, struct vm_area_struct *vma,\n\t      unsigned long addr, int new_below)\n{\n\tstruct vm_area_struct *new;\n\tstruct vm_region *region;\n\tunsigned long npages;\n\n\t/* we're only permitted to split anonymous regions (these should have\n\t * only a single usage on the region) */\n\tif (vma->vm_file)\n\t\treturn -ENOMEM;\n\n\tif (mm->map_count >= sysctl_max_map_count)\n\t\treturn -ENOMEM;\n\n\tregion = kmem_cache_alloc(vm_region_jar, GFP_KERNEL);\n\tif (!region)\n\t\treturn -ENOMEM;\n\n\tnew = vm_area_dup(vma);\n\tif (!new) {\n\t\tkmem_cache_free(vm_region_jar, region);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* most fields are the same, copy all, and then fixup */\n\t*region = *vma->vm_region;\n\tnew->vm_region = region;\n\n\tnpages = (addr - vma->vm_start) >> PAGE_SHIFT;\n\n\tif (new_below) {\n\t\tregion->vm_top = region->vm_end = new->vm_end = addr;\n\t} else {\n\t\tregion->vm_start = new->vm_start = addr;\n\t\tregion->vm_pgoff = new->vm_pgoff += npages;\n\t}\n\n\tif (new->vm_ops && new->vm_ops->open)\n\t\tnew->vm_ops->open(new);\n\n\tdelete_vma_from_mm(vma);\n\tdown_write(&nommu_region_sem);\n\tdelete_nommu_region(vma->vm_region);\n\tif (new_below) {\n\t\tvma->vm_region->vm_start = vma->vm_start = addr;\n\t\tvma->vm_region->vm_pgoff = vma->vm_pgoff += npages;\n\t} else {\n\t\tvma->vm_region->vm_end = vma->vm_end = addr;\n\t\tvma->vm_region->vm_top = addr;\n\t}\n\tadd_nommu_region(vma->vm_region);\n\tadd_nommu_region(new->vm_region);\n\tup_write(&nommu_region_sem);\n\tadd_vma_to_mm(mm, vma);\n\tadd_vma_to_mm(mm, new);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_WARN_ON",
          "args": [
            "(vma->vm_flags ^ newflags) & ~VM_SOFTDIRTY"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_merge",
          "args": [
            "mm",
            "*pprev",
            "start",
            "end",
            "newflags",
            "vma->anon_vma",
            "vma->vm_file",
            "pgoff",
            "vma_policy(vma)",
            "vma->vm_userfaultfd_ctx"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "vma_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "1132-1223",
          "snippet": "struct vm_area_struct *vma_merge(struct mm_struct *mm,\n\t\t\tstruct vm_area_struct *prev, unsigned long addr,\n\t\t\tunsigned long end, unsigned long vm_flags,\n\t\t\tstruct anon_vma *anon_vma, struct file *file,\n\t\t\tpgoff_t pgoff, struct mempolicy *policy,\n\t\t\tstruct vm_userfaultfd_ctx vm_userfaultfd_ctx)\n{\n\tpgoff_t pglen = (end - addr) >> PAGE_SHIFT;\n\tstruct vm_area_struct *area, *next;\n\tint err;\n\n\t/*\n\t * We later require that vma->vm_flags == vm_flags,\n\t * so this tests vma->vm_flags & VM_SPECIAL, too.\n\t */\n\tif (vm_flags & VM_SPECIAL)\n\t\treturn NULL;\n\n\tif (prev)\n\t\tnext = prev->vm_next;\n\telse\n\t\tnext = mm->mmap;\n\tarea = next;\n\tif (area && area->vm_end == end)\t\t/* cases 6, 7, 8 */\n\t\tnext = next->vm_next;\n\n\t/* verify some invariant that must be enforced by the caller */\n\tVM_WARN_ON(prev && addr <= prev->vm_start);\n\tVM_WARN_ON(area && end > area->vm_end);\n\tVM_WARN_ON(addr >= end);\n\n\t/*\n\t * Can it merge with the predecessor?\n\t */\n\tif (prev && prev->vm_end == addr &&\n\t\t\tmpol_equal(vma_policy(prev), policy) &&\n\t\t\tcan_vma_merge_after(prev, vm_flags,\n\t\t\t\t\t    anon_vma, file, pgoff,\n\t\t\t\t\t    vm_userfaultfd_ctx)) {\n\t\t/*\n\t\t * OK, it can.  Can we now merge in the successor as well?\n\t\t */\n\t\tif (next && end == next->vm_start &&\n\t\t\t\tmpol_equal(policy, vma_policy(next)) &&\n\t\t\t\tcan_vma_merge_before(next, vm_flags,\n\t\t\t\t\t\t     anon_vma, file,\n\t\t\t\t\t\t     pgoff+pglen,\n\t\t\t\t\t\t     vm_userfaultfd_ctx) &&\n\t\t\t\tis_mergeable_anon_vma(prev->anon_vma,\n\t\t\t\t\t\t      next->anon_vma, NULL)) {\n\t\t\t\t\t\t\t/* cases 1, 6 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t next->vm_end, prev->vm_pgoff, NULL,\n\t\t\t\t\t prev);\n\t\t} else\t\t\t\t\t/* cases 2, 5, 7 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t end, prev->vm_pgoff, NULL, prev);\n\t\tif (err)\n\t\t\treturn NULL;\n\t\tkhugepaged_enter_vma_merge(prev, vm_flags);\n\t\treturn prev;\n\t}\n\n\t/*\n\t * Can this new request be merged in front of next?\n\t */\n\tif (next && end == next->vm_start &&\n\t\t\tmpol_equal(policy, vma_policy(next)) &&\n\t\t\tcan_vma_merge_before(next, vm_flags,\n\t\t\t\t\t     anon_vma, file, pgoff+pglen,\n\t\t\t\t\t     vm_userfaultfd_ctx)) {\n\t\tif (prev && addr < prev->vm_end)\t/* case 4 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t addr, prev->vm_pgoff, NULL, next);\n\t\telse {\t\t\t\t\t/* cases 3, 8 */\n\t\t\terr = __vma_adjust(area, addr, next->vm_end,\n\t\t\t\t\t next->vm_pgoff - pglen, NULL, next);\n\t\t\t/*\n\t\t\t * In case 3 area is already equal to next and\n\t\t\t * this is a noop, but in case 8 \"area\" has\n\t\t\t * been removed and next was expanded over it.\n\t\t\t */\n\t\t\tarea = next;\n\t\t}\n\t\tif (err)\n\t\t\treturn NULL;\n\t\tkhugepaged_enter_vma_merge(area, vm_flags);\n\t\treturn area;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end);\n\nstruct vm_area_struct *vma_merge(struct mm_struct *mm,\n\t\t\tstruct vm_area_struct *prev, unsigned long addr,\n\t\t\tunsigned long end, unsigned long vm_flags,\n\t\t\tstruct anon_vma *anon_vma, struct file *file,\n\t\t\tpgoff_t pgoff, struct mempolicy *policy,\n\t\t\tstruct vm_userfaultfd_ctx vm_userfaultfd_ctx)\n{\n\tpgoff_t pglen = (end - addr) >> PAGE_SHIFT;\n\tstruct vm_area_struct *area, *next;\n\tint err;\n\n\t/*\n\t * We later require that vma->vm_flags == vm_flags,\n\t * so this tests vma->vm_flags & VM_SPECIAL, too.\n\t */\n\tif (vm_flags & VM_SPECIAL)\n\t\treturn NULL;\n\n\tif (prev)\n\t\tnext = prev->vm_next;\n\telse\n\t\tnext = mm->mmap;\n\tarea = next;\n\tif (area && area->vm_end == end)\t\t/* cases 6, 7, 8 */\n\t\tnext = next->vm_next;\n\n\t/* verify some invariant that must be enforced by the caller */\n\tVM_WARN_ON(prev && addr <= prev->vm_start);\n\tVM_WARN_ON(area && end > area->vm_end);\n\tVM_WARN_ON(addr >= end);\n\n\t/*\n\t * Can it merge with the predecessor?\n\t */\n\tif (prev && prev->vm_end == addr &&\n\t\t\tmpol_equal(vma_policy(prev), policy) &&\n\t\t\tcan_vma_merge_after(prev, vm_flags,\n\t\t\t\t\t    anon_vma, file, pgoff,\n\t\t\t\t\t    vm_userfaultfd_ctx)) {\n\t\t/*\n\t\t * OK, it can.  Can we now merge in the successor as well?\n\t\t */\n\t\tif (next && end == next->vm_start &&\n\t\t\t\tmpol_equal(policy, vma_policy(next)) &&\n\t\t\t\tcan_vma_merge_before(next, vm_flags,\n\t\t\t\t\t\t     anon_vma, file,\n\t\t\t\t\t\t     pgoff+pglen,\n\t\t\t\t\t\t     vm_userfaultfd_ctx) &&\n\t\t\t\tis_mergeable_anon_vma(prev->anon_vma,\n\t\t\t\t\t\t      next->anon_vma, NULL)) {\n\t\t\t\t\t\t\t/* cases 1, 6 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t next->vm_end, prev->vm_pgoff, NULL,\n\t\t\t\t\t prev);\n\t\t} else\t\t\t\t\t/* cases 2, 5, 7 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t end, prev->vm_pgoff, NULL, prev);\n\t\tif (err)\n\t\t\treturn NULL;\n\t\tkhugepaged_enter_vma_merge(prev, vm_flags);\n\t\treturn prev;\n\t}\n\n\t/*\n\t * Can this new request be merged in front of next?\n\t */\n\tif (next && end == next->vm_start &&\n\t\t\tmpol_equal(policy, vma_policy(next)) &&\n\t\t\tcan_vma_merge_before(next, vm_flags,\n\t\t\t\t\t     anon_vma, file, pgoff+pglen,\n\t\t\t\t\t     vm_userfaultfd_ctx)) {\n\t\tif (prev && addr < prev->vm_end)\t/* case 4 */\n\t\t\terr = __vma_adjust(prev, prev->vm_start,\n\t\t\t\t\t addr, prev->vm_pgoff, NULL, next);\n\t\telse {\t\t\t\t\t/* cases 3, 8 */\n\t\t\terr = __vma_adjust(area, addr, next->vm_end,\n\t\t\t\t\t next->vm_pgoff - pglen, NULL, next);\n\t\t\t/*\n\t\t\t * In case 3 area is already equal to next and\n\t\t\t * this is a noop, but in case 8 \"area\" has\n\t\t\t * been removed and next was expanded over it.\n\t\t\t */\n\t\t\tarea = next;\n\t\t}\n\t\tif (err)\n\t\t\treturn NULL;\n\t\tkhugepaged_enter_vma_merge(area, vm_flags);\n\t\treturn area;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_policy",
          "args": [
            "vma"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "vma_policy_mof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1676-1696",
          "snippet": "bool vma_policy_mof(struct vm_area_struct *vma)\n{\n\tstruct mempolicy *pol;\n\n\tif (vma->vm_ops && vma->vm_ops->get_policy) {\n\t\tbool ret = false;\n\n\t\tpol = vma->vm_ops->get_policy(vma, vma->vm_start);\n\t\tif (pol && (pol->flags & MPOL_F_MOF))\n\t\t\tret = true;\n\t\tmpol_cond_put(pol);\n\n\t\treturn ret;\n\t}\n\n\tpol = vma->vm_policy;\n\tif (!pol)\n\t\tpol = get_task_policy(current);\n\n\treturn pol->flags & MPOL_F_MOF;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nstatic void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nbool vma_policy_mof(struct vm_area_struct *vma)\n{\n\tstruct mempolicy *pol;\n\n\tif (vma->vm_ops && vma->vm_ops->get_policy) {\n\t\tbool ret = false;\n\n\t\tpol = vma->vm_ops->get_policy(vma, vma->vm_start);\n\t\tif (pol && (pol->flags & MPOL_F_MOF))\n\t\t\tret = true;\n\t\tmpol_cond_put(pol);\n\n\t\treturn ret;\n\t}\n\n\tpol = vma->vm_policy;\n\tif (!pol)\n\t\tpol = get_task_policy(current);\n\n\treturn pol->flags & MPOL_F_MOF;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_vm_enough_memory_mm",
          "args": [
            "mm",
            "charged"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "may_expand_vm",
          "args": [
            "mm",
            "oldflags",
            "nrpages"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "may_expand_vm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "3281-3304",
          "snippet": "bool may_expand_vm(struct mm_struct *mm, vm_flags_t flags, unsigned long npages)\n{\n\tif (mm->total_vm + npages > rlimit(RLIMIT_AS) >> PAGE_SHIFT)\n\t\treturn false;\n\n\tif (is_data_mapping(flags) &&\n\t    mm->data_vm + npages > rlimit(RLIMIT_DATA) >> PAGE_SHIFT) {\n\t\t/* Workaround for Valgrind */\n\t\tif (rlimit(RLIMIT_DATA) == 0 &&\n\t\t    mm->data_vm + npages <= rlimit_max(RLIMIT_DATA) >> PAGE_SHIFT)\n\t\t\treturn true;\n\n\t\tpr_warn_once(\"%s (%d): VmData %lu exceed data ulimit %lu. Update limits%s.\\n\",\n\t\t\t     current->comm, current->pid,\n\t\t\t     (mm->data_vm + npages) << PAGE_SHIFT,\n\t\t\t     rlimit(RLIMIT_DATA),\n\t\t\t     ignore_rlimit_data ? \"\" : \" or use boot option ignore_rlimit_data\");\n\n\t\tif (!ignore_rlimit_data)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool ignore_rlimit_data;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic bool ignore_rlimit_data;\n\nbool may_expand_vm(struct mm_struct *mm, vm_flags_t flags, unsigned long npages)\n{\n\tif (mm->total_vm + npages > rlimit(RLIMIT_AS) >> PAGE_SHIFT)\n\t\treturn false;\n\n\tif (is_data_mapping(flags) &&\n\t    mm->data_vm + npages > rlimit(RLIMIT_DATA) >> PAGE_SHIFT) {\n\t\t/* Workaround for Valgrind */\n\t\tif (rlimit(RLIMIT_DATA) == 0 &&\n\t\t    mm->data_vm + npages <= rlimit_max(RLIMIT_DATA) >> PAGE_SHIFT)\n\t\t\treturn true;\n\n\t\tpr_warn_once(\"%s (%d): VmData %lu exceed data ulimit %lu. Update limits%s.\\n\",\n\t\t\t     current->comm, current->pid,\n\t\t\t     (mm->data_vm + npages) << PAGE_SHIFT,\n\t\t\t     rlimit(RLIMIT_DATA),\n\t\t\t     ignore_rlimit_data ? \"\" : \" or use boot option ignore_rlimit_data\");\n\n\t\tif (!ignore_rlimit_data)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prot_none_walk",
          "args": [
            "vma",
            "start",
            "end",
            "newflags"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "prot_none_walk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mprotect.c",
          "lines": "330-343",
          "snippet": "static int prot_none_walk(struct vm_area_struct *vma, unsigned long start,\n\t\t\t   unsigned long end, unsigned long newflags)\n{\n\tpgprot_t new_pgprot = vm_get_page_prot(newflags);\n\tstruct mm_walk prot_none_walk = {\n\t\t.pte_entry = prot_none_pte_entry,\n\t\t.hugetlb_entry = prot_none_hugetlb_entry,\n\t\t.test_walk = prot_none_test,\n\t\t.mm = current->mm,\n\t\t.private = &new_pgprot,\n\t};\n\n\treturn walk_page_range(start, end, &prot_none_walk);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/personality.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/security.h>",
            "#include <linux/highmem.h>",
            "#include <linux/fs.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <asm/cacheflush.h>\n#include <asm/pgtable.h>\n#include <linux/mm_inline.h>\n#include <linux/uaccess.h>\n#include <linux/ksm.h>\n#include <linux/pkeys.h>\n#include <linux/perf_event.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/personality.h>\n#include <linux/mempolicy.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nstatic int prot_none_walk(struct vm_area_struct *vma, unsigned long start,\n\t\t\t   unsigned long end, unsigned long newflags)\n{\n\tpgprot_t new_pgprot = vm_get_page_prot(newflags);\n\tstruct mm_walk prot_none_walk = {\n\t\t.pte_entry = prot_none_pte_entry,\n\t\t.hugetlb_entry = prot_none_hugetlb_entry,\n\t\t.test_walk = prot_none_test,\n\t\t.mm = current->mm,\n\t\t.private = &new_pgprot,\n\t};\n\n\treturn walk_page_range(start, end, &prot_none_walk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_has_pfn_modify_check",
          "args": [],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <asm/cacheflush.h>\n#include <asm/pgtable.h>\n#include <linux/mm_inline.h>\n#include <linux/uaccess.h>\n#include <linux/ksm.h>\n#include <linux/pkeys.h>\n#include <linux/perf_event.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/personality.h>\n#include <linux/mempolicy.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nint\nmprotect_fixup(struct vm_area_struct *vma, struct vm_area_struct **pprev,\n\tunsigned long start, unsigned long end, unsigned long newflags)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long oldflags = vma->vm_flags;\n\tlong nrpages = (end - start) >> PAGE_SHIFT;\n\tunsigned long charged = 0;\n\tpgoff_t pgoff;\n\tint error;\n\tint dirty_accountable = 0;\n\n\tif (newflags == oldflags) {\n\t\t*pprev = vma;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Do PROT_NONE PFN permission checks here when we can still\n\t * bail out without undoing a lot of state. This is a rather\n\t * uncommon case, so doesn't need to be very optimized.\n\t */\n\tif (arch_has_pfn_modify_check() &&\n\t    (vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)) &&\n\t    (newflags & (VM_READ|VM_WRITE|VM_EXEC)) == 0) {\n\t\terror = prot_none_walk(vma, start, end, newflags);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * If we make a private mapping writable we increase our commit;\n\t * but (without finer accounting) cannot reduce our commit if we\n\t * make it unwritable again. hugetlb mapping were accounted for\n\t * even if read-only so there is no need to account for them here\n\t */\n\tif (newflags & VM_WRITE) {\n\t\t/* Check space limits when area turns into data. */\n\t\tif (!may_expand_vm(mm, newflags, nrpages) &&\n\t\t\t\tmay_expand_vm(mm, oldflags, nrpages))\n\t\t\treturn -ENOMEM;\n\t\tif (!(oldflags & (VM_ACCOUNT|VM_WRITE|VM_HUGETLB|\n\t\t\t\t\t\tVM_SHARED|VM_NORESERVE))) {\n\t\t\tcharged = nrpages;\n\t\t\tif (security_vm_enough_memory_mm(mm, charged))\n\t\t\t\treturn -ENOMEM;\n\t\t\tnewflags |= VM_ACCOUNT;\n\t\t}\n\t}\n\n\t/*\n\t * First try to merge with previous and/or next vma.\n\t */\n\tpgoff = vma->vm_pgoff + ((start - vma->vm_start) >> PAGE_SHIFT);\n\t*pprev = vma_merge(mm, *pprev, start, end, newflags,\n\t\t\t   vma->anon_vma, vma->vm_file, pgoff, vma_policy(vma),\n\t\t\t   vma->vm_userfaultfd_ctx);\n\tif (*pprev) {\n\t\tvma = *pprev;\n\t\tVM_WARN_ON((vma->vm_flags ^ newflags) & ~VM_SOFTDIRTY);\n\t\tgoto success;\n\t}\n\n\t*pprev = vma;\n\n\tif (start != vma->vm_start) {\n\t\terror = split_vma(mm, vma, start, 1);\n\t\tif (error)\n\t\t\tgoto fail;\n\t}\n\n\tif (end != vma->vm_end) {\n\t\terror = split_vma(mm, vma, end, 0);\n\t\tif (error)\n\t\t\tgoto fail;\n\t}\n\nsuccess:\n\t/*\n\t * vm_flags and vm_page_prot are protected by the mmap_sem\n\t * held in write mode.\n\t */\n\tvma->vm_flags = newflags;\n\tdirty_accountable = vma_wants_writenotify(vma, vma->vm_page_prot);\n\tvma_set_page_prot(vma);\n\n\tchange_protection(vma, start, end, vma->vm_page_prot,\n\t\t\t  dirty_accountable, 0);\n\n\t/*\n\t * Private VM_LOCKED VMA becoming writable: trigger COW to avoid major\n\t * fault on access.\n\t */\n\tif ((oldflags & (VM_WRITE | VM_SHARED | VM_LOCKED)) == VM_LOCKED &&\n\t\t\t(newflags & VM_WRITE)) {\n\t\tpopulate_vma_page_range(vma, start, end, NULL);\n\t}\n\n\tvm_stat_account(mm, oldflags, -nrpages);\n\tvm_stat_account(mm, newflags, nrpages);\n\tperf_event_mmap(vma);\n\treturn 0;\n\nfail:\n\tvm_unacct_memory(charged);\n\treturn error;\n}"
  },
  {
    "function_name": "prot_none_walk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mprotect.c",
    "lines": "330-343",
    "snippet": "static int prot_none_walk(struct vm_area_struct *vma, unsigned long start,\n\t\t\t   unsigned long end, unsigned long newflags)\n{\n\tpgprot_t new_pgprot = vm_get_page_prot(newflags);\n\tstruct mm_walk prot_none_walk = {\n\t\t.pte_entry = prot_none_pte_entry,\n\t\t.hugetlb_entry = prot_none_hugetlb_entry,\n\t\t.test_walk = prot_none_test,\n\t\t.mm = current->mm,\n\t\t.private = &new_pgprot,\n\t};\n\n\treturn walk_page_range(start, end, &prot_none_walk);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/personality.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/security.h>",
      "#include <linux/highmem.h>",
      "#include <linux/fs.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "walk_page_range",
          "args": [
            "start",
            "end",
            "&prot_none_walk"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "walk_page_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pagewalk.c",
          "lines": "293-340",
          "snippet": "int walk_page_range(unsigned long start, unsigned long end,\n\t\t    struct mm_walk *walk)\n{\n\tint err = 0;\n\tunsigned long next;\n\tstruct vm_area_struct *vma;\n\n\tif (start >= end)\n\t\treturn -EINVAL;\n\n\tif (!walk->mm)\n\t\treturn -EINVAL;\n\n\tVM_BUG_ON_MM(!rwsem_is_locked(&walk->mm->mmap_sem), walk->mm);\n\n\tvma = find_vma(walk->mm, start);\n\tdo {\n\t\tif (!vma) { /* after the last vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = end;\n\t\t} else if (start < vma->vm_start) { /* outside vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = min(end, vma->vm_start);\n\t\t} else { /* inside vma */\n\t\t\twalk->vma = vma;\n\t\t\tnext = min(end, vma->vm_end);\n\t\t\tvma = vma->vm_next;\n\n\t\t\terr = walk_page_test(start, next, walk);\n\t\t\tif (err > 0) {\n\t\t\t\t/*\n\t\t\t\t * positive return values are purely for\n\t\t\t\t * controlling the pagewalk, so should never\n\t\t\t\t * be passed to the callers.\n\t\t\t\t */\n\t\t\t\terr = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (walk->vma || walk->pte_hole)\n\t\t\terr = __walk_page_range(start, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (start = next, start < end);\n\treturn err;\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nint walk_page_range(unsigned long start, unsigned long end,\n\t\t    struct mm_walk *walk)\n{\n\tint err = 0;\n\tunsigned long next;\n\tstruct vm_area_struct *vma;\n\n\tif (start >= end)\n\t\treturn -EINVAL;\n\n\tif (!walk->mm)\n\t\treturn -EINVAL;\n\n\tVM_BUG_ON_MM(!rwsem_is_locked(&walk->mm->mmap_sem), walk->mm);\n\n\tvma = find_vma(walk->mm, start);\n\tdo {\n\t\tif (!vma) { /* after the last vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = end;\n\t\t} else if (start < vma->vm_start) { /* outside vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = min(end, vma->vm_start);\n\t\t} else { /* inside vma */\n\t\t\twalk->vma = vma;\n\t\t\tnext = min(end, vma->vm_end);\n\t\t\tvma = vma->vm_next;\n\n\t\t\terr = walk_page_test(start, next, walk);\n\t\t\tif (err > 0) {\n\t\t\t\t/*\n\t\t\t\t * positive return values are purely for\n\t\t\t\t * controlling the pagewalk, so should never\n\t\t\t\t * be passed to the callers.\n\t\t\t\t */\n\t\t\t\terr = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (walk->vma || walk->pte_hole)\n\t\t\terr = __walk_page_range(start, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (start = next, start < end);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vm_get_page_prot",
          "args": [
            "newflags"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "vm_get_page_prot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmap.c",
          "lines": "110-117",
          "snippet": "pgprot_t vm_get_page_prot(unsigned long vm_flags)\n{\n\tpgprot_t ret = __pgprot(pgprot_val(protection_map[vm_flags &\n\t\t\t\t(VM_READ|VM_WRITE|VM_EXEC|VM_SHARED)]) |\n\t\t\tpgprot_val(arch_vm_get_page_prot(vm_flags)));\n\n\treturn arch_filter_pgprot(ret);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlb.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/oom.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/printk.h>",
            "#include <linux/memory.h>",
            "#include <linux/notifier.h>",
            "#include <linux/rbtree_augmented.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/audit.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/profile.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/init.h>",
            "#include <linux/capability.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "pgprot_t protection_map[16] __ro_after_init = {\n\t__P000, __P001, __P010, __P011, __P100, __P101, __P110, __P111,\n\t__S000, __S001, __S010, __S011, __S100, __S101, __S110, __S111\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlb.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/oom.h>\n#include <linux/pkeys.h>\n#include <linux/moduleparam.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/printk.h>\n#include <linux/memory.h>\n#include <linux/notifier.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/audit.h>\n#include <linux/perf_event.h>\n#include <linux/mmdebug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/shmem_fs.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\npgprot_t protection_map[16] __ro_after_init = {\n\t__P000, __P001, __P010, __P011, __P100, __P101, __P110, __P111,\n\t__S000, __S001, __S010, __S011, __S100, __S101, __S110, __S111\n};\n\npgprot_t vm_get_page_prot(unsigned long vm_flags)\n{\n\tpgprot_t ret = __pgprot(pgprot_val(protection_map[vm_flags &\n\t\t\t\t(VM_READ|VM_WRITE|VM_EXEC|VM_SHARED)]) |\n\t\t\tpgprot_val(arch_vm_get_page_prot(vm_flags)));\n\n\treturn arch_filter_pgprot(ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <asm/cacheflush.h>\n#include <asm/pgtable.h>\n#include <linux/mm_inline.h>\n#include <linux/uaccess.h>\n#include <linux/ksm.h>\n#include <linux/pkeys.h>\n#include <linux/perf_event.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/personality.h>\n#include <linux/mempolicy.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nstatic int prot_none_walk(struct vm_area_struct *vma, unsigned long start,\n\t\t\t   unsigned long end, unsigned long newflags)\n{\n\tpgprot_t new_pgprot = vm_get_page_prot(newflags);\n\tstruct mm_walk prot_none_walk = {\n\t\t.pte_entry = prot_none_pte_entry,\n\t\t.hugetlb_entry = prot_none_hugetlb_entry,\n\t\t.test_walk = prot_none_test,\n\t\t.mm = current->mm,\n\t\t.private = &new_pgprot,\n\t};\n\n\treturn walk_page_range(start, end, &prot_none_walk);\n}"
  },
  {
    "function_name": "prot_none_test",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mprotect.c",
    "lines": "324-328",
    "snippet": "static int prot_none_test(unsigned long addr, unsigned long next,\n\t\t\t  struct mm_walk *walk)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/personality.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/security.h>",
      "#include <linux/highmem.h>",
      "#include <linux/fs.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <asm/cacheflush.h>\n#include <asm/pgtable.h>\n#include <linux/mm_inline.h>\n#include <linux/uaccess.h>\n#include <linux/ksm.h>\n#include <linux/pkeys.h>\n#include <linux/perf_event.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/personality.h>\n#include <linux/mempolicy.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nstatic int prot_none_test(unsigned long addr, unsigned long next,\n\t\t\t  struct mm_walk *walk)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "prot_none_hugetlb_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mprotect.c",
    "lines": "316-322",
    "snippet": "static int prot_none_hugetlb_entry(pte_t *pte, unsigned long hmask,\n\t\t\t\t   unsigned long addr, unsigned long next,\n\t\t\t\t   struct mm_walk *walk)\n{\n\treturn pfn_modify_allowed(pte_pfn(*pte), *(pgprot_t *)(walk->private)) ?\n\t\t0 : -EACCES;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/personality.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/security.h>",
      "#include <linux/highmem.h>",
      "#include <linux/fs.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfn_modify_allowed",
          "args": [
            "pte_pfn(*pte)",
            "*(pgprot_t *)(walk->private)"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_pfn",
          "args": [
            "*pte"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <asm/cacheflush.h>\n#include <asm/pgtable.h>\n#include <linux/mm_inline.h>\n#include <linux/uaccess.h>\n#include <linux/ksm.h>\n#include <linux/pkeys.h>\n#include <linux/perf_event.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/personality.h>\n#include <linux/mempolicy.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nstatic int prot_none_hugetlb_entry(pte_t *pte, unsigned long hmask,\n\t\t\t\t   unsigned long addr, unsigned long next,\n\t\t\t\t   struct mm_walk *walk)\n{\n\treturn pfn_modify_allowed(pte_pfn(*pte), *(pgprot_t *)(walk->private)) ?\n\t\t0 : -EACCES;\n}"
  },
  {
    "function_name": "prot_none_pte_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mprotect.c",
    "lines": "309-314",
    "snippet": "static int prot_none_pte_entry(pte_t *pte, unsigned long addr,\n\t\t\t       unsigned long next, struct mm_walk *walk)\n{\n\treturn pfn_modify_allowed(pte_pfn(*pte), *(pgprot_t *)(walk->private)) ?\n\t\t0 : -EACCES;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/personality.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/security.h>",
      "#include <linux/highmem.h>",
      "#include <linux/fs.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfn_modify_allowed",
          "args": [
            "pte_pfn(*pte)",
            "*(pgprot_t *)(walk->private)"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_pfn",
          "args": [
            "*pte"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <asm/cacheflush.h>\n#include <asm/pgtable.h>\n#include <linux/mm_inline.h>\n#include <linux/uaccess.h>\n#include <linux/ksm.h>\n#include <linux/pkeys.h>\n#include <linux/perf_event.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/personality.h>\n#include <linux/mempolicy.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nstatic int prot_none_pte_entry(pte_t *pte, unsigned long addr,\n\t\t\t       unsigned long next, struct mm_walk *walk)\n{\n\treturn pfn_modify_allowed(pte_pfn(*pte), *(pgprot_t *)(walk->private)) ?\n\t\t0 : -EACCES;\n}"
  },
  {
    "function_name": "change_protection",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mprotect.c",
    "lines": "295-307",
    "snippet": "unsigned long change_protection(struct vm_area_struct *vma, unsigned long start,\n\t\t       unsigned long end, pgprot_t newprot,\n\t\t       int dirty_accountable, int prot_numa)\n{\n\tunsigned long pages;\n\n\tif (is_vm_hugetlb_page(vma))\n\t\tpages = hugetlb_change_protection(vma, start, end, newprot);\n\telse\n\t\tpages = change_protection_range(vma, start, end, newprot, dirty_accountable, prot_numa);\n\n\treturn pages;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/personality.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/security.h>",
      "#include <linux/highmem.h>",
      "#include <linux/fs.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "change_protection_range",
          "args": [
            "vma",
            "start",
            "end",
            "newprot",
            "dirty_accountable",
            "prot_numa"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "change_protection_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mprotect.c",
          "lines": "265-293",
          "snippet": "static unsigned long change_protection_range(struct vm_area_struct *vma,\n\t\tunsigned long addr, unsigned long end, pgprot_t newprot,\n\t\tint dirty_accountable, int prot_numa)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpgd_t *pgd;\n\tunsigned long next;\n\tunsigned long start = addr;\n\tunsigned long pages = 0;\n\n\tBUG_ON(addr >= end);\n\tpgd = pgd_offset(mm, addr);\n\tflush_cache_range(vma, addr, end);\n\tinc_tlb_flush_pending(mm);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(pgd))\n\t\t\tcontinue;\n\t\tpages += change_p4d_range(vma, pgd, addr, next, newprot,\n\t\t\t\t dirty_accountable, prot_numa);\n\t} while (pgd++, addr = next, addr != end);\n\n\t/* Only flush the TLB if we actually modified any entries: */\n\tif (pages)\n\t\tflush_tlb_range(vma, start, end);\n\tdec_tlb_flush_pending(mm);\n\n\treturn pages;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/personality.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/security.h>",
            "#include <linux/highmem.h>",
            "#include <linux/fs.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <asm/cacheflush.h>\n#include <asm/pgtable.h>\n#include <linux/mm_inline.h>\n#include <linux/uaccess.h>\n#include <linux/ksm.h>\n#include <linux/pkeys.h>\n#include <linux/perf_event.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/personality.h>\n#include <linux/mempolicy.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nstatic unsigned long change_protection_range(struct vm_area_struct *vma,\n\t\tunsigned long addr, unsigned long end, pgprot_t newprot,\n\t\tint dirty_accountable, int prot_numa)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpgd_t *pgd;\n\tunsigned long next;\n\tunsigned long start = addr;\n\tunsigned long pages = 0;\n\n\tBUG_ON(addr >= end);\n\tpgd = pgd_offset(mm, addr);\n\tflush_cache_range(vma, addr, end);\n\tinc_tlb_flush_pending(mm);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(pgd))\n\t\t\tcontinue;\n\t\tpages += change_p4d_range(vma, pgd, addr, next, newprot,\n\t\t\t\t dirty_accountable, prot_numa);\n\t} while (pgd++, addr = next, addr != end);\n\n\t/* Only flush the TLB if we actually modified any entries: */\n\tif (pages)\n\t\tflush_tlb_range(vma, start, end);\n\tdec_tlb_flush_pending(mm);\n\n\treturn pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hugetlb_change_protection",
          "args": [
            "vma",
            "start",
            "end",
            "newprot"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_change_protection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "4333-4420",
          "snippet": "unsigned long hugetlb_change_protection(struct vm_area_struct *vma,\n\t\tunsigned long address, unsigned long end, pgprot_t newprot)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long start = address;\n\tpte_t *ptep;\n\tpte_t pte;\n\tstruct hstate *h = hstate_vma(vma);\n\tunsigned long pages = 0;\n\tunsigned long f_start = start;\n\tunsigned long f_end = end;\n\tbool shared_pmd = false;\n\n\t/*\n\t * In the case of shared PMDs, the area to flush could be beyond\n\t * start/end.  Set f_start/f_end to cover the maximum possible\n\t * range if PMD sharing is possible.\n\t */\n\tadjust_range_if_pmd_sharing_possible(vma, &f_start, &f_end);\n\n\tBUG_ON(address >= end);\n\tflush_cache_range(vma, f_start, f_end);\n\n\tmmu_notifier_invalidate_range_start(mm, f_start, f_end);\n\ti_mmap_lock_write(vma->vm_file->f_mapping);\n\tfor (; address < end; address += huge_page_size(h)) {\n\t\tspinlock_t *ptl;\n\t\tptep = huge_pte_offset(mm, address, huge_page_size(h));\n\t\tif (!ptep)\n\t\t\tcontinue;\n\t\tptl = huge_pte_lock(h, mm, ptep);\n\t\tif (huge_pmd_unshare(mm, &address, ptep)) {\n\t\t\tpages++;\n\t\t\tspin_unlock(ptl);\n\t\t\tshared_pmd = true;\n\t\t\tcontinue;\n\t\t}\n\t\tpte = huge_ptep_get(ptep);\n\t\tif (unlikely(is_hugetlb_entry_hwpoisoned(pte))) {\n\t\t\tspin_unlock(ptl);\n\t\t\tcontinue;\n\t\t}\n\t\tif (unlikely(is_hugetlb_entry_migration(pte))) {\n\t\t\tswp_entry_t entry = pte_to_swp_entry(pte);\n\n\t\t\tif (is_write_migration_entry(entry)) {\n\t\t\t\tpte_t newpte;\n\n\t\t\t\tmake_migration_entry_read(&entry);\n\t\t\t\tnewpte = swp_entry_to_pte(entry);\n\t\t\t\tset_huge_swap_pte_at(mm, address, ptep,\n\t\t\t\t\t\t     newpte, huge_page_size(h));\n\t\t\t\tpages++;\n\t\t\t}\n\t\t\tspin_unlock(ptl);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!huge_pte_none(pte)) {\n\t\t\tpte = huge_ptep_get_and_clear(mm, address, ptep);\n\t\t\tpte = pte_mkhuge(huge_pte_modify(pte, newprot));\n\t\t\tpte = arch_make_huge_pte(pte, vma, NULL, 0);\n\t\t\tset_huge_pte_at(mm, address, ptep, pte);\n\t\t\tpages++;\n\t\t}\n\t\tspin_unlock(ptl);\n\t}\n\t/*\n\t * Must flush TLB before releasing i_mmap_rwsem: x86's huge_pmd_unshare\n\t * may have cleared our pud entry and done put_page on the page table:\n\t * once we release i_mmap_rwsem, another task can do the final put_page\n\t * and that page table be reused and filled with junk.  If we actually\n\t * did unshare a page of pmds, flush the range corresponding to the pud.\n\t */\n\tif (shared_pmd)\n\t\tflush_hugetlb_tlb_range(vma, f_start, f_end);\n\telse\n\t\tflush_hugetlb_tlb_range(vma, start, end);\n\t/*\n\t * No need to call mmu_notifier_invalidate_range() we are downgrading\n\t * page table protection not changing it to point to a new page.\n\t *\n\t * See Documentation/vm/mmu_notifier.rst\n\t */\n\ti_mmap_unlock_write(vma->vm_file->f_mapping);\n\tmmu_notifier_invalidate_range_end(mm, f_start, f_end);\n\n\treturn pages << h->order;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nunsigned long hugetlb_change_protection(struct vm_area_struct *vma,\n\t\tunsigned long address, unsigned long end, pgprot_t newprot)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long start = address;\n\tpte_t *ptep;\n\tpte_t pte;\n\tstruct hstate *h = hstate_vma(vma);\n\tunsigned long pages = 0;\n\tunsigned long f_start = start;\n\tunsigned long f_end = end;\n\tbool shared_pmd = false;\n\n\t/*\n\t * In the case of shared PMDs, the area to flush could be beyond\n\t * start/end.  Set f_start/f_end to cover the maximum possible\n\t * range if PMD sharing is possible.\n\t */\n\tadjust_range_if_pmd_sharing_possible(vma, &f_start, &f_end);\n\n\tBUG_ON(address >= end);\n\tflush_cache_range(vma, f_start, f_end);\n\n\tmmu_notifier_invalidate_range_start(mm, f_start, f_end);\n\ti_mmap_lock_write(vma->vm_file->f_mapping);\n\tfor (; address < end; address += huge_page_size(h)) {\n\t\tspinlock_t *ptl;\n\t\tptep = huge_pte_offset(mm, address, huge_page_size(h));\n\t\tif (!ptep)\n\t\t\tcontinue;\n\t\tptl = huge_pte_lock(h, mm, ptep);\n\t\tif (huge_pmd_unshare(mm, &address, ptep)) {\n\t\t\tpages++;\n\t\t\tspin_unlock(ptl);\n\t\t\tshared_pmd = true;\n\t\t\tcontinue;\n\t\t}\n\t\tpte = huge_ptep_get(ptep);\n\t\tif (unlikely(is_hugetlb_entry_hwpoisoned(pte))) {\n\t\t\tspin_unlock(ptl);\n\t\t\tcontinue;\n\t\t}\n\t\tif (unlikely(is_hugetlb_entry_migration(pte))) {\n\t\t\tswp_entry_t entry = pte_to_swp_entry(pte);\n\n\t\t\tif (is_write_migration_entry(entry)) {\n\t\t\t\tpte_t newpte;\n\n\t\t\t\tmake_migration_entry_read(&entry);\n\t\t\t\tnewpte = swp_entry_to_pte(entry);\n\t\t\t\tset_huge_swap_pte_at(mm, address, ptep,\n\t\t\t\t\t\t     newpte, huge_page_size(h));\n\t\t\t\tpages++;\n\t\t\t}\n\t\t\tspin_unlock(ptl);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!huge_pte_none(pte)) {\n\t\t\tpte = huge_ptep_get_and_clear(mm, address, ptep);\n\t\t\tpte = pte_mkhuge(huge_pte_modify(pte, newprot));\n\t\t\tpte = arch_make_huge_pte(pte, vma, NULL, 0);\n\t\t\tset_huge_pte_at(mm, address, ptep, pte);\n\t\t\tpages++;\n\t\t}\n\t\tspin_unlock(ptl);\n\t}\n\t/*\n\t * Must flush TLB before releasing i_mmap_rwsem: x86's huge_pmd_unshare\n\t * may have cleared our pud entry and done put_page on the page table:\n\t * once we release i_mmap_rwsem, another task can do the final put_page\n\t * and that page table be reused and filled with junk.  If we actually\n\t * did unshare a page of pmds, flush the range corresponding to the pud.\n\t */\n\tif (shared_pmd)\n\t\tflush_hugetlb_tlb_range(vma, f_start, f_end);\n\telse\n\t\tflush_hugetlb_tlb_range(vma, start, end);\n\t/*\n\t * No need to call mmu_notifier_invalidate_range() we are downgrading\n\t * page table protection not changing it to point to a new page.\n\t *\n\t * See Documentation/vm/mmu_notifier.rst\n\t */\n\ti_mmap_unlock_write(vma->vm_file->f_mapping);\n\tmmu_notifier_invalidate_range_end(mm, f_start, f_end);\n\n\treturn pages << h->order;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_vm_hugetlb_page",
          "args": [
            "vma"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <asm/cacheflush.h>\n#include <asm/pgtable.h>\n#include <linux/mm_inline.h>\n#include <linux/uaccess.h>\n#include <linux/ksm.h>\n#include <linux/pkeys.h>\n#include <linux/perf_event.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/personality.h>\n#include <linux/mempolicy.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nunsigned long change_protection(struct vm_area_struct *vma, unsigned long start,\n\t\t       unsigned long end, pgprot_t newprot,\n\t\t       int dirty_accountable, int prot_numa)\n{\n\tunsigned long pages;\n\n\tif (is_vm_hugetlb_page(vma))\n\t\tpages = hugetlb_change_protection(vma, start, end, newprot);\n\telse\n\t\tpages = change_protection_range(vma, start, end, newprot, dirty_accountable, prot_numa);\n\n\treturn pages;\n}"
  },
  {
    "function_name": "change_protection_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mprotect.c",
    "lines": "265-293",
    "snippet": "static unsigned long change_protection_range(struct vm_area_struct *vma,\n\t\tunsigned long addr, unsigned long end, pgprot_t newprot,\n\t\tint dirty_accountable, int prot_numa)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpgd_t *pgd;\n\tunsigned long next;\n\tunsigned long start = addr;\n\tunsigned long pages = 0;\n\n\tBUG_ON(addr >= end);\n\tpgd = pgd_offset(mm, addr);\n\tflush_cache_range(vma, addr, end);\n\tinc_tlb_flush_pending(mm);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(pgd))\n\t\t\tcontinue;\n\t\tpages += change_p4d_range(vma, pgd, addr, next, newprot,\n\t\t\t\t dirty_accountable, prot_numa);\n\t} while (pgd++, addr = next, addr != end);\n\n\t/* Only flush the TLB if we actually modified any entries: */\n\tif (pages)\n\t\tflush_tlb_range(vma, start, end);\n\tdec_tlb_flush_pending(mm);\n\n\treturn pages;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/personality.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/security.h>",
      "#include <linux/highmem.h>",
      "#include <linux/fs.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dec_tlb_flush_pending",
          "args": [
            "mm"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_tlb_range",
          "args": [
            "vma",
            "start",
            "end"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "change_p4d_range",
          "args": [
            "vma",
            "pgd",
            "addr",
            "next",
            "newprot",
            "dirty_accountable",
            "prot_numa"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "change_p4d_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mprotect.c",
          "lines": "245-263",
          "snippet": "static inline unsigned long change_p4d_range(struct vm_area_struct *vma,\n\t\tpgd_t *pgd, unsigned long addr, unsigned long end,\n\t\tpgprot_t newprot, int dirty_accountable, int prot_numa)\n{\n\tp4d_t *p4d;\n\tunsigned long next;\n\tunsigned long pages = 0;\n\n\tp4d = p4d_offset(pgd, addr);\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\tif (p4d_none_or_clear_bad(p4d))\n\t\t\tcontinue;\n\t\tpages += change_pud_range(vma, p4d, addr, next, newprot,\n\t\t\t\t dirty_accountable, prot_numa);\n\t} while (p4d++, addr = next, addr != end);\n\n\treturn pages;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/personality.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/security.h>",
            "#include <linux/highmem.h>",
            "#include <linux/fs.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <asm/cacheflush.h>\n#include <asm/pgtable.h>\n#include <linux/mm_inline.h>\n#include <linux/uaccess.h>\n#include <linux/ksm.h>\n#include <linux/pkeys.h>\n#include <linux/perf_event.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/personality.h>\n#include <linux/mempolicy.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long change_p4d_range(struct vm_area_struct *vma,\n\t\tpgd_t *pgd, unsigned long addr, unsigned long end,\n\t\tpgprot_t newprot, int dirty_accountable, int prot_numa)\n{\n\tp4d_t *p4d;\n\tunsigned long next;\n\tunsigned long pages = 0;\n\n\tp4d = p4d_offset(pgd, addr);\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\tif (p4d_none_or_clear_bad(p4d))\n\t\t\tcontinue;\n\t\tpages += change_pud_range(vma, p4d, addr, next, newprot,\n\t\t\t\t dirty_accountable, prot_numa);\n\t} while (p4d++, addr = next, addr != end);\n\n\treturn pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgd_none_or_clear_bad",
          "args": [
            "pgd"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_tlb_flush_pending",
          "args": [
            "mm"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_cache_range",
          "args": [
            "vma",
            "addr",
            "end"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgd_offset",
          "args": [
            "mm",
            "addr"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "addr >= end"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <asm/cacheflush.h>\n#include <asm/pgtable.h>\n#include <linux/mm_inline.h>\n#include <linux/uaccess.h>\n#include <linux/ksm.h>\n#include <linux/pkeys.h>\n#include <linux/perf_event.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/personality.h>\n#include <linux/mempolicy.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nstatic unsigned long change_protection_range(struct vm_area_struct *vma,\n\t\tunsigned long addr, unsigned long end, pgprot_t newprot,\n\t\tint dirty_accountable, int prot_numa)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpgd_t *pgd;\n\tunsigned long next;\n\tunsigned long start = addr;\n\tunsigned long pages = 0;\n\n\tBUG_ON(addr >= end);\n\tpgd = pgd_offset(mm, addr);\n\tflush_cache_range(vma, addr, end);\n\tinc_tlb_flush_pending(mm);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(pgd))\n\t\t\tcontinue;\n\t\tpages += change_p4d_range(vma, pgd, addr, next, newprot,\n\t\t\t\t dirty_accountable, prot_numa);\n\t} while (pgd++, addr = next, addr != end);\n\n\t/* Only flush the TLB if we actually modified any entries: */\n\tif (pages)\n\t\tflush_tlb_range(vma, start, end);\n\tdec_tlb_flush_pending(mm);\n\n\treturn pages;\n}"
  },
  {
    "function_name": "change_p4d_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mprotect.c",
    "lines": "245-263",
    "snippet": "static inline unsigned long change_p4d_range(struct vm_area_struct *vma,\n\t\tpgd_t *pgd, unsigned long addr, unsigned long end,\n\t\tpgprot_t newprot, int dirty_accountable, int prot_numa)\n{\n\tp4d_t *p4d;\n\tunsigned long next;\n\tunsigned long pages = 0;\n\n\tp4d = p4d_offset(pgd, addr);\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\tif (p4d_none_or_clear_bad(p4d))\n\t\t\tcontinue;\n\t\tpages += change_pud_range(vma, p4d, addr, next, newprot,\n\t\t\t\t dirty_accountable, prot_numa);\n\t} while (p4d++, addr = next, addr != end);\n\n\treturn pages;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/personality.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/security.h>",
      "#include <linux/highmem.h>",
      "#include <linux/fs.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "change_pud_range",
          "args": [
            "vma",
            "p4d",
            "addr",
            "next",
            "newprot",
            "dirty_accountable",
            "prot_numa"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "change_pud_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mprotect.c",
          "lines": "225-243",
          "snippet": "static inline unsigned long change_pud_range(struct vm_area_struct *vma,\n\t\tp4d_t *p4d, unsigned long addr, unsigned long end,\n\t\tpgprot_t newprot, int dirty_accountable, int prot_numa)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\tunsigned long pages = 0;\n\n\tpud = pud_offset(p4d, addr);\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (pud_none_or_clear_bad(pud))\n\t\t\tcontinue;\n\t\tpages += change_pmd_range(vma, pud, addr, next, newprot,\n\t\t\t\t dirty_accountable, prot_numa);\n\t} while (pud++, addr = next, addr != end);\n\n\treturn pages;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/personality.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/security.h>",
            "#include <linux/highmem.h>",
            "#include <linux/fs.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <asm/cacheflush.h>\n#include <asm/pgtable.h>\n#include <linux/mm_inline.h>\n#include <linux/uaccess.h>\n#include <linux/ksm.h>\n#include <linux/pkeys.h>\n#include <linux/perf_event.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/personality.h>\n#include <linux/mempolicy.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long change_pud_range(struct vm_area_struct *vma,\n\t\tp4d_t *p4d, unsigned long addr, unsigned long end,\n\t\tpgprot_t newprot, int dirty_accountable, int prot_numa)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\tunsigned long pages = 0;\n\n\tpud = pud_offset(p4d, addr);\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (pud_none_or_clear_bad(pud))\n\t\t\tcontinue;\n\t\tpages += change_pmd_range(vma, pud, addr, next, newprot,\n\t\t\t\t dirty_accountable, prot_numa);\n\t} while (pud++, addr = next, addr != end);\n\n\treturn pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p4d_none_or_clear_bad",
          "args": [
            "p4d"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p4d_offset",
          "args": [
            "pgd",
            "addr"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <asm/cacheflush.h>\n#include <asm/pgtable.h>\n#include <linux/mm_inline.h>\n#include <linux/uaccess.h>\n#include <linux/ksm.h>\n#include <linux/pkeys.h>\n#include <linux/perf_event.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/personality.h>\n#include <linux/mempolicy.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long change_p4d_range(struct vm_area_struct *vma,\n\t\tpgd_t *pgd, unsigned long addr, unsigned long end,\n\t\tpgprot_t newprot, int dirty_accountable, int prot_numa)\n{\n\tp4d_t *p4d;\n\tunsigned long next;\n\tunsigned long pages = 0;\n\n\tp4d = p4d_offset(pgd, addr);\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\tif (p4d_none_or_clear_bad(p4d))\n\t\t\tcontinue;\n\t\tpages += change_pud_range(vma, p4d, addr, next, newprot,\n\t\t\t\t dirty_accountable, prot_numa);\n\t} while (p4d++, addr = next, addr != end);\n\n\treturn pages;\n}"
  },
  {
    "function_name": "change_pud_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mprotect.c",
    "lines": "225-243",
    "snippet": "static inline unsigned long change_pud_range(struct vm_area_struct *vma,\n\t\tp4d_t *p4d, unsigned long addr, unsigned long end,\n\t\tpgprot_t newprot, int dirty_accountable, int prot_numa)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\tunsigned long pages = 0;\n\n\tpud = pud_offset(p4d, addr);\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (pud_none_or_clear_bad(pud))\n\t\t\tcontinue;\n\t\tpages += change_pmd_range(vma, pud, addr, next, newprot,\n\t\t\t\t dirty_accountable, prot_numa);\n\t} while (pud++, addr = next, addr != end);\n\n\treturn pages;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/personality.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/security.h>",
      "#include <linux/highmem.h>",
      "#include <linux/fs.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "change_pmd_range",
          "args": [
            "vma",
            "pud",
            "addr",
            "next",
            "newprot",
            "dirty_accountable",
            "prot_numa"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "change_pmd_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mprotect.c",
          "lines": "165-223",
          "snippet": "static inline unsigned long change_pmd_range(struct vm_area_struct *vma,\n\t\tpud_t *pud, unsigned long addr, unsigned long end,\n\t\tpgprot_t newprot, int dirty_accountable, int prot_numa)\n{\n\tpmd_t *pmd;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long next;\n\tunsigned long pages = 0;\n\tunsigned long nr_huge_updates = 0;\n\tunsigned long mni_start = 0;\n\n\tpmd = pmd_offset(pud, addr);\n\tdo {\n\t\tunsigned long this_pages;\n\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (!is_swap_pmd(*pmd) && !pmd_trans_huge(*pmd) && !pmd_devmap(*pmd)\n\t\t\t\t&& pmd_none_or_clear_bad(pmd))\n\t\t\tgoto next;\n\n\t\t/* invoke the mmu notifier if the pmd is populated */\n\t\tif (!mni_start) {\n\t\t\tmni_start = addr;\n\t\t\tmmu_notifier_invalidate_range_start(mm, mni_start, end);\n\t\t}\n\n\t\tif (is_swap_pmd(*pmd) || pmd_trans_huge(*pmd) || pmd_devmap(*pmd)) {\n\t\t\tif (next - addr != HPAGE_PMD_SIZE) {\n\t\t\t\t__split_huge_pmd(vma, pmd, addr, false, NULL);\n\t\t\t} else {\n\t\t\t\tint nr_ptes = change_huge_pmd(vma, pmd, addr,\n\t\t\t\t\t\tnewprot, prot_numa);\n\n\t\t\t\tif (nr_ptes) {\n\t\t\t\t\tif (nr_ptes == HPAGE_PMD_NR) {\n\t\t\t\t\t\tpages += HPAGE_PMD_NR;\n\t\t\t\t\t\tnr_huge_updates++;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* huge pmd was handled */\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* fall through, the trans huge pmd just split */\n\t\t}\n\t\tthis_pages = change_pte_range(vma, pmd, addr, next, newprot,\n\t\t\t\t dirty_accountable, prot_numa);\n\t\tpages += this_pages;\nnext:\n\t\tcond_resched();\n\t} while (pmd++, addr = next, addr != end);\n\n\tif (mni_start)\n\t\tmmu_notifier_invalidate_range_end(mm, mni_start, end);\n\n\tif (nr_huge_updates)\n\t\tcount_vm_numa_events(NUMA_HUGE_PTE_UPDATES, nr_huge_updates);\n\treturn pages;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/personality.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/security.h>",
            "#include <linux/highmem.h>",
            "#include <linux/fs.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <asm/cacheflush.h>\n#include <asm/pgtable.h>\n#include <linux/mm_inline.h>\n#include <linux/uaccess.h>\n#include <linux/ksm.h>\n#include <linux/pkeys.h>\n#include <linux/perf_event.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/personality.h>\n#include <linux/mempolicy.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long change_pmd_range(struct vm_area_struct *vma,\n\t\tpud_t *pud, unsigned long addr, unsigned long end,\n\t\tpgprot_t newprot, int dirty_accountable, int prot_numa)\n{\n\tpmd_t *pmd;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long next;\n\tunsigned long pages = 0;\n\tunsigned long nr_huge_updates = 0;\n\tunsigned long mni_start = 0;\n\n\tpmd = pmd_offset(pud, addr);\n\tdo {\n\t\tunsigned long this_pages;\n\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (!is_swap_pmd(*pmd) && !pmd_trans_huge(*pmd) && !pmd_devmap(*pmd)\n\t\t\t\t&& pmd_none_or_clear_bad(pmd))\n\t\t\tgoto next;\n\n\t\t/* invoke the mmu notifier if the pmd is populated */\n\t\tif (!mni_start) {\n\t\t\tmni_start = addr;\n\t\t\tmmu_notifier_invalidate_range_start(mm, mni_start, end);\n\t\t}\n\n\t\tif (is_swap_pmd(*pmd) || pmd_trans_huge(*pmd) || pmd_devmap(*pmd)) {\n\t\t\tif (next - addr != HPAGE_PMD_SIZE) {\n\t\t\t\t__split_huge_pmd(vma, pmd, addr, false, NULL);\n\t\t\t} else {\n\t\t\t\tint nr_ptes = change_huge_pmd(vma, pmd, addr,\n\t\t\t\t\t\tnewprot, prot_numa);\n\n\t\t\t\tif (nr_ptes) {\n\t\t\t\t\tif (nr_ptes == HPAGE_PMD_NR) {\n\t\t\t\t\t\tpages += HPAGE_PMD_NR;\n\t\t\t\t\t\tnr_huge_updates++;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* huge pmd was handled */\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* fall through, the trans huge pmd just split */\n\t\t}\n\t\tthis_pages = change_pte_range(vma, pmd, addr, next, newprot,\n\t\t\t\t dirty_accountable, prot_numa);\n\t\tpages += this_pages;\nnext:\n\t\tcond_resched();\n\t} while (pmd++, addr = next, addr != end);\n\n\tif (mni_start)\n\t\tmmu_notifier_invalidate_range_end(mm, mni_start, end);\n\n\tif (nr_huge_updates)\n\t\tcount_vm_numa_events(NUMA_HUGE_PTE_UPDATES, nr_huge_updates);\n\treturn pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pud_none_or_clear_bad",
          "args": [
            "pud"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pud_offset",
          "args": [
            "p4d",
            "addr"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <asm/cacheflush.h>\n#include <asm/pgtable.h>\n#include <linux/mm_inline.h>\n#include <linux/uaccess.h>\n#include <linux/ksm.h>\n#include <linux/pkeys.h>\n#include <linux/perf_event.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/personality.h>\n#include <linux/mempolicy.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long change_pud_range(struct vm_area_struct *vma,\n\t\tp4d_t *p4d, unsigned long addr, unsigned long end,\n\t\tpgprot_t newprot, int dirty_accountable, int prot_numa)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\tunsigned long pages = 0;\n\n\tpud = pud_offset(p4d, addr);\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (pud_none_or_clear_bad(pud))\n\t\t\tcontinue;\n\t\tpages += change_pmd_range(vma, pud, addr, next, newprot,\n\t\t\t\t dirty_accountable, prot_numa);\n\t} while (pud++, addr = next, addr != end);\n\n\treturn pages;\n}"
  },
  {
    "function_name": "change_pmd_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mprotect.c",
    "lines": "165-223",
    "snippet": "static inline unsigned long change_pmd_range(struct vm_area_struct *vma,\n\t\tpud_t *pud, unsigned long addr, unsigned long end,\n\t\tpgprot_t newprot, int dirty_accountable, int prot_numa)\n{\n\tpmd_t *pmd;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long next;\n\tunsigned long pages = 0;\n\tunsigned long nr_huge_updates = 0;\n\tunsigned long mni_start = 0;\n\n\tpmd = pmd_offset(pud, addr);\n\tdo {\n\t\tunsigned long this_pages;\n\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (!is_swap_pmd(*pmd) && !pmd_trans_huge(*pmd) && !pmd_devmap(*pmd)\n\t\t\t\t&& pmd_none_or_clear_bad(pmd))\n\t\t\tgoto next;\n\n\t\t/* invoke the mmu notifier if the pmd is populated */\n\t\tif (!mni_start) {\n\t\t\tmni_start = addr;\n\t\t\tmmu_notifier_invalidate_range_start(mm, mni_start, end);\n\t\t}\n\n\t\tif (is_swap_pmd(*pmd) || pmd_trans_huge(*pmd) || pmd_devmap(*pmd)) {\n\t\t\tif (next - addr != HPAGE_PMD_SIZE) {\n\t\t\t\t__split_huge_pmd(vma, pmd, addr, false, NULL);\n\t\t\t} else {\n\t\t\t\tint nr_ptes = change_huge_pmd(vma, pmd, addr,\n\t\t\t\t\t\tnewprot, prot_numa);\n\n\t\t\t\tif (nr_ptes) {\n\t\t\t\t\tif (nr_ptes == HPAGE_PMD_NR) {\n\t\t\t\t\t\tpages += HPAGE_PMD_NR;\n\t\t\t\t\t\tnr_huge_updates++;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* huge pmd was handled */\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* fall through, the trans huge pmd just split */\n\t\t}\n\t\tthis_pages = change_pte_range(vma, pmd, addr, next, newprot,\n\t\t\t\t dirty_accountable, prot_numa);\n\t\tpages += this_pages;\nnext:\n\t\tcond_resched();\n\t} while (pmd++, addr = next, addr != end);\n\n\tif (mni_start)\n\t\tmmu_notifier_invalidate_range_end(mm, mni_start, end);\n\n\tif (nr_huge_updates)\n\t\tcount_vm_numa_events(NUMA_HUGE_PTE_UPDATES, nr_huge_updates);\n\treturn pages;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/personality.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/security.h>",
      "#include <linux/highmem.h>",
      "#include <linux/fs.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "count_vm_numa_events",
          "args": [
            "NUMA_HUGE_PTE_UPDATES",
            "nr_huge_updates"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_end",
          "args": [
            "mm",
            "mni_start",
            "end"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "change_pte_range",
          "args": [
            "vma",
            "pmd",
            "addr",
            "next",
            "newprot",
            "dirty_accountable",
            "prot_numa"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "change_pte_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mprotect.c",
          "lines": "38-163",
          "snippet": "static unsigned long change_pte_range(struct vm_area_struct *vma, pmd_t *pmd,\n\t\tunsigned long addr, unsigned long end, pgprot_t newprot,\n\t\tint dirty_accountable, int prot_numa)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpte_t *pte, oldpte;\n\tspinlock_t *ptl;\n\tunsigned long pages = 0;\n\tint target_node = NUMA_NO_NODE;\n\n\t/*\n\t * Can be called with only the mmap_sem for reading by\n\t * prot_numa so we must check the pmd isn't constantly\n\t * changing from under us from pmd_none to pmd_trans_huge\n\t * and/or the other way around.\n\t */\n\tif (pmd_trans_unstable(pmd))\n\t\treturn 0;\n\n\t/*\n\t * The pmd points to a regular pte so the pmd can't change\n\t * from under us even if the mmap_sem is only hold for\n\t * reading.\n\t */\n\tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n\n\t/* Get target node for single threaded private VMAs */\n\tif (prot_numa && !(vma->vm_flags & VM_SHARED) &&\n\t    atomic_read(&vma->vm_mm->mm_users) == 1)\n\t\ttarget_node = numa_node_id();\n\n\tflush_tlb_batched_pending(vma->vm_mm);\n\tarch_enter_lazy_mmu_mode();\n\tdo {\n\t\toldpte = *pte;\n\t\tif (pte_present(oldpte)) {\n\t\t\tpte_t ptent;\n\t\t\tbool preserve_write = prot_numa && pte_write(oldpte);\n\n\t\t\t/*\n\t\t\t * Avoid trapping faults against the zero or KSM\n\t\t\t * pages. See similar comment in change_huge_pmd.\n\t\t\t */\n\t\t\tif (prot_numa) {\n\t\t\t\tstruct page *page;\n\n\t\t\t\tpage = vm_normal_page(vma, addr, oldpte);\n\t\t\t\tif (!page || PageKsm(page))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t/* Also skip shared copy-on-write pages */\n\t\t\t\tif (is_cow_mapping(vma->vm_flags) &&\n\t\t\t\t    page_mapcount(page) != 1)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t/*\n\t\t\t\t * While migration can move some dirty pages,\n\t\t\t\t * it cannot move them all from MIGRATE_ASYNC\n\t\t\t\t * context.\n\t\t\t\t */\n\t\t\t\tif (page_is_file_cache(page) && PageDirty(page))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t/* Avoid TLB flush if possible */\n\t\t\t\tif (pte_protnone(oldpte))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t/*\n\t\t\t\t * Don't mess with PTEs if page is already on the node\n\t\t\t\t * a single-threaded process is running on.\n\t\t\t\t */\n\t\t\t\tif (target_node == page_to_nid(page))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tptent = ptep_modify_prot_start(mm, addr, pte);\n\t\t\tptent = pte_modify(ptent, newprot);\n\t\t\tif (preserve_write)\n\t\t\t\tptent = pte_mk_savedwrite(ptent);\n\n\t\t\t/* Avoid taking write faults for known dirty pages */\n\t\t\tif (dirty_accountable && pte_dirty(ptent) &&\n\t\t\t\t\t(pte_soft_dirty(ptent) ||\n\t\t\t\t\t !(vma->vm_flags & VM_SOFTDIRTY))) {\n\t\t\t\tptent = pte_mkwrite(ptent);\n\t\t\t}\n\t\t\tptep_modify_prot_commit(mm, addr, pte, ptent);\n\t\t\tpages++;\n\t\t} else if (IS_ENABLED(CONFIG_MIGRATION)) {\n\t\t\tswp_entry_t entry = pte_to_swp_entry(oldpte);\n\n\t\t\tif (is_write_migration_entry(entry)) {\n\t\t\t\tpte_t newpte;\n\t\t\t\t/*\n\t\t\t\t * A protection check is difficult so\n\t\t\t\t * just be safe and disable write\n\t\t\t\t */\n\t\t\t\tmake_migration_entry_read(&entry);\n\t\t\t\tnewpte = swp_entry_to_pte(entry);\n\t\t\t\tif (pte_swp_soft_dirty(oldpte))\n\t\t\t\t\tnewpte = pte_swp_mksoft_dirty(newpte);\n\t\t\t\tset_pte_at(mm, addr, pte, newpte);\n\n\t\t\t\tpages++;\n\t\t\t}\n\n\t\t\tif (is_write_device_private_entry(entry)) {\n\t\t\t\tpte_t newpte;\n\n\t\t\t\t/*\n\t\t\t\t * We do not preserve soft-dirtiness. See\n\t\t\t\t * copy_one_pte() for explanation.\n\t\t\t\t */\n\t\t\t\tmake_device_private_entry_read(&entry);\n\t\t\t\tnewpte = swp_entry_to_pte(entry);\n\t\t\t\tset_pte_at(mm, addr, pte, newpte);\n\n\t\t\t\tpages++;\n\t\t\t}\n\t\t}\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n\tarch_leave_lazy_mmu_mode();\n\tpte_unmap_unlock(pte - 1, ptl);\n\n\treturn pages;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pkeys.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/personality.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/security.h>",
            "#include <linux/highmem.h>",
            "#include <linux/fs.h>",
            "#include <linux/mman.h>",
            "#include <linux/shm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <asm/cacheflush.h>\n#include <asm/pgtable.h>\n#include <linux/mm_inline.h>\n#include <linux/uaccess.h>\n#include <linux/ksm.h>\n#include <linux/pkeys.h>\n#include <linux/perf_event.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/personality.h>\n#include <linux/mempolicy.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nstatic unsigned long change_pte_range(struct vm_area_struct *vma, pmd_t *pmd,\n\t\tunsigned long addr, unsigned long end, pgprot_t newprot,\n\t\tint dirty_accountable, int prot_numa)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpte_t *pte, oldpte;\n\tspinlock_t *ptl;\n\tunsigned long pages = 0;\n\tint target_node = NUMA_NO_NODE;\n\n\t/*\n\t * Can be called with only the mmap_sem for reading by\n\t * prot_numa so we must check the pmd isn't constantly\n\t * changing from under us from pmd_none to pmd_trans_huge\n\t * and/or the other way around.\n\t */\n\tif (pmd_trans_unstable(pmd))\n\t\treturn 0;\n\n\t/*\n\t * The pmd points to a regular pte so the pmd can't change\n\t * from under us even if the mmap_sem is only hold for\n\t * reading.\n\t */\n\tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n\n\t/* Get target node for single threaded private VMAs */\n\tif (prot_numa && !(vma->vm_flags & VM_SHARED) &&\n\t    atomic_read(&vma->vm_mm->mm_users) == 1)\n\t\ttarget_node = numa_node_id();\n\n\tflush_tlb_batched_pending(vma->vm_mm);\n\tarch_enter_lazy_mmu_mode();\n\tdo {\n\t\toldpte = *pte;\n\t\tif (pte_present(oldpte)) {\n\t\t\tpte_t ptent;\n\t\t\tbool preserve_write = prot_numa && pte_write(oldpte);\n\n\t\t\t/*\n\t\t\t * Avoid trapping faults against the zero or KSM\n\t\t\t * pages. See similar comment in change_huge_pmd.\n\t\t\t */\n\t\t\tif (prot_numa) {\n\t\t\t\tstruct page *page;\n\n\t\t\t\tpage = vm_normal_page(vma, addr, oldpte);\n\t\t\t\tif (!page || PageKsm(page))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t/* Also skip shared copy-on-write pages */\n\t\t\t\tif (is_cow_mapping(vma->vm_flags) &&\n\t\t\t\t    page_mapcount(page) != 1)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t/*\n\t\t\t\t * While migration can move some dirty pages,\n\t\t\t\t * it cannot move them all from MIGRATE_ASYNC\n\t\t\t\t * context.\n\t\t\t\t */\n\t\t\t\tif (page_is_file_cache(page) && PageDirty(page))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t/* Avoid TLB flush if possible */\n\t\t\t\tif (pte_protnone(oldpte))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t/*\n\t\t\t\t * Don't mess with PTEs if page is already on the node\n\t\t\t\t * a single-threaded process is running on.\n\t\t\t\t */\n\t\t\t\tif (target_node == page_to_nid(page))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tptent = ptep_modify_prot_start(mm, addr, pte);\n\t\t\tptent = pte_modify(ptent, newprot);\n\t\t\tif (preserve_write)\n\t\t\t\tptent = pte_mk_savedwrite(ptent);\n\n\t\t\t/* Avoid taking write faults for known dirty pages */\n\t\t\tif (dirty_accountable && pte_dirty(ptent) &&\n\t\t\t\t\t(pte_soft_dirty(ptent) ||\n\t\t\t\t\t !(vma->vm_flags & VM_SOFTDIRTY))) {\n\t\t\t\tptent = pte_mkwrite(ptent);\n\t\t\t}\n\t\t\tptep_modify_prot_commit(mm, addr, pte, ptent);\n\t\t\tpages++;\n\t\t} else if (IS_ENABLED(CONFIG_MIGRATION)) {\n\t\t\tswp_entry_t entry = pte_to_swp_entry(oldpte);\n\n\t\t\tif (is_write_migration_entry(entry)) {\n\t\t\t\tpte_t newpte;\n\t\t\t\t/*\n\t\t\t\t * A protection check is difficult so\n\t\t\t\t * just be safe and disable write\n\t\t\t\t */\n\t\t\t\tmake_migration_entry_read(&entry);\n\t\t\t\tnewpte = swp_entry_to_pte(entry);\n\t\t\t\tif (pte_swp_soft_dirty(oldpte))\n\t\t\t\t\tnewpte = pte_swp_mksoft_dirty(newpte);\n\t\t\t\tset_pte_at(mm, addr, pte, newpte);\n\n\t\t\t\tpages++;\n\t\t\t}\n\n\t\t\tif (is_write_device_private_entry(entry)) {\n\t\t\t\tpte_t newpte;\n\n\t\t\t\t/*\n\t\t\t\t * We do not preserve soft-dirtiness. See\n\t\t\t\t * copy_one_pte() for explanation.\n\t\t\t\t */\n\t\t\t\tmake_device_private_entry_read(&entry);\n\t\t\t\tnewpte = swp_entry_to_pte(entry);\n\t\t\t\tset_pte_at(mm, addr, pte, newpte);\n\n\t\t\t\tpages++;\n\t\t\t}\n\t\t}\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n\tarch_leave_lazy_mmu_mode();\n\tpte_unmap_unlock(pte - 1, ptl);\n\n\treturn pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "change_huge_pmd",
          "args": [
            "vma",
            "pmd",
            "addr",
            "newprot",
            "prot_numa"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "change_huge_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "1869-1949",
          "snippet": "int change_huge_pmd(struct vm_area_struct *vma, pmd_t *pmd,\n\t\tunsigned long addr, pgprot_t newprot, int prot_numa)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tspinlock_t *ptl;\n\tpmd_t entry;\n\tbool preserve_write;\n\tint ret;\n\n\tptl = __pmd_trans_huge_lock(pmd, vma);\n\tif (!ptl)\n\t\treturn 0;\n\n\tpreserve_write = prot_numa && pmd_write(*pmd);\n\tret = 1;\n\n#ifdef CONFIG_ARCH_ENABLE_THP_MIGRATION\n\tif (is_swap_pmd(*pmd)) {\n\t\tswp_entry_t entry = pmd_to_swp_entry(*pmd);\n\n\t\tVM_BUG_ON(!is_pmd_migration_entry(*pmd));\n\t\tif (is_write_migration_entry(entry)) {\n\t\t\tpmd_t newpmd;\n\t\t\t/*\n\t\t\t * A protection check is difficult so\n\t\t\t * just be safe and disable write\n\t\t\t */\n\t\t\tmake_migration_entry_read(&entry);\n\t\t\tnewpmd = swp_entry_to_pmd(entry);\n\t\t\tif (pmd_swp_soft_dirty(*pmd))\n\t\t\t\tnewpmd = pmd_swp_mksoft_dirty(newpmd);\n\t\t\tset_pmd_at(mm, addr, pmd, newpmd);\n\t\t}\n\t\tgoto unlock;\n\t}\n#endif\n\n\t/*\n\t * Avoid trapping faults against the zero page. The read-only\n\t * data is likely to be read-cached on the local CPU and\n\t * local/remote hits to the zero page are not interesting.\n\t */\n\tif (prot_numa && is_huge_zero_pmd(*pmd))\n\t\tgoto unlock;\n\n\tif (prot_numa && pmd_protnone(*pmd))\n\t\tgoto unlock;\n\n\t/*\n\t * In case prot_numa, we are under down_read(mmap_sem). It's critical\n\t * to not clear pmd intermittently to avoid race with MADV_DONTNEED\n\t * which is also under down_read(mmap_sem):\n\t *\n\t *\tCPU0:\t\t\t\tCPU1:\n\t *\t\t\t\tchange_huge_pmd(prot_numa=1)\n\t *\t\t\t\t pmdp_huge_get_and_clear_notify()\n\t * madvise_dontneed()\n\t *  zap_pmd_range()\n\t *   pmd_trans_huge(*pmd) == 0 (without ptl)\n\t *   // skip the pmd\n\t *\t\t\t\t set_pmd_at();\n\t *\t\t\t\t // pmd is re-established\n\t *\n\t * The race makes MADV_DONTNEED miss the huge pmd and don't clear it\n\t * which may break userspace.\n\t *\n\t * pmdp_invalidate() is required to make sure we don't miss\n\t * dirty/young flags set by hardware.\n\t */\n\tentry = pmdp_invalidate(vma, addr, pmd);\n\n\tentry = pmd_modify(entry, newprot);\n\tif (preserve_write)\n\t\tentry = pmd_mk_savedwrite(entry);\n\tret = HPAGE_PMD_NR;\n\tset_pmd_at(mm, addr, pmd, entry);\n\tBUG_ON(vma_is_anonymous(vma) && !preserve_write && pmd_write(entry));\nunlock:\n\tspin_unlock(ptl);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nint change_huge_pmd(struct vm_area_struct *vma, pmd_t *pmd,\n\t\tunsigned long addr, pgprot_t newprot, int prot_numa)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tspinlock_t *ptl;\n\tpmd_t entry;\n\tbool preserve_write;\n\tint ret;\n\n\tptl = __pmd_trans_huge_lock(pmd, vma);\n\tif (!ptl)\n\t\treturn 0;\n\n\tpreserve_write = prot_numa && pmd_write(*pmd);\n\tret = 1;\n\n#ifdef CONFIG_ARCH_ENABLE_THP_MIGRATION\n\tif (is_swap_pmd(*pmd)) {\n\t\tswp_entry_t entry = pmd_to_swp_entry(*pmd);\n\n\t\tVM_BUG_ON(!is_pmd_migration_entry(*pmd));\n\t\tif (is_write_migration_entry(entry)) {\n\t\t\tpmd_t newpmd;\n\t\t\t/*\n\t\t\t * A protection check is difficult so\n\t\t\t * just be safe and disable write\n\t\t\t */\n\t\t\tmake_migration_entry_read(&entry);\n\t\t\tnewpmd = swp_entry_to_pmd(entry);\n\t\t\tif (pmd_swp_soft_dirty(*pmd))\n\t\t\t\tnewpmd = pmd_swp_mksoft_dirty(newpmd);\n\t\t\tset_pmd_at(mm, addr, pmd, newpmd);\n\t\t}\n\t\tgoto unlock;\n\t}\n#endif\n\n\t/*\n\t * Avoid trapping faults against the zero page. The read-only\n\t * data is likely to be read-cached on the local CPU and\n\t * local/remote hits to the zero page are not interesting.\n\t */\n\tif (prot_numa && is_huge_zero_pmd(*pmd))\n\t\tgoto unlock;\n\n\tif (prot_numa && pmd_protnone(*pmd))\n\t\tgoto unlock;\n\n\t/*\n\t * In case prot_numa, we are under down_read(mmap_sem). It's critical\n\t * to not clear pmd intermittently to avoid race with MADV_DONTNEED\n\t * which is also under down_read(mmap_sem):\n\t *\n\t *\tCPU0:\t\t\t\tCPU1:\n\t *\t\t\t\tchange_huge_pmd(prot_numa=1)\n\t *\t\t\t\t pmdp_huge_get_and_clear_notify()\n\t * madvise_dontneed()\n\t *  zap_pmd_range()\n\t *   pmd_trans_huge(*pmd) == 0 (without ptl)\n\t *   // skip the pmd\n\t *\t\t\t\t set_pmd_at();\n\t *\t\t\t\t // pmd is re-established\n\t *\n\t * The race makes MADV_DONTNEED miss the huge pmd and don't clear it\n\t * which may break userspace.\n\t *\n\t * pmdp_invalidate() is required to make sure we don't miss\n\t * dirty/young flags set by hardware.\n\t */\n\tentry = pmdp_invalidate(vma, addr, pmd);\n\n\tentry = pmd_modify(entry, newprot);\n\tif (preserve_write)\n\t\tentry = pmd_mk_savedwrite(entry);\n\tret = HPAGE_PMD_NR;\n\tset_pmd_at(mm, addr, pmd, entry);\n\tBUG_ON(vma_is_anonymous(vma) && !preserve_write && pmd_write(entry));\nunlock:\n\tspin_unlock(ptl);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__split_huge_pmd",
          "args": [
            "vma",
            "pmd",
            "addr",
            "false",
            "NULL"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "__split_huge_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "2243-2285",
          "snippet": "void __split_huge_pmd(struct vm_area_struct *vma, pmd_t *pmd,\n\t\tunsigned long address, bool freeze, struct page *page)\n{\n\tspinlock_t *ptl;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long haddr = address & HPAGE_PMD_MASK;\n\n\tmmu_notifier_invalidate_range_start(mm, haddr, haddr + HPAGE_PMD_SIZE);\n\tptl = pmd_lock(mm, pmd);\n\n\t/*\n\t * If caller asks to setup a migration entries, we need a page to check\n\t * pmd against. Otherwise we can end up replacing wrong page.\n\t */\n\tVM_BUG_ON(freeze && !page);\n\tif (page && page != pmd_page(*pmd))\n\t        goto out;\n\n\tif (pmd_trans_huge(*pmd)) {\n\t\tpage = pmd_page(*pmd);\n\t\tif (PageMlocked(page))\n\t\t\tclear_page_mlock(page);\n\t} else if (!(pmd_devmap(*pmd) || is_pmd_migration_entry(*pmd)))\n\t\tgoto out;\n\t__split_huge_pmd_locked(vma, pmd, haddr, freeze);\nout:\n\tspin_unlock(ptl);\n\t/*\n\t * No need to double call mmu_notifier->invalidate_range() callback.\n\t * They are 3 cases to consider inside __split_huge_pmd_locked():\n\t *  1) pmdp_huge_clear_flush_notify() call invalidate_range() obvious\n\t *  2) __split_huge_zero_page_pmd() read only zero page and any write\n\t *    fault will trigger a flush_notify before pointing to a new page\n\t *    (it is fine if the secondary mmu keeps pointing to the old zero\n\t *    page in the meantime)\n\t *  3) Split a huge pmd into pte pointing to the same page. No need\n\t *     to invalidate secondary tlb entry they are all still valid.\n\t *     any further changes to individual pte will notify. So no need\n\t *     to call mmu_notifier->invalidate_range()\n\t */\n\tmmu_notifier_invalidate_range_only_end(mm, haddr, haddr +\n\t\t\t\t\t       HPAGE_PMD_SIZE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid __split_huge_pmd(struct vm_area_struct *vma, pmd_t *pmd,\n\t\tunsigned long address, bool freeze, struct page *page)\n{\n\tspinlock_t *ptl;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long haddr = address & HPAGE_PMD_MASK;\n\n\tmmu_notifier_invalidate_range_start(mm, haddr, haddr + HPAGE_PMD_SIZE);\n\tptl = pmd_lock(mm, pmd);\n\n\t/*\n\t * If caller asks to setup a migration entries, we need a page to check\n\t * pmd against. Otherwise we can end up replacing wrong page.\n\t */\n\tVM_BUG_ON(freeze && !page);\n\tif (page && page != pmd_page(*pmd))\n\t        goto out;\n\n\tif (pmd_trans_huge(*pmd)) {\n\t\tpage = pmd_page(*pmd);\n\t\tif (PageMlocked(page))\n\t\t\tclear_page_mlock(page);\n\t} else if (!(pmd_devmap(*pmd) || is_pmd_migration_entry(*pmd)))\n\t\tgoto out;\n\t__split_huge_pmd_locked(vma, pmd, haddr, freeze);\nout:\n\tspin_unlock(ptl);\n\t/*\n\t * No need to double call mmu_notifier->invalidate_range() callback.\n\t * They are 3 cases to consider inside __split_huge_pmd_locked():\n\t *  1) pmdp_huge_clear_flush_notify() call invalidate_range() obvious\n\t *  2) __split_huge_zero_page_pmd() read only zero page and any write\n\t *    fault will trigger a flush_notify before pointing to a new page\n\t *    (it is fine if the secondary mmu keeps pointing to the old zero\n\t *    page in the meantime)\n\t *  3) Split a huge pmd into pte pointing to the same page. No need\n\t *     to invalidate secondary tlb entry they are all still valid.\n\t *     any further changes to individual pte will notify. So no need\n\t *     to call mmu_notifier->invalidate_range()\n\t */\n\tmmu_notifier_invalidate_range_only_end(mm, haddr, haddr +\n\t\t\t\t\t       HPAGE_PMD_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_devmap",
          "args": [
            "*pmd"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "pmd_devmap_trans_unstable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3023-3026",
          "snippet": "static int pmd_devmap_trans_unstable(pmd_t *pmd)\n{\n\treturn pmd_devmap(*pmd) || pmd_trans_unstable(pmd);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic int pmd_devmap_trans_unstable(pmd_t *pmd)\n{\n\treturn pmd_devmap(*pmd) || pmd_trans_unstable(pmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_trans_huge",
          "args": [
            "*pmd"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_swap_pmd",
          "args": [
            "*pmd"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_start",
          "args": [
            "mm",
            "mni_start",
            "end"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_none_or_clear_bad",
          "args": [
            "pmd"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_huge",
          "args": [
            "*pmd"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_swap_pmd",
          "args": [
            "*pmd"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_addr_end",
          "args": [
            "addr",
            "end"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_offset",
          "args": [
            "pud",
            "addr"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <asm/cacheflush.h>\n#include <asm/pgtable.h>\n#include <linux/mm_inline.h>\n#include <linux/uaccess.h>\n#include <linux/ksm.h>\n#include <linux/pkeys.h>\n#include <linux/perf_event.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/personality.h>\n#include <linux/mempolicy.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long change_pmd_range(struct vm_area_struct *vma,\n\t\tpud_t *pud, unsigned long addr, unsigned long end,\n\t\tpgprot_t newprot, int dirty_accountable, int prot_numa)\n{\n\tpmd_t *pmd;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long next;\n\tunsigned long pages = 0;\n\tunsigned long nr_huge_updates = 0;\n\tunsigned long mni_start = 0;\n\n\tpmd = pmd_offset(pud, addr);\n\tdo {\n\t\tunsigned long this_pages;\n\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (!is_swap_pmd(*pmd) && !pmd_trans_huge(*pmd) && !pmd_devmap(*pmd)\n\t\t\t\t&& pmd_none_or_clear_bad(pmd))\n\t\t\tgoto next;\n\n\t\t/* invoke the mmu notifier if the pmd is populated */\n\t\tif (!mni_start) {\n\t\t\tmni_start = addr;\n\t\t\tmmu_notifier_invalidate_range_start(mm, mni_start, end);\n\t\t}\n\n\t\tif (is_swap_pmd(*pmd) || pmd_trans_huge(*pmd) || pmd_devmap(*pmd)) {\n\t\t\tif (next - addr != HPAGE_PMD_SIZE) {\n\t\t\t\t__split_huge_pmd(vma, pmd, addr, false, NULL);\n\t\t\t} else {\n\t\t\t\tint nr_ptes = change_huge_pmd(vma, pmd, addr,\n\t\t\t\t\t\tnewprot, prot_numa);\n\n\t\t\t\tif (nr_ptes) {\n\t\t\t\t\tif (nr_ptes == HPAGE_PMD_NR) {\n\t\t\t\t\t\tpages += HPAGE_PMD_NR;\n\t\t\t\t\t\tnr_huge_updates++;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* huge pmd was handled */\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* fall through, the trans huge pmd just split */\n\t\t}\n\t\tthis_pages = change_pte_range(vma, pmd, addr, next, newprot,\n\t\t\t\t dirty_accountable, prot_numa);\n\t\tpages += this_pages;\nnext:\n\t\tcond_resched();\n\t} while (pmd++, addr = next, addr != end);\n\n\tif (mni_start)\n\t\tmmu_notifier_invalidate_range_end(mm, mni_start, end);\n\n\tif (nr_huge_updates)\n\t\tcount_vm_numa_events(NUMA_HUGE_PTE_UPDATES, nr_huge_updates);\n\treturn pages;\n}"
  },
  {
    "function_name": "change_pte_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mprotect.c",
    "lines": "38-163",
    "snippet": "static unsigned long change_pte_range(struct vm_area_struct *vma, pmd_t *pmd,\n\t\tunsigned long addr, unsigned long end, pgprot_t newprot,\n\t\tint dirty_accountable, int prot_numa)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpte_t *pte, oldpte;\n\tspinlock_t *ptl;\n\tunsigned long pages = 0;\n\tint target_node = NUMA_NO_NODE;\n\n\t/*\n\t * Can be called with only the mmap_sem for reading by\n\t * prot_numa so we must check the pmd isn't constantly\n\t * changing from under us from pmd_none to pmd_trans_huge\n\t * and/or the other way around.\n\t */\n\tif (pmd_trans_unstable(pmd))\n\t\treturn 0;\n\n\t/*\n\t * The pmd points to a regular pte so the pmd can't change\n\t * from under us even if the mmap_sem is only hold for\n\t * reading.\n\t */\n\tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n\n\t/* Get target node for single threaded private VMAs */\n\tif (prot_numa && !(vma->vm_flags & VM_SHARED) &&\n\t    atomic_read(&vma->vm_mm->mm_users) == 1)\n\t\ttarget_node = numa_node_id();\n\n\tflush_tlb_batched_pending(vma->vm_mm);\n\tarch_enter_lazy_mmu_mode();\n\tdo {\n\t\toldpte = *pte;\n\t\tif (pte_present(oldpte)) {\n\t\t\tpte_t ptent;\n\t\t\tbool preserve_write = prot_numa && pte_write(oldpte);\n\n\t\t\t/*\n\t\t\t * Avoid trapping faults against the zero or KSM\n\t\t\t * pages. See similar comment in change_huge_pmd.\n\t\t\t */\n\t\t\tif (prot_numa) {\n\t\t\t\tstruct page *page;\n\n\t\t\t\tpage = vm_normal_page(vma, addr, oldpte);\n\t\t\t\tif (!page || PageKsm(page))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t/* Also skip shared copy-on-write pages */\n\t\t\t\tif (is_cow_mapping(vma->vm_flags) &&\n\t\t\t\t    page_mapcount(page) != 1)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t/*\n\t\t\t\t * While migration can move some dirty pages,\n\t\t\t\t * it cannot move them all from MIGRATE_ASYNC\n\t\t\t\t * context.\n\t\t\t\t */\n\t\t\t\tif (page_is_file_cache(page) && PageDirty(page))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t/* Avoid TLB flush if possible */\n\t\t\t\tif (pte_protnone(oldpte))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t/*\n\t\t\t\t * Don't mess with PTEs if page is already on the node\n\t\t\t\t * a single-threaded process is running on.\n\t\t\t\t */\n\t\t\t\tif (target_node == page_to_nid(page))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tptent = ptep_modify_prot_start(mm, addr, pte);\n\t\t\tptent = pte_modify(ptent, newprot);\n\t\t\tif (preserve_write)\n\t\t\t\tptent = pte_mk_savedwrite(ptent);\n\n\t\t\t/* Avoid taking write faults for known dirty pages */\n\t\t\tif (dirty_accountable && pte_dirty(ptent) &&\n\t\t\t\t\t(pte_soft_dirty(ptent) ||\n\t\t\t\t\t !(vma->vm_flags & VM_SOFTDIRTY))) {\n\t\t\t\tptent = pte_mkwrite(ptent);\n\t\t\t}\n\t\t\tptep_modify_prot_commit(mm, addr, pte, ptent);\n\t\t\tpages++;\n\t\t} else if (IS_ENABLED(CONFIG_MIGRATION)) {\n\t\t\tswp_entry_t entry = pte_to_swp_entry(oldpte);\n\n\t\t\tif (is_write_migration_entry(entry)) {\n\t\t\t\tpte_t newpte;\n\t\t\t\t/*\n\t\t\t\t * A protection check is difficult so\n\t\t\t\t * just be safe and disable write\n\t\t\t\t */\n\t\t\t\tmake_migration_entry_read(&entry);\n\t\t\t\tnewpte = swp_entry_to_pte(entry);\n\t\t\t\tif (pte_swp_soft_dirty(oldpte))\n\t\t\t\t\tnewpte = pte_swp_mksoft_dirty(newpte);\n\t\t\t\tset_pte_at(mm, addr, pte, newpte);\n\n\t\t\t\tpages++;\n\t\t\t}\n\n\t\t\tif (is_write_device_private_entry(entry)) {\n\t\t\t\tpte_t newpte;\n\n\t\t\t\t/*\n\t\t\t\t * We do not preserve soft-dirtiness. See\n\t\t\t\t * copy_one_pte() for explanation.\n\t\t\t\t */\n\t\t\t\tmake_device_private_entry_read(&entry);\n\t\t\t\tnewpte = swp_entry_to_pte(entry);\n\t\t\t\tset_pte_at(mm, addr, pte, newpte);\n\n\t\t\t\tpages++;\n\t\t\t}\n\t\t}\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n\tarch_leave_lazy_mmu_mode();\n\tpte_unmap_unlock(pte - 1, ptl);\n\n\treturn pages;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/personality.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/security.h>",
      "#include <linux/highmem.h>",
      "#include <linux/fs.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "pte - 1",
            "ptl"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_leave_lazy_mmu_mode",
          "args": [],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pte_at",
          "args": [
            "mm",
            "addr",
            "pte",
            "newpte"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_entry_to_pte",
          "args": [
            "entry"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_device_private_entry_read",
          "args": [
            "&entry"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_write_device_private_entry",
          "args": [
            "entry"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pte_at",
          "args": [
            "mm",
            "addr",
            "pte",
            "newpte"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_swp_mksoft_dirty",
          "args": [
            "newpte"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_swp_soft_dirty",
          "args": [
            "oldpte"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_entry_to_pte",
          "args": [
            "entry"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_migration_entry_read",
          "args": [
            "&entry"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_write_migration_entry",
          "args": [
            "entry"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_to_swp_entry",
          "args": [
            "oldpte"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_MIGRATION"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptep_modify_prot_commit",
          "args": [
            "mm",
            "addr",
            "pte",
            "ptent"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mkwrite",
          "args": [
            "ptent"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_soft_dirty",
          "args": [
            "ptent"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_dirty",
          "args": [
            "ptent"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_mk_savedwrite",
          "args": [
            "ptent"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_modify",
          "args": [
            "ptent",
            "newprot"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptep_modify_prot_start",
          "args": [
            "mm",
            "addr",
            "pte"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_protnone",
          "args": [
            "oldpte"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_is_file_cache",
          "args": [
            "page"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapcount",
          "args": [
            "page"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_cow_mapping",
          "args": [
            "vma->vm_flags"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "is_cow_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "247-250",
          "snippet": "static inline bool is_cow_mapping(vm_flags_t flags)\n{\n\treturn (flags & (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE;\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline bool is_cow_mapping(vm_flags_t flags)\n{\n\treturn (flags & (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageKsm",
          "args": [
            "page"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_normal_page",
          "args": [
            "vma",
            "addr",
            "oldpte"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "vm_normal_page_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "651-689",
          "snippet": "struct page *vm_normal_page_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tpmd_t pmd)\n{\n\tunsigned long pfn = pmd_pfn(pmd);\n\n\t/*\n\t * There is no pmd_special() but there may be special pmds, e.g.\n\t * in a direct-access (dax) mapping, so let's just replicate the\n\t * !CONFIG_ARCH_HAS_PTE_SPECIAL case from vm_normal_page() here.\n\t */\n\tif (unlikely(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP))) {\n\t\tif (vma->vm_flags & VM_MIXEDMAP) {\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\treturn NULL;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tunsigned long off;\n\t\t\toff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\t\tif (pfn == vma->vm_pgoff + off)\n\t\t\t\treturn NULL;\n\t\t\tif (!is_cow_mapping(vma->vm_flags))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (pmd_devmap(pmd))\n\t\treturn NULL;\n\tif (is_zero_pfn(pfn))\n\t\treturn NULL;\n\tif (unlikely(pfn > highest_memmap_pfn))\n\t\treturn NULL;\n\n\t/*\n\t * NOTE! We still have PageReserved() pages in the page tables.\n\t * eg. VDSO mappings can cause them to exist.\n\t */\nout:\n\treturn pfn_to_page(pfn);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstruct page *vm_normal_page_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tpmd_t pmd)\n{\n\tunsigned long pfn = pmd_pfn(pmd);\n\n\t/*\n\t * There is no pmd_special() but there may be special pmds, e.g.\n\t * in a direct-access (dax) mapping, so let's just replicate the\n\t * !CONFIG_ARCH_HAS_PTE_SPECIAL case from vm_normal_page() here.\n\t */\n\tif (unlikely(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP))) {\n\t\tif (vma->vm_flags & VM_MIXEDMAP) {\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\treturn NULL;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tunsigned long off;\n\t\t\toff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\t\tif (pfn == vma->vm_pgoff + off)\n\t\t\t\treturn NULL;\n\t\t\tif (!is_cow_mapping(vma->vm_flags))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (pmd_devmap(pmd))\n\t\treturn NULL;\n\tif (is_zero_pfn(pfn))\n\t\treturn NULL;\n\tif (unlikely(pfn > highest_memmap_pfn))\n\t\treturn NULL;\n\n\t/*\n\t * NOTE! We still have PageReserved() pages in the page tables.\n\t * eg. VDSO mappings can cause them to exist.\n\t */\nout:\n\treturn pfn_to_page(pfn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_write",
          "args": [
            "oldpte"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "oldpte"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_enter_lazy_mmu_mode",
          "args": [],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_tlb_batched_pending",
          "args": [
            "vma->vm_mm"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "flush_tlb_batched_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "509-511",
          "snippet": "static inline void flush_tlb_batched_pending(struct mm_struct *mm)\n{\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void flush_tlb_batched_pending(struct mm_struct *mm)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "numa_node_id",
          "args": [],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&vma->vm_mm->mm_users"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_offset_map_lock",
          "args": [
            "vma->vm_mm",
            "pmd",
            "addr",
            "&ptl"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_unstable",
          "args": [
            "pmd"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <asm/cacheflush.h>\n#include <asm/pgtable.h>\n#include <linux/mm_inline.h>\n#include <linux/uaccess.h>\n#include <linux/ksm.h>\n#include <linux/pkeys.h>\n#include <linux/perf_event.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/personality.h>\n#include <linux/mempolicy.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nstatic unsigned long change_pte_range(struct vm_area_struct *vma, pmd_t *pmd,\n\t\tunsigned long addr, unsigned long end, pgprot_t newprot,\n\t\tint dirty_accountable, int prot_numa)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpte_t *pte, oldpte;\n\tspinlock_t *ptl;\n\tunsigned long pages = 0;\n\tint target_node = NUMA_NO_NODE;\n\n\t/*\n\t * Can be called with only the mmap_sem for reading by\n\t * prot_numa so we must check the pmd isn't constantly\n\t * changing from under us from pmd_none to pmd_trans_huge\n\t * and/or the other way around.\n\t */\n\tif (pmd_trans_unstable(pmd))\n\t\treturn 0;\n\n\t/*\n\t * The pmd points to a regular pte so the pmd can't change\n\t * from under us even if the mmap_sem is only hold for\n\t * reading.\n\t */\n\tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n\n\t/* Get target node for single threaded private VMAs */\n\tif (prot_numa && !(vma->vm_flags & VM_SHARED) &&\n\t    atomic_read(&vma->vm_mm->mm_users) == 1)\n\t\ttarget_node = numa_node_id();\n\n\tflush_tlb_batched_pending(vma->vm_mm);\n\tarch_enter_lazy_mmu_mode();\n\tdo {\n\t\toldpte = *pte;\n\t\tif (pte_present(oldpte)) {\n\t\t\tpte_t ptent;\n\t\t\tbool preserve_write = prot_numa && pte_write(oldpte);\n\n\t\t\t/*\n\t\t\t * Avoid trapping faults against the zero or KSM\n\t\t\t * pages. See similar comment in change_huge_pmd.\n\t\t\t */\n\t\t\tif (prot_numa) {\n\t\t\t\tstruct page *page;\n\n\t\t\t\tpage = vm_normal_page(vma, addr, oldpte);\n\t\t\t\tif (!page || PageKsm(page))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t/* Also skip shared copy-on-write pages */\n\t\t\t\tif (is_cow_mapping(vma->vm_flags) &&\n\t\t\t\t    page_mapcount(page) != 1)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t/*\n\t\t\t\t * While migration can move some dirty pages,\n\t\t\t\t * it cannot move them all from MIGRATE_ASYNC\n\t\t\t\t * context.\n\t\t\t\t */\n\t\t\t\tif (page_is_file_cache(page) && PageDirty(page))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t/* Avoid TLB flush if possible */\n\t\t\t\tif (pte_protnone(oldpte))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t/*\n\t\t\t\t * Don't mess with PTEs if page is already on the node\n\t\t\t\t * a single-threaded process is running on.\n\t\t\t\t */\n\t\t\t\tif (target_node == page_to_nid(page))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tptent = ptep_modify_prot_start(mm, addr, pte);\n\t\t\tptent = pte_modify(ptent, newprot);\n\t\t\tif (preserve_write)\n\t\t\t\tptent = pte_mk_savedwrite(ptent);\n\n\t\t\t/* Avoid taking write faults for known dirty pages */\n\t\t\tif (dirty_accountable && pte_dirty(ptent) &&\n\t\t\t\t\t(pte_soft_dirty(ptent) ||\n\t\t\t\t\t !(vma->vm_flags & VM_SOFTDIRTY))) {\n\t\t\t\tptent = pte_mkwrite(ptent);\n\t\t\t}\n\t\t\tptep_modify_prot_commit(mm, addr, pte, ptent);\n\t\t\tpages++;\n\t\t} else if (IS_ENABLED(CONFIG_MIGRATION)) {\n\t\t\tswp_entry_t entry = pte_to_swp_entry(oldpte);\n\n\t\t\tif (is_write_migration_entry(entry)) {\n\t\t\t\tpte_t newpte;\n\t\t\t\t/*\n\t\t\t\t * A protection check is difficult so\n\t\t\t\t * just be safe and disable write\n\t\t\t\t */\n\t\t\t\tmake_migration_entry_read(&entry);\n\t\t\t\tnewpte = swp_entry_to_pte(entry);\n\t\t\t\tif (pte_swp_soft_dirty(oldpte))\n\t\t\t\t\tnewpte = pte_swp_mksoft_dirty(newpte);\n\t\t\t\tset_pte_at(mm, addr, pte, newpte);\n\n\t\t\t\tpages++;\n\t\t\t}\n\n\t\t\tif (is_write_device_private_entry(entry)) {\n\t\t\t\tpte_t newpte;\n\n\t\t\t\t/*\n\t\t\t\t * We do not preserve soft-dirtiness. See\n\t\t\t\t * copy_one_pte() for explanation.\n\t\t\t\t */\n\t\t\t\tmake_device_private_entry_read(&entry);\n\t\t\t\tnewpte = swp_entry_to_pte(entry);\n\t\t\t\tset_pte_at(mm, addr, pte, newpte);\n\n\t\t\t\tpages++;\n\t\t\t}\n\t\t}\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n\tarch_leave_lazy_mmu_mode();\n\tpte_unmap_unlock(pte - 1, ptl);\n\n\treturn pages;\n}"
  },
  {
    "function_name": "mprotect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mprotect.c",
    "lines": "577-581",
    "snippet": "SYSCALL_DEFINE3(mprotect, unsigned long, start, size_t, len,\n\t\tunsigned long, prot)\n{\n\treturn do_mprotect_pkey(start, len, prot, -1);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/personality.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/security.h>",
      "#include <linux/highmem.h>",
      "#include <linux/fs.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <asm/cacheflush.h>\n#include <asm/pgtable.h>\n#include <linux/mm_inline.h>\n#include <linux/uaccess.h>\n#include <linux/ksm.h>\n#include <linux/pkeys.h>\n#include <linux/perf_event.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/personality.h>\n#include <linux/mempolicy.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE3(mprotect, unsigned long, start, size_t, len,\n\t\tunsigned long, prot)\n{\n\treturn do_mprotect_pkey(start, len, prot, -1);\n}"
  },
  {
    "function_name": "pkey_mprotect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mprotect.c",
    "lines": "585-589",
    "snippet": "SYSCALL_DEFINE4(pkey_mprotect, unsigned long, start, size_t, len,\n\t\tunsigned long, prot, int, pkey)\n{\n\treturn do_mprotect_pkey(start, len, prot, pkey);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/personality.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/security.h>",
      "#include <linux/highmem.h>",
      "#include <linux/fs.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <asm/cacheflush.h>\n#include <asm/pgtable.h>\n#include <linux/mm_inline.h>\n#include <linux/uaccess.h>\n#include <linux/ksm.h>\n#include <linux/pkeys.h>\n#include <linux/perf_event.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/personality.h>\n#include <linux/mempolicy.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE4(pkey_mprotect, unsigned long, start, size_t, len,\n\t\tunsigned long, prot, int, pkey)\n{\n\treturn do_mprotect_pkey(start, len, prot, pkey);\n}"
  },
  {
    "function_name": "pkey_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mprotect.c",
    "lines": "591-619",
    "snippet": "SYSCALL_DEFINE2(pkey_alloc, unsigned long, flags, unsigned long, init_val)\n{\n\tint pkey;\n\tint ret;\n\n\t/* No flags supported yet. */\n\tif (flags)\n\t\treturn -EINVAL;\n\t/* check for unsupported init values */\n\tif (init_val & ~PKEY_ACCESS_MASK)\n\t\treturn -EINVAL;\n\n\tdown_write(&current->mm->mmap_sem);\n\tpkey = mm_pkey_alloc(current->mm);\n\n\tret = -ENOSPC;\n\tif (pkey == -1)\n\t\tgoto out;\n\n\tret = arch_set_user_pkey_access(current, pkey, init_val);\n\tif (ret) {\n\t\tmm_pkey_free(current->mm, pkey);\n\t\tgoto out;\n\t}\n\tret = pkey;\nout:\n\tup_write(&current->mm->mmap_sem);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/personality.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/security.h>",
      "#include <linux/highmem.h>",
      "#include <linux/fs.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <asm/cacheflush.h>\n#include <asm/pgtable.h>\n#include <linux/mm_inline.h>\n#include <linux/uaccess.h>\n#include <linux/ksm.h>\n#include <linux/pkeys.h>\n#include <linux/perf_event.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/personality.h>\n#include <linux/mempolicy.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE2(pkey_alloc, unsigned long, flags, unsigned long, init_val)\n{\n\tint pkey;\n\tint ret;\n\n\t/* No flags supported yet. */\n\tif (flags)\n\t\treturn -EINVAL;\n\t/* check for unsupported init values */\n\tif (init_val & ~PKEY_ACCESS_MASK)\n\t\treturn -EINVAL;\n\n\tdown_write(&current->mm->mmap_sem);\n\tpkey = mm_pkey_alloc(current->mm);\n\n\tret = -ENOSPC;\n\tif (pkey == -1)\n\t\tgoto out;\n\n\tret = arch_set_user_pkey_access(current, pkey, init_val);\n\tif (ret) {\n\t\tmm_pkey_free(current->mm, pkey);\n\t\tgoto out;\n\t}\n\tret = pkey;\nout:\n\tup_write(&current->mm->mmap_sem);\n\treturn ret;\n}"
  },
  {
    "function_name": "pkey_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mprotect.c",
    "lines": "621-634",
    "snippet": "SYSCALL_DEFINE1(pkey_free, int, pkey)\n{\n\tint ret;\n\n\tdown_write(&current->mm->mmap_sem);\n\tret = mm_pkey_free(current->mm, pkey);\n\tup_write(&current->mm->mmap_sem);\n\n\t/*\n\t * We could provie warnings or errors if any VMA still\n\t * has the pkey set here.\n\t */\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/tlbflush.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/ksm.h>",
      "#include <linux/pkeys.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/personality.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/security.h>",
      "#include <linux/highmem.h>",
      "#include <linux/fs.h>",
      "#include <linux/mman.h>",
      "#include <linux/shm.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <asm/cacheflush.h>\n#include <asm/pgtable.h>\n#include <linux/mm_inline.h>\n#include <linux/uaccess.h>\n#include <linux/ksm.h>\n#include <linux/pkeys.h>\n#include <linux/perf_event.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/personality.h>\n#include <linux/mempolicy.h>\n#include <linux/security.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n#include <linux/mman.h>\n#include <linux/shm.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE1(pkey_free, int, pkey)\n{\n\tint ret;\n\n\tdown_write(&current->mm->mmap_sem);\n\tret = mm_pkey_free(current->mm, pkey);\n\tup_write(&current->mm->mmap_sem);\n\n\t/*\n\t * We could provie warnings or errors if any VMA still\n\t * has the pkey set here.\n\t */\n\treturn ret;\n}"
  }
]