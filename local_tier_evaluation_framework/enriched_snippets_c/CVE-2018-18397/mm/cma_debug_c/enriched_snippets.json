[
  {
    "function_name": "cma_debugfs_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma_debug.c",
    "lines": "189-201",
    "snippet": "static int __init cma_debugfs_init(void)\n{\n\tint i;\n\n\tcma_debugfs_root = debugfs_create_dir(\"cma\", NULL);\n\tif (!cma_debugfs_root)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < cma_area_count; i++)\n\t\tcma_debugfs_add_one(&cma_areas[i], i);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"cma.h\"",
      "#include <linux/mm_types.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/list.h>",
      "#include <linux/cma.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *cma_debugfs_root;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cma_debugfs_add_one",
          "args": [
            "&cma_areas[i]",
            "i"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "cma_debugfs_add_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma_debug.c",
          "lines": "165-187",
          "snippet": "static void cma_debugfs_add_one(struct cma *cma, int idx)\n{\n\tstruct dentry *tmp;\n\tchar name[16];\n\tint u32s;\n\n\tscnprintf(name, sizeof(name), \"cma-%s\", cma->name);\n\n\ttmp = debugfs_create_dir(name, cma_debugfs_root);\n\n\tdebugfs_create_file(\"alloc\", 0200, tmp, cma, &cma_alloc_fops);\n\tdebugfs_create_file(\"free\", 0200, tmp, cma, &cma_free_fops);\n\tdebugfs_create_file(\"base_pfn\", 0444, tmp,\n\t\t\t    &cma->base_pfn, &cma_debugfs_fops);\n\tdebugfs_create_file(\"count\", 0444, tmp, &cma->count, &cma_debugfs_fops);\n\tdebugfs_create_file(\"order_per_bit\", 0444, tmp,\n\t\t\t    &cma->order_per_bit, &cma_debugfs_fops);\n\tdebugfs_create_file(\"used\", 0444, tmp, cma, &cma_used_fops);\n\tdebugfs_create_file(\"maxchunk\", 0444, tmp, cma, &cma_maxchunk_fops);\n\n\tu32s = DIV_ROUND_UP(cma_bitmap_maxno(cma), BITS_PER_BYTE * sizeof(u32));\n\tdebugfs_create_u32_array(\"bitmap\", 0444, tmp, (u32 *)cma->bitmap, u32s);\n}",
          "includes": [
            "#include \"cma.h\"",
            "#include <linux/mm_types.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/cma.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *cma_debugfs_root;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cma.h\"\n#include <linux/mm_types.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/cma.h>\n#include <linux/debugfs.h>\n\nstatic struct dentry *cma_debugfs_root;\n\nstatic void cma_debugfs_add_one(struct cma *cma, int idx)\n{\n\tstruct dentry *tmp;\n\tchar name[16];\n\tint u32s;\n\n\tscnprintf(name, sizeof(name), \"cma-%s\", cma->name);\n\n\ttmp = debugfs_create_dir(name, cma_debugfs_root);\n\n\tdebugfs_create_file(\"alloc\", 0200, tmp, cma, &cma_alloc_fops);\n\tdebugfs_create_file(\"free\", 0200, tmp, cma, &cma_free_fops);\n\tdebugfs_create_file(\"base_pfn\", 0444, tmp,\n\t\t\t    &cma->base_pfn, &cma_debugfs_fops);\n\tdebugfs_create_file(\"count\", 0444, tmp, &cma->count, &cma_debugfs_fops);\n\tdebugfs_create_file(\"order_per_bit\", 0444, tmp,\n\t\t\t    &cma->order_per_bit, &cma_debugfs_fops);\n\tdebugfs_create_file(\"used\", 0444, tmp, cma, &cma_used_fops);\n\tdebugfs_create_file(\"maxchunk\", 0444, tmp, cma, &cma_maxchunk_fops);\n\n\tu32s = DIV_ROUND_UP(cma_bitmap_maxno(cma), BITS_PER_BYTE * sizeof(u32));\n\tdebugfs_create_u32_array(\"bitmap\", 0444, tmp, (u32 *)cma->bitmap, u32s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_create_dir",
          "args": [
            "\"cma\"",
            "NULL"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cma.h\"\n#include <linux/mm_types.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/cma.h>\n#include <linux/debugfs.h>\n\nstatic struct dentry *cma_debugfs_root;\n\nstatic int __init cma_debugfs_init(void)\n{\n\tint i;\n\n\tcma_debugfs_root = debugfs_create_dir(\"cma\", NULL);\n\tif (!cma_debugfs_root)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < cma_area_count; i++)\n\t\tcma_debugfs_add_one(&cma_areas[i], i);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cma_debugfs_add_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma_debug.c",
    "lines": "165-187",
    "snippet": "static void cma_debugfs_add_one(struct cma *cma, int idx)\n{\n\tstruct dentry *tmp;\n\tchar name[16];\n\tint u32s;\n\n\tscnprintf(name, sizeof(name), \"cma-%s\", cma->name);\n\n\ttmp = debugfs_create_dir(name, cma_debugfs_root);\n\n\tdebugfs_create_file(\"alloc\", 0200, tmp, cma, &cma_alloc_fops);\n\tdebugfs_create_file(\"free\", 0200, tmp, cma, &cma_free_fops);\n\tdebugfs_create_file(\"base_pfn\", 0444, tmp,\n\t\t\t    &cma->base_pfn, &cma_debugfs_fops);\n\tdebugfs_create_file(\"count\", 0444, tmp, &cma->count, &cma_debugfs_fops);\n\tdebugfs_create_file(\"order_per_bit\", 0444, tmp,\n\t\t\t    &cma->order_per_bit, &cma_debugfs_fops);\n\tdebugfs_create_file(\"used\", 0444, tmp, cma, &cma_used_fops);\n\tdebugfs_create_file(\"maxchunk\", 0444, tmp, cma, &cma_maxchunk_fops);\n\n\tu32s = DIV_ROUND_UP(cma_bitmap_maxno(cma), BITS_PER_BYTE * sizeof(u32));\n\tdebugfs_create_u32_array(\"bitmap\", 0444, tmp, (u32 *)cma->bitmap, u32s);\n}",
    "includes": [
      "#include \"cma.h\"",
      "#include <linux/mm_types.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/list.h>",
      "#include <linux/cma.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *cma_debugfs_root;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_create_u32_array",
          "args": [
            "\"bitmap\"",
            "0444",
            "tmp",
            "(u32 *)cma->bitmap",
            "u32s"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "cma_bitmap_maxno(cma)",
            "BITS_PER_BYTE * sizeof(u32)"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cma_bitmap_maxno",
          "args": [
            "cma"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "cma_bitmap_maxno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma.h",
          "lines": "21-24",
          "snippet": "static inline unsigned long cma_bitmap_maxno(struct cma *cma)\n{\n\treturn cma->count >> cma->order_per_bit;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long cma_bitmap_maxno(struct cma *cma)\n{\n\treturn cma->count >> cma->order_per_bit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"maxchunk\"",
            "0444",
            "tmp",
            "cma",
            "&cma_maxchunk_fops"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"used\"",
            "0444",
            "tmp",
            "cma",
            "&cma_used_fops"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"order_per_bit\"",
            "0444",
            "tmp",
            "&cma->order_per_bit",
            "&cma_debugfs_fops"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"count\"",
            "0444",
            "tmp",
            "&cma->count",
            "&cma_debugfs_fops"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"base_pfn\"",
            "0444",
            "tmp",
            "&cma->base_pfn",
            "&cma_debugfs_fops"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"free\"",
            "0200",
            "tmp",
            "cma",
            "&cma_free_fops"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"alloc\"",
            "0200",
            "tmp",
            "cma",
            "&cma_alloc_fops"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_dir",
          "args": [
            "name",
            "cma_debugfs_root"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "name",
            "sizeof(name)",
            "\"cma-%s\"",
            "cma->name"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cma.h\"\n#include <linux/mm_types.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/cma.h>\n#include <linux/debugfs.h>\n\nstatic struct dentry *cma_debugfs_root;\n\nstatic void cma_debugfs_add_one(struct cma *cma, int idx)\n{\n\tstruct dentry *tmp;\n\tchar name[16];\n\tint u32s;\n\n\tscnprintf(name, sizeof(name), \"cma-%s\", cma->name);\n\n\ttmp = debugfs_create_dir(name, cma_debugfs_root);\n\n\tdebugfs_create_file(\"alloc\", 0200, tmp, cma, &cma_alloc_fops);\n\tdebugfs_create_file(\"free\", 0200, tmp, cma, &cma_free_fops);\n\tdebugfs_create_file(\"base_pfn\", 0444, tmp,\n\t\t\t    &cma->base_pfn, &cma_debugfs_fops);\n\tdebugfs_create_file(\"count\", 0444, tmp, &cma->count, &cma_debugfs_fops);\n\tdebugfs_create_file(\"order_per_bit\", 0444, tmp,\n\t\t\t    &cma->order_per_bit, &cma_debugfs_fops);\n\tdebugfs_create_file(\"used\", 0444, tmp, cma, &cma_used_fops);\n\tdebugfs_create_file(\"maxchunk\", 0444, tmp, cma, &cma_maxchunk_fops);\n\n\tu32s = DIV_ROUND_UP(cma_bitmap_maxno(cma), BITS_PER_BYTE * sizeof(u32));\n\tdebugfs_create_u32_array(\"bitmap\", 0444, tmp, (u32 *)cma->bitmap, u32s);\n}"
  },
  {
    "function_name": "cma_alloc_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma_debug.c",
    "lines": "156-162",
    "snippet": "static int cma_alloc_write(void *data, u64 val)\n{\n\tint pages = val;\n\tstruct cma *cma = data;\n\n\treturn cma_alloc_mem(cma, pages);\n}",
    "includes": [
      "#include \"cma.h\"",
      "#include <linux/mm_types.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/list.h>",
      "#include <linux/cma.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cma_alloc_mem",
          "args": [
            "cma",
            "pages"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "cma_alloc_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma_debug.c",
          "lines": "133-154",
          "snippet": "static int cma_alloc_mem(struct cma *cma, int count)\n{\n\tstruct cma_mem *mem;\n\tstruct page *p;\n\n\tmem = kzalloc(sizeof(*mem), GFP_KERNEL);\n\tif (!mem)\n\t\treturn -ENOMEM;\n\n\tp = cma_alloc(cma, count, 0, false);\n\tif (!p) {\n\t\tkfree(mem);\n\t\treturn -ENOMEM;\n\t}\n\n\tmem->p = p;\n\tmem->n = count;\n\n\tcma_add_to_cma_mem_list(cma, mem);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"cma.h\"",
            "#include <linux/mm_types.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/cma.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cma.h\"\n#include <linux/mm_types.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/cma.h>\n#include <linux/debugfs.h>\n\nstatic int cma_alloc_mem(struct cma *cma, int count)\n{\n\tstruct cma_mem *mem;\n\tstruct page *p;\n\n\tmem = kzalloc(sizeof(*mem), GFP_KERNEL);\n\tif (!mem)\n\t\treturn -ENOMEM;\n\n\tp = cma_alloc(cma, count, 0, false);\n\tif (!p) {\n\t\tkfree(mem);\n\t\treturn -ENOMEM;\n\t}\n\n\tmem->p = p;\n\tmem->n = count;\n\n\tcma_add_to_cma_mem_list(cma, mem);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cma.h\"\n#include <linux/mm_types.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/cma.h>\n#include <linux/debugfs.h>\n\nstatic int cma_alloc_write(void *data, u64 val)\n{\n\tint pages = val;\n\tstruct cma *cma = data;\n\n\treturn cma_alloc_mem(cma, pages);\n}"
  },
  {
    "function_name": "cma_alloc_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma_debug.c",
    "lines": "133-154",
    "snippet": "static int cma_alloc_mem(struct cma *cma, int count)\n{\n\tstruct cma_mem *mem;\n\tstruct page *p;\n\n\tmem = kzalloc(sizeof(*mem), GFP_KERNEL);\n\tif (!mem)\n\t\treturn -ENOMEM;\n\n\tp = cma_alloc(cma, count, 0, false);\n\tif (!p) {\n\t\tkfree(mem);\n\t\treturn -ENOMEM;\n\t}\n\n\tmem->p = p;\n\tmem->n = count;\n\n\tcma_add_to_cma_mem_list(cma, mem);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"cma.h\"",
      "#include <linux/mm_types.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/list.h>",
      "#include <linux/cma.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cma_add_to_cma_mem_list",
          "args": [
            "cma",
            "mem"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "cma_add_to_cma_mem_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma_debug.c",
          "lines": "73-78",
          "snippet": "static void cma_add_to_cma_mem_list(struct cma *cma, struct cma_mem *mem)\n{\n\tspin_lock(&cma->mem_head_lock);\n\thlist_add_head(&mem->node, &cma->mem_head);\n\tspin_unlock(&cma->mem_head_lock);\n}",
          "includes": [
            "#include \"cma.h\"",
            "#include <linux/mm_types.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/cma.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cma.h\"\n#include <linux/mm_types.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/cma.h>\n#include <linux/debugfs.h>\n\nstatic void cma_add_to_cma_mem_list(struct cma *cma, struct cma_mem *mem)\n{\n\tspin_lock(&cma->mem_head_lock);\n\thlist_add_head(&mem->node, &cma->mem_head);\n\tspin_unlock(&cma->mem_head_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mem"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cma_alloc",
          "args": [
            "cma",
            "count",
            "0",
            "false"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "cma_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma.c",
          "lines": "403-477",
          "snippet": "struct page *cma_alloc(struct cma *cma, size_t count, unsigned int align,\n\t\t       bool no_warn)\n{\n\tunsigned long mask, offset;\n\tunsigned long pfn = -1;\n\tunsigned long start = 0;\n\tunsigned long bitmap_maxno, bitmap_no, bitmap_count;\n\tstruct page *page = NULL;\n\tint ret = -ENOMEM;\n\n\tif (!cma || !cma->count)\n\t\treturn NULL;\n\n\tpr_debug(\"%s(cma %p, count %zu, align %d)\\n\", __func__, (void *)cma,\n\t\t count, align);\n\n\tif (!count)\n\t\treturn NULL;\n\n\tmask = cma_bitmap_aligned_mask(cma, align);\n\toffset = cma_bitmap_aligned_offset(cma, align);\n\tbitmap_maxno = cma_bitmap_maxno(cma);\n\tbitmap_count = cma_bitmap_pages_to_bits(cma, count);\n\n\tif (bitmap_count > bitmap_maxno)\n\t\treturn NULL;\n\n\tfor (;;) {\n\t\tmutex_lock(&cma->lock);\n\t\tbitmap_no = bitmap_find_next_zero_area_off(cma->bitmap,\n\t\t\t\tbitmap_maxno, start, bitmap_count, mask,\n\t\t\t\toffset);\n\t\tif (bitmap_no >= bitmap_maxno) {\n\t\t\tmutex_unlock(&cma->lock);\n\t\t\tbreak;\n\t\t}\n\t\tbitmap_set(cma->bitmap, bitmap_no, bitmap_count);\n\t\t/*\n\t\t * It's safe to drop the lock here. We've marked this region for\n\t\t * our exclusive use. If the migration fails we will take the\n\t\t * lock again and unmark it.\n\t\t */\n\t\tmutex_unlock(&cma->lock);\n\n\t\tpfn = cma->base_pfn + (bitmap_no << cma->order_per_bit);\n\t\tmutex_lock(&cma_mutex);\n\t\tret = alloc_contig_range(pfn, pfn + count, MIGRATE_CMA,\n\t\t\t\t     GFP_KERNEL | (no_warn ? __GFP_NOWARN : 0));\n\t\tmutex_unlock(&cma_mutex);\n\t\tif (ret == 0) {\n\t\t\tpage = pfn_to_page(pfn);\n\t\t\tbreak;\n\t\t}\n\n\t\tcma_clear_bitmap(cma, pfn, count);\n\t\tif (ret != -EBUSY)\n\t\t\tbreak;\n\n\t\tpr_debug(\"%s(): memory range at %p is busy, retrying\\n\",\n\t\t\t __func__, pfn_to_page(pfn));\n\t\t/* try again with a bit different memory target */\n\t\tstart = bitmap_no + mask + 1;\n\t}\n\n\ttrace_cma_alloc(pfn, page, count, align);\n\n\tif (ret && !no_warn) {\n\t\tpr_err(\"%s: alloc failed, req-size: %zu pages, ret: %d\\n\",\n\t\t\t__func__, count, ret);\n\t\tcma_debug_show_areas(cma);\n\t}\n\n\tpr_debug(\"%s(): returned %p\\n\", __func__, page);\n\treturn page;\n}",
          "includes": [
            "#include \"cma.h\"",
            "#include <trace/events/cma.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/io.h>",
            "#include <linux/highmem.h>",
            "#include <linux/cma.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/sizes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(cma_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cma.h\"\n#include <trace/events/cma.h>\n#include <linux/kmemleak.h>\n#include <linux/io.h>\n#include <linux/highmem.h>\n#include <linux/cma.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/sizes.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n\nstatic DEFINE_MUTEX(cma_mutex);\n\nstruct page *cma_alloc(struct cma *cma, size_t count, unsigned int align,\n\t\t       bool no_warn)\n{\n\tunsigned long mask, offset;\n\tunsigned long pfn = -1;\n\tunsigned long start = 0;\n\tunsigned long bitmap_maxno, bitmap_no, bitmap_count;\n\tstruct page *page = NULL;\n\tint ret = -ENOMEM;\n\n\tif (!cma || !cma->count)\n\t\treturn NULL;\n\n\tpr_debug(\"%s(cma %p, count %zu, align %d)\\n\", __func__, (void *)cma,\n\t\t count, align);\n\n\tif (!count)\n\t\treturn NULL;\n\n\tmask = cma_bitmap_aligned_mask(cma, align);\n\toffset = cma_bitmap_aligned_offset(cma, align);\n\tbitmap_maxno = cma_bitmap_maxno(cma);\n\tbitmap_count = cma_bitmap_pages_to_bits(cma, count);\n\n\tif (bitmap_count > bitmap_maxno)\n\t\treturn NULL;\n\n\tfor (;;) {\n\t\tmutex_lock(&cma->lock);\n\t\tbitmap_no = bitmap_find_next_zero_area_off(cma->bitmap,\n\t\t\t\tbitmap_maxno, start, bitmap_count, mask,\n\t\t\t\toffset);\n\t\tif (bitmap_no >= bitmap_maxno) {\n\t\t\tmutex_unlock(&cma->lock);\n\t\t\tbreak;\n\t\t}\n\t\tbitmap_set(cma->bitmap, bitmap_no, bitmap_count);\n\t\t/*\n\t\t * It's safe to drop the lock here. We've marked this region for\n\t\t * our exclusive use. If the migration fails we will take the\n\t\t * lock again and unmark it.\n\t\t */\n\t\tmutex_unlock(&cma->lock);\n\n\t\tpfn = cma->base_pfn + (bitmap_no << cma->order_per_bit);\n\t\tmutex_lock(&cma_mutex);\n\t\tret = alloc_contig_range(pfn, pfn + count, MIGRATE_CMA,\n\t\t\t\t     GFP_KERNEL | (no_warn ? __GFP_NOWARN : 0));\n\t\tmutex_unlock(&cma_mutex);\n\t\tif (ret == 0) {\n\t\t\tpage = pfn_to_page(pfn);\n\t\t\tbreak;\n\t\t}\n\n\t\tcma_clear_bitmap(cma, pfn, count);\n\t\tif (ret != -EBUSY)\n\t\t\tbreak;\n\n\t\tpr_debug(\"%s(): memory range at %p is busy, retrying\\n\",\n\t\t\t __func__, pfn_to_page(pfn));\n\t\t/* try again with a bit different memory target */\n\t\tstart = bitmap_no + mask + 1;\n\t}\n\n\ttrace_cma_alloc(pfn, page, count, align);\n\n\tif (ret && !no_warn) {\n\t\tpr_err(\"%s: alloc failed, req-size: %zu pages, ret: %d\\n\",\n\t\t\t__func__, count, ret);\n\t\tcma_debug_show_areas(cma);\n\t}\n\n\tpr_debug(\"%s(): returned %p\\n\", __func__, page);\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*mem)",
            "GFP_KERNEL"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cma.h\"\n#include <linux/mm_types.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/cma.h>\n#include <linux/debugfs.h>\n\nstatic int cma_alloc_mem(struct cma *cma, int count)\n{\n\tstruct cma_mem *mem;\n\tstruct page *p;\n\n\tmem = kzalloc(sizeof(*mem), GFP_KERNEL);\n\tif (!mem)\n\t\treturn -ENOMEM;\n\n\tp = cma_alloc(cma, count, 0, false);\n\tif (!p) {\n\t\tkfree(mem);\n\t\treturn -ENOMEM;\n\t}\n\n\tmem->p = p;\n\tmem->n = count;\n\n\tcma_add_to_cma_mem_list(cma, mem);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cma_free_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma_debug.c",
    "lines": "124-130",
    "snippet": "static int cma_free_write(void *data, u64 val)\n{\n\tint pages = val;\n\tstruct cma *cma = data;\n\n\treturn cma_free_mem(cma, pages);\n}",
    "includes": [
      "#include \"cma.h\"",
      "#include <linux/mm_types.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/list.h>",
      "#include <linux/cma.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cma_free_mem",
          "args": [
            "cma",
            "pages"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "cma_free_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma_debug.c",
          "lines": "94-122",
          "snippet": "static int cma_free_mem(struct cma *cma, int count)\n{\n\tstruct cma_mem *mem = NULL;\n\n\twhile (count) {\n\t\tmem = cma_get_entry_from_list(cma);\n\t\tif (mem == NULL)\n\t\t\treturn 0;\n\n\t\tif (mem->n <= count) {\n\t\t\tcma_release(cma, mem->p, mem->n);\n\t\t\tcount -= mem->n;\n\t\t\tkfree(mem);\n\t\t} else if (cma->order_per_bit == 0) {\n\t\t\tcma_release(cma, mem->p, count);\n\t\t\tmem->p += count;\n\t\t\tmem->n -= count;\n\t\t\tcount = 0;\n\t\t\tcma_add_to_cma_mem_list(cma, mem);\n\t\t} else {\n\t\t\tpr_debug(\"cma: cannot release partial block when order_per_bit != 0\\n\");\n\t\t\tcma_add_to_cma_mem_list(cma, mem);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n\n}",
          "includes": [
            "#include \"cma.h\"",
            "#include <linux/mm_types.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/cma.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cma.h\"\n#include <linux/mm_types.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/cma.h>\n#include <linux/debugfs.h>\n\nstatic int cma_free_mem(struct cma *cma, int count)\n{\n\tstruct cma_mem *mem = NULL;\n\n\twhile (count) {\n\t\tmem = cma_get_entry_from_list(cma);\n\t\tif (mem == NULL)\n\t\t\treturn 0;\n\n\t\tif (mem->n <= count) {\n\t\t\tcma_release(cma, mem->p, mem->n);\n\t\t\tcount -= mem->n;\n\t\t\tkfree(mem);\n\t\t} else if (cma->order_per_bit == 0) {\n\t\t\tcma_release(cma, mem->p, count);\n\t\t\tmem->p += count;\n\t\t\tmem->n -= count;\n\t\t\tcount = 0;\n\t\t\tcma_add_to_cma_mem_list(cma, mem);\n\t\t} else {\n\t\t\tpr_debug(\"cma: cannot release partial block when order_per_bit != 0\\n\");\n\t\t\tcma_add_to_cma_mem_list(cma, mem);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cma.h\"\n#include <linux/mm_types.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/cma.h>\n#include <linux/debugfs.h>\n\nstatic int cma_free_write(void *data, u64 val)\n{\n\tint pages = val;\n\tstruct cma *cma = data;\n\n\treturn cma_free_mem(cma, pages);\n}"
  },
  {
    "function_name": "cma_free_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma_debug.c",
    "lines": "94-122",
    "snippet": "static int cma_free_mem(struct cma *cma, int count)\n{\n\tstruct cma_mem *mem = NULL;\n\n\twhile (count) {\n\t\tmem = cma_get_entry_from_list(cma);\n\t\tif (mem == NULL)\n\t\t\treturn 0;\n\n\t\tif (mem->n <= count) {\n\t\t\tcma_release(cma, mem->p, mem->n);\n\t\t\tcount -= mem->n;\n\t\t\tkfree(mem);\n\t\t} else if (cma->order_per_bit == 0) {\n\t\t\tcma_release(cma, mem->p, count);\n\t\t\tmem->p += count;\n\t\t\tmem->n -= count;\n\t\t\tcount = 0;\n\t\t\tcma_add_to_cma_mem_list(cma, mem);\n\t\t} else {\n\t\t\tpr_debug(\"cma: cannot release partial block when order_per_bit != 0\\n\");\n\t\t\tcma_add_to_cma_mem_list(cma, mem);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n\n}",
    "includes": [
      "#include \"cma.h\"",
      "#include <linux/mm_types.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/list.h>",
      "#include <linux/cma.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cma_add_to_cma_mem_list",
          "args": [
            "cma",
            "mem"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "cma_add_to_cma_mem_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma_debug.c",
          "lines": "73-78",
          "snippet": "static void cma_add_to_cma_mem_list(struct cma *cma, struct cma_mem *mem)\n{\n\tspin_lock(&cma->mem_head_lock);\n\thlist_add_head(&mem->node, &cma->mem_head);\n\tspin_unlock(&cma->mem_head_lock);\n}",
          "includes": [
            "#include \"cma.h\"",
            "#include <linux/mm_types.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/cma.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cma.h\"\n#include <linux/mm_types.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/cma.h>\n#include <linux/debugfs.h>\n\nstatic void cma_add_to_cma_mem_list(struct cma *cma, struct cma_mem *mem)\n{\n\tspin_lock(&cma->mem_head_lock);\n\thlist_add_head(&mem->node, &cma->mem_head);\n\tspin_unlock(&cma->mem_head_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"cma: cannot release partial block when order_per_bit != 0\\n\""
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cma_release",
          "args": [
            "cma",
            "mem->p",
            "count"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "cma_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma.c",
          "lines": "489-510",
          "snippet": "bool cma_release(struct cma *cma, const struct page *pages, unsigned int count)\n{\n\tunsigned long pfn;\n\n\tif (!cma || !pages)\n\t\treturn false;\n\n\tpr_debug(\"%s(page %p)\\n\", __func__, (void *)pages);\n\n\tpfn = page_to_pfn(pages);\n\n\tif (pfn < cma->base_pfn || pfn >= cma->base_pfn + cma->count)\n\t\treturn false;\n\n\tVM_BUG_ON(pfn + count > cma->base_pfn + cma->count);\n\n\tfree_contig_range(pfn, count);\n\tcma_clear_bitmap(cma, pfn, count);\n\ttrace_cma_release(pfn, pages, count);\n\n\treturn true;\n}",
          "includes": [
            "#include \"cma.h\"",
            "#include <trace/events/cma.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/io.h>",
            "#include <linux/highmem.h>",
            "#include <linux/cma.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/sizes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cma.h\"\n#include <trace/events/cma.h>\n#include <linux/kmemleak.h>\n#include <linux/io.h>\n#include <linux/highmem.h>\n#include <linux/cma.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/sizes.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n\nbool cma_release(struct cma *cma, const struct page *pages, unsigned int count)\n{\n\tunsigned long pfn;\n\n\tif (!cma || !pages)\n\t\treturn false;\n\n\tpr_debug(\"%s(page %p)\\n\", __func__, (void *)pages);\n\n\tpfn = page_to_pfn(pages);\n\n\tif (pfn < cma->base_pfn || pfn >= cma->base_pfn + cma->count)\n\t\treturn false;\n\n\tVM_BUG_ON(pfn + count > cma->base_pfn + cma->count);\n\n\tfree_contig_range(pfn, count);\n\tcma_clear_bitmap(cma, pfn, count);\n\ttrace_cma_release(pfn, pages, count);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mem"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cma_get_entry_from_list",
          "args": [
            "cma"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "cma_get_entry_from_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma_debug.c",
          "lines": "80-92",
          "snippet": "static struct cma_mem *cma_get_entry_from_list(struct cma *cma)\n{\n\tstruct cma_mem *mem = NULL;\n\n\tspin_lock(&cma->mem_head_lock);\n\tif (!hlist_empty(&cma->mem_head)) {\n\t\tmem = hlist_entry(cma->mem_head.first, struct cma_mem, node);\n\t\thlist_del_init(&mem->node);\n\t}\n\tspin_unlock(&cma->mem_head_lock);\n\n\treturn mem;\n}",
          "includes": [
            "#include \"cma.h\"",
            "#include <linux/mm_types.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/cma.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cma.h\"\n#include <linux/mm_types.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/cma.h>\n#include <linux/debugfs.h>\n\nstatic struct cma_mem *cma_get_entry_from_list(struct cma *cma)\n{\n\tstruct cma_mem *mem = NULL;\n\n\tspin_lock(&cma->mem_head_lock);\n\tif (!hlist_empty(&cma->mem_head)) {\n\t\tmem = hlist_entry(cma->mem_head.first, struct cma_mem, node);\n\t\thlist_del_init(&mem->node);\n\t}\n\tspin_unlock(&cma->mem_head_lock);\n\n\treturn mem;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cma.h\"\n#include <linux/mm_types.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/cma.h>\n#include <linux/debugfs.h>\n\nstatic int cma_free_mem(struct cma *cma, int count)\n{\n\tstruct cma_mem *mem = NULL;\n\n\twhile (count) {\n\t\tmem = cma_get_entry_from_list(cma);\n\t\tif (mem == NULL)\n\t\t\treturn 0;\n\n\t\tif (mem->n <= count) {\n\t\t\tcma_release(cma, mem->p, mem->n);\n\t\t\tcount -= mem->n;\n\t\t\tkfree(mem);\n\t\t} else if (cma->order_per_bit == 0) {\n\t\t\tcma_release(cma, mem->p, count);\n\t\t\tmem->p += count;\n\t\t\tmem->n -= count;\n\t\t\tcount = 0;\n\t\t\tcma_add_to_cma_mem_list(cma, mem);\n\t\t} else {\n\t\t\tpr_debug(\"cma: cannot release partial block when order_per_bit != 0\\n\");\n\t\t\tcma_add_to_cma_mem_list(cma, mem);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n\n}"
  },
  {
    "function_name": "cma_get_entry_from_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma_debug.c",
    "lines": "80-92",
    "snippet": "static struct cma_mem *cma_get_entry_from_list(struct cma *cma)\n{\n\tstruct cma_mem *mem = NULL;\n\n\tspin_lock(&cma->mem_head_lock);\n\tif (!hlist_empty(&cma->mem_head)) {\n\t\tmem = hlist_entry(cma->mem_head.first, struct cma_mem, node);\n\t\thlist_del_init(&mem->node);\n\t}\n\tspin_unlock(&cma->mem_head_lock);\n\n\treturn mem;\n}",
    "includes": [
      "#include \"cma.h\"",
      "#include <linux/mm_types.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/list.h>",
      "#include <linux/cma.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cma->mem_head_lock"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_del_init",
          "args": [
            "&mem->node"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_entry",
          "args": [
            "cma->mem_head.first",
            "structcma_mem",
            "node"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&cma->mem_head"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cma->mem_head_lock"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cma.h\"\n#include <linux/mm_types.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/cma.h>\n#include <linux/debugfs.h>\n\nstatic struct cma_mem *cma_get_entry_from_list(struct cma *cma)\n{\n\tstruct cma_mem *mem = NULL;\n\n\tspin_lock(&cma->mem_head_lock);\n\tif (!hlist_empty(&cma->mem_head)) {\n\t\tmem = hlist_entry(cma->mem_head.first, struct cma_mem, node);\n\t\thlist_del_init(&mem->node);\n\t}\n\tspin_unlock(&cma->mem_head_lock);\n\n\treturn mem;\n}"
  },
  {
    "function_name": "cma_add_to_cma_mem_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma_debug.c",
    "lines": "73-78",
    "snippet": "static void cma_add_to_cma_mem_list(struct cma *cma, struct cma_mem *mem)\n{\n\tspin_lock(&cma->mem_head_lock);\n\thlist_add_head(&mem->node, &cma->mem_head);\n\tspin_unlock(&cma->mem_head_lock);\n}",
    "includes": [
      "#include \"cma.h\"",
      "#include <linux/mm_types.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/list.h>",
      "#include <linux/cma.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cma->mem_head_lock"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&mem->node",
            "&cma->mem_head"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cma->mem_head_lock"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cma.h\"\n#include <linux/mm_types.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/cma.h>\n#include <linux/debugfs.h>\n\nstatic void cma_add_to_cma_mem_list(struct cma *cma, struct cma_mem *mem)\n{\n\tspin_lock(&cma->mem_head_lock);\n\thlist_add_head(&mem->node, &cma->mem_head);\n\tspin_unlock(&cma->mem_head_lock);\n}"
  },
  {
    "function_name": "cma_maxchunk_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma_debug.c",
    "lines": "51-70",
    "snippet": "static int cma_maxchunk_get(void *data, u64 *val)\n{\n\tstruct cma *cma = data;\n\tunsigned long maxchunk = 0;\n\tunsigned long start, end = 0;\n\tunsigned long bitmap_maxno = cma_bitmap_maxno(cma);\n\n\tmutex_lock(&cma->lock);\n\tfor (;;) {\n\t\tstart = find_next_zero_bit(cma->bitmap, bitmap_maxno, end);\n\t\tif (start >= cma->count)\n\t\t\tbreak;\n\t\tend = find_next_bit(cma->bitmap, bitmap_maxno, start);\n\t\tmaxchunk = max(end - start, maxchunk);\n\t}\n\tmutex_unlock(&cma->lock);\n\t*val = (u64)maxchunk << cma->order_per_bit;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"cma.h\"",
      "#include <linux/mm_types.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/list.h>",
      "#include <linux/cma.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cma->lock"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "end - start",
            "maxchunk"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "cma_maxchunk_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma_debug.c",
          "lines": "51-70",
          "snippet": "static int cma_maxchunk_get(void *data, u64 *val)\n{\n\tstruct cma *cma = data;\n\tunsigned long maxchunk = 0;\n\tunsigned long start, end = 0;\n\tunsigned long bitmap_maxno = cma_bitmap_maxno(cma);\n\n\tmutex_lock(&cma->lock);\n\tfor (;;) {\n\t\tstart = find_next_zero_bit(cma->bitmap, bitmap_maxno, end);\n\t\tif (start >= cma->count)\n\t\t\tbreak;\n\t\tend = find_next_bit(cma->bitmap, bitmap_maxno, start);\n\t\tmaxchunk = max(end - start, maxchunk);\n\t}\n\tmutex_unlock(&cma->lock);\n\t*val = (u64)maxchunk << cma->order_per_bit;\n\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "cma->bitmap",
            "bitmap_maxno",
            "start"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_next_zero_bit",
          "args": [
            "cma->bitmap",
            "bitmap_maxno",
            "end"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cma->lock"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cma_bitmap_maxno",
          "args": [
            "cma"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "cma_bitmap_maxno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma.h",
          "lines": "21-24",
          "snippet": "static inline unsigned long cma_bitmap_maxno(struct cma *cma)\n{\n\treturn cma->count >> cma->order_per_bit;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long cma_bitmap_maxno(struct cma *cma)\n{\n\treturn cma->count >> cma->order_per_bit;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cma.h\"\n#include <linux/mm_types.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/cma.h>\n#include <linux/debugfs.h>\n\nstatic int cma_maxchunk_get(void *data, u64 *val)\n{\n\tstruct cma *cma = data;\n\tunsigned long maxchunk = 0;\n\tunsigned long start, end = 0;\n\tunsigned long bitmap_maxno = cma_bitmap_maxno(cma);\n\n\tmutex_lock(&cma->lock);\n\tfor (;;) {\n\t\tstart = find_next_zero_bit(cma->bitmap, bitmap_maxno, end);\n\t\tif (start >= cma->count)\n\t\t\tbreak;\n\t\tend = find_next_bit(cma->bitmap, bitmap_maxno, start);\n\t\tmaxchunk = max(end - start, maxchunk);\n\t}\n\tmutex_unlock(&cma->lock);\n\t*val = (u64)maxchunk << cma->order_per_bit;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cma_used_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma_debug.c",
    "lines": "36-48",
    "snippet": "static int cma_used_get(void *data, u64 *val)\n{\n\tstruct cma *cma = data;\n\tunsigned long used;\n\n\tmutex_lock(&cma->lock);\n\t/* pages counter is smaller than sizeof(int) */\n\tused = bitmap_weight(cma->bitmap, (int)cma_bitmap_maxno(cma));\n\tmutex_unlock(&cma->lock);\n\t*val = (u64)used << cma->order_per_bit;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"cma.h\"",
      "#include <linux/mm_types.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/list.h>",
      "#include <linux/cma.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&cma->lock"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_weight",
          "args": [
            "cma->bitmap",
            "(int)cma_bitmap_maxno(cma)"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cma_bitmap_maxno",
          "args": [
            "cma"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "cma_bitmap_maxno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma.h",
          "lines": "21-24",
          "snippet": "static inline unsigned long cma_bitmap_maxno(struct cma *cma)\n{\n\treturn cma->count >> cma->order_per_bit;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long cma_bitmap_maxno(struct cma *cma)\n{\n\treturn cma->count >> cma->order_per_bit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&cma->lock"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cma.h\"\n#include <linux/mm_types.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/cma.h>\n#include <linux/debugfs.h>\n\nstatic int cma_used_get(void *data, u64 *val)\n{\n\tstruct cma *cma = data;\n\tunsigned long used;\n\n\tmutex_lock(&cma->lock);\n\t/* pages counter is smaller than sizeof(int) */\n\tused = bitmap_weight(cma->bitmap, (int)cma_bitmap_maxno(cma));\n\tmutex_unlock(&cma->lock);\n\t*val = (u64)used << cma->order_per_bit;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cma_debugfs_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/cma_debug.c",
    "lines": "26-33",
    "snippet": "static int cma_debugfs_get(void *data, u64 *val)\n{\n\tunsigned long *p = data;\n\n\t*val = *p;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"cma.h\"",
      "#include <linux/mm_types.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/list.h>",
      "#include <linux/cma.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"cma.h\"\n#include <linux/mm_types.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/cma.h>\n#include <linux/debugfs.h>\n\nstatic int cma_debugfs_get(void *data, u64 *val)\n{\n\tunsigned long *p = data;\n\n\t*val = *p;\n\n\treturn 0;\n}"
  }
]