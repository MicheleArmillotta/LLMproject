[
  {
    "function_name": "swap_init_sysfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
    "lines": "793-813",
    "snippet": "static int __init swap_init_sysfs(void)\n{\n\tint err;\n\tstruct kobject *swap_kobj;\n\n\tswap_kobj = kobject_create_and_add(\"swap\", mm_kobj);\n\tif (!swap_kobj) {\n\t\tpr_err(\"failed to create swap kobject\\n\");\n\t\treturn -ENOMEM;\n\t}\n\terr = sysfs_create_group(swap_kobj, &swap_attr_group);\n\tif (err) {\n\t\tpr_err(\"failed to register swap group\\n\");\n\t\tgoto delete_obj;\n\t}\n\treturn 0;\n\ndelete_obj:\n\tkobject_put(swap_kobj);\n\treturn err;\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/migrate.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kobject_put",
          "args": [
            "swap_kobj"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"failed to register swap group\\n\""
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_create_group",
          "args": [
            "swap_kobj",
            "&swap_attr_group"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"failed to create swap kobject\\n\""
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobject_create_and_add",
          "args": [
            "\"swap\"",
            "mm_kobj"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstatic int __init swap_init_sysfs(void)\n{\n\tint err;\n\tstruct kobject *swap_kobj;\n\n\tswap_kobj = kobject_create_and_add(\"swap\", mm_kobj);\n\tif (!swap_kobj) {\n\t\tpr_err(\"failed to create swap kobject\\n\");\n\t\treturn -ENOMEM;\n\t}\n\terr = sysfs_create_group(swap_kobj, &swap_attr_group);\n\tif (err) {\n\t\tpr_err(\"failed to register swap group\\n\");\n\t\tgoto delete_obj;\n\t}\n\treturn 0;\n\ndelete_obj:\n\tkobject_put(swap_kobj);\n\treturn err;\n}"
  },
  {
    "function_name": "vma_ra_enabled_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
    "lines": "767-779",
    "snippet": "static ssize_t vma_ra_enabled_store(struct kobject *kobj,\n\t\t\t\t      struct kobj_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tif (!strncmp(buf, \"true\", 4) || !strncmp(buf, \"1\", 1))\n\t\tenable_vma_readahead = true;\n\telse if (!strncmp(buf, \"false\", 5) || !strncmp(buf, \"0\", 1))\n\t\tenable_vma_readahead = false;\n\telse\n\t\treturn -EINVAL;\n\n\treturn count;\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/migrate.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool enable_vma_readahead"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "\"0\"",
            "1"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "\"false\"",
            "5"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "\"1\"",
            "1"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "\"true\"",
            "4"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstatic bool enable_vma_readahead;\n\nstatic ssize_t vma_ra_enabled_store(struct kobject *kobj,\n\t\t\t\t      struct kobj_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tif (!strncmp(buf, \"true\", 4) || !strncmp(buf, \"1\", 1))\n\t\tenable_vma_readahead = true;\n\telse if (!strncmp(buf, \"false\", 5) || !strncmp(buf, \"0\", 1))\n\t\tenable_vma_readahead = false;\n\telse\n\t\treturn -EINVAL;\n\n\treturn count;\n}"
  },
  {
    "function_name": "vma_ra_enabled_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
    "lines": "762-766",
    "snippet": "static ssize_t vma_ra_enabled_show(struct kobject *kobj,\n\t\t\t\t     struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%s\\n\", enable_vma_readahead ? \"true\" : \"false\");\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/migrate.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool enable_vma_readahead"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%s\\n\"",
            "enable_vma_readahead ? \"true\" : \"false\""
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstatic bool enable_vma_readahead;\n\nstatic ssize_t vma_ra_enabled_show(struct kobject *kobj,\n\t\t\t\t     struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%s\\n\", enable_vma_readahead ? \"true\" : \"false\");\n}"
  },
  {
    "function_name": "swapin_readahead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
    "lines": "753-759",
    "snippet": "struct page *swapin_readahead(swp_entry_t entry, gfp_t gfp_mask,\n\t\t\t\tstruct vm_fault *vmf)\n{\n\treturn swap_use_vma_readahead() ?\n\t\t\tswap_vma_readahead(entry, gfp_mask, vmf) :\n\t\t\tswap_cluster_readahead(entry, gfp_mask, vmf);\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/migrate.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "swap_cluster_readahead",
          "args": [
            "entry",
            "gfp_mask",
            "vmf"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "swap_cluster_readahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "528-577",
          "snippet": "struct page *swap_cluster_readahead(swp_entry_t entry, gfp_t gfp_mask,\n\t\t\t\tstruct vm_fault *vmf)\n{\n\tstruct page *page;\n\tunsigned long entry_offset = swp_offset(entry);\n\tunsigned long offset = entry_offset;\n\tunsigned long start_offset, end_offset;\n\tunsigned long mask;\n\tstruct swap_info_struct *si = swp_swap_info(entry);\n\tstruct blk_plug plug;\n\tbool do_poll = true, page_allocated;\n\tstruct vm_area_struct *vma = vmf->vma;\n\tunsigned long addr = vmf->address;\n\n\tmask = swapin_nr_pages(offset) - 1;\n\tif (!mask)\n\t\tgoto skip;\n\n\tdo_poll = false;\n\t/* Read a page_cluster sized and aligned cluster around offset. */\n\tstart_offset = offset & ~mask;\n\tend_offset = offset | mask;\n\tif (!start_offset)\t/* First page is swap header. */\n\t\tstart_offset++;\n\tif (end_offset >= si->max)\n\t\tend_offset = si->max - 1;\n\n\tblk_start_plug(&plug);\n\tfor (offset = start_offset; offset <= end_offset ; offset++) {\n\t\t/* Ok, do the async read-ahead now */\n\t\tpage = __read_swap_cache_async(\n\t\t\tswp_entry(swp_type(entry), offset),\n\t\t\tgfp_mask, vma, addr, &page_allocated);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (page_allocated) {\n\t\t\tswap_readpage(page, false);\n\t\t\tif (offset != entry_offset) {\n\t\t\t\tSetPageReadahead(page);\n\t\t\t\tcount_vm_event(SWAP_RA);\n\t\t\t}\n\t\t}\n\t\tput_page(page);\n\t}\n\tblk_finish_plug(&plug);\n\n\tlru_add_drain();\t/* Push any new pages onto the LRU now */\nskip:\n\treturn read_swap_cache_async(entry, gfp_mask, vma, addr, do_poll);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstruct page *swap_cluster_readahead(swp_entry_t entry, gfp_t gfp_mask,\n\t\t\t\tstruct vm_fault *vmf)\n{\n\tstruct page *page;\n\tunsigned long entry_offset = swp_offset(entry);\n\tunsigned long offset = entry_offset;\n\tunsigned long start_offset, end_offset;\n\tunsigned long mask;\n\tstruct swap_info_struct *si = swp_swap_info(entry);\n\tstruct blk_plug plug;\n\tbool do_poll = true, page_allocated;\n\tstruct vm_area_struct *vma = vmf->vma;\n\tunsigned long addr = vmf->address;\n\n\tmask = swapin_nr_pages(offset) - 1;\n\tif (!mask)\n\t\tgoto skip;\n\n\tdo_poll = false;\n\t/* Read a page_cluster sized and aligned cluster around offset. */\n\tstart_offset = offset & ~mask;\n\tend_offset = offset | mask;\n\tif (!start_offset)\t/* First page is swap header. */\n\t\tstart_offset++;\n\tif (end_offset >= si->max)\n\t\tend_offset = si->max - 1;\n\n\tblk_start_plug(&plug);\n\tfor (offset = start_offset; offset <= end_offset ; offset++) {\n\t\t/* Ok, do the async read-ahead now */\n\t\tpage = __read_swap_cache_async(\n\t\t\tswp_entry(swp_type(entry), offset),\n\t\t\tgfp_mask, vma, addr, &page_allocated);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (page_allocated) {\n\t\t\tswap_readpage(page, false);\n\t\t\tif (offset != entry_offset) {\n\t\t\t\tSetPageReadahead(page);\n\t\t\t\tcount_vm_event(SWAP_RA);\n\t\t\t}\n\t\t}\n\t\tput_page(page);\n\t}\n\tblk_finish_plug(&plug);\n\n\tlru_add_drain();\t/* Push any new pages onto the LRU now */\nskip:\n\treturn read_swap_cache_async(entry, gfp_mask, vma, addr, do_poll);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap_vma_readahead",
          "args": [
            "entry",
            "gfp_mask",
            "vmf"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "swap_vma_readahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "694-739",
          "snippet": "static struct page *swap_vma_readahead(swp_entry_t fentry, gfp_t gfp_mask,\n\t\t\t\t       struct vm_fault *vmf)\n{\n\tstruct blk_plug plug;\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct page *page;\n\tpte_t *pte, pentry;\n\tswp_entry_t entry;\n\tunsigned int i;\n\tbool page_allocated;\n\tstruct vma_swap_readahead ra_info = {0,};\n\n\tswap_ra_info(vmf, &ra_info);\n\tif (ra_info.win == 1)\n\t\tgoto skip;\n\n\tblk_start_plug(&plug);\n\tfor (i = 0, pte = ra_info.ptes; i < ra_info.nr_pte;\n\t     i++, pte++) {\n\t\tpentry = *pte;\n\t\tif (pte_none(pentry))\n\t\t\tcontinue;\n\t\tif (pte_present(pentry))\n\t\t\tcontinue;\n\t\tentry = pte_to_swp_entry(pentry);\n\t\tif (unlikely(non_swap_entry(entry)))\n\t\t\tcontinue;\n\t\tpage = __read_swap_cache_async(entry, gfp_mask, vma,\n\t\t\t\t\t       vmf->address, &page_allocated);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (page_allocated) {\n\t\t\tswap_readpage(page, false);\n\t\t\tif (i != ra_info.offset) {\n\t\t\t\tSetPageReadahead(page);\n\t\t\t\tcount_vm_event(SWAP_RA);\n\t\t\t}\n\t\t}\n\t\tput_page(page);\n\t}\n\tblk_finish_plug(&plug);\n\tlru_add_drain();\nskip:\n\treturn read_swap_cache_async(fentry, gfp_mask, vma, vmf->address,\n\t\t\t\t     ra_info.win == 1);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstatic struct page *swap_vma_readahead(swp_entry_t fentry, gfp_t gfp_mask,\n\t\t\t\t       struct vm_fault *vmf)\n{\n\tstruct blk_plug plug;\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct page *page;\n\tpte_t *pte, pentry;\n\tswp_entry_t entry;\n\tunsigned int i;\n\tbool page_allocated;\n\tstruct vma_swap_readahead ra_info = {0,};\n\n\tswap_ra_info(vmf, &ra_info);\n\tif (ra_info.win == 1)\n\t\tgoto skip;\n\n\tblk_start_plug(&plug);\n\tfor (i = 0, pte = ra_info.ptes; i < ra_info.nr_pte;\n\t     i++, pte++) {\n\t\tpentry = *pte;\n\t\tif (pte_none(pentry))\n\t\t\tcontinue;\n\t\tif (pte_present(pentry))\n\t\t\tcontinue;\n\t\tentry = pte_to_swp_entry(pentry);\n\t\tif (unlikely(non_swap_entry(entry)))\n\t\t\tcontinue;\n\t\tpage = __read_swap_cache_async(entry, gfp_mask, vma,\n\t\t\t\t\t       vmf->address, &page_allocated);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (page_allocated) {\n\t\t\tswap_readpage(page, false);\n\t\t\tif (i != ra_info.offset) {\n\t\t\t\tSetPageReadahead(page);\n\t\t\t\tcount_vm_event(SWAP_RA);\n\t\t\t}\n\t\t}\n\t\tput_page(page);\n\t}\n\tblk_finish_plug(&plug);\n\tlru_add_drain();\nskip:\n\treturn read_swap_cache_async(fentry, gfp_mask, vma, vmf->address,\n\t\t\t\t     ra_info.win == 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap_use_vma_readahead",
          "args": [],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "swap_use_vma_readahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "298-301",
          "snippet": "static inline bool swap_use_vma_readahead(void)\n{\n\treturn READ_ONCE(enable_vma_readahead) && !atomic_read(&nr_rotate_swap);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool enable_vma_readahead"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstatic bool enable_vma_readahead;\n\nstatic inline bool swap_use_vma_readahead(void)\n{\n\treturn READ_ONCE(enable_vma_readahead) && !atomic_read(&nr_rotate_swap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstruct page *swapin_readahead(swp_entry_t entry, gfp_t gfp_mask,\n\t\t\t\tstruct vm_fault *vmf)\n{\n\treturn swap_use_vma_readahead() ?\n\t\t\tswap_vma_readahead(entry, gfp_mask, vmf) :\n\t\t\tswap_cluster_readahead(entry, gfp_mask, vmf);\n}"
  },
  {
    "function_name": "swap_vma_readahead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
    "lines": "694-739",
    "snippet": "static struct page *swap_vma_readahead(swp_entry_t fentry, gfp_t gfp_mask,\n\t\t\t\t       struct vm_fault *vmf)\n{\n\tstruct blk_plug plug;\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct page *page;\n\tpte_t *pte, pentry;\n\tswp_entry_t entry;\n\tunsigned int i;\n\tbool page_allocated;\n\tstruct vma_swap_readahead ra_info = {0,};\n\n\tswap_ra_info(vmf, &ra_info);\n\tif (ra_info.win == 1)\n\t\tgoto skip;\n\n\tblk_start_plug(&plug);\n\tfor (i = 0, pte = ra_info.ptes; i < ra_info.nr_pte;\n\t     i++, pte++) {\n\t\tpentry = *pte;\n\t\tif (pte_none(pentry))\n\t\t\tcontinue;\n\t\tif (pte_present(pentry))\n\t\t\tcontinue;\n\t\tentry = pte_to_swp_entry(pentry);\n\t\tif (unlikely(non_swap_entry(entry)))\n\t\t\tcontinue;\n\t\tpage = __read_swap_cache_async(entry, gfp_mask, vma,\n\t\t\t\t\t       vmf->address, &page_allocated);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (page_allocated) {\n\t\t\tswap_readpage(page, false);\n\t\t\tif (i != ra_info.offset) {\n\t\t\t\tSetPageReadahead(page);\n\t\t\t\tcount_vm_event(SWAP_RA);\n\t\t\t}\n\t\t}\n\t\tput_page(page);\n\t}\n\tblk_finish_plug(&plug);\n\tlru_add_drain();\nskip:\n\treturn read_swap_cache_async(fentry, gfp_mask, vma, vmf->address,\n\t\t\t\t     ra_info.win == 1);\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/migrate.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_swap_cache_async",
          "args": [
            "fentry",
            "gfp_mask",
            "vma",
            "vmf->address",
            "ra_info.win == 1"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "read_swap_cache_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "437-448",
          "snippet": "struct page *read_swap_cache_async(swp_entry_t entry, gfp_t gfp_mask,\n\t\tstruct vm_area_struct *vma, unsigned long addr, bool do_poll)\n{\n\tbool page_was_allocated;\n\tstruct page *retpage = __read_swap_cache_async(entry, gfp_mask,\n\t\t\tvma, addr, &page_was_allocated);\n\n\tif (page_was_allocated)\n\t\tswap_readpage(retpage, do_poll);\n\n\treturn retpage;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstruct page *read_swap_cache_async(swp_entry_t entry, gfp_t gfp_mask,\n\t\tstruct vm_area_struct *vma, unsigned long addr, bool do_poll)\n{\n\tbool page_was_allocated;\n\tstruct page *retpage = __read_swap_cache_async(entry, gfp_mask,\n\t\t\tvma, addr, &page_was_allocated);\n\n\tif (page_was_allocated)\n\t\tswap_readpage(retpage, do_poll);\n\n\treturn retpage;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lru_add_drain",
          "args": [],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "lru_add_drain_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "670-704",
          "snippet": "void lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);",
            "static DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);",
            "static DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\nstatic DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);\nstatic DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);\n\nvoid lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "SWAP_RA"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageReadahead",
          "args": [
            "page"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_readpage",
          "args": [
            "page",
            "false"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "swap_readpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_io.c",
          "lines": "351-420",
          "snippet": "int swap_readpage(struct page *page, bool synchronous)\n{\n\tstruct bio *bio;\n\tint ret = 0;\n\tstruct swap_info_struct *sis = page_swap_info(page);\n\tblk_qc_t qc;\n\tstruct gendisk *disk;\n\n\tVM_BUG_ON_PAGE(!PageSwapCache(page) && !synchronous, page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(PageUptodate(page), page);\n\tif (frontswap_load(page) == 0) {\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\tgoto out;\n\t}\n\n\tif (sis->flags & SWP_FS) {\n\t\tstruct file *swap_file = sis->swap_file;\n\t\tstruct address_space *mapping = swap_file->f_mapping;\n\n\t\tret = mapping->a_ops->readpage(swap_file, page);\n\t\tif (!ret)\n\t\t\tcount_vm_event(PSWPIN);\n\t\treturn ret;\n\t}\n\n\tret = bdev_read_page(sis->bdev, swap_page_sector(page), page);\n\tif (!ret) {\n\t\tif (trylock_page(page)) {\n\t\t\tswap_slot_free_notify(page);\n\t\t\tunlock_page(page);\n\t\t}\n\n\t\tcount_vm_event(PSWPIN);\n\t\treturn 0;\n\t}\n\n\tret = 0;\n\tbio = get_swap_bio(GFP_KERNEL, page, end_swap_bio_read);\n\tif (bio == NULL) {\n\t\tunlock_page(page);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tdisk = bio->bi_disk;\n\t/*\n\t * Keep this task valid during swap readpage because the oom killer may\n\t * attempt to access it in the page fault retry time check.\n\t */\n\tget_task_struct(current);\n\tbio->bi_private = current;\n\tbio_set_op_attrs(bio, REQ_OP_READ, 0);\n\tcount_vm_event(PSWPIN);\n\tbio_get(bio);\n\tqc = submit_bio(bio);\n\twhile (synchronous) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (!READ_ONCE(bio->bi_private))\n\t\t\tbreak;\n\n\t\tif (!blk_poll(disk->queue, qc))\n\t\t\tbreak;\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tbio_put(bio);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/swapops.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/sched/task.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/frontswap.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swapops.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/mm.h>\n\nint swap_readpage(struct page *page, bool synchronous)\n{\n\tstruct bio *bio;\n\tint ret = 0;\n\tstruct swap_info_struct *sis = page_swap_info(page);\n\tblk_qc_t qc;\n\tstruct gendisk *disk;\n\n\tVM_BUG_ON_PAGE(!PageSwapCache(page) && !synchronous, page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(PageUptodate(page), page);\n\tif (frontswap_load(page) == 0) {\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\tgoto out;\n\t}\n\n\tif (sis->flags & SWP_FS) {\n\t\tstruct file *swap_file = sis->swap_file;\n\t\tstruct address_space *mapping = swap_file->f_mapping;\n\n\t\tret = mapping->a_ops->readpage(swap_file, page);\n\t\tif (!ret)\n\t\t\tcount_vm_event(PSWPIN);\n\t\treturn ret;\n\t}\n\n\tret = bdev_read_page(sis->bdev, swap_page_sector(page), page);\n\tif (!ret) {\n\t\tif (trylock_page(page)) {\n\t\t\tswap_slot_free_notify(page);\n\t\t\tunlock_page(page);\n\t\t}\n\n\t\tcount_vm_event(PSWPIN);\n\t\treturn 0;\n\t}\n\n\tret = 0;\n\tbio = get_swap_bio(GFP_KERNEL, page, end_swap_bio_read);\n\tif (bio == NULL) {\n\t\tunlock_page(page);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tdisk = bio->bi_disk;\n\t/*\n\t * Keep this task valid during swap readpage because the oom killer may\n\t * attempt to access it in the page fault retry time check.\n\t */\n\tget_task_struct(current);\n\tbio->bi_private = current;\n\tbio_set_op_attrs(bio, REQ_OP_READ, 0);\n\tcount_vm_event(PSWPIN);\n\tbio_get(bio);\n\tqc = submit_bio(bio);\n\twhile (synchronous) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (!READ_ONCE(bio->bi_private))\n\t\t\tbreak;\n\n\t\tif (!blk_poll(disk->queue, qc))\n\t\t\tbreak;\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tbio_put(bio);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__read_swap_cache_async",
          "args": [
            "entry",
            "gfp_mask",
            "vma",
            "vmf->address",
            "&page_allocated"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "__read_swap_cache_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "353-429",
          "snippet": "struct page *__read_swap_cache_async(swp_entry_t entry, gfp_t gfp_mask,\n\t\t\tstruct vm_area_struct *vma, unsigned long addr,\n\t\t\tbool *new_page_allocated)\n{\n\tstruct page *found_page, *new_page = NULL;\n\tstruct address_space *swapper_space = swap_address_space(entry);\n\tint err;\n\t*new_page_allocated = false;\n\n\tdo {\n\t\t/*\n\t\t * First check the swap cache.  Since this is normally\n\t\t * called after lookup_swap_cache() failed, re-calling\n\t\t * that would confuse statistics.\n\t\t */\n\t\tfound_page = find_get_page(swapper_space, swp_offset(entry));\n\t\tif (found_page)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Just skip read ahead for unused swap slot.\n\t\t * During swap_off when swap_slot_cache is disabled,\n\t\t * we have to handle the race between putting\n\t\t * swap entry in swap cache and marking swap slot\n\t\t * as SWAP_HAS_CACHE.  That's done in later part of code or\n\t\t * else swap_off will be aborted if we return NULL.\n\t\t */\n\t\tif (!__swp_swapcount(entry) && swap_slot_cache_enabled)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Get a new page to read into from swap.\n\t\t */\n\t\tif (!new_page) {\n\t\t\tnew_page = alloc_page_vma(gfp_mask, vma, addr);\n\t\t\tif (!new_page)\n\t\t\t\tbreak;\t\t/* Out of memory */\n\t\t}\n\n\t\t/*\n\t\t * Swap entry may have been freed since our caller observed it.\n\t\t */\n\t\terr = swapcache_prepare(entry);\n\t\tif (err == -EEXIST) {\n\t\t\t/*\n\t\t\t * We might race against get_swap_page() and stumble\n\t\t\t * across a SWAP_HAS_CACHE swap_map entry whose page\n\t\t\t * has not been brought into the swapcache yet.\n\t\t\t */\n\t\t\tcond_resched();\n\t\t\tcontinue;\n\t\t} else if (err)\t\t/* swp entry is obsolete ? */\n\t\t\tbreak;\n\n\t\t/* May fail (-ENOMEM) if XArray node allocation failed. */\n\t\t__SetPageLocked(new_page);\n\t\t__SetPageSwapBacked(new_page);\n\t\terr = add_to_swap_cache(new_page, entry, gfp_mask & GFP_KERNEL);\n\t\tif (likely(!err)) {\n\t\t\t/* Initiate read into locked page */\n\t\t\tSetPageWorkingset(new_page);\n\t\t\tlru_cache_add_anon(new_page);\n\t\t\t*new_page_allocated = true;\n\t\t\treturn new_page;\n\t\t}\n\t\t__ClearPageLocked(new_page);\n\t\t/*\n\t\t * add_to_swap_cache() doesn't return -EEXIST, so we can safely\n\t\t * clear SWAP_HAS_CACHE flag.\n\t\t */\n\t\tput_swap_page(new_page, entry);\n\t} while (err != -ENOMEM);\n\n\tif (new_page)\n\t\tput_page(new_page);\n\treturn found_page;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstruct page *__read_swap_cache_async(swp_entry_t entry, gfp_t gfp_mask,\n\t\t\tstruct vm_area_struct *vma, unsigned long addr,\n\t\t\tbool *new_page_allocated)\n{\n\tstruct page *found_page, *new_page = NULL;\n\tstruct address_space *swapper_space = swap_address_space(entry);\n\tint err;\n\t*new_page_allocated = false;\n\n\tdo {\n\t\t/*\n\t\t * First check the swap cache.  Since this is normally\n\t\t * called after lookup_swap_cache() failed, re-calling\n\t\t * that would confuse statistics.\n\t\t */\n\t\tfound_page = find_get_page(swapper_space, swp_offset(entry));\n\t\tif (found_page)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Just skip read ahead for unused swap slot.\n\t\t * During swap_off when swap_slot_cache is disabled,\n\t\t * we have to handle the race between putting\n\t\t * swap entry in swap cache and marking swap slot\n\t\t * as SWAP_HAS_CACHE.  That's done in later part of code or\n\t\t * else swap_off will be aborted if we return NULL.\n\t\t */\n\t\tif (!__swp_swapcount(entry) && swap_slot_cache_enabled)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Get a new page to read into from swap.\n\t\t */\n\t\tif (!new_page) {\n\t\t\tnew_page = alloc_page_vma(gfp_mask, vma, addr);\n\t\t\tif (!new_page)\n\t\t\t\tbreak;\t\t/* Out of memory */\n\t\t}\n\n\t\t/*\n\t\t * Swap entry may have been freed since our caller observed it.\n\t\t */\n\t\terr = swapcache_prepare(entry);\n\t\tif (err == -EEXIST) {\n\t\t\t/*\n\t\t\t * We might race against get_swap_page() and stumble\n\t\t\t * across a SWAP_HAS_CACHE swap_map entry whose page\n\t\t\t * has not been brought into the swapcache yet.\n\t\t\t */\n\t\t\tcond_resched();\n\t\t\tcontinue;\n\t\t} else if (err)\t\t/* swp entry is obsolete ? */\n\t\t\tbreak;\n\n\t\t/* May fail (-ENOMEM) if XArray node allocation failed. */\n\t\t__SetPageLocked(new_page);\n\t\t__SetPageSwapBacked(new_page);\n\t\terr = add_to_swap_cache(new_page, entry, gfp_mask & GFP_KERNEL);\n\t\tif (likely(!err)) {\n\t\t\t/* Initiate read into locked page */\n\t\t\tSetPageWorkingset(new_page);\n\t\t\tlru_cache_add_anon(new_page);\n\t\t\t*new_page_allocated = true;\n\t\t\treturn new_page;\n\t\t}\n\t\t__ClearPageLocked(new_page);\n\t\t/*\n\t\t * add_to_swap_cache() doesn't return -EEXIST, so we can safely\n\t\t * clear SWAP_HAS_CACHE flag.\n\t\t */\n\t\tput_swap_page(new_page, entry);\n\t} while (err != -ENOMEM);\n\n\tif (new_page)\n\t\tput_page(new_page);\n\treturn found_page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "non_swap_entry(entry)"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "non_swap_entry",
          "args": [
            "entry"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_to_swp_entry",
          "args": [
            "pentry"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "pentry"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_none",
          "args": [
            "pentry"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_start_plug",
          "args": [
            "&plug"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_ra_info",
          "args": [
            "vmf",
            "&ra_info"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "swap_ra_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "626-692",
          "snippet": "static void swap_ra_info(struct vm_fault *vmf,\n\t\t\tstruct vma_swap_readahead *ra_info)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tunsigned long ra_val;\n\tswp_entry_t entry;\n\tunsigned long faddr, pfn, fpfn;\n\tunsigned long start, end;\n\tpte_t *pte, *orig_pte;\n\tunsigned int max_win, hits, prev_win, win, left;\n#ifndef CONFIG_64BIT\n\tpte_t *tpte;\n#endif\n\n\tmax_win = 1 << min_t(unsigned int, READ_ONCE(page_cluster),\n\t\t\t     SWAP_RA_ORDER_CEILING);\n\tif (max_win == 1) {\n\t\tra_info->win = 1;\n\t\treturn;\n\t}\n\n\tfaddr = vmf->address;\n\torig_pte = pte = pte_offset_map(vmf->pmd, faddr);\n\tentry = pte_to_swp_entry(*pte);\n\tif ((unlikely(non_swap_entry(entry)))) {\n\t\tpte_unmap(orig_pte);\n\t\treturn;\n\t}\n\n\tfpfn = PFN_DOWN(faddr);\n\tra_val = GET_SWAP_RA_VAL(vma);\n\tpfn = PFN_DOWN(SWAP_RA_ADDR(ra_val));\n\tprev_win = SWAP_RA_WIN(ra_val);\n\thits = SWAP_RA_HITS(ra_val);\n\tra_info->win = win = __swapin_nr_pages(pfn, fpfn, hits,\n\t\t\t\t\t       max_win, prev_win);\n\tatomic_long_set(&vma->swap_readahead_info,\n\t\t\tSWAP_RA_VAL(faddr, win, 0));\n\n\tif (win == 1) {\n\t\tpte_unmap(orig_pte);\n\t\treturn;\n\t}\n\n\t/* Copy the PTEs because the page table may be unmapped */\n\tif (fpfn == pfn + 1)\n\t\tswap_ra_clamp_pfn(vma, faddr, fpfn, fpfn + win, &start, &end);\n\telse if (pfn == fpfn + 1)\n\t\tswap_ra_clamp_pfn(vma, faddr, fpfn - win + 1, fpfn + 1,\n\t\t\t\t  &start, &end);\n\telse {\n\t\tleft = (win - 1) / 2;\n\t\tswap_ra_clamp_pfn(vma, faddr, fpfn - left, fpfn + win - left,\n\t\t\t\t  &start, &end);\n\t}\n\tra_info->nr_pte = end - start;\n\tra_info->offset = fpfn - start;\n\tpte -= ra_info->offset;\n#ifdef CONFIG_64BIT\n\tra_info->ptes = pte;\n#else\n\ttpte = ra_info->ptes;\n\tfor (pfn = start; pfn != end; pfn++)\n\t\t*tpte++ = *pte++;\n#endif\n\tpte_unmap(orig_pte);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstatic void swap_ra_info(struct vm_fault *vmf,\n\t\t\tstruct vma_swap_readahead *ra_info)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tunsigned long ra_val;\n\tswp_entry_t entry;\n\tunsigned long faddr, pfn, fpfn;\n\tunsigned long start, end;\n\tpte_t *pte, *orig_pte;\n\tunsigned int max_win, hits, prev_win, win, left;\n#ifndef CONFIG_64BIT\n\tpte_t *tpte;\n#endif\n\n\tmax_win = 1 << min_t(unsigned int, READ_ONCE(page_cluster),\n\t\t\t     SWAP_RA_ORDER_CEILING);\n\tif (max_win == 1) {\n\t\tra_info->win = 1;\n\t\treturn;\n\t}\n\n\tfaddr = vmf->address;\n\torig_pte = pte = pte_offset_map(vmf->pmd, faddr);\n\tentry = pte_to_swp_entry(*pte);\n\tif ((unlikely(non_swap_entry(entry)))) {\n\t\tpte_unmap(orig_pte);\n\t\treturn;\n\t}\n\n\tfpfn = PFN_DOWN(faddr);\n\tra_val = GET_SWAP_RA_VAL(vma);\n\tpfn = PFN_DOWN(SWAP_RA_ADDR(ra_val));\n\tprev_win = SWAP_RA_WIN(ra_val);\n\thits = SWAP_RA_HITS(ra_val);\n\tra_info->win = win = __swapin_nr_pages(pfn, fpfn, hits,\n\t\t\t\t\t       max_win, prev_win);\n\tatomic_long_set(&vma->swap_readahead_info,\n\t\t\tSWAP_RA_VAL(faddr, win, 0));\n\n\tif (win == 1) {\n\t\tpte_unmap(orig_pte);\n\t\treturn;\n\t}\n\n\t/* Copy the PTEs because the page table may be unmapped */\n\tif (fpfn == pfn + 1)\n\t\tswap_ra_clamp_pfn(vma, faddr, fpfn, fpfn + win, &start, &end);\n\telse if (pfn == fpfn + 1)\n\t\tswap_ra_clamp_pfn(vma, faddr, fpfn - win + 1, fpfn + 1,\n\t\t\t\t  &start, &end);\n\telse {\n\t\tleft = (win - 1) / 2;\n\t\tswap_ra_clamp_pfn(vma, faddr, fpfn - left, fpfn + win - left,\n\t\t\t\t  &start, &end);\n\t}\n\tra_info->nr_pte = end - start;\n\tra_info->offset = fpfn - start;\n\tpte -= ra_info->offset;\n#ifdef CONFIG_64BIT\n\tra_info->ptes = pte;\n#else\n\ttpte = ra_info->ptes;\n\tfor (pfn = start; pfn != end; pfn++)\n\t\t*tpte++ = *pte++;\n#endif\n\tpte_unmap(orig_pte);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstatic struct page *swap_vma_readahead(swp_entry_t fentry, gfp_t gfp_mask,\n\t\t\t\t       struct vm_fault *vmf)\n{\n\tstruct blk_plug plug;\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct page *page;\n\tpte_t *pte, pentry;\n\tswp_entry_t entry;\n\tunsigned int i;\n\tbool page_allocated;\n\tstruct vma_swap_readahead ra_info = {0,};\n\n\tswap_ra_info(vmf, &ra_info);\n\tif (ra_info.win == 1)\n\t\tgoto skip;\n\n\tblk_start_plug(&plug);\n\tfor (i = 0, pte = ra_info.ptes; i < ra_info.nr_pte;\n\t     i++, pte++) {\n\t\tpentry = *pte;\n\t\tif (pte_none(pentry))\n\t\t\tcontinue;\n\t\tif (pte_present(pentry))\n\t\t\tcontinue;\n\t\tentry = pte_to_swp_entry(pentry);\n\t\tif (unlikely(non_swap_entry(entry)))\n\t\t\tcontinue;\n\t\tpage = __read_swap_cache_async(entry, gfp_mask, vma,\n\t\t\t\t\t       vmf->address, &page_allocated);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (page_allocated) {\n\t\t\tswap_readpage(page, false);\n\t\t\tif (i != ra_info.offset) {\n\t\t\t\tSetPageReadahead(page);\n\t\t\t\tcount_vm_event(SWAP_RA);\n\t\t\t}\n\t\t}\n\t\tput_page(page);\n\t}\n\tblk_finish_plug(&plug);\n\tlru_add_drain();\nskip:\n\treturn read_swap_cache_async(fentry, gfp_mask, vma, vmf->address,\n\t\t\t\t     ra_info.win == 1);\n}"
  },
  {
    "function_name": "swap_ra_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
    "lines": "626-692",
    "snippet": "static void swap_ra_info(struct vm_fault *vmf,\n\t\t\tstruct vma_swap_readahead *ra_info)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tunsigned long ra_val;\n\tswp_entry_t entry;\n\tunsigned long faddr, pfn, fpfn;\n\tunsigned long start, end;\n\tpte_t *pte, *orig_pte;\n\tunsigned int max_win, hits, prev_win, win, left;\n#ifndef CONFIG_64BIT\n\tpte_t *tpte;\n#endif\n\n\tmax_win = 1 << min_t(unsigned int, READ_ONCE(page_cluster),\n\t\t\t     SWAP_RA_ORDER_CEILING);\n\tif (max_win == 1) {\n\t\tra_info->win = 1;\n\t\treturn;\n\t}\n\n\tfaddr = vmf->address;\n\torig_pte = pte = pte_offset_map(vmf->pmd, faddr);\n\tentry = pte_to_swp_entry(*pte);\n\tif ((unlikely(non_swap_entry(entry)))) {\n\t\tpte_unmap(orig_pte);\n\t\treturn;\n\t}\n\n\tfpfn = PFN_DOWN(faddr);\n\tra_val = GET_SWAP_RA_VAL(vma);\n\tpfn = PFN_DOWN(SWAP_RA_ADDR(ra_val));\n\tprev_win = SWAP_RA_WIN(ra_val);\n\thits = SWAP_RA_HITS(ra_val);\n\tra_info->win = win = __swapin_nr_pages(pfn, fpfn, hits,\n\t\t\t\t\t       max_win, prev_win);\n\tatomic_long_set(&vma->swap_readahead_info,\n\t\t\tSWAP_RA_VAL(faddr, win, 0));\n\n\tif (win == 1) {\n\t\tpte_unmap(orig_pte);\n\t\treturn;\n\t}\n\n\t/* Copy the PTEs because the page table may be unmapped */\n\tif (fpfn == pfn + 1)\n\t\tswap_ra_clamp_pfn(vma, faddr, fpfn, fpfn + win, &start, &end);\n\telse if (pfn == fpfn + 1)\n\t\tswap_ra_clamp_pfn(vma, faddr, fpfn - win + 1, fpfn + 1,\n\t\t\t\t  &start, &end);\n\telse {\n\t\tleft = (win - 1) / 2;\n\t\tswap_ra_clamp_pfn(vma, faddr, fpfn - left, fpfn + win - left,\n\t\t\t\t  &start, &end);\n\t}\n\tra_info->nr_pte = end - start;\n\tra_info->offset = fpfn - start;\n\tpte -= ra_info->offset;\n#ifdef CONFIG_64BIT\n\tra_info->ptes = pte;\n#else\n\ttpte = ra_info->ptes;\n\tfor (pfn = start; pfn != end; pfn++)\n\t\t*tpte++ = *pte++;\n#endif\n\tpte_unmap(orig_pte);\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/migrate.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_unmap",
          "args": [
            "orig_pte"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_ra_clamp_pfn",
          "args": [
            "vma",
            "faddr",
            "fpfn - left",
            "fpfn + win - left",
            "&start",
            "&end"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "swap_ra_clamp_pfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "613-624",
          "snippet": "static inline void swap_ra_clamp_pfn(struct vm_area_struct *vma,\n\t\t\t\t     unsigned long faddr,\n\t\t\t\t     unsigned long lpfn,\n\t\t\t\t     unsigned long rpfn,\n\t\t\t\t     unsigned long *start,\n\t\t\t\t     unsigned long *end)\n{\n\t*start = max3(lpfn, PFN_DOWN(vma->vm_start),\n\t\t      PFN_DOWN(faddr & PMD_MASK));\n\t*end = min3(rpfn, PFN_DOWN(vma->vm_end),\n\t\t    PFN_DOWN((faddr & PMD_MASK) + PMD_SIZE));\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstatic inline void swap_ra_clamp_pfn(struct vm_area_struct *vma,\n\t\t\t\t     unsigned long faddr,\n\t\t\t\t     unsigned long lpfn,\n\t\t\t\t     unsigned long rpfn,\n\t\t\t\t     unsigned long *start,\n\t\t\t\t     unsigned long *end)\n{\n\t*start = max3(lpfn, PFN_DOWN(vma->vm_start),\n\t\t      PFN_DOWN(faddr & PMD_MASK));\n\t*end = min3(rpfn, PFN_DOWN(vma->vm_end),\n\t\t    PFN_DOWN((faddr & PMD_MASK) + PMD_SIZE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_unmap",
          "args": [
            "orig_pte"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_set",
          "args": [
            "&vma->swap_readahead_info",
            "SWAP_RA_VAL(faddr, win, 0)"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SWAP_RA_VAL",
          "args": [
            "faddr",
            "win",
            "0"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__swapin_nr_pages",
          "args": [
            "pfn",
            "fpfn",
            "hits",
            "max_win",
            "prev_win"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "__swapin_nr_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "450-488",
          "snippet": "static unsigned int __swapin_nr_pages(unsigned long prev_offset,\n\t\t\t\t      unsigned long offset,\n\t\t\t\t      int hits,\n\t\t\t\t      int max_pages,\n\t\t\t\t      int prev_win)\n{\n\tunsigned int pages, last_ra;\n\n\t/*\n\t * This heuristic has been found to work well on both sequential and\n\t * random loads, swapping to hard disk or to SSD: please don't ask\n\t * what the \"+ 2\" means, it just happens to work well, that's all.\n\t */\n\tpages = hits + 2;\n\tif (pages == 2) {\n\t\t/*\n\t\t * We can have no readahead hits to judge by: but must not get\n\t\t * stuck here forever, so check for an adjacent offset instead\n\t\t * (and don't even bother to check whether swap type is same).\n\t\t */\n\t\tif (offset != prev_offset + 1 && offset != prev_offset - 1)\n\t\t\tpages = 1;\n\t} else {\n\t\tunsigned int roundup = 4;\n\t\twhile (roundup < pages)\n\t\t\troundup <<= 1;\n\t\tpages = roundup;\n\t}\n\n\tif (pages > max_pages)\n\t\tpages = max_pages;\n\n\t/* Don't shrink readahead too fast */\n\tlast_ra = prev_win / 2;\n\tif (pages < last_ra)\n\t\tpages = last_ra;\n\n\treturn pages;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstatic unsigned int __swapin_nr_pages(unsigned long prev_offset,\n\t\t\t\t      unsigned long offset,\n\t\t\t\t      int hits,\n\t\t\t\t      int max_pages,\n\t\t\t\t      int prev_win)\n{\n\tunsigned int pages, last_ra;\n\n\t/*\n\t * This heuristic has been found to work well on both sequential and\n\t * random loads, swapping to hard disk or to SSD: please don't ask\n\t * what the \"+ 2\" means, it just happens to work well, that's all.\n\t */\n\tpages = hits + 2;\n\tif (pages == 2) {\n\t\t/*\n\t\t * We can have no readahead hits to judge by: but must not get\n\t\t * stuck here forever, so check for an adjacent offset instead\n\t\t * (and don't even bother to check whether swap type is same).\n\t\t */\n\t\tif (offset != prev_offset + 1 && offset != prev_offset - 1)\n\t\t\tpages = 1;\n\t} else {\n\t\tunsigned int roundup = 4;\n\t\twhile (roundup < pages)\n\t\t\troundup <<= 1;\n\t\tpages = roundup;\n\t}\n\n\tif (pages > max_pages)\n\t\tpages = max_pages;\n\n\t/* Don't shrink readahead too fast */\n\tlast_ra = prev_win / 2;\n\tif (pages < last_ra)\n\t\tpages = last_ra;\n\n\treturn pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SWAP_RA_HITS",
          "args": [
            "ra_val"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SWAP_RA_WIN",
          "args": [
            "ra_val"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "SWAP_RA_ADDR(ra_val)"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SWAP_RA_ADDR",
          "args": [
            "ra_val"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SWAP_RA_VAL",
          "args": [
            "vma"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "faddr"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unmap",
          "args": [
            "orig_pte"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "non_swap_entry(entry)"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "non_swap_entry",
          "args": [
            "entry"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_to_swp_entry",
          "args": [
            "*pte"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_offset_map",
          "args": [
            "vmf->pmd",
            "faddr"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "READ_ONCE(page_cluster)",
            "SWAP_RA_ORDER_CEILING"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "page_cluster"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstatic void swap_ra_info(struct vm_fault *vmf,\n\t\t\tstruct vma_swap_readahead *ra_info)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tunsigned long ra_val;\n\tswp_entry_t entry;\n\tunsigned long faddr, pfn, fpfn;\n\tunsigned long start, end;\n\tpte_t *pte, *orig_pte;\n\tunsigned int max_win, hits, prev_win, win, left;\n#ifndef CONFIG_64BIT\n\tpte_t *tpte;\n#endif\n\n\tmax_win = 1 << min_t(unsigned int, READ_ONCE(page_cluster),\n\t\t\t     SWAP_RA_ORDER_CEILING);\n\tif (max_win == 1) {\n\t\tra_info->win = 1;\n\t\treturn;\n\t}\n\n\tfaddr = vmf->address;\n\torig_pte = pte = pte_offset_map(vmf->pmd, faddr);\n\tentry = pte_to_swp_entry(*pte);\n\tif ((unlikely(non_swap_entry(entry)))) {\n\t\tpte_unmap(orig_pte);\n\t\treturn;\n\t}\n\n\tfpfn = PFN_DOWN(faddr);\n\tra_val = GET_SWAP_RA_VAL(vma);\n\tpfn = PFN_DOWN(SWAP_RA_ADDR(ra_val));\n\tprev_win = SWAP_RA_WIN(ra_val);\n\thits = SWAP_RA_HITS(ra_val);\n\tra_info->win = win = __swapin_nr_pages(pfn, fpfn, hits,\n\t\t\t\t\t       max_win, prev_win);\n\tatomic_long_set(&vma->swap_readahead_info,\n\t\t\tSWAP_RA_VAL(faddr, win, 0));\n\n\tif (win == 1) {\n\t\tpte_unmap(orig_pte);\n\t\treturn;\n\t}\n\n\t/* Copy the PTEs because the page table may be unmapped */\n\tif (fpfn == pfn + 1)\n\t\tswap_ra_clamp_pfn(vma, faddr, fpfn, fpfn + win, &start, &end);\n\telse if (pfn == fpfn + 1)\n\t\tswap_ra_clamp_pfn(vma, faddr, fpfn - win + 1, fpfn + 1,\n\t\t\t\t  &start, &end);\n\telse {\n\t\tleft = (win - 1) / 2;\n\t\tswap_ra_clamp_pfn(vma, faddr, fpfn - left, fpfn + win - left,\n\t\t\t\t  &start, &end);\n\t}\n\tra_info->nr_pte = end - start;\n\tra_info->offset = fpfn - start;\n\tpte -= ra_info->offset;\n#ifdef CONFIG_64BIT\n\tra_info->ptes = pte;\n#else\n\ttpte = ra_info->ptes;\n\tfor (pfn = start; pfn != end; pfn++)\n\t\t*tpte++ = *pte++;\n#endif\n\tpte_unmap(orig_pte);\n}"
  },
  {
    "function_name": "swap_ra_clamp_pfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
    "lines": "613-624",
    "snippet": "static inline void swap_ra_clamp_pfn(struct vm_area_struct *vma,\n\t\t\t\t     unsigned long faddr,\n\t\t\t\t     unsigned long lpfn,\n\t\t\t\t     unsigned long rpfn,\n\t\t\t\t     unsigned long *start,\n\t\t\t\t     unsigned long *end)\n{\n\t*start = max3(lpfn, PFN_DOWN(vma->vm_start),\n\t\t      PFN_DOWN(faddr & PMD_MASK));\n\t*end = min3(rpfn, PFN_DOWN(vma->vm_end),\n\t\t    PFN_DOWN((faddr & PMD_MASK) + PMD_SIZE));\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/migrate.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min3",
          "args": [
            "rpfn",
            "PFN_DOWN(vma->vm_end)",
            "PFN_DOWN((faddr & PMD_MASK) + PMD_SIZE)"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "(faddr & PMD_MASK) + PMD_SIZE"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "vma->vm_end"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max3",
          "args": [
            "lpfn",
            "PFN_DOWN(vma->vm_start)",
            "PFN_DOWN(faddr & PMD_MASK)"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "faddr & PMD_MASK"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "vma->vm_start"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstatic inline void swap_ra_clamp_pfn(struct vm_area_struct *vma,\n\t\t\t\t     unsigned long faddr,\n\t\t\t\t     unsigned long lpfn,\n\t\t\t\t     unsigned long rpfn,\n\t\t\t\t     unsigned long *start,\n\t\t\t\t     unsigned long *end)\n{\n\t*start = max3(lpfn, PFN_DOWN(vma->vm_start),\n\t\t      PFN_DOWN(faddr & PMD_MASK));\n\t*end = min3(rpfn, PFN_DOWN(vma->vm_end),\n\t\t    PFN_DOWN((faddr & PMD_MASK) + PMD_SIZE));\n}"
  },
  {
    "function_name": "exit_swap_address_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
    "lines": "602-611",
    "snippet": "void exit_swap_address_space(unsigned int type)\n{\n\tstruct address_space *spaces;\n\n\tspaces = swapper_spaces[type];\n\tnr_swapper_spaces[type] = 0;\n\trcu_assign_pointer(swapper_spaces[type], NULL);\n\tsynchronize_rcu();\n\tkvfree(spaces);\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/migrate.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct address_space *swapper_spaces[MAX_SWAPFILES]",
      "static unsigned int nr_swapper_spaces[MAX_SWAPFILES]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "spaces"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "kvfree_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "395-401",
          "snippet": "static void kvfree_rcu(struct rcu_head *head)\n{\n\tstruct list_lru_memcg *mlru;\n\n\tmlru = container_of(head, struct list_lru_memcg, rcu);\n\tkvfree(mlru);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void kvfree_rcu(struct rcu_head *head)\n{\n\tstruct list_lru_memcg *mlru;\n\n\tmlru = container_of(head, struct list_lru_memcg, rcu);\n\tkvfree(mlru);\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "swapper_spaces[type]",
            "NULL"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstruct address_space *swapper_spaces[MAX_SWAPFILES];\nstatic unsigned int nr_swapper_spaces[MAX_SWAPFILES];\n\nvoid exit_swap_address_space(unsigned int type)\n{\n\tstruct address_space *spaces;\n\n\tspaces = swapper_spaces[type];\n\tnr_swapper_spaces[type] = 0;\n\trcu_assign_pointer(swapper_spaces[type], NULL);\n\tsynchronize_rcu();\n\tkvfree(spaces);\n}"
  },
  {
    "function_name": "init_swap_address_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
    "lines": "579-600",
    "snippet": "int init_swap_address_space(unsigned int type, unsigned long nr_pages)\n{\n\tstruct address_space *spaces, *space;\n\tunsigned int i, nr;\n\n\tnr = DIV_ROUND_UP(nr_pages, SWAP_ADDRESS_SPACE_PAGES);\n\tspaces = kvcalloc(nr, sizeof(struct address_space), GFP_KERNEL);\n\tif (!spaces)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < nr; i++) {\n\t\tspace = spaces + i;\n\t\txa_init_flags(&space->i_pages, XA_FLAGS_LOCK_IRQ);\n\t\tatomic_set(&space->i_mmap_writable, 0);\n\t\tspace->a_ops = &swap_aops;\n\t\t/* swap cache doesn't use writeback related tags */\n\t\tmapping_set_no_writeback_tags(space);\n\t}\n\tnr_swapper_spaces[type] = nr;\n\trcu_assign_pointer(swapper_spaces[type], spaces);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/migrate.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct address_space_operations swap_aops = {\n\t.writepage\t= swap_writepage,\n\t.set_page_dirty\t= swap_set_page_dirty,\n#ifdef CONFIG_MIGRATION\n\t.migratepage\t= migrate_page,\n#endif\n};",
      "struct address_space *swapper_spaces[MAX_SWAPFILES]",
      "static unsigned int nr_swapper_spaces[MAX_SWAPFILES]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "swapper_spaces[type]",
            "spaces"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_set_no_writeback_tags",
          "args": [
            "space"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&space->i_mmap_writable",
            "0"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_init_flags",
          "args": [
            "&space->i_pages",
            "XA_FLAGS_LOCK_IRQ"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvcalloc",
          "args": [
            "nr",
            "sizeof(struct address_space)",
            "GFP_KERNEL"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "nr_pages",
            "SWAP_ADDRESS_SPACE_PAGES"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstatic const struct address_space_operations swap_aops = {\n\t.writepage\t= swap_writepage,\n\t.set_page_dirty\t= swap_set_page_dirty,\n#ifdef CONFIG_MIGRATION\n\t.migratepage\t= migrate_page,\n#endif\n};\nstruct address_space *swapper_spaces[MAX_SWAPFILES];\nstatic unsigned int nr_swapper_spaces[MAX_SWAPFILES];\n\nint init_swap_address_space(unsigned int type, unsigned long nr_pages)\n{\n\tstruct address_space *spaces, *space;\n\tunsigned int i, nr;\n\n\tnr = DIV_ROUND_UP(nr_pages, SWAP_ADDRESS_SPACE_PAGES);\n\tspaces = kvcalloc(nr, sizeof(struct address_space), GFP_KERNEL);\n\tif (!spaces)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < nr; i++) {\n\t\tspace = spaces + i;\n\t\txa_init_flags(&space->i_pages, XA_FLAGS_LOCK_IRQ);\n\t\tatomic_set(&space->i_mmap_writable, 0);\n\t\tspace->a_ops = &swap_aops;\n\t\t/* swap cache doesn't use writeback related tags */\n\t\tmapping_set_no_writeback_tags(space);\n\t}\n\tnr_swapper_spaces[type] = nr;\n\trcu_assign_pointer(swapper_spaces[type], spaces);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "swap_cluster_readahead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
    "lines": "528-577",
    "snippet": "struct page *swap_cluster_readahead(swp_entry_t entry, gfp_t gfp_mask,\n\t\t\t\tstruct vm_fault *vmf)\n{\n\tstruct page *page;\n\tunsigned long entry_offset = swp_offset(entry);\n\tunsigned long offset = entry_offset;\n\tunsigned long start_offset, end_offset;\n\tunsigned long mask;\n\tstruct swap_info_struct *si = swp_swap_info(entry);\n\tstruct blk_plug plug;\n\tbool do_poll = true, page_allocated;\n\tstruct vm_area_struct *vma = vmf->vma;\n\tunsigned long addr = vmf->address;\n\n\tmask = swapin_nr_pages(offset) - 1;\n\tif (!mask)\n\t\tgoto skip;\n\n\tdo_poll = false;\n\t/* Read a page_cluster sized and aligned cluster around offset. */\n\tstart_offset = offset & ~mask;\n\tend_offset = offset | mask;\n\tif (!start_offset)\t/* First page is swap header. */\n\t\tstart_offset++;\n\tif (end_offset >= si->max)\n\t\tend_offset = si->max - 1;\n\n\tblk_start_plug(&plug);\n\tfor (offset = start_offset; offset <= end_offset ; offset++) {\n\t\t/* Ok, do the async read-ahead now */\n\t\tpage = __read_swap_cache_async(\n\t\t\tswp_entry(swp_type(entry), offset),\n\t\t\tgfp_mask, vma, addr, &page_allocated);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (page_allocated) {\n\t\t\tswap_readpage(page, false);\n\t\t\tif (offset != entry_offset) {\n\t\t\t\tSetPageReadahead(page);\n\t\t\t\tcount_vm_event(SWAP_RA);\n\t\t\t}\n\t\t}\n\t\tput_page(page);\n\t}\n\tblk_finish_plug(&plug);\n\n\tlru_add_drain();\t/* Push any new pages onto the LRU now */\nskip:\n\treturn read_swap_cache_async(entry, gfp_mask, vma, addr, do_poll);\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/migrate.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_swap_cache_async",
          "args": [
            "entry",
            "gfp_mask",
            "vma",
            "addr",
            "do_poll"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "read_swap_cache_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "437-448",
          "snippet": "struct page *read_swap_cache_async(swp_entry_t entry, gfp_t gfp_mask,\n\t\tstruct vm_area_struct *vma, unsigned long addr, bool do_poll)\n{\n\tbool page_was_allocated;\n\tstruct page *retpage = __read_swap_cache_async(entry, gfp_mask,\n\t\t\tvma, addr, &page_was_allocated);\n\n\tif (page_was_allocated)\n\t\tswap_readpage(retpage, do_poll);\n\n\treturn retpage;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstruct page *read_swap_cache_async(swp_entry_t entry, gfp_t gfp_mask,\n\t\tstruct vm_area_struct *vma, unsigned long addr, bool do_poll)\n{\n\tbool page_was_allocated;\n\tstruct page *retpage = __read_swap_cache_async(entry, gfp_mask,\n\t\t\tvma, addr, &page_was_allocated);\n\n\tif (page_was_allocated)\n\t\tswap_readpage(retpage, do_poll);\n\n\treturn retpage;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lru_add_drain",
          "args": [],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "lru_add_drain_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "670-704",
          "snippet": "void lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);",
            "static DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);",
            "static DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\nstatic DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);\nstatic DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);\n\nvoid lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "SWAP_RA"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageReadahead",
          "args": [
            "page"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_readpage",
          "args": [
            "page",
            "false"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "swap_readpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_io.c",
          "lines": "351-420",
          "snippet": "int swap_readpage(struct page *page, bool synchronous)\n{\n\tstruct bio *bio;\n\tint ret = 0;\n\tstruct swap_info_struct *sis = page_swap_info(page);\n\tblk_qc_t qc;\n\tstruct gendisk *disk;\n\n\tVM_BUG_ON_PAGE(!PageSwapCache(page) && !synchronous, page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(PageUptodate(page), page);\n\tif (frontswap_load(page) == 0) {\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\tgoto out;\n\t}\n\n\tif (sis->flags & SWP_FS) {\n\t\tstruct file *swap_file = sis->swap_file;\n\t\tstruct address_space *mapping = swap_file->f_mapping;\n\n\t\tret = mapping->a_ops->readpage(swap_file, page);\n\t\tif (!ret)\n\t\t\tcount_vm_event(PSWPIN);\n\t\treturn ret;\n\t}\n\n\tret = bdev_read_page(sis->bdev, swap_page_sector(page), page);\n\tif (!ret) {\n\t\tif (trylock_page(page)) {\n\t\t\tswap_slot_free_notify(page);\n\t\t\tunlock_page(page);\n\t\t}\n\n\t\tcount_vm_event(PSWPIN);\n\t\treturn 0;\n\t}\n\n\tret = 0;\n\tbio = get_swap_bio(GFP_KERNEL, page, end_swap_bio_read);\n\tif (bio == NULL) {\n\t\tunlock_page(page);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tdisk = bio->bi_disk;\n\t/*\n\t * Keep this task valid during swap readpage because the oom killer may\n\t * attempt to access it in the page fault retry time check.\n\t */\n\tget_task_struct(current);\n\tbio->bi_private = current;\n\tbio_set_op_attrs(bio, REQ_OP_READ, 0);\n\tcount_vm_event(PSWPIN);\n\tbio_get(bio);\n\tqc = submit_bio(bio);\n\twhile (synchronous) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (!READ_ONCE(bio->bi_private))\n\t\t\tbreak;\n\n\t\tif (!blk_poll(disk->queue, qc))\n\t\t\tbreak;\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tbio_put(bio);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/swapops.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/sched/task.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/frontswap.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swapops.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/mm.h>\n\nint swap_readpage(struct page *page, bool synchronous)\n{\n\tstruct bio *bio;\n\tint ret = 0;\n\tstruct swap_info_struct *sis = page_swap_info(page);\n\tblk_qc_t qc;\n\tstruct gendisk *disk;\n\n\tVM_BUG_ON_PAGE(!PageSwapCache(page) && !synchronous, page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(PageUptodate(page), page);\n\tif (frontswap_load(page) == 0) {\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\tgoto out;\n\t}\n\n\tif (sis->flags & SWP_FS) {\n\t\tstruct file *swap_file = sis->swap_file;\n\t\tstruct address_space *mapping = swap_file->f_mapping;\n\n\t\tret = mapping->a_ops->readpage(swap_file, page);\n\t\tif (!ret)\n\t\t\tcount_vm_event(PSWPIN);\n\t\treturn ret;\n\t}\n\n\tret = bdev_read_page(sis->bdev, swap_page_sector(page), page);\n\tif (!ret) {\n\t\tif (trylock_page(page)) {\n\t\t\tswap_slot_free_notify(page);\n\t\t\tunlock_page(page);\n\t\t}\n\n\t\tcount_vm_event(PSWPIN);\n\t\treturn 0;\n\t}\n\n\tret = 0;\n\tbio = get_swap_bio(GFP_KERNEL, page, end_swap_bio_read);\n\tif (bio == NULL) {\n\t\tunlock_page(page);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tdisk = bio->bi_disk;\n\t/*\n\t * Keep this task valid during swap readpage because the oom killer may\n\t * attempt to access it in the page fault retry time check.\n\t */\n\tget_task_struct(current);\n\tbio->bi_private = current;\n\tbio_set_op_attrs(bio, REQ_OP_READ, 0);\n\tcount_vm_event(PSWPIN);\n\tbio_get(bio);\n\tqc = submit_bio(bio);\n\twhile (synchronous) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (!READ_ONCE(bio->bi_private))\n\t\t\tbreak;\n\n\t\tif (!blk_poll(disk->queue, qc))\n\t\t\tbreak;\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tbio_put(bio);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__read_swap_cache_async",
          "args": [
            "swp_entry(swp_type(entry), offset)",
            "gfp_mask",
            "vma",
            "addr",
            "&page_allocated"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "__read_swap_cache_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "353-429",
          "snippet": "struct page *__read_swap_cache_async(swp_entry_t entry, gfp_t gfp_mask,\n\t\t\tstruct vm_area_struct *vma, unsigned long addr,\n\t\t\tbool *new_page_allocated)\n{\n\tstruct page *found_page, *new_page = NULL;\n\tstruct address_space *swapper_space = swap_address_space(entry);\n\tint err;\n\t*new_page_allocated = false;\n\n\tdo {\n\t\t/*\n\t\t * First check the swap cache.  Since this is normally\n\t\t * called after lookup_swap_cache() failed, re-calling\n\t\t * that would confuse statistics.\n\t\t */\n\t\tfound_page = find_get_page(swapper_space, swp_offset(entry));\n\t\tif (found_page)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Just skip read ahead for unused swap slot.\n\t\t * During swap_off when swap_slot_cache is disabled,\n\t\t * we have to handle the race between putting\n\t\t * swap entry in swap cache and marking swap slot\n\t\t * as SWAP_HAS_CACHE.  That's done in later part of code or\n\t\t * else swap_off will be aborted if we return NULL.\n\t\t */\n\t\tif (!__swp_swapcount(entry) && swap_slot_cache_enabled)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Get a new page to read into from swap.\n\t\t */\n\t\tif (!new_page) {\n\t\t\tnew_page = alloc_page_vma(gfp_mask, vma, addr);\n\t\t\tif (!new_page)\n\t\t\t\tbreak;\t\t/* Out of memory */\n\t\t}\n\n\t\t/*\n\t\t * Swap entry may have been freed since our caller observed it.\n\t\t */\n\t\terr = swapcache_prepare(entry);\n\t\tif (err == -EEXIST) {\n\t\t\t/*\n\t\t\t * We might race against get_swap_page() and stumble\n\t\t\t * across a SWAP_HAS_CACHE swap_map entry whose page\n\t\t\t * has not been brought into the swapcache yet.\n\t\t\t */\n\t\t\tcond_resched();\n\t\t\tcontinue;\n\t\t} else if (err)\t\t/* swp entry is obsolete ? */\n\t\t\tbreak;\n\n\t\t/* May fail (-ENOMEM) if XArray node allocation failed. */\n\t\t__SetPageLocked(new_page);\n\t\t__SetPageSwapBacked(new_page);\n\t\terr = add_to_swap_cache(new_page, entry, gfp_mask & GFP_KERNEL);\n\t\tif (likely(!err)) {\n\t\t\t/* Initiate read into locked page */\n\t\t\tSetPageWorkingset(new_page);\n\t\t\tlru_cache_add_anon(new_page);\n\t\t\t*new_page_allocated = true;\n\t\t\treturn new_page;\n\t\t}\n\t\t__ClearPageLocked(new_page);\n\t\t/*\n\t\t * add_to_swap_cache() doesn't return -EEXIST, so we can safely\n\t\t * clear SWAP_HAS_CACHE flag.\n\t\t */\n\t\tput_swap_page(new_page, entry);\n\t} while (err != -ENOMEM);\n\n\tif (new_page)\n\t\tput_page(new_page);\n\treturn found_page;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstruct page *__read_swap_cache_async(swp_entry_t entry, gfp_t gfp_mask,\n\t\t\tstruct vm_area_struct *vma, unsigned long addr,\n\t\t\tbool *new_page_allocated)\n{\n\tstruct page *found_page, *new_page = NULL;\n\tstruct address_space *swapper_space = swap_address_space(entry);\n\tint err;\n\t*new_page_allocated = false;\n\n\tdo {\n\t\t/*\n\t\t * First check the swap cache.  Since this is normally\n\t\t * called after lookup_swap_cache() failed, re-calling\n\t\t * that would confuse statistics.\n\t\t */\n\t\tfound_page = find_get_page(swapper_space, swp_offset(entry));\n\t\tif (found_page)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Just skip read ahead for unused swap slot.\n\t\t * During swap_off when swap_slot_cache is disabled,\n\t\t * we have to handle the race between putting\n\t\t * swap entry in swap cache and marking swap slot\n\t\t * as SWAP_HAS_CACHE.  That's done in later part of code or\n\t\t * else swap_off will be aborted if we return NULL.\n\t\t */\n\t\tif (!__swp_swapcount(entry) && swap_slot_cache_enabled)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Get a new page to read into from swap.\n\t\t */\n\t\tif (!new_page) {\n\t\t\tnew_page = alloc_page_vma(gfp_mask, vma, addr);\n\t\t\tif (!new_page)\n\t\t\t\tbreak;\t\t/* Out of memory */\n\t\t}\n\n\t\t/*\n\t\t * Swap entry may have been freed since our caller observed it.\n\t\t */\n\t\terr = swapcache_prepare(entry);\n\t\tif (err == -EEXIST) {\n\t\t\t/*\n\t\t\t * We might race against get_swap_page() and stumble\n\t\t\t * across a SWAP_HAS_CACHE swap_map entry whose page\n\t\t\t * has not been brought into the swapcache yet.\n\t\t\t */\n\t\t\tcond_resched();\n\t\t\tcontinue;\n\t\t} else if (err)\t\t/* swp entry is obsolete ? */\n\t\t\tbreak;\n\n\t\t/* May fail (-ENOMEM) if XArray node allocation failed. */\n\t\t__SetPageLocked(new_page);\n\t\t__SetPageSwapBacked(new_page);\n\t\terr = add_to_swap_cache(new_page, entry, gfp_mask & GFP_KERNEL);\n\t\tif (likely(!err)) {\n\t\t\t/* Initiate read into locked page */\n\t\t\tSetPageWorkingset(new_page);\n\t\t\tlru_cache_add_anon(new_page);\n\t\t\t*new_page_allocated = true;\n\t\t\treturn new_page;\n\t\t}\n\t\t__ClearPageLocked(new_page);\n\t\t/*\n\t\t * add_to_swap_cache() doesn't return -EEXIST, so we can safely\n\t\t * clear SWAP_HAS_CACHE flag.\n\t\t */\n\t\tput_swap_page(new_page, entry);\n\t} while (err != -ENOMEM);\n\n\tif (new_page)\n\t\tput_page(new_page);\n\treturn found_page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "swp_entry",
          "args": [
            "swp_type(entry)",
            "offset"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "swp_entry_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1289-1294",
          "snippet": "static int swp_entry_cmp(const void *ent1, const void *ent2)\n{\n\tconst swp_entry_t *e1 = ent1, *e2 = ent2;\n\n\treturn (int)swp_type(*e1) - (int)swp_type(*e2);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic int swp_entry_cmp(const void *ent1, const void *ent2)\n{\n\tconst swp_entry_t *e1 = ent1, *e2 = ent2;\n\n\treturn (int)swp_type(*e1) - (int)swp_type(*e2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swp_type",
          "args": [
            "entry"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_start_plug",
          "args": [
            "&plug"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swapin_nr_pages",
          "args": [
            "offset"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "swapin_nr_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "490-508",
          "snippet": "static unsigned long swapin_nr_pages(unsigned long offset)\n{\n\tstatic unsigned long prev_offset;\n\tunsigned int hits, pages, max_pages;\n\tstatic atomic_t last_readahead_pages;\n\n\tmax_pages = 1 << READ_ONCE(page_cluster);\n\tif (max_pages <= 1)\n\t\treturn 1;\n\n\thits = atomic_xchg(&swapin_readahead_hits, 0);\n\tpages = __swapin_nr_pages(prev_offset, offset, hits, max_pages,\n\t\t\t\t  atomic_read(&last_readahead_pages));\n\tif (!hits)\n\t\tprev_offset = offset;\n\tatomic_set(&last_readahead_pages, pages);\n\n\treturn pages;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t swapin_readahead_hits = ATOMIC_INIT(4);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstatic atomic_t swapin_readahead_hits = ATOMIC_INIT(4);\n\nstatic unsigned long swapin_nr_pages(unsigned long offset)\n{\n\tstatic unsigned long prev_offset;\n\tunsigned int hits, pages, max_pages;\n\tstatic atomic_t last_readahead_pages;\n\n\tmax_pages = 1 << READ_ONCE(page_cluster);\n\tif (max_pages <= 1)\n\t\treturn 1;\n\n\thits = atomic_xchg(&swapin_readahead_hits, 0);\n\tpages = __swapin_nr_pages(prev_offset, offset, hits, max_pages,\n\t\t\t\t  atomic_read(&last_readahead_pages));\n\tif (!hits)\n\t\tprev_offset = offset;\n\tatomic_set(&last_readahead_pages, pages);\n\n\treturn pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "swp_swap_info",
          "args": [
            "entry"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "swp_swap_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "3465-3468",
          "snippet": "struct swap_info_struct *swp_swap_info(swp_entry_t entry)\n{\n\treturn swap_info[swp_type(entry)];\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);",
            "struct swap_info_struct *swap_info[MAX_SWAPFILES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\nstruct swap_info_struct *swap_info[MAX_SWAPFILES];\n\nstruct swap_info_struct *swp_swap_info(swp_entry_t entry)\n{\n\treturn swap_info[swp_type(entry)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "swp_offset",
          "args": [
            "entry"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstruct page *swap_cluster_readahead(swp_entry_t entry, gfp_t gfp_mask,\n\t\t\t\tstruct vm_fault *vmf)\n{\n\tstruct page *page;\n\tunsigned long entry_offset = swp_offset(entry);\n\tunsigned long offset = entry_offset;\n\tunsigned long start_offset, end_offset;\n\tunsigned long mask;\n\tstruct swap_info_struct *si = swp_swap_info(entry);\n\tstruct blk_plug plug;\n\tbool do_poll = true, page_allocated;\n\tstruct vm_area_struct *vma = vmf->vma;\n\tunsigned long addr = vmf->address;\n\n\tmask = swapin_nr_pages(offset) - 1;\n\tif (!mask)\n\t\tgoto skip;\n\n\tdo_poll = false;\n\t/* Read a page_cluster sized and aligned cluster around offset. */\n\tstart_offset = offset & ~mask;\n\tend_offset = offset | mask;\n\tif (!start_offset)\t/* First page is swap header. */\n\t\tstart_offset++;\n\tif (end_offset >= si->max)\n\t\tend_offset = si->max - 1;\n\n\tblk_start_plug(&plug);\n\tfor (offset = start_offset; offset <= end_offset ; offset++) {\n\t\t/* Ok, do the async read-ahead now */\n\t\tpage = __read_swap_cache_async(\n\t\t\tswp_entry(swp_type(entry), offset),\n\t\t\tgfp_mask, vma, addr, &page_allocated);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (page_allocated) {\n\t\t\tswap_readpage(page, false);\n\t\t\tif (offset != entry_offset) {\n\t\t\t\tSetPageReadahead(page);\n\t\t\t\tcount_vm_event(SWAP_RA);\n\t\t\t}\n\t\t}\n\t\tput_page(page);\n\t}\n\tblk_finish_plug(&plug);\n\n\tlru_add_drain();\t/* Push any new pages onto the LRU now */\nskip:\n\treturn read_swap_cache_async(entry, gfp_mask, vma, addr, do_poll);\n}"
  },
  {
    "function_name": "swapin_nr_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
    "lines": "490-508",
    "snippet": "static unsigned long swapin_nr_pages(unsigned long offset)\n{\n\tstatic unsigned long prev_offset;\n\tunsigned int hits, pages, max_pages;\n\tstatic atomic_t last_readahead_pages;\n\n\tmax_pages = 1 << READ_ONCE(page_cluster);\n\tif (max_pages <= 1)\n\t\treturn 1;\n\n\thits = atomic_xchg(&swapin_readahead_hits, 0);\n\tpages = __swapin_nr_pages(prev_offset, offset, hits, max_pages,\n\t\t\t\t  atomic_read(&last_readahead_pages));\n\tif (!hits)\n\t\tprev_offset = offset;\n\tatomic_set(&last_readahead_pages, pages);\n\n\treturn pages;\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/migrate.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t swapin_readahead_hits = ATOMIC_INIT(4);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&last_readahead_pages",
            "pages"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__swapin_nr_pages",
          "args": [
            "prev_offset",
            "offset",
            "hits",
            "max_pages",
            "atomic_read(&last_readahead_pages)"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "__swapin_nr_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "450-488",
          "snippet": "static unsigned int __swapin_nr_pages(unsigned long prev_offset,\n\t\t\t\t      unsigned long offset,\n\t\t\t\t      int hits,\n\t\t\t\t      int max_pages,\n\t\t\t\t      int prev_win)\n{\n\tunsigned int pages, last_ra;\n\n\t/*\n\t * This heuristic has been found to work well on both sequential and\n\t * random loads, swapping to hard disk or to SSD: please don't ask\n\t * what the \"+ 2\" means, it just happens to work well, that's all.\n\t */\n\tpages = hits + 2;\n\tif (pages == 2) {\n\t\t/*\n\t\t * We can have no readahead hits to judge by: but must not get\n\t\t * stuck here forever, so check for an adjacent offset instead\n\t\t * (and don't even bother to check whether swap type is same).\n\t\t */\n\t\tif (offset != prev_offset + 1 && offset != prev_offset - 1)\n\t\t\tpages = 1;\n\t} else {\n\t\tunsigned int roundup = 4;\n\t\twhile (roundup < pages)\n\t\t\troundup <<= 1;\n\t\tpages = roundup;\n\t}\n\n\tif (pages > max_pages)\n\t\tpages = max_pages;\n\n\t/* Don't shrink readahead too fast */\n\tlast_ra = prev_win / 2;\n\tif (pages < last_ra)\n\t\tpages = last_ra;\n\n\treturn pages;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstatic unsigned int __swapin_nr_pages(unsigned long prev_offset,\n\t\t\t\t      unsigned long offset,\n\t\t\t\t      int hits,\n\t\t\t\t      int max_pages,\n\t\t\t\t      int prev_win)\n{\n\tunsigned int pages, last_ra;\n\n\t/*\n\t * This heuristic has been found to work well on both sequential and\n\t * random loads, swapping to hard disk or to SSD: please don't ask\n\t * what the \"+ 2\" means, it just happens to work well, that's all.\n\t */\n\tpages = hits + 2;\n\tif (pages == 2) {\n\t\t/*\n\t\t * We can have no readahead hits to judge by: but must not get\n\t\t * stuck here forever, so check for an adjacent offset instead\n\t\t * (and don't even bother to check whether swap type is same).\n\t\t */\n\t\tif (offset != prev_offset + 1 && offset != prev_offset - 1)\n\t\t\tpages = 1;\n\t} else {\n\t\tunsigned int roundup = 4;\n\t\twhile (roundup < pages)\n\t\t\troundup <<= 1;\n\t\tpages = roundup;\n\t}\n\n\tif (pages > max_pages)\n\t\tpages = max_pages;\n\n\t/* Don't shrink readahead too fast */\n\tlast_ra = prev_win / 2;\n\tif (pages < last_ra)\n\t\tpages = last_ra;\n\n\treturn pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&last_readahead_pages"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_xchg",
          "args": [
            "&swapin_readahead_hits",
            "0"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "page_cluster"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstatic atomic_t swapin_readahead_hits = ATOMIC_INIT(4);\n\nstatic unsigned long swapin_nr_pages(unsigned long offset)\n{\n\tstatic unsigned long prev_offset;\n\tunsigned int hits, pages, max_pages;\n\tstatic atomic_t last_readahead_pages;\n\n\tmax_pages = 1 << READ_ONCE(page_cluster);\n\tif (max_pages <= 1)\n\t\treturn 1;\n\n\thits = atomic_xchg(&swapin_readahead_hits, 0);\n\tpages = __swapin_nr_pages(prev_offset, offset, hits, max_pages,\n\t\t\t\t  atomic_read(&last_readahead_pages));\n\tif (!hits)\n\t\tprev_offset = offset;\n\tatomic_set(&last_readahead_pages, pages);\n\n\treturn pages;\n}"
  },
  {
    "function_name": "__swapin_nr_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
    "lines": "450-488",
    "snippet": "static unsigned int __swapin_nr_pages(unsigned long prev_offset,\n\t\t\t\t      unsigned long offset,\n\t\t\t\t      int hits,\n\t\t\t\t      int max_pages,\n\t\t\t\t      int prev_win)\n{\n\tunsigned int pages, last_ra;\n\n\t/*\n\t * This heuristic has been found to work well on both sequential and\n\t * random loads, swapping to hard disk or to SSD: please don't ask\n\t * what the \"+ 2\" means, it just happens to work well, that's all.\n\t */\n\tpages = hits + 2;\n\tif (pages == 2) {\n\t\t/*\n\t\t * We can have no readahead hits to judge by: but must not get\n\t\t * stuck here forever, so check for an adjacent offset instead\n\t\t * (and don't even bother to check whether swap type is same).\n\t\t */\n\t\tif (offset != prev_offset + 1 && offset != prev_offset - 1)\n\t\t\tpages = 1;\n\t} else {\n\t\tunsigned int roundup = 4;\n\t\twhile (roundup < pages)\n\t\t\troundup <<= 1;\n\t\tpages = roundup;\n\t}\n\n\tif (pages > max_pages)\n\t\tpages = max_pages;\n\n\t/* Don't shrink readahead too fast */\n\tlast_ra = prev_win / 2;\n\tif (pages < last_ra)\n\t\tpages = last_ra;\n\n\treturn pages;\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/migrate.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstatic unsigned int __swapin_nr_pages(unsigned long prev_offset,\n\t\t\t\t      unsigned long offset,\n\t\t\t\t      int hits,\n\t\t\t\t      int max_pages,\n\t\t\t\t      int prev_win)\n{\n\tunsigned int pages, last_ra;\n\n\t/*\n\t * This heuristic has been found to work well on both sequential and\n\t * random loads, swapping to hard disk or to SSD: please don't ask\n\t * what the \"+ 2\" means, it just happens to work well, that's all.\n\t */\n\tpages = hits + 2;\n\tif (pages == 2) {\n\t\t/*\n\t\t * We can have no readahead hits to judge by: but must not get\n\t\t * stuck here forever, so check for an adjacent offset instead\n\t\t * (and don't even bother to check whether swap type is same).\n\t\t */\n\t\tif (offset != prev_offset + 1 && offset != prev_offset - 1)\n\t\t\tpages = 1;\n\t} else {\n\t\tunsigned int roundup = 4;\n\t\twhile (roundup < pages)\n\t\t\troundup <<= 1;\n\t\tpages = roundup;\n\t}\n\n\tif (pages > max_pages)\n\t\tpages = max_pages;\n\n\t/* Don't shrink readahead too fast */\n\tlast_ra = prev_win / 2;\n\tif (pages < last_ra)\n\t\tpages = last_ra;\n\n\treturn pages;\n}"
  },
  {
    "function_name": "read_swap_cache_async",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
    "lines": "437-448",
    "snippet": "struct page *read_swap_cache_async(swp_entry_t entry, gfp_t gfp_mask,\n\t\tstruct vm_area_struct *vma, unsigned long addr, bool do_poll)\n{\n\tbool page_was_allocated;\n\tstruct page *retpage = __read_swap_cache_async(entry, gfp_mask,\n\t\t\tvma, addr, &page_was_allocated);\n\n\tif (page_was_allocated)\n\t\tswap_readpage(retpage, do_poll);\n\n\treturn retpage;\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/migrate.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "swap_readpage",
          "args": [
            "retpage",
            "do_poll"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "swap_readpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_io.c",
          "lines": "351-420",
          "snippet": "int swap_readpage(struct page *page, bool synchronous)\n{\n\tstruct bio *bio;\n\tint ret = 0;\n\tstruct swap_info_struct *sis = page_swap_info(page);\n\tblk_qc_t qc;\n\tstruct gendisk *disk;\n\n\tVM_BUG_ON_PAGE(!PageSwapCache(page) && !synchronous, page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(PageUptodate(page), page);\n\tif (frontswap_load(page) == 0) {\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\tgoto out;\n\t}\n\n\tif (sis->flags & SWP_FS) {\n\t\tstruct file *swap_file = sis->swap_file;\n\t\tstruct address_space *mapping = swap_file->f_mapping;\n\n\t\tret = mapping->a_ops->readpage(swap_file, page);\n\t\tif (!ret)\n\t\t\tcount_vm_event(PSWPIN);\n\t\treturn ret;\n\t}\n\n\tret = bdev_read_page(sis->bdev, swap_page_sector(page), page);\n\tif (!ret) {\n\t\tif (trylock_page(page)) {\n\t\t\tswap_slot_free_notify(page);\n\t\t\tunlock_page(page);\n\t\t}\n\n\t\tcount_vm_event(PSWPIN);\n\t\treturn 0;\n\t}\n\n\tret = 0;\n\tbio = get_swap_bio(GFP_KERNEL, page, end_swap_bio_read);\n\tif (bio == NULL) {\n\t\tunlock_page(page);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tdisk = bio->bi_disk;\n\t/*\n\t * Keep this task valid during swap readpage because the oom killer may\n\t * attempt to access it in the page fault retry time check.\n\t */\n\tget_task_struct(current);\n\tbio->bi_private = current;\n\tbio_set_op_attrs(bio, REQ_OP_READ, 0);\n\tcount_vm_event(PSWPIN);\n\tbio_get(bio);\n\tqc = submit_bio(bio);\n\twhile (synchronous) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (!READ_ONCE(bio->bi_private))\n\t\t\tbreak;\n\n\t\tif (!blk_poll(disk->queue, qc))\n\t\t\tbreak;\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tbio_put(bio);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/uio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/swapops.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/sched/task.h>\n#include <linux/uio.h>\n#include <linux/blkdev.h>\n#include <linux/frontswap.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/swapops.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/mm.h>\n\nint swap_readpage(struct page *page, bool synchronous)\n{\n\tstruct bio *bio;\n\tint ret = 0;\n\tstruct swap_info_struct *sis = page_swap_info(page);\n\tblk_qc_t qc;\n\tstruct gendisk *disk;\n\n\tVM_BUG_ON_PAGE(!PageSwapCache(page) && !synchronous, page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(PageUptodate(page), page);\n\tif (frontswap_load(page) == 0) {\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\tgoto out;\n\t}\n\n\tif (sis->flags & SWP_FS) {\n\t\tstruct file *swap_file = sis->swap_file;\n\t\tstruct address_space *mapping = swap_file->f_mapping;\n\n\t\tret = mapping->a_ops->readpage(swap_file, page);\n\t\tif (!ret)\n\t\t\tcount_vm_event(PSWPIN);\n\t\treturn ret;\n\t}\n\n\tret = bdev_read_page(sis->bdev, swap_page_sector(page), page);\n\tif (!ret) {\n\t\tif (trylock_page(page)) {\n\t\t\tswap_slot_free_notify(page);\n\t\t\tunlock_page(page);\n\t\t}\n\n\t\tcount_vm_event(PSWPIN);\n\t\treturn 0;\n\t}\n\n\tret = 0;\n\tbio = get_swap_bio(GFP_KERNEL, page, end_swap_bio_read);\n\tif (bio == NULL) {\n\t\tunlock_page(page);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tdisk = bio->bi_disk;\n\t/*\n\t * Keep this task valid during swap readpage because the oom killer may\n\t * attempt to access it in the page fault retry time check.\n\t */\n\tget_task_struct(current);\n\tbio->bi_private = current;\n\tbio_set_op_attrs(bio, REQ_OP_READ, 0);\n\tcount_vm_event(PSWPIN);\n\tbio_get(bio);\n\tqc = submit_bio(bio);\n\twhile (synchronous) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (!READ_ONCE(bio->bi_private))\n\t\t\tbreak;\n\n\t\tif (!blk_poll(disk->queue, qc))\n\t\t\tbreak;\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tbio_put(bio);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__read_swap_cache_async",
          "args": [
            "entry",
            "gfp_mask",
            "vma",
            "addr",
            "&page_was_allocated"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "__read_swap_cache_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "353-429",
          "snippet": "struct page *__read_swap_cache_async(swp_entry_t entry, gfp_t gfp_mask,\n\t\t\tstruct vm_area_struct *vma, unsigned long addr,\n\t\t\tbool *new_page_allocated)\n{\n\tstruct page *found_page, *new_page = NULL;\n\tstruct address_space *swapper_space = swap_address_space(entry);\n\tint err;\n\t*new_page_allocated = false;\n\n\tdo {\n\t\t/*\n\t\t * First check the swap cache.  Since this is normally\n\t\t * called after lookup_swap_cache() failed, re-calling\n\t\t * that would confuse statistics.\n\t\t */\n\t\tfound_page = find_get_page(swapper_space, swp_offset(entry));\n\t\tif (found_page)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Just skip read ahead for unused swap slot.\n\t\t * During swap_off when swap_slot_cache is disabled,\n\t\t * we have to handle the race between putting\n\t\t * swap entry in swap cache and marking swap slot\n\t\t * as SWAP_HAS_CACHE.  That's done in later part of code or\n\t\t * else swap_off will be aborted if we return NULL.\n\t\t */\n\t\tif (!__swp_swapcount(entry) && swap_slot_cache_enabled)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Get a new page to read into from swap.\n\t\t */\n\t\tif (!new_page) {\n\t\t\tnew_page = alloc_page_vma(gfp_mask, vma, addr);\n\t\t\tif (!new_page)\n\t\t\t\tbreak;\t\t/* Out of memory */\n\t\t}\n\n\t\t/*\n\t\t * Swap entry may have been freed since our caller observed it.\n\t\t */\n\t\terr = swapcache_prepare(entry);\n\t\tif (err == -EEXIST) {\n\t\t\t/*\n\t\t\t * We might race against get_swap_page() and stumble\n\t\t\t * across a SWAP_HAS_CACHE swap_map entry whose page\n\t\t\t * has not been brought into the swapcache yet.\n\t\t\t */\n\t\t\tcond_resched();\n\t\t\tcontinue;\n\t\t} else if (err)\t\t/* swp entry is obsolete ? */\n\t\t\tbreak;\n\n\t\t/* May fail (-ENOMEM) if XArray node allocation failed. */\n\t\t__SetPageLocked(new_page);\n\t\t__SetPageSwapBacked(new_page);\n\t\terr = add_to_swap_cache(new_page, entry, gfp_mask & GFP_KERNEL);\n\t\tif (likely(!err)) {\n\t\t\t/* Initiate read into locked page */\n\t\t\tSetPageWorkingset(new_page);\n\t\t\tlru_cache_add_anon(new_page);\n\t\t\t*new_page_allocated = true;\n\t\t\treturn new_page;\n\t\t}\n\t\t__ClearPageLocked(new_page);\n\t\t/*\n\t\t * add_to_swap_cache() doesn't return -EEXIST, so we can safely\n\t\t * clear SWAP_HAS_CACHE flag.\n\t\t */\n\t\tput_swap_page(new_page, entry);\n\t} while (err != -ENOMEM);\n\n\tif (new_page)\n\t\tput_page(new_page);\n\treturn found_page;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstruct page *__read_swap_cache_async(swp_entry_t entry, gfp_t gfp_mask,\n\t\t\tstruct vm_area_struct *vma, unsigned long addr,\n\t\t\tbool *new_page_allocated)\n{\n\tstruct page *found_page, *new_page = NULL;\n\tstruct address_space *swapper_space = swap_address_space(entry);\n\tint err;\n\t*new_page_allocated = false;\n\n\tdo {\n\t\t/*\n\t\t * First check the swap cache.  Since this is normally\n\t\t * called after lookup_swap_cache() failed, re-calling\n\t\t * that would confuse statistics.\n\t\t */\n\t\tfound_page = find_get_page(swapper_space, swp_offset(entry));\n\t\tif (found_page)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Just skip read ahead for unused swap slot.\n\t\t * During swap_off when swap_slot_cache is disabled,\n\t\t * we have to handle the race between putting\n\t\t * swap entry in swap cache and marking swap slot\n\t\t * as SWAP_HAS_CACHE.  That's done in later part of code or\n\t\t * else swap_off will be aborted if we return NULL.\n\t\t */\n\t\tif (!__swp_swapcount(entry) && swap_slot_cache_enabled)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Get a new page to read into from swap.\n\t\t */\n\t\tif (!new_page) {\n\t\t\tnew_page = alloc_page_vma(gfp_mask, vma, addr);\n\t\t\tif (!new_page)\n\t\t\t\tbreak;\t\t/* Out of memory */\n\t\t}\n\n\t\t/*\n\t\t * Swap entry may have been freed since our caller observed it.\n\t\t */\n\t\terr = swapcache_prepare(entry);\n\t\tif (err == -EEXIST) {\n\t\t\t/*\n\t\t\t * We might race against get_swap_page() and stumble\n\t\t\t * across a SWAP_HAS_CACHE swap_map entry whose page\n\t\t\t * has not been brought into the swapcache yet.\n\t\t\t */\n\t\t\tcond_resched();\n\t\t\tcontinue;\n\t\t} else if (err)\t\t/* swp entry is obsolete ? */\n\t\t\tbreak;\n\n\t\t/* May fail (-ENOMEM) if XArray node allocation failed. */\n\t\t__SetPageLocked(new_page);\n\t\t__SetPageSwapBacked(new_page);\n\t\terr = add_to_swap_cache(new_page, entry, gfp_mask & GFP_KERNEL);\n\t\tif (likely(!err)) {\n\t\t\t/* Initiate read into locked page */\n\t\t\tSetPageWorkingset(new_page);\n\t\t\tlru_cache_add_anon(new_page);\n\t\t\t*new_page_allocated = true;\n\t\t\treturn new_page;\n\t\t}\n\t\t__ClearPageLocked(new_page);\n\t\t/*\n\t\t * add_to_swap_cache() doesn't return -EEXIST, so we can safely\n\t\t * clear SWAP_HAS_CACHE flag.\n\t\t */\n\t\tput_swap_page(new_page, entry);\n\t} while (err != -ENOMEM);\n\n\tif (new_page)\n\t\tput_page(new_page);\n\treturn found_page;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstruct page *read_swap_cache_async(swp_entry_t entry, gfp_t gfp_mask,\n\t\tstruct vm_area_struct *vma, unsigned long addr, bool do_poll)\n{\n\tbool page_was_allocated;\n\tstruct page *retpage = __read_swap_cache_async(entry, gfp_mask,\n\t\t\tvma, addr, &page_was_allocated);\n\n\tif (page_was_allocated)\n\t\tswap_readpage(retpage, do_poll);\n\n\treturn retpage;\n}"
  },
  {
    "function_name": "__read_swap_cache_async",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
    "lines": "353-429",
    "snippet": "struct page *__read_swap_cache_async(swp_entry_t entry, gfp_t gfp_mask,\n\t\t\tstruct vm_area_struct *vma, unsigned long addr,\n\t\t\tbool *new_page_allocated)\n{\n\tstruct page *found_page, *new_page = NULL;\n\tstruct address_space *swapper_space = swap_address_space(entry);\n\tint err;\n\t*new_page_allocated = false;\n\n\tdo {\n\t\t/*\n\t\t * First check the swap cache.  Since this is normally\n\t\t * called after lookup_swap_cache() failed, re-calling\n\t\t * that would confuse statistics.\n\t\t */\n\t\tfound_page = find_get_page(swapper_space, swp_offset(entry));\n\t\tif (found_page)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Just skip read ahead for unused swap slot.\n\t\t * During swap_off when swap_slot_cache is disabled,\n\t\t * we have to handle the race between putting\n\t\t * swap entry in swap cache and marking swap slot\n\t\t * as SWAP_HAS_CACHE.  That's done in later part of code or\n\t\t * else swap_off will be aborted if we return NULL.\n\t\t */\n\t\tif (!__swp_swapcount(entry) && swap_slot_cache_enabled)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Get a new page to read into from swap.\n\t\t */\n\t\tif (!new_page) {\n\t\t\tnew_page = alloc_page_vma(gfp_mask, vma, addr);\n\t\t\tif (!new_page)\n\t\t\t\tbreak;\t\t/* Out of memory */\n\t\t}\n\n\t\t/*\n\t\t * Swap entry may have been freed since our caller observed it.\n\t\t */\n\t\terr = swapcache_prepare(entry);\n\t\tif (err == -EEXIST) {\n\t\t\t/*\n\t\t\t * We might race against get_swap_page() and stumble\n\t\t\t * across a SWAP_HAS_CACHE swap_map entry whose page\n\t\t\t * has not been brought into the swapcache yet.\n\t\t\t */\n\t\t\tcond_resched();\n\t\t\tcontinue;\n\t\t} else if (err)\t\t/* swp entry is obsolete ? */\n\t\t\tbreak;\n\n\t\t/* May fail (-ENOMEM) if XArray node allocation failed. */\n\t\t__SetPageLocked(new_page);\n\t\t__SetPageSwapBacked(new_page);\n\t\terr = add_to_swap_cache(new_page, entry, gfp_mask & GFP_KERNEL);\n\t\tif (likely(!err)) {\n\t\t\t/* Initiate read into locked page */\n\t\t\tSetPageWorkingset(new_page);\n\t\t\tlru_cache_add_anon(new_page);\n\t\t\t*new_page_allocated = true;\n\t\t\treturn new_page;\n\t\t}\n\t\t__ClearPageLocked(new_page);\n\t\t/*\n\t\t * add_to_swap_cache() doesn't return -EEXIST, so we can safely\n\t\t * clear SWAP_HAS_CACHE flag.\n\t\t */\n\t\tput_swap_page(new_page, entry);\n\t} while (err != -ENOMEM);\n\n\tif (new_page)\n\t\tput_page(new_page);\n\treturn found_page;\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/migrate.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "new_page"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_swap_page",
          "args": [
            "new_page",
            "entry"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "put_swap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1225-1270",
          "snippet": "void put_swap_page(struct page *page, swp_entry_t entry)\n{\n\tunsigned long offset = swp_offset(entry);\n\tunsigned long idx = offset / SWAPFILE_CLUSTER;\n\tstruct swap_cluster_info *ci;\n\tstruct swap_info_struct *si;\n\tunsigned char *map;\n\tunsigned int i, free_entries = 0;\n\tunsigned char val;\n\tint size = swap_entry_size(hpage_nr_pages(page));\n\n\tsi = _swap_info_get(entry);\n\tif (!si)\n\t\treturn;\n\n\tci = lock_cluster_or_swap_info(si, offset);\n\tif (size == SWAPFILE_CLUSTER) {\n\t\tVM_BUG_ON(!cluster_is_huge(ci));\n\t\tmap = si->swap_map + offset;\n\t\tfor (i = 0; i < SWAPFILE_CLUSTER; i++) {\n\t\t\tval = map[i];\n\t\t\tVM_BUG_ON(!(val & SWAP_HAS_CACHE));\n\t\t\tif (val == SWAP_HAS_CACHE)\n\t\t\t\tfree_entries++;\n\t\t}\n\t\tcluster_clear_huge(ci);\n\t\tif (free_entries == SWAPFILE_CLUSTER) {\n\t\t\tunlock_cluster_or_swap_info(si, ci);\n\t\t\tspin_lock(&si->lock);\n\t\t\tmem_cgroup_uncharge_swap(entry, SWAPFILE_CLUSTER);\n\t\t\tswap_free_cluster(si, idx);\n\t\t\tspin_unlock(&si->lock);\n\t\t\treturn;\n\t\t}\n\t}\n\tfor (i = 0; i < size; i++, entry.val++) {\n\t\tif (!__swap_entry_free_locked(si, offset + i, SWAP_HAS_CACHE)) {\n\t\t\tunlock_cluster_or_swap_info(si, ci);\n\t\t\tfree_swap_slot(entry);\n\t\t\tif (i == size - 1)\n\t\t\t\treturn;\n\t\t\tlock_cluster_or_swap_info(si, offset);\n\t\t}\n\t}\n\tunlock_cluster_or_swap_info(si, ci);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SWAPFILE_CLUSTER\t256",
            "#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR"
          ],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define SWAPFILE_CLUSTER\t256\n#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nvoid put_swap_page(struct page *page, swp_entry_t entry)\n{\n\tunsigned long offset = swp_offset(entry);\n\tunsigned long idx = offset / SWAPFILE_CLUSTER;\n\tstruct swap_cluster_info *ci;\n\tstruct swap_info_struct *si;\n\tunsigned char *map;\n\tunsigned int i, free_entries = 0;\n\tunsigned char val;\n\tint size = swap_entry_size(hpage_nr_pages(page));\n\n\tsi = _swap_info_get(entry);\n\tif (!si)\n\t\treturn;\n\n\tci = lock_cluster_or_swap_info(si, offset);\n\tif (size == SWAPFILE_CLUSTER) {\n\t\tVM_BUG_ON(!cluster_is_huge(ci));\n\t\tmap = si->swap_map + offset;\n\t\tfor (i = 0; i < SWAPFILE_CLUSTER; i++) {\n\t\t\tval = map[i];\n\t\t\tVM_BUG_ON(!(val & SWAP_HAS_CACHE));\n\t\t\tif (val == SWAP_HAS_CACHE)\n\t\t\t\tfree_entries++;\n\t\t}\n\t\tcluster_clear_huge(ci);\n\t\tif (free_entries == SWAPFILE_CLUSTER) {\n\t\t\tunlock_cluster_or_swap_info(si, ci);\n\t\t\tspin_lock(&si->lock);\n\t\t\tmem_cgroup_uncharge_swap(entry, SWAPFILE_CLUSTER);\n\t\t\tswap_free_cluster(si, idx);\n\t\t\tspin_unlock(&si->lock);\n\t\t\treturn;\n\t\t}\n\t}\n\tfor (i = 0; i < size; i++, entry.val++) {\n\t\tif (!__swap_entry_free_locked(si, offset + i, SWAP_HAS_CACHE)) {\n\t\t\tunlock_cluster_or_swap_info(si, ci);\n\t\t\tfree_swap_slot(entry);\n\t\t\tif (i == size - 1)\n\t\t\t\treturn;\n\t\t\tlock_cluster_or_swap_info(si, offset);\n\t\t}\n\t}\n\tunlock_cluster_or_swap_info(si, ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ClearPageLocked",
          "args": [
            "new_page"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lru_cache_add_anon",
          "args": [
            "new_page"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "lru_cache_add_anon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "417-422",
          "snippet": "void lru_cache_add_anon(struct page *page)\n{\n\tif (PageActive(page))\n\t\tClearPageActive(page);\n\t__lru_cache_add(page);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid lru_cache_add_anon(struct page *page)\n{\n\tif (PageActive(page))\n\t\tClearPageActive(page);\n\t__lru_cache_add(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageWorkingset",
          "args": [
            "new_page"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!err"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_to_swap_cache",
          "args": [
            "new_page",
            "entry",
            "gfp_mask & GFP_KERNEL"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "add_to_swap_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "113-151",
          "snippet": "int add_to_swap_cache(struct page *page, swp_entry_t entry, gfp_t gfp)\n{\n\tstruct address_space *address_space = swap_address_space(entry);\n\tpgoff_t idx = swp_offset(entry);\n\tXA_STATE_ORDER(xas, &address_space->i_pages, idx, compound_order(page));\n\tunsigned long i, nr = 1UL << compound_order(page);\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(PageSwapCache(page), page);\n\tVM_BUG_ON_PAGE(!PageSwapBacked(page), page);\n\n\tpage_ref_add(page, nr);\n\tSetPageSwapCache(page);\n\n\tdo {\n\t\txas_lock_irq(&xas);\n\t\txas_create_range(&xas);\n\t\tif (xas_error(&xas))\n\t\t\tgoto unlock;\n\t\tfor (i = 0; i < nr; i++) {\n\t\t\tVM_BUG_ON_PAGE(xas.xa_index != idx + i, page);\n\t\t\tset_page_private(page + i, entry.val + i);\n\t\t\txas_store(&xas, page + i);\n\t\t\txas_next(&xas);\n\t\t}\n\t\taddress_space->nrpages += nr;\n\t\t__mod_node_page_state(page_pgdat(page), NR_FILE_PAGES, nr);\n\t\tADD_CACHE_INFO(add_total, nr);\nunlock:\n\t\txas_unlock_irq(&xas);\n\t} while (xas_nomem(&xas, gfp));\n\n\tif (!xas_error(&xas))\n\t\treturn 0;\n\n\tClearPageSwapCache(page);\n\tpage_ref_sub(page, nr);\n\treturn xas_error(&xas);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nint add_to_swap_cache(struct page *page, swp_entry_t entry, gfp_t gfp)\n{\n\tstruct address_space *address_space = swap_address_space(entry);\n\tpgoff_t idx = swp_offset(entry);\n\tXA_STATE_ORDER(xas, &address_space->i_pages, idx, compound_order(page));\n\tunsigned long i, nr = 1UL << compound_order(page);\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(PageSwapCache(page), page);\n\tVM_BUG_ON_PAGE(!PageSwapBacked(page), page);\n\n\tpage_ref_add(page, nr);\n\tSetPageSwapCache(page);\n\n\tdo {\n\t\txas_lock_irq(&xas);\n\t\txas_create_range(&xas);\n\t\tif (xas_error(&xas))\n\t\t\tgoto unlock;\n\t\tfor (i = 0; i < nr; i++) {\n\t\t\tVM_BUG_ON_PAGE(xas.xa_index != idx + i, page);\n\t\t\tset_page_private(page + i, entry.val + i);\n\t\t\txas_store(&xas, page + i);\n\t\t\txas_next(&xas);\n\t\t}\n\t\taddress_space->nrpages += nr;\n\t\t__mod_node_page_state(page_pgdat(page), NR_FILE_PAGES, nr);\n\t\tADD_CACHE_INFO(add_total, nr);\nunlock:\n\t\txas_unlock_irq(&xas);\n\t} while (xas_nomem(&xas, gfp));\n\n\tif (!xas_error(&xas))\n\t\treturn 0;\n\n\tClearPageSwapCache(page);\n\tpage_ref_sub(page, nr);\n\treturn xas_error(&xas);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__SetPageSwapBacked",
          "args": [
            "new_page"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__SetPageLocked",
          "args": [
            "new_page"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swapcache_prepare",
          "args": [
            "entry"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "swapcache_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "3460-3463",
          "snippet": "int swapcache_prepare(swp_entry_t entry)\n{\n\treturn __swap_duplicate(entry, SWAP_HAS_CACHE);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint swapcache_prepare(swp_entry_t entry)\n{\n\treturn __swap_duplicate(entry, SWAP_HAS_CACHE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_page_vma",
          "args": [
            "gfp_mask",
            "vma",
            "addr"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__swp_swapcount",
          "args": [
            "entry"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "__swp_swapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1372-1381",
          "snippet": "int __swp_swapcount(swp_entry_t entry)\n{\n\tint count = 0;\n\tstruct swap_info_struct *si;\n\n\tsi = __swap_info_get(entry);\n\tif (si)\n\t\tcount = swap_swapcount(si, entry);\n\treturn count;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nint __swp_swapcount(swp_entry_t entry)\n{\n\tint count = 0;\n\tstruct swap_info_struct *si;\n\n\tsi = __swap_info_get(entry);\n\tif (si)\n\t\tcount = swap_swapcount(si, entry);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "swapper_space",
            "swp_offset(entry)"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_offset",
          "args": [
            "entry"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_address_space",
          "args": [
            "entry"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "exit_swap_address_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "602-611",
          "snippet": "void exit_swap_address_space(unsigned int type)\n{\n\tstruct address_space *spaces;\n\n\tspaces = swapper_spaces[type];\n\tnr_swapper_spaces[type] = 0;\n\trcu_assign_pointer(swapper_spaces[type], NULL);\n\tsynchronize_rcu();\n\tkvfree(spaces);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct address_space *swapper_spaces[MAX_SWAPFILES]",
            "static unsigned int nr_swapper_spaces[MAX_SWAPFILES]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstruct address_space *swapper_spaces[MAX_SWAPFILES];\nstatic unsigned int nr_swapper_spaces[MAX_SWAPFILES];\n\nvoid exit_swap_address_space(unsigned int type)\n{\n\tstruct address_space *spaces;\n\n\tspaces = swapper_spaces[type];\n\tnr_swapper_spaces[type] = 0;\n\trcu_assign_pointer(swapper_spaces[type], NULL);\n\tsynchronize_rcu();\n\tkvfree(spaces);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstruct page *__read_swap_cache_async(swp_entry_t entry, gfp_t gfp_mask,\n\t\t\tstruct vm_area_struct *vma, unsigned long addr,\n\t\t\tbool *new_page_allocated)\n{\n\tstruct page *found_page, *new_page = NULL;\n\tstruct address_space *swapper_space = swap_address_space(entry);\n\tint err;\n\t*new_page_allocated = false;\n\n\tdo {\n\t\t/*\n\t\t * First check the swap cache.  Since this is normally\n\t\t * called after lookup_swap_cache() failed, re-calling\n\t\t * that would confuse statistics.\n\t\t */\n\t\tfound_page = find_get_page(swapper_space, swp_offset(entry));\n\t\tif (found_page)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Just skip read ahead for unused swap slot.\n\t\t * During swap_off when swap_slot_cache is disabled,\n\t\t * we have to handle the race between putting\n\t\t * swap entry in swap cache and marking swap slot\n\t\t * as SWAP_HAS_CACHE.  That's done in later part of code or\n\t\t * else swap_off will be aborted if we return NULL.\n\t\t */\n\t\tif (!__swp_swapcount(entry) && swap_slot_cache_enabled)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Get a new page to read into from swap.\n\t\t */\n\t\tif (!new_page) {\n\t\t\tnew_page = alloc_page_vma(gfp_mask, vma, addr);\n\t\t\tif (!new_page)\n\t\t\t\tbreak;\t\t/* Out of memory */\n\t\t}\n\n\t\t/*\n\t\t * Swap entry may have been freed since our caller observed it.\n\t\t */\n\t\terr = swapcache_prepare(entry);\n\t\tif (err == -EEXIST) {\n\t\t\t/*\n\t\t\t * We might race against get_swap_page() and stumble\n\t\t\t * across a SWAP_HAS_CACHE swap_map entry whose page\n\t\t\t * has not been brought into the swapcache yet.\n\t\t\t */\n\t\t\tcond_resched();\n\t\t\tcontinue;\n\t\t} else if (err)\t\t/* swp entry is obsolete ? */\n\t\t\tbreak;\n\n\t\t/* May fail (-ENOMEM) if XArray node allocation failed. */\n\t\t__SetPageLocked(new_page);\n\t\t__SetPageSwapBacked(new_page);\n\t\terr = add_to_swap_cache(new_page, entry, gfp_mask & GFP_KERNEL);\n\t\tif (likely(!err)) {\n\t\t\t/* Initiate read into locked page */\n\t\t\tSetPageWorkingset(new_page);\n\t\t\tlru_cache_add_anon(new_page);\n\t\t\t*new_page_allocated = true;\n\t\t\treturn new_page;\n\t\t}\n\t\t__ClearPageLocked(new_page);\n\t\t/*\n\t\t * add_to_swap_cache() doesn't return -EEXIST, so we can safely\n\t\t * clear SWAP_HAS_CACHE flag.\n\t\t */\n\t\tput_swap_page(new_page, entry);\n\t} while (err != -ENOMEM);\n\n\tif (new_page)\n\t\tput_page(new_page);\n\treturn found_page;\n}"
  },
  {
    "function_name": "lookup_swap_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
    "lines": "309-351",
    "snippet": "struct page *lookup_swap_cache(swp_entry_t entry, struct vm_area_struct *vma,\n\t\t\t       unsigned long addr)\n{\n\tstruct page *page;\n\n\tpage = find_get_page(swap_address_space(entry), swp_offset(entry));\n\n\tINC_CACHE_INFO(find_total);\n\tif (page) {\n\t\tbool vma_ra = swap_use_vma_readahead();\n\t\tbool readahead;\n\n\t\tINC_CACHE_INFO(find_success);\n\t\t/*\n\t\t * At the moment, we don't support PG_readahead for anon THP\n\t\t * so let's bail out rather than confusing the readahead stat.\n\t\t */\n\t\tif (unlikely(PageTransCompound(page)))\n\t\t\treturn page;\n\n\t\treadahead = TestClearPageReadahead(page);\n\t\tif (vma && vma_ra) {\n\t\t\tunsigned long ra_val;\n\t\t\tint win, hits;\n\n\t\t\tra_val = GET_SWAP_RA_VAL(vma);\n\t\t\twin = SWAP_RA_WIN(ra_val);\n\t\t\thits = SWAP_RA_HITS(ra_val);\n\t\t\tif (readahead)\n\t\t\t\thits = min_t(int, hits + 1, SWAP_RA_HITS_MAX);\n\t\t\tatomic_long_set(&vma->swap_readahead_info,\n\t\t\t\t\tSWAP_RA_VAL(addr, win, hits));\n\t\t}\n\n\t\tif (readahead) {\n\t\t\tcount_vm_event(SWAP_RA_HIT);\n\t\t\tif (!vma || !vma_ra)\n\t\t\t\tatomic_inc(&swapin_readahead_hits);\n\t\t}\n\t}\n\n\treturn page;\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/migrate.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define SWAP_RA_HITS_MAX\tSWAP_RA_HITS_MASK"
    ],
    "globals_used": [
      "static atomic_t swapin_readahead_hits = ATOMIC_INIT(4);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&swapin_readahead_hits"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "SWAP_RA_HIT"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_set",
          "args": [
            "&vma->swap_readahead_info",
            "SWAP_RA_VAL(addr, win, hits)"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SWAP_RA_VAL",
          "args": [
            "addr",
            "win",
            "hits"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "hits + 1",
            "SWAP_RA_HITS_MAX"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SWAP_RA_HITS",
          "args": [
            "ra_val"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SWAP_RA_WIN",
          "args": [
            "ra_val"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SWAP_RA_VAL",
          "args": [
            "vma"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestClearPageReadahead",
          "args": [
            "page"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "PageTransCompound(page)"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransCompound",
          "args": [
            "page"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INC_CACHE_INFO",
          "args": [
            "find_success"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_use_vma_readahead",
          "args": [],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "swap_use_vma_readahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "298-301",
          "snippet": "static inline bool swap_use_vma_readahead(void)\n{\n\treturn READ_ONCE(enable_vma_readahead) && !atomic_read(&nr_rotate_swap);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool enable_vma_readahead"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstatic bool enable_vma_readahead;\n\nstatic inline bool swap_use_vma_readahead(void)\n{\n\treturn READ_ONCE(enable_vma_readahead) && !atomic_read(&nr_rotate_swap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INC_CACHE_INFO",
          "args": [
            "find_total"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "swap_address_space(entry)",
            "swp_offset(entry)"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_offset",
          "args": [
            "entry"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_address_space",
          "args": [
            "entry"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "exit_swap_address_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "602-611",
          "snippet": "void exit_swap_address_space(unsigned int type)\n{\n\tstruct address_space *spaces;\n\n\tspaces = swapper_spaces[type];\n\tnr_swapper_spaces[type] = 0;\n\trcu_assign_pointer(swapper_spaces[type], NULL);\n\tsynchronize_rcu();\n\tkvfree(spaces);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct address_space *swapper_spaces[MAX_SWAPFILES]",
            "static unsigned int nr_swapper_spaces[MAX_SWAPFILES]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstruct address_space *swapper_spaces[MAX_SWAPFILES];\nstatic unsigned int nr_swapper_spaces[MAX_SWAPFILES];\n\nvoid exit_swap_address_space(unsigned int type)\n{\n\tstruct address_space *spaces;\n\n\tspaces = swapper_spaces[type];\n\tnr_swapper_spaces[type] = 0;\n\trcu_assign_pointer(swapper_spaces[type], NULL);\n\tsynchronize_rcu();\n\tkvfree(spaces);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\n#define SWAP_RA_HITS_MAX\tSWAP_RA_HITS_MASK\n\nstatic atomic_t swapin_readahead_hits = ATOMIC_INIT(4);\n\nstruct page *lookup_swap_cache(swp_entry_t entry, struct vm_area_struct *vma,\n\t\t\t       unsigned long addr)\n{\n\tstruct page *page;\n\n\tpage = find_get_page(swap_address_space(entry), swp_offset(entry));\n\n\tINC_CACHE_INFO(find_total);\n\tif (page) {\n\t\tbool vma_ra = swap_use_vma_readahead();\n\t\tbool readahead;\n\n\t\tINC_CACHE_INFO(find_success);\n\t\t/*\n\t\t * At the moment, we don't support PG_readahead for anon THP\n\t\t * so let's bail out rather than confusing the readahead stat.\n\t\t */\n\t\tif (unlikely(PageTransCompound(page)))\n\t\t\treturn page;\n\n\t\treadahead = TestClearPageReadahead(page);\n\t\tif (vma && vma_ra) {\n\t\t\tunsigned long ra_val;\n\t\t\tint win, hits;\n\n\t\t\tra_val = GET_SWAP_RA_VAL(vma);\n\t\t\twin = SWAP_RA_WIN(ra_val);\n\t\t\thits = SWAP_RA_HITS(ra_val);\n\t\t\tif (readahead)\n\t\t\t\thits = min_t(int, hits + 1, SWAP_RA_HITS_MAX);\n\t\t\tatomic_long_set(&vma->swap_readahead_info,\n\t\t\t\t\tSWAP_RA_VAL(addr, win, hits));\n\t\t}\n\n\t\tif (readahead) {\n\t\t\tcount_vm_event(SWAP_RA_HIT);\n\t\t\tif (!vma || !vma_ra)\n\t\t\t\tatomic_inc(&swapin_readahead_hits);\n\t\t}\n\t}\n\n\treturn page;\n}"
  },
  {
    "function_name": "swap_use_vma_readahead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
    "lines": "298-301",
    "snippet": "static inline bool swap_use_vma_readahead(void)\n{\n\treturn READ_ONCE(enable_vma_readahead) && !atomic_read(&nr_rotate_swap);\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/migrate.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool enable_vma_readahead"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&nr_rotate_swap"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "enable_vma_readahead"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstatic bool enable_vma_readahead;\n\nstatic inline bool swap_use_vma_readahead(void)\n{\n\treturn READ_ONCE(enable_vma_readahead) && !atomic_read(&nr_rotate_swap);\n}"
  },
  {
    "function_name": "free_pages_and_swap_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
    "lines": "287-296",
    "snippet": "void free_pages_and_swap_cache(struct page **pages, int nr)\n{\n\tstruct page **pagep = pages;\n\tint i;\n\n\tlru_add_drain();\n\tfor (i = 0; i < nr; i++)\n\t\tfree_swap_cache(pagep[i]);\n\trelease_pages(pagep, nr);\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/migrate.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_pages",
          "args": [
            "pagep",
            "nr"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "release_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "714-792",
          "snippet": "void release_pages(struct page **pages, int nr)\n{\n\tint i;\n\tLIST_HEAD(pages_to_free);\n\tstruct pglist_data *locked_pgdat = NULL;\n\tstruct lruvec *lruvec;\n\tunsigned long uninitialized_var(flags);\n\tunsigned int uninitialized_var(lock_batch);\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct page *page = pages[i];\n\n\t\t/*\n\t\t * Make sure the IRQ-safe lock-holding time does not get\n\t\t * excessive with a continuous string of pages from the\n\t\t * same pgdat. The lock is held only if pgdat != NULL.\n\t\t */\n\t\tif (locked_pgdat && ++lock_batch == SWAP_CLUSTER_MAX) {\n\t\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock, flags);\n\t\t\tlocked_pgdat = NULL;\n\t\t}\n\n\t\tif (is_huge_zero_page(page))\n\t\t\tcontinue;\n\n\t\t/* Device public page can not be huge page */\n\t\tif (is_device_public_page(page)) {\n\t\t\tif (locked_pgdat) {\n\t\t\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock,\n\t\t\t\t\t\t       flags);\n\t\t\t\tlocked_pgdat = NULL;\n\t\t\t}\n\t\t\tput_devmap_managed_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpage = compound_head(page);\n\t\tif (!put_page_testzero(page))\n\t\t\tcontinue;\n\n\t\tif (PageCompound(page)) {\n\t\t\tif (locked_pgdat) {\n\t\t\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock, flags);\n\t\t\t\tlocked_pgdat = NULL;\n\t\t\t}\n\t\t\t__put_compound_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (PageLRU(page)) {\n\t\t\tstruct pglist_data *pgdat = page_pgdat(page);\n\n\t\t\tif (pgdat != locked_pgdat) {\n\t\t\t\tif (locked_pgdat)\n\t\t\t\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock,\n\t\t\t\t\t\t\t\t\tflags);\n\t\t\t\tlock_batch = 0;\n\t\t\t\tlocked_pgdat = pgdat;\n\t\t\t\tspin_lock_irqsave(&locked_pgdat->lru_lock, flags);\n\t\t\t}\n\n\t\t\tlruvec = mem_cgroup_page_lruvec(page, locked_pgdat);\n\t\t\tVM_BUG_ON_PAGE(!PageLRU(page), page);\n\t\t\t__ClearPageLRU(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, page_off_lru(page));\n\t\t}\n\n\t\t/* Clear Active bit in case of parallel mark_page_accessed */\n\t\t__ClearPageActive(page);\n\t\t__ClearPageWaiters(page);\n\n\t\tlist_add(&page->lru, &pages_to_free);\n\t}\n\tif (locked_pgdat)\n\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock, flags);\n\n\tmem_cgroup_uncharge_list(&pages_to_free);\n\tfree_unref_page_list(&pages_to_free);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid release_pages(struct page **pages, int nr)\n{\n\tint i;\n\tLIST_HEAD(pages_to_free);\n\tstruct pglist_data *locked_pgdat = NULL;\n\tstruct lruvec *lruvec;\n\tunsigned long uninitialized_var(flags);\n\tunsigned int uninitialized_var(lock_batch);\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct page *page = pages[i];\n\n\t\t/*\n\t\t * Make sure the IRQ-safe lock-holding time does not get\n\t\t * excessive with a continuous string of pages from the\n\t\t * same pgdat. The lock is held only if pgdat != NULL.\n\t\t */\n\t\tif (locked_pgdat && ++lock_batch == SWAP_CLUSTER_MAX) {\n\t\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock, flags);\n\t\t\tlocked_pgdat = NULL;\n\t\t}\n\n\t\tif (is_huge_zero_page(page))\n\t\t\tcontinue;\n\n\t\t/* Device public page can not be huge page */\n\t\tif (is_device_public_page(page)) {\n\t\t\tif (locked_pgdat) {\n\t\t\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock,\n\t\t\t\t\t\t       flags);\n\t\t\t\tlocked_pgdat = NULL;\n\t\t\t}\n\t\t\tput_devmap_managed_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpage = compound_head(page);\n\t\tif (!put_page_testzero(page))\n\t\t\tcontinue;\n\n\t\tif (PageCompound(page)) {\n\t\t\tif (locked_pgdat) {\n\t\t\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock, flags);\n\t\t\t\tlocked_pgdat = NULL;\n\t\t\t}\n\t\t\t__put_compound_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (PageLRU(page)) {\n\t\t\tstruct pglist_data *pgdat = page_pgdat(page);\n\n\t\t\tif (pgdat != locked_pgdat) {\n\t\t\t\tif (locked_pgdat)\n\t\t\t\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock,\n\t\t\t\t\t\t\t\t\tflags);\n\t\t\t\tlock_batch = 0;\n\t\t\t\tlocked_pgdat = pgdat;\n\t\t\t\tspin_lock_irqsave(&locked_pgdat->lru_lock, flags);\n\t\t\t}\n\n\t\t\tlruvec = mem_cgroup_page_lruvec(page, locked_pgdat);\n\t\t\tVM_BUG_ON_PAGE(!PageLRU(page), page);\n\t\t\t__ClearPageLRU(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, page_off_lru(page));\n\t\t}\n\n\t\t/* Clear Active bit in case of parallel mark_page_accessed */\n\t\t__ClearPageActive(page);\n\t\t__ClearPageWaiters(page);\n\n\t\tlist_add(&page->lru, &pages_to_free);\n\t}\n\tif (locked_pgdat)\n\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock, flags);\n\n\tmem_cgroup_uncharge_list(&pages_to_free);\n\tfree_unref_page_list(&pages_to_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_swap_cache",
          "args": [
            "pagep[i]"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "free_swap_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "264-270",
          "snippet": "static inline void free_swap_cache(struct page *page)\n{\n\tif (PageSwapCache(page) && !page_mapped(page) && trylock_page(page)) {\n\t\ttry_to_free_swap(page);\n\t\tunlock_page(page);\n\t}\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstatic inline void free_swap_cache(struct page *page)\n{\n\tif (PageSwapCache(page) && !page_mapped(page) && trylock_page(page)) {\n\t\ttry_to_free_swap(page);\n\t\tunlock_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lru_add_drain",
          "args": [],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "lru_add_drain_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "670-704",
          "snippet": "void lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);",
            "static DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);",
            "static DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\nstatic DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);\nstatic DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);\n\nvoid lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nvoid free_pages_and_swap_cache(struct page **pages, int nr)\n{\n\tstruct page **pagep = pages;\n\tint i;\n\n\tlru_add_drain();\n\tfor (i = 0; i < nr; i++)\n\t\tfree_swap_cache(pagep[i]);\n\trelease_pages(pagep, nr);\n}"
  },
  {
    "function_name": "free_page_and_swap_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
    "lines": "276-281",
    "snippet": "void free_page_and_swap_cache(struct page *page)\n{\n\tfree_swap_cache(page);\n\tif (!is_huge_zero_page(page))\n\t\tput_page(page);\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/migrate.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_huge_zero_page",
          "args": [
            "page"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_swap_cache",
          "args": [
            "page"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "free_swap_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "264-270",
          "snippet": "static inline void free_swap_cache(struct page *page)\n{\n\tif (PageSwapCache(page) && !page_mapped(page) && trylock_page(page)) {\n\t\ttry_to_free_swap(page);\n\t\tunlock_page(page);\n\t}\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstatic inline void free_swap_cache(struct page *page)\n{\n\tif (PageSwapCache(page) && !page_mapped(page) && trylock_page(page)) {\n\t\ttry_to_free_swap(page);\n\t\tunlock_page(page);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nvoid free_page_and_swap_cache(struct page *page)\n{\n\tfree_swap_cache(page);\n\tif (!is_huge_zero_page(page))\n\t\tput_page(page);\n}"
  },
  {
    "function_name": "free_swap_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
    "lines": "264-270",
    "snippet": "static inline void free_swap_cache(struct page *page)\n{\n\tif (PageSwapCache(page) && !page_mapped(page) && trylock_page(page)) {\n\t\ttry_to_free_swap(page);\n\t\tunlock_page(page);\n\t}\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/migrate.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_free_swap",
          "args": [
            "page"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_free_swap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1584-1617",
          "snippet": "int try_to_free_swap(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tif (!PageSwapCache(page))\n\t\treturn 0;\n\tif (PageWriteback(page))\n\t\treturn 0;\n\tif (page_swapped(page))\n\t\treturn 0;\n\n\t/*\n\t * Once hibernation has begun to create its image of memory,\n\t * there's a danger that one of the calls to try_to_free_swap()\n\t * - most probably a call from __try_to_reclaim_swap() while\n\t * hibernation is allocating its own swap pages for the image,\n\t * but conceivably even a call from memory reclaim - will free\n\t * the swap from a page which has already been recorded in the\n\t * image as a clean swapcache page, and then reuse its swap for\n\t * another page of the image.  On waking from hibernation, the\n\t * original page might be freed under memory pressure, then\n\t * later read back in from swap, now with the wrong data.\n\t *\n\t * Hibernation suspends storage while it is writing the image\n\t * to disk so check that here.\n\t */\n\tif (pm_suspended_storage())\n\t\treturn 0;\n\n\tpage = compound_head(page);\n\tdelete_from_swap_cache(page);\n\tSetPageDirty(page);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint try_to_free_swap(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tif (!PageSwapCache(page))\n\t\treturn 0;\n\tif (PageWriteback(page))\n\t\treturn 0;\n\tif (page_swapped(page))\n\t\treturn 0;\n\n\t/*\n\t * Once hibernation has begun to create its image of memory,\n\t * there's a danger that one of the calls to try_to_free_swap()\n\t * - most probably a call from __try_to_reclaim_swap() while\n\t * hibernation is allocating its own swap pages for the image,\n\t * but conceivably even a call from memory reclaim - will free\n\t * the swap from a page which has already been recorded in the\n\t * image as a clean swapcache page, and then reuse its swap for\n\t * another page of the image.  On waking from hibernation, the\n\t * original page might be freed under memory pressure, then\n\t * later read back in from swap, now with the wrong data.\n\t *\n\t * Hibernation suspends storage while it is writing the image\n\t * to disk so check that here.\n\t */\n\tif (pm_suspended_storage())\n\t\treturn 0;\n\n\tpage = compound_head(page);\n\tdelete_from_swap_cache(page);\n\tSetPageDirty(page);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapped",
          "args": [
            "page"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "470-486",
          "snippet": "bool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nbool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstatic inline void free_swap_cache(struct page *page)\n{\n\tif (PageSwapCache(page) && !page_mapped(page) && trylock_page(page)) {\n\t\ttry_to_free_swap(page);\n\t\tunlock_page(page);\n\t}\n}"
  },
  {
    "function_name": "delete_from_swap_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
    "lines": "243-254",
    "snippet": "void delete_from_swap_cache(struct page *page)\n{\n\tswp_entry_t entry = { .val = page_private(page) };\n\tstruct address_space *address_space = swap_address_space(entry);\n\n\txa_lock_irq(&address_space->i_pages);\n\t__delete_from_swap_cache(page, entry);\n\txa_unlock_irq(&address_space->i_pages);\n\n\tput_swap_page(page, entry);\n\tpage_ref_sub(page, hpage_nr_pages(page));\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/migrate.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_ref_sub",
          "args": [
            "page",
            "hpage_nr_pages(page)"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "page"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_swap_page",
          "args": [
            "page",
            "entry"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "put_swap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1225-1270",
          "snippet": "void put_swap_page(struct page *page, swp_entry_t entry)\n{\n\tunsigned long offset = swp_offset(entry);\n\tunsigned long idx = offset / SWAPFILE_CLUSTER;\n\tstruct swap_cluster_info *ci;\n\tstruct swap_info_struct *si;\n\tunsigned char *map;\n\tunsigned int i, free_entries = 0;\n\tunsigned char val;\n\tint size = swap_entry_size(hpage_nr_pages(page));\n\n\tsi = _swap_info_get(entry);\n\tif (!si)\n\t\treturn;\n\n\tci = lock_cluster_or_swap_info(si, offset);\n\tif (size == SWAPFILE_CLUSTER) {\n\t\tVM_BUG_ON(!cluster_is_huge(ci));\n\t\tmap = si->swap_map + offset;\n\t\tfor (i = 0; i < SWAPFILE_CLUSTER; i++) {\n\t\t\tval = map[i];\n\t\t\tVM_BUG_ON(!(val & SWAP_HAS_CACHE));\n\t\t\tif (val == SWAP_HAS_CACHE)\n\t\t\t\tfree_entries++;\n\t\t}\n\t\tcluster_clear_huge(ci);\n\t\tif (free_entries == SWAPFILE_CLUSTER) {\n\t\t\tunlock_cluster_or_swap_info(si, ci);\n\t\t\tspin_lock(&si->lock);\n\t\t\tmem_cgroup_uncharge_swap(entry, SWAPFILE_CLUSTER);\n\t\t\tswap_free_cluster(si, idx);\n\t\t\tspin_unlock(&si->lock);\n\t\t\treturn;\n\t\t}\n\t}\n\tfor (i = 0; i < size; i++, entry.val++) {\n\t\tif (!__swap_entry_free_locked(si, offset + i, SWAP_HAS_CACHE)) {\n\t\t\tunlock_cluster_or_swap_info(si, ci);\n\t\t\tfree_swap_slot(entry);\n\t\t\tif (i == size - 1)\n\t\t\t\treturn;\n\t\t\tlock_cluster_or_swap_info(si, offset);\n\t\t}\n\t}\n\tunlock_cluster_or_swap_info(si, ci);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SWAPFILE_CLUSTER\t256",
            "#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR"
          ],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define SWAPFILE_CLUSTER\t256\n#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nvoid put_swap_page(struct page *page, swp_entry_t entry)\n{\n\tunsigned long offset = swp_offset(entry);\n\tunsigned long idx = offset / SWAPFILE_CLUSTER;\n\tstruct swap_cluster_info *ci;\n\tstruct swap_info_struct *si;\n\tunsigned char *map;\n\tunsigned int i, free_entries = 0;\n\tunsigned char val;\n\tint size = swap_entry_size(hpage_nr_pages(page));\n\n\tsi = _swap_info_get(entry);\n\tif (!si)\n\t\treturn;\n\n\tci = lock_cluster_or_swap_info(si, offset);\n\tif (size == SWAPFILE_CLUSTER) {\n\t\tVM_BUG_ON(!cluster_is_huge(ci));\n\t\tmap = si->swap_map + offset;\n\t\tfor (i = 0; i < SWAPFILE_CLUSTER; i++) {\n\t\t\tval = map[i];\n\t\t\tVM_BUG_ON(!(val & SWAP_HAS_CACHE));\n\t\t\tif (val == SWAP_HAS_CACHE)\n\t\t\t\tfree_entries++;\n\t\t}\n\t\tcluster_clear_huge(ci);\n\t\tif (free_entries == SWAPFILE_CLUSTER) {\n\t\t\tunlock_cluster_or_swap_info(si, ci);\n\t\t\tspin_lock(&si->lock);\n\t\t\tmem_cgroup_uncharge_swap(entry, SWAPFILE_CLUSTER);\n\t\t\tswap_free_cluster(si, idx);\n\t\t\tspin_unlock(&si->lock);\n\t\t\treturn;\n\t\t}\n\t}\n\tfor (i = 0; i < size; i++, entry.val++) {\n\t\tif (!__swap_entry_free_locked(si, offset + i, SWAP_HAS_CACHE)) {\n\t\t\tunlock_cluster_or_swap_info(si, ci);\n\t\t\tfree_swap_slot(entry);\n\t\t\tif (i == size - 1)\n\t\t\t\treturn;\n\t\t\tlock_cluster_or_swap_info(si, offset);\n\t\t}\n\t}\n\tunlock_cluster_or_swap_info(si, ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xa_unlock_irq",
          "args": [
            "&address_space->i_pages"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__delete_from_swap_cache",
          "args": [
            "page",
            "entry"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "__delete_from_swap_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "157-178",
          "snippet": "void __delete_from_swap_cache(struct page *page, swp_entry_t entry)\n{\n\tstruct address_space *address_space = swap_address_space(entry);\n\tint i, nr = hpage_nr_pages(page);\n\tpgoff_t idx = swp_offset(entry);\n\tXA_STATE(xas, &address_space->i_pages, idx);\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(!PageSwapCache(page), page);\n\tVM_BUG_ON_PAGE(PageWriteback(page), page);\n\n\tfor (i = 0; i < nr; i++) {\n\t\tvoid *entry = xas_store(&xas, NULL);\n\t\tVM_BUG_ON_PAGE(entry != page + i, entry);\n\t\tset_page_private(page + i, 0);\n\t\txas_next(&xas);\n\t}\n\tClearPageSwapCache(page);\n\taddress_space->nrpages -= nr;\n\t__mod_node_page_state(page_pgdat(page), NR_FILE_PAGES, -nr);\n\tADD_CACHE_INFO(del_total, nr);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nvoid __delete_from_swap_cache(struct page *page, swp_entry_t entry)\n{\n\tstruct address_space *address_space = swap_address_space(entry);\n\tint i, nr = hpage_nr_pages(page);\n\tpgoff_t idx = swp_offset(entry);\n\tXA_STATE(xas, &address_space->i_pages, idx);\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(!PageSwapCache(page), page);\n\tVM_BUG_ON_PAGE(PageWriteback(page), page);\n\n\tfor (i = 0; i < nr; i++) {\n\t\tvoid *entry = xas_store(&xas, NULL);\n\t\tVM_BUG_ON_PAGE(entry != page + i, entry);\n\t\tset_page_private(page + i, 0);\n\t\txas_next(&xas);\n\t}\n\tClearPageSwapCache(page);\n\taddress_space->nrpages -= nr;\n\t__mod_node_page_state(page_pgdat(page), NR_FILE_PAGES, -nr);\n\tADD_CACHE_INFO(del_total, nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xa_lock_irq",
          "args": [
            "&address_space->i_pages"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_address_space",
          "args": [
            "entry"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "exit_swap_address_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "602-611",
          "snippet": "void exit_swap_address_space(unsigned int type)\n{\n\tstruct address_space *spaces;\n\n\tspaces = swapper_spaces[type];\n\tnr_swapper_spaces[type] = 0;\n\trcu_assign_pointer(swapper_spaces[type], NULL);\n\tsynchronize_rcu();\n\tkvfree(spaces);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct address_space *swapper_spaces[MAX_SWAPFILES]",
            "static unsigned int nr_swapper_spaces[MAX_SWAPFILES]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstruct address_space *swapper_spaces[MAX_SWAPFILES];\nstatic unsigned int nr_swapper_spaces[MAX_SWAPFILES];\n\nvoid exit_swap_address_space(unsigned int type)\n{\n\tstruct address_space *spaces;\n\n\tspaces = swapper_spaces[type];\n\tnr_swapper_spaces[type] = 0;\n\trcu_assign_pointer(swapper_spaces[type], NULL);\n\tsynchronize_rcu();\n\tkvfree(spaces);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "page"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nvoid delete_from_swap_cache(struct page *page)\n{\n\tswp_entry_t entry = { .val = page_private(page) };\n\tstruct address_space *address_space = swap_address_space(entry);\n\n\txa_lock_irq(&address_space->i_pages);\n\t__delete_from_swap_cache(page, entry);\n\txa_unlock_irq(&address_space->i_pages);\n\n\tput_swap_page(page, entry);\n\tpage_ref_sub(page, hpage_nr_pages(page));\n}"
  },
  {
    "function_name": "add_to_swap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
    "lines": "187-235",
    "snippet": "int add_to_swap(struct page *page)\n{\n\tswp_entry_t entry;\n\tint err;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(!PageUptodate(page), page);\n\n\tentry = get_swap_page(page);\n\tif (!entry.val)\n\t\treturn 0;\n\n\t/*\n\t * XArray node allocations from PF_MEMALLOC contexts could\n\t * completely exhaust the page allocator. __GFP_NOMEMALLOC\n\t * stops emergency reserves from being allocated.\n\t *\n\t * TODO: this could cause a theoretical memory reclaim\n\t * deadlock in the swap out path.\n\t */\n\t/*\n\t * Add it to the swap cache.\n\t */\n\terr = add_to_swap_cache(page, entry,\n\t\t\t__GFP_HIGH|__GFP_NOMEMALLOC|__GFP_NOWARN);\n\tif (err)\n\t\t/*\n\t\t * add_to_swap_cache() doesn't return -EEXIST, so we can safely\n\t\t * clear SWAP_HAS_CACHE flag.\n\t\t */\n\t\tgoto fail;\n\t/*\n\t * Normally the page will be dirtied in unmap because its pte should be\n\t * dirty. A special case is MADV_FREE page. The page'e pte could have\n\t * dirty bit cleared but the page's SwapBacked bit is still set because\n\t * clearing the dirty bit and SwapBacked bit has no lock protected. For\n\t * such page, unmap will not set dirty bit for it, so page reclaim will\n\t * not write the page out. This can cause data corruption when the page\n\t * is swap in later. Always setting the dirty bit for the page solves\n\t * the problem.\n\t */\n\tset_page_dirty(page);\n\n\treturn 1;\n\nfail:\n\tput_swap_page(page, entry);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/migrate.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_swap_page",
          "args": [
            "page",
            "entry"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "put_swap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1225-1270",
          "snippet": "void put_swap_page(struct page *page, swp_entry_t entry)\n{\n\tunsigned long offset = swp_offset(entry);\n\tunsigned long idx = offset / SWAPFILE_CLUSTER;\n\tstruct swap_cluster_info *ci;\n\tstruct swap_info_struct *si;\n\tunsigned char *map;\n\tunsigned int i, free_entries = 0;\n\tunsigned char val;\n\tint size = swap_entry_size(hpage_nr_pages(page));\n\n\tsi = _swap_info_get(entry);\n\tif (!si)\n\t\treturn;\n\n\tci = lock_cluster_or_swap_info(si, offset);\n\tif (size == SWAPFILE_CLUSTER) {\n\t\tVM_BUG_ON(!cluster_is_huge(ci));\n\t\tmap = si->swap_map + offset;\n\t\tfor (i = 0; i < SWAPFILE_CLUSTER; i++) {\n\t\t\tval = map[i];\n\t\t\tVM_BUG_ON(!(val & SWAP_HAS_CACHE));\n\t\t\tif (val == SWAP_HAS_CACHE)\n\t\t\t\tfree_entries++;\n\t\t}\n\t\tcluster_clear_huge(ci);\n\t\tif (free_entries == SWAPFILE_CLUSTER) {\n\t\t\tunlock_cluster_or_swap_info(si, ci);\n\t\t\tspin_lock(&si->lock);\n\t\t\tmem_cgroup_uncharge_swap(entry, SWAPFILE_CLUSTER);\n\t\t\tswap_free_cluster(si, idx);\n\t\t\tspin_unlock(&si->lock);\n\t\t\treturn;\n\t\t}\n\t}\n\tfor (i = 0; i < size; i++, entry.val++) {\n\t\tif (!__swap_entry_free_locked(si, offset + i, SWAP_HAS_CACHE)) {\n\t\t\tunlock_cluster_or_swap_info(si, ci);\n\t\t\tfree_swap_slot(entry);\n\t\t\tif (i == size - 1)\n\t\t\t\treturn;\n\t\t\tlock_cluster_or_swap_info(si, offset);\n\t\t}\n\t}\n\tunlock_cluster_or_swap_info(si, ci);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SWAPFILE_CLUSTER\t256",
            "#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR"
          ],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\n#define SWAPFILE_CLUSTER\t256\n#define SWAPFILE_CLUSTER\tHPAGE_PMD_NR\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nvoid put_swap_page(struct page *page, swp_entry_t entry)\n{\n\tunsigned long offset = swp_offset(entry);\n\tunsigned long idx = offset / SWAPFILE_CLUSTER;\n\tstruct swap_cluster_info *ci;\n\tstruct swap_info_struct *si;\n\tunsigned char *map;\n\tunsigned int i, free_entries = 0;\n\tunsigned char val;\n\tint size = swap_entry_size(hpage_nr_pages(page));\n\n\tsi = _swap_info_get(entry);\n\tif (!si)\n\t\treturn;\n\n\tci = lock_cluster_or_swap_info(si, offset);\n\tif (size == SWAPFILE_CLUSTER) {\n\t\tVM_BUG_ON(!cluster_is_huge(ci));\n\t\tmap = si->swap_map + offset;\n\t\tfor (i = 0; i < SWAPFILE_CLUSTER; i++) {\n\t\t\tval = map[i];\n\t\t\tVM_BUG_ON(!(val & SWAP_HAS_CACHE));\n\t\t\tif (val == SWAP_HAS_CACHE)\n\t\t\t\tfree_entries++;\n\t\t}\n\t\tcluster_clear_huge(ci);\n\t\tif (free_entries == SWAPFILE_CLUSTER) {\n\t\t\tunlock_cluster_or_swap_info(si, ci);\n\t\t\tspin_lock(&si->lock);\n\t\t\tmem_cgroup_uncharge_swap(entry, SWAPFILE_CLUSTER);\n\t\t\tswap_free_cluster(si, idx);\n\t\t\tspin_unlock(&si->lock);\n\t\t\treturn;\n\t\t}\n\t}\n\tfor (i = 0; i < size; i++, entry.val++) {\n\t\tif (!__swap_entry_free_locked(si, offset + i, SWAP_HAS_CACHE)) {\n\t\t\tunlock_cluster_or_swap_info(si, ci);\n\t\t\tfree_swap_slot(entry);\n\t\t\tif (i == size - 1)\n\t\t\t\treturn;\n\t\t\tlock_cluster_or_swap_info(si, offset);\n\t\t}\n\t}\n\tunlock_cluster_or_swap_info(si, ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_dirty_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2573-2581",
          "snippet": "int set_page_dirty_lock(struct page *page)\n{\n\tint ret;\n\n\tlock_page(page);\n\tret = set_page_dirty(page);\n\tunlock_page(page);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint set_page_dirty_lock(struct page *page)\n{\n\tint ret;\n\n\tlock_page(page);\n\tret = set_page_dirty(page);\n\tunlock_page(page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_to_swap_cache",
          "args": [
            "page",
            "entry",
            "__GFP_HIGH|__GFP_NOMEMALLOC|__GFP_NOWARN"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "add_to_swap_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "113-151",
          "snippet": "int add_to_swap_cache(struct page *page, swp_entry_t entry, gfp_t gfp)\n{\n\tstruct address_space *address_space = swap_address_space(entry);\n\tpgoff_t idx = swp_offset(entry);\n\tXA_STATE_ORDER(xas, &address_space->i_pages, idx, compound_order(page));\n\tunsigned long i, nr = 1UL << compound_order(page);\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(PageSwapCache(page), page);\n\tVM_BUG_ON_PAGE(!PageSwapBacked(page), page);\n\n\tpage_ref_add(page, nr);\n\tSetPageSwapCache(page);\n\n\tdo {\n\t\txas_lock_irq(&xas);\n\t\txas_create_range(&xas);\n\t\tif (xas_error(&xas))\n\t\t\tgoto unlock;\n\t\tfor (i = 0; i < nr; i++) {\n\t\t\tVM_BUG_ON_PAGE(xas.xa_index != idx + i, page);\n\t\t\tset_page_private(page + i, entry.val + i);\n\t\t\txas_store(&xas, page + i);\n\t\t\txas_next(&xas);\n\t\t}\n\t\taddress_space->nrpages += nr;\n\t\t__mod_node_page_state(page_pgdat(page), NR_FILE_PAGES, nr);\n\t\tADD_CACHE_INFO(add_total, nr);\nunlock:\n\t\txas_unlock_irq(&xas);\n\t} while (xas_nomem(&xas, gfp));\n\n\tif (!xas_error(&xas))\n\t\treturn 0;\n\n\tClearPageSwapCache(page);\n\tpage_ref_sub(page, nr);\n\treturn xas_error(&xas);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nint add_to_swap_cache(struct page *page, swp_entry_t entry, gfp_t gfp)\n{\n\tstruct address_space *address_space = swap_address_space(entry);\n\tpgoff_t idx = swp_offset(entry);\n\tXA_STATE_ORDER(xas, &address_space->i_pages, idx, compound_order(page));\n\tunsigned long i, nr = 1UL << compound_order(page);\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(PageSwapCache(page), page);\n\tVM_BUG_ON_PAGE(!PageSwapBacked(page), page);\n\n\tpage_ref_add(page, nr);\n\tSetPageSwapCache(page);\n\n\tdo {\n\t\txas_lock_irq(&xas);\n\t\txas_create_range(&xas);\n\t\tif (xas_error(&xas))\n\t\t\tgoto unlock;\n\t\tfor (i = 0; i < nr; i++) {\n\t\t\tVM_BUG_ON_PAGE(xas.xa_index != idx + i, page);\n\t\t\tset_page_private(page + i, entry.val + i);\n\t\t\txas_store(&xas, page + i);\n\t\t\txas_next(&xas);\n\t\t}\n\t\taddress_space->nrpages += nr;\n\t\t__mod_node_page_state(page_pgdat(page), NR_FILE_PAGES, nr);\n\t\tADD_CACHE_INFO(add_total, nr);\nunlock:\n\t\txas_unlock_irq(&xas);\n\t} while (xas_nomem(&xas, gfp));\n\n\tif (!xas_error(&xas))\n\t\treturn 0;\n\n\tClearPageSwapCache(page);\n\tpage_ref_sub(page, nr);\n\treturn xas_error(&xas);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_swap_page",
          "args": [
            "page"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "get_swap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_slots.c",
          "lines": "310-360",
          "snippet": "swp_entry_t get_swap_page(struct page *page)\n{\n\tswp_entry_t entry, *pentry;\n\tstruct swap_slots_cache *cache;\n\n\tentry.val = 0;\n\n\tif (PageTransHuge(page)) {\n\t\tif (IS_ENABLED(CONFIG_THP_SWAP))\n\t\t\tget_swap_pages(1, &entry, HPAGE_PMD_NR);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Preemption is allowed here, because we may sleep\n\t * in refill_swap_slots_cache().  But it is safe, because\n\t * accesses to the per-CPU data structure are protected by the\n\t * mutex cache->alloc_lock.\n\t *\n\t * The alloc path here does not touch cache->slots_ret\n\t * so cache->free_lock is not taken.\n\t */\n\tcache = raw_cpu_ptr(&swp_slots);\n\n\tif (likely(check_cache_active() && cache->slots)) {\n\t\tmutex_lock(&cache->alloc_lock);\n\t\tif (cache->slots) {\nrepeat:\n\t\t\tif (cache->nr) {\n\t\t\t\tpentry = &cache->slots[cache->cur++];\n\t\t\t\tentry = *pentry;\n\t\t\t\tpentry->val = 0;\n\t\t\t\tcache->nr--;\n\t\t\t} else {\n\t\t\t\tif (refill_swap_slots_cache(cache))\n\t\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&cache->alloc_lock);\n\t\tif (entry.val)\n\t\t\tgoto out;\n\t}\n\n\tget_swap_pages(1, &entry, 1);\nout:\n\tif (mem_cgroup_try_charge_swap(page, entry)) {\n\t\tput_swap_page(page, entry);\n\t\tentry.val = 0;\n\t}\n\treturn entry;\n}",
          "includes": [
            "#include <linux/mm.h>",
            "#include <linux/mutex.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_slots.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct swap_slots_cache, swp_slots);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mm.h>\n#include <linux/mutex.h>\n#include <linux/vmalloc.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/swap_slots.h>\n\nstatic DEFINE_PER_CPU(struct swap_slots_cache, swp_slots);\n\nswp_entry_t get_swap_page(struct page *page)\n{\n\tswp_entry_t entry, *pentry;\n\tstruct swap_slots_cache *cache;\n\n\tentry.val = 0;\n\n\tif (PageTransHuge(page)) {\n\t\tif (IS_ENABLED(CONFIG_THP_SWAP))\n\t\t\tget_swap_pages(1, &entry, HPAGE_PMD_NR);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Preemption is allowed here, because we may sleep\n\t * in refill_swap_slots_cache().  But it is safe, because\n\t * accesses to the per-CPU data structure are protected by the\n\t * mutex cache->alloc_lock.\n\t *\n\t * The alloc path here does not touch cache->slots_ret\n\t * so cache->free_lock is not taken.\n\t */\n\tcache = raw_cpu_ptr(&swp_slots);\n\n\tif (likely(check_cache_active() && cache->slots)) {\n\t\tmutex_lock(&cache->alloc_lock);\n\t\tif (cache->slots) {\nrepeat:\n\t\t\tif (cache->nr) {\n\t\t\t\tpentry = &cache->slots[cache->cur++];\n\t\t\t\tentry = *pentry;\n\t\t\t\tpentry->val = 0;\n\t\t\t\tcache->nr--;\n\t\t\t} else {\n\t\t\t\tif (refill_swap_slots_cache(cache))\n\t\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&cache->alloc_lock);\n\t\tif (entry.val)\n\t\t\tgoto out;\n\t}\n\n\tget_swap_pages(1, &entry, 1);\nout:\n\tif (mem_cgroup_try_charge_swap(page, entry)) {\n\t\tput_swap_page(page, entry);\n\t\tentry.val = 0;\n\t}\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageUptodate(page)",
            "page"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLocked(page)",
            "page"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nint add_to_swap(struct page *page)\n{\n\tswp_entry_t entry;\n\tint err;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(!PageUptodate(page), page);\n\n\tentry = get_swap_page(page);\n\tif (!entry.val)\n\t\treturn 0;\n\n\t/*\n\t * XArray node allocations from PF_MEMALLOC contexts could\n\t * completely exhaust the page allocator. __GFP_NOMEMALLOC\n\t * stops emergency reserves from being allocated.\n\t *\n\t * TODO: this could cause a theoretical memory reclaim\n\t * deadlock in the swap out path.\n\t */\n\t/*\n\t * Add it to the swap cache.\n\t */\n\terr = add_to_swap_cache(page, entry,\n\t\t\t__GFP_HIGH|__GFP_NOMEMALLOC|__GFP_NOWARN);\n\tif (err)\n\t\t/*\n\t\t * add_to_swap_cache() doesn't return -EEXIST, so we can safely\n\t\t * clear SWAP_HAS_CACHE flag.\n\t\t */\n\t\tgoto fail;\n\t/*\n\t * Normally the page will be dirtied in unmap because its pte should be\n\t * dirty. A special case is MADV_FREE page. The page'e pte could have\n\t * dirty bit cleared but the page's SwapBacked bit is still set because\n\t * clearing the dirty bit and SwapBacked bit has no lock protected. For\n\t * such page, unmap will not set dirty bit for it, so page reclaim will\n\t * not write the page out. This can cause data corruption when the page\n\t * is swap in later. Always setting the dirty bit for the page solves\n\t * the problem.\n\t */\n\tset_page_dirty(page);\n\n\treturn 1;\n\nfail:\n\tput_swap_page(page, entry);\n\treturn 0;\n}"
  },
  {
    "function_name": "__delete_from_swap_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
    "lines": "157-178",
    "snippet": "void __delete_from_swap_cache(struct page *page, swp_entry_t entry)\n{\n\tstruct address_space *address_space = swap_address_space(entry);\n\tint i, nr = hpage_nr_pages(page);\n\tpgoff_t idx = swp_offset(entry);\n\tXA_STATE(xas, &address_space->i_pages, idx);\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(!PageSwapCache(page), page);\n\tVM_BUG_ON_PAGE(PageWriteback(page), page);\n\n\tfor (i = 0; i < nr; i++) {\n\t\tvoid *entry = xas_store(&xas, NULL);\n\t\tVM_BUG_ON_PAGE(entry != page + i, entry);\n\t\tset_page_private(page + i, 0);\n\t\txas_next(&xas);\n\t}\n\tClearPageSwapCache(page);\n\taddress_space->nrpages -= nr;\n\t__mod_node_page_state(page_pgdat(page), NR_FILE_PAGES, -nr);\n\tADD_CACHE_INFO(del_total, nr);\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/migrate.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ADD_CACHE_INFO",
          "args": [
            "del_total",
            "nr"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mod_node_page_state",
          "args": [
            "page_pgdat(page)",
            "NR_FILE_PAGES",
            "-nr"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "__mod_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "335-352",
          "snippet": "void __mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,\n\t\t\t\tlong delta)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\tlong x;\n\tlong t;\n\n\tx = delta + __this_cpu_read(*p);\n\n\tt = __this_cpu_read(pcp->stat_threshold);\n\n\tif (unlikely(x > t || x < -t)) {\n\t\tnode_page_state_add(x, pgdat, item);\n\t\tx = 0;\n\t}\n\t__this_cpu_write(*p, x);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,\n\t\t\t\tlong delta)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\tlong x;\n\tlong t;\n\n\tx = delta + __this_cpu_read(*p);\n\n\tt = __this_cpu_read(pcp->stat_threshold);\n\n\tif (unlikely(x > t || x < -t)) {\n\t\tnode_page_state_add(x, pgdat, item);\n\t\tx = 0;\n\t}\n\t__this_cpu_write(*p, x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_pgdat",
          "args": [
            "page"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageSwapCache",
          "args": [
            "page"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_next",
          "args": [
            "&xas"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page + i",
            "0"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "entry != page + i",
            "entry"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_store",
          "args": [
            "&xas",
            "NULL"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageWriteback(page)",
            "page"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageSwapCache(page)",
            "page"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLocked(page)",
            "page"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XA_STATE",
          "args": [
            "xas",
            "&address_space->i_pages",
            "idx"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_offset",
          "args": [
            "entry"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "page"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_address_space",
          "args": [
            "entry"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "exit_swap_address_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "602-611",
          "snippet": "void exit_swap_address_space(unsigned int type)\n{\n\tstruct address_space *spaces;\n\n\tspaces = swapper_spaces[type];\n\tnr_swapper_spaces[type] = 0;\n\trcu_assign_pointer(swapper_spaces[type], NULL);\n\tsynchronize_rcu();\n\tkvfree(spaces);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct address_space *swapper_spaces[MAX_SWAPFILES]",
            "static unsigned int nr_swapper_spaces[MAX_SWAPFILES]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstruct address_space *swapper_spaces[MAX_SWAPFILES];\nstatic unsigned int nr_swapper_spaces[MAX_SWAPFILES];\n\nvoid exit_swap_address_space(unsigned int type)\n{\n\tstruct address_space *spaces;\n\n\tspaces = swapper_spaces[type];\n\tnr_swapper_spaces[type] = 0;\n\trcu_assign_pointer(swapper_spaces[type], NULL);\n\tsynchronize_rcu();\n\tkvfree(spaces);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nvoid __delete_from_swap_cache(struct page *page, swp_entry_t entry)\n{\n\tstruct address_space *address_space = swap_address_space(entry);\n\tint i, nr = hpage_nr_pages(page);\n\tpgoff_t idx = swp_offset(entry);\n\tXA_STATE(xas, &address_space->i_pages, idx);\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(!PageSwapCache(page), page);\n\tVM_BUG_ON_PAGE(PageWriteback(page), page);\n\n\tfor (i = 0; i < nr; i++) {\n\t\tvoid *entry = xas_store(&xas, NULL);\n\t\tVM_BUG_ON_PAGE(entry != page + i, entry);\n\t\tset_page_private(page + i, 0);\n\t\txas_next(&xas);\n\t}\n\tClearPageSwapCache(page);\n\taddress_space->nrpages -= nr;\n\t__mod_node_page_state(page_pgdat(page), NR_FILE_PAGES, -nr);\n\tADD_CACHE_INFO(del_total, nr);\n}"
  },
  {
    "function_name": "add_to_swap_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
    "lines": "113-151",
    "snippet": "int add_to_swap_cache(struct page *page, swp_entry_t entry, gfp_t gfp)\n{\n\tstruct address_space *address_space = swap_address_space(entry);\n\tpgoff_t idx = swp_offset(entry);\n\tXA_STATE_ORDER(xas, &address_space->i_pages, idx, compound_order(page));\n\tunsigned long i, nr = 1UL << compound_order(page);\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(PageSwapCache(page), page);\n\tVM_BUG_ON_PAGE(!PageSwapBacked(page), page);\n\n\tpage_ref_add(page, nr);\n\tSetPageSwapCache(page);\n\n\tdo {\n\t\txas_lock_irq(&xas);\n\t\txas_create_range(&xas);\n\t\tif (xas_error(&xas))\n\t\t\tgoto unlock;\n\t\tfor (i = 0; i < nr; i++) {\n\t\t\tVM_BUG_ON_PAGE(xas.xa_index != idx + i, page);\n\t\t\tset_page_private(page + i, entry.val + i);\n\t\t\txas_store(&xas, page + i);\n\t\t\txas_next(&xas);\n\t\t}\n\t\taddress_space->nrpages += nr;\n\t\t__mod_node_page_state(page_pgdat(page), NR_FILE_PAGES, nr);\n\t\tADD_CACHE_INFO(add_total, nr);\nunlock:\n\t\txas_unlock_irq(&xas);\n\t} while (xas_nomem(&xas, gfp));\n\n\tif (!xas_error(&xas))\n\t\treturn 0;\n\n\tClearPageSwapCache(page);\n\tpage_ref_sub(page, nr);\n\treturn xas_error(&xas);\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/migrate.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xas_error",
          "args": [
            "&xas"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_ref_sub",
          "args": [
            "page",
            "nr"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageSwapCache",
          "args": [
            "page"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_error",
          "args": [
            "&xas"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_nomem",
          "args": [
            "&xas",
            "gfp"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_unlock_irq",
          "args": [
            "&xas"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADD_CACHE_INFO",
          "args": [
            "add_total",
            "nr"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mod_node_page_state",
          "args": [
            "page_pgdat(page)",
            "NR_FILE_PAGES",
            "nr"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "__mod_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "335-352",
          "snippet": "void __mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,\n\t\t\t\tlong delta)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\tlong x;\n\tlong t;\n\n\tx = delta + __this_cpu_read(*p);\n\n\tt = __this_cpu_read(pcp->stat_threshold);\n\n\tif (unlikely(x > t || x < -t)) {\n\t\tnode_page_state_add(x, pgdat, item);\n\t\tx = 0;\n\t}\n\t__this_cpu_write(*p, x);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,\n\t\t\t\tlong delta)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\tlong x;\n\tlong t;\n\n\tx = delta + __this_cpu_read(*p);\n\n\tt = __this_cpu_read(pcp->stat_threshold);\n\n\tif (unlikely(x > t || x < -t)) {\n\t\tnode_page_state_add(x, pgdat, item);\n\t\tx = 0;\n\t}\n\t__this_cpu_write(*p, x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_pgdat",
          "args": [
            "page"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_next",
          "args": [
            "&xas"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_store",
          "args": [
            "&xas",
            "page + i"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page + i",
            "entry.val + i"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "xas.xa_index != idx + i",
            "page"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_error",
          "args": [
            "&xas"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_create_range",
          "args": [
            "&xas"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_lock_irq",
          "args": [
            "&xas"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageSwapCache",
          "args": [
            "page"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_ref_add",
          "args": [
            "page",
            "nr"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageSwapBacked(page)",
            "page"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapBacked",
          "args": [
            "page"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageSwapCache(page)",
            "page"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLocked(page)",
            "page"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "page"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XA_STATE_ORDER",
          "args": [
            "xas",
            "&address_space->i_pages",
            "idx",
            "compound_order(page)"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "page"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_offset",
          "args": [
            "entry"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_address_space",
          "args": [
            "entry"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "exit_swap_address_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "602-611",
          "snippet": "void exit_swap_address_space(unsigned int type)\n{\n\tstruct address_space *spaces;\n\n\tspaces = swapper_spaces[type];\n\tnr_swapper_spaces[type] = 0;\n\trcu_assign_pointer(swapper_spaces[type], NULL);\n\tsynchronize_rcu();\n\tkvfree(spaces);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct address_space *swapper_spaces[MAX_SWAPFILES]",
            "static unsigned int nr_swapper_spaces[MAX_SWAPFILES]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstruct address_space *swapper_spaces[MAX_SWAPFILES];\nstatic unsigned int nr_swapper_spaces[MAX_SWAPFILES];\n\nvoid exit_swap_address_space(unsigned int type)\n{\n\tstruct address_space *spaces;\n\n\tspaces = swapper_spaces[type];\n\tnr_swapper_spaces[type] = 0;\n\trcu_assign_pointer(swapper_spaces[type], NULL);\n\tsynchronize_rcu();\n\tkvfree(spaces);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nint add_to_swap_cache(struct page *page, swp_entry_t entry, gfp_t gfp)\n{\n\tstruct address_space *address_space = swap_address_space(entry);\n\tpgoff_t idx = swp_offset(entry);\n\tXA_STATE_ORDER(xas, &address_space->i_pages, idx, compound_order(page));\n\tunsigned long i, nr = 1UL << compound_order(page);\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON_PAGE(PageSwapCache(page), page);\n\tVM_BUG_ON_PAGE(!PageSwapBacked(page), page);\n\n\tpage_ref_add(page, nr);\n\tSetPageSwapCache(page);\n\n\tdo {\n\t\txas_lock_irq(&xas);\n\t\txas_create_range(&xas);\n\t\tif (xas_error(&xas))\n\t\t\tgoto unlock;\n\t\tfor (i = 0; i < nr; i++) {\n\t\t\tVM_BUG_ON_PAGE(xas.xa_index != idx + i, page);\n\t\t\tset_page_private(page + i, entry.val + i);\n\t\t\txas_store(&xas, page + i);\n\t\t\txas_next(&xas);\n\t\t}\n\t\taddress_space->nrpages += nr;\n\t\t__mod_node_page_state(page_pgdat(page), NR_FILE_PAGES, nr);\n\t\tADD_CACHE_INFO(add_total, nr);\nunlock:\n\t\txas_unlock_irq(&xas);\n\t} while (xas_nomem(&xas, gfp));\n\n\tif (!xas_error(&xas))\n\t\treturn 0;\n\n\tClearPageSwapCache(page);\n\tpage_ref_sub(page, nr);\n\treturn xas_error(&xas);\n}"
  },
  {
    "function_name": "show_swap_cache_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
    "lines": "98-107",
    "snippet": "void show_swap_cache_info(void)\n{\n\tprintk(\"%lu pages in swap cache\\n\", total_swapcache_pages());\n\tprintk(\"Swap cache stats: add %lu, delete %lu, find %lu/%lu\\n\",\n\t\tswap_cache_info.add_total, swap_cache_info.del_total,\n\t\tswap_cache_info.find_success, swap_cache_info.find_total);\n\tprintk(\"Free swap  = %ldkB\\n\",\n\t\tget_nr_swap_pages() << (PAGE_SHIFT - 10));\n\tprintk(\"Total swap = %lukB\\n\", total_swap_pages << (PAGE_SHIFT - 10));\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/migrate.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n\tunsigned long add_total;\n\tunsigned long del_total;\n\tunsigned long find_success;\n\tunsigned long find_total;\n} swap_cache_info;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Total swap = %lukB\\n\"",
            "total_swap_pages << (PAGE_SHIFT - 10)"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Free swap  = %ldkB\\n\"",
            "get_nr_swap_pages() << (PAGE_SHIFT - 10)"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_nr_swap_pages",
          "args": [],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Swap cache stats: add %lu, delete %lu, find %lu/%lu\\n\"",
            "swap_cache_info.add_total",
            "swap_cache_info.del_total",
            "swap_cache_info.find_success",
            "swap_cache_info.find_total"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "mminit_dprintk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "417-420",
          "snippet": "static inline void mminit_dprintk(enum mminit_level level,\n\t\t\t\tconst char *prefix, const char *fmt, ...)\n{\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void mminit_dprintk(enum mminit_level level,\n\t\t\t\tconst char *prefix, const char *fmt, ...)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%lu pages in swap cache\\n\"",
            "total_swapcache_pages()"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "total_swapcache_pages",
          "args": [],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "total_swapcache_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "71-94",
          "snippet": "unsigned long total_swapcache_pages(void)\n{\n\tunsigned int i, j, nr;\n\tunsigned long ret = 0;\n\tstruct address_space *spaces;\n\n\trcu_read_lock();\n\tfor (i = 0; i < MAX_SWAPFILES; i++) {\n\t\t/*\n\t\t * The corresponding entries in nr_swapper_spaces and\n\t\t * swapper_spaces will be reused only after at least\n\t\t * one grace period.  So it is impossible for them\n\t\t * belongs to different usage.\n\t\t */\n\t\tnr = nr_swapper_spaces[i];\n\t\tspaces = rcu_dereference(swapper_spaces[i]);\n\t\tif (!nr || !spaces)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < nr; j++)\n\t\t\tret += spaces[j].nrpages;\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct address_space *swapper_spaces[MAX_SWAPFILES]",
            "static unsigned int nr_swapper_spaces[MAX_SWAPFILES]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstruct address_space *swapper_spaces[MAX_SWAPFILES];\nstatic unsigned int nr_swapper_spaces[MAX_SWAPFILES];\n\nunsigned long total_swapcache_pages(void)\n{\n\tunsigned int i, j, nr;\n\tunsigned long ret = 0;\n\tstruct address_space *spaces;\n\n\trcu_read_lock();\n\tfor (i = 0; i < MAX_SWAPFILES; i++) {\n\t\t/*\n\t\t * The corresponding entries in nr_swapper_spaces and\n\t\t * swapper_spaces will be reused only after at least\n\t\t * one grace period.  So it is impossible for them\n\t\t * belongs to different usage.\n\t\t */\n\t\tnr = nr_swapper_spaces[i];\n\t\tspaces = rcu_dereference(swapper_spaces[i]);\n\t\tif (!nr || !spaces)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < nr; j++)\n\t\t\tret += spaces[j].nrpages;\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstatic struct {\n\tunsigned long add_total;\n\tunsigned long del_total;\n\tunsigned long find_success;\n\tunsigned long find_total;\n} swap_cache_info;\n\nvoid show_swap_cache_info(void)\n{\n\tprintk(\"%lu pages in swap cache\\n\", total_swapcache_pages());\n\tprintk(\"Swap cache stats: add %lu, delete %lu, find %lu/%lu\\n\",\n\t\tswap_cache_info.add_total, swap_cache_info.del_total,\n\t\tswap_cache_info.find_success, swap_cache_info.find_total);\n\tprintk(\"Free swap  = %ldkB\\n\",\n\t\tget_nr_swap_pages() << (PAGE_SHIFT - 10));\n\tprintk(\"Total swap = %lukB\\n\", total_swap_pages << (PAGE_SHIFT - 10));\n}"
  },
  {
    "function_name": "total_swapcache_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
    "lines": "71-94",
    "snippet": "unsigned long total_swapcache_pages(void)\n{\n\tunsigned int i, j, nr;\n\tunsigned long ret = 0;\n\tstruct address_space *spaces;\n\n\trcu_read_lock();\n\tfor (i = 0; i < MAX_SWAPFILES; i++) {\n\t\t/*\n\t\t * The corresponding entries in nr_swapper_spaces and\n\t\t * swapper_spaces will be reused only after at least\n\t\t * one grace period.  So it is impossible for them\n\t\t * belongs to different usage.\n\t\t */\n\t\tnr = nr_swapper_spaces[i];\n\t\tspaces = rcu_dereference(swapper_spaces[i]);\n\t\tif (!nr || !spaces)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < nr; j++)\n\t\t\tret += spaces[j].nrpages;\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}",
    "includes": [
      "#include <asm/pgtable.h>",
      "#include <linux/huge_mm.h>",
      "#include <linux/swap_slots.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/migrate.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/swapops.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/gfp.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct address_space *swapper_spaces[MAX_SWAPFILES]",
      "static unsigned int nr_swapper_spaces[MAX_SWAPFILES]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "swapper_spaces[i]"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstruct address_space *swapper_spaces[MAX_SWAPFILES];\nstatic unsigned int nr_swapper_spaces[MAX_SWAPFILES];\n\nunsigned long total_swapcache_pages(void)\n{\n\tunsigned int i, j, nr;\n\tunsigned long ret = 0;\n\tstruct address_space *spaces;\n\n\trcu_read_lock();\n\tfor (i = 0; i < MAX_SWAPFILES; i++) {\n\t\t/*\n\t\t * The corresponding entries in nr_swapper_spaces and\n\t\t * swapper_spaces will be reused only after at least\n\t\t * one grace period.  So it is impossible for them\n\t\t * belongs to different usage.\n\t\t */\n\t\tnr = nr_swapper_spaces[i];\n\t\tspaces = rcu_dereference(swapper_spaces[i]);\n\t\tif (!nr || !spaces)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < nr; j++)\n\t\t\tret += spaces[j].nrpages;\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}"
  }
]