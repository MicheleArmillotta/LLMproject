[
  {
    "function_name": "hmm_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "1452-1468",
    "snippet": "static int __init hmm_init(void)\n{\n\tint ret;\n\n\tret = alloc_chrdev_region(&hmm_device_devt, 0,\n\t\t\t\t  HMM_DEVICE_MAX,\n\t\t\t\t  \"hmm_device\");\n\tif (ret)\n\t\treturn ret;\n\n\thmm_device_class = class_create(THIS_MODULE, \"hmm_device\");\n\tif (IS_ERR(hmm_device_class)) {\n\t\tunregister_chrdev_region(hmm_device_devt, HMM_DEVICE_MAX);\n\t\treturn PTR_ERR(hmm_device_class);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define HMM_DEVICE_MAX 256"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "hmm_device_class"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_chrdev_region",
          "args": [
            "hmm_device_devt",
            "HMM_DEVICE_MAX"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "hmm_device_class"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "class_create",
          "args": [
            "THIS_MODULE",
            "\"hmm_device\""
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_chrdev_region",
          "args": [
            "&hmm_device_devt",
            "0",
            "HMM_DEVICE_MAX",
            "\"hmm_device\""
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\n#define HMM_DEVICE_MAX 256\n\nstatic int __init hmm_init(void)\n{\n\tint ret;\n\n\tret = alloc_chrdev_region(&hmm_device_devt, 0,\n\t\t\t\t  HMM_DEVICE_MAX,\n\t\t\t\t  \"hmm_device\");\n\tif (ret)\n\t\treturn ret;\n\n\thmm_device_class = class_create(THIS_MODULE, \"hmm_device\");\n\tif (IS_ERR(hmm_device_class)) {\n\t\tunregister_chrdev_region(hmm_device_devt, HMM_DEVICE_MAX);\n\t\treturn PTR_ERR(hmm_device_class);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "hmm_device_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "1446-1449",
    "snippet": "void hmm_device_put(struct hmm_device *hmm_device)\n{\n\tput_device(&hmm_device->device);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_device",
          "args": [
            "&hmm_device->device"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nvoid hmm_device_put(struct hmm_device *hmm_device)\n{\n\tput_device(&hmm_device->device);\n}"
  },
  {
    "function_name": "hmm_device_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "1416-1443",
    "snippet": "struct hmm_device *hmm_device_new(void *drvdata)\n{\n\tstruct hmm_device *hmm_device;\n\n\thmm_device = kzalloc(sizeof(*hmm_device), GFP_KERNEL);\n\tif (!hmm_device)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tspin_lock(&hmm_device_lock);\n\thmm_device->minor = find_first_zero_bit(hmm_device_mask, HMM_DEVICE_MAX);\n\tif (hmm_device->minor >= HMM_DEVICE_MAX) {\n\t\tspin_unlock(&hmm_device_lock);\n\t\tkfree(hmm_device);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\tset_bit(hmm_device->minor, hmm_device_mask);\n\tspin_unlock(&hmm_device_lock);\n\n\tdev_set_name(&hmm_device->device, \"hmm_device%d\", hmm_device->minor);\n\thmm_device->device.devt = MKDEV(MAJOR(hmm_device_devt),\n\t\t\t\t\thmm_device->minor);\n\thmm_device->device.release = hmm_device_release;\n\tdev_set_drvdata(&hmm_device->device, drvdata);\n\thmm_device->device.class = hmm_device_class;\n\tdevice_initialize(&hmm_device->device);\n\n\treturn hmm_device;\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define HMM_DEVICE_MAX 256"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "device_initialize",
          "args": [
            "&hmm_device->device"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_set_drvdata",
          "args": [
            "&hmm_device->device",
            "drvdata"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MKDEV",
          "args": [
            "MAJOR(hmm_device_devt)",
            "hmm_device->minor"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "hmm_device_devt"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_set_name",
          "args": [
            "&hmm_device->device",
            "\"hmm_device%d\"",
            "hmm_device->minor"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hmm_device_lock"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "hmm_device->minor",
            "hmm_device_mask"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EBUSY"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "hmm_device"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hmm_device_lock"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_first_zero_bit",
          "args": [
            "hmm_device_mask",
            "HMM_DEVICE_MAX"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hmm_device_lock"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*hmm_device)",
            "GFP_KERNEL"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\n#define HMM_DEVICE_MAX 256\n\nstruct hmm_device *hmm_device_new(void *drvdata)\n{\n\tstruct hmm_device *hmm_device;\n\n\thmm_device = kzalloc(sizeof(*hmm_device), GFP_KERNEL);\n\tif (!hmm_device)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tspin_lock(&hmm_device_lock);\n\thmm_device->minor = find_first_zero_bit(hmm_device_mask, HMM_DEVICE_MAX);\n\tif (hmm_device->minor >= HMM_DEVICE_MAX) {\n\t\tspin_unlock(&hmm_device_lock);\n\t\tkfree(hmm_device);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\tset_bit(hmm_device->minor, hmm_device_mask);\n\tspin_unlock(&hmm_device_lock);\n\n\tdev_set_name(&hmm_device->device, \"hmm_device%d\", hmm_device->minor);\n\thmm_device->device.devt = MKDEV(MAJOR(hmm_device_devt),\n\t\t\t\t\thmm_device->minor);\n\thmm_device->device.release = hmm_device_release;\n\tdev_set_drvdata(&hmm_device->device, drvdata);\n\thmm_device->device.class = hmm_device_class;\n\tdevice_initialize(&hmm_device->device);\n\n\treturn hmm_device;\n}"
  },
  {
    "function_name": "hmm_device_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "1404-1414",
    "snippet": "static void hmm_device_release(struct device *device)\n{\n\tstruct hmm_device *hmm_device;\n\n\thmm_device = container_of(device, struct hmm_device, device);\n\tspin_lock(&hmm_device_lock);\n\tclear_bit(hmm_device->minor, hmm_device_mask);\n\tspin_unlock(&hmm_device_lock);\n\n\tkfree(hmm_device);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "hmm_device"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hmm_device_lock"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "hmm_device->minor",
            "hmm_device_mask"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "clear_bit_unlock_is_negative_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1171-1176",
          "snippet": "static inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hmm_device_lock"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "device",
            "structhmm_device",
            "device"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic void hmm_device_release(struct device *device)\n{\n\tstruct hmm_device *hmm_device;\n\n\thmm_device = container_of(device, struct hmm_device, device);\n\tspin_lock(&hmm_device_lock);\n\tclear_bit(hmm_device->minor, hmm_device_mask);\n\tspin_unlock(&hmm_device_lock);\n\n\tkfree(hmm_device);\n}"
  },
  {
    "function_name": "hmm_devmem_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "1369-1389",
    "snippet": "void hmm_devmem_remove(struct hmm_devmem *devmem)\n{\n\tresource_size_t start, size;\n\tstruct device *device;\n\tbool cdm = false;\n\n\tif (!devmem)\n\t\treturn;\n\n\tdevice = devmem->device;\n\tstart = devmem->resource->start;\n\tsize = resource_size(devmem->resource);\n\n\tcdm = devmem->resource->desc == IORES_DESC_DEVICE_PUBLIC_MEMORY;\n\thmm_devmem_ref_kill(&devmem->ref);\n\thmm_devmem_ref_exit(&devmem->ref);\n\thmm_devmem_pages_remove(devmem);\n\n\tif (!cdm)\n\t\tdevm_release_mem_region(device, start, size);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "devm_release_mem_region",
          "args": [
            "device",
            "start",
            "size"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hmm_devmem_pages_remove",
          "args": [
            "devmem"
          ],
          "line": 1385
        },
        "resolved": true,
        "details": {
          "function_name": "hmm_devmem_pages_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
          "lines": "1184-1188",
          "snippet": "static void hmm_devmem_pages_remove(struct hmm_devmem *devmem)\n{\n\tdevres_release(devmem->device, &hmm_devmem_release,\n\t\t       &hmm_devmem_match, devmem->resource);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/memremap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/init.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic void hmm_devmem_pages_remove(struct hmm_devmem *devmem)\n{\n\tdevres_release(devmem->device, &hmm_devmem_release,\n\t\t       &hmm_devmem_match, devmem->resource);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hmm_devmem_ref_exit",
          "args": [
            "&devmem->ref"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "hmm_devmem_ref_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
          "lines": "983-991",
          "snippet": "static void hmm_devmem_ref_exit(void *data)\n{\n\tstruct percpu_ref *ref = data;\n\tstruct hmm_devmem *devmem;\n\n\tdevmem = container_of(ref, struct hmm_devmem, ref);\n\tpercpu_ref_exit(ref);\n\tdevm_remove_action(devmem->device, &hmm_devmem_ref_exit, data);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/memremap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/init.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic void hmm_devmem_ref_exit(void *data)\n{\n\tstruct percpu_ref *ref = data;\n\tstruct hmm_devmem *devmem;\n\n\tdevmem = container_of(ref, struct hmm_devmem, ref);\n\tpercpu_ref_exit(ref);\n\tdevm_remove_action(devmem->device, &hmm_devmem_ref_exit, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hmm_devmem_ref_kill",
          "args": [
            "&devmem->ref"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "hmm_devmem_ref_kill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
          "lines": "993-1002",
          "snippet": "static void hmm_devmem_ref_kill(void *data)\n{\n\tstruct percpu_ref *ref = data;\n\tstruct hmm_devmem *devmem;\n\n\tdevmem = container_of(ref, struct hmm_devmem, ref);\n\tpercpu_ref_kill(ref);\n\twait_for_completion(&devmem->completion);\n\tdevm_remove_action(devmem->device, &hmm_devmem_ref_kill, data);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/memremap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/init.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic void hmm_devmem_ref_kill(void *data)\n{\n\tstruct percpu_ref *ref = data;\n\tstruct hmm_devmem *devmem;\n\n\tdevmem = container_of(ref, struct hmm_devmem, ref);\n\tpercpu_ref_kill(ref);\n\twait_for_completion(&devmem->completion);\n\tdevm_remove_action(devmem->device, &hmm_devmem_ref_kill, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "resource_size",
          "args": [
            "devmem->resource"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nvoid hmm_devmem_remove(struct hmm_devmem *devmem)\n{\n\tresource_size_t start, size;\n\tstruct device *device;\n\tbool cdm = false;\n\n\tif (!devmem)\n\t\treturn;\n\n\tdevice = devmem->device;\n\tstart = devmem->resource->start;\n\tsize = resource_size(devmem->resource);\n\n\tcdm = devmem->resource->desc == IORES_DESC_DEVICE_PUBLIC_MEMORY;\n\thmm_devmem_ref_kill(&devmem->ref);\n\thmm_devmem_ref_exit(&devmem->ref);\n\thmm_devmem_pages_remove(devmem);\n\n\tif (!cdm)\n\t\tdevm_release_mem_region(device, start, size);\n}"
  },
  {
    "function_name": "hmm_devmem_add_resource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "1299-1357",
    "snippet": "struct hmm_devmem *hmm_devmem_add_resource(const struct hmm_devmem_ops *ops,\n\t\t\t\t\t   struct device *device,\n\t\t\t\t\t   struct resource *res)\n{\n\tstruct hmm_devmem *devmem;\n\tint ret;\n\n\tif (res->desc != IORES_DESC_DEVICE_PUBLIC_MEMORY)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdev_pagemap_get_ops();\n\n\tdevmem = devres_alloc_node(&hmm_devmem_release, sizeof(*devmem),\n\t\t\t\t   GFP_KERNEL, dev_to_node(device));\n\tif (!devmem)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit_completion(&devmem->completion);\n\tdevmem->pfn_first = -1UL;\n\tdevmem->pfn_last = -1UL;\n\tdevmem->resource = res;\n\tdevmem->device = device;\n\tdevmem->ops = ops;\n\n\tret = percpu_ref_init(&devmem->ref, &hmm_devmem_ref_release,\n\t\t\t      0, GFP_KERNEL);\n\tif (ret)\n\t\tgoto error_percpu_ref;\n\n\tret = devm_add_action(device, hmm_devmem_ref_exit, &devmem->ref);\n\tif (ret)\n\t\tgoto error_devm_add_action;\n\n\n\tdevmem->pfn_first = devmem->resource->start >> PAGE_SHIFT;\n\tdevmem->pfn_last = devmem->pfn_first +\n\t\t\t   (resource_size(devmem->resource) >> PAGE_SHIFT);\n\n\tret = hmm_devmem_pages_create(devmem);\n\tif (ret)\n\t\tgoto error_devm_add_action;\n\n\tdevres_add(device, devmem);\n\n\tret = devm_add_action(device, hmm_devmem_ref_kill, &devmem->ref);\n\tif (ret) {\n\t\thmm_devmem_remove(devmem);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn devmem;\n\nerror_devm_add_action:\n\thmm_devmem_ref_kill(&devmem->ref);\n\thmm_devmem_ref_exit(&devmem->ref);\nerror_percpu_ref:\n\tdevres_free(devmem);\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devres_free",
          "args": [
            "devmem"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hmm_devmem_ref_exit",
          "args": [
            "&devmem->ref"
          ],
          "line": 1353
        },
        "resolved": true,
        "details": {
          "function_name": "hmm_devmem_ref_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
          "lines": "983-991",
          "snippet": "static void hmm_devmem_ref_exit(void *data)\n{\n\tstruct percpu_ref *ref = data;\n\tstruct hmm_devmem *devmem;\n\n\tdevmem = container_of(ref, struct hmm_devmem, ref);\n\tpercpu_ref_exit(ref);\n\tdevm_remove_action(devmem->device, &hmm_devmem_ref_exit, data);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/memremap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/init.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic void hmm_devmem_ref_exit(void *data)\n{\n\tstruct percpu_ref *ref = data;\n\tstruct hmm_devmem *devmem;\n\n\tdevmem = container_of(ref, struct hmm_devmem, ref);\n\tpercpu_ref_exit(ref);\n\tdevm_remove_action(devmem->device, &hmm_devmem_ref_exit, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hmm_devmem_ref_kill",
          "args": [
            "&devmem->ref"
          ],
          "line": 1352
        },
        "resolved": true,
        "details": {
          "function_name": "hmm_devmem_ref_kill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
          "lines": "993-1002",
          "snippet": "static void hmm_devmem_ref_kill(void *data)\n{\n\tstruct percpu_ref *ref = data;\n\tstruct hmm_devmem *devmem;\n\n\tdevmem = container_of(ref, struct hmm_devmem, ref);\n\tpercpu_ref_kill(ref);\n\twait_for_completion(&devmem->completion);\n\tdevm_remove_action(devmem->device, &hmm_devmem_ref_kill, data);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/memremap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/init.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic void hmm_devmem_ref_kill(void *data)\n{\n\tstruct percpu_ref *ref = data;\n\tstruct hmm_devmem *devmem;\n\n\tdevmem = container_of(ref, struct hmm_devmem, ref);\n\tpercpu_ref_kill(ref);\n\twait_for_completion(&devmem->completion);\n\tdevm_remove_action(devmem->device, &hmm_devmem_ref_kill, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hmm_devmem_remove",
          "args": [
            "devmem"
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "hmm_devmem_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
          "lines": "1369-1389",
          "snippet": "void hmm_devmem_remove(struct hmm_devmem *devmem)\n{\n\tresource_size_t start, size;\n\tstruct device *device;\n\tbool cdm = false;\n\n\tif (!devmem)\n\t\treturn;\n\n\tdevice = devmem->device;\n\tstart = devmem->resource->start;\n\tsize = resource_size(devmem->resource);\n\n\tcdm = devmem->resource->desc == IORES_DESC_DEVICE_PUBLIC_MEMORY;\n\thmm_devmem_ref_kill(&devmem->ref);\n\thmm_devmem_ref_exit(&devmem->ref);\n\thmm_devmem_pages_remove(devmem);\n\n\tif (!cdm)\n\t\tdevm_release_mem_region(device, start, size);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/memremap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/init.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nvoid hmm_devmem_remove(struct hmm_devmem *devmem)\n{\n\tresource_size_t start, size;\n\tstruct device *device;\n\tbool cdm = false;\n\n\tif (!devmem)\n\t\treturn;\n\n\tdevice = devmem->device;\n\tstart = devmem->resource->start;\n\tsize = resource_size(devmem->resource);\n\n\tcdm = devmem->resource->desc == IORES_DESC_DEVICE_PUBLIC_MEMORY;\n\thmm_devmem_ref_kill(&devmem->ref);\n\thmm_devmem_ref_exit(&devmem->ref);\n\thmm_devmem_pages_remove(devmem);\n\n\tif (!cdm)\n\t\tdevm_release_mem_region(device, start, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "devm_add_action",
          "args": [
            "device",
            "hmm_devmem_ref_kill",
            "&devmem->ref"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devres_add",
          "args": [
            "device",
            "devmem"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hmm_devmem_pages_create",
          "args": [
            "devmem"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "hmm_devmem_pages_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
          "lines": "1070-1175",
          "snippet": "static int hmm_devmem_pages_create(struct hmm_devmem *devmem)\n{\n\tresource_size_t key, align_start, align_size, align_end;\n\tstruct device *device = devmem->device;\n\tint ret, nid, is_ram;\n\n\talign_start = devmem->resource->start & ~(PA_SECTION_SIZE - 1);\n\talign_size = ALIGN(devmem->resource->start +\n\t\t\t   resource_size(devmem->resource),\n\t\t\t   PA_SECTION_SIZE) - align_start;\n\n\tis_ram = region_intersects(align_start, align_size,\n\t\t\t\t   IORESOURCE_SYSTEM_RAM,\n\t\t\t\t   IORES_DESC_NONE);\n\tif (is_ram == REGION_MIXED) {\n\t\tWARN_ONCE(1, \"%s attempted on mixed region %pr\\n\",\n\t\t\t\t__func__, devmem->resource);\n\t\treturn -ENXIO;\n\t}\n\tif (is_ram == REGION_INTERSECTS)\n\t\treturn -ENXIO;\n\n\tif (devmem->resource->desc == IORES_DESC_DEVICE_PUBLIC_MEMORY)\n\t\tdevmem->pagemap.type = MEMORY_DEVICE_PUBLIC;\n\telse\n\t\tdevmem->pagemap.type = MEMORY_DEVICE_PRIVATE;\n\n\tdevmem->pagemap.res = *devmem->resource;\n\tdevmem->pagemap.page_fault = hmm_devmem_fault;\n\tdevmem->pagemap.page_free = hmm_devmem_free;\n\tdevmem->pagemap.dev = devmem->device;\n\tdevmem->pagemap.ref = &devmem->ref;\n\tdevmem->pagemap.data = devmem;\n\n\tmutex_lock(&hmm_devmem_lock);\n\talign_end = align_start + align_size - 1;\n\tfor (key = align_start; key <= align_end; key += PA_SECTION_SIZE) {\n\t\tstruct hmm_devmem *dup;\n\n\t\tdup = radix_tree_lookup(&hmm_devmem_radix,\n\t\t\t\t\tkey >> PA_SECTION_SHIFT);\n\t\tif (dup) {\n\t\t\tdev_err(device, \"%s: collides with mapping for %s\\n\",\n\t\t\t\t__func__, dev_name(dup->device));\n\t\t\tmutex_unlock(&hmm_devmem_lock);\n\t\t\tret = -EBUSY;\n\t\t\tgoto error;\n\t\t}\n\t\tret = radix_tree_insert(&hmm_devmem_radix,\n\t\t\t\t\tkey >> PA_SECTION_SHIFT,\n\t\t\t\t\tdevmem);\n\t\tif (ret) {\n\t\t\tdev_err(device, \"%s: failed: %d\\n\", __func__, ret);\n\t\t\tmutex_unlock(&hmm_devmem_lock);\n\t\t\tgoto error_radix;\n\t\t}\n\t}\n\tmutex_unlock(&hmm_devmem_lock);\n\n\tnid = dev_to_node(device);\n\tif (nid < 0)\n\t\tnid = numa_mem_id();\n\n\tmem_hotplug_begin();\n\t/*\n\t * For device private memory we call add_pages() as we only need to\n\t * allocate and initialize struct page for the device memory. More-\n\t * over the device memory is un-accessible thus we do not want to\n\t * create a linear mapping for the memory like arch_add_memory()\n\t * would do.\n\t *\n\t * For device public memory, which is accesible by the CPU, we do\n\t * want the linear mapping and thus use arch_add_memory().\n\t */\n\tif (devmem->pagemap.type == MEMORY_DEVICE_PUBLIC)\n\t\tret = arch_add_memory(nid, align_start, align_size, NULL,\n\t\t\t\tfalse);\n\telse\n\t\tret = add_pages(nid, align_start >> PAGE_SHIFT,\n\t\t\t\talign_size >> PAGE_SHIFT, NULL, false);\n\tif (ret) {\n\t\tmem_hotplug_done();\n\t\tgoto error_add_memory;\n\t}\n\tmove_pfn_range_to_zone(&NODE_DATA(nid)->node_zones[ZONE_DEVICE],\n\t\t\t\talign_start >> PAGE_SHIFT,\n\t\t\t\talign_size >> PAGE_SHIFT, NULL);\n\tmem_hotplug_done();\n\n\t/*\n\t * Initialization of the pages has been deferred until now in order\n\t * to allow us to do the work while not holding the hotplug lock.\n\t */\n\tmemmap_init_zone_device(&NODE_DATA(nid)->node_zones[ZONE_DEVICE],\n\t\t\t\talign_start >> PAGE_SHIFT,\n\t\t\t\talign_size >> PAGE_SHIFT, &devmem->pagemap);\n\n\treturn 0;\n\nerror_add_memory:\n\tuntrack_pfn(NULL, PHYS_PFN(align_start), align_size);\nerror_radix:\n\thmm_devmem_radix_release(devmem->resource);\nerror:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/memremap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/init.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define PA_SECTION_SIZE (1UL << PA_SECTION_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\n#define PA_SECTION_SIZE (1UL << PA_SECTION_SHIFT)\n\nstatic int hmm_devmem_pages_create(struct hmm_devmem *devmem)\n{\n\tresource_size_t key, align_start, align_size, align_end;\n\tstruct device *device = devmem->device;\n\tint ret, nid, is_ram;\n\n\talign_start = devmem->resource->start & ~(PA_SECTION_SIZE - 1);\n\talign_size = ALIGN(devmem->resource->start +\n\t\t\t   resource_size(devmem->resource),\n\t\t\t   PA_SECTION_SIZE) - align_start;\n\n\tis_ram = region_intersects(align_start, align_size,\n\t\t\t\t   IORESOURCE_SYSTEM_RAM,\n\t\t\t\t   IORES_DESC_NONE);\n\tif (is_ram == REGION_MIXED) {\n\t\tWARN_ONCE(1, \"%s attempted on mixed region %pr\\n\",\n\t\t\t\t__func__, devmem->resource);\n\t\treturn -ENXIO;\n\t}\n\tif (is_ram == REGION_INTERSECTS)\n\t\treturn -ENXIO;\n\n\tif (devmem->resource->desc == IORES_DESC_DEVICE_PUBLIC_MEMORY)\n\t\tdevmem->pagemap.type = MEMORY_DEVICE_PUBLIC;\n\telse\n\t\tdevmem->pagemap.type = MEMORY_DEVICE_PRIVATE;\n\n\tdevmem->pagemap.res = *devmem->resource;\n\tdevmem->pagemap.page_fault = hmm_devmem_fault;\n\tdevmem->pagemap.page_free = hmm_devmem_free;\n\tdevmem->pagemap.dev = devmem->device;\n\tdevmem->pagemap.ref = &devmem->ref;\n\tdevmem->pagemap.data = devmem;\n\n\tmutex_lock(&hmm_devmem_lock);\n\talign_end = align_start + align_size - 1;\n\tfor (key = align_start; key <= align_end; key += PA_SECTION_SIZE) {\n\t\tstruct hmm_devmem *dup;\n\n\t\tdup = radix_tree_lookup(&hmm_devmem_radix,\n\t\t\t\t\tkey >> PA_SECTION_SHIFT);\n\t\tif (dup) {\n\t\t\tdev_err(device, \"%s: collides with mapping for %s\\n\",\n\t\t\t\t__func__, dev_name(dup->device));\n\t\t\tmutex_unlock(&hmm_devmem_lock);\n\t\t\tret = -EBUSY;\n\t\t\tgoto error;\n\t\t}\n\t\tret = radix_tree_insert(&hmm_devmem_radix,\n\t\t\t\t\tkey >> PA_SECTION_SHIFT,\n\t\t\t\t\tdevmem);\n\t\tif (ret) {\n\t\t\tdev_err(device, \"%s: failed: %d\\n\", __func__, ret);\n\t\t\tmutex_unlock(&hmm_devmem_lock);\n\t\t\tgoto error_radix;\n\t\t}\n\t}\n\tmutex_unlock(&hmm_devmem_lock);\n\n\tnid = dev_to_node(device);\n\tif (nid < 0)\n\t\tnid = numa_mem_id();\n\n\tmem_hotplug_begin();\n\t/*\n\t * For device private memory we call add_pages() as we only need to\n\t * allocate and initialize struct page for the device memory. More-\n\t * over the device memory is un-accessible thus we do not want to\n\t * create a linear mapping for the memory like arch_add_memory()\n\t * would do.\n\t *\n\t * For device public memory, which is accesible by the CPU, we do\n\t * want the linear mapping and thus use arch_add_memory().\n\t */\n\tif (devmem->pagemap.type == MEMORY_DEVICE_PUBLIC)\n\t\tret = arch_add_memory(nid, align_start, align_size, NULL,\n\t\t\t\tfalse);\n\telse\n\t\tret = add_pages(nid, align_start >> PAGE_SHIFT,\n\t\t\t\talign_size >> PAGE_SHIFT, NULL, false);\n\tif (ret) {\n\t\tmem_hotplug_done();\n\t\tgoto error_add_memory;\n\t}\n\tmove_pfn_range_to_zone(&NODE_DATA(nid)->node_zones[ZONE_DEVICE],\n\t\t\t\talign_start >> PAGE_SHIFT,\n\t\t\t\talign_size >> PAGE_SHIFT, NULL);\n\tmem_hotplug_done();\n\n\t/*\n\t * Initialization of the pages has been deferred until now in order\n\t * to allow us to do the work while not holding the hotplug lock.\n\t */\n\tmemmap_init_zone_device(&NODE_DATA(nid)->node_zones[ZONE_DEVICE],\n\t\t\t\talign_start >> PAGE_SHIFT,\n\t\t\t\talign_size >> PAGE_SHIFT, &devmem->pagemap);\n\n\treturn 0;\n\nerror_add_memory:\n\tuntrack_pfn(NULL, PHYS_PFN(align_start), align_size);\nerror_radix:\n\thmm_devmem_radix_release(devmem->resource);\nerror:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "resource_size",
          "args": [
            "devmem->resource"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devm_add_action",
          "args": [
            "device",
            "hmm_devmem_ref_exit",
            "&devmem->ref"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_init",
          "args": [
            "&devmem->ref",
            "&hmm_devmem_ref_release",
            "0",
            "GFP_KERNEL"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&devmem->completion"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devres_alloc_node",
          "args": [
            "&hmm_devmem_release",
            "sizeof(*devmem)",
            "GFP_KERNEL",
            "dev_to_node(device)"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_to_node",
          "args": [
            "device"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_pagemap_get_ops",
          "args": [],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstruct hmm_devmem *hmm_devmem_add_resource(const struct hmm_devmem_ops *ops,\n\t\t\t\t\t   struct device *device,\n\t\t\t\t\t   struct resource *res)\n{\n\tstruct hmm_devmem *devmem;\n\tint ret;\n\n\tif (res->desc != IORES_DESC_DEVICE_PUBLIC_MEMORY)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdev_pagemap_get_ops();\n\n\tdevmem = devres_alloc_node(&hmm_devmem_release, sizeof(*devmem),\n\t\t\t\t   GFP_KERNEL, dev_to_node(device));\n\tif (!devmem)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit_completion(&devmem->completion);\n\tdevmem->pfn_first = -1UL;\n\tdevmem->pfn_last = -1UL;\n\tdevmem->resource = res;\n\tdevmem->device = device;\n\tdevmem->ops = ops;\n\n\tret = percpu_ref_init(&devmem->ref, &hmm_devmem_ref_release,\n\t\t\t      0, GFP_KERNEL);\n\tif (ret)\n\t\tgoto error_percpu_ref;\n\n\tret = devm_add_action(device, hmm_devmem_ref_exit, &devmem->ref);\n\tif (ret)\n\t\tgoto error_devm_add_action;\n\n\n\tdevmem->pfn_first = devmem->resource->start >> PAGE_SHIFT;\n\tdevmem->pfn_last = devmem->pfn_first +\n\t\t\t   (resource_size(devmem->resource) >> PAGE_SHIFT);\n\n\tret = hmm_devmem_pages_create(devmem);\n\tif (ret)\n\t\tgoto error_devm_add_action;\n\n\tdevres_add(device, devmem);\n\n\tret = devm_add_action(device, hmm_devmem_ref_kill, &devmem->ref);\n\tif (ret) {\n\t\thmm_devmem_remove(devmem);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn devmem;\n\nerror_devm_add_action:\n\thmm_devmem_ref_kill(&devmem->ref);\n\thmm_devmem_ref_exit(&devmem->ref);\nerror_percpu_ref:\n\tdevres_free(devmem);\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "hmm_devmem_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "1207-1296",
    "snippet": "struct hmm_devmem *hmm_devmem_add(const struct hmm_devmem_ops *ops,\n\t\t\t\t  struct device *device,\n\t\t\t\t  unsigned long size)\n{\n\tstruct hmm_devmem *devmem;\n\tresource_size_t addr;\n\tint ret;\n\n\tdev_pagemap_get_ops();\n\n\tdevmem = devres_alloc_node(&hmm_devmem_release, sizeof(*devmem),\n\t\t\t\t   GFP_KERNEL, dev_to_node(device));\n\tif (!devmem)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit_completion(&devmem->completion);\n\tdevmem->pfn_first = -1UL;\n\tdevmem->pfn_last = -1UL;\n\tdevmem->resource = NULL;\n\tdevmem->device = device;\n\tdevmem->ops = ops;\n\n\tret = percpu_ref_init(&devmem->ref, &hmm_devmem_ref_release,\n\t\t\t      0, GFP_KERNEL);\n\tif (ret)\n\t\tgoto error_percpu_ref;\n\n\tret = devm_add_action(device, hmm_devmem_ref_exit, &devmem->ref);\n\tif (ret)\n\t\tgoto error_devm_add_action;\n\n\tsize = ALIGN(size, PA_SECTION_SIZE);\n\taddr = min((unsigned long)iomem_resource.end,\n\t\t   (1UL << MAX_PHYSMEM_BITS) - 1);\n\taddr = addr - size + 1UL;\n\n\t/*\n\t * FIXME add a new helper to quickly walk resource tree and find free\n\t * range\n\t *\n\t * FIXME what about ioport_resource resource ?\n\t */\n\tfor (; addr > size && addr >= iomem_resource.start; addr -= size) {\n\t\tret = region_intersects(addr, size, 0, IORES_DESC_NONE);\n\t\tif (ret != REGION_DISJOINT)\n\t\t\tcontinue;\n\n\t\tdevmem->resource = devm_request_mem_region(device, addr, size,\n\t\t\t\t\t\t\t   dev_name(device));\n\t\tif (!devmem->resource) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error_no_resource;\n\t\t}\n\t\tbreak;\n\t}\n\tif (!devmem->resource) {\n\t\tret = -ERANGE;\n\t\tgoto error_no_resource;\n\t}\n\n\tdevmem->resource->desc = IORES_DESC_DEVICE_PRIVATE_MEMORY;\n\tdevmem->pfn_first = devmem->resource->start >> PAGE_SHIFT;\n\tdevmem->pfn_last = devmem->pfn_first +\n\t\t\t   (resource_size(devmem->resource) >> PAGE_SHIFT);\n\n\tret = hmm_devmem_pages_create(devmem);\n\tif (ret)\n\t\tgoto error_pages;\n\n\tdevres_add(device, devmem);\n\n\tret = devm_add_action(device, hmm_devmem_ref_kill, &devmem->ref);\n\tif (ret) {\n\t\thmm_devmem_remove(devmem);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn devmem;\n\nerror_pages:\n\tdevm_release_mem_region(device, devmem->resource->start,\n\t\t\t\tresource_size(devmem->resource));\nerror_no_resource:\nerror_devm_add_action:\n\thmm_devmem_ref_kill(&devmem->ref);\n\thmm_devmem_ref_exit(&devmem->ref);\nerror_percpu_ref:\n\tdevres_free(devmem);\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define PA_SECTION_SIZE (1UL << PA_SECTION_SHIFT)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devres_free",
          "args": [
            "devmem"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hmm_devmem_ref_exit",
          "args": [
            "&devmem->ref"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "hmm_devmem_ref_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
          "lines": "983-991",
          "snippet": "static void hmm_devmem_ref_exit(void *data)\n{\n\tstruct percpu_ref *ref = data;\n\tstruct hmm_devmem *devmem;\n\n\tdevmem = container_of(ref, struct hmm_devmem, ref);\n\tpercpu_ref_exit(ref);\n\tdevm_remove_action(devmem->device, &hmm_devmem_ref_exit, data);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/memremap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/init.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic void hmm_devmem_ref_exit(void *data)\n{\n\tstruct percpu_ref *ref = data;\n\tstruct hmm_devmem *devmem;\n\n\tdevmem = container_of(ref, struct hmm_devmem, ref);\n\tpercpu_ref_exit(ref);\n\tdevm_remove_action(devmem->device, &hmm_devmem_ref_exit, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hmm_devmem_ref_kill",
          "args": [
            "&devmem->ref"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "hmm_devmem_ref_kill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
          "lines": "993-1002",
          "snippet": "static void hmm_devmem_ref_kill(void *data)\n{\n\tstruct percpu_ref *ref = data;\n\tstruct hmm_devmem *devmem;\n\n\tdevmem = container_of(ref, struct hmm_devmem, ref);\n\tpercpu_ref_kill(ref);\n\twait_for_completion(&devmem->completion);\n\tdevm_remove_action(devmem->device, &hmm_devmem_ref_kill, data);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/memremap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/init.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic void hmm_devmem_ref_kill(void *data)\n{\n\tstruct percpu_ref *ref = data;\n\tstruct hmm_devmem *devmem;\n\n\tdevmem = container_of(ref, struct hmm_devmem, ref);\n\tpercpu_ref_kill(ref);\n\twait_for_completion(&devmem->completion);\n\tdevm_remove_action(devmem->device, &hmm_devmem_ref_kill, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "devm_release_mem_region",
          "args": [
            "device",
            "devmem->resource->start",
            "resource_size(devmem->resource)"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resource_size",
          "args": [
            "devmem->resource"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hmm_devmem_remove",
          "args": [
            "devmem"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "hmm_devmem_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
          "lines": "1369-1389",
          "snippet": "void hmm_devmem_remove(struct hmm_devmem *devmem)\n{\n\tresource_size_t start, size;\n\tstruct device *device;\n\tbool cdm = false;\n\n\tif (!devmem)\n\t\treturn;\n\n\tdevice = devmem->device;\n\tstart = devmem->resource->start;\n\tsize = resource_size(devmem->resource);\n\n\tcdm = devmem->resource->desc == IORES_DESC_DEVICE_PUBLIC_MEMORY;\n\thmm_devmem_ref_kill(&devmem->ref);\n\thmm_devmem_ref_exit(&devmem->ref);\n\thmm_devmem_pages_remove(devmem);\n\n\tif (!cdm)\n\t\tdevm_release_mem_region(device, start, size);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/memremap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/init.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nvoid hmm_devmem_remove(struct hmm_devmem *devmem)\n{\n\tresource_size_t start, size;\n\tstruct device *device;\n\tbool cdm = false;\n\n\tif (!devmem)\n\t\treturn;\n\n\tdevice = devmem->device;\n\tstart = devmem->resource->start;\n\tsize = resource_size(devmem->resource);\n\n\tcdm = devmem->resource->desc == IORES_DESC_DEVICE_PUBLIC_MEMORY;\n\thmm_devmem_ref_kill(&devmem->ref);\n\thmm_devmem_ref_exit(&devmem->ref);\n\thmm_devmem_pages_remove(devmem);\n\n\tif (!cdm)\n\t\tdevm_release_mem_region(device, start, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "devm_add_action",
          "args": [
            "device",
            "hmm_devmem_ref_kill",
            "&devmem->ref"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devres_add",
          "args": [
            "device",
            "devmem"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hmm_devmem_pages_create",
          "args": [
            "devmem"
          ],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "hmm_devmem_pages_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
          "lines": "1070-1175",
          "snippet": "static int hmm_devmem_pages_create(struct hmm_devmem *devmem)\n{\n\tresource_size_t key, align_start, align_size, align_end;\n\tstruct device *device = devmem->device;\n\tint ret, nid, is_ram;\n\n\talign_start = devmem->resource->start & ~(PA_SECTION_SIZE - 1);\n\talign_size = ALIGN(devmem->resource->start +\n\t\t\t   resource_size(devmem->resource),\n\t\t\t   PA_SECTION_SIZE) - align_start;\n\n\tis_ram = region_intersects(align_start, align_size,\n\t\t\t\t   IORESOURCE_SYSTEM_RAM,\n\t\t\t\t   IORES_DESC_NONE);\n\tif (is_ram == REGION_MIXED) {\n\t\tWARN_ONCE(1, \"%s attempted on mixed region %pr\\n\",\n\t\t\t\t__func__, devmem->resource);\n\t\treturn -ENXIO;\n\t}\n\tif (is_ram == REGION_INTERSECTS)\n\t\treturn -ENXIO;\n\n\tif (devmem->resource->desc == IORES_DESC_DEVICE_PUBLIC_MEMORY)\n\t\tdevmem->pagemap.type = MEMORY_DEVICE_PUBLIC;\n\telse\n\t\tdevmem->pagemap.type = MEMORY_DEVICE_PRIVATE;\n\n\tdevmem->pagemap.res = *devmem->resource;\n\tdevmem->pagemap.page_fault = hmm_devmem_fault;\n\tdevmem->pagemap.page_free = hmm_devmem_free;\n\tdevmem->pagemap.dev = devmem->device;\n\tdevmem->pagemap.ref = &devmem->ref;\n\tdevmem->pagemap.data = devmem;\n\n\tmutex_lock(&hmm_devmem_lock);\n\talign_end = align_start + align_size - 1;\n\tfor (key = align_start; key <= align_end; key += PA_SECTION_SIZE) {\n\t\tstruct hmm_devmem *dup;\n\n\t\tdup = radix_tree_lookup(&hmm_devmem_radix,\n\t\t\t\t\tkey >> PA_SECTION_SHIFT);\n\t\tif (dup) {\n\t\t\tdev_err(device, \"%s: collides with mapping for %s\\n\",\n\t\t\t\t__func__, dev_name(dup->device));\n\t\t\tmutex_unlock(&hmm_devmem_lock);\n\t\t\tret = -EBUSY;\n\t\t\tgoto error;\n\t\t}\n\t\tret = radix_tree_insert(&hmm_devmem_radix,\n\t\t\t\t\tkey >> PA_SECTION_SHIFT,\n\t\t\t\t\tdevmem);\n\t\tif (ret) {\n\t\t\tdev_err(device, \"%s: failed: %d\\n\", __func__, ret);\n\t\t\tmutex_unlock(&hmm_devmem_lock);\n\t\t\tgoto error_radix;\n\t\t}\n\t}\n\tmutex_unlock(&hmm_devmem_lock);\n\n\tnid = dev_to_node(device);\n\tif (nid < 0)\n\t\tnid = numa_mem_id();\n\n\tmem_hotplug_begin();\n\t/*\n\t * For device private memory we call add_pages() as we only need to\n\t * allocate and initialize struct page for the device memory. More-\n\t * over the device memory is un-accessible thus we do not want to\n\t * create a linear mapping for the memory like arch_add_memory()\n\t * would do.\n\t *\n\t * For device public memory, which is accesible by the CPU, we do\n\t * want the linear mapping and thus use arch_add_memory().\n\t */\n\tif (devmem->pagemap.type == MEMORY_DEVICE_PUBLIC)\n\t\tret = arch_add_memory(nid, align_start, align_size, NULL,\n\t\t\t\tfalse);\n\telse\n\t\tret = add_pages(nid, align_start >> PAGE_SHIFT,\n\t\t\t\talign_size >> PAGE_SHIFT, NULL, false);\n\tif (ret) {\n\t\tmem_hotplug_done();\n\t\tgoto error_add_memory;\n\t}\n\tmove_pfn_range_to_zone(&NODE_DATA(nid)->node_zones[ZONE_DEVICE],\n\t\t\t\talign_start >> PAGE_SHIFT,\n\t\t\t\talign_size >> PAGE_SHIFT, NULL);\n\tmem_hotplug_done();\n\n\t/*\n\t * Initialization of the pages has been deferred until now in order\n\t * to allow us to do the work while not holding the hotplug lock.\n\t */\n\tmemmap_init_zone_device(&NODE_DATA(nid)->node_zones[ZONE_DEVICE],\n\t\t\t\talign_start >> PAGE_SHIFT,\n\t\t\t\talign_size >> PAGE_SHIFT, &devmem->pagemap);\n\n\treturn 0;\n\nerror_add_memory:\n\tuntrack_pfn(NULL, PHYS_PFN(align_start), align_size);\nerror_radix:\n\thmm_devmem_radix_release(devmem->resource);\nerror:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/memremap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/init.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define PA_SECTION_SIZE (1UL << PA_SECTION_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\n#define PA_SECTION_SIZE (1UL << PA_SECTION_SHIFT)\n\nstatic int hmm_devmem_pages_create(struct hmm_devmem *devmem)\n{\n\tresource_size_t key, align_start, align_size, align_end;\n\tstruct device *device = devmem->device;\n\tint ret, nid, is_ram;\n\n\talign_start = devmem->resource->start & ~(PA_SECTION_SIZE - 1);\n\talign_size = ALIGN(devmem->resource->start +\n\t\t\t   resource_size(devmem->resource),\n\t\t\t   PA_SECTION_SIZE) - align_start;\n\n\tis_ram = region_intersects(align_start, align_size,\n\t\t\t\t   IORESOURCE_SYSTEM_RAM,\n\t\t\t\t   IORES_DESC_NONE);\n\tif (is_ram == REGION_MIXED) {\n\t\tWARN_ONCE(1, \"%s attempted on mixed region %pr\\n\",\n\t\t\t\t__func__, devmem->resource);\n\t\treturn -ENXIO;\n\t}\n\tif (is_ram == REGION_INTERSECTS)\n\t\treturn -ENXIO;\n\n\tif (devmem->resource->desc == IORES_DESC_DEVICE_PUBLIC_MEMORY)\n\t\tdevmem->pagemap.type = MEMORY_DEVICE_PUBLIC;\n\telse\n\t\tdevmem->pagemap.type = MEMORY_DEVICE_PRIVATE;\n\n\tdevmem->pagemap.res = *devmem->resource;\n\tdevmem->pagemap.page_fault = hmm_devmem_fault;\n\tdevmem->pagemap.page_free = hmm_devmem_free;\n\tdevmem->pagemap.dev = devmem->device;\n\tdevmem->pagemap.ref = &devmem->ref;\n\tdevmem->pagemap.data = devmem;\n\n\tmutex_lock(&hmm_devmem_lock);\n\talign_end = align_start + align_size - 1;\n\tfor (key = align_start; key <= align_end; key += PA_SECTION_SIZE) {\n\t\tstruct hmm_devmem *dup;\n\n\t\tdup = radix_tree_lookup(&hmm_devmem_radix,\n\t\t\t\t\tkey >> PA_SECTION_SHIFT);\n\t\tif (dup) {\n\t\t\tdev_err(device, \"%s: collides with mapping for %s\\n\",\n\t\t\t\t__func__, dev_name(dup->device));\n\t\t\tmutex_unlock(&hmm_devmem_lock);\n\t\t\tret = -EBUSY;\n\t\t\tgoto error;\n\t\t}\n\t\tret = radix_tree_insert(&hmm_devmem_radix,\n\t\t\t\t\tkey >> PA_SECTION_SHIFT,\n\t\t\t\t\tdevmem);\n\t\tif (ret) {\n\t\t\tdev_err(device, \"%s: failed: %d\\n\", __func__, ret);\n\t\t\tmutex_unlock(&hmm_devmem_lock);\n\t\t\tgoto error_radix;\n\t\t}\n\t}\n\tmutex_unlock(&hmm_devmem_lock);\n\n\tnid = dev_to_node(device);\n\tif (nid < 0)\n\t\tnid = numa_mem_id();\n\n\tmem_hotplug_begin();\n\t/*\n\t * For device private memory we call add_pages() as we only need to\n\t * allocate and initialize struct page for the device memory. More-\n\t * over the device memory is un-accessible thus we do not want to\n\t * create a linear mapping for the memory like arch_add_memory()\n\t * would do.\n\t *\n\t * For device public memory, which is accesible by the CPU, we do\n\t * want the linear mapping and thus use arch_add_memory().\n\t */\n\tif (devmem->pagemap.type == MEMORY_DEVICE_PUBLIC)\n\t\tret = arch_add_memory(nid, align_start, align_size, NULL,\n\t\t\t\tfalse);\n\telse\n\t\tret = add_pages(nid, align_start >> PAGE_SHIFT,\n\t\t\t\talign_size >> PAGE_SHIFT, NULL, false);\n\tif (ret) {\n\t\tmem_hotplug_done();\n\t\tgoto error_add_memory;\n\t}\n\tmove_pfn_range_to_zone(&NODE_DATA(nid)->node_zones[ZONE_DEVICE],\n\t\t\t\talign_start >> PAGE_SHIFT,\n\t\t\t\talign_size >> PAGE_SHIFT, NULL);\n\tmem_hotplug_done();\n\n\t/*\n\t * Initialization of the pages has been deferred until now in order\n\t * to allow us to do the work while not holding the hotplug lock.\n\t */\n\tmemmap_init_zone_device(&NODE_DATA(nid)->node_zones[ZONE_DEVICE],\n\t\t\t\talign_start >> PAGE_SHIFT,\n\t\t\t\talign_size >> PAGE_SHIFT, &devmem->pagemap);\n\n\treturn 0;\n\nerror_add_memory:\n\tuntrack_pfn(NULL, PHYS_PFN(align_start), align_size);\nerror_radix:\n\thmm_devmem_radix_release(devmem->resource);\nerror:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "resource_size",
          "args": [
            "devmem->resource"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devm_request_mem_region",
          "args": [
            "device",
            "addr",
            "size",
            "dev_name(device)"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_name",
          "args": [
            "device"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "region_intersects",
          "args": [
            "addr",
            "size",
            "0",
            "IORES_DESC_NONE"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "(unsigned long)iomem_resource.end",
            "(1UL << MAX_PHYSMEM_BITS) - 1"
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "size",
            "PA_SECTION_SIZE"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devm_add_action",
          "args": [
            "device",
            "hmm_devmem_ref_exit",
            "&devmem->ref"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_init",
          "args": [
            "&devmem->ref",
            "&hmm_devmem_ref_release",
            "0",
            "GFP_KERNEL"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&devmem->completion"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devres_alloc_node",
          "args": [
            "&hmm_devmem_release",
            "sizeof(*devmem)",
            "GFP_KERNEL",
            "dev_to_node(device)"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_to_node",
          "args": [
            "device"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_pagemap_get_ops",
          "args": [],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\n#define PA_SECTION_SIZE (1UL << PA_SECTION_SHIFT)\n\nstruct hmm_devmem *hmm_devmem_add(const struct hmm_devmem_ops *ops,\n\t\t\t\t  struct device *device,\n\t\t\t\t  unsigned long size)\n{\n\tstruct hmm_devmem *devmem;\n\tresource_size_t addr;\n\tint ret;\n\n\tdev_pagemap_get_ops();\n\n\tdevmem = devres_alloc_node(&hmm_devmem_release, sizeof(*devmem),\n\t\t\t\t   GFP_KERNEL, dev_to_node(device));\n\tif (!devmem)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit_completion(&devmem->completion);\n\tdevmem->pfn_first = -1UL;\n\tdevmem->pfn_last = -1UL;\n\tdevmem->resource = NULL;\n\tdevmem->device = device;\n\tdevmem->ops = ops;\n\n\tret = percpu_ref_init(&devmem->ref, &hmm_devmem_ref_release,\n\t\t\t      0, GFP_KERNEL);\n\tif (ret)\n\t\tgoto error_percpu_ref;\n\n\tret = devm_add_action(device, hmm_devmem_ref_exit, &devmem->ref);\n\tif (ret)\n\t\tgoto error_devm_add_action;\n\n\tsize = ALIGN(size, PA_SECTION_SIZE);\n\taddr = min((unsigned long)iomem_resource.end,\n\t\t   (1UL << MAX_PHYSMEM_BITS) - 1);\n\taddr = addr - size + 1UL;\n\n\t/*\n\t * FIXME add a new helper to quickly walk resource tree and find free\n\t * range\n\t *\n\t * FIXME what about ioport_resource resource ?\n\t */\n\tfor (; addr > size && addr >= iomem_resource.start; addr -= size) {\n\t\tret = region_intersects(addr, size, 0, IORES_DESC_NONE);\n\t\tif (ret != REGION_DISJOINT)\n\t\t\tcontinue;\n\n\t\tdevmem->resource = devm_request_mem_region(device, addr, size,\n\t\t\t\t\t\t\t   dev_name(device));\n\t\tif (!devmem->resource) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error_no_resource;\n\t\t}\n\t\tbreak;\n\t}\n\tif (!devmem->resource) {\n\t\tret = -ERANGE;\n\t\tgoto error_no_resource;\n\t}\n\n\tdevmem->resource->desc = IORES_DESC_DEVICE_PRIVATE_MEMORY;\n\tdevmem->pfn_first = devmem->resource->start >> PAGE_SHIFT;\n\tdevmem->pfn_last = devmem->pfn_first +\n\t\t\t   (resource_size(devmem->resource) >> PAGE_SHIFT);\n\n\tret = hmm_devmem_pages_create(devmem);\n\tif (ret)\n\t\tgoto error_pages;\n\n\tdevres_add(device, devmem);\n\n\tret = devm_add_action(device, hmm_devmem_ref_kill, &devmem->ref);\n\tif (ret) {\n\t\thmm_devmem_remove(devmem);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn devmem;\n\nerror_pages:\n\tdevm_release_mem_region(device, devmem->resource->start,\n\t\t\t\tresource_size(devmem->resource));\nerror_no_resource:\nerror_devm_add_action:\n\thmm_devmem_ref_kill(&devmem->ref);\n\thmm_devmem_ref_exit(&devmem->ref);\nerror_percpu_ref:\n\tdevres_free(devmem);\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "hmm_devmem_pages_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "1184-1188",
    "snippet": "static void hmm_devmem_pages_remove(struct hmm_devmem *devmem)\n{\n\tdevres_release(devmem->device, &hmm_devmem_release,\n\t\t       &hmm_devmem_match, devmem->resource);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "devres_release",
          "args": [
            "devmem->device",
            "&hmm_devmem_release",
            "&hmm_devmem_match",
            "devmem->resource"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic void hmm_devmem_pages_remove(struct hmm_devmem *devmem)\n{\n\tdevres_release(devmem->device, &hmm_devmem_release,\n\t\t       &hmm_devmem_match, devmem->resource);\n}"
  },
  {
    "function_name": "hmm_devmem_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "1177-1182",
    "snippet": "static int hmm_devmem_match(struct device *dev, void *data, void *match_data)\n{\n\tstruct hmm_devmem *devmem = data;\n\n\treturn devmem->resource == match_data;\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic int hmm_devmem_match(struct device *dev, void *data, void *match_data)\n{\n\tstruct hmm_devmem *devmem = data;\n\n\treturn devmem->resource == match_data;\n}"
  },
  {
    "function_name": "hmm_devmem_pages_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "1070-1175",
    "snippet": "static int hmm_devmem_pages_create(struct hmm_devmem *devmem)\n{\n\tresource_size_t key, align_start, align_size, align_end;\n\tstruct device *device = devmem->device;\n\tint ret, nid, is_ram;\n\n\talign_start = devmem->resource->start & ~(PA_SECTION_SIZE - 1);\n\talign_size = ALIGN(devmem->resource->start +\n\t\t\t   resource_size(devmem->resource),\n\t\t\t   PA_SECTION_SIZE) - align_start;\n\n\tis_ram = region_intersects(align_start, align_size,\n\t\t\t\t   IORESOURCE_SYSTEM_RAM,\n\t\t\t\t   IORES_DESC_NONE);\n\tif (is_ram == REGION_MIXED) {\n\t\tWARN_ONCE(1, \"%s attempted on mixed region %pr\\n\",\n\t\t\t\t__func__, devmem->resource);\n\t\treturn -ENXIO;\n\t}\n\tif (is_ram == REGION_INTERSECTS)\n\t\treturn -ENXIO;\n\n\tif (devmem->resource->desc == IORES_DESC_DEVICE_PUBLIC_MEMORY)\n\t\tdevmem->pagemap.type = MEMORY_DEVICE_PUBLIC;\n\telse\n\t\tdevmem->pagemap.type = MEMORY_DEVICE_PRIVATE;\n\n\tdevmem->pagemap.res = *devmem->resource;\n\tdevmem->pagemap.page_fault = hmm_devmem_fault;\n\tdevmem->pagemap.page_free = hmm_devmem_free;\n\tdevmem->pagemap.dev = devmem->device;\n\tdevmem->pagemap.ref = &devmem->ref;\n\tdevmem->pagemap.data = devmem;\n\n\tmutex_lock(&hmm_devmem_lock);\n\talign_end = align_start + align_size - 1;\n\tfor (key = align_start; key <= align_end; key += PA_SECTION_SIZE) {\n\t\tstruct hmm_devmem *dup;\n\n\t\tdup = radix_tree_lookup(&hmm_devmem_radix,\n\t\t\t\t\tkey >> PA_SECTION_SHIFT);\n\t\tif (dup) {\n\t\t\tdev_err(device, \"%s: collides with mapping for %s\\n\",\n\t\t\t\t__func__, dev_name(dup->device));\n\t\t\tmutex_unlock(&hmm_devmem_lock);\n\t\t\tret = -EBUSY;\n\t\t\tgoto error;\n\t\t}\n\t\tret = radix_tree_insert(&hmm_devmem_radix,\n\t\t\t\t\tkey >> PA_SECTION_SHIFT,\n\t\t\t\t\tdevmem);\n\t\tif (ret) {\n\t\t\tdev_err(device, \"%s: failed: %d\\n\", __func__, ret);\n\t\t\tmutex_unlock(&hmm_devmem_lock);\n\t\t\tgoto error_radix;\n\t\t}\n\t}\n\tmutex_unlock(&hmm_devmem_lock);\n\n\tnid = dev_to_node(device);\n\tif (nid < 0)\n\t\tnid = numa_mem_id();\n\n\tmem_hotplug_begin();\n\t/*\n\t * For device private memory we call add_pages() as we only need to\n\t * allocate and initialize struct page for the device memory. More-\n\t * over the device memory is un-accessible thus we do not want to\n\t * create a linear mapping for the memory like arch_add_memory()\n\t * would do.\n\t *\n\t * For device public memory, which is accesible by the CPU, we do\n\t * want the linear mapping and thus use arch_add_memory().\n\t */\n\tif (devmem->pagemap.type == MEMORY_DEVICE_PUBLIC)\n\t\tret = arch_add_memory(nid, align_start, align_size, NULL,\n\t\t\t\tfalse);\n\telse\n\t\tret = add_pages(nid, align_start >> PAGE_SHIFT,\n\t\t\t\talign_size >> PAGE_SHIFT, NULL, false);\n\tif (ret) {\n\t\tmem_hotplug_done();\n\t\tgoto error_add_memory;\n\t}\n\tmove_pfn_range_to_zone(&NODE_DATA(nid)->node_zones[ZONE_DEVICE],\n\t\t\t\talign_start >> PAGE_SHIFT,\n\t\t\t\talign_size >> PAGE_SHIFT, NULL);\n\tmem_hotplug_done();\n\n\t/*\n\t * Initialization of the pages has been deferred until now in order\n\t * to allow us to do the work while not holding the hotplug lock.\n\t */\n\tmemmap_init_zone_device(&NODE_DATA(nid)->node_zones[ZONE_DEVICE],\n\t\t\t\talign_start >> PAGE_SHIFT,\n\t\t\t\talign_size >> PAGE_SHIFT, &devmem->pagemap);\n\n\treturn 0;\n\nerror_add_memory:\n\tuntrack_pfn(NULL, PHYS_PFN(align_start), align_size);\nerror_radix:\n\thmm_devmem_radix_release(devmem->resource);\nerror:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define PA_SECTION_SIZE (1UL << PA_SECTION_SHIFT)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hmm_devmem_radix_release",
          "args": [
            "devmem->resource"
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "hmm_devmem_radix_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
          "lines": "1027-1037",
          "snippet": "static void hmm_devmem_radix_release(struct resource *resource)\n{\n\tresource_size_t key;\n\n\tmutex_lock(&hmm_devmem_lock);\n\tfor (key = resource->start;\n\t     key <= resource->end;\n\t     key += PA_SECTION_SIZE)\n\t\tradix_tree_delete(&hmm_devmem_radix, key >> PA_SECTION_SHIFT);\n\tmutex_unlock(&hmm_devmem_lock);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/memremap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/init.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define PA_SECTION_SIZE (1UL << PA_SECTION_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\n#define PA_SECTION_SIZE (1UL << PA_SECTION_SHIFT)\n\nstatic void hmm_devmem_radix_release(struct resource *resource)\n{\n\tresource_size_t key;\n\n\tmutex_lock(&hmm_devmem_lock);\n\tfor (key = resource->start;\n\t     key <= resource->end;\n\t     key += PA_SECTION_SIZE)\n\t\tradix_tree_delete(&hmm_devmem_radix, key >> PA_SECTION_SHIFT);\n\tmutex_unlock(&hmm_devmem_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "untrack_pfn",
          "args": [
            "NULL",
            "PHYS_PFN(align_start)",
            "align_size"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHYS_PFN",
          "args": [
            "align_start"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmap_init_zone_device",
          "args": [
            "&NODE_DATA(nid)->node_zones[ZONE_DEVICE]",
            "align_start >> PAGE_SHIFT",
            "align_size >> PAGE_SHIFT",
            "&devmem->pagemap"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "nid"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_hotplug_done",
          "args": [],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "mem_hotplug_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "92-96",
          "snippet": "void mem_hotplug_done(void)\n{\n\tpercpu_up_write(&mem_hotplug_lock);\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid mem_hotplug_done(void)\n{\n\tpercpu_up_write(&mem_hotplug_lock);\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "move_pfn_range_to_zone",
          "args": [
            "&NODE_DATA(nid)->node_zones[ZONE_DEVICE]",
            "align_start >> PAGE_SHIFT",
            "align_size >> PAGE_SHIFT",
            "NULL"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "move_pfn_range_to_zone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "739-769",
          "snippet": "void __ref move_pfn_range_to_zone(struct zone *zone, unsigned long start_pfn,\n\t\tunsigned long nr_pages, struct vmem_altmap *altmap)\n{\n\tstruct pglist_data *pgdat = zone->zone_pgdat;\n\tint nid = pgdat->node_id;\n\tunsigned long flags;\n\n\tif (zone_is_empty(zone))\n\t\tinit_currently_empty_zone(zone, start_pfn, nr_pages);\n\n\tclear_zone_contiguous(zone);\n\n\t/* TODO Huh pgdat is irqsave while zone is not. It used to be like that before */\n\tpgdat_resize_lock(pgdat, &flags);\n\tzone_span_writelock(zone);\n\tresize_zone_range(zone, start_pfn, nr_pages);\n\tzone_span_writeunlock(zone);\n\tresize_pgdat_range(pgdat, start_pfn, nr_pages);\n\tpgdat_resize_unlock(pgdat, &flags);\n\n\t/*\n\t * TODO now we have a visible range of pages which are not associated\n\t * with their zone properly. Not nice but set_pfnblock_flags_mask\n\t * expects the zone spans the pfn range. All the pages in the range\n\t * are reserved so nobody should be touching them so we should be safe\n\t */\n\tmemmap_init_zone(nr_pages, nid, zone_idx(zone), start_pfn,\n\t\t\tMEMMAP_HOTPLUG, altmap);\n\n\tset_zone_contiguous(zone);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid __ref move_pfn_range_to_zone(struct zone *zone, unsigned long start_pfn,\n\t\tunsigned long nr_pages, struct vmem_altmap *altmap)\n{\n\tstruct pglist_data *pgdat = zone->zone_pgdat;\n\tint nid = pgdat->node_id;\n\tunsigned long flags;\n\n\tif (zone_is_empty(zone))\n\t\tinit_currently_empty_zone(zone, start_pfn, nr_pages);\n\n\tclear_zone_contiguous(zone);\n\n\t/* TODO Huh pgdat is irqsave while zone is not. It used to be like that before */\n\tpgdat_resize_lock(pgdat, &flags);\n\tzone_span_writelock(zone);\n\tresize_zone_range(zone, start_pfn, nr_pages);\n\tzone_span_writeunlock(zone);\n\tresize_pgdat_range(pgdat, start_pfn, nr_pages);\n\tpgdat_resize_unlock(pgdat, &flags);\n\n\t/*\n\t * TODO now we have a visible range of pages which are not associated\n\t * with their zone properly. Not nice but set_pfnblock_flags_mask\n\t * expects the zone spans the pfn range. All the pages in the range\n\t * are reserved so nobody should be touching them so we should be safe\n\t */\n\tmemmap_init_zone(nr_pages, nid, zone_idx(zone), start_pfn,\n\t\t\tMEMMAP_HOTPLUG, altmap);\n\n\tset_zone_contiguous(zone);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "nid"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_pages",
          "args": [
            "nid",
            "align_start >> PAGE_SHIFT",
            "align_size >> PAGE_SHIFT",
            "NULL",
            "false"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "__add_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "272-314",
          "snippet": "int __ref __add_pages(int nid, unsigned long phys_start_pfn,\n\t\tunsigned long nr_pages, struct vmem_altmap *altmap,\n\t\tbool want_memblock)\n{\n\tunsigned long i;\n\tint err = 0;\n\tint start_sec, end_sec;\n\n\t/* during initialize mem_map, align hot-added range to section */\n\tstart_sec = pfn_to_section_nr(phys_start_pfn);\n\tend_sec = pfn_to_section_nr(phys_start_pfn + nr_pages - 1);\n\n\tif (altmap) {\n\t\t/*\n\t\t * Validate altmap is within bounds of the total request\n\t\t */\n\t\tif (altmap->base_pfn != phys_start_pfn\n\t\t\t\t|| vmem_altmap_offset(altmap) > nr_pages) {\n\t\t\tpr_warn_once(\"memory add fail, invalid altmap\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\taltmap->alloc = 0;\n\t}\n\n\tfor (i = start_sec; i <= end_sec; i++) {\n\t\terr = __add_section(nid, section_nr_to_pfn(i), altmap,\n\t\t\t\twant_memblock);\n\n\t\t/*\n\t\t * EEXIST is finally dealt with by ioresource collision\n\t\t * check. see add_memory() => register_memory_resource()\n\t\t * Warning will be printed if there is collision.\n\t\t */\n\t\tif (err && (err != -EEXIST))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tcond_resched();\n\t}\n\tvmemmap_populate_print_last();\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint __ref __add_pages(int nid, unsigned long phys_start_pfn,\n\t\tunsigned long nr_pages, struct vmem_altmap *altmap,\n\t\tbool want_memblock)\n{\n\tunsigned long i;\n\tint err = 0;\n\tint start_sec, end_sec;\n\n\t/* during initialize mem_map, align hot-added range to section */\n\tstart_sec = pfn_to_section_nr(phys_start_pfn);\n\tend_sec = pfn_to_section_nr(phys_start_pfn + nr_pages - 1);\n\n\tif (altmap) {\n\t\t/*\n\t\t * Validate altmap is within bounds of the total request\n\t\t */\n\t\tif (altmap->base_pfn != phys_start_pfn\n\t\t\t\t|| vmem_altmap_offset(altmap) > nr_pages) {\n\t\t\tpr_warn_once(\"memory add fail, invalid altmap\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\taltmap->alloc = 0;\n\t}\n\n\tfor (i = start_sec; i <= end_sec; i++) {\n\t\terr = __add_section(nid, section_nr_to_pfn(i), altmap,\n\t\t\t\twant_memblock);\n\n\t\t/*\n\t\t * EEXIST is finally dealt with by ioresource collision\n\t\t * check. see add_memory() => register_memory_resource()\n\t\t * Warning will be printed if there is collision.\n\t\t */\n\t\tif (err && (err != -EEXIST))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tcond_resched();\n\t}\n\tvmemmap_populate_print_last();\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_add_memory",
          "args": [
            "nid",
            "align_start",
            "align_size",
            "NULL",
            "false"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_hotplug_begin",
          "args": [],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "mem_hotplug_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "86-90",
          "snippet": "void mem_hotplug_begin(void)\n{\n\tcpus_read_lock();\n\tpercpu_down_write(&mem_hotplug_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid mem_hotplug_begin(void)\n{\n\tcpus_read_lock();\n\tpercpu_down_write(&mem_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "numa_mem_id",
          "args": [],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_to_node",
          "args": [
            "device"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&hmm_devmem_lock"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&hmm_devmem_lock"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_err",
          "args": [
            "device",
            "\"%s: failed: %d\\n\"",
            "__func__",
            "ret"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_insert",
          "args": [
            "&hmm_devmem_radix",
            "key >> PA_SECTION_SHIFT",
            "devmem"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&hmm_devmem_lock"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_err",
          "args": [
            "device",
            "\"%s: collides with mapping for %s\\n\"",
            "__func__",
            "dev_name(dup->device)"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_name",
          "args": [
            "dup->device"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_lookup",
          "args": [
            "&hmm_devmem_radix",
            "key >> PA_SECTION_SHIFT"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&hmm_devmem_lock"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"%s attempted on mixed region %pr\\n\"",
            "__func__",
            "devmem->resource"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "region_intersects",
          "args": [
            "align_start",
            "align_size",
            "IORESOURCE_SYSTEM_RAM",
            "IORES_DESC_NONE"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "devmem->resource->start +\n\t\t\t   resource_size(devmem->resource)",
            "PA_SECTION_SIZE"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resource_size",
          "args": [
            "devmem->resource"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\n#define PA_SECTION_SIZE (1UL << PA_SECTION_SHIFT)\n\nstatic int hmm_devmem_pages_create(struct hmm_devmem *devmem)\n{\n\tresource_size_t key, align_start, align_size, align_end;\n\tstruct device *device = devmem->device;\n\tint ret, nid, is_ram;\n\n\talign_start = devmem->resource->start & ~(PA_SECTION_SIZE - 1);\n\talign_size = ALIGN(devmem->resource->start +\n\t\t\t   resource_size(devmem->resource),\n\t\t\t   PA_SECTION_SIZE) - align_start;\n\n\tis_ram = region_intersects(align_start, align_size,\n\t\t\t\t   IORESOURCE_SYSTEM_RAM,\n\t\t\t\t   IORES_DESC_NONE);\n\tif (is_ram == REGION_MIXED) {\n\t\tWARN_ONCE(1, \"%s attempted on mixed region %pr\\n\",\n\t\t\t\t__func__, devmem->resource);\n\t\treturn -ENXIO;\n\t}\n\tif (is_ram == REGION_INTERSECTS)\n\t\treturn -ENXIO;\n\n\tif (devmem->resource->desc == IORES_DESC_DEVICE_PUBLIC_MEMORY)\n\t\tdevmem->pagemap.type = MEMORY_DEVICE_PUBLIC;\n\telse\n\t\tdevmem->pagemap.type = MEMORY_DEVICE_PRIVATE;\n\n\tdevmem->pagemap.res = *devmem->resource;\n\tdevmem->pagemap.page_fault = hmm_devmem_fault;\n\tdevmem->pagemap.page_free = hmm_devmem_free;\n\tdevmem->pagemap.dev = devmem->device;\n\tdevmem->pagemap.ref = &devmem->ref;\n\tdevmem->pagemap.data = devmem;\n\n\tmutex_lock(&hmm_devmem_lock);\n\talign_end = align_start + align_size - 1;\n\tfor (key = align_start; key <= align_end; key += PA_SECTION_SIZE) {\n\t\tstruct hmm_devmem *dup;\n\n\t\tdup = radix_tree_lookup(&hmm_devmem_radix,\n\t\t\t\t\tkey >> PA_SECTION_SHIFT);\n\t\tif (dup) {\n\t\t\tdev_err(device, \"%s: collides with mapping for %s\\n\",\n\t\t\t\t__func__, dev_name(dup->device));\n\t\t\tmutex_unlock(&hmm_devmem_lock);\n\t\t\tret = -EBUSY;\n\t\t\tgoto error;\n\t\t}\n\t\tret = radix_tree_insert(&hmm_devmem_radix,\n\t\t\t\t\tkey >> PA_SECTION_SHIFT,\n\t\t\t\t\tdevmem);\n\t\tif (ret) {\n\t\t\tdev_err(device, \"%s: failed: %d\\n\", __func__, ret);\n\t\t\tmutex_unlock(&hmm_devmem_lock);\n\t\t\tgoto error_radix;\n\t\t}\n\t}\n\tmutex_unlock(&hmm_devmem_lock);\n\n\tnid = dev_to_node(device);\n\tif (nid < 0)\n\t\tnid = numa_mem_id();\n\n\tmem_hotplug_begin();\n\t/*\n\t * For device private memory we call add_pages() as we only need to\n\t * allocate and initialize struct page for the device memory. More-\n\t * over the device memory is un-accessible thus we do not want to\n\t * create a linear mapping for the memory like arch_add_memory()\n\t * would do.\n\t *\n\t * For device public memory, which is accesible by the CPU, we do\n\t * want the linear mapping and thus use arch_add_memory().\n\t */\n\tif (devmem->pagemap.type == MEMORY_DEVICE_PUBLIC)\n\t\tret = arch_add_memory(nid, align_start, align_size, NULL,\n\t\t\t\tfalse);\n\telse\n\t\tret = add_pages(nid, align_start >> PAGE_SHIFT,\n\t\t\t\talign_size >> PAGE_SHIFT, NULL, false);\n\tif (ret) {\n\t\tmem_hotplug_done();\n\t\tgoto error_add_memory;\n\t}\n\tmove_pfn_range_to_zone(&NODE_DATA(nid)->node_zones[ZONE_DEVICE],\n\t\t\t\talign_start >> PAGE_SHIFT,\n\t\t\t\talign_size >> PAGE_SHIFT, NULL);\n\tmem_hotplug_done();\n\n\t/*\n\t * Initialization of the pages has been deferred until now in order\n\t * to allow us to do the work while not holding the hotplug lock.\n\t */\n\tmemmap_init_zone_device(&NODE_DATA(nid)->node_zones[ZONE_DEVICE],\n\t\t\t\talign_start >> PAGE_SHIFT,\n\t\t\t\talign_size >> PAGE_SHIFT, &devmem->pagemap);\n\n\treturn 0;\n\nerror_add_memory:\n\tuntrack_pfn(NULL, PHYS_PFN(align_start), align_size);\nerror_radix:\n\thmm_devmem_radix_release(devmem->resource);\nerror:\n\treturn ret;\n}"
  },
  {
    "function_name": "hmm_devmem_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "1039-1068",
    "snippet": "static void hmm_devmem_release(struct device *dev, void *data)\n{\n\tstruct hmm_devmem *devmem = data;\n\tstruct resource *resource = devmem->resource;\n\tunsigned long start_pfn, npages;\n\tstruct zone *zone;\n\tstruct page *page;\n\n\tif (percpu_ref_tryget_live(&devmem->ref)) {\n\t\tdev_WARN(dev, \"%s: page mapping is still live!\\n\", __func__);\n\t\tpercpu_ref_put(&devmem->ref);\n\t}\n\n\t/* pages are dead and unused, undo the arch mapping */\n\tstart_pfn = (resource->start & ~(PA_SECTION_SIZE - 1)) >> PAGE_SHIFT;\n\tnpages = ALIGN(resource_size(resource), PA_SECTION_SIZE) >> PAGE_SHIFT;\n\n\tpage = pfn_to_page(start_pfn);\n\tzone = page_zone(page);\n\n\tmem_hotplug_begin();\n\tif (resource->desc == IORES_DESC_DEVICE_PRIVATE_MEMORY)\n\t\t__remove_pages(zone, start_pfn, npages, NULL);\n\telse\n\t\tarch_remove_memory(start_pfn << PAGE_SHIFT,\n\t\t\t\t   npages << PAGE_SHIFT, NULL);\n\tmem_hotplug_done();\n\n\thmm_devmem_radix_release(resource);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define PA_SECTION_SIZE (1UL << PA_SECTION_SHIFT)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hmm_devmem_radix_release",
          "args": [
            "resource"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "hmm_devmem_radix_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
          "lines": "1027-1037",
          "snippet": "static void hmm_devmem_radix_release(struct resource *resource)\n{\n\tresource_size_t key;\n\n\tmutex_lock(&hmm_devmem_lock);\n\tfor (key = resource->start;\n\t     key <= resource->end;\n\t     key += PA_SECTION_SIZE)\n\t\tradix_tree_delete(&hmm_devmem_radix, key >> PA_SECTION_SHIFT);\n\tmutex_unlock(&hmm_devmem_lock);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/memremap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/init.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define PA_SECTION_SIZE (1UL << PA_SECTION_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\n#define PA_SECTION_SIZE (1UL << PA_SECTION_SHIFT)\n\nstatic void hmm_devmem_radix_release(struct resource *resource)\n{\n\tresource_size_t key;\n\n\tmutex_lock(&hmm_devmem_lock);\n\tfor (key = resource->start;\n\t     key <= resource->end;\n\t     key += PA_SECTION_SIZE)\n\t\tradix_tree_delete(&hmm_devmem_radix, key >> PA_SECTION_SHIFT);\n\tmutex_unlock(&hmm_devmem_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_hotplug_done",
          "args": [],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "mem_hotplug_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "92-96",
          "snippet": "void mem_hotplug_done(void)\n{\n\tpercpu_up_write(&mem_hotplug_lock);\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid mem_hotplug_done(void)\n{\n\tpercpu_up_write(&mem_hotplug_lock);\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_remove_memory",
          "args": [
            "start_pfn << PAGE_SHIFT",
            "npages << PAGE_SHIFT",
            "NULL"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__remove_pages",
          "args": [
            "zone",
            "start_pfn",
            "npages",
            "NULL"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "__remove_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "550-600",
          "snippet": "int __remove_pages(struct zone *zone, unsigned long phys_start_pfn,\n\t\t unsigned long nr_pages, struct vmem_altmap *altmap)\n{\n\tunsigned long i;\n\tunsigned long map_offset = 0;\n\tint sections_to_remove, ret = 0;\n\n\t/* In the ZONE_DEVICE case device driver owns the memory region */\n\tif (is_dev_zone(zone)) {\n\t\tif (altmap)\n\t\t\tmap_offset = vmem_altmap_offset(altmap);\n\t} else {\n\t\tresource_size_t start, size;\n\n\t\tstart = phys_start_pfn << PAGE_SHIFT;\n\t\tsize = nr_pages * PAGE_SIZE;\n\n\t\tret = release_mem_region_adjustable(&iomem_resource, start,\n\t\t\t\t\tsize);\n\t\tif (ret) {\n\t\t\tresource_size_t endres = start + size - 1;\n\n\t\t\tpr_warn(\"Unable to release resource <%pa-%pa> (%d)\\n\",\n\t\t\t\t\t&start, &endres, ret);\n\t\t}\n\t}\n\n\tclear_zone_contiguous(zone);\n\n\t/*\n\t * We can only remove entire sections\n\t */\n\tBUG_ON(phys_start_pfn & ~PAGE_SECTION_MASK);\n\tBUG_ON(nr_pages % PAGES_PER_SECTION);\n\n\tsections_to_remove = nr_pages / PAGES_PER_SECTION;\n\tfor (i = 0; i < sections_to_remove; i++) {\n\t\tunsigned long pfn = phys_start_pfn + i*PAGES_PER_SECTION;\n\n\t\tcond_resched();\n\t\tret = __remove_section(zone, __pfn_to_section(pfn), map_offset,\n\t\t\t\taltmap);\n\t\tmap_offset = 0;\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tset_zone_contiguous(zone);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint __remove_pages(struct zone *zone, unsigned long phys_start_pfn,\n\t\t unsigned long nr_pages, struct vmem_altmap *altmap)\n{\n\tunsigned long i;\n\tunsigned long map_offset = 0;\n\tint sections_to_remove, ret = 0;\n\n\t/* In the ZONE_DEVICE case device driver owns the memory region */\n\tif (is_dev_zone(zone)) {\n\t\tif (altmap)\n\t\t\tmap_offset = vmem_altmap_offset(altmap);\n\t} else {\n\t\tresource_size_t start, size;\n\n\t\tstart = phys_start_pfn << PAGE_SHIFT;\n\t\tsize = nr_pages * PAGE_SIZE;\n\n\t\tret = release_mem_region_adjustable(&iomem_resource, start,\n\t\t\t\t\tsize);\n\t\tif (ret) {\n\t\t\tresource_size_t endres = start + size - 1;\n\n\t\t\tpr_warn(\"Unable to release resource <%pa-%pa> (%d)\\n\",\n\t\t\t\t\t&start, &endres, ret);\n\t\t}\n\t}\n\n\tclear_zone_contiguous(zone);\n\n\t/*\n\t * We can only remove entire sections\n\t */\n\tBUG_ON(phys_start_pfn & ~PAGE_SECTION_MASK);\n\tBUG_ON(nr_pages % PAGES_PER_SECTION);\n\n\tsections_to_remove = nr_pages / PAGES_PER_SECTION;\n\tfor (i = 0; i < sections_to_remove; i++) {\n\t\tunsigned long pfn = phys_start_pfn + i*PAGES_PER_SECTION;\n\n\t\tcond_resched();\n\t\tret = __remove_section(zone, __pfn_to_section(pfn), map_offset,\n\t\t\t\taltmap);\n\t\tmap_offset = 0;\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tset_zone_contiguous(zone);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_hotplug_begin",
          "args": [],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "mem_hotplug_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "86-90",
          "snippet": "void mem_hotplug_begin(void)\n{\n\tcpus_read_lock();\n\tpercpu_down_write(&mem_hotplug_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid mem_hotplug_begin(void)\n{\n\tcpus_read_lock();\n\tpercpu_down_write(&mem_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "start_pfn"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "resource_size(resource)",
            "PA_SECTION_SIZE"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resource_size",
          "args": [
            "resource"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_put",
          "args": [
            "&devmem->ref"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_WARN",
          "args": [
            "dev",
            "\"%s: page mapping is still live!\\n\"",
            "__func__"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_tryget_live",
          "args": [
            "&devmem->ref"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\n#define PA_SECTION_SIZE (1UL << PA_SECTION_SHIFT)\n\nstatic void hmm_devmem_release(struct device *dev, void *data)\n{\n\tstruct hmm_devmem *devmem = data;\n\tstruct resource *resource = devmem->resource;\n\tunsigned long start_pfn, npages;\n\tstruct zone *zone;\n\tstruct page *page;\n\n\tif (percpu_ref_tryget_live(&devmem->ref)) {\n\t\tdev_WARN(dev, \"%s: page mapping is still live!\\n\", __func__);\n\t\tpercpu_ref_put(&devmem->ref);\n\t}\n\n\t/* pages are dead and unused, undo the arch mapping */\n\tstart_pfn = (resource->start & ~(PA_SECTION_SIZE - 1)) >> PAGE_SHIFT;\n\tnpages = ALIGN(resource_size(resource), PA_SECTION_SIZE) >> PAGE_SHIFT;\n\n\tpage = pfn_to_page(start_pfn);\n\tzone = page_zone(page);\n\n\tmem_hotplug_begin();\n\tif (resource->desc == IORES_DESC_DEVICE_PRIVATE_MEMORY)\n\t\t__remove_pages(zone, start_pfn, npages, NULL);\n\telse\n\t\tarch_remove_memory(start_pfn << PAGE_SHIFT,\n\t\t\t\t   npages << PAGE_SHIFT, NULL);\n\tmem_hotplug_done();\n\n\thmm_devmem_radix_release(resource);\n}"
  },
  {
    "function_name": "hmm_devmem_radix_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "1027-1037",
    "snippet": "static void hmm_devmem_radix_release(struct resource *resource)\n{\n\tresource_size_t key;\n\n\tmutex_lock(&hmm_devmem_lock);\n\tfor (key = resource->start;\n\t     key <= resource->end;\n\t     key += PA_SECTION_SIZE)\n\t\tradix_tree_delete(&hmm_devmem_radix, key >> PA_SECTION_SHIFT);\n\tmutex_unlock(&hmm_devmem_lock);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define PA_SECTION_SIZE (1UL << PA_SECTION_SHIFT)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&hmm_devmem_lock"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_delete",
          "args": [
            "&hmm_devmem_radix",
            "key >> PA_SECTION_SHIFT"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&hmm_devmem_lock"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\n#define PA_SECTION_SIZE (1UL << PA_SECTION_SHIFT)\n\nstatic void hmm_devmem_radix_release(struct resource *resource)\n{\n\tresource_size_t key;\n\n\tmutex_lock(&hmm_devmem_lock);\n\tfor (key = resource->start;\n\t     key <= resource->end;\n\t     key += PA_SECTION_SIZE)\n\t\tradix_tree_delete(&hmm_devmem_radix, key >> PA_SECTION_SHIFT);\n\tmutex_unlock(&hmm_devmem_lock);\n}"
  },
  {
    "function_name": "hmm_devmem_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "1015-1022",
    "snippet": "static void hmm_devmem_free(struct page *page, void *data)\n{\n\tstruct hmm_devmem *devmem = data;\n\n\tpage->mapping = NULL;\n\n\tdevmem->ops->free(devmem, page);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "devmem->ops->free",
          "args": [
            "devmem",
            "page"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic void hmm_devmem_free(struct page *page, void *data)\n{\n\tstruct hmm_devmem *devmem = data;\n\n\tpage->mapping = NULL;\n\n\tdevmem->ops->free(devmem, page);\n}"
  },
  {
    "function_name": "hmm_devmem_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "1004-1013",
    "snippet": "static int hmm_devmem_fault(struct vm_area_struct *vma,\n\t\t\t    unsigned long addr,\n\t\t\t    const struct page *page,\n\t\t\t    unsigned int flags,\n\t\t\t    pmd_t *pmdp)\n{\n\tstruct hmm_devmem *devmem = page->pgmap->data;\n\n\treturn devmem->ops->fault(devmem, vma, addr, page, flags, pmdp);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "devmem->ops->fault",
          "args": [
            "devmem",
            "vma",
            "addr",
            "page",
            "flags",
            "pmdp"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic int hmm_devmem_fault(struct vm_area_struct *vma,\n\t\t\t    unsigned long addr,\n\t\t\t    const struct page *page,\n\t\t\t    unsigned int flags,\n\t\t\t    pmd_t *pmdp)\n{\n\tstruct hmm_devmem *devmem = page->pgmap->data;\n\n\treturn devmem->ops->fault(devmem, vma, addr, page, flags, pmdp);\n}"
  },
  {
    "function_name": "hmm_devmem_ref_kill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "993-1002",
    "snippet": "static void hmm_devmem_ref_kill(void *data)\n{\n\tstruct percpu_ref *ref = data;\n\tstruct hmm_devmem *devmem;\n\n\tdevmem = container_of(ref, struct hmm_devmem, ref);\n\tpercpu_ref_kill(ref);\n\twait_for_completion(&devmem->completion);\n\tdevm_remove_action(devmem->device, &hmm_devmem_ref_kill, data);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "devm_remove_action",
          "args": [
            "devmem->device",
            "&hmm_devmem_ref_kill",
            "data"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&devmem->completion"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_kill",
          "args": [
            "ref"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ref",
            "structhmm_devmem",
            "ref"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic void hmm_devmem_ref_kill(void *data)\n{\n\tstruct percpu_ref *ref = data;\n\tstruct hmm_devmem *devmem;\n\n\tdevmem = container_of(ref, struct hmm_devmem, ref);\n\tpercpu_ref_kill(ref);\n\twait_for_completion(&devmem->completion);\n\tdevm_remove_action(devmem->device, &hmm_devmem_ref_kill, data);\n}"
  },
  {
    "function_name": "hmm_devmem_ref_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "983-991",
    "snippet": "static void hmm_devmem_ref_exit(void *data)\n{\n\tstruct percpu_ref *ref = data;\n\tstruct hmm_devmem *devmem;\n\n\tdevmem = container_of(ref, struct hmm_devmem, ref);\n\tpercpu_ref_exit(ref);\n\tdevm_remove_action(devmem->device, &hmm_devmem_ref_exit, data);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "devm_remove_action",
          "args": [
            "devmem->device",
            "&hmm_devmem_ref_exit",
            "data"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_ref_exit",
          "args": [
            "ref"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ref",
            "structhmm_devmem",
            "ref"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic void hmm_devmem_ref_exit(void *data)\n{\n\tstruct percpu_ref *ref = data;\n\tstruct hmm_devmem *devmem;\n\n\tdevmem = container_of(ref, struct hmm_devmem, ref);\n\tpercpu_ref_exit(ref);\n\tdevm_remove_action(devmem->device, &hmm_devmem_ref_exit, data);\n}"
  },
  {
    "function_name": "hmm_devmem_ref_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "975-981",
    "snippet": "static void hmm_devmem_ref_release(struct percpu_ref *ref)\n{\n\tstruct hmm_devmem *devmem;\n\n\tdevmem = container_of(ref, struct hmm_devmem, ref);\n\tcomplete(&devmem->completion);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&devmem->completion"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ref",
            "structhmm_devmem",
            "ref"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic void hmm_devmem_ref_release(struct percpu_ref *ref)\n{\n\tstruct hmm_devmem *devmem;\n\n\tdevmem = container_of(ref, struct hmm_devmem, ref);\n\tcomplete(&devmem->completion);\n}"
  },
  {
    "function_name": "hmm_vma_alloc_locked_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "961-971",
    "snippet": "struct page *hmm_vma_alloc_locked_page(struct vm_area_struct *vma,\n\t\t\t\t       unsigned long addr)\n{\n\tstruct page *page;\n\n\tpage = alloc_page_vma(GFP_HIGHUSER, vma, addr);\n\tif (!page)\n\t\treturn NULL;\n\tlock_page(page);\n\treturn page;\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "page"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_page_vma",
          "args": [
            "GFP_HIGHUSER",
            "vma",
            "addr"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstruct page *hmm_vma_alloc_locked_page(struct vm_area_struct *vma,\n\t\t\t\t       unsigned long addr)\n{\n\tstruct page *page;\n\n\tpage = alloc_page_vma(GFP_HIGHUSER, vma, addr);\n\tif (!page)\n\t\treturn NULL;\n\tlock_page(page);\n\treturn page;\n}"
  },
  {
    "function_name": "hmm_vma_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "879-955",
    "snippet": "int hmm_vma_fault(struct hmm_range *range, bool block)\n{\n\tstruct vm_area_struct *vma = range->vma;\n\tunsigned long start = range->start;\n\tstruct hmm_vma_walk hmm_vma_walk;\n\tstruct mm_walk mm_walk;\n\tstruct hmm *hmm;\n\tint ret;\n\n\t/* Sanity check, this really should not happen ! */\n\tif (range->start < vma->vm_start || range->start >= vma->vm_end)\n\t\treturn -EINVAL;\n\tif (range->end < vma->vm_start || range->end > vma->vm_end)\n\t\treturn -EINVAL;\n\n\thmm = hmm_register(vma->vm_mm);\n\tif (!hmm) {\n\t\thmm_pfns_clear(range, range->pfns, range->start, range->end);\n\t\treturn -ENOMEM;\n\t}\n\t/* Caller must have registered a mirror using hmm_mirror_register() */\n\tif (!hmm->mmu_notifier.ops)\n\t\treturn -EINVAL;\n\n\t/* FIXME support hugetlb fs */\n\tif (is_vm_hugetlb_page(vma) || (vma->vm_flags & VM_SPECIAL) ||\n\t\t\tvma_is_dax(vma)) {\n\t\thmm_pfns_special(range);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!(vma->vm_flags & VM_READ)) {\n\t\t/*\n\t\t * If vma do not allow read access, then assume that it does\n\t\t * not allow write access, either. Architecture that allow\n\t\t * write without read access are not supported by HMM, because\n\t\t * operations such has atomic access would not work.\n\t\t */\n\t\thmm_pfns_clear(range, range->pfns, range->start, range->end);\n\t\treturn -EPERM;\n\t}\n\n\t/* Initialize range to track CPU page table update */\n\tspin_lock(&hmm->lock);\n\trange->valid = true;\n\tlist_add_rcu(&range->list, &hmm->ranges);\n\tspin_unlock(&hmm->lock);\n\n\thmm_vma_walk.fault = true;\n\thmm_vma_walk.block = block;\n\thmm_vma_walk.range = range;\n\tmm_walk.private = &hmm_vma_walk;\n\thmm_vma_walk.last = range->start;\n\n\tmm_walk.vma = vma;\n\tmm_walk.mm = vma->vm_mm;\n\tmm_walk.pte_entry = NULL;\n\tmm_walk.test_walk = NULL;\n\tmm_walk.hugetlb_entry = NULL;\n\tmm_walk.pmd_entry = hmm_vma_walk_pmd;\n\tmm_walk.pte_hole = hmm_vma_walk_hole;\n\n\tdo {\n\t\tret = walk_page_range(start, range->end, &mm_walk);\n\t\tstart = hmm_vma_walk.last;\n\t} while (ret == -EAGAIN);\n\n\tif (ret) {\n\t\tunsigned long i;\n\n\t\ti = (hmm_vma_walk.last - range->start) >> PAGE_SHIFT;\n\t\thmm_pfns_clear(range, &range->pfns[i], hmm_vma_walk.last,\n\t\t\t       range->end);\n\t\thmm_vma_range_done(range);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hmm_vma_range_done",
          "args": [
            "range"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "hmm_vma_range_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
          "lines": "808-829",
          "snippet": "bool hmm_vma_range_done(struct hmm_range *range)\n{\n\tunsigned long npages = (range->end - range->start) >> PAGE_SHIFT;\n\tstruct hmm *hmm;\n\n\tif (range->end <= range->start) {\n\t\tBUG();\n\t\treturn false;\n\t}\n\n\thmm = hmm_register(range->vma->vm_mm);\n\tif (!hmm) {\n\t\tmemset(range->pfns, 0, sizeof(*range->pfns) * npages);\n\t\treturn false;\n\t}\n\n\tspin_lock(&hmm->lock);\n\tlist_del_rcu(&range->list);\n\tspin_unlock(&hmm->lock);\n\n\treturn range->valid;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/memremap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/init.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nbool hmm_vma_range_done(struct hmm_range *range)\n{\n\tunsigned long npages = (range->end - range->start) >> PAGE_SHIFT;\n\tstruct hmm *hmm;\n\n\tif (range->end <= range->start) {\n\t\tBUG();\n\t\treturn false;\n\t}\n\n\thmm = hmm_register(range->vma->vm_mm);\n\tif (!hmm) {\n\t\tmemset(range->pfns, 0, sizeof(*range->pfns) * npages);\n\t\treturn false;\n\t}\n\n\tspin_lock(&hmm->lock);\n\tlist_del_rcu(&range->list);\n\tspin_unlock(&hmm->lock);\n\n\treturn range->valid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hmm_pfns_clear",
          "args": [
            "range",
            "&range->pfns[i]",
            "hmm_vma_walk.last",
            "range->end"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "hmm_pfns_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
          "lines": "675-682",
          "snippet": "static void hmm_pfns_clear(struct hmm_range *range,\n\t\t\t   uint64_t *pfns,\n\t\t\t   unsigned long addr,\n\t\t\t   unsigned long end)\n{\n\tfor (; addr < end; addr += PAGE_SIZE, pfns++)\n\t\t*pfns = range->values[HMM_PFN_NONE];\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/memremap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/init.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic void hmm_pfns_clear(struct hmm_range *range,\n\t\t\t   uint64_t *pfns,\n\t\t\t   unsigned long addr,\n\t\t\t   unsigned long end)\n{\n\tfor (; addr < end; addr += PAGE_SIZE, pfns++)\n\t\t*pfns = range->values[HMM_PFN_NONE];\n}"
        }
      },
      {
        "call_info": {
          "callee": "walk_page_range",
          "args": [
            "start",
            "range->end",
            "&mm_walk"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "walk_page_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pagewalk.c",
          "lines": "293-340",
          "snippet": "int walk_page_range(unsigned long start, unsigned long end,\n\t\t    struct mm_walk *walk)\n{\n\tint err = 0;\n\tunsigned long next;\n\tstruct vm_area_struct *vma;\n\n\tif (start >= end)\n\t\treturn -EINVAL;\n\n\tif (!walk->mm)\n\t\treturn -EINVAL;\n\n\tVM_BUG_ON_MM(!rwsem_is_locked(&walk->mm->mmap_sem), walk->mm);\n\n\tvma = find_vma(walk->mm, start);\n\tdo {\n\t\tif (!vma) { /* after the last vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = end;\n\t\t} else if (start < vma->vm_start) { /* outside vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = min(end, vma->vm_start);\n\t\t} else { /* inside vma */\n\t\t\twalk->vma = vma;\n\t\t\tnext = min(end, vma->vm_end);\n\t\t\tvma = vma->vm_next;\n\n\t\t\terr = walk_page_test(start, next, walk);\n\t\t\tif (err > 0) {\n\t\t\t\t/*\n\t\t\t\t * positive return values are purely for\n\t\t\t\t * controlling the pagewalk, so should never\n\t\t\t\t * be passed to the callers.\n\t\t\t\t */\n\t\t\t\terr = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (walk->vma || walk->pte_hole)\n\t\t\terr = __walk_page_range(start, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (start = next, start < end);\n\treturn err;\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nint walk_page_range(unsigned long start, unsigned long end,\n\t\t    struct mm_walk *walk)\n{\n\tint err = 0;\n\tunsigned long next;\n\tstruct vm_area_struct *vma;\n\n\tif (start >= end)\n\t\treturn -EINVAL;\n\n\tif (!walk->mm)\n\t\treturn -EINVAL;\n\n\tVM_BUG_ON_MM(!rwsem_is_locked(&walk->mm->mmap_sem), walk->mm);\n\n\tvma = find_vma(walk->mm, start);\n\tdo {\n\t\tif (!vma) { /* after the last vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = end;\n\t\t} else if (start < vma->vm_start) { /* outside vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = min(end, vma->vm_start);\n\t\t} else { /* inside vma */\n\t\t\twalk->vma = vma;\n\t\t\tnext = min(end, vma->vm_end);\n\t\t\tvma = vma->vm_next;\n\n\t\t\terr = walk_page_test(start, next, walk);\n\t\t\tif (err > 0) {\n\t\t\t\t/*\n\t\t\t\t * positive return values are purely for\n\t\t\t\t * controlling the pagewalk, so should never\n\t\t\t\t * be passed to the callers.\n\t\t\t\t */\n\t\t\t\terr = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (walk->vma || walk->pte_hole)\n\t\t\terr = __walk_page_range(start, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (start = next, start < end);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hmm->lock"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&range->list",
            "&hmm->ranges"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hmm->lock"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hmm_pfns_special",
          "args": [
            "range"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "hmm_pfns_special",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
          "lines": "684-690",
          "snippet": "static void hmm_pfns_special(struct hmm_range *range)\n{\n\tunsigned long addr = range->start, i = 0;\n\n\tfor (; addr < range->end; addr += PAGE_SIZE, i++)\n\t\trange->pfns[i] = range->values[HMM_PFN_SPECIAL];\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/memremap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/init.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic void hmm_pfns_special(struct hmm_range *range)\n{\n\tunsigned long addr = range->start, i = 0;\n\n\tfor (; addr < range->end; addr += PAGE_SIZE, i++)\n\t\trange->pfns[i] = range->values[HMM_PFN_SPECIAL];\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_is_dax",
          "args": [
            "vma"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vm_hugetlb_page",
          "args": [
            "vma"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hmm_register",
          "args": [
            "vma->vm_mm"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "hmm_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
          "lines": "68-119",
          "snippet": "static struct hmm *hmm_register(struct mm_struct *mm)\n{\n\tstruct hmm *hmm = READ_ONCE(mm->hmm);\n\tbool cleanup = false;\n\n\t/*\n\t * The hmm struct can only be freed once the mm_struct goes away,\n\t * hence we should always have pre-allocated an new hmm struct\n\t * above.\n\t */\n\tif (hmm)\n\t\treturn hmm;\n\n\thmm = kmalloc(sizeof(*hmm), GFP_KERNEL);\n\tif (!hmm)\n\t\treturn NULL;\n\tINIT_LIST_HEAD(&hmm->mirrors);\n\tinit_rwsem(&hmm->mirrors_sem);\n\thmm->mmu_notifier.ops = NULL;\n\tINIT_LIST_HEAD(&hmm->ranges);\n\tspin_lock_init(&hmm->lock);\n\thmm->mm = mm;\n\n\tspin_lock(&mm->page_table_lock);\n\tif (!mm->hmm)\n\t\tmm->hmm = hmm;\n\telse\n\t\tcleanup = true;\n\tspin_unlock(&mm->page_table_lock);\n\n\tif (cleanup)\n\t\tgoto error;\n\n\t/*\n\t * We should only get here if hold the mmap_sem in write mode ie on\n\t * registration of first mirror through hmm_mirror_register()\n\t */\n\thmm->mmu_notifier.ops = &hmm_mmu_notifier_ops;\n\tif (__mmu_notifier_register(&hmm->mmu_notifier, mm))\n\t\tgoto error_mm;\n\n\treturn mm->hmm;\n\nerror_mm:\n\tspin_lock(&mm->page_table_lock);\n\tif (mm->hmm == hmm)\n\t\tmm->hmm = NULL;\n\tspin_unlock(&mm->page_table_lock);\nerror:\n\tkfree(hmm);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/memremap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/init.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic struct hmm *hmm_register(struct mm_struct *mm)\n{\n\tstruct hmm *hmm = READ_ONCE(mm->hmm);\n\tbool cleanup = false;\n\n\t/*\n\t * The hmm struct can only be freed once the mm_struct goes away,\n\t * hence we should always have pre-allocated an new hmm struct\n\t * above.\n\t */\n\tif (hmm)\n\t\treturn hmm;\n\n\thmm = kmalloc(sizeof(*hmm), GFP_KERNEL);\n\tif (!hmm)\n\t\treturn NULL;\n\tINIT_LIST_HEAD(&hmm->mirrors);\n\tinit_rwsem(&hmm->mirrors_sem);\n\thmm->mmu_notifier.ops = NULL;\n\tINIT_LIST_HEAD(&hmm->ranges);\n\tspin_lock_init(&hmm->lock);\n\thmm->mm = mm;\n\n\tspin_lock(&mm->page_table_lock);\n\tif (!mm->hmm)\n\t\tmm->hmm = hmm;\n\telse\n\t\tcleanup = true;\n\tspin_unlock(&mm->page_table_lock);\n\n\tif (cleanup)\n\t\tgoto error;\n\n\t/*\n\t * We should only get here if hold the mmap_sem in write mode ie on\n\t * registration of first mirror through hmm_mirror_register()\n\t */\n\thmm->mmu_notifier.ops = &hmm_mmu_notifier_ops;\n\tif (__mmu_notifier_register(&hmm->mmu_notifier, mm))\n\t\tgoto error_mm;\n\n\treturn mm->hmm;\n\nerror_mm:\n\tspin_lock(&mm->page_table_lock);\n\tif (mm->hmm == hmm)\n\t\tmm->hmm = NULL;\n\tspin_unlock(&mm->page_table_lock);\nerror:\n\tkfree(hmm);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nint hmm_vma_fault(struct hmm_range *range, bool block)\n{\n\tstruct vm_area_struct *vma = range->vma;\n\tunsigned long start = range->start;\n\tstruct hmm_vma_walk hmm_vma_walk;\n\tstruct mm_walk mm_walk;\n\tstruct hmm *hmm;\n\tint ret;\n\n\t/* Sanity check, this really should not happen ! */\n\tif (range->start < vma->vm_start || range->start >= vma->vm_end)\n\t\treturn -EINVAL;\n\tif (range->end < vma->vm_start || range->end > vma->vm_end)\n\t\treturn -EINVAL;\n\n\thmm = hmm_register(vma->vm_mm);\n\tif (!hmm) {\n\t\thmm_pfns_clear(range, range->pfns, range->start, range->end);\n\t\treturn -ENOMEM;\n\t}\n\t/* Caller must have registered a mirror using hmm_mirror_register() */\n\tif (!hmm->mmu_notifier.ops)\n\t\treturn -EINVAL;\n\n\t/* FIXME support hugetlb fs */\n\tif (is_vm_hugetlb_page(vma) || (vma->vm_flags & VM_SPECIAL) ||\n\t\t\tvma_is_dax(vma)) {\n\t\thmm_pfns_special(range);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!(vma->vm_flags & VM_READ)) {\n\t\t/*\n\t\t * If vma do not allow read access, then assume that it does\n\t\t * not allow write access, either. Architecture that allow\n\t\t * write without read access are not supported by HMM, because\n\t\t * operations such has atomic access would not work.\n\t\t */\n\t\thmm_pfns_clear(range, range->pfns, range->start, range->end);\n\t\treturn -EPERM;\n\t}\n\n\t/* Initialize range to track CPU page table update */\n\tspin_lock(&hmm->lock);\n\trange->valid = true;\n\tlist_add_rcu(&range->list, &hmm->ranges);\n\tspin_unlock(&hmm->lock);\n\n\thmm_vma_walk.fault = true;\n\thmm_vma_walk.block = block;\n\thmm_vma_walk.range = range;\n\tmm_walk.private = &hmm_vma_walk;\n\thmm_vma_walk.last = range->start;\n\n\tmm_walk.vma = vma;\n\tmm_walk.mm = vma->vm_mm;\n\tmm_walk.pte_entry = NULL;\n\tmm_walk.test_walk = NULL;\n\tmm_walk.hugetlb_entry = NULL;\n\tmm_walk.pmd_entry = hmm_vma_walk_pmd;\n\tmm_walk.pte_hole = hmm_vma_walk_hole;\n\n\tdo {\n\t\tret = walk_page_range(start, range->end, &mm_walk);\n\t\tstart = hmm_vma_walk.last;\n\t} while (ret == -EAGAIN);\n\n\tif (ret) {\n\t\tunsigned long i;\n\n\t\ti = (hmm_vma_walk.last - range->start) >> PAGE_SHIFT;\n\t\thmm_pfns_clear(range, &range->pfns[i], hmm_vma_walk.last,\n\t\t\t       range->end);\n\t\thmm_vma_range_done(range);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "hmm_vma_range_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "808-829",
    "snippet": "bool hmm_vma_range_done(struct hmm_range *range)\n{\n\tunsigned long npages = (range->end - range->start) >> PAGE_SHIFT;\n\tstruct hmm *hmm;\n\n\tif (range->end <= range->start) {\n\t\tBUG();\n\t\treturn false;\n\t}\n\n\thmm = hmm_register(range->vma->vm_mm);\n\tif (!hmm) {\n\t\tmemset(range->pfns, 0, sizeof(*range->pfns) * npages);\n\t\treturn false;\n\t}\n\n\tspin_lock(&hmm->lock);\n\tlist_del_rcu(&range->list);\n\tspin_unlock(&hmm->lock);\n\n\treturn range->valid;\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hmm->lock"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&range->list"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hmm->lock"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "range->pfns",
            "0",
            "sizeof(*range->pfns) * npages"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hmm_register",
          "args": [
            "range->vma->vm_mm"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "hmm_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
          "lines": "68-119",
          "snippet": "static struct hmm *hmm_register(struct mm_struct *mm)\n{\n\tstruct hmm *hmm = READ_ONCE(mm->hmm);\n\tbool cleanup = false;\n\n\t/*\n\t * The hmm struct can only be freed once the mm_struct goes away,\n\t * hence we should always have pre-allocated an new hmm struct\n\t * above.\n\t */\n\tif (hmm)\n\t\treturn hmm;\n\n\thmm = kmalloc(sizeof(*hmm), GFP_KERNEL);\n\tif (!hmm)\n\t\treturn NULL;\n\tINIT_LIST_HEAD(&hmm->mirrors);\n\tinit_rwsem(&hmm->mirrors_sem);\n\thmm->mmu_notifier.ops = NULL;\n\tINIT_LIST_HEAD(&hmm->ranges);\n\tspin_lock_init(&hmm->lock);\n\thmm->mm = mm;\n\n\tspin_lock(&mm->page_table_lock);\n\tif (!mm->hmm)\n\t\tmm->hmm = hmm;\n\telse\n\t\tcleanup = true;\n\tspin_unlock(&mm->page_table_lock);\n\n\tif (cleanup)\n\t\tgoto error;\n\n\t/*\n\t * We should only get here if hold the mmap_sem in write mode ie on\n\t * registration of first mirror through hmm_mirror_register()\n\t */\n\thmm->mmu_notifier.ops = &hmm_mmu_notifier_ops;\n\tif (__mmu_notifier_register(&hmm->mmu_notifier, mm))\n\t\tgoto error_mm;\n\n\treturn mm->hmm;\n\nerror_mm:\n\tspin_lock(&mm->page_table_lock);\n\tif (mm->hmm == hmm)\n\t\tmm->hmm = NULL;\n\tspin_unlock(&mm->page_table_lock);\nerror:\n\tkfree(hmm);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/memremap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/init.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic struct hmm *hmm_register(struct mm_struct *mm)\n{\n\tstruct hmm *hmm = READ_ONCE(mm->hmm);\n\tbool cleanup = false;\n\n\t/*\n\t * The hmm struct can only be freed once the mm_struct goes away,\n\t * hence we should always have pre-allocated an new hmm struct\n\t * above.\n\t */\n\tif (hmm)\n\t\treturn hmm;\n\n\thmm = kmalloc(sizeof(*hmm), GFP_KERNEL);\n\tif (!hmm)\n\t\treturn NULL;\n\tINIT_LIST_HEAD(&hmm->mirrors);\n\tinit_rwsem(&hmm->mirrors_sem);\n\thmm->mmu_notifier.ops = NULL;\n\tINIT_LIST_HEAD(&hmm->ranges);\n\tspin_lock_init(&hmm->lock);\n\thmm->mm = mm;\n\n\tspin_lock(&mm->page_table_lock);\n\tif (!mm->hmm)\n\t\tmm->hmm = hmm;\n\telse\n\t\tcleanup = true;\n\tspin_unlock(&mm->page_table_lock);\n\n\tif (cleanup)\n\t\tgoto error;\n\n\t/*\n\t * We should only get here if hold the mmap_sem in write mode ie on\n\t * registration of first mirror through hmm_mirror_register()\n\t */\n\thmm->mmu_notifier.ops = &hmm_mmu_notifier_ops;\n\tif (__mmu_notifier_register(&hmm->mmu_notifier, mm))\n\t\tgoto error_mm;\n\n\treturn mm->hmm;\n\nerror_mm:\n\tspin_lock(&mm->page_table_lock);\n\tif (mm->hmm == hmm)\n\t\tmm->hmm = NULL;\n\tspin_unlock(&mm->page_table_lock);\nerror:\n\tkfree(hmm);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nbool hmm_vma_range_done(struct hmm_range *range)\n{\n\tunsigned long npages = (range->end - range->start) >> PAGE_SHIFT;\n\tstruct hmm *hmm;\n\n\tif (range->end <= range->start) {\n\t\tBUG();\n\t\treturn false;\n\t}\n\n\thmm = hmm_register(range->vma->vm_mm);\n\tif (!hmm) {\n\t\tmemset(range->pfns, 0, sizeof(*range->pfns) * npages);\n\t\treturn false;\n\t}\n\n\tspin_lock(&hmm->lock);\n\tlist_del_rcu(&range->list);\n\tspin_unlock(&hmm->lock);\n\n\treturn range->valid;\n}"
  },
  {
    "function_name": "hmm_vma_get_pfns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "709-767",
    "snippet": "int hmm_vma_get_pfns(struct hmm_range *range)\n{\n\tstruct vm_area_struct *vma = range->vma;\n\tstruct hmm_vma_walk hmm_vma_walk;\n\tstruct mm_walk mm_walk;\n\tstruct hmm *hmm;\n\n\t/* Sanity check, this really should not happen ! */\n\tif (range->start < vma->vm_start || range->start >= vma->vm_end)\n\t\treturn -EINVAL;\n\tif (range->end < vma->vm_start || range->end > vma->vm_end)\n\t\treturn -EINVAL;\n\n\thmm = hmm_register(vma->vm_mm);\n\tif (!hmm)\n\t\treturn -ENOMEM;\n\t/* Caller must have registered a mirror, via hmm_mirror_register() ! */\n\tif (!hmm->mmu_notifier.ops)\n\t\treturn -EINVAL;\n\n\t/* FIXME support hugetlb fs */\n\tif (is_vm_hugetlb_page(vma) || (vma->vm_flags & VM_SPECIAL) ||\n\t\t\tvma_is_dax(vma)) {\n\t\thmm_pfns_special(range);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!(vma->vm_flags & VM_READ)) {\n\t\t/*\n\t\t * If vma do not allow read access, then assume that it does\n\t\t * not allow write access, either. Architecture that allow\n\t\t * write without read access are not supported by HMM, because\n\t\t * operations such has atomic access would not work.\n\t\t */\n\t\thmm_pfns_clear(range, range->pfns, range->start, range->end);\n\t\treturn -EPERM;\n\t}\n\n\t/* Initialize range to track CPU page table update */\n\tspin_lock(&hmm->lock);\n\trange->valid = true;\n\tlist_add_rcu(&range->list, &hmm->ranges);\n\tspin_unlock(&hmm->lock);\n\n\thmm_vma_walk.fault = false;\n\thmm_vma_walk.range = range;\n\tmm_walk.private = &hmm_vma_walk;\n\n\tmm_walk.vma = vma;\n\tmm_walk.mm = vma->vm_mm;\n\tmm_walk.pte_entry = NULL;\n\tmm_walk.test_walk = NULL;\n\tmm_walk.hugetlb_entry = NULL;\n\tmm_walk.pmd_entry = hmm_vma_walk_pmd;\n\tmm_walk.pte_hole = hmm_vma_walk_hole;\n\n\twalk_page_range(range->start, range->end, &mm_walk);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "walk_page_range",
          "args": [
            "range->start",
            "range->end",
            "&mm_walk"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "walk_page_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pagewalk.c",
          "lines": "293-340",
          "snippet": "int walk_page_range(unsigned long start, unsigned long end,\n\t\t    struct mm_walk *walk)\n{\n\tint err = 0;\n\tunsigned long next;\n\tstruct vm_area_struct *vma;\n\n\tif (start >= end)\n\t\treturn -EINVAL;\n\n\tif (!walk->mm)\n\t\treturn -EINVAL;\n\n\tVM_BUG_ON_MM(!rwsem_is_locked(&walk->mm->mmap_sem), walk->mm);\n\n\tvma = find_vma(walk->mm, start);\n\tdo {\n\t\tif (!vma) { /* after the last vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = end;\n\t\t} else if (start < vma->vm_start) { /* outside vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = min(end, vma->vm_start);\n\t\t} else { /* inside vma */\n\t\t\twalk->vma = vma;\n\t\t\tnext = min(end, vma->vm_end);\n\t\t\tvma = vma->vm_next;\n\n\t\t\terr = walk_page_test(start, next, walk);\n\t\t\tif (err > 0) {\n\t\t\t\t/*\n\t\t\t\t * positive return values are purely for\n\t\t\t\t * controlling the pagewalk, so should never\n\t\t\t\t * be passed to the callers.\n\t\t\t\t */\n\t\t\t\terr = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (walk->vma || walk->pte_hole)\n\t\t\terr = __walk_page_range(start, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (start = next, start < end);\n\treturn err;\n}",
          "includes": [
            "#include <linux/hugetlb.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hugetlb.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nint walk_page_range(unsigned long start, unsigned long end,\n\t\t    struct mm_walk *walk)\n{\n\tint err = 0;\n\tunsigned long next;\n\tstruct vm_area_struct *vma;\n\n\tif (start >= end)\n\t\treturn -EINVAL;\n\n\tif (!walk->mm)\n\t\treturn -EINVAL;\n\n\tVM_BUG_ON_MM(!rwsem_is_locked(&walk->mm->mmap_sem), walk->mm);\n\n\tvma = find_vma(walk->mm, start);\n\tdo {\n\t\tif (!vma) { /* after the last vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = end;\n\t\t} else if (start < vma->vm_start) { /* outside vma */\n\t\t\twalk->vma = NULL;\n\t\t\tnext = min(end, vma->vm_start);\n\t\t} else { /* inside vma */\n\t\t\twalk->vma = vma;\n\t\t\tnext = min(end, vma->vm_end);\n\t\t\tvma = vma->vm_next;\n\n\t\t\terr = walk_page_test(start, next, walk);\n\t\t\tif (err > 0) {\n\t\t\t\t/*\n\t\t\t\t * positive return values are purely for\n\t\t\t\t * controlling the pagewalk, so should never\n\t\t\t\t * be passed to the callers.\n\t\t\t\t */\n\t\t\t\terr = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (walk->vma || walk->pte_hole)\n\t\t\terr = __walk_page_range(start, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (start = next, start < end);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hmm->lock"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&range->list",
            "&hmm->ranges"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hmm->lock"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hmm_pfns_clear",
          "args": [
            "range",
            "range->pfns",
            "range->start",
            "range->end"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "hmm_pfns_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
          "lines": "675-682",
          "snippet": "static void hmm_pfns_clear(struct hmm_range *range,\n\t\t\t   uint64_t *pfns,\n\t\t\t   unsigned long addr,\n\t\t\t   unsigned long end)\n{\n\tfor (; addr < end; addr += PAGE_SIZE, pfns++)\n\t\t*pfns = range->values[HMM_PFN_NONE];\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/memremap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/init.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic void hmm_pfns_clear(struct hmm_range *range,\n\t\t\t   uint64_t *pfns,\n\t\t\t   unsigned long addr,\n\t\t\t   unsigned long end)\n{\n\tfor (; addr < end; addr += PAGE_SIZE, pfns++)\n\t\t*pfns = range->values[HMM_PFN_NONE];\n}"
        }
      },
      {
        "call_info": {
          "callee": "hmm_pfns_special",
          "args": [
            "range"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "hmm_pfns_special",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
          "lines": "684-690",
          "snippet": "static void hmm_pfns_special(struct hmm_range *range)\n{\n\tunsigned long addr = range->start, i = 0;\n\n\tfor (; addr < range->end; addr += PAGE_SIZE, i++)\n\t\trange->pfns[i] = range->values[HMM_PFN_SPECIAL];\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/memremap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/init.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic void hmm_pfns_special(struct hmm_range *range)\n{\n\tunsigned long addr = range->start, i = 0;\n\n\tfor (; addr < range->end; addr += PAGE_SIZE, i++)\n\t\trange->pfns[i] = range->values[HMM_PFN_SPECIAL];\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_is_dax",
          "args": [
            "vma"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vm_hugetlb_page",
          "args": [
            "vma"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hmm_register",
          "args": [
            "vma->vm_mm"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "hmm_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
          "lines": "68-119",
          "snippet": "static struct hmm *hmm_register(struct mm_struct *mm)\n{\n\tstruct hmm *hmm = READ_ONCE(mm->hmm);\n\tbool cleanup = false;\n\n\t/*\n\t * The hmm struct can only be freed once the mm_struct goes away,\n\t * hence we should always have pre-allocated an new hmm struct\n\t * above.\n\t */\n\tif (hmm)\n\t\treturn hmm;\n\n\thmm = kmalloc(sizeof(*hmm), GFP_KERNEL);\n\tif (!hmm)\n\t\treturn NULL;\n\tINIT_LIST_HEAD(&hmm->mirrors);\n\tinit_rwsem(&hmm->mirrors_sem);\n\thmm->mmu_notifier.ops = NULL;\n\tINIT_LIST_HEAD(&hmm->ranges);\n\tspin_lock_init(&hmm->lock);\n\thmm->mm = mm;\n\n\tspin_lock(&mm->page_table_lock);\n\tif (!mm->hmm)\n\t\tmm->hmm = hmm;\n\telse\n\t\tcleanup = true;\n\tspin_unlock(&mm->page_table_lock);\n\n\tif (cleanup)\n\t\tgoto error;\n\n\t/*\n\t * We should only get here if hold the mmap_sem in write mode ie on\n\t * registration of first mirror through hmm_mirror_register()\n\t */\n\thmm->mmu_notifier.ops = &hmm_mmu_notifier_ops;\n\tif (__mmu_notifier_register(&hmm->mmu_notifier, mm))\n\t\tgoto error_mm;\n\n\treturn mm->hmm;\n\nerror_mm:\n\tspin_lock(&mm->page_table_lock);\n\tif (mm->hmm == hmm)\n\t\tmm->hmm = NULL;\n\tspin_unlock(&mm->page_table_lock);\nerror:\n\tkfree(hmm);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/memremap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/init.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic struct hmm *hmm_register(struct mm_struct *mm)\n{\n\tstruct hmm *hmm = READ_ONCE(mm->hmm);\n\tbool cleanup = false;\n\n\t/*\n\t * The hmm struct can only be freed once the mm_struct goes away,\n\t * hence we should always have pre-allocated an new hmm struct\n\t * above.\n\t */\n\tif (hmm)\n\t\treturn hmm;\n\n\thmm = kmalloc(sizeof(*hmm), GFP_KERNEL);\n\tif (!hmm)\n\t\treturn NULL;\n\tINIT_LIST_HEAD(&hmm->mirrors);\n\tinit_rwsem(&hmm->mirrors_sem);\n\thmm->mmu_notifier.ops = NULL;\n\tINIT_LIST_HEAD(&hmm->ranges);\n\tspin_lock_init(&hmm->lock);\n\thmm->mm = mm;\n\n\tspin_lock(&mm->page_table_lock);\n\tif (!mm->hmm)\n\t\tmm->hmm = hmm;\n\telse\n\t\tcleanup = true;\n\tspin_unlock(&mm->page_table_lock);\n\n\tif (cleanup)\n\t\tgoto error;\n\n\t/*\n\t * We should only get here if hold the mmap_sem in write mode ie on\n\t * registration of first mirror through hmm_mirror_register()\n\t */\n\thmm->mmu_notifier.ops = &hmm_mmu_notifier_ops;\n\tif (__mmu_notifier_register(&hmm->mmu_notifier, mm))\n\t\tgoto error_mm;\n\n\treturn mm->hmm;\n\nerror_mm:\n\tspin_lock(&mm->page_table_lock);\n\tif (mm->hmm == hmm)\n\t\tmm->hmm = NULL;\n\tspin_unlock(&mm->page_table_lock);\nerror:\n\tkfree(hmm);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nint hmm_vma_get_pfns(struct hmm_range *range)\n{\n\tstruct vm_area_struct *vma = range->vma;\n\tstruct hmm_vma_walk hmm_vma_walk;\n\tstruct mm_walk mm_walk;\n\tstruct hmm *hmm;\n\n\t/* Sanity check, this really should not happen ! */\n\tif (range->start < vma->vm_start || range->start >= vma->vm_end)\n\t\treturn -EINVAL;\n\tif (range->end < vma->vm_start || range->end > vma->vm_end)\n\t\treturn -EINVAL;\n\n\thmm = hmm_register(vma->vm_mm);\n\tif (!hmm)\n\t\treturn -ENOMEM;\n\t/* Caller must have registered a mirror, via hmm_mirror_register() ! */\n\tif (!hmm->mmu_notifier.ops)\n\t\treturn -EINVAL;\n\n\t/* FIXME support hugetlb fs */\n\tif (is_vm_hugetlb_page(vma) || (vma->vm_flags & VM_SPECIAL) ||\n\t\t\tvma_is_dax(vma)) {\n\t\thmm_pfns_special(range);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!(vma->vm_flags & VM_READ)) {\n\t\t/*\n\t\t * If vma do not allow read access, then assume that it does\n\t\t * not allow write access, either. Architecture that allow\n\t\t * write without read access are not supported by HMM, because\n\t\t * operations such has atomic access would not work.\n\t\t */\n\t\thmm_pfns_clear(range, range->pfns, range->start, range->end);\n\t\treturn -EPERM;\n\t}\n\n\t/* Initialize range to track CPU page table update */\n\tspin_lock(&hmm->lock);\n\trange->valid = true;\n\tlist_add_rcu(&range->list, &hmm->ranges);\n\tspin_unlock(&hmm->lock);\n\n\thmm_vma_walk.fault = false;\n\thmm_vma_walk.range = range;\n\tmm_walk.private = &hmm_vma_walk;\n\n\tmm_walk.vma = vma;\n\tmm_walk.mm = vma->vm_mm;\n\tmm_walk.pte_entry = NULL;\n\tmm_walk.test_walk = NULL;\n\tmm_walk.hugetlb_entry = NULL;\n\tmm_walk.pmd_entry = hmm_vma_walk_pmd;\n\tmm_walk.pte_hole = hmm_vma_walk_hole;\n\n\twalk_page_range(range->start, range->end, &mm_walk);\n\treturn 0;\n}"
  },
  {
    "function_name": "hmm_pfns_special",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "684-690",
    "snippet": "static void hmm_pfns_special(struct hmm_range *range)\n{\n\tunsigned long addr = range->start, i = 0;\n\n\tfor (; addr < range->end; addr += PAGE_SIZE, i++)\n\t\trange->pfns[i] = range->values[HMM_PFN_SPECIAL];\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic void hmm_pfns_special(struct hmm_range *range)\n{\n\tunsigned long addr = range->start, i = 0;\n\n\tfor (; addr < range->end; addr += PAGE_SIZE, i++)\n\t\trange->pfns[i] = range->values[HMM_PFN_SPECIAL];\n}"
  },
  {
    "function_name": "hmm_pfns_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "675-682",
    "snippet": "static void hmm_pfns_clear(struct hmm_range *range,\n\t\t\t   uint64_t *pfns,\n\t\t\t   unsigned long addr,\n\t\t\t   unsigned long end)\n{\n\tfor (; addr < end; addr += PAGE_SIZE, pfns++)\n\t\t*pfns = range->values[HMM_PFN_NONE];\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic void hmm_pfns_clear(struct hmm_range *range,\n\t\t\t   uint64_t *pfns,\n\t\t\t   unsigned long addr,\n\t\t\t   unsigned long end)\n{\n\tfor (; addr < end; addr += PAGE_SIZE, pfns++)\n\t\t*pfns = range->values[HMM_PFN_NONE];\n}"
  },
  {
    "function_name": "hmm_vma_walk_pmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "587-673",
    "snippet": "static int hmm_vma_walk_pmd(pmd_t *pmdp,\n\t\t\t    unsigned long start,\n\t\t\t    unsigned long end,\n\t\t\t    struct mm_walk *walk)\n{\n\tstruct hmm_vma_walk *hmm_vma_walk = walk->private;\n\tstruct hmm_range *range = hmm_vma_walk->range;\n\tstruct vm_area_struct *vma = walk->vma;\n\tuint64_t *pfns = range->pfns;\n\tunsigned long addr = start, i;\n\tpte_t *ptep;\n\tpmd_t pmd;\n\n\nagain:\n\tpmd = READ_ONCE(*pmdp);\n\tif (pmd_none(pmd))\n\t\treturn hmm_vma_walk_hole(start, end, walk);\n\n\tif (pmd_huge(pmd) && (range->vma->vm_flags & VM_HUGETLB))\n\t\treturn hmm_pfns_bad(start, end, walk);\n\n\tif (thp_migration_supported() && is_pmd_migration_entry(pmd)) {\n\t\tbool fault, write_fault;\n\t\tunsigned long npages;\n\t\tuint64_t *pfns;\n\n\t\ti = (addr - range->start) >> PAGE_SHIFT;\n\t\tnpages = (end - addr) >> PAGE_SHIFT;\n\t\tpfns = &range->pfns[i];\n\n\t\thmm_range_need_fault(hmm_vma_walk, pfns, npages,\n\t\t\t\t     0, &fault, &write_fault);\n\t\tif (fault || write_fault) {\n\t\t\thmm_vma_walk->last = addr;\n\t\t\tpmd_migration_entry_wait(vma->vm_mm, pmdp);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\treturn 0;\n\t} else if (!pmd_present(pmd))\n\t\treturn hmm_pfns_bad(start, end, walk);\n\n\tif (pmd_devmap(pmd) || pmd_trans_huge(pmd)) {\n\t\t/*\n\t\t * No need to take pmd_lock here, even if some other threads\n\t\t * is splitting the huge pmd we will get that event through\n\t\t * mmu_notifier callback.\n\t\t *\n\t\t * So just read pmd value and check again its a transparent\n\t\t * huge or device mapping one and compute corresponding pfn\n\t\t * values.\n\t\t */\n\t\tpmd = pmd_read_atomic(pmdp);\n\t\tbarrier();\n\t\tif (!pmd_devmap(pmd) && !pmd_trans_huge(pmd))\n\t\t\tgoto again;\n\n\t\ti = (addr - range->start) >> PAGE_SHIFT;\n\t\treturn hmm_vma_handle_pmd(walk, addr, end, &pfns[i], pmd);\n\t}\n\n\t/*\n\t * We have handled all the valid case above ie either none, migration,\n\t * huge or transparent huge. At this point either it is a valid pmd\n\t * entry pointing to pte directory or it is a bad pmd that will not\n\t * recover.\n\t */\n\tif (pmd_bad(pmd))\n\t\treturn hmm_pfns_bad(start, end, walk);\n\n\tptep = pte_offset_map(pmdp, addr);\n\ti = (addr - range->start) >> PAGE_SHIFT;\n\tfor (; addr < end; addr += PAGE_SIZE, ptep++, i++) {\n\t\tint r;\n\n\t\tr = hmm_vma_handle_pte(walk, addr, end, pmdp, ptep, &pfns[i]);\n\t\tif (r) {\n\t\t\t/* hmm_vma_handle_pte() did unmap pte directory */\n\t\t\thmm_vma_walk->last = addr;\n\t\t\treturn r;\n\t\t}\n\t}\n\tpte_unmap(ptep - 1);\n\n\thmm_vma_walk->last = addr;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_unmap",
          "args": [
            "ptep - 1"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hmm_vma_handle_pte",
          "args": [
            "walk",
            "addr",
            "end",
            "pmdp",
            "ptep",
            "&pfns[i]"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "hmm_vma_handle_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
          "lines": "509-585",
          "snippet": "static int hmm_vma_handle_pte(struct mm_walk *walk, unsigned long addr,\n\t\t\t      unsigned long end, pmd_t *pmdp, pte_t *ptep,\n\t\t\t      uint64_t *pfn)\n{\n\tstruct hmm_vma_walk *hmm_vma_walk = walk->private;\n\tstruct hmm_range *range = hmm_vma_walk->range;\n\tstruct vm_area_struct *vma = walk->vma;\n\tbool fault, write_fault;\n\tuint64_t cpu_flags;\n\tpte_t pte = *ptep;\n\tuint64_t orig_pfn = *pfn;\n\n\t*pfn = range->values[HMM_PFN_NONE];\n\tcpu_flags = pte_to_hmm_pfn_flags(range, pte);\n\thmm_pte_need_fault(hmm_vma_walk, orig_pfn, cpu_flags,\n\t\t\t   &fault, &write_fault);\n\n\tif (pte_none(pte)) {\n\t\tif (fault || write_fault)\n\t\t\tgoto fault;\n\t\treturn 0;\n\t}\n\n\tif (!pte_present(pte)) {\n\t\tswp_entry_t entry = pte_to_swp_entry(pte);\n\n\t\tif (!non_swap_entry(entry)) {\n\t\t\tif (fault || write_fault)\n\t\t\t\tgoto fault;\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * This is a special swap entry, ignore migration, use\n\t\t * device and report anything else as error.\n\t\t */\n\t\tif (is_device_private_entry(entry)) {\n\t\t\tcpu_flags = range->flags[HMM_PFN_VALID] |\n\t\t\t\trange->flags[HMM_PFN_DEVICE_PRIVATE];\n\t\t\tcpu_flags |= is_write_device_private_entry(entry) ?\n\t\t\t\trange->flags[HMM_PFN_WRITE] : 0;\n\t\t\thmm_pte_need_fault(hmm_vma_walk, orig_pfn, cpu_flags,\n\t\t\t\t\t   &fault, &write_fault);\n\t\t\tif (fault || write_fault)\n\t\t\t\tgoto fault;\n\t\t\t*pfn = hmm_pfn_from_pfn(range, swp_offset(entry));\n\t\t\t*pfn |= cpu_flags;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (is_migration_entry(entry)) {\n\t\t\tif (fault || write_fault) {\n\t\t\t\tpte_unmap(ptep);\n\t\t\t\thmm_vma_walk->last = addr;\n\t\t\t\tmigration_entry_wait(vma->vm_mm,\n\t\t\t\t\t\t     pmdp, addr);\n\t\t\t\treturn -EAGAIN;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* Report error for everything else */\n\t\t*pfn = range->values[HMM_PFN_ERROR];\n\t\treturn -EFAULT;\n\t}\n\n\tif (fault || write_fault)\n\t\tgoto fault;\n\n\t*pfn = hmm_pfn_from_pfn(range, pte_pfn(pte)) | cpu_flags;\n\treturn 0;\n\nfault:\n\tpte_unmap(ptep);\n\t/* Fault any virtual address we were asked to fault */\n\treturn hmm_vma_walk_hole_(addr, end, fault, write_fault, walk);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/memremap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/init.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic int hmm_vma_handle_pte(struct mm_walk *walk, unsigned long addr,\n\t\t\t      unsigned long end, pmd_t *pmdp, pte_t *ptep,\n\t\t\t      uint64_t *pfn)\n{\n\tstruct hmm_vma_walk *hmm_vma_walk = walk->private;\n\tstruct hmm_range *range = hmm_vma_walk->range;\n\tstruct vm_area_struct *vma = walk->vma;\n\tbool fault, write_fault;\n\tuint64_t cpu_flags;\n\tpte_t pte = *ptep;\n\tuint64_t orig_pfn = *pfn;\n\n\t*pfn = range->values[HMM_PFN_NONE];\n\tcpu_flags = pte_to_hmm_pfn_flags(range, pte);\n\thmm_pte_need_fault(hmm_vma_walk, orig_pfn, cpu_flags,\n\t\t\t   &fault, &write_fault);\n\n\tif (pte_none(pte)) {\n\t\tif (fault || write_fault)\n\t\t\tgoto fault;\n\t\treturn 0;\n\t}\n\n\tif (!pte_present(pte)) {\n\t\tswp_entry_t entry = pte_to_swp_entry(pte);\n\n\t\tif (!non_swap_entry(entry)) {\n\t\t\tif (fault || write_fault)\n\t\t\t\tgoto fault;\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * This is a special swap entry, ignore migration, use\n\t\t * device and report anything else as error.\n\t\t */\n\t\tif (is_device_private_entry(entry)) {\n\t\t\tcpu_flags = range->flags[HMM_PFN_VALID] |\n\t\t\t\trange->flags[HMM_PFN_DEVICE_PRIVATE];\n\t\t\tcpu_flags |= is_write_device_private_entry(entry) ?\n\t\t\t\trange->flags[HMM_PFN_WRITE] : 0;\n\t\t\thmm_pte_need_fault(hmm_vma_walk, orig_pfn, cpu_flags,\n\t\t\t\t\t   &fault, &write_fault);\n\t\t\tif (fault || write_fault)\n\t\t\t\tgoto fault;\n\t\t\t*pfn = hmm_pfn_from_pfn(range, swp_offset(entry));\n\t\t\t*pfn |= cpu_flags;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (is_migration_entry(entry)) {\n\t\t\tif (fault || write_fault) {\n\t\t\t\tpte_unmap(ptep);\n\t\t\t\thmm_vma_walk->last = addr;\n\t\t\t\tmigration_entry_wait(vma->vm_mm,\n\t\t\t\t\t\t     pmdp, addr);\n\t\t\t\treturn -EAGAIN;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* Report error for everything else */\n\t\t*pfn = range->values[HMM_PFN_ERROR];\n\t\treturn -EFAULT;\n\t}\n\n\tif (fault || write_fault)\n\t\tgoto fault;\n\n\t*pfn = hmm_pfn_from_pfn(range, pte_pfn(pte)) | cpu_flags;\n\treturn 0;\n\nfault:\n\tpte_unmap(ptep);\n\t/* Fault any virtual address we were asked to fault */\n\treturn hmm_vma_walk_hole_(addr, end, fault, write_fault, walk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_offset_map",
          "args": [
            "pmdp",
            "addr"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hmm_pfns_bad",
          "args": [
            "start",
            "end",
            "walk"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "hmm_pfns_bad",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
          "lines": "340-354",
          "snippet": "static int hmm_pfns_bad(unsigned long addr,\n\t\t\tunsigned long end,\n\t\t\tstruct mm_walk *walk)\n{\n\tstruct hmm_vma_walk *hmm_vma_walk = walk->private;\n\tstruct hmm_range *range = hmm_vma_walk->range;\n\tuint64_t *pfns = range->pfns;\n\tunsigned long i;\n\n\ti = (addr - range->start) >> PAGE_SHIFT;\n\tfor (; addr < end; addr += PAGE_SIZE, i++)\n\t\tpfns[i] = range->values[HMM_PFN_ERROR];\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/memremap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/init.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic int hmm_pfns_bad(unsigned long addr,\n\t\t\tunsigned long end,\n\t\t\tstruct mm_walk *walk)\n{\n\tstruct hmm_vma_walk *hmm_vma_walk = walk->private;\n\tstruct hmm_range *range = hmm_vma_walk->range;\n\tuint64_t *pfns = range->pfns;\n\tunsigned long i;\n\n\ti = (addr - range->start) >> PAGE_SHIFT;\n\tfor (; addr < end; addr += PAGE_SIZE, i++)\n\t\tpfns[i] = range->values[HMM_PFN_ERROR];\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_bad",
          "args": [
            "pmd"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hmm_vma_handle_pmd",
          "args": [
            "walk",
            "addr",
            "end",
            "&pfns[i]",
            "pmd"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "hmm_vma_handle_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
          "lines": "473-498",
          "snippet": "static int hmm_vma_handle_pmd(struct mm_walk *walk,\n\t\t\t      unsigned long addr,\n\t\t\t      unsigned long end,\n\t\t\t      uint64_t *pfns,\n\t\t\t      pmd_t pmd)\n{\n\tstruct hmm_vma_walk *hmm_vma_walk = walk->private;\n\tstruct hmm_range *range = hmm_vma_walk->range;\n\tunsigned long pfn, npages, i;\n\tbool fault, write_fault;\n\tuint64_t cpu_flags;\n\n\tnpages = (end - addr) >> PAGE_SHIFT;\n\tcpu_flags = pmd_to_hmm_pfn_flags(range, pmd);\n\thmm_range_need_fault(hmm_vma_walk, pfns, npages, cpu_flags,\n\t\t\t     &fault, &write_fault);\n\n\tif (pmd_protnone(pmd) || fault || write_fault)\n\t\treturn hmm_vma_walk_hole_(addr, end, fault, write_fault, walk);\n\n\tpfn = pmd_pfn(pmd) + pte_index(addr);\n\tfor (i = 0; addr < end; addr += PAGE_SIZE, i++, pfn++)\n\t\tpfns[i] = hmm_pfn_from_pfn(range, pfn) | cpu_flags;\n\thmm_vma_walk->last = end;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/memremap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/init.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic int hmm_vma_handle_pmd(struct mm_walk *walk,\n\t\t\t      unsigned long addr,\n\t\t\t      unsigned long end,\n\t\t\t      uint64_t *pfns,\n\t\t\t      pmd_t pmd)\n{\n\tstruct hmm_vma_walk *hmm_vma_walk = walk->private;\n\tstruct hmm_range *range = hmm_vma_walk->range;\n\tunsigned long pfn, npages, i;\n\tbool fault, write_fault;\n\tuint64_t cpu_flags;\n\n\tnpages = (end - addr) >> PAGE_SHIFT;\n\tcpu_flags = pmd_to_hmm_pfn_flags(range, pmd);\n\thmm_range_need_fault(hmm_vma_walk, pfns, npages, cpu_flags,\n\t\t\t     &fault, &write_fault);\n\n\tif (pmd_protnone(pmd) || fault || write_fault)\n\t\treturn hmm_vma_walk_hole_(addr, end, fault, write_fault, walk);\n\n\tpfn = pmd_pfn(pmd) + pte_index(addr);\n\tfor (i = 0; addr < end; addr += PAGE_SIZE, i++, pfn++)\n\t\tpfns[i] = hmm_pfn_from_pfn(range, pfn) | cpu_flags;\n\thmm_vma_walk->last = end;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_trans_huge",
          "args": [
            "pmd"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_devmap",
          "args": [
            "pmd"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "pmd_devmap_trans_unstable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3023-3026",
          "snippet": "static int pmd_devmap_trans_unstable(pmd_t *pmd)\n{\n\treturn pmd_devmap(*pmd) || pmd_trans_unstable(pmd);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic int pmd_devmap_trans_unstable(pmd_t *pmd)\n{\n\treturn pmd_devmap(*pmd) || pmd_trans_unstable(pmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_read_atomic",
          "args": [
            "pmdp"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_trans_huge",
          "args": [
            "pmd"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_present",
          "args": [
            "pmd"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_migration_entry_wait",
          "args": [
            "vma->vm_mm",
            "pmdp"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "pmd_migration_entry_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "361-378",
          "snippet": "void pmd_migration_entry_wait(struct mm_struct *mm, pmd_t *pmd)\n{\n\tspinlock_t *ptl;\n\tstruct page *page;\n\n\tptl = pmd_lock(mm, pmd);\n\tif (!is_pmd_migration_entry(*pmd))\n\t\tgoto unlock;\n\tpage = migration_entry_to_page(pmd_to_swp_entry(*pmd));\n\tif (!get_page_unless_zero(page))\n\t\tgoto unlock;\n\tspin_unlock(ptl);\n\twait_on_page_locked(page);\n\tput_page(page);\n\treturn;\nunlock:\n\tspin_unlock(ptl);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nvoid pmd_migration_entry_wait(struct mm_struct *mm, pmd_t *pmd)\n{\n\tspinlock_t *ptl;\n\tstruct page *page;\n\n\tptl = pmd_lock(mm, pmd);\n\tif (!is_pmd_migration_entry(*pmd))\n\t\tgoto unlock;\n\tpage = migration_entry_to_page(pmd_to_swp_entry(*pmd));\n\tif (!get_page_unless_zero(page))\n\t\tgoto unlock;\n\tspin_unlock(ptl);\n\twait_on_page_locked(page);\n\tput_page(page);\n\treturn;\nunlock:\n\tspin_unlock(ptl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hmm_range_need_fault",
          "args": [
            "hmm_vma_walk",
            "pfns",
            "npages",
            "0",
            "&fault",
            "&write_fault"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "hmm_range_need_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
          "lines": "427-445",
          "snippet": "static void hmm_range_need_fault(const struct hmm_vma_walk *hmm_vma_walk,\n\t\t\t\t const uint64_t *pfns, unsigned long npages,\n\t\t\t\t uint64_t cpu_flags, bool *fault,\n\t\t\t\t bool *write_fault)\n{\n\tunsigned long i;\n\n\tif (!hmm_vma_walk->fault) {\n\t\t*fault = *write_fault = false;\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < npages; ++i) {\n\t\thmm_pte_need_fault(hmm_vma_walk, pfns[i], cpu_flags,\n\t\t\t\t   fault, write_fault);\n\t\tif ((*fault) || (*write_fault))\n\t\t\treturn;\n\t}\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/memremap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/init.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic void hmm_range_need_fault(const struct hmm_vma_walk *hmm_vma_walk,\n\t\t\t\t const uint64_t *pfns, unsigned long npages,\n\t\t\t\t uint64_t cpu_flags, bool *fault,\n\t\t\t\t bool *write_fault)\n{\n\tunsigned long i;\n\n\tif (!hmm_vma_walk->fault) {\n\t\t*fault = *write_fault = false;\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < npages; ++i) {\n\t\thmm_pte_need_fault(hmm_vma_walk, pfns[i], cpu_flags,\n\t\t\t\t   fault, write_fault);\n\t\tif ((*fault) || (*write_fault))\n\t\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_pmd_migration_entry",
          "args": [
            "pmd"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thp_migration_supported",
          "args": [],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_huge",
          "args": [
            "pmd"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hmm_vma_walk_hole",
          "args": [
            "start",
            "end",
            "walk"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "hmm_vma_walk_hole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
          "lines": "447-462",
          "snippet": "static int hmm_vma_walk_hole(unsigned long addr, unsigned long end,\n\t\t\t     struct mm_walk *walk)\n{\n\tstruct hmm_vma_walk *hmm_vma_walk = walk->private;\n\tstruct hmm_range *range = hmm_vma_walk->range;\n\tbool fault, write_fault;\n\tunsigned long i, npages;\n\tuint64_t *pfns;\n\n\ti = (addr - range->start) >> PAGE_SHIFT;\n\tnpages = (end - addr) >> PAGE_SHIFT;\n\tpfns = &range->pfns[i];\n\thmm_range_need_fault(hmm_vma_walk, pfns, npages,\n\t\t\t     0, &fault, &write_fault);\n\treturn hmm_vma_walk_hole_(addr, end, fault, write_fault, walk);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/memremap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/init.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic int hmm_vma_walk_hole(unsigned long addr, unsigned long end,\n\t\t\t     struct mm_walk *walk)\n{\n\tstruct hmm_vma_walk *hmm_vma_walk = walk->private;\n\tstruct hmm_range *range = hmm_vma_walk->range;\n\tbool fault, write_fault;\n\tunsigned long i, npages;\n\tuint64_t *pfns;\n\n\ti = (addr - range->start) >> PAGE_SHIFT;\n\tnpages = (end - addr) >> PAGE_SHIFT;\n\tpfns = &range->pfns[i];\n\thmm_range_need_fault(hmm_vma_walk, pfns, npages,\n\t\t\t     0, &fault, &write_fault);\n\treturn hmm_vma_walk_hole_(addr, end, fault, write_fault, walk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_none",
          "args": [
            "pmd"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*pmdp"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic int hmm_vma_walk_pmd(pmd_t *pmdp,\n\t\t\t    unsigned long start,\n\t\t\t    unsigned long end,\n\t\t\t    struct mm_walk *walk)\n{\n\tstruct hmm_vma_walk *hmm_vma_walk = walk->private;\n\tstruct hmm_range *range = hmm_vma_walk->range;\n\tstruct vm_area_struct *vma = walk->vma;\n\tuint64_t *pfns = range->pfns;\n\tunsigned long addr = start, i;\n\tpte_t *ptep;\n\tpmd_t pmd;\n\n\nagain:\n\tpmd = READ_ONCE(*pmdp);\n\tif (pmd_none(pmd))\n\t\treturn hmm_vma_walk_hole(start, end, walk);\n\n\tif (pmd_huge(pmd) && (range->vma->vm_flags & VM_HUGETLB))\n\t\treturn hmm_pfns_bad(start, end, walk);\n\n\tif (thp_migration_supported() && is_pmd_migration_entry(pmd)) {\n\t\tbool fault, write_fault;\n\t\tunsigned long npages;\n\t\tuint64_t *pfns;\n\n\t\ti = (addr - range->start) >> PAGE_SHIFT;\n\t\tnpages = (end - addr) >> PAGE_SHIFT;\n\t\tpfns = &range->pfns[i];\n\n\t\thmm_range_need_fault(hmm_vma_walk, pfns, npages,\n\t\t\t\t     0, &fault, &write_fault);\n\t\tif (fault || write_fault) {\n\t\t\thmm_vma_walk->last = addr;\n\t\t\tpmd_migration_entry_wait(vma->vm_mm, pmdp);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\treturn 0;\n\t} else if (!pmd_present(pmd))\n\t\treturn hmm_pfns_bad(start, end, walk);\n\n\tif (pmd_devmap(pmd) || pmd_trans_huge(pmd)) {\n\t\t/*\n\t\t * No need to take pmd_lock here, even if some other threads\n\t\t * is splitting the huge pmd we will get that event through\n\t\t * mmu_notifier callback.\n\t\t *\n\t\t * So just read pmd value and check again its a transparent\n\t\t * huge or device mapping one and compute corresponding pfn\n\t\t * values.\n\t\t */\n\t\tpmd = pmd_read_atomic(pmdp);\n\t\tbarrier();\n\t\tif (!pmd_devmap(pmd) && !pmd_trans_huge(pmd))\n\t\t\tgoto again;\n\n\t\ti = (addr - range->start) >> PAGE_SHIFT;\n\t\treturn hmm_vma_handle_pmd(walk, addr, end, &pfns[i], pmd);\n\t}\n\n\t/*\n\t * We have handled all the valid case above ie either none, migration,\n\t * huge or transparent huge. At this point either it is a valid pmd\n\t * entry pointing to pte directory or it is a bad pmd that will not\n\t * recover.\n\t */\n\tif (pmd_bad(pmd))\n\t\treturn hmm_pfns_bad(start, end, walk);\n\n\tptep = pte_offset_map(pmdp, addr);\n\ti = (addr - range->start) >> PAGE_SHIFT;\n\tfor (; addr < end; addr += PAGE_SIZE, ptep++, i++) {\n\t\tint r;\n\n\t\tr = hmm_vma_handle_pte(walk, addr, end, pmdp, ptep, &pfns[i]);\n\t\tif (r) {\n\t\t\t/* hmm_vma_handle_pte() did unmap pte directory */\n\t\t\thmm_vma_walk->last = addr;\n\t\t\treturn r;\n\t\t}\n\t}\n\tpte_unmap(ptep - 1);\n\n\thmm_vma_walk->last = addr;\n\treturn 0;\n}"
  },
  {
    "function_name": "hmm_vma_handle_pte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "509-585",
    "snippet": "static int hmm_vma_handle_pte(struct mm_walk *walk, unsigned long addr,\n\t\t\t      unsigned long end, pmd_t *pmdp, pte_t *ptep,\n\t\t\t      uint64_t *pfn)\n{\n\tstruct hmm_vma_walk *hmm_vma_walk = walk->private;\n\tstruct hmm_range *range = hmm_vma_walk->range;\n\tstruct vm_area_struct *vma = walk->vma;\n\tbool fault, write_fault;\n\tuint64_t cpu_flags;\n\tpte_t pte = *ptep;\n\tuint64_t orig_pfn = *pfn;\n\n\t*pfn = range->values[HMM_PFN_NONE];\n\tcpu_flags = pte_to_hmm_pfn_flags(range, pte);\n\thmm_pte_need_fault(hmm_vma_walk, orig_pfn, cpu_flags,\n\t\t\t   &fault, &write_fault);\n\n\tif (pte_none(pte)) {\n\t\tif (fault || write_fault)\n\t\t\tgoto fault;\n\t\treturn 0;\n\t}\n\n\tif (!pte_present(pte)) {\n\t\tswp_entry_t entry = pte_to_swp_entry(pte);\n\n\t\tif (!non_swap_entry(entry)) {\n\t\t\tif (fault || write_fault)\n\t\t\t\tgoto fault;\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * This is a special swap entry, ignore migration, use\n\t\t * device and report anything else as error.\n\t\t */\n\t\tif (is_device_private_entry(entry)) {\n\t\t\tcpu_flags = range->flags[HMM_PFN_VALID] |\n\t\t\t\trange->flags[HMM_PFN_DEVICE_PRIVATE];\n\t\t\tcpu_flags |= is_write_device_private_entry(entry) ?\n\t\t\t\trange->flags[HMM_PFN_WRITE] : 0;\n\t\t\thmm_pte_need_fault(hmm_vma_walk, orig_pfn, cpu_flags,\n\t\t\t\t\t   &fault, &write_fault);\n\t\t\tif (fault || write_fault)\n\t\t\t\tgoto fault;\n\t\t\t*pfn = hmm_pfn_from_pfn(range, swp_offset(entry));\n\t\t\t*pfn |= cpu_flags;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (is_migration_entry(entry)) {\n\t\t\tif (fault || write_fault) {\n\t\t\t\tpte_unmap(ptep);\n\t\t\t\thmm_vma_walk->last = addr;\n\t\t\t\tmigration_entry_wait(vma->vm_mm,\n\t\t\t\t\t\t     pmdp, addr);\n\t\t\t\treturn -EAGAIN;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* Report error for everything else */\n\t\t*pfn = range->values[HMM_PFN_ERROR];\n\t\treturn -EFAULT;\n\t}\n\n\tif (fault || write_fault)\n\t\tgoto fault;\n\n\t*pfn = hmm_pfn_from_pfn(range, pte_pfn(pte)) | cpu_flags;\n\treturn 0;\n\nfault:\n\tpte_unmap(ptep);\n\t/* Fault any virtual address we were asked to fault */\n\treturn hmm_vma_walk_hole_(addr, end, fault, write_fault, walk);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hmm_vma_walk_hole_",
          "args": [
            "addr",
            "end",
            "fault",
            "write_fault",
            "walk"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "hmm_vma_walk_hole_",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
          "lines": "368-392",
          "snippet": "static int hmm_vma_walk_hole_(unsigned long addr, unsigned long end,\n\t\t\t      bool fault, bool write_fault,\n\t\t\t      struct mm_walk *walk)\n{\n\tstruct hmm_vma_walk *hmm_vma_walk = walk->private;\n\tstruct hmm_range *range = hmm_vma_walk->range;\n\tuint64_t *pfns = range->pfns;\n\tunsigned long i;\n\n\thmm_vma_walk->last = addr;\n\ti = (addr - range->start) >> PAGE_SHIFT;\n\tfor (; addr < end; addr += PAGE_SIZE, i++) {\n\t\tpfns[i] = range->values[HMM_PFN_NONE];\n\t\tif (fault || write_fault) {\n\t\t\tint ret;\n\n\t\t\tret = hmm_vma_do_fault(walk, addr, write_fault,\n\t\t\t\t\t       &pfns[i]);\n\t\t\tif (ret != -EAGAIN)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn (fault || write_fault) ? -EAGAIN : 0;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/memremap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/init.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic int hmm_vma_walk_hole_(unsigned long addr, unsigned long end,\n\t\t\t      bool fault, bool write_fault,\n\t\t\t      struct mm_walk *walk)\n{\n\tstruct hmm_vma_walk *hmm_vma_walk = walk->private;\n\tstruct hmm_range *range = hmm_vma_walk->range;\n\tuint64_t *pfns = range->pfns;\n\tunsigned long i;\n\n\thmm_vma_walk->last = addr;\n\ti = (addr - range->start) >> PAGE_SHIFT;\n\tfor (; addr < end; addr += PAGE_SIZE, i++) {\n\t\tpfns[i] = range->values[HMM_PFN_NONE];\n\t\tif (fault || write_fault) {\n\t\t\tint ret;\n\n\t\t\tret = hmm_vma_do_fault(walk, addr, write_fault,\n\t\t\t\t\t       &pfns[i]);\n\t\t\tif (ret != -EAGAIN)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn (fault || write_fault) ? -EAGAIN : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_unmap",
          "args": [
            "ptep"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hmm_pfn_from_pfn",
          "args": [
            "range",
            "pte_pfn(pte)"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_pfn",
          "args": [
            "pte"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migration_entry_wait",
          "args": [
            "vma->vm_mm",
            "pmdp",
            "addr"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "migration_entry_wait_huge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "353-358",
          "snippet": "void migration_entry_wait_huge(struct vm_area_struct *vma,\n\t\tstruct mm_struct *mm, pte_t *pte)\n{\n\tspinlock_t *ptl = huge_pte_lockptr(hstate_vma(vma), mm, pte);\n\t__migration_entry_wait(mm, pte, ptl);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nvoid migration_entry_wait_huge(struct vm_area_struct *vma,\n\t\tstruct mm_struct *mm, pte_t *pte)\n{\n\tspinlock_t *ptl = huge_pte_lockptr(hstate_vma(vma), mm, pte);\n\t__migration_entry_wait(mm, pte, ptl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_unmap",
          "args": [
            "ptep"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_migration_entry",
          "args": [
            "entry"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hmm_pfn_from_pfn",
          "args": [
            "range",
            "swp_offset(entry)"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swp_offset",
          "args": [
            "entry"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hmm_pte_need_fault",
          "args": [
            "hmm_vma_walk",
            "orig_pfn",
            "cpu_flags",
            "&fault",
            "&write_fault"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "hmm_pte_need_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
          "lines": "394-425",
          "snippet": "static inline void hmm_pte_need_fault(const struct hmm_vma_walk *hmm_vma_walk,\n\t\t\t\t      uint64_t pfns, uint64_t cpu_flags,\n\t\t\t\t      bool *fault, bool *write_fault)\n{\n\tstruct hmm_range *range = hmm_vma_walk->range;\n\n\t*fault = *write_fault = false;\n\tif (!hmm_vma_walk->fault)\n\t\treturn;\n\n\t/* We aren't ask to do anything ... */\n\tif (!(pfns & range->flags[HMM_PFN_VALID]))\n\t\treturn;\n\t/* If this is device memory than only fault if explicitly requested */\n\tif ((cpu_flags & range->flags[HMM_PFN_DEVICE_PRIVATE])) {\n\t\t/* Do we fault on device memory ? */\n\t\tif (pfns & range->flags[HMM_PFN_DEVICE_PRIVATE]) {\n\t\t\t*write_fault = pfns & range->flags[HMM_PFN_WRITE];\n\t\t\t*fault = true;\n\t\t}\n\t\treturn;\n\t}\n\n\t/* If CPU page table is not valid then we need to fault */\n\t*fault = !(cpu_flags & range->flags[HMM_PFN_VALID]);\n\t/* Need to write fault ? */\n\tif ((pfns & range->flags[HMM_PFN_WRITE]) &&\n\t    !(cpu_flags & range->flags[HMM_PFN_WRITE])) {\n\t\t*write_fault = true;\n\t\t*fault = true;\n\t}\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/memremap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/init.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic inline void hmm_pte_need_fault(const struct hmm_vma_walk *hmm_vma_walk,\n\t\t\t\t      uint64_t pfns, uint64_t cpu_flags,\n\t\t\t\t      bool *fault, bool *write_fault)\n{\n\tstruct hmm_range *range = hmm_vma_walk->range;\n\n\t*fault = *write_fault = false;\n\tif (!hmm_vma_walk->fault)\n\t\treturn;\n\n\t/* We aren't ask to do anything ... */\n\tif (!(pfns & range->flags[HMM_PFN_VALID]))\n\t\treturn;\n\t/* If this is device memory than only fault if explicitly requested */\n\tif ((cpu_flags & range->flags[HMM_PFN_DEVICE_PRIVATE])) {\n\t\t/* Do we fault on device memory ? */\n\t\tif (pfns & range->flags[HMM_PFN_DEVICE_PRIVATE]) {\n\t\t\t*write_fault = pfns & range->flags[HMM_PFN_WRITE];\n\t\t\t*fault = true;\n\t\t}\n\t\treturn;\n\t}\n\n\t/* If CPU page table is not valid then we need to fault */\n\t*fault = !(cpu_flags & range->flags[HMM_PFN_VALID]);\n\t/* Need to write fault ? */\n\tif ((pfns & range->flags[HMM_PFN_WRITE]) &&\n\t    !(cpu_flags & range->flags[HMM_PFN_WRITE])) {\n\t\t*write_fault = true;\n\t\t*fault = true;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_write_device_private_entry",
          "args": [
            "entry"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_device_private_entry",
          "args": [
            "entry"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "non_swap_entry",
          "args": [
            "entry"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_to_swp_entry",
          "args": [
            "pte"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "pte"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_none",
          "args": [
            "pte"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_to_hmm_pfn_flags",
          "args": [
            "range",
            "pte"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "pte_to_hmm_pfn_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
          "lines": "500-507",
          "snippet": "static inline uint64_t pte_to_hmm_pfn_flags(struct hmm_range *range, pte_t pte)\n{\n\tif (pte_none(pte) || !pte_present(pte))\n\t\treturn 0;\n\treturn pte_write(pte) ? range->flags[HMM_PFN_VALID] |\n\t\t\t\trange->flags[HMM_PFN_WRITE] :\n\t\t\t\trange->flags[HMM_PFN_VALID];\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/memremap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/init.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic inline uint64_t pte_to_hmm_pfn_flags(struct hmm_range *range, pte_t pte)\n{\n\tif (pte_none(pte) || !pte_present(pte))\n\t\treturn 0;\n\treturn pte_write(pte) ? range->flags[HMM_PFN_VALID] |\n\t\t\t\trange->flags[HMM_PFN_WRITE] :\n\t\t\t\trange->flags[HMM_PFN_VALID];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic int hmm_vma_handle_pte(struct mm_walk *walk, unsigned long addr,\n\t\t\t      unsigned long end, pmd_t *pmdp, pte_t *ptep,\n\t\t\t      uint64_t *pfn)\n{\n\tstruct hmm_vma_walk *hmm_vma_walk = walk->private;\n\tstruct hmm_range *range = hmm_vma_walk->range;\n\tstruct vm_area_struct *vma = walk->vma;\n\tbool fault, write_fault;\n\tuint64_t cpu_flags;\n\tpte_t pte = *ptep;\n\tuint64_t orig_pfn = *pfn;\n\n\t*pfn = range->values[HMM_PFN_NONE];\n\tcpu_flags = pte_to_hmm_pfn_flags(range, pte);\n\thmm_pte_need_fault(hmm_vma_walk, orig_pfn, cpu_flags,\n\t\t\t   &fault, &write_fault);\n\n\tif (pte_none(pte)) {\n\t\tif (fault || write_fault)\n\t\t\tgoto fault;\n\t\treturn 0;\n\t}\n\n\tif (!pte_present(pte)) {\n\t\tswp_entry_t entry = pte_to_swp_entry(pte);\n\n\t\tif (!non_swap_entry(entry)) {\n\t\t\tif (fault || write_fault)\n\t\t\t\tgoto fault;\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * This is a special swap entry, ignore migration, use\n\t\t * device and report anything else as error.\n\t\t */\n\t\tif (is_device_private_entry(entry)) {\n\t\t\tcpu_flags = range->flags[HMM_PFN_VALID] |\n\t\t\t\trange->flags[HMM_PFN_DEVICE_PRIVATE];\n\t\t\tcpu_flags |= is_write_device_private_entry(entry) ?\n\t\t\t\trange->flags[HMM_PFN_WRITE] : 0;\n\t\t\thmm_pte_need_fault(hmm_vma_walk, orig_pfn, cpu_flags,\n\t\t\t\t\t   &fault, &write_fault);\n\t\t\tif (fault || write_fault)\n\t\t\t\tgoto fault;\n\t\t\t*pfn = hmm_pfn_from_pfn(range, swp_offset(entry));\n\t\t\t*pfn |= cpu_flags;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (is_migration_entry(entry)) {\n\t\t\tif (fault || write_fault) {\n\t\t\t\tpte_unmap(ptep);\n\t\t\t\thmm_vma_walk->last = addr;\n\t\t\t\tmigration_entry_wait(vma->vm_mm,\n\t\t\t\t\t\t     pmdp, addr);\n\t\t\t\treturn -EAGAIN;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* Report error for everything else */\n\t\t*pfn = range->values[HMM_PFN_ERROR];\n\t\treturn -EFAULT;\n\t}\n\n\tif (fault || write_fault)\n\t\tgoto fault;\n\n\t*pfn = hmm_pfn_from_pfn(range, pte_pfn(pte)) | cpu_flags;\n\treturn 0;\n\nfault:\n\tpte_unmap(ptep);\n\t/* Fault any virtual address we were asked to fault */\n\treturn hmm_vma_walk_hole_(addr, end, fault, write_fault, walk);\n}"
  },
  {
    "function_name": "pte_to_hmm_pfn_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "500-507",
    "snippet": "static inline uint64_t pte_to_hmm_pfn_flags(struct hmm_range *range, pte_t pte)\n{\n\tif (pte_none(pte) || !pte_present(pte))\n\t\treturn 0;\n\treturn pte_write(pte) ? range->flags[HMM_PFN_VALID] |\n\t\t\t\trange->flags[HMM_PFN_WRITE] :\n\t\t\t\trange->flags[HMM_PFN_VALID];\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_write",
          "args": [
            "pte"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "pte"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_none",
          "args": [
            "pte"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic inline uint64_t pte_to_hmm_pfn_flags(struct hmm_range *range, pte_t pte)\n{\n\tif (pte_none(pte) || !pte_present(pte))\n\t\treturn 0;\n\treturn pte_write(pte) ? range->flags[HMM_PFN_VALID] |\n\t\t\t\trange->flags[HMM_PFN_WRITE] :\n\t\t\t\trange->flags[HMM_PFN_VALID];\n}"
  },
  {
    "function_name": "hmm_vma_handle_pmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "473-498",
    "snippet": "static int hmm_vma_handle_pmd(struct mm_walk *walk,\n\t\t\t      unsigned long addr,\n\t\t\t      unsigned long end,\n\t\t\t      uint64_t *pfns,\n\t\t\t      pmd_t pmd)\n{\n\tstruct hmm_vma_walk *hmm_vma_walk = walk->private;\n\tstruct hmm_range *range = hmm_vma_walk->range;\n\tunsigned long pfn, npages, i;\n\tbool fault, write_fault;\n\tuint64_t cpu_flags;\n\n\tnpages = (end - addr) >> PAGE_SHIFT;\n\tcpu_flags = pmd_to_hmm_pfn_flags(range, pmd);\n\thmm_range_need_fault(hmm_vma_walk, pfns, npages, cpu_flags,\n\t\t\t     &fault, &write_fault);\n\n\tif (pmd_protnone(pmd) || fault || write_fault)\n\t\treturn hmm_vma_walk_hole_(addr, end, fault, write_fault, walk);\n\n\tpfn = pmd_pfn(pmd) + pte_index(addr);\n\tfor (i = 0; addr < end; addr += PAGE_SIZE, i++, pfn++)\n\t\tpfns[i] = hmm_pfn_from_pfn(range, pfn) | cpu_flags;\n\thmm_vma_walk->last = end;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hmm_pfn_from_pfn",
          "args": [
            "range",
            "pfn"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_index",
          "args": [
            "addr"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_pfn",
          "args": [
            "pmd"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hmm_vma_walk_hole_",
          "args": [
            "addr",
            "end",
            "fault",
            "write_fault",
            "walk"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "hmm_vma_walk_hole_",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
          "lines": "368-392",
          "snippet": "static int hmm_vma_walk_hole_(unsigned long addr, unsigned long end,\n\t\t\t      bool fault, bool write_fault,\n\t\t\t      struct mm_walk *walk)\n{\n\tstruct hmm_vma_walk *hmm_vma_walk = walk->private;\n\tstruct hmm_range *range = hmm_vma_walk->range;\n\tuint64_t *pfns = range->pfns;\n\tunsigned long i;\n\n\thmm_vma_walk->last = addr;\n\ti = (addr - range->start) >> PAGE_SHIFT;\n\tfor (; addr < end; addr += PAGE_SIZE, i++) {\n\t\tpfns[i] = range->values[HMM_PFN_NONE];\n\t\tif (fault || write_fault) {\n\t\t\tint ret;\n\n\t\t\tret = hmm_vma_do_fault(walk, addr, write_fault,\n\t\t\t\t\t       &pfns[i]);\n\t\t\tif (ret != -EAGAIN)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn (fault || write_fault) ? -EAGAIN : 0;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/memremap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/init.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic int hmm_vma_walk_hole_(unsigned long addr, unsigned long end,\n\t\t\t      bool fault, bool write_fault,\n\t\t\t      struct mm_walk *walk)\n{\n\tstruct hmm_vma_walk *hmm_vma_walk = walk->private;\n\tstruct hmm_range *range = hmm_vma_walk->range;\n\tuint64_t *pfns = range->pfns;\n\tunsigned long i;\n\n\thmm_vma_walk->last = addr;\n\ti = (addr - range->start) >> PAGE_SHIFT;\n\tfor (; addr < end; addr += PAGE_SIZE, i++) {\n\t\tpfns[i] = range->values[HMM_PFN_NONE];\n\t\tif (fault || write_fault) {\n\t\t\tint ret;\n\n\t\t\tret = hmm_vma_do_fault(walk, addr, write_fault,\n\t\t\t\t\t       &pfns[i]);\n\t\t\tif (ret != -EAGAIN)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn (fault || write_fault) ? -EAGAIN : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_protnone",
          "args": [
            "pmd"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hmm_range_need_fault",
          "args": [
            "hmm_vma_walk",
            "pfns",
            "npages",
            "cpu_flags",
            "&fault",
            "&write_fault"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "hmm_range_need_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
          "lines": "427-445",
          "snippet": "static void hmm_range_need_fault(const struct hmm_vma_walk *hmm_vma_walk,\n\t\t\t\t const uint64_t *pfns, unsigned long npages,\n\t\t\t\t uint64_t cpu_flags, bool *fault,\n\t\t\t\t bool *write_fault)\n{\n\tunsigned long i;\n\n\tif (!hmm_vma_walk->fault) {\n\t\t*fault = *write_fault = false;\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < npages; ++i) {\n\t\thmm_pte_need_fault(hmm_vma_walk, pfns[i], cpu_flags,\n\t\t\t\t   fault, write_fault);\n\t\tif ((*fault) || (*write_fault))\n\t\t\treturn;\n\t}\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/memremap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/init.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic void hmm_range_need_fault(const struct hmm_vma_walk *hmm_vma_walk,\n\t\t\t\t const uint64_t *pfns, unsigned long npages,\n\t\t\t\t uint64_t cpu_flags, bool *fault,\n\t\t\t\t bool *write_fault)\n{\n\tunsigned long i;\n\n\tif (!hmm_vma_walk->fault) {\n\t\t*fault = *write_fault = false;\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < npages; ++i) {\n\t\thmm_pte_need_fault(hmm_vma_walk, pfns[i], cpu_flags,\n\t\t\t\t   fault, write_fault);\n\t\tif ((*fault) || (*write_fault))\n\t\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_to_hmm_pfn_flags",
          "args": [
            "range",
            "pmd"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "pmd_to_hmm_pfn_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
          "lines": "464-471",
          "snippet": "static inline uint64_t pmd_to_hmm_pfn_flags(struct hmm_range *range, pmd_t pmd)\n{\n\tif (pmd_protnone(pmd))\n\t\treturn 0;\n\treturn pmd_write(pmd) ? range->flags[HMM_PFN_VALID] |\n\t\t\t\trange->flags[HMM_PFN_WRITE] :\n\t\t\t\trange->flags[HMM_PFN_VALID];\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/memremap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/init.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic inline uint64_t pmd_to_hmm_pfn_flags(struct hmm_range *range, pmd_t pmd)\n{\n\tif (pmd_protnone(pmd))\n\t\treturn 0;\n\treturn pmd_write(pmd) ? range->flags[HMM_PFN_VALID] |\n\t\t\t\trange->flags[HMM_PFN_WRITE] :\n\t\t\t\trange->flags[HMM_PFN_VALID];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic int hmm_vma_handle_pmd(struct mm_walk *walk,\n\t\t\t      unsigned long addr,\n\t\t\t      unsigned long end,\n\t\t\t      uint64_t *pfns,\n\t\t\t      pmd_t pmd)\n{\n\tstruct hmm_vma_walk *hmm_vma_walk = walk->private;\n\tstruct hmm_range *range = hmm_vma_walk->range;\n\tunsigned long pfn, npages, i;\n\tbool fault, write_fault;\n\tuint64_t cpu_flags;\n\n\tnpages = (end - addr) >> PAGE_SHIFT;\n\tcpu_flags = pmd_to_hmm_pfn_flags(range, pmd);\n\thmm_range_need_fault(hmm_vma_walk, pfns, npages, cpu_flags,\n\t\t\t     &fault, &write_fault);\n\n\tif (pmd_protnone(pmd) || fault || write_fault)\n\t\treturn hmm_vma_walk_hole_(addr, end, fault, write_fault, walk);\n\n\tpfn = pmd_pfn(pmd) + pte_index(addr);\n\tfor (i = 0; addr < end; addr += PAGE_SIZE, i++, pfn++)\n\t\tpfns[i] = hmm_pfn_from_pfn(range, pfn) | cpu_flags;\n\thmm_vma_walk->last = end;\n\treturn 0;\n}"
  },
  {
    "function_name": "pmd_to_hmm_pfn_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "464-471",
    "snippet": "static inline uint64_t pmd_to_hmm_pfn_flags(struct hmm_range *range, pmd_t pmd)\n{\n\tif (pmd_protnone(pmd))\n\t\treturn 0;\n\treturn pmd_write(pmd) ? range->flags[HMM_PFN_VALID] |\n\t\t\t\trange->flags[HMM_PFN_WRITE] :\n\t\t\t\trange->flags[HMM_PFN_VALID];\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pmd_write",
          "args": [
            "pmd"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_protnone",
          "args": [
            "pmd"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic inline uint64_t pmd_to_hmm_pfn_flags(struct hmm_range *range, pmd_t pmd)\n{\n\tif (pmd_protnone(pmd))\n\t\treturn 0;\n\treturn pmd_write(pmd) ? range->flags[HMM_PFN_VALID] |\n\t\t\t\trange->flags[HMM_PFN_WRITE] :\n\t\t\t\trange->flags[HMM_PFN_VALID];\n}"
  },
  {
    "function_name": "hmm_vma_walk_hole",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "447-462",
    "snippet": "static int hmm_vma_walk_hole(unsigned long addr, unsigned long end,\n\t\t\t     struct mm_walk *walk)\n{\n\tstruct hmm_vma_walk *hmm_vma_walk = walk->private;\n\tstruct hmm_range *range = hmm_vma_walk->range;\n\tbool fault, write_fault;\n\tunsigned long i, npages;\n\tuint64_t *pfns;\n\n\ti = (addr - range->start) >> PAGE_SHIFT;\n\tnpages = (end - addr) >> PAGE_SHIFT;\n\tpfns = &range->pfns[i];\n\thmm_range_need_fault(hmm_vma_walk, pfns, npages,\n\t\t\t     0, &fault, &write_fault);\n\treturn hmm_vma_walk_hole_(addr, end, fault, write_fault, walk);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hmm_vma_walk_hole_",
          "args": [
            "addr",
            "end",
            "fault",
            "write_fault",
            "walk"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "hmm_vma_walk_hole_",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
          "lines": "368-392",
          "snippet": "static int hmm_vma_walk_hole_(unsigned long addr, unsigned long end,\n\t\t\t      bool fault, bool write_fault,\n\t\t\t      struct mm_walk *walk)\n{\n\tstruct hmm_vma_walk *hmm_vma_walk = walk->private;\n\tstruct hmm_range *range = hmm_vma_walk->range;\n\tuint64_t *pfns = range->pfns;\n\tunsigned long i;\n\n\thmm_vma_walk->last = addr;\n\ti = (addr - range->start) >> PAGE_SHIFT;\n\tfor (; addr < end; addr += PAGE_SIZE, i++) {\n\t\tpfns[i] = range->values[HMM_PFN_NONE];\n\t\tif (fault || write_fault) {\n\t\t\tint ret;\n\n\t\t\tret = hmm_vma_do_fault(walk, addr, write_fault,\n\t\t\t\t\t       &pfns[i]);\n\t\t\tif (ret != -EAGAIN)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn (fault || write_fault) ? -EAGAIN : 0;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/memremap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/init.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic int hmm_vma_walk_hole_(unsigned long addr, unsigned long end,\n\t\t\t      bool fault, bool write_fault,\n\t\t\t      struct mm_walk *walk)\n{\n\tstruct hmm_vma_walk *hmm_vma_walk = walk->private;\n\tstruct hmm_range *range = hmm_vma_walk->range;\n\tuint64_t *pfns = range->pfns;\n\tunsigned long i;\n\n\thmm_vma_walk->last = addr;\n\ti = (addr - range->start) >> PAGE_SHIFT;\n\tfor (; addr < end; addr += PAGE_SIZE, i++) {\n\t\tpfns[i] = range->values[HMM_PFN_NONE];\n\t\tif (fault || write_fault) {\n\t\t\tint ret;\n\n\t\t\tret = hmm_vma_do_fault(walk, addr, write_fault,\n\t\t\t\t\t       &pfns[i]);\n\t\t\tif (ret != -EAGAIN)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn (fault || write_fault) ? -EAGAIN : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hmm_range_need_fault",
          "args": [
            "hmm_vma_walk",
            "pfns",
            "npages",
            "0",
            "&fault",
            "&write_fault"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "hmm_range_need_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
          "lines": "427-445",
          "snippet": "static void hmm_range_need_fault(const struct hmm_vma_walk *hmm_vma_walk,\n\t\t\t\t const uint64_t *pfns, unsigned long npages,\n\t\t\t\t uint64_t cpu_flags, bool *fault,\n\t\t\t\t bool *write_fault)\n{\n\tunsigned long i;\n\n\tif (!hmm_vma_walk->fault) {\n\t\t*fault = *write_fault = false;\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < npages; ++i) {\n\t\thmm_pte_need_fault(hmm_vma_walk, pfns[i], cpu_flags,\n\t\t\t\t   fault, write_fault);\n\t\tif ((*fault) || (*write_fault))\n\t\t\treturn;\n\t}\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/memremap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/init.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic void hmm_range_need_fault(const struct hmm_vma_walk *hmm_vma_walk,\n\t\t\t\t const uint64_t *pfns, unsigned long npages,\n\t\t\t\t uint64_t cpu_flags, bool *fault,\n\t\t\t\t bool *write_fault)\n{\n\tunsigned long i;\n\n\tif (!hmm_vma_walk->fault) {\n\t\t*fault = *write_fault = false;\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < npages; ++i) {\n\t\thmm_pte_need_fault(hmm_vma_walk, pfns[i], cpu_flags,\n\t\t\t\t   fault, write_fault);\n\t\tif ((*fault) || (*write_fault))\n\t\t\treturn;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic int hmm_vma_walk_hole(unsigned long addr, unsigned long end,\n\t\t\t     struct mm_walk *walk)\n{\n\tstruct hmm_vma_walk *hmm_vma_walk = walk->private;\n\tstruct hmm_range *range = hmm_vma_walk->range;\n\tbool fault, write_fault;\n\tunsigned long i, npages;\n\tuint64_t *pfns;\n\n\ti = (addr - range->start) >> PAGE_SHIFT;\n\tnpages = (end - addr) >> PAGE_SHIFT;\n\tpfns = &range->pfns[i];\n\thmm_range_need_fault(hmm_vma_walk, pfns, npages,\n\t\t\t     0, &fault, &write_fault);\n\treturn hmm_vma_walk_hole_(addr, end, fault, write_fault, walk);\n}"
  },
  {
    "function_name": "hmm_range_need_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "427-445",
    "snippet": "static void hmm_range_need_fault(const struct hmm_vma_walk *hmm_vma_walk,\n\t\t\t\t const uint64_t *pfns, unsigned long npages,\n\t\t\t\t uint64_t cpu_flags, bool *fault,\n\t\t\t\t bool *write_fault)\n{\n\tunsigned long i;\n\n\tif (!hmm_vma_walk->fault) {\n\t\t*fault = *write_fault = false;\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < npages; ++i) {\n\t\thmm_pte_need_fault(hmm_vma_walk, pfns[i], cpu_flags,\n\t\t\t\t   fault, write_fault);\n\t\tif ((*fault) || (*write_fault))\n\t\t\treturn;\n\t}\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hmm_pte_need_fault",
          "args": [
            "hmm_vma_walk",
            "pfns[i]",
            "cpu_flags",
            "fault",
            "write_fault"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "hmm_pte_need_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
          "lines": "394-425",
          "snippet": "static inline void hmm_pte_need_fault(const struct hmm_vma_walk *hmm_vma_walk,\n\t\t\t\t      uint64_t pfns, uint64_t cpu_flags,\n\t\t\t\t      bool *fault, bool *write_fault)\n{\n\tstruct hmm_range *range = hmm_vma_walk->range;\n\n\t*fault = *write_fault = false;\n\tif (!hmm_vma_walk->fault)\n\t\treturn;\n\n\t/* We aren't ask to do anything ... */\n\tif (!(pfns & range->flags[HMM_PFN_VALID]))\n\t\treturn;\n\t/* If this is device memory than only fault if explicitly requested */\n\tif ((cpu_flags & range->flags[HMM_PFN_DEVICE_PRIVATE])) {\n\t\t/* Do we fault on device memory ? */\n\t\tif (pfns & range->flags[HMM_PFN_DEVICE_PRIVATE]) {\n\t\t\t*write_fault = pfns & range->flags[HMM_PFN_WRITE];\n\t\t\t*fault = true;\n\t\t}\n\t\treturn;\n\t}\n\n\t/* If CPU page table is not valid then we need to fault */\n\t*fault = !(cpu_flags & range->flags[HMM_PFN_VALID]);\n\t/* Need to write fault ? */\n\tif ((pfns & range->flags[HMM_PFN_WRITE]) &&\n\t    !(cpu_flags & range->flags[HMM_PFN_WRITE])) {\n\t\t*write_fault = true;\n\t\t*fault = true;\n\t}\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/memremap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/init.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic inline void hmm_pte_need_fault(const struct hmm_vma_walk *hmm_vma_walk,\n\t\t\t\t      uint64_t pfns, uint64_t cpu_flags,\n\t\t\t\t      bool *fault, bool *write_fault)\n{\n\tstruct hmm_range *range = hmm_vma_walk->range;\n\n\t*fault = *write_fault = false;\n\tif (!hmm_vma_walk->fault)\n\t\treturn;\n\n\t/* We aren't ask to do anything ... */\n\tif (!(pfns & range->flags[HMM_PFN_VALID]))\n\t\treturn;\n\t/* If this is device memory than only fault if explicitly requested */\n\tif ((cpu_flags & range->flags[HMM_PFN_DEVICE_PRIVATE])) {\n\t\t/* Do we fault on device memory ? */\n\t\tif (pfns & range->flags[HMM_PFN_DEVICE_PRIVATE]) {\n\t\t\t*write_fault = pfns & range->flags[HMM_PFN_WRITE];\n\t\t\t*fault = true;\n\t\t}\n\t\treturn;\n\t}\n\n\t/* If CPU page table is not valid then we need to fault */\n\t*fault = !(cpu_flags & range->flags[HMM_PFN_VALID]);\n\t/* Need to write fault ? */\n\tif ((pfns & range->flags[HMM_PFN_WRITE]) &&\n\t    !(cpu_flags & range->flags[HMM_PFN_WRITE])) {\n\t\t*write_fault = true;\n\t\t*fault = true;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic void hmm_range_need_fault(const struct hmm_vma_walk *hmm_vma_walk,\n\t\t\t\t const uint64_t *pfns, unsigned long npages,\n\t\t\t\t uint64_t cpu_flags, bool *fault,\n\t\t\t\t bool *write_fault)\n{\n\tunsigned long i;\n\n\tif (!hmm_vma_walk->fault) {\n\t\t*fault = *write_fault = false;\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < npages; ++i) {\n\t\thmm_pte_need_fault(hmm_vma_walk, pfns[i], cpu_flags,\n\t\t\t\t   fault, write_fault);\n\t\tif ((*fault) || (*write_fault))\n\t\t\treturn;\n\t}\n}"
  },
  {
    "function_name": "hmm_pte_need_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "394-425",
    "snippet": "static inline void hmm_pte_need_fault(const struct hmm_vma_walk *hmm_vma_walk,\n\t\t\t\t      uint64_t pfns, uint64_t cpu_flags,\n\t\t\t\t      bool *fault, bool *write_fault)\n{\n\tstruct hmm_range *range = hmm_vma_walk->range;\n\n\t*fault = *write_fault = false;\n\tif (!hmm_vma_walk->fault)\n\t\treturn;\n\n\t/* We aren't ask to do anything ... */\n\tif (!(pfns & range->flags[HMM_PFN_VALID]))\n\t\treturn;\n\t/* If this is device memory than only fault if explicitly requested */\n\tif ((cpu_flags & range->flags[HMM_PFN_DEVICE_PRIVATE])) {\n\t\t/* Do we fault on device memory ? */\n\t\tif (pfns & range->flags[HMM_PFN_DEVICE_PRIVATE]) {\n\t\t\t*write_fault = pfns & range->flags[HMM_PFN_WRITE];\n\t\t\t*fault = true;\n\t\t}\n\t\treturn;\n\t}\n\n\t/* If CPU page table is not valid then we need to fault */\n\t*fault = !(cpu_flags & range->flags[HMM_PFN_VALID]);\n\t/* Need to write fault ? */\n\tif ((pfns & range->flags[HMM_PFN_WRITE]) &&\n\t    !(cpu_flags & range->flags[HMM_PFN_WRITE])) {\n\t\t*write_fault = true;\n\t\t*fault = true;\n\t}\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic inline void hmm_pte_need_fault(const struct hmm_vma_walk *hmm_vma_walk,\n\t\t\t\t      uint64_t pfns, uint64_t cpu_flags,\n\t\t\t\t      bool *fault, bool *write_fault)\n{\n\tstruct hmm_range *range = hmm_vma_walk->range;\n\n\t*fault = *write_fault = false;\n\tif (!hmm_vma_walk->fault)\n\t\treturn;\n\n\t/* We aren't ask to do anything ... */\n\tif (!(pfns & range->flags[HMM_PFN_VALID]))\n\t\treturn;\n\t/* If this is device memory than only fault if explicitly requested */\n\tif ((cpu_flags & range->flags[HMM_PFN_DEVICE_PRIVATE])) {\n\t\t/* Do we fault on device memory ? */\n\t\tif (pfns & range->flags[HMM_PFN_DEVICE_PRIVATE]) {\n\t\t\t*write_fault = pfns & range->flags[HMM_PFN_WRITE];\n\t\t\t*fault = true;\n\t\t}\n\t\treturn;\n\t}\n\n\t/* If CPU page table is not valid then we need to fault */\n\t*fault = !(cpu_flags & range->flags[HMM_PFN_VALID]);\n\t/* Need to write fault ? */\n\tif ((pfns & range->flags[HMM_PFN_WRITE]) &&\n\t    !(cpu_flags & range->flags[HMM_PFN_WRITE])) {\n\t\t*write_fault = true;\n\t\t*fault = true;\n\t}\n}"
  },
  {
    "function_name": "hmm_vma_walk_hole_",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "368-392",
    "snippet": "static int hmm_vma_walk_hole_(unsigned long addr, unsigned long end,\n\t\t\t      bool fault, bool write_fault,\n\t\t\t      struct mm_walk *walk)\n{\n\tstruct hmm_vma_walk *hmm_vma_walk = walk->private;\n\tstruct hmm_range *range = hmm_vma_walk->range;\n\tuint64_t *pfns = range->pfns;\n\tunsigned long i;\n\n\thmm_vma_walk->last = addr;\n\ti = (addr - range->start) >> PAGE_SHIFT;\n\tfor (; addr < end; addr += PAGE_SIZE, i++) {\n\t\tpfns[i] = range->values[HMM_PFN_NONE];\n\t\tif (fault || write_fault) {\n\t\t\tint ret;\n\n\t\t\tret = hmm_vma_do_fault(walk, addr, write_fault,\n\t\t\t\t\t       &pfns[i]);\n\t\t\tif (ret != -EAGAIN)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn (fault || write_fault) ? -EAGAIN : 0;\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hmm_vma_do_fault",
          "args": [
            "walk",
            "addr",
            "write_fault",
            "&pfns[i]"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "hmm_vma_do_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
          "lines": "318-338",
          "snippet": "static int hmm_vma_do_fault(struct mm_walk *walk, unsigned long addr,\n\t\t\t    bool write_fault, uint64_t *pfn)\n{\n\tunsigned int flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_REMOTE;\n\tstruct hmm_vma_walk *hmm_vma_walk = walk->private;\n\tstruct hmm_range *range = hmm_vma_walk->range;\n\tstruct vm_area_struct *vma = walk->vma;\n\tvm_fault_t ret;\n\n\tflags |= hmm_vma_walk->block ? 0 : FAULT_FLAG_ALLOW_RETRY;\n\tflags |= write_fault ? FAULT_FLAG_WRITE : 0;\n\tret = handle_mm_fault(vma, addr, flags);\n\tif (ret & VM_FAULT_RETRY)\n\t\treturn -EBUSY;\n\tif (ret & VM_FAULT_ERROR) {\n\t\t*pfn = range->values[HMM_PFN_ERROR];\n\t\treturn -EFAULT;\n\t}\n\n\treturn -EAGAIN;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/memremap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/init.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic int hmm_vma_do_fault(struct mm_walk *walk, unsigned long addr,\n\t\t\t    bool write_fault, uint64_t *pfn)\n{\n\tunsigned int flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_REMOTE;\n\tstruct hmm_vma_walk *hmm_vma_walk = walk->private;\n\tstruct hmm_range *range = hmm_vma_walk->range;\n\tstruct vm_area_struct *vma = walk->vma;\n\tvm_fault_t ret;\n\n\tflags |= hmm_vma_walk->block ? 0 : FAULT_FLAG_ALLOW_RETRY;\n\tflags |= write_fault ? FAULT_FLAG_WRITE : 0;\n\tret = handle_mm_fault(vma, addr, flags);\n\tif (ret & VM_FAULT_RETRY)\n\t\treturn -EBUSY;\n\tif (ret & VM_FAULT_ERROR) {\n\t\t*pfn = range->values[HMM_PFN_ERROR];\n\t\treturn -EFAULT;\n\t}\n\n\treturn -EAGAIN;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic int hmm_vma_walk_hole_(unsigned long addr, unsigned long end,\n\t\t\t      bool fault, bool write_fault,\n\t\t\t      struct mm_walk *walk)\n{\n\tstruct hmm_vma_walk *hmm_vma_walk = walk->private;\n\tstruct hmm_range *range = hmm_vma_walk->range;\n\tuint64_t *pfns = range->pfns;\n\tunsigned long i;\n\n\thmm_vma_walk->last = addr;\n\ti = (addr - range->start) >> PAGE_SHIFT;\n\tfor (; addr < end; addr += PAGE_SIZE, i++) {\n\t\tpfns[i] = range->values[HMM_PFN_NONE];\n\t\tif (fault || write_fault) {\n\t\t\tint ret;\n\n\t\t\tret = hmm_vma_do_fault(walk, addr, write_fault,\n\t\t\t\t\t       &pfns[i]);\n\t\t\tif (ret != -EAGAIN)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn (fault || write_fault) ? -EAGAIN : 0;\n}"
  },
  {
    "function_name": "hmm_pfns_bad",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "340-354",
    "snippet": "static int hmm_pfns_bad(unsigned long addr,\n\t\t\tunsigned long end,\n\t\t\tstruct mm_walk *walk)\n{\n\tstruct hmm_vma_walk *hmm_vma_walk = walk->private;\n\tstruct hmm_range *range = hmm_vma_walk->range;\n\tuint64_t *pfns = range->pfns;\n\tunsigned long i;\n\n\ti = (addr - range->start) >> PAGE_SHIFT;\n\tfor (; addr < end; addr += PAGE_SIZE, i++)\n\t\tpfns[i] = range->values[HMM_PFN_ERROR];\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic int hmm_pfns_bad(unsigned long addr,\n\t\t\tunsigned long end,\n\t\t\tstruct mm_walk *walk)\n{\n\tstruct hmm_vma_walk *hmm_vma_walk = walk->private;\n\tstruct hmm_range *range = hmm_vma_walk->range;\n\tuint64_t *pfns = range->pfns;\n\tunsigned long i;\n\n\ti = (addr - range->start) >> PAGE_SHIFT;\n\tfor (; addr < end; addr += PAGE_SIZE, i++)\n\t\tpfns[i] = range->values[HMM_PFN_ERROR];\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hmm_vma_do_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "318-338",
    "snippet": "static int hmm_vma_do_fault(struct mm_walk *walk, unsigned long addr,\n\t\t\t    bool write_fault, uint64_t *pfn)\n{\n\tunsigned int flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_REMOTE;\n\tstruct hmm_vma_walk *hmm_vma_walk = walk->private;\n\tstruct hmm_range *range = hmm_vma_walk->range;\n\tstruct vm_area_struct *vma = walk->vma;\n\tvm_fault_t ret;\n\n\tflags |= hmm_vma_walk->block ? 0 : FAULT_FLAG_ALLOW_RETRY;\n\tflags |= write_fault ? FAULT_FLAG_WRITE : 0;\n\tret = handle_mm_fault(vma, addr, flags);\n\tif (ret & VM_FAULT_RETRY)\n\t\treturn -EBUSY;\n\tif (ret & VM_FAULT_ERROR) {\n\t\t*pfn = range->values[HMM_PFN_ERROR];\n\t\treturn -EFAULT;\n\t}\n\n\treturn -EAGAIN;\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "handle_mm_fault",
          "args": [
            "vma",
            "addr",
            "flags"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "handle_mm_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "3898-3941",
          "snippet": "vm_fault_t handle_mm_fault(struct vm_area_struct *vma, unsigned long address,\n\t\tunsigned int flags)\n{\n\tvm_fault_t ret;\n\n\t__set_current_state(TASK_RUNNING);\n\n\tcount_vm_event(PGFAULT);\n\tcount_memcg_event_mm(vma->vm_mm, PGFAULT);\n\n\t/* do counter updates before entering really critical section. */\n\tcheck_sync_rss_stat(current);\n\n\tif (!arch_vma_access_permitted(vma, flags & FAULT_FLAG_WRITE,\n\t\t\t\t\t    flags & FAULT_FLAG_INSTRUCTION,\n\t\t\t\t\t    flags & FAULT_FLAG_REMOTE))\n\t\treturn VM_FAULT_SIGSEGV;\n\n\t/*\n\t * Enable the memcg OOM handling for faults triggered in user\n\t * space.  Kernel faults are handled more gracefully.\n\t */\n\tif (flags & FAULT_FLAG_USER)\n\t\tmem_cgroup_enter_user_fault();\n\n\tif (unlikely(is_vm_hugetlb_page(vma)))\n\t\tret = hugetlb_fault(vma->vm_mm, vma, address, flags);\n\telse\n\t\tret = __handle_mm_fault(vma, address, flags);\n\n\tif (flags & FAULT_FLAG_USER) {\n\t\tmem_cgroup_exit_user_fault();\n\t\t/*\n\t\t * The task may have entered a memcg OOM situation but\n\t\t * if the allocation error was handled gracefully (no\n\t\t * VM_FAULT_OOM), there is no need to kill anything.\n\t\t * Just clean up the OOM state peacefully.\n\t\t */\n\t\tif (task_in_memcg_oom(current) && !(ret & VM_FAULT_OOM))\n\t\t\tmem_cgroup_oom_synchronize(false);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvm_fault_t handle_mm_fault(struct vm_area_struct *vma, unsigned long address,\n\t\tunsigned int flags)\n{\n\tvm_fault_t ret;\n\n\t__set_current_state(TASK_RUNNING);\n\n\tcount_vm_event(PGFAULT);\n\tcount_memcg_event_mm(vma->vm_mm, PGFAULT);\n\n\t/* do counter updates before entering really critical section. */\n\tcheck_sync_rss_stat(current);\n\n\tif (!arch_vma_access_permitted(vma, flags & FAULT_FLAG_WRITE,\n\t\t\t\t\t    flags & FAULT_FLAG_INSTRUCTION,\n\t\t\t\t\t    flags & FAULT_FLAG_REMOTE))\n\t\treturn VM_FAULT_SIGSEGV;\n\n\t/*\n\t * Enable the memcg OOM handling for faults triggered in user\n\t * space.  Kernel faults are handled more gracefully.\n\t */\n\tif (flags & FAULT_FLAG_USER)\n\t\tmem_cgroup_enter_user_fault();\n\n\tif (unlikely(is_vm_hugetlb_page(vma)))\n\t\tret = hugetlb_fault(vma->vm_mm, vma, address, flags);\n\telse\n\t\tret = __handle_mm_fault(vma, address, flags);\n\n\tif (flags & FAULT_FLAG_USER) {\n\t\tmem_cgroup_exit_user_fault();\n\t\t/*\n\t\t * The task may have entered a memcg OOM situation but\n\t\t * if the allocation error was handled gracefully (no\n\t\t * VM_FAULT_OOM), there is no need to kill anything.\n\t\t * Just clean up the OOM state peacefully.\n\t\t */\n\t\tif (task_in_memcg_oom(current) && !(ret & VM_FAULT_OOM))\n\t\t\tmem_cgroup_oom_synchronize(false);\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic int hmm_vma_do_fault(struct mm_walk *walk, unsigned long addr,\n\t\t\t    bool write_fault, uint64_t *pfn)\n{\n\tunsigned int flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_REMOTE;\n\tstruct hmm_vma_walk *hmm_vma_walk = walk->private;\n\tstruct hmm_range *range = hmm_vma_walk->range;\n\tstruct vm_area_struct *vma = walk->vma;\n\tvm_fault_t ret;\n\n\tflags |= hmm_vma_walk->block ? 0 : FAULT_FLAG_ALLOW_RETRY;\n\tflags |= write_fault ? FAULT_FLAG_WRITE : 0;\n\tret = handle_mm_fault(vma, addr, flags);\n\tif (ret & VM_FAULT_RETRY)\n\t\treturn -EBUSY;\n\tif (ret & VM_FAULT_ERROR) {\n\t\t*pfn = range->values[HMM_PFN_ERROR];\n\t\treturn -EFAULT;\n\t}\n\n\treturn -EAGAIN;\n}"
  },
  {
    "function_name": "hmm_mirror_unregister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "279-308",
    "snippet": "void hmm_mirror_unregister(struct hmm_mirror *mirror)\n{\n\tbool should_unregister = false;\n\tstruct mm_struct *mm;\n\tstruct hmm *hmm;\n\n\tif (mirror->hmm == NULL)\n\t\treturn;\n\n\thmm = mirror->hmm;\n\tdown_write(&hmm->mirrors_sem);\n\tlist_del_init(&mirror->list);\n\tshould_unregister = list_empty(&hmm->mirrors);\n\tmirror->hmm = NULL;\n\tmm = hmm->mm;\n\thmm->mm = NULL;\n\tup_write(&hmm->mirrors_sem);\n\n\tif (!should_unregister || mm == NULL)\n\t\treturn;\n\n\tmmu_notifier_unregister_no_release(&hmm->mmu_notifier, mm);\n\n\tspin_lock(&mm->page_table_lock);\n\tif (mm->hmm == hmm)\n\t\tmm->hmm = NULL;\n\tspin_unlock(&mm->page_table_lock);\n\n\tkfree(hmm);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "hmm"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mm->page_table_lock"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mm->page_table_lock"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_notifier_unregister_no_release",
          "args": [
            "&hmm->mmu_notifier",
            "mm"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_notifier_unregister_no_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_notifier.c",
          "lines": "392-405",
          "snippet": "void mmu_notifier_unregister_no_release(struct mmu_notifier *mn,\n\t\t\t\t\tstruct mm_struct *mm)\n{\n\tspin_lock(&mm->mmu_notifier_mm->lock);\n\t/*\n\t * Can not use list_del_rcu() since __mmu_notifier_release\n\t * can delete it before we hold the lock.\n\t */\n\thlist_del_init_rcu(&mn->hlist);\n\tspin_unlock(&mm->mmu_notifier_mm->lock);\n\n\tBUG_ON(atomic_read(&mm->mm_count) <= 0);\n\tmmdrop(mm);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/srcu.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/srcu.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rculist.h>\n\nvoid mmu_notifier_unregister_no_release(struct mmu_notifier *mn,\n\t\t\t\t\tstruct mm_struct *mm)\n{\n\tspin_lock(&mm->mmu_notifier_mm->lock);\n\t/*\n\t * Can not use list_del_rcu() since __mmu_notifier_release\n\t * can delete it before we hold the lock.\n\t */\n\thlist_del_init_rcu(&mn->hlist);\n\tspin_unlock(&mm->mmu_notifier_mm->lock);\n\n\tBUG_ON(atomic_read(&mm->mm_count) <= 0);\n\tmmdrop(mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&hmm->mirrors_sem"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&hmm->mirrors"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&mirror->list"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&hmm->mirrors_sem"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nvoid hmm_mirror_unregister(struct hmm_mirror *mirror)\n{\n\tbool should_unregister = false;\n\tstruct mm_struct *mm;\n\tstruct hmm *hmm;\n\n\tif (mirror->hmm == NULL)\n\t\treturn;\n\n\thmm = mirror->hmm;\n\tdown_write(&hmm->mirrors_sem);\n\tlist_del_init(&mirror->list);\n\tshould_unregister = list_empty(&hmm->mirrors);\n\tmirror->hmm = NULL;\n\tmm = hmm->mm;\n\thmm->mm = NULL;\n\tup_write(&hmm->mirrors_sem);\n\n\tif (!should_unregister || mm == NULL)\n\t\treturn;\n\n\tmmu_notifier_unregister_no_release(&hmm->mmu_notifier, mm);\n\n\tspin_lock(&mm->page_table_lock);\n\tif (mm->hmm == hmm)\n\t\tmm->hmm = NULL;\n\tspin_unlock(&mm->page_table_lock);\n\n\tkfree(hmm);\n}"
  },
  {
    "function_name": "hmm_mirror_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "243-269",
    "snippet": "int hmm_mirror_register(struct hmm_mirror *mirror, struct mm_struct *mm)\n{\n\t/* Sanity check */\n\tif (!mm || !mirror || !mirror->ops)\n\t\treturn -EINVAL;\n\nagain:\n\tmirror->hmm = hmm_register(mm);\n\tif (!mirror->hmm)\n\t\treturn -ENOMEM;\n\n\tdown_write(&mirror->hmm->mirrors_sem);\n\tif (mirror->hmm->mm == NULL) {\n\t\t/*\n\t\t * A racing hmm_mirror_unregister() is about to destroy the hmm\n\t\t * struct. Try again to allocate a new one.\n\t\t */\n\t\tup_write(&mirror->hmm->mirrors_sem);\n\t\tmirror->hmm = NULL;\n\t\tgoto again;\n\t} else {\n\t\tlist_add(&mirror->list, &mirror->hmm->mirrors);\n\t\tup_write(&mirror->hmm->mirrors_sem);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mirror->hmm->mirrors_sem"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&mirror->list",
            "&mirror->hmm->mirrors"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mirror->hmm->mirrors_sem"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&mirror->hmm->mirrors_sem"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hmm_register",
          "args": [
            "mm"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "hmm_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
          "lines": "68-119",
          "snippet": "static struct hmm *hmm_register(struct mm_struct *mm)\n{\n\tstruct hmm *hmm = READ_ONCE(mm->hmm);\n\tbool cleanup = false;\n\n\t/*\n\t * The hmm struct can only be freed once the mm_struct goes away,\n\t * hence we should always have pre-allocated an new hmm struct\n\t * above.\n\t */\n\tif (hmm)\n\t\treturn hmm;\n\n\thmm = kmalloc(sizeof(*hmm), GFP_KERNEL);\n\tif (!hmm)\n\t\treturn NULL;\n\tINIT_LIST_HEAD(&hmm->mirrors);\n\tinit_rwsem(&hmm->mirrors_sem);\n\thmm->mmu_notifier.ops = NULL;\n\tINIT_LIST_HEAD(&hmm->ranges);\n\tspin_lock_init(&hmm->lock);\n\thmm->mm = mm;\n\n\tspin_lock(&mm->page_table_lock);\n\tif (!mm->hmm)\n\t\tmm->hmm = hmm;\n\telse\n\t\tcleanup = true;\n\tspin_unlock(&mm->page_table_lock);\n\n\tif (cleanup)\n\t\tgoto error;\n\n\t/*\n\t * We should only get here if hold the mmap_sem in write mode ie on\n\t * registration of first mirror through hmm_mirror_register()\n\t */\n\thmm->mmu_notifier.ops = &hmm_mmu_notifier_ops;\n\tif (__mmu_notifier_register(&hmm->mmu_notifier, mm))\n\t\tgoto error_mm;\n\n\treturn mm->hmm;\n\nerror_mm:\n\tspin_lock(&mm->page_table_lock);\n\tif (mm->hmm == hmm)\n\t\tmm->hmm = NULL;\n\tspin_unlock(&mm->page_table_lock);\nerror:\n\tkfree(hmm);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/memremap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/init.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic struct hmm *hmm_register(struct mm_struct *mm)\n{\n\tstruct hmm *hmm = READ_ONCE(mm->hmm);\n\tbool cleanup = false;\n\n\t/*\n\t * The hmm struct can only be freed once the mm_struct goes away,\n\t * hence we should always have pre-allocated an new hmm struct\n\t * above.\n\t */\n\tif (hmm)\n\t\treturn hmm;\n\n\thmm = kmalloc(sizeof(*hmm), GFP_KERNEL);\n\tif (!hmm)\n\t\treturn NULL;\n\tINIT_LIST_HEAD(&hmm->mirrors);\n\tinit_rwsem(&hmm->mirrors_sem);\n\thmm->mmu_notifier.ops = NULL;\n\tINIT_LIST_HEAD(&hmm->ranges);\n\tspin_lock_init(&hmm->lock);\n\thmm->mm = mm;\n\n\tspin_lock(&mm->page_table_lock);\n\tif (!mm->hmm)\n\t\tmm->hmm = hmm;\n\telse\n\t\tcleanup = true;\n\tspin_unlock(&mm->page_table_lock);\n\n\tif (cleanup)\n\t\tgoto error;\n\n\t/*\n\t * We should only get here if hold the mmap_sem in write mode ie on\n\t * registration of first mirror through hmm_mirror_register()\n\t */\n\thmm->mmu_notifier.ops = &hmm_mmu_notifier_ops;\n\tif (__mmu_notifier_register(&hmm->mmu_notifier, mm))\n\t\tgoto error_mm;\n\n\treturn mm->hmm;\n\nerror_mm:\n\tspin_lock(&mm->page_table_lock);\n\tif (mm->hmm == hmm)\n\t\tmm->hmm = NULL;\n\tspin_unlock(&mm->page_table_lock);\nerror:\n\tkfree(hmm);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nint hmm_mirror_register(struct hmm_mirror *mirror, struct mm_struct *mm)\n{\n\t/* Sanity check */\n\tif (!mm || !mirror || !mirror->ops)\n\t\treturn -EINVAL;\n\nagain:\n\tmirror->hmm = hmm_register(mm);\n\tif (!mirror->hmm)\n\t\treturn -ENOMEM;\n\n\tdown_write(&mirror->hmm->mirrors_sem);\n\tif (mirror->hmm->mm == NULL) {\n\t\t/*\n\t\t * A racing hmm_mirror_unregister() is about to destroy the hmm\n\t\t * struct. Try again to allocate a new one.\n\t\t */\n\t\tup_write(&mirror->hmm->mirrors_sem);\n\t\tmirror->hmm = NULL;\n\t\tgoto again;\n\t} else {\n\t\tlist_add(&mirror->list, &mirror->hmm->mirrors);\n\t\tup_write(&mirror->hmm->mirrors_sem);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hmm_invalidate_range_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "209-224",
    "snippet": "static void hmm_invalidate_range_end(struct mmu_notifier *mn,\n\t\t\t\t     struct mm_struct *mm,\n\t\t\t\t     unsigned long start,\n\t\t\t\t     unsigned long end)\n{\n\tstruct hmm_update update;\n\tstruct hmm *hmm = mm->hmm;\n\n\tVM_BUG_ON(!hmm);\n\n\tupdate.start = start;\n\tupdate.end = end;\n\tupdate.event = HMM_UPDATE_INVALIDATE;\n\tupdate.blockable = true;\n\thmm_invalidate_range(hmm, false, &update);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hmm_invalidate_range",
          "args": [
            "hmm",
            "false",
            "&update"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "hmm_invalidate_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
          "lines": "126-163",
          "snippet": "static int hmm_invalidate_range(struct hmm *hmm, bool device,\n\t\t\t\tconst struct hmm_update *update)\n{\n\tstruct hmm_mirror *mirror;\n\tstruct hmm_range *range;\n\n\tspin_lock(&hmm->lock);\n\tlist_for_each_entry(range, &hmm->ranges, list) {\n\t\tunsigned long addr, idx, npages;\n\n\t\tif (update->end < range->start || update->start >= range->end)\n\t\t\tcontinue;\n\n\t\trange->valid = false;\n\t\taddr = max(update->start, range->start);\n\t\tidx = (addr - range->start) >> PAGE_SHIFT;\n\t\tnpages = (min(range->end, update->end) - addr) >> PAGE_SHIFT;\n\t\tmemset(&range->pfns[idx], 0, sizeof(*range->pfns) * npages);\n\t}\n\tspin_unlock(&hmm->lock);\n\n\tif (!device)\n\t\treturn 0;\n\n\tdown_read(&hmm->mirrors_sem);\n\tlist_for_each_entry(mirror, &hmm->mirrors, list) {\n\t\tint ret;\n\n\t\tret = mirror->ops->sync_cpu_device_pagetables(mirror, update);\n\t\tif (!update->blockable && ret == -EAGAIN) {\n\t\t\tup_read(&hmm->mirrors_sem);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\tup_read(&hmm->mirrors_sem);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/memremap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/init.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic int hmm_invalidate_range(struct hmm *hmm, bool device,\n\t\t\t\tconst struct hmm_update *update)\n{\n\tstruct hmm_mirror *mirror;\n\tstruct hmm_range *range;\n\n\tspin_lock(&hmm->lock);\n\tlist_for_each_entry(range, &hmm->ranges, list) {\n\t\tunsigned long addr, idx, npages;\n\n\t\tif (update->end < range->start || update->start >= range->end)\n\t\t\tcontinue;\n\n\t\trange->valid = false;\n\t\taddr = max(update->start, range->start);\n\t\tidx = (addr - range->start) >> PAGE_SHIFT;\n\t\tnpages = (min(range->end, update->end) - addr) >> PAGE_SHIFT;\n\t\tmemset(&range->pfns[idx], 0, sizeof(*range->pfns) * npages);\n\t}\n\tspin_unlock(&hmm->lock);\n\n\tif (!device)\n\t\treturn 0;\n\n\tdown_read(&hmm->mirrors_sem);\n\tlist_for_each_entry(mirror, &hmm->mirrors, list) {\n\t\tint ret;\n\n\t\tret = mirror->ops->sync_cpu_device_pagetables(mirror, update);\n\t\tif (!update->blockable && ret == -EAGAIN) {\n\t\t\tup_read(&hmm->mirrors_sem);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\tup_read(&hmm->mirrors_sem);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!hmm"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic void hmm_invalidate_range_end(struct mmu_notifier *mn,\n\t\t\t\t     struct mm_struct *mm,\n\t\t\t\t     unsigned long start,\n\t\t\t\t     unsigned long end)\n{\n\tstruct hmm_update update;\n\tstruct hmm *hmm = mm->hmm;\n\n\tVM_BUG_ON(!hmm);\n\n\tupdate.start = start;\n\tupdate.end = end;\n\tupdate.event = HMM_UPDATE_INVALIDATE;\n\tupdate.blockable = true;\n\thmm_invalidate_range(hmm, false, &update);\n}"
  },
  {
    "function_name": "hmm_invalidate_range_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "191-207",
    "snippet": "static int hmm_invalidate_range_start(struct mmu_notifier *mn,\n\t\t\t\t      struct mm_struct *mm,\n\t\t\t\t      unsigned long start,\n\t\t\t\t      unsigned long end,\n\t\t\t\t      bool blockable)\n{\n\tstruct hmm_update update;\n\tstruct hmm *hmm = mm->hmm;\n\n\tVM_BUG_ON(!hmm);\n\n\tupdate.start = start;\n\tupdate.end = end;\n\tupdate.event = HMM_UPDATE_INVALIDATE;\n\tupdate.blockable = blockable;\n\treturn hmm_invalidate_range(hmm, true, &update);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hmm_invalidate_range",
          "args": [
            "hmm",
            "true",
            "&update"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "hmm_invalidate_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
          "lines": "126-163",
          "snippet": "static int hmm_invalidate_range(struct hmm *hmm, bool device,\n\t\t\t\tconst struct hmm_update *update)\n{\n\tstruct hmm_mirror *mirror;\n\tstruct hmm_range *range;\n\n\tspin_lock(&hmm->lock);\n\tlist_for_each_entry(range, &hmm->ranges, list) {\n\t\tunsigned long addr, idx, npages;\n\n\t\tif (update->end < range->start || update->start >= range->end)\n\t\t\tcontinue;\n\n\t\trange->valid = false;\n\t\taddr = max(update->start, range->start);\n\t\tidx = (addr - range->start) >> PAGE_SHIFT;\n\t\tnpages = (min(range->end, update->end) - addr) >> PAGE_SHIFT;\n\t\tmemset(&range->pfns[idx], 0, sizeof(*range->pfns) * npages);\n\t}\n\tspin_unlock(&hmm->lock);\n\n\tif (!device)\n\t\treturn 0;\n\n\tdown_read(&hmm->mirrors_sem);\n\tlist_for_each_entry(mirror, &hmm->mirrors, list) {\n\t\tint ret;\n\n\t\tret = mirror->ops->sync_cpu_device_pagetables(mirror, update);\n\t\tif (!update->blockable && ret == -EAGAIN) {\n\t\t\tup_read(&hmm->mirrors_sem);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\tup_read(&hmm->mirrors_sem);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/memremap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/init.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic int hmm_invalidate_range(struct hmm *hmm, bool device,\n\t\t\t\tconst struct hmm_update *update)\n{\n\tstruct hmm_mirror *mirror;\n\tstruct hmm_range *range;\n\n\tspin_lock(&hmm->lock);\n\tlist_for_each_entry(range, &hmm->ranges, list) {\n\t\tunsigned long addr, idx, npages;\n\n\t\tif (update->end < range->start || update->start >= range->end)\n\t\t\tcontinue;\n\n\t\trange->valid = false;\n\t\taddr = max(update->start, range->start);\n\t\tidx = (addr - range->start) >> PAGE_SHIFT;\n\t\tnpages = (min(range->end, update->end) - addr) >> PAGE_SHIFT;\n\t\tmemset(&range->pfns[idx], 0, sizeof(*range->pfns) * npages);\n\t}\n\tspin_unlock(&hmm->lock);\n\n\tif (!device)\n\t\treturn 0;\n\n\tdown_read(&hmm->mirrors_sem);\n\tlist_for_each_entry(mirror, &hmm->mirrors, list) {\n\t\tint ret;\n\n\t\tret = mirror->ops->sync_cpu_device_pagetables(mirror, update);\n\t\tif (!update->blockable && ret == -EAGAIN) {\n\t\t\tup_read(&hmm->mirrors_sem);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\tup_read(&hmm->mirrors_sem);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!hmm"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic int hmm_invalidate_range_start(struct mmu_notifier *mn,\n\t\t\t\t      struct mm_struct *mm,\n\t\t\t\t      unsigned long start,\n\t\t\t\t      unsigned long end,\n\t\t\t\t      bool blockable)\n{\n\tstruct hmm_update update;\n\tstruct hmm *hmm = mm->hmm;\n\n\tVM_BUG_ON(!hmm);\n\n\tupdate.start = start;\n\tupdate.end = end;\n\tupdate.event = HMM_UPDATE_INVALIDATE;\n\tupdate.blockable = blockable;\n\treturn hmm_invalidate_range(hmm, true, &update);\n}"
  },
  {
    "function_name": "hmm_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "165-189",
    "snippet": "static void hmm_release(struct mmu_notifier *mn, struct mm_struct *mm)\n{\n\tstruct hmm_mirror *mirror;\n\tstruct hmm *hmm = mm->hmm;\n\n\tdown_write(&hmm->mirrors_sem);\n\tmirror = list_first_entry_or_null(&hmm->mirrors, struct hmm_mirror,\n\t\t\t\t\t  list);\n\twhile (mirror) {\n\t\tlist_del_init(&mirror->list);\n\t\tif (mirror->ops->release) {\n\t\t\t/*\n\t\t\t * Drop mirrors_sem so callback can wait on any pending\n\t\t\t * work that might itself trigger mmu_notifier callback\n\t\t\t * and thus would deadlock with us.\n\t\t\t */\n\t\t\tup_write(&hmm->mirrors_sem);\n\t\t\tmirror->ops->release(mirror);\n\t\t\tdown_write(&hmm->mirrors_sem);\n\t\t}\n\t\tmirror = list_first_entry_or_null(&hmm->mirrors,\n\t\t\t\t\t\t  struct hmm_mirror, list);\n\t}\n\tup_write(&hmm->mirrors_sem);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&hmm->mirrors_sem"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry_or_null",
          "args": [
            "&hmm->mirrors",
            "structhmm_mirror",
            "list"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&hmm->mirrors_sem"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mirror->ops->release",
          "args": [
            "mirror"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&hmm->mirrors_sem"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&mirror->list"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry_or_null",
          "args": [
            "&hmm->mirrors",
            "structhmm_mirror",
            "list"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&hmm->mirrors_sem"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic void hmm_release(struct mmu_notifier *mn, struct mm_struct *mm)\n{\n\tstruct hmm_mirror *mirror;\n\tstruct hmm *hmm = mm->hmm;\n\n\tdown_write(&hmm->mirrors_sem);\n\tmirror = list_first_entry_or_null(&hmm->mirrors, struct hmm_mirror,\n\t\t\t\t\t  list);\n\twhile (mirror) {\n\t\tlist_del_init(&mirror->list);\n\t\tif (mirror->ops->release) {\n\t\t\t/*\n\t\t\t * Drop mirrors_sem so callback can wait on any pending\n\t\t\t * work that might itself trigger mmu_notifier callback\n\t\t\t * and thus would deadlock with us.\n\t\t\t */\n\t\t\tup_write(&hmm->mirrors_sem);\n\t\t\tmirror->ops->release(mirror);\n\t\t\tdown_write(&hmm->mirrors_sem);\n\t\t}\n\t\tmirror = list_first_entry_or_null(&hmm->mirrors,\n\t\t\t\t\t\t  struct hmm_mirror, list);\n\t}\n\tup_write(&hmm->mirrors_sem);\n}"
  },
  {
    "function_name": "hmm_invalidate_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "126-163",
    "snippet": "static int hmm_invalidate_range(struct hmm *hmm, bool device,\n\t\t\t\tconst struct hmm_update *update)\n{\n\tstruct hmm_mirror *mirror;\n\tstruct hmm_range *range;\n\n\tspin_lock(&hmm->lock);\n\tlist_for_each_entry(range, &hmm->ranges, list) {\n\t\tunsigned long addr, idx, npages;\n\n\t\tif (update->end < range->start || update->start >= range->end)\n\t\t\tcontinue;\n\n\t\trange->valid = false;\n\t\taddr = max(update->start, range->start);\n\t\tidx = (addr - range->start) >> PAGE_SHIFT;\n\t\tnpages = (min(range->end, update->end) - addr) >> PAGE_SHIFT;\n\t\tmemset(&range->pfns[idx], 0, sizeof(*range->pfns) * npages);\n\t}\n\tspin_unlock(&hmm->lock);\n\n\tif (!device)\n\t\treturn 0;\n\n\tdown_read(&hmm->mirrors_sem);\n\tlist_for_each_entry(mirror, &hmm->mirrors, list) {\n\t\tint ret;\n\n\t\tret = mirror->ops->sync_cpu_device_pagetables(mirror, update);\n\t\tif (!update->blockable && ret == -EAGAIN) {\n\t\t\tup_read(&hmm->mirrors_sem);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\tup_read(&hmm->mirrors_sem);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&hmm->mirrors_sem"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&hmm->mirrors_sem"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mirror->ops->sync_cpu_device_pagetables",
          "args": [
            "mirror",
            "update"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "mirror",
            "&hmm->mirrors",
            "list"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&hmm->mirrors_sem"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hmm->lock"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&range->pfns[idx]",
            "0",
            "sizeof(*range->pfns) * npages"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "range->end",
            "update->end"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "update->start",
            "range->start"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "range",
            "&hmm->ranges",
            "list"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hmm->lock"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic int hmm_invalidate_range(struct hmm *hmm, bool device,\n\t\t\t\tconst struct hmm_update *update)\n{\n\tstruct hmm_mirror *mirror;\n\tstruct hmm_range *range;\n\n\tspin_lock(&hmm->lock);\n\tlist_for_each_entry(range, &hmm->ranges, list) {\n\t\tunsigned long addr, idx, npages;\n\n\t\tif (update->end < range->start || update->start >= range->end)\n\t\t\tcontinue;\n\n\t\trange->valid = false;\n\t\taddr = max(update->start, range->start);\n\t\tidx = (addr - range->start) >> PAGE_SHIFT;\n\t\tnpages = (min(range->end, update->end) - addr) >> PAGE_SHIFT;\n\t\tmemset(&range->pfns[idx], 0, sizeof(*range->pfns) * npages);\n\t}\n\tspin_unlock(&hmm->lock);\n\n\tif (!device)\n\t\treturn 0;\n\n\tdown_read(&hmm->mirrors_sem);\n\tlist_for_each_entry(mirror, &hmm->mirrors, list) {\n\t\tint ret;\n\n\t\tret = mirror->ops->sync_cpu_device_pagetables(mirror, update);\n\t\tif (!update->blockable && ret == -EAGAIN) {\n\t\t\tup_read(&hmm->mirrors_sem);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\tup_read(&hmm->mirrors_sem);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hmm_mm_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "121-124",
    "snippet": "void hmm_mm_destroy(struct mm_struct *mm)\n{\n\tkfree(mm->hmm);\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mm->hmm"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nvoid hmm_mm_destroy(struct mm_struct *mm)\n{\n\tkfree(mm->hmm);\n}"
  },
  {
    "function_name": "hmm_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hmm.c",
    "lines": "68-119",
    "snippet": "static struct hmm *hmm_register(struct mm_struct *mm)\n{\n\tstruct hmm *hmm = READ_ONCE(mm->hmm);\n\tbool cleanup = false;\n\n\t/*\n\t * The hmm struct can only be freed once the mm_struct goes away,\n\t * hence we should always have pre-allocated an new hmm struct\n\t * above.\n\t */\n\tif (hmm)\n\t\treturn hmm;\n\n\thmm = kmalloc(sizeof(*hmm), GFP_KERNEL);\n\tif (!hmm)\n\t\treturn NULL;\n\tINIT_LIST_HEAD(&hmm->mirrors);\n\tinit_rwsem(&hmm->mirrors_sem);\n\thmm->mmu_notifier.ops = NULL;\n\tINIT_LIST_HEAD(&hmm->ranges);\n\tspin_lock_init(&hmm->lock);\n\thmm->mm = mm;\n\n\tspin_lock(&mm->page_table_lock);\n\tif (!mm->hmm)\n\t\tmm->hmm = hmm;\n\telse\n\t\tcleanup = true;\n\tspin_unlock(&mm->page_table_lock);\n\n\tif (cleanup)\n\t\tgoto error;\n\n\t/*\n\t * We should only get here if hold the mmap_sem in write mode ie on\n\t * registration of first mirror through hmm_mirror_register()\n\t */\n\thmm->mmu_notifier.ops = &hmm_mmu_notifier_ops;\n\tif (__mmu_notifier_register(&hmm->mmu_notifier, mm))\n\t\tgoto error_mm;\n\n\treturn mm->hmm;\n\nerror_mm:\n\tspin_lock(&mm->page_table_lock);\n\tif (mm->hmm == hmm)\n\t\tmm->hmm = NULL;\n\tspin_unlock(&mm->page_table_lock);\nerror:\n\tkfree(hmm);\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/memory_hotplug.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/memremap.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swapops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/init.h>",
      "#include <linux/hmm.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "hmm"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mm->page_table_lock"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mm->page_table_lock"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mmu_notifier_register",
          "args": [
            "&hmm->mmu_notifier",
            "mm"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "__mmu_notifier_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_notifier.c",
          "lines": "324-327",
          "snippet": "int __mmu_notifier_register(struct mmu_notifier *mn, struct mm_struct *mm)\n{\n\treturn do_mmu_notifier_register(mn, mm, 0);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/srcu.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/srcu.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rculist.h>\n\nint __mmu_notifier_register(struct mmu_notifier *mn, struct mm_struct *mm)\n{\n\treturn do_mmu_notifier_register(mn, mm, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mm->page_table_lock"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mm->page_table_lock"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&hmm->lock"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&hmm->ranges"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&hmm->mirrors_sem"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&hmm->mirrors"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*hmm)",
            "GFP_KERNEL"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "__kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3729-3732",
          "snippet": "void *__kmalloc(size_t size, gfp_t flags)\n{\n\treturn __do_kmalloc(size, flags, _RET_IP_);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nvoid *__kmalloc(size_t size, gfp_t flags)\n{\n\treturn __do_kmalloc(size, flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "mm->hmm"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/mmu_notifier.h>\n#include <linux/jump_label.h>\n#include <linux/memremap.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/init.h>\n#include <linux/hmm.h>\n#include <linux/mm.h>\n\nstatic struct hmm *hmm_register(struct mm_struct *mm)\n{\n\tstruct hmm *hmm = READ_ONCE(mm->hmm);\n\tbool cleanup = false;\n\n\t/*\n\t * The hmm struct can only be freed once the mm_struct goes away,\n\t * hence we should always have pre-allocated an new hmm struct\n\t * above.\n\t */\n\tif (hmm)\n\t\treturn hmm;\n\n\thmm = kmalloc(sizeof(*hmm), GFP_KERNEL);\n\tif (!hmm)\n\t\treturn NULL;\n\tINIT_LIST_HEAD(&hmm->mirrors);\n\tinit_rwsem(&hmm->mirrors_sem);\n\thmm->mmu_notifier.ops = NULL;\n\tINIT_LIST_HEAD(&hmm->ranges);\n\tspin_lock_init(&hmm->lock);\n\thmm->mm = mm;\n\n\tspin_lock(&mm->page_table_lock);\n\tif (!mm->hmm)\n\t\tmm->hmm = hmm;\n\telse\n\t\tcleanup = true;\n\tspin_unlock(&mm->page_table_lock);\n\n\tif (cleanup)\n\t\tgoto error;\n\n\t/*\n\t * We should only get here if hold the mmap_sem in write mode ie on\n\t * registration of first mirror through hmm_mirror_register()\n\t */\n\thmm->mmu_notifier.ops = &hmm_mmu_notifier_ops;\n\tif (__mmu_notifier_register(&hmm->mmu_notifier, mm))\n\t\tgoto error_mm;\n\n\treturn mm->hmm;\n\nerror_mm:\n\tspin_lock(&mm->page_table_lock);\n\tif (mm->hmm == hmm)\n\t\tmm->hmm = NULL;\n\tspin_unlock(&mm->page_table_lock);\nerror:\n\tkfree(hmm);\n\treturn NULL;\n}"
  }
]