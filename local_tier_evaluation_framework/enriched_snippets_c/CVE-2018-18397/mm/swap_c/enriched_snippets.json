[
  {
    "function_name": "swap_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "1024-1037",
    "snippet": "void __init swap_setup(void)\n{\n\tunsigned long megs = totalram_pages >> (20 - PAGE_SHIFT);\n\n\t/* Use a smaller cluster for small-memory machines */\n\tif (megs < 16)\n\t\tpage_cluster = 2;\n\telse\n\t\tpage_cluster = 3;\n\t/*\n\t * Right now other parts of the system means that we\n\t * _really_ don't want to cluster much more\n\t */\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int page_cluster;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nint page_cluster;\n\nvoid __init swap_setup(void)\n{\n\tunsigned long megs = totalram_pages >> (20 - PAGE_SHIFT);\n\n\t/* Use a smaller cluster for small-memory machines */\n\tif (megs < 16)\n\t\tpage_cluster = 2;\n\telse\n\t\tpage_cluster = 3;\n\t/*\n\t * Right now other parts of the system means that we\n\t * _really_ don't want to cluster much more\n\t */\n}"
  },
  {
    "function_name": "pagevec_lookup_range_nr_tag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "1012-1019",
    "snippet": "unsigned pagevec_lookup_range_nr_tag(struct pagevec *pvec,\n\t\tstruct address_space *mapping, pgoff_t *index, pgoff_t end,\n\t\txa_mark_t tag, unsigned max_pages)\n{\n\tpvec->nr = find_get_pages_range_tag(mapping, index, end, tag,\n\t\tmin_t(unsigned int, max_pages, PAGEVEC_SIZE), pvec->pages);\n\treturn pagevec_count(pvec);\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "pvec"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_pages_range_tag",
          "args": [
            "mapping",
            "index",
            "end",
            "tag",
            "min_t(unsigned int, max_pages, PAGEVEC_SIZE)",
            "pvec->pages"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "find_get_pages_range_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1815-1877",
          "snippet": "unsigned find_get_pages_range_tag(struct address_space *mapping, pgoff_t *index,\n\t\t\tpgoff_t end, xa_mark_t tag, unsigned int nr_pages,\n\t\t\tstruct page **pages)\n{\n\tXA_STATE(xas, &mapping->i_pages, *index);\n\tstruct page *page;\n\tunsigned ret = 0;\n\n\tif (unlikely(!nr_pages))\n\t\treturn 0;\n\n\trcu_read_lock();\n\txas_for_each_marked(&xas, page, end, tag) {\n\t\tstruct page *head;\n\t\tif (xas_retry(&xas, page))\n\t\t\tcontinue;\n\t\t/*\n\t\t * Shadow entries should never be tagged, but this iteration\n\t\t * is lockless so there is a window for page reclaim to evict\n\t\t * a page we saw tagged.  Skip over it.\n\t\t */\n\t\tif (xa_is_value(page))\n\t\t\tcontinue;\n\n\t\thead = compound_head(page);\n\t\tif (!page_cache_get_speculative(head))\n\t\t\tgoto retry;\n\n\t\t/* The page was split under us? */\n\t\tif (compound_head(page) != head)\n\t\t\tgoto put_page;\n\n\t\t/* Has the page moved? */\n\t\tif (unlikely(page != xas_reload(&xas)))\n\t\t\tgoto put_page;\n\n\t\tpages[ret] = page;\n\t\tif (++ret == nr_pages) {\n\t\t\t*index = page->index + 1;\n\t\t\tgoto out;\n\t\t}\n\t\tcontinue;\nput_page:\n\t\tput_page(head);\nretry:\n\t\txas_reset(&xas);\n\t}\n\n\t/*\n\t * We come here when we got to @end. We take care to not overflow the\n\t * index @index as it confuses some of the callers. This breaks the\n\t * iteration when there is a page at index -1 but that is already\n\t * broken anyway.\n\t */\n\tif (end == (pgoff_t)-1)\n\t\t*index = (pgoff_t)-1;\n\telse\n\t\t*index = end + 1;\nout:\n\trcu_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nunsigned find_get_pages_range_tag(struct address_space *mapping, pgoff_t *index,\n\t\t\tpgoff_t end, xa_mark_t tag, unsigned int nr_pages,\n\t\t\tstruct page **pages)\n{\n\tXA_STATE(xas, &mapping->i_pages, *index);\n\tstruct page *page;\n\tunsigned ret = 0;\n\n\tif (unlikely(!nr_pages))\n\t\treturn 0;\n\n\trcu_read_lock();\n\txas_for_each_marked(&xas, page, end, tag) {\n\t\tstruct page *head;\n\t\tif (xas_retry(&xas, page))\n\t\t\tcontinue;\n\t\t/*\n\t\t * Shadow entries should never be tagged, but this iteration\n\t\t * is lockless so there is a window for page reclaim to evict\n\t\t * a page we saw tagged.  Skip over it.\n\t\t */\n\t\tif (xa_is_value(page))\n\t\t\tcontinue;\n\n\t\thead = compound_head(page);\n\t\tif (!page_cache_get_speculative(head))\n\t\t\tgoto retry;\n\n\t\t/* The page was split under us? */\n\t\tif (compound_head(page) != head)\n\t\t\tgoto put_page;\n\n\t\t/* Has the page moved? */\n\t\tif (unlikely(page != xas_reload(&xas)))\n\t\t\tgoto put_page;\n\n\t\tpages[ret] = page;\n\t\tif (++ret == nr_pages) {\n\t\t\t*index = page->index + 1;\n\t\t\tgoto out;\n\t\t}\n\t\tcontinue;\nput_page:\n\t\tput_page(head);\nretry:\n\t\txas_reset(&xas);\n\t}\n\n\t/*\n\t * We come here when we got to @end. We take care to not overflow the\n\t * index @index as it confuses some of the callers. This breaks the\n\t * iteration when there is a page at index -1 but that is already\n\t * broken anyway.\n\t */\n\tif (end == (pgoff_t)-1)\n\t\t*index = (pgoff_t)-1;\n\telse\n\t\t*index = end + 1;\nout:\n\trcu_read_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "max_pages",
            "PAGEVEC_SIZE"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nunsigned pagevec_lookup_range_nr_tag(struct pagevec *pvec,\n\t\tstruct address_space *mapping, pgoff_t *index, pgoff_t end,\n\t\txa_mark_t tag, unsigned max_pages)\n{\n\tpvec->nr = find_get_pages_range_tag(mapping, index, end, tag,\n\t\tmin_t(unsigned int, max_pages, PAGEVEC_SIZE), pvec->pages);\n\treturn pagevec_count(pvec);\n}"
  },
  {
    "function_name": "pagevec_lookup_range_tag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "1002-1009",
    "snippet": "unsigned pagevec_lookup_range_tag(struct pagevec *pvec,\n\t\tstruct address_space *mapping, pgoff_t *index, pgoff_t end,\n\t\txa_mark_t tag)\n{\n\tpvec->nr = find_get_pages_range_tag(mapping, index, end, tag,\n\t\t\t\t\tPAGEVEC_SIZE, pvec->pages);\n\treturn pagevec_count(pvec);\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "pvec"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_pages_range_tag",
          "args": [
            "mapping",
            "index",
            "end",
            "tag",
            "PAGEVEC_SIZE",
            "pvec->pages"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "find_get_pages_range_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1815-1877",
          "snippet": "unsigned find_get_pages_range_tag(struct address_space *mapping, pgoff_t *index,\n\t\t\tpgoff_t end, xa_mark_t tag, unsigned int nr_pages,\n\t\t\tstruct page **pages)\n{\n\tXA_STATE(xas, &mapping->i_pages, *index);\n\tstruct page *page;\n\tunsigned ret = 0;\n\n\tif (unlikely(!nr_pages))\n\t\treturn 0;\n\n\trcu_read_lock();\n\txas_for_each_marked(&xas, page, end, tag) {\n\t\tstruct page *head;\n\t\tif (xas_retry(&xas, page))\n\t\t\tcontinue;\n\t\t/*\n\t\t * Shadow entries should never be tagged, but this iteration\n\t\t * is lockless so there is a window for page reclaim to evict\n\t\t * a page we saw tagged.  Skip over it.\n\t\t */\n\t\tif (xa_is_value(page))\n\t\t\tcontinue;\n\n\t\thead = compound_head(page);\n\t\tif (!page_cache_get_speculative(head))\n\t\t\tgoto retry;\n\n\t\t/* The page was split under us? */\n\t\tif (compound_head(page) != head)\n\t\t\tgoto put_page;\n\n\t\t/* Has the page moved? */\n\t\tif (unlikely(page != xas_reload(&xas)))\n\t\t\tgoto put_page;\n\n\t\tpages[ret] = page;\n\t\tif (++ret == nr_pages) {\n\t\t\t*index = page->index + 1;\n\t\t\tgoto out;\n\t\t}\n\t\tcontinue;\nput_page:\n\t\tput_page(head);\nretry:\n\t\txas_reset(&xas);\n\t}\n\n\t/*\n\t * We come here when we got to @end. We take care to not overflow the\n\t * index @index as it confuses some of the callers. This breaks the\n\t * iteration when there is a page at index -1 but that is already\n\t * broken anyway.\n\t */\n\tif (end == (pgoff_t)-1)\n\t\t*index = (pgoff_t)-1;\n\telse\n\t\t*index = end + 1;\nout:\n\trcu_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nunsigned find_get_pages_range_tag(struct address_space *mapping, pgoff_t *index,\n\t\t\tpgoff_t end, xa_mark_t tag, unsigned int nr_pages,\n\t\t\tstruct page **pages)\n{\n\tXA_STATE(xas, &mapping->i_pages, *index);\n\tstruct page *page;\n\tunsigned ret = 0;\n\n\tif (unlikely(!nr_pages))\n\t\treturn 0;\n\n\trcu_read_lock();\n\txas_for_each_marked(&xas, page, end, tag) {\n\t\tstruct page *head;\n\t\tif (xas_retry(&xas, page))\n\t\t\tcontinue;\n\t\t/*\n\t\t * Shadow entries should never be tagged, but this iteration\n\t\t * is lockless so there is a window for page reclaim to evict\n\t\t * a page we saw tagged.  Skip over it.\n\t\t */\n\t\tif (xa_is_value(page))\n\t\t\tcontinue;\n\n\t\thead = compound_head(page);\n\t\tif (!page_cache_get_speculative(head))\n\t\t\tgoto retry;\n\n\t\t/* The page was split under us? */\n\t\tif (compound_head(page) != head)\n\t\t\tgoto put_page;\n\n\t\t/* Has the page moved? */\n\t\tif (unlikely(page != xas_reload(&xas)))\n\t\t\tgoto put_page;\n\n\t\tpages[ret] = page;\n\t\tif (++ret == nr_pages) {\n\t\t\t*index = page->index + 1;\n\t\t\tgoto out;\n\t\t}\n\t\tcontinue;\nput_page:\n\t\tput_page(head);\nretry:\n\t\txas_reset(&xas);\n\t}\n\n\t/*\n\t * We come here when we got to @end. We take care to not overflow the\n\t * index @index as it confuses some of the callers. This breaks the\n\t * iteration when there is a page at index -1 but that is already\n\t * broken anyway.\n\t */\n\tif (end == (pgoff_t)-1)\n\t\t*index = (pgoff_t)-1;\n\telse\n\t\t*index = end + 1;\nout:\n\trcu_read_unlock();\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nunsigned pagevec_lookup_range_tag(struct pagevec *pvec,\n\t\tstruct address_space *mapping, pgoff_t *index, pgoff_t end,\n\t\txa_mark_t tag)\n{\n\tpvec->nr = find_get_pages_range_tag(mapping, index, end, tag,\n\t\t\t\t\tPAGEVEC_SIZE, pvec->pages);\n\treturn pagevec_count(pvec);\n}"
  },
  {
    "function_name": "pagevec_lookup_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "993-999",
    "snippet": "unsigned pagevec_lookup_range(struct pagevec *pvec,\n\t\tstruct address_space *mapping, pgoff_t *start, pgoff_t end)\n{\n\tpvec->nr = find_get_pages_range(mapping, start, end, PAGEVEC_SIZE,\n\t\t\t\t\tpvec->pages);\n\treturn pagevec_count(pvec);\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "pvec"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_pages_range",
          "args": [
            "mapping",
            "start",
            "end",
            "PAGEVEC_SIZE",
            "pvec->pages"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "find_get_pages_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1673-1731",
          "snippet": "unsigned find_get_pages_range(struct address_space *mapping, pgoff_t *start,\n\t\t\t      pgoff_t end, unsigned int nr_pages,\n\t\t\t      struct page **pages)\n{\n\tXA_STATE(xas, &mapping->i_pages, *start);\n\tstruct page *page;\n\tunsigned ret = 0;\n\n\tif (unlikely(!nr_pages))\n\t\treturn 0;\n\n\trcu_read_lock();\n\txas_for_each(&xas, page, end) {\n\t\tstruct page *head;\n\t\tif (xas_retry(&xas, page))\n\t\t\tcontinue;\n\t\t/* Skip over shadow, swap and DAX entries */\n\t\tif (xa_is_value(page))\n\t\t\tcontinue;\n\n\t\thead = compound_head(page);\n\t\tif (!page_cache_get_speculative(head))\n\t\t\tgoto retry;\n\n\t\t/* The page was split under us? */\n\t\tif (compound_head(page) != head)\n\t\t\tgoto put_page;\n\n\t\t/* Has the page moved? */\n\t\tif (unlikely(page != xas_reload(&xas)))\n\t\t\tgoto put_page;\n\n\t\tpages[ret] = page;\n\t\tif (++ret == nr_pages) {\n\t\t\t*start = page->index + 1;\n\t\t\tgoto out;\n\t\t}\n\t\tcontinue;\nput_page:\n\t\tput_page(head);\nretry:\n\t\txas_reset(&xas);\n\t}\n\n\t/*\n\t * We come here when there is no page beyond @end. We take care to not\n\t * overflow the index @start as it confuses some of the callers. This\n\t * breaks the iteration when there is a page at index -1 but that is\n\t * already broken anyway.\n\t */\n\tif (end == (pgoff_t)-1)\n\t\t*start = (pgoff_t)-1;\n\telse\n\t\t*start = end + 1;\nout:\n\trcu_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nunsigned find_get_pages_range(struct address_space *mapping, pgoff_t *start,\n\t\t\t      pgoff_t end, unsigned int nr_pages,\n\t\t\t      struct page **pages)\n{\n\tXA_STATE(xas, &mapping->i_pages, *start);\n\tstruct page *page;\n\tunsigned ret = 0;\n\n\tif (unlikely(!nr_pages))\n\t\treturn 0;\n\n\trcu_read_lock();\n\txas_for_each(&xas, page, end) {\n\t\tstruct page *head;\n\t\tif (xas_retry(&xas, page))\n\t\t\tcontinue;\n\t\t/* Skip over shadow, swap and DAX entries */\n\t\tif (xa_is_value(page))\n\t\t\tcontinue;\n\n\t\thead = compound_head(page);\n\t\tif (!page_cache_get_speculative(head))\n\t\t\tgoto retry;\n\n\t\t/* The page was split under us? */\n\t\tif (compound_head(page) != head)\n\t\t\tgoto put_page;\n\n\t\t/* Has the page moved? */\n\t\tif (unlikely(page != xas_reload(&xas)))\n\t\t\tgoto put_page;\n\n\t\tpages[ret] = page;\n\t\tif (++ret == nr_pages) {\n\t\t\t*start = page->index + 1;\n\t\t\tgoto out;\n\t\t}\n\t\tcontinue;\nput_page:\n\t\tput_page(head);\nretry:\n\t\txas_reset(&xas);\n\t}\n\n\t/*\n\t * We come here when there is no page beyond @end. We take care to not\n\t * overflow the index @start as it confuses some of the callers. This\n\t * breaks the iteration when there is a page at index -1 but that is\n\t * already broken anyway.\n\t */\n\tif (end == (pgoff_t)-1)\n\t\t*start = (pgoff_t)-1;\n\telse\n\t\t*start = end + 1;\nout:\n\trcu_read_unlock();\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nunsigned pagevec_lookup_range(struct pagevec *pvec,\n\t\tstruct address_space *mapping, pgoff_t *start, pgoff_t end)\n{\n\tpvec->nr = find_get_pages_range(mapping, start, end, PAGEVEC_SIZE,\n\t\t\t\t\tpvec->pages);\n\treturn pagevec_count(pvec);\n}"
  },
  {
    "function_name": "pagevec_remove_exceptionals",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "961-971",
    "snippet": "void pagevec_remove_exceptionals(struct pagevec *pvec)\n{\n\tint i, j;\n\n\tfor (i = 0, j = 0; i < pagevec_count(pvec); i++) {\n\t\tstruct page *page = pvec->pages[i];\n\t\tif (!xa_is_value(page))\n\t\t\tpvec->pages[j++] = page;\n\t}\n\tpvec->nr = j;\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xa_is_value",
          "args": [
            "page"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "pvec"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid pagevec_remove_exceptionals(struct pagevec *pvec)\n{\n\tint i, j;\n\n\tfor (i = 0, j = 0; i < pagevec_count(pvec); i++) {\n\t\tstruct page *page = pvec->pages[i];\n\t\tif (!xa_is_value(page))\n\t\t\tpvec->pages[j++] = page;\n\t}\n\tpvec->nr = j;\n}"
  },
  {
    "function_name": "pagevec_lookup_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "942-950",
    "snippet": "unsigned pagevec_lookup_entries(struct pagevec *pvec,\n\t\t\t\tstruct address_space *mapping,\n\t\t\t\tpgoff_t start, unsigned nr_entries,\n\t\t\t\tpgoff_t *indices)\n{\n\tpvec->nr = find_get_entries(mapping, start, nr_entries,\n\t\t\t\t    pvec->pages, indices);\n\treturn pagevec_count(pvec);\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "pvec"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_entries",
          "args": [
            "mapping",
            "start",
            "nr_entries",
            "pvec->pages",
            "indices"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "find_get_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1601-1650",
          "snippet": "unsigned find_get_entries(struct address_space *mapping,\n\t\t\t  pgoff_t start, unsigned int nr_entries,\n\t\t\t  struct page **entries, pgoff_t *indices)\n{\n\tXA_STATE(xas, &mapping->i_pages, start);\n\tstruct page *page;\n\tunsigned int ret = 0;\n\n\tif (!nr_entries)\n\t\treturn 0;\n\n\trcu_read_lock();\n\txas_for_each(&xas, page, ULONG_MAX) {\n\t\tstruct page *head;\n\t\tif (xas_retry(&xas, page))\n\t\t\tcontinue;\n\t\t/*\n\t\t * A shadow entry of a recently evicted page, a swap\n\t\t * entry from shmem/tmpfs or a DAX entry.  Return it\n\t\t * without attempting to raise page count.\n\t\t */\n\t\tif (xa_is_value(page))\n\t\t\tgoto export;\n\n\t\thead = compound_head(page);\n\t\tif (!page_cache_get_speculative(head))\n\t\t\tgoto retry;\n\n\t\t/* The page was split under us? */\n\t\tif (compound_head(page) != head)\n\t\t\tgoto put_page;\n\n\t\t/* Has the page moved? */\n\t\tif (unlikely(page != xas_reload(&xas)))\n\t\t\tgoto put_page;\n\nexport:\n\t\tindices[ret] = xas.xa_index;\n\t\tentries[ret] = page;\n\t\tif (++ret == nr_entries)\n\t\t\tbreak;\n\t\tcontinue;\nput_page:\n\t\tput_page(head);\nretry:\n\t\txas_reset(&xas);\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nunsigned find_get_entries(struct address_space *mapping,\n\t\t\t  pgoff_t start, unsigned int nr_entries,\n\t\t\t  struct page **entries, pgoff_t *indices)\n{\n\tXA_STATE(xas, &mapping->i_pages, start);\n\tstruct page *page;\n\tunsigned int ret = 0;\n\n\tif (!nr_entries)\n\t\treturn 0;\n\n\trcu_read_lock();\n\txas_for_each(&xas, page, ULONG_MAX) {\n\t\tstruct page *head;\n\t\tif (xas_retry(&xas, page))\n\t\t\tcontinue;\n\t\t/*\n\t\t * A shadow entry of a recently evicted page, a swap\n\t\t * entry from shmem/tmpfs or a DAX entry.  Return it\n\t\t * without attempting to raise page count.\n\t\t */\n\t\tif (xa_is_value(page))\n\t\t\tgoto export;\n\n\t\thead = compound_head(page);\n\t\tif (!page_cache_get_speculative(head))\n\t\t\tgoto retry;\n\n\t\t/* The page was split under us? */\n\t\tif (compound_head(page) != head)\n\t\t\tgoto put_page;\n\n\t\t/* Has the page moved? */\n\t\tif (unlikely(page != xas_reload(&xas)))\n\t\t\tgoto put_page;\n\nexport:\n\t\tindices[ret] = xas.xa_index;\n\t\tentries[ret] = page;\n\t\tif (++ret == nr_entries)\n\t\t\tbreak;\n\t\tcontinue;\nput_page:\n\t\tput_page(head);\nretry:\n\t\txas_reset(&xas);\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nunsigned pagevec_lookup_entries(struct pagevec *pvec,\n\t\t\t\tstruct address_space *mapping,\n\t\t\t\tpgoff_t start, unsigned nr_entries,\n\t\t\t\tpgoff_t *indices)\n{\n\tpvec->nr = find_get_entries(mapping, start, nr_entries,\n\t\t\t\t    pvec->pages, indices);\n\treturn pagevec_count(pvec);\n}"
  },
  {
    "function_name": "__pagevec_lru_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "916-919",
    "snippet": "void __pagevec_lru_add(struct pagevec *pvec)\n{\n\tpagevec_lru_move_fn(pvec, __pagevec_lru_add_fn, NULL);\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pagevec_lru_move_fn",
          "args": [
            "pvec",
            "__pagevec_lru_add_fn",
            "NULL"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "pagevec_lru_move_fn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "188-215",
          "snippet": "static void pagevec_lru_move_fn(struct pagevec *pvec,\n\tvoid (*move_fn)(struct page *page, struct lruvec *lruvec, void *arg),\n\tvoid *arg)\n{\n\tint i;\n\tstruct pglist_data *pgdat = NULL;\n\tstruct lruvec *lruvec;\n\tunsigned long flags = 0;\n\n\tfor (i = 0; i < pagevec_count(pvec); i++) {\n\t\tstruct page *page = pvec->pages[i];\n\t\tstruct pglist_data *pagepgdat = page_pgdat(page);\n\n\t\tif (pagepgdat != pgdat) {\n\t\t\tif (pgdat)\n\t\t\t\tspin_unlock_irqrestore(&pgdat->lru_lock, flags);\n\t\t\tpgdat = pagepgdat;\n\t\t\tspin_lock_irqsave(&pgdat->lru_lock, flags);\n\t\t}\n\n\t\tlruvec = mem_cgroup_page_lruvec(page, pgdat);\n\t\t(*move_fn)(page, lruvec, arg);\n\t}\n\tif (pgdat)\n\t\tspin_unlock_irqrestore(&pgdat->lru_lock, flags);\n\trelease_pages(pvec->pages, pvec->nr);\n\tpagevec_reinit(pvec);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void pagevec_lru_move_fn(struct pagevec *pvec,\n\tvoid (*move_fn)(struct page *page, struct lruvec *lruvec, void *arg),\n\tvoid *arg)\n{\n\tint i;\n\tstruct pglist_data *pgdat = NULL;\n\tstruct lruvec *lruvec;\n\tunsigned long flags = 0;\n\n\tfor (i = 0; i < pagevec_count(pvec); i++) {\n\t\tstruct page *page = pvec->pages[i];\n\t\tstruct pglist_data *pagepgdat = page_pgdat(page);\n\n\t\tif (pagepgdat != pgdat) {\n\t\t\tif (pgdat)\n\t\t\t\tspin_unlock_irqrestore(&pgdat->lru_lock, flags);\n\t\t\tpgdat = pagepgdat;\n\t\t\tspin_lock_irqsave(&pgdat->lru_lock, flags);\n\t\t}\n\n\t\tlruvec = mem_cgroup_page_lruvec(page, pgdat);\n\t\t(*move_fn)(page, lruvec, arg);\n\t}\n\tif (pgdat)\n\t\tspin_unlock_irqrestore(&pgdat->lru_lock, flags);\n\trelease_pages(pvec->pages, pvec->nr);\n\tpagevec_reinit(pvec);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid __pagevec_lru_add(struct pagevec *pvec)\n{\n\tpagevec_lru_move_fn(pvec, __pagevec_lru_add_fn, NULL);\n}"
  },
  {
    "function_name": "__pagevec_lru_add_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "857-910",
    "snippet": "static void __pagevec_lru_add_fn(struct page *page, struct lruvec *lruvec,\n\t\t\t\t void *arg)\n{\n\tenum lru_list lru;\n\tint was_unevictable = TestClearPageUnevictable(page);\n\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\n\tSetPageLRU(page);\n\t/*\n\t * Page becomes evictable in two ways:\n\t * 1) Within LRU lock [munlock_vma_pages() and __munlock_pagevec()].\n\t * 2) Before acquiring LRU lock to put the page to correct LRU and then\n\t *   a) do PageLRU check with lock [check_move_unevictable_pages]\n\t *   b) do PageLRU check before lock [clear_page_mlock]\n\t *\n\t * (1) & (2a) are ok as LRU lock will serialize them. For (2b), we need\n\t * following strict ordering:\n\t *\n\t * #0: __pagevec_lru_add_fn\t\t#1: clear_page_mlock\n\t *\n\t * SetPageLRU()\t\t\t\tTestClearPageMlocked()\n\t * smp_mb() // explicit ordering\t// above provides strict\n\t *\t\t\t\t\t// ordering\n\t * PageMlocked()\t\t\tPageLRU()\n\t *\n\t *\n\t * if '#1' does not observe setting of PG_lru by '#0' and fails\n\t * isolation, the explicit barrier will make sure that page_evictable\n\t * check will put the page in correct LRU. Without smp_mb(), SetPageLRU\n\t * can be reordered after PageMlocked check and can make '#1' to fail\n\t * the isolation of the page whose Mlocked bit is cleared (#0 is also\n\t * looking at the same page) and the evictable page will be stranded\n\t * in an unevictable LRU.\n\t */\n\tsmp_mb();\n\n\tif (page_evictable(page)) {\n\t\tlru = page_lru(page);\n\t\tupdate_page_reclaim_stat(lruvec, page_is_file_cache(page),\n\t\t\t\t\t PageActive(page));\n\t\tif (was_unevictable)\n\t\t\tcount_vm_event(UNEVICTABLE_PGRESCUED);\n\t} else {\n\t\tlru = LRU_UNEVICTABLE;\n\t\tClearPageActive(page);\n\t\tSetPageUnevictable(page);\n\t\tif (!was_unevictable)\n\t\t\tcount_vm_event(UNEVICTABLE_PGCULLED);\n\t}\n\n\tadd_page_to_lru_list(page, lruvec, lru);\n\ttrace_mm_lru_insertion(page, lru);\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_mm_lru_insertion",
          "args": [
            "page",
            "lru"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_page_to_lru_list",
          "args": [
            "page",
            "lruvec",
            "lru"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "UNEVICTABLE_PGCULLED"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUnevictable",
          "args": [
            "page"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageActive",
          "args": [
            "page"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "UNEVICTABLE_PGRESCUED"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_page_reclaim_stat",
          "args": [
            "lruvec",
            "page_is_file_cache(page)",
            "PageActive(page)"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "update_page_reclaim_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "263-271",
          "snippet": "static void update_page_reclaim_stat(struct lruvec *lruvec,\n\t\t\t\t     int file, int rotated)\n{\n\tstruct zone_reclaim_stat *reclaim_stat = &lruvec->reclaim_stat;\n\n\treclaim_stat->recent_scanned[file]++;\n\tif (rotated)\n\t\treclaim_stat->recent_rotated[file]++;\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void update_page_reclaim_stat(struct lruvec *lruvec,\n\t\t\t\t     int file, int rotated)\n{\n\tstruct zone_reclaim_stat *reclaim_stat = &lruvec->reclaim_stat;\n\n\treclaim_stat->recent_scanned[file]++;\n\tif (rotated)\n\t\treclaim_stat->recent_rotated[file]++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageActive",
          "args": [
            "page"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_is_file_cache",
          "args": [
            "page"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_lru",
          "args": [
            "page"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_evictable",
          "args": [
            "page"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "page_evictable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "4174-4183",
          "snippet": "int page_evictable(struct page *page)\n{\n\tint ret;\n\n\t/* Prevent address_space of inode and swap cache from being freed */\n\trcu_read_lock();\n\tret = !mapping_unevictable(page_mapping(page)) && !PageMlocked(page);\n\trcu_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint page_evictable(struct page *page)\n{\n\tint ret;\n\n\t/* Prevent address_space of inode and swap cache from being freed */\n\trcu_read_lock();\n\tret = !mapping_unevictable(page_mapping(page)) && !PageMlocked(page);\n\trcu_read_unlock();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageLRU",
          "args": [
            "page"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageLRU(page)",
            "page"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestClearPageUnevictable",
          "args": [
            "page"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void __pagevec_lru_add_fn(struct page *page, struct lruvec *lruvec,\n\t\t\t\t void *arg)\n{\n\tenum lru_list lru;\n\tint was_unevictable = TestClearPageUnevictable(page);\n\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\n\tSetPageLRU(page);\n\t/*\n\t * Page becomes evictable in two ways:\n\t * 1) Within LRU lock [munlock_vma_pages() and __munlock_pagevec()].\n\t * 2) Before acquiring LRU lock to put the page to correct LRU and then\n\t *   a) do PageLRU check with lock [check_move_unevictable_pages]\n\t *   b) do PageLRU check before lock [clear_page_mlock]\n\t *\n\t * (1) & (2a) are ok as LRU lock will serialize them. For (2b), we need\n\t * following strict ordering:\n\t *\n\t * #0: __pagevec_lru_add_fn\t\t#1: clear_page_mlock\n\t *\n\t * SetPageLRU()\t\t\t\tTestClearPageMlocked()\n\t * smp_mb() // explicit ordering\t// above provides strict\n\t *\t\t\t\t\t// ordering\n\t * PageMlocked()\t\t\tPageLRU()\n\t *\n\t *\n\t * if '#1' does not observe setting of PG_lru by '#0' and fails\n\t * isolation, the explicit barrier will make sure that page_evictable\n\t * check will put the page in correct LRU. Without smp_mb(), SetPageLRU\n\t * can be reordered after PageMlocked check and can make '#1' to fail\n\t * the isolation of the page whose Mlocked bit is cleared (#0 is also\n\t * looking at the same page) and the evictable page will be stranded\n\t * in an unevictable LRU.\n\t */\n\tsmp_mb();\n\n\tif (page_evictable(page)) {\n\t\tlru = page_lru(page);\n\t\tupdate_page_reclaim_stat(lruvec, page_is_file_cache(page),\n\t\t\t\t\t PageActive(page));\n\t\tif (was_unevictable)\n\t\t\tcount_vm_event(UNEVICTABLE_PGRESCUED);\n\t} else {\n\t\tlru = LRU_UNEVICTABLE;\n\t\tClearPageActive(page);\n\t\tSetPageUnevictable(page);\n\t\tif (!was_unevictable)\n\t\t\tcount_vm_event(UNEVICTABLE_PGCULLED);\n\t}\n\n\tadd_page_to_lru_list(page, lruvec, lru);\n\ttrace_mm_lru_insertion(page, lru);\n}"
  },
  {
    "function_name": "lru_add_page_tail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "818-854",
    "snippet": "void lru_add_page_tail(struct page *page, struct page *page_tail,\n\t\t       struct lruvec *lruvec, struct list_head *list)\n{\n\tconst int file = 0;\n\n\tVM_BUG_ON_PAGE(!PageHead(page), page);\n\tVM_BUG_ON_PAGE(PageCompound(page_tail), page);\n\tVM_BUG_ON_PAGE(PageLRU(page_tail), page);\n\tVM_BUG_ON(NR_CPUS != 1 &&\n\t\t  !spin_is_locked(&lruvec_pgdat(lruvec)->lru_lock));\n\n\tif (!list)\n\t\tSetPageLRU(page_tail);\n\n\tif (likely(PageLRU(page)))\n\t\tlist_add_tail(&page_tail->lru, &page->lru);\n\telse if (list) {\n\t\t/* page reclaim is reclaiming a huge page */\n\t\tget_page(page_tail);\n\t\tlist_add_tail(&page_tail->lru, list);\n\t} else {\n\t\tstruct list_head *list_head;\n\t\t/*\n\t\t * Head page has not yet been counted, as an hpage,\n\t\t * so we must account for each subpage individually.\n\t\t *\n\t\t * Use the standard add function to put page_tail on the list,\n\t\t * but then correct its position so they all end up in order.\n\t\t */\n\t\tadd_page_to_lru_list(page_tail, lruvec, page_lru(page_tail));\n\t\tlist_head = page_tail->lru.prev;\n\t\tlist_move_tail(&page_tail->lru, list_head);\n\t}\n\n\tif (!PageUnevictable(page))\n\t\tupdate_page_reclaim_stat(lruvec, file, PageActive(page_tail));\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_page_reclaim_stat",
          "args": [
            "lruvec",
            "file",
            "PageActive(page_tail)"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "update_page_reclaim_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "263-271",
          "snippet": "static void update_page_reclaim_stat(struct lruvec *lruvec,\n\t\t\t\t     int file, int rotated)\n{\n\tstruct zone_reclaim_stat *reclaim_stat = &lruvec->reclaim_stat;\n\n\treclaim_stat->recent_scanned[file]++;\n\tif (rotated)\n\t\treclaim_stat->recent_rotated[file]++;\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void update_page_reclaim_stat(struct lruvec *lruvec,\n\t\t\t\t     int file, int rotated)\n{\n\tstruct zone_reclaim_stat *reclaim_stat = &lruvec->reclaim_stat;\n\n\treclaim_stat->recent_scanned[file]++;\n\tif (rotated)\n\t\treclaim_stat->recent_rotated[file]++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageActive",
          "args": [
            "page_tail"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUnevictable",
          "args": [
            "page"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&page_tail->lru",
            "list_head"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_page_to_lru_list",
          "args": [
            "page_tail",
            "lruvec",
            "page_lru(page_tail)"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_lru",
          "args": [
            "page_tail"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&page_tail->lru",
            "list"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "page_tail"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&page_tail->lru",
            "&page->lru"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "PageLRU(page)"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageLRU",
          "args": [
            "page_tail"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "NR_CPUS != 1 &&\n\t\t  !spin_is_locked(&lruvec_pgdat(lruvec)->lru_lock)"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_is_locked",
          "args": [
            "&lruvec_pgdat(lruvec)->lru_lock"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lruvec_pgdat",
          "args": [
            "lruvec"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageLRU(page_tail)",
            "page"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page_tail"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageCompound(page_tail)",
            "page"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "page_tail"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageHead(page)",
            "page"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHead",
          "args": [
            "page"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "PageHeadHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "1350-1356",
          "snippet": "int PageHeadHuge(struct page *page_head)\n{\n\tif (!PageHead(page_head))\n\t\treturn 0;\n\n\treturn get_compound_page_dtor(page_head) == free_huge_page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nint PageHeadHuge(struct page *page_head)\n{\n\tif (!PageHead(page_head))\n\t\treturn 0;\n\n\treturn get_compound_page_dtor(page_head) == free_huge_page;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid lru_add_page_tail(struct page *page, struct page *page_tail,\n\t\t       struct lruvec *lruvec, struct list_head *list)\n{\n\tconst int file = 0;\n\n\tVM_BUG_ON_PAGE(!PageHead(page), page);\n\tVM_BUG_ON_PAGE(PageCompound(page_tail), page);\n\tVM_BUG_ON_PAGE(PageLRU(page_tail), page);\n\tVM_BUG_ON(NR_CPUS != 1 &&\n\t\t  !spin_is_locked(&lruvec_pgdat(lruvec)->lru_lock));\n\n\tif (!list)\n\t\tSetPageLRU(page_tail);\n\n\tif (likely(PageLRU(page)))\n\t\tlist_add_tail(&page_tail->lru, &page->lru);\n\telse if (list) {\n\t\t/* page reclaim is reclaiming a huge page */\n\t\tget_page(page_tail);\n\t\tlist_add_tail(&page_tail->lru, list);\n\t} else {\n\t\tstruct list_head *list_head;\n\t\t/*\n\t\t * Head page has not yet been counted, as an hpage,\n\t\t * so we must account for each subpage individually.\n\t\t *\n\t\t * Use the standard add function to put page_tail on the list,\n\t\t * but then correct its position so they all end up in order.\n\t\t */\n\t\tadd_page_to_lru_list(page_tail, lruvec, page_lru(page_tail));\n\t\tlist_head = page_tail->lru.prev;\n\t\tlist_move_tail(&page_tail->lru, list_head);\n\t}\n\n\tif (!PageUnevictable(page))\n\t\tupdate_page_reclaim_stat(lruvec, file, PageActive(page_tail));\n}"
  },
  {
    "function_name": "__pagevec_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "805-813",
    "snippet": "void __pagevec_release(struct pagevec *pvec)\n{\n\tif (!pvec->percpu_pvec_drained) {\n\t\tlru_add_drain();\n\t\tpvec->percpu_pvec_drained = true;\n\t}\n\trelease_pages(pvec->pages, pagevec_count(pvec));\n\tpagevec_reinit(pvec);\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pagevec_reinit",
          "args": [
            "pvec"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "release_pages",
          "args": [
            "pvec->pages",
            "pagevec_count(pvec)"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "release_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "714-792",
          "snippet": "void release_pages(struct page **pages, int nr)\n{\n\tint i;\n\tLIST_HEAD(pages_to_free);\n\tstruct pglist_data *locked_pgdat = NULL;\n\tstruct lruvec *lruvec;\n\tunsigned long uninitialized_var(flags);\n\tunsigned int uninitialized_var(lock_batch);\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct page *page = pages[i];\n\n\t\t/*\n\t\t * Make sure the IRQ-safe lock-holding time does not get\n\t\t * excessive with a continuous string of pages from the\n\t\t * same pgdat. The lock is held only if pgdat != NULL.\n\t\t */\n\t\tif (locked_pgdat && ++lock_batch == SWAP_CLUSTER_MAX) {\n\t\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock, flags);\n\t\t\tlocked_pgdat = NULL;\n\t\t}\n\n\t\tif (is_huge_zero_page(page))\n\t\t\tcontinue;\n\n\t\t/* Device public page can not be huge page */\n\t\tif (is_device_public_page(page)) {\n\t\t\tif (locked_pgdat) {\n\t\t\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock,\n\t\t\t\t\t\t       flags);\n\t\t\t\tlocked_pgdat = NULL;\n\t\t\t}\n\t\t\tput_devmap_managed_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpage = compound_head(page);\n\t\tif (!put_page_testzero(page))\n\t\t\tcontinue;\n\n\t\tif (PageCompound(page)) {\n\t\t\tif (locked_pgdat) {\n\t\t\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock, flags);\n\t\t\t\tlocked_pgdat = NULL;\n\t\t\t}\n\t\t\t__put_compound_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (PageLRU(page)) {\n\t\t\tstruct pglist_data *pgdat = page_pgdat(page);\n\n\t\t\tif (pgdat != locked_pgdat) {\n\t\t\t\tif (locked_pgdat)\n\t\t\t\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock,\n\t\t\t\t\t\t\t\t\tflags);\n\t\t\t\tlock_batch = 0;\n\t\t\t\tlocked_pgdat = pgdat;\n\t\t\t\tspin_lock_irqsave(&locked_pgdat->lru_lock, flags);\n\t\t\t}\n\n\t\t\tlruvec = mem_cgroup_page_lruvec(page, locked_pgdat);\n\t\t\tVM_BUG_ON_PAGE(!PageLRU(page), page);\n\t\t\t__ClearPageLRU(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, page_off_lru(page));\n\t\t}\n\n\t\t/* Clear Active bit in case of parallel mark_page_accessed */\n\t\t__ClearPageActive(page);\n\t\t__ClearPageWaiters(page);\n\n\t\tlist_add(&page->lru, &pages_to_free);\n\t}\n\tif (locked_pgdat)\n\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock, flags);\n\n\tmem_cgroup_uncharge_list(&pages_to_free);\n\tfree_unref_page_list(&pages_to_free);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid release_pages(struct page **pages, int nr)\n{\n\tint i;\n\tLIST_HEAD(pages_to_free);\n\tstruct pglist_data *locked_pgdat = NULL;\n\tstruct lruvec *lruvec;\n\tunsigned long uninitialized_var(flags);\n\tunsigned int uninitialized_var(lock_batch);\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct page *page = pages[i];\n\n\t\t/*\n\t\t * Make sure the IRQ-safe lock-holding time does not get\n\t\t * excessive with a continuous string of pages from the\n\t\t * same pgdat. The lock is held only if pgdat != NULL.\n\t\t */\n\t\tif (locked_pgdat && ++lock_batch == SWAP_CLUSTER_MAX) {\n\t\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock, flags);\n\t\t\tlocked_pgdat = NULL;\n\t\t}\n\n\t\tif (is_huge_zero_page(page))\n\t\t\tcontinue;\n\n\t\t/* Device public page can not be huge page */\n\t\tif (is_device_public_page(page)) {\n\t\t\tif (locked_pgdat) {\n\t\t\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock,\n\t\t\t\t\t\t       flags);\n\t\t\t\tlocked_pgdat = NULL;\n\t\t\t}\n\t\t\tput_devmap_managed_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpage = compound_head(page);\n\t\tif (!put_page_testzero(page))\n\t\t\tcontinue;\n\n\t\tif (PageCompound(page)) {\n\t\t\tif (locked_pgdat) {\n\t\t\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock, flags);\n\t\t\t\tlocked_pgdat = NULL;\n\t\t\t}\n\t\t\t__put_compound_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (PageLRU(page)) {\n\t\t\tstruct pglist_data *pgdat = page_pgdat(page);\n\n\t\t\tif (pgdat != locked_pgdat) {\n\t\t\t\tif (locked_pgdat)\n\t\t\t\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock,\n\t\t\t\t\t\t\t\t\tflags);\n\t\t\t\tlock_batch = 0;\n\t\t\t\tlocked_pgdat = pgdat;\n\t\t\t\tspin_lock_irqsave(&locked_pgdat->lru_lock, flags);\n\t\t\t}\n\n\t\t\tlruvec = mem_cgroup_page_lruvec(page, locked_pgdat);\n\t\t\tVM_BUG_ON_PAGE(!PageLRU(page), page);\n\t\t\t__ClearPageLRU(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, page_off_lru(page));\n\t\t}\n\n\t\t/* Clear Active bit in case of parallel mark_page_accessed */\n\t\t__ClearPageActive(page);\n\t\t__ClearPageWaiters(page);\n\n\t\tlist_add(&page->lru, &pages_to_free);\n\t}\n\tif (locked_pgdat)\n\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock, flags);\n\n\tmem_cgroup_uncharge_list(&pages_to_free);\n\tfree_unref_page_list(&pages_to_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "pvec"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lru_add_drain",
          "args": [],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "lru_add_drain_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "670-704",
          "snippet": "void lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);",
            "static DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);",
            "static DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\nstatic DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);\nstatic DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);\n\nvoid lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid __pagevec_release(struct pagevec *pvec)\n{\n\tif (!pvec->percpu_pvec_drained) {\n\t\tlru_add_drain();\n\t\tpvec->percpu_pvec_drained = true;\n\t}\n\trelease_pages(pvec->pages, pagevec_count(pvec));\n\tpagevec_reinit(pvec);\n}"
  },
  {
    "function_name": "release_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "714-792",
    "snippet": "void release_pages(struct page **pages, int nr)\n{\n\tint i;\n\tLIST_HEAD(pages_to_free);\n\tstruct pglist_data *locked_pgdat = NULL;\n\tstruct lruvec *lruvec;\n\tunsigned long uninitialized_var(flags);\n\tunsigned int uninitialized_var(lock_batch);\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct page *page = pages[i];\n\n\t\t/*\n\t\t * Make sure the IRQ-safe lock-holding time does not get\n\t\t * excessive with a continuous string of pages from the\n\t\t * same pgdat. The lock is held only if pgdat != NULL.\n\t\t */\n\t\tif (locked_pgdat && ++lock_batch == SWAP_CLUSTER_MAX) {\n\t\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock, flags);\n\t\t\tlocked_pgdat = NULL;\n\t\t}\n\n\t\tif (is_huge_zero_page(page))\n\t\t\tcontinue;\n\n\t\t/* Device public page can not be huge page */\n\t\tif (is_device_public_page(page)) {\n\t\t\tif (locked_pgdat) {\n\t\t\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock,\n\t\t\t\t\t\t       flags);\n\t\t\t\tlocked_pgdat = NULL;\n\t\t\t}\n\t\t\tput_devmap_managed_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpage = compound_head(page);\n\t\tif (!put_page_testzero(page))\n\t\t\tcontinue;\n\n\t\tif (PageCompound(page)) {\n\t\t\tif (locked_pgdat) {\n\t\t\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock, flags);\n\t\t\t\tlocked_pgdat = NULL;\n\t\t\t}\n\t\t\t__put_compound_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (PageLRU(page)) {\n\t\t\tstruct pglist_data *pgdat = page_pgdat(page);\n\n\t\t\tif (pgdat != locked_pgdat) {\n\t\t\t\tif (locked_pgdat)\n\t\t\t\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock,\n\t\t\t\t\t\t\t\t\tflags);\n\t\t\t\tlock_batch = 0;\n\t\t\t\tlocked_pgdat = pgdat;\n\t\t\t\tspin_lock_irqsave(&locked_pgdat->lru_lock, flags);\n\t\t\t}\n\n\t\t\tlruvec = mem_cgroup_page_lruvec(page, locked_pgdat);\n\t\t\tVM_BUG_ON_PAGE(!PageLRU(page), page);\n\t\t\t__ClearPageLRU(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, page_off_lru(page));\n\t\t}\n\n\t\t/* Clear Active bit in case of parallel mark_page_accessed */\n\t\t__ClearPageActive(page);\n\t\t__ClearPageWaiters(page);\n\n\t\tlist_add(&page->lru, &pages_to_free);\n\t}\n\tif (locked_pgdat)\n\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock, flags);\n\n\tmem_cgroup_uncharge_list(&pages_to_free);\n\tfree_unref_page_list(&pages_to_free);\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_unref_page_list",
          "args": [
            "&pages_to_free"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "free_unref_page_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2803-2836",
          "snippet": "void free_unref_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\tunsigned long flags, pfn;\n\tint batch_count = 0;\n\n\t/* Prepare pages for freeing */\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tpfn = page_to_pfn(page);\n\t\tif (!free_unref_page_prepare(page, pfn))\n\t\t\tlist_del(&page->lru);\n\t\tset_page_private(page, pfn);\n\t}\n\n\tlocal_irq_save(flags);\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tunsigned long pfn = page_private(page);\n\n\t\tset_page_private(page, 0);\n\t\ttrace_mm_page_free_batched(page);\n\t\tfree_unref_page_commit(page, pfn);\n\n\t\t/*\n\t\t * Guard against excessive IRQ disabled times when we get\n\t\t * a large list of pages to free.\n\t\t */\n\t\tif (++batch_count == SWAP_CLUSTER_MAX) {\n\t\t\tlocal_irq_restore(flags);\n\t\t\tbatch_count = 0;\n\t\t\tlocal_irq_save(flags);\n\t\t}\n\t}\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid free_unref_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\tunsigned long flags, pfn;\n\tint batch_count = 0;\n\n\t/* Prepare pages for freeing */\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tpfn = page_to_pfn(page);\n\t\tif (!free_unref_page_prepare(page, pfn))\n\t\t\tlist_del(&page->lru);\n\t\tset_page_private(page, pfn);\n\t}\n\n\tlocal_irq_save(flags);\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tunsigned long pfn = page_private(page);\n\n\t\tset_page_private(page, 0);\n\t\ttrace_mm_page_free_batched(page);\n\t\tfree_unref_page_commit(page, pfn);\n\n\t\t/*\n\t\t * Guard against excessive IRQ disabled times when we get\n\t\t * a large list of pages to free.\n\t\t */\n\t\tif (++batch_count == SWAP_CLUSTER_MAX) {\n\t\t\tlocal_irq_restore(flags);\n\t\t\tbatch_count = 0;\n\t\t\tlocal_irq_save(flags);\n\t\t}\n\t}\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_uncharge_list",
          "args": [
            "&pages_to_free"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_uncharge_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "6136-6143",
          "snippet": "void mem_cgroup_uncharge_list(struct list_head *page_list)\n{\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\tif (!list_empty(page_list))\n\t\tuncharge_list(page_list);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid mem_cgroup_uncharge_list(struct list_head *page_list)\n{\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\tif (!list_empty(page_list))\n\t\tuncharge_list(page_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&locked_pgdat->lru_lock",
            "flags"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&page->lru",
            "&pages_to_free"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ClearPageWaiters",
          "args": [
            "page"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ClearPageActive",
          "args": [
            "page"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "del_page_from_lru_list",
          "args": [
            "page",
            "lruvec",
            "page_off_lru(page)"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_off_lru",
          "args": [
            "page"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ClearPageLRU",
          "args": [
            "page"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLRU(page)",
            "page"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_page_lruvec",
          "args": [
            "page",
            "locked_pgdat"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_page_lruvec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1100-1130",
          "snippet": "struct lruvec *mem_cgroup_page_lruvec(struct page *page, struct pglist_data *pgdat)\n{\n\tstruct mem_cgroup_per_node *mz;\n\tstruct mem_cgroup *memcg;\n\tstruct lruvec *lruvec;\n\n\tif (mem_cgroup_disabled()) {\n\t\tlruvec = &pgdat->lruvec;\n\t\tgoto out;\n\t}\n\n\tmemcg = page->mem_cgroup;\n\t/*\n\t * Swapcache readahead pages are added to the LRU - and\n\t * possibly migrated - before they are charged.\n\t */\n\tif (!memcg)\n\t\tmemcg = root_mem_cgroup;\n\n\tmz = mem_cgroup_page_nodeinfo(memcg, page);\n\tlruvec = &mz->lruvec;\nout:\n\t/*\n\t * Since a node can be onlined after the mem_cgroup was created,\n\t * we have to be prepared to initialize lruvec->zone here;\n\t * and if offlined then reonlined, we need to reinitialize it.\n\t */\n\tif (unlikely(lruvec->pgdat != pgdat))\n\t\tlruvec->pgdat = pgdat;\n\treturn lruvec;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstruct lruvec *mem_cgroup_page_lruvec(struct page *page, struct pglist_data *pgdat)\n{\n\tstruct mem_cgroup_per_node *mz;\n\tstruct mem_cgroup *memcg;\n\tstruct lruvec *lruvec;\n\n\tif (mem_cgroup_disabled()) {\n\t\tlruvec = &pgdat->lruvec;\n\t\tgoto out;\n\t}\n\n\tmemcg = page->mem_cgroup;\n\t/*\n\t * Swapcache readahead pages are added to the LRU - and\n\t * possibly migrated - before they are charged.\n\t */\n\tif (!memcg)\n\t\tmemcg = root_mem_cgroup;\n\n\tmz = mem_cgroup_page_nodeinfo(memcg, page);\n\tlruvec = &mz->lruvec;\nout:\n\t/*\n\t * Since a node can be onlined after the mem_cgroup was created,\n\t * we have to be prepared to initialize lruvec->zone here;\n\t * and if offlined then reonlined, we need to reinitialize it.\n\t */\n\tif (unlikely(lruvec->pgdat != pgdat))\n\t\tlruvec->pgdat = pgdat;\n\treturn lruvec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&locked_pgdat->lru_lock",
            "flags"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&locked_pgdat->lru_lock",
            "flags"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_pgdat",
          "args": [
            "page"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_compound_page",
          "args": [
            "page"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "__put_compound_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "82-96",
          "snippet": "static void __put_compound_page(struct page *page)\n{\n\tcompound_page_dtor *dtor;\n\n\t/*\n\t * __page_cache_release() is supposed to be called for thp, not for\n\t * hugetlb. This is because hugetlb page does never have PageLRU set\n\t * (it's never listed to any LRU lists) and no memcg routines should\n\t * be called for hugetlb (it has a separate hugetlb_cgroup.)\n\t */\n\tif (!PageHuge(page))\n\t\t__page_cache_release(page);\n\tdtor = get_compound_page_dtor(page);\n\t(*dtor)(page);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void __put_compound_page(struct page *page)\n{\n\tcompound_page_dtor *dtor;\n\n\t/*\n\t * __page_cache_release() is supposed to be called for thp, not for\n\t * hugetlb. This is because hugetlb page does never have PageLRU set\n\t * (it's never listed to any LRU lists) and no memcg routines should\n\t * be called for hugetlb (it has a separate hugetlb_cgroup.)\n\t */\n\tif (!PageHuge(page))\n\t\t__page_cache_release(page);\n\tdtor = get_compound_page_dtor(page);\n\t(*dtor)(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&locked_pgdat->lru_lock",
            "flags"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "page"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page_testzero",
          "args": [
            "page"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_devmap_managed_page",
          "args": [
            "page"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&locked_pgdat->lru_lock",
            "flags"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_device_public_page",
          "args": [
            "page"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_huge_zero_page",
          "args": [
            "page"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&locked_pgdat->lru_lock",
            "flags"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "pages_to_free"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid release_pages(struct page **pages, int nr)\n{\n\tint i;\n\tLIST_HEAD(pages_to_free);\n\tstruct pglist_data *locked_pgdat = NULL;\n\tstruct lruvec *lruvec;\n\tunsigned long uninitialized_var(flags);\n\tunsigned int uninitialized_var(lock_batch);\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct page *page = pages[i];\n\n\t\t/*\n\t\t * Make sure the IRQ-safe lock-holding time does not get\n\t\t * excessive with a continuous string of pages from the\n\t\t * same pgdat. The lock is held only if pgdat != NULL.\n\t\t */\n\t\tif (locked_pgdat && ++lock_batch == SWAP_CLUSTER_MAX) {\n\t\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock, flags);\n\t\t\tlocked_pgdat = NULL;\n\t\t}\n\n\t\tif (is_huge_zero_page(page))\n\t\t\tcontinue;\n\n\t\t/* Device public page can not be huge page */\n\t\tif (is_device_public_page(page)) {\n\t\t\tif (locked_pgdat) {\n\t\t\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock,\n\t\t\t\t\t\t       flags);\n\t\t\t\tlocked_pgdat = NULL;\n\t\t\t}\n\t\t\tput_devmap_managed_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpage = compound_head(page);\n\t\tif (!put_page_testzero(page))\n\t\t\tcontinue;\n\n\t\tif (PageCompound(page)) {\n\t\t\tif (locked_pgdat) {\n\t\t\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock, flags);\n\t\t\t\tlocked_pgdat = NULL;\n\t\t\t}\n\t\t\t__put_compound_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (PageLRU(page)) {\n\t\t\tstruct pglist_data *pgdat = page_pgdat(page);\n\n\t\t\tif (pgdat != locked_pgdat) {\n\t\t\t\tif (locked_pgdat)\n\t\t\t\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock,\n\t\t\t\t\t\t\t\t\tflags);\n\t\t\t\tlock_batch = 0;\n\t\t\t\tlocked_pgdat = pgdat;\n\t\t\t\tspin_lock_irqsave(&locked_pgdat->lru_lock, flags);\n\t\t\t}\n\n\t\t\tlruvec = mem_cgroup_page_lruvec(page, locked_pgdat);\n\t\t\tVM_BUG_ON_PAGE(!PageLRU(page), page);\n\t\t\t__ClearPageLRU(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, page_off_lru(page));\n\t\t}\n\n\t\t/* Clear Active bit in case of parallel mark_page_accessed */\n\t\t__ClearPageActive(page);\n\t\t__ClearPageWaiters(page);\n\n\t\tlist_add(&page->lru, &pages_to_free);\n\t}\n\tif (locked_pgdat)\n\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock, flags);\n\n\tmem_cgroup_uncharge_list(&pages_to_free);\n\tfree_unref_page_list(&pages_to_free);\n}"
  },
  {
    "function_name": "lru_add_drain_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "670-704",
    "snippet": "void lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);",
      "static DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);",
      "static DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);",
      "static DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);",
      "static DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&lock"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_work",
          "args": [
            "&per_cpu(lru_add_drain_work, cpu)"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "lru_add_drain_work",
            "cpu"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "&has_work"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "cpu",
            "&has_work"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_work_on",
          "args": [
            "cpu",
            "mm_percpu_wq",
            "work"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "work",
            "lru_add_drain_per_cpu"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_activate_page_drain",
          "args": [
            "cpu"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "need_activate_page_drain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "323-326",
          "snippet": "static bool need_activate_page_drain(int cpu)\n{\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic bool need_activate_page_drain(int cpu)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "&per_cpu(lru_lazyfree_pvecs, cpu)"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "lru_lazyfree_pvecs",
            "cpu"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "&per_cpu(lru_deactivate_file_pvecs, cpu)"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "lru_deactivate_file_pvecs",
            "cpu"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "&per_cpu(lru_rotate_pvecs, cpu)"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "lru_rotate_pvecs",
            "cpu"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "&per_cpu(lru_add_pvec, cpu)"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "lru_add_pvec",
            "cpu"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "lru_add_drain_work",
            "cpu"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear",
          "args": [
            "&has_work"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&lock"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!mm_percpu_wq"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\nstatic DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);\nstatic DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);\n\nvoid lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}"
  },
  {
    "function_name": "lru_add_drain_per_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "656-659",
    "snippet": "static void lru_add_drain_per_cpu(struct work_struct *dummy)\n{\n\tlru_add_drain();\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lru_add_drain",
          "args": [],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "lru_add_drain_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "670-704",
          "snippet": "void lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);",
            "static DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);",
            "static DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\nstatic DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);\nstatic DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);\n\nvoid lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void lru_add_drain_per_cpu(struct work_struct *dummy)\n{\n\tlru_add_drain();\n}"
  },
  {
    "function_name": "lru_add_drain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "650-654",
    "snippet": "void lru_add_drain(void)\n{\n\tlru_add_drain_cpu(get_cpu());\n\tput_cpu();\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cpu",
          "args": [],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lru_add_drain_cpu",
          "args": [
            "get_cpu()"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "lru_add_drain_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "576-602",
          "snippet": "void lru_add_drain_cpu(int cpu)\n{\n\tstruct pagevec *pvec = &per_cpu(lru_add_pvec, cpu);\n\n\tif (pagevec_count(pvec))\n\t\t__pagevec_lru_add(pvec);\n\n\tpvec = &per_cpu(lru_rotate_pvecs, cpu);\n\tif (pagevec_count(pvec)) {\n\t\tunsigned long flags;\n\n\t\t/* No harm done if a racing interrupt already did this */\n\t\tlocal_irq_save(flags);\n\t\tpagevec_move_tail(pvec);\n\t\tlocal_irq_restore(flags);\n\t}\n\n\tpvec = &per_cpu(lru_deactivate_file_pvecs, cpu);\n\tif (pagevec_count(pvec))\n\t\tpagevec_lru_move_fn(pvec, lru_deactivate_file_fn, NULL);\n\n\tpvec = &per_cpu(lru_lazyfree_pvecs, cpu);\n\tif (pagevec_count(pvec))\n\t\tpagevec_lru_move_fn(pvec, lru_lazyfree_fn, NULL);\n\n\tactivate_page_drain(cpu);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);",
            "static DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\nstatic DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);\n\nvoid lru_add_drain_cpu(int cpu)\n{\n\tstruct pagevec *pvec = &per_cpu(lru_add_pvec, cpu);\n\n\tif (pagevec_count(pvec))\n\t\t__pagevec_lru_add(pvec);\n\n\tpvec = &per_cpu(lru_rotate_pvecs, cpu);\n\tif (pagevec_count(pvec)) {\n\t\tunsigned long flags;\n\n\t\t/* No harm done if a racing interrupt already did this */\n\t\tlocal_irq_save(flags);\n\t\tpagevec_move_tail(pvec);\n\t\tlocal_irq_restore(flags);\n\t}\n\n\tpvec = &per_cpu(lru_deactivate_file_pvecs, cpu);\n\tif (pagevec_count(pvec))\n\t\tpagevec_lru_move_fn(pvec, lru_deactivate_file_fn, NULL);\n\n\tpvec = &per_cpu(lru_lazyfree_pvecs, cpu);\n\tif (pagevec_count(pvec))\n\t\tpagevec_lru_move_fn(pvec, lru_lazyfree_fn, NULL);\n\n\tactivate_page_drain(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cpu",
          "args": [],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid lru_add_drain(void)\n{\n\tlru_add_drain_cpu(get_cpu());\n\tput_cpu();\n}"
  },
  {
    "function_name": "mark_page_lazyfree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "637-648",
    "snippet": "void mark_page_lazyfree(struct page *page)\n{\n\tif (PageLRU(page) && PageAnon(page) && PageSwapBacked(page) &&\n\t    !PageSwapCache(page) && !PageUnevictable(page)) {\n\t\tstruct pagevec *pvec = &get_cpu_var(lru_lazyfree_pvecs);\n\n\t\tget_page(page);\n\t\tif (!pagevec_add(pvec, page) || PageCompound(page))\n\t\t\tpagevec_lru_move_fn(pvec, lru_lazyfree_fn, NULL);\n\t\tput_cpu_var(lru_lazyfree_pvecs);\n\t}\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cpu_var",
          "args": [
            "lru_lazyfree_pvecs"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_lru_move_fn",
          "args": [
            "pvec",
            "lru_lazyfree_fn",
            "NULL"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "pagevec_lru_move_fn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "188-215",
          "snippet": "static void pagevec_lru_move_fn(struct pagevec *pvec,\n\tvoid (*move_fn)(struct page *page, struct lruvec *lruvec, void *arg),\n\tvoid *arg)\n{\n\tint i;\n\tstruct pglist_data *pgdat = NULL;\n\tstruct lruvec *lruvec;\n\tunsigned long flags = 0;\n\n\tfor (i = 0; i < pagevec_count(pvec); i++) {\n\t\tstruct page *page = pvec->pages[i];\n\t\tstruct pglist_data *pagepgdat = page_pgdat(page);\n\n\t\tif (pagepgdat != pgdat) {\n\t\t\tif (pgdat)\n\t\t\t\tspin_unlock_irqrestore(&pgdat->lru_lock, flags);\n\t\t\tpgdat = pagepgdat;\n\t\t\tspin_lock_irqsave(&pgdat->lru_lock, flags);\n\t\t}\n\n\t\tlruvec = mem_cgroup_page_lruvec(page, pgdat);\n\t\t(*move_fn)(page, lruvec, arg);\n\t}\n\tif (pgdat)\n\t\tspin_unlock_irqrestore(&pgdat->lru_lock, flags);\n\trelease_pages(pvec->pages, pvec->nr);\n\tpagevec_reinit(pvec);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void pagevec_lru_move_fn(struct pagevec *pvec,\n\tvoid (*move_fn)(struct page *page, struct lruvec *lruvec, void *arg),\n\tvoid *arg)\n{\n\tint i;\n\tstruct pglist_data *pgdat = NULL;\n\tstruct lruvec *lruvec;\n\tunsigned long flags = 0;\n\n\tfor (i = 0; i < pagevec_count(pvec); i++) {\n\t\tstruct page *page = pvec->pages[i];\n\t\tstruct pglist_data *pagepgdat = page_pgdat(page);\n\n\t\tif (pagepgdat != pgdat) {\n\t\t\tif (pgdat)\n\t\t\t\tspin_unlock_irqrestore(&pgdat->lru_lock, flags);\n\t\t\tpgdat = pagepgdat;\n\t\t\tspin_lock_irqsave(&pgdat->lru_lock, flags);\n\t\t}\n\n\t\tlruvec = mem_cgroup_page_lruvec(page, pgdat);\n\t\t(*move_fn)(page, lruvec, arg);\n\t}\n\tif (pgdat)\n\t\tspin_unlock_irqrestore(&pgdat->lru_lock, flags);\n\trelease_pages(pvec->pages, pvec->nr);\n\tpagevec_reinit(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "page"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_add",
          "args": [
            "pvec",
            "page"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "page"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cpu_var",
          "args": [
            "lru_lazyfree_pvecs"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUnevictable",
          "args": [
            "page"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapBacked",
          "args": [
            "page"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);\n\nvoid mark_page_lazyfree(struct page *page)\n{\n\tif (PageLRU(page) && PageAnon(page) && PageSwapBacked(page) &&\n\t    !PageSwapCache(page) && !PageUnevictable(page)) {\n\t\tstruct pagevec *pvec = &get_cpu_var(lru_lazyfree_pvecs);\n\n\t\tget_page(page);\n\t\tif (!pagevec_add(pvec, page) || PageCompound(page))\n\t\t\tpagevec_lru_move_fn(pvec, lru_lazyfree_fn, NULL);\n\t\tput_cpu_var(lru_lazyfree_pvecs);\n\t}\n}"
  },
  {
    "function_name": "deactivate_file_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "612-628",
    "snippet": "void deactivate_file_page(struct page *page)\n{\n\t/*\n\t * In a workload with many unevictable page such as mprotect,\n\t * unevictable page deactivation for accelerating reclaim is pointless.\n\t */\n\tif (PageUnevictable(page))\n\t\treturn;\n\n\tif (likely(get_page_unless_zero(page))) {\n\t\tstruct pagevec *pvec = &get_cpu_var(lru_deactivate_file_pvecs);\n\n\t\tif (!pagevec_add(pvec, page) || PageCompound(page))\n\t\t\tpagevec_lru_move_fn(pvec, lru_deactivate_file_fn, NULL);\n\t\tput_cpu_var(lru_deactivate_file_pvecs);\n\t}\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cpu_var",
          "args": [
            "lru_deactivate_file_pvecs"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_lru_move_fn",
          "args": [
            "pvec",
            "lru_deactivate_file_fn",
            "NULL"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "pagevec_lru_move_fn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "188-215",
          "snippet": "static void pagevec_lru_move_fn(struct pagevec *pvec,\n\tvoid (*move_fn)(struct page *page, struct lruvec *lruvec, void *arg),\n\tvoid *arg)\n{\n\tint i;\n\tstruct pglist_data *pgdat = NULL;\n\tstruct lruvec *lruvec;\n\tunsigned long flags = 0;\n\n\tfor (i = 0; i < pagevec_count(pvec); i++) {\n\t\tstruct page *page = pvec->pages[i];\n\t\tstruct pglist_data *pagepgdat = page_pgdat(page);\n\n\t\tif (pagepgdat != pgdat) {\n\t\t\tif (pgdat)\n\t\t\t\tspin_unlock_irqrestore(&pgdat->lru_lock, flags);\n\t\t\tpgdat = pagepgdat;\n\t\t\tspin_lock_irqsave(&pgdat->lru_lock, flags);\n\t\t}\n\n\t\tlruvec = mem_cgroup_page_lruvec(page, pgdat);\n\t\t(*move_fn)(page, lruvec, arg);\n\t}\n\tif (pgdat)\n\t\tspin_unlock_irqrestore(&pgdat->lru_lock, flags);\n\trelease_pages(pvec->pages, pvec->nr);\n\tpagevec_reinit(pvec);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void pagevec_lru_move_fn(struct pagevec *pvec,\n\tvoid (*move_fn)(struct page *page, struct lruvec *lruvec, void *arg),\n\tvoid *arg)\n{\n\tint i;\n\tstruct pglist_data *pgdat = NULL;\n\tstruct lruvec *lruvec;\n\tunsigned long flags = 0;\n\n\tfor (i = 0; i < pagevec_count(pvec); i++) {\n\t\tstruct page *page = pvec->pages[i];\n\t\tstruct pglist_data *pagepgdat = page_pgdat(page);\n\n\t\tif (pagepgdat != pgdat) {\n\t\t\tif (pgdat)\n\t\t\t\tspin_unlock_irqrestore(&pgdat->lru_lock, flags);\n\t\t\tpgdat = pagepgdat;\n\t\t\tspin_lock_irqsave(&pgdat->lru_lock, flags);\n\t\t}\n\n\t\tlruvec = mem_cgroup_page_lruvec(page, pgdat);\n\t\t(*move_fn)(page, lruvec, arg);\n\t}\n\tif (pgdat)\n\t\tspin_unlock_irqrestore(&pgdat->lru_lock, flags);\n\trelease_pages(pvec->pages, pvec->nr);\n\tpagevec_reinit(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "page"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_add",
          "args": [
            "pvec",
            "page"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu_var",
          "args": [
            "lru_deactivate_file_pvecs"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "get_page_unless_zero(page)"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page_unless_zero",
          "args": [
            "page"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUnevictable",
          "args": [
            "page"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);\n\nvoid deactivate_file_page(struct page *page)\n{\n\t/*\n\t * In a workload with many unevictable page such as mprotect,\n\t * unevictable page deactivation for accelerating reclaim is pointless.\n\t */\n\tif (PageUnevictable(page))\n\t\treturn;\n\n\tif (likely(get_page_unless_zero(page))) {\n\t\tstruct pagevec *pvec = &get_cpu_var(lru_deactivate_file_pvecs);\n\n\t\tif (!pagevec_add(pvec, page) || PageCompound(page))\n\t\t\tpagevec_lru_move_fn(pvec, lru_deactivate_file_fn, NULL);\n\t\tput_cpu_var(lru_deactivate_file_pvecs);\n\t}\n}"
  },
  {
    "function_name": "lru_add_drain_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "576-602",
    "snippet": "void lru_add_drain_cpu(int cpu)\n{\n\tstruct pagevec *pvec = &per_cpu(lru_add_pvec, cpu);\n\n\tif (pagevec_count(pvec))\n\t\t__pagevec_lru_add(pvec);\n\n\tpvec = &per_cpu(lru_rotate_pvecs, cpu);\n\tif (pagevec_count(pvec)) {\n\t\tunsigned long flags;\n\n\t\t/* No harm done if a racing interrupt already did this */\n\t\tlocal_irq_save(flags);\n\t\tpagevec_move_tail(pvec);\n\t\tlocal_irq_restore(flags);\n\t}\n\n\tpvec = &per_cpu(lru_deactivate_file_pvecs, cpu);\n\tif (pagevec_count(pvec))\n\t\tpagevec_lru_move_fn(pvec, lru_deactivate_file_fn, NULL);\n\n\tpvec = &per_cpu(lru_lazyfree_pvecs, cpu);\n\tif (pagevec_count(pvec))\n\t\tpagevec_lru_move_fn(pvec, lru_lazyfree_fn, NULL);\n\n\tactivate_page_drain(cpu);\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);",
      "static DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);",
      "static DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);",
      "static DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "activate_page_drain",
          "args": [
            "cpu"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "need_activate_page_drain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "323-326",
          "snippet": "static bool need_activate_page_drain(int cpu)\n{\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic bool need_activate_page_drain(int cpu)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagevec_lru_move_fn",
          "args": [
            "pvec",
            "lru_lazyfree_fn",
            "NULL"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "pagevec_lru_move_fn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "188-215",
          "snippet": "static void pagevec_lru_move_fn(struct pagevec *pvec,\n\tvoid (*move_fn)(struct page *page, struct lruvec *lruvec, void *arg),\n\tvoid *arg)\n{\n\tint i;\n\tstruct pglist_data *pgdat = NULL;\n\tstruct lruvec *lruvec;\n\tunsigned long flags = 0;\n\n\tfor (i = 0; i < pagevec_count(pvec); i++) {\n\t\tstruct page *page = pvec->pages[i];\n\t\tstruct pglist_data *pagepgdat = page_pgdat(page);\n\n\t\tif (pagepgdat != pgdat) {\n\t\t\tif (pgdat)\n\t\t\t\tspin_unlock_irqrestore(&pgdat->lru_lock, flags);\n\t\t\tpgdat = pagepgdat;\n\t\t\tspin_lock_irqsave(&pgdat->lru_lock, flags);\n\t\t}\n\n\t\tlruvec = mem_cgroup_page_lruvec(page, pgdat);\n\t\t(*move_fn)(page, lruvec, arg);\n\t}\n\tif (pgdat)\n\t\tspin_unlock_irqrestore(&pgdat->lru_lock, flags);\n\trelease_pages(pvec->pages, pvec->nr);\n\tpagevec_reinit(pvec);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void pagevec_lru_move_fn(struct pagevec *pvec,\n\tvoid (*move_fn)(struct page *page, struct lruvec *lruvec, void *arg),\n\tvoid *arg)\n{\n\tint i;\n\tstruct pglist_data *pgdat = NULL;\n\tstruct lruvec *lruvec;\n\tunsigned long flags = 0;\n\n\tfor (i = 0; i < pagevec_count(pvec); i++) {\n\t\tstruct page *page = pvec->pages[i];\n\t\tstruct pglist_data *pagepgdat = page_pgdat(page);\n\n\t\tif (pagepgdat != pgdat) {\n\t\t\tif (pgdat)\n\t\t\t\tspin_unlock_irqrestore(&pgdat->lru_lock, flags);\n\t\t\tpgdat = pagepgdat;\n\t\t\tspin_lock_irqsave(&pgdat->lru_lock, flags);\n\t\t}\n\n\t\tlruvec = mem_cgroup_page_lruvec(page, pgdat);\n\t\t(*move_fn)(page, lruvec, arg);\n\t}\n\tif (pgdat)\n\t\tspin_unlock_irqrestore(&pgdat->lru_lock, flags);\n\trelease_pages(pvec->pages, pvec->nr);\n\tpagevec_reinit(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "pvec"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "lru_lazyfree_pvecs",
            "cpu"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "pvec"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "lru_deactivate_file_pvecs",
            "cpu"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_move_tail",
          "args": [
            "pvec"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "pagevec_move_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "234-240",
          "snippet": "static void pagevec_move_tail(struct pagevec *pvec)\n{\n\tint pgmoved = 0;\n\n\tpagevec_lru_move_fn(pvec, pagevec_move_tail_fn, &pgmoved);\n\t__count_vm_events(PGROTATED, pgmoved);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void pagevec_move_tail(struct pagevec *pvec)\n{\n\tint pgmoved = 0;\n\n\tpagevec_lru_move_fn(pvec, pagevec_move_tail_fn, &pgmoved);\n\t__count_vm_events(PGROTATED, pgmoved);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "pvec"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "lru_rotate_pvecs",
            "cpu"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pagevec_lru_add",
          "args": [
            "pvec"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "__pagevec_lru_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "916-919",
          "snippet": "void __pagevec_lru_add(struct pagevec *pvec)\n{\n\tpagevec_lru_move_fn(pvec, __pagevec_lru_add_fn, NULL);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid __pagevec_lru_add(struct pagevec *pvec)\n{\n\tpagevec_lru_move_fn(pvec, __pagevec_lru_add_fn, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "pvec"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "lru_add_pvec",
            "cpu"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\nstatic DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);\n\nvoid lru_add_drain_cpu(int cpu)\n{\n\tstruct pagevec *pvec = &per_cpu(lru_add_pvec, cpu);\n\n\tif (pagevec_count(pvec))\n\t\t__pagevec_lru_add(pvec);\n\n\tpvec = &per_cpu(lru_rotate_pvecs, cpu);\n\tif (pagevec_count(pvec)) {\n\t\tunsigned long flags;\n\n\t\t/* No harm done if a racing interrupt already did this */\n\t\tlocal_irq_save(flags);\n\t\tpagevec_move_tail(pvec);\n\t\tlocal_irq_restore(flags);\n\t}\n\n\tpvec = &per_cpu(lru_deactivate_file_pvecs, cpu);\n\tif (pagevec_count(pvec))\n\t\tpagevec_lru_move_fn(pvec, lru_deactivate_file_fn, NULL);\n\n\tpvec = &per_cpu(lru_lazyfree_pvecs, cpu);\n\tif (pagevec_count(pvec))\n\t\tpagevec_lru_move_fn(pvec, lru_lazyfree_fn, NULL);\n\n\tactivate_page_drain(cpu);\n}"
  },
  {
    "function_name": "lru_lazyfree_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "546-569",
    "snippet": "static void lru_lazyfree_fn(struct page *page, struct lruvec *lruvec,\n\t\t\t    void *arg)\n{\n\tif (PageLRU(page) && PageAnon(page) && PageSwapBacked(page) &&\n\t    !PageSwapCache(page) && !PageUnevictable(page)) {\n\t\tbool active = PageActive(page);\n\n\t\tdel_page_from_lru_list(page, lruvec,\n\t\t\t\t       LRU_INACTIVE_ANON + active);\n\t\tClearPageActive(page);\n\t\tClearPageReferenced(page);\n\t\t/*\n\t\t * lazyfree pages are clean anonymous pages. They have\n\t\t * SwapBacked flag cleared to distinguish normal anonymous\n\t\t * pages\n\t\t */\n\t\tClearPageSwapBacked(page);\n\t\tadd_page_to_lru_list(page, lruvec, LRU_INACTIVE_FILE);\n\n\t\t__count_vm_events(PGLAZYFREE, hpage_nr_pages(page));\n\t\tcount_memcg_page_event(page, PGLAZYFREE);\n\t\tupdate_page_reclaim_stat(lruvec, 1, 0);\n\t}\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_page_reclaim_stat",
          "args": [
            "lruvec",
            "1",
            "0"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "update_page_reclaim_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "263-271",
          "snippet": "static void update_page_reclaim_stat(struct lruvec *lruvec,\n\t\t\t\t     int file, int rotated)\n{\n\tstruct zone_reclaim_stat *reclaim_stat = &lruvec->reclaim_stat;\n\n\treclaim_stat->recent_scanned[file]++;\n\tif (rotated)\n\t\treclaim_stat->recent_rotated[file]++;\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void update_page_reclaim_stat(struct lruvec *lruvec,\n\t\t\t\t     int file, int rotated)\n{\n\tstruct zone_reclaim_stat *reclaim_stat = &lruvec->reclaim_stat;\n\n\treclaim_stat->recent_scanned[file]++;\n\tif (rotated)\n\t\treclaim_stat->recent_rotated[file]++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "count_memcg_page_event",
          "args": [
            "page",
            "PGLAZYFREE"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__count_vm_events",
          "args": [
            "PGLAZYFREE",
            "hpage_nr_pages(page)"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "page"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_page_to_lru_list",
          "args": [
            "page",
            "lruvec",
            "LRU_INACTIVE_FILE"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageSwapBacked",
          "args": [
            "page"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageReferenced",
          "args": [
            "page"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageActive",
          "args": [
            "page"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "del_page_from_lru_list",
          "args": [
            "page",
            "lruvec",
            "LRU_INACTIVE_ANON + active"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageActive",
          "args": [
            "page"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUnevictable",
          "args": [
            "page"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapBacked",
          "args": [
            "page"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void lru_lazyfree_fn(struct page *page, struct lruvec *lruvec,\n\t\t\t    void *arg)\n{\n\tif (PageLRU(page) && PageAnon(page) && PageSwapBacked(page) &&\n\t    !PageSwapCache(page) && !PageUnevictable(page)) {\n\t\tbool active = PageActive(page);\n\n\t\tdel_page_from_lru_list(page, lruvec,\n\t\t\t\t       LRU_INACTIVE_ANON + active);\n\t\tClearPageActive(page);\n\t\tClearPageReferenced(page);\n\t\t/*\n\t\t * lazyfree pages are clean anonymous pages. They have\n\t\t * SwapBacked flag cleared to distinguish normal anonymous\n\t\t * pages\n\t\t */\n\t\tClearPageSwapBacked(page);\n\t\tadd_page_to_lru_list(page, lruvec, LRU_INACTIVE_FILE);\n\n\t\t__count_vm_events(PGLAZYFREE, hpage_nr_pages(page));\n\t\tcount_memcg_page_event(page, PGLAZYFREE);\n\t\tupdate_page_reclaim_stat(lruvec, 1, 0);\n\t}\n}"
  },
  {
    "function_name": "lru_deactivate_file_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "499-543",
    "snippet": "static void lru_deactivate_file_fn(struct page *page, struct lruvec *lruvec,\n\t\t\t      void *arg)\n{\n\tint lru, file;\n\tbool active;\n\n\tif (!PageLRU(page))\n\t\treturn;\n\n\tif (PageUnevictable(page))\n\t\treturn;\n\n\t/* Some processes are using the page */\n\tif (page_mapped(page))\n\t\treturn;\n\n\tactive = PageActive(page);\n\tfile = page_is_file_cache(page);\n\tlru = page_lru_base_type(page);\n\n\tdel_page_from_lru_list(page, lruvec, lru + active);\n\tClearPageActive(page);\n\tClearPageReferenced(page);\n\tadd_page_to_lru_list(page, lruvec, lru);\n\n\tif (PageWriteback(page) || PageDirty(page)) {\n\t\t/*\n\t\t * PG_reclaim could be raced with end_page_writeback\n\t\t * It can make readahead confusing.  But race window\n\t\t * is _really_ small and  it's non-critical problem.\n\t\t */\n\t\tSetPageReclaim(page);\n\t} else {\n\t\t/*\n\t\t * The page's writeback ends up during pagevec\n\t\t * We moves tha page into tail of inactive.\n\t\t */\n\t\tlist_move_tail(&page->lru, &lruvec->lists[lru]);\n\t\t__count_vm_event(PGROTATED);\n\t}\n\n\tif (active)\n\t\t__count_vm_event(PGDEACTIVATE);\n\tupdate_page_reclaim_stat(lruvec, file, 0);\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_page_reclaim_stat",
          "args": [
            "lruvec",
            "file",
            "0"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "update_page_reclaim_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "263-271",
          "snippet": "static void update_page_reclaim_stat(struct lruvec *lruvec,\n\t\t\t\t     int file, int rotated)\n{\n\tstruct zone_reclaim_stat *reclaim_stat = &lruvec->reclaim_stat;\n\n\treclaim_stat->recent_scanned[file]++;\n\tif (rotated)\n\t\treclaim_stat->recent_rotated[file]++;\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void update_page_reclaim_stat(struct lruvec *lruvec,\n\t\t\t\t     int file, int rotated)\n{\n\tstruct zone_reclaim_stat *reclaim_stat = &lruvec->reclaim_stat;\n\n\treclaim_stat->recent_scanned[file]++;\n\tif (rotated)\n\t\treclaim_stat->recent_rotated[file]++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__count_vm_event",
          "args": [
            "PGDEACTIVATE"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__count_vm_event",
          "args": [
            "PGROTATED"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&page->lru",
            "&lruvec->lists[lru]"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageReclaim",
          "args": [
            "page"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_page_to_lru_list",
          "args": [
            "page",
            "lruvec",
            "lru"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageReferenced",
          "args": [
            "page"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageActive",
          "args": [
            "page"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "del_page_from_lru_list",
          "args": [
            "page",
            "lruvec",
            "lru + active"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_lru_base_type",
          "args": [
            "page"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_is_file_cache",
          "args": [
            "page"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageActive",
          "args": [
            "page"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapped",
          "args": [
            "page"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "470-486",
          "snippet": "bool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nbool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUnevictable",
          "args": [
            "page"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void lru_deactivate_file_fn(struct page *page, struct lruvec *lruvec,\n\t\t\t      void *arg)\n{\n\tint lru, file;\n\tbool active;\n\n\tif (!PageLRU(page))\n\t\treturn;\n\n\tif (PageUnevictable(page))\n\t\treturn;\n\n\t/* Some processes are using the page */\n\tif (page_mapped(page))\n\t\treturn;\n\n\tactive = PageActive(page);\n\tfile = page_is_file_cache(page);\n\tlru = page_lru_base_type(page);\n\n\tdel_page_from_lru_list(page, lruvec, lru + active);\n\tClearPageActive(page);\n\tClearPageReferenced(page);\n\tadd_page_to_lru_list(page, lruvec, lru);\n\n\tif (PageWriteback(page) || PageDirty(page)) {\n\t\t/*\n\t\t * PG_reclaim could be raced with end_page_writeback\n\t\t * It can make readahead confusing.  But race window\n\t\t * is _really_ small and  it's non-critical problem.\n\t\t */\n\t\tSetPageReclaim(page);\n\t} else {\n\t\t/*\n\t\t * The page's writeback ends up during pagevec\n\t\t * We moves tha page into tail of inactive.\n\t\t */\n\t\tlist_move_tail(&page->lru, &lruvec->lists[lru]);\n\t\t__count_vm_event(PGROTATED);\n\t}\n\n\tif (active)\n\t\t__count_vm_event(PGDEACTIVATE);\n\tupdate_page_reclaim_stat(lruvec, file, 0);\n}"
  },
  {
    "function_name": "lru_cache_add_active_or_unevictable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "458-476",
    "snippet": "void lru_cache_add_active_or_unevictable(struct page *page,\n\t\t\t\t\t struct vm_area_struct *vma)\n{\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\n\tif (likely((vma->vm_flags & (VM_LOCKED | VM_SPECIAL)) != VM_LOCKED))\n\t\tSetPageActive(page);\n\telse if (!TestSetPageMlocked(page)) {\n\t\t/*\n\t\t * We use the irq-unsafe __mod_zone_page_stat because this\n\t\t * counter is not modified from interrupt context, and the pte\n\t\t * lock is held(spinlock), which implies preemption disabled.\n\t\t */\n\t\t__mod_zone_page_state(page_zone(page), NR_MLOCK,\n\t\t\t\t    hpage_nr_pages(page));\n\t\tcount_vm_event(UNEVICTABLE_PGMLOCKED);\n\t}\n\tlru_cache_add(page);\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lru_cache_add",
          "args": [
            "page"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "lru_cache_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "441-446",
          "snippet": "void lru_cache_add(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageActive(page) && PageUnevictable(page), page);\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\t__lru_cache_add(page);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid lru_cache_add(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageActive(page) && PageUnevictable(page), page);\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\t__lru_cache_add(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "UNEVICTABLE_PGMLOCKED"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mod_zone_page_state",
          "args": [
            "page_zone(page)",
            "NR_MLOCK",
            "hpage_nr_pages(page)"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "__mod_zone_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "315-332",
          "snippet": "void __mod_zone_page_state(struct zone *zone, enum zone_stat_item item,\n\t\t\t   long delta)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\ts8 __percpu *p = pcp->vm_stat_diff + item;\n\tlong x;\n\tlong t;\n\n\tx = delta + __this_cpu_read(*p);\n\n\tt = __this_cpu_read(pcp->stat_threshold);\n\n\tif (unlikely(x > t || x < -t)) {\n\t\tzone_page_state_add(x, zone, item);\n\t\tx = 0;\n\t}\n\t__this_cpu_write(*p, x);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __mod_zone_page_state(struct zone *zone, enum zone_stat_item item,\n\t\t\t   long delta)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\ts8 __percpu *p = pcp->vm_stat_diff + item;\n\tlong x;\n\tlong t;\n\n\tx = delta + __this_cpu_read(*p);\n\n\tt = __this_cpu_read(pcp->stat_threshold);\n\n\tif (unlikely(x > t || x < -t)) {\n\t\tzone_page_state_add(x, zone, item);\n\t\tx = 0;\n\t}\n\t__this_cpu_write(*p, x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpage_nr_pages",
          "args": [
            "page"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestSetPageMlocked",
          "args": [
            "page"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageActive",
          "args": [
            "page"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "(vma->vm_flags & (VM_LOCKED | VM_SPECIAL)) != VM_LOCKED"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageLRU(page)",
            "page"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid lru_cache_add_active_or_unevictable(struct page *page,\n\t\t\t\t\t struct vm_area_struct *vma)\n{\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\n\tif (likely((vma->vm_flags & (VM_LOCKED | VM_SPECIAL)) != VM_LOCKED))\n\t\tSetPageActive(page);\n\telse if (!TestSetPageMlocked(page)) {\n\t\t/*\n\t\t * We use the irq-unsafe __mod_zone_page_stat because this\n\t\t * counter is not modified from interrupt context, and the pte\n\t\t * lock is held(spinlock), which implies preemption disabled.\n\t\t */\n\t\t__mod_zone_page_state(page_zone(page), NR_MLOCK,\n\t\t\t\t    hpage_nr_pages(page));\n\t\tcount_vm_event(UNEVICTABLE_PGMLOCKED);\n\t}\n\tlru_cache_add(page);\n}"
  },
  {
    "function_name": "lru_cache_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "441-446",
    "snippet": "void lru_cache_add(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageActive(page) && PageUnevictable(page), page);\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\t__lru_cache_add(page);\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__lru_cache_add",
          "args": [
            "page"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "__lru_cache_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "403-411",
          "snippet": "static void __lru_cache_add(struct page *page)\n{\n\tstruct pagevec *pvec = &get_cpu_var(lru_add_pvec);\n\n\tget_page(page);\n\tif (!pagevec_add(pvec, page) || PageCompound(page))\n\t\t__pagevec_lru_add(pvec);\n\tput_cpu_var(lru_add_pvec);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\n\nstatic void __lru_cache_add(struct page *page)\n{\n\tstruct pagevec *pvec = &get_cpu_var(lru_add_pvec);\n\n\tget_page(page);\n\tif (!pagevec_add(pvec, page) || PageCompound(page))\n\t\t__pagevec_lru_add(pvec);\n\tput_cpu_var(lru_add_pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageLRU(page)",
            "page"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageActive(page) && PageUnevictable(page)",
            "page"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUnevictable",
          "args": [
            "page"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageActive",
          "args": [
            "page"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid lru_cache_add(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageActive(page) && PageUnevictable(page), page);\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\t__lru_cache_add(page);\n}"
  },
  {
    "function_name": "lru_cache_add_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "424-429",
    "snippet": "void lru_cache_add_file(struct page *page)\n{\n\tif (PageActive(page))\n\t\tClearPageActive(page);\n\t__lru_cache_add(page);\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__lru_cache_add",
          "args": [
            "page"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "__lru_cache_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "403-411",
          "snippet": "static void __lru_cache_add(struct page *page)\n{\n\tstruct pagevec *pvec = &get_cpu_var(lru_add_pvec);\n\n\tget_page(page);\n\tif (!pagevec_add(pvec, page) || PageCompound(page))\n\t\t__pagevec_lru_add(pvec);\n\tput_cpu_var(lru_add_pvec);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\n\nstatic void __lru_cache_add(struct page *page)\n{\n\tstruct pagevec *pvec = &get_cpu_var(lru_add_pvec);\n\n\tget_page(page);\n\tif (!pagevec_add(pvec, page) || PageCompound(page))\n\t\t__pagevec_lru_add(pvec);\n\tput_cpu_var(lru_add_pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPageActive",
          "args": [
            "page"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageActive",
          "args": [
            "page"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid lru_cache_add_file(struct page *page)\n{\n\tif (PageActive(page))\n\t\tClearPageActive(page);\n\t__lru_cache_add(page);\n}"
  },
  {
    "function_name": "lru_cache_add_anon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "417-422",
    "snippet": "void lru_cache_add_anon(struct page *page)\n{\n\tif (PageActive(page))\n\t\tClearPageActive(page);\n\t__lru_cache_add(page);\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__lru_cache_add",
          "args": [
            "page"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "__lru_cache_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "403-411",
          "snippet": "static void __lru_cache_add(struct page *page)\n{\n\tstruct pagevec *pvec = &get_cpu_var(lru_add_pvec);\n\n\tget_page(page);\n\tif (!pagevec_add(pvec, page) || PageCompound(page))\n\t\t__pagevec_lru_add(pvec);\n\tput_cpu_var(lru_add_pvec);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\n\nstatic void __lru_cache_add(struct page *page)\n{\n\tstruct pagevec *pvec = &get_cpu_var(lru_add_pvec);\n\n\tget_page(page);\n\tif (!pagevec_add(pvec, page) || PageCompound(page))\n\t\t__pagevec_lru_add(pvec);\n\tput_cpu_var(lru_add_pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPageActive",
          "args": [
            "page"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageActive",
          "args": [
            "page"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid lru_cache_add_anon(struct page *page)\n{\n\tif (PageActive(page))\n\t\tClearPageActive(page);\n\t__lru_cache_add(page);\n}"
  },
  {
    "function_name": "__lru_cache_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "403-411",
    "snippet": "static void __lru_cache_add(struct page *page)\n{\n\tstruct pagevec *pvec = &get_cpu_var(lru_add_pvec);\n\n\tget_page(page);\n\tif (!pagevec_add(pvec, page) || PageCompound(page))\n\t\t__pagevec_lru_add(pvec);\n\tput_cpu_var(lru_add_pvec);\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cpu_var",
          "args": [
            "lru_add_pvec"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pagevec_lru_add",
          "args": [
            "pvec"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "__pagevec_lru_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "916-919",
          "snippet": "void __pagevec_lru_add(struct pagevec *pvec)\n{\n\tpagevec_lru_move_fn(pvec, __pagevec_lru_add_fn, NULL);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid __pagevec_lru_add(struct pagevec *pvec)\n{\n\tpagevec_lru_move_fn(pvec, __pagevec_lru_add_fn, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "page"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_add",
          "args": [
            "pvec",
            "page"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "page"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cpu_var",
          "args": [
            "lru_add_pvec"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\n\nstatic void __lru_cache_add(struct page *page)\n{\n\tstruct pagevec *pvec = &get_cpu_var(lru_add_pvec);\n\n\tget_page(page);\n\tif (!pagevec_add(pvec, page) || PageCompound(page))\n\t\t__pagevec_lru_add(pvec);\n\tput_cpu_var(lru_add_pvec);\n}"
  },
  {
    "function_name": "mark_page_accessed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "376-400",
    "snippet": "void mark_page_accessed(struct page *page)\n{\n\tpage = compound_head(page);\n\tif (!PageActive(page) && !PageUnevictable(page) &&\n\t\t\tPageReferenced(page)) {\n\n\t\t/*\n\t\t * If the page is on the LRU, queue it for activation via\n\t\t * activate_page_pvecs. Otherwise, assume the page is on a\n\t\t * pagevec, mark it active and it'll be moved to the active\n\t\t * LRU on the next drain.\n\t\t */\n\t\tif (PageLRU(page))\n\t\t\tactivate_page(page);\n\t\telse\n\t\t\t__lru_cache_activate_page(page);\n\t\tClearPageReferenced(page);\n\t\tif (page_is_file_cache(page))\n\t\t\tworkingset_activation(page);\n\t} else if (!PageReferenced(page)) {\n\t\tSetPageReferenced(page);\n\t}\n\tif (page_is_idle(page))\n\t\tclear_page_idle(page);\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_page_idle",
          "args": [
            "page"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_is_idle",
          "args": [
            "page"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageReferenced",
          "args": [
            "page"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageReferenced",
          "args": [
            "page"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "workingset_activation",
          "args": [
            "page"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "workingset_activation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/workingset.c",
          "lines": "333-353",
          "snippet": "void workingset_activation(struct page *page)\n{\n\tstruct mem_cgroup *memcg;\n\tstruct lruvec *lruvec;\n\n\trcu_read_lock();\n\t/*\n\t * Filter non-memcg pages here, e.g. unmap can call\n\t * mark_page_accessed() on VDSO pages.\n\t *\n\t * XXX: See workingset_refault() - this should return\n\t * root_mem_cgroup even for !CONFIG_MEMCG.\n\t */\n\tmemcg = page_memcg_rcu(page);\n\tif (!mem_cgroup_disabled() && !memcg)\n\t\tgoto out;\n\tlruvec = mem_cgroup_lruvec(page_pgdat(page), memcg);\n\tatomic_long_inc(&lruvec->inactive_age);\nout:\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/memcontrol.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/pagemap.h>\n#include <linux/shmem_fs.h>\n#include <linux/writeback.h>\n#include <linux/memcontrol.h>\n\nvoid workingset_activation(struct page *page)\n{\n\tstruct mem_cgroup *memcg;\n\tstruct lruvec *lruvec;\n\n\trcu_read_lock();\n\t/*\n\t * Filter non-memcg pages here, e.g. unmap can call\n\t * mark_page_accessed() on VDSO pages.\n\t *\n\t * XXX: See workingset_refault() - this should return\n\t * root_mem_cgroup even for !CONFIG_MEMCG.\n\t */\n\tmemcg = page_memcg_rcu(page);\n\tif (!mem_cgroup_disabled() && !memcg)\n\t\tgoto out;\n\tlruvec = mem_cgroup_lruvec(page_pgdat(page), memcg);\n\tatomic_long_inc(&lruvec->inactive_age);\nout:\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_is_file_cache",
          "args": [
            "page"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageReferenced",
          "args": [
            "page"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__lru_cache_activate_page",
          "args": [
            "page"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "__lru_cache_activate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "339-364",
          "snippet": "static void __lru_cache_activate_page(struct page *page)\n{\n\tstruct pagevec *pvec = &get_cpu_var(lru_add_pvec);\n\tint i;\n\n\t/*\n\t * Search backwards on the optimistic assumption that the page being\n\t * activated has just been added to this pagevec. Note that only\n\t * the local pagevec is examined as a !PageLRU page could be in the\n\t * process of being released, reclaimed, migrated or on a remote\n\t * pagevec that is currently being drained. Furthermore, marking\n\t * a remote pagevec's page PageActive potentially hits a race where\n\t * a page is marked PageActive just after it is added to the inactive\n\t * list causing accounting errors and BUG_ON checks to trigger.\n\t */\n\tfor (i = pagevec_count(pvec) - 1; i >= 0; i--) {\n\t\tstruct page *pagevec_page = pvec->pages[i];\n\n\t\tif (pagevec_page == page) {\n\t\t\tSetPageActive(page);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tput_cpu_var(lru_add_pvec);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\n\nstatic void __lru_cache_activate_page(struct page *page)\n{\n\tstruct pagevec *pvec = &get_cpu_var(lru_add_pvec);\n\tint i;\n\n\t/*\n\t * Search backwards on the optimistic assumption that the page being\n\t * activated has just been added to this pagevec. Note that only\n\t * the local pagevec is examined as a !PageLRU page could be in the\n\t * process of being released, reclaimed, migrated or on a remote\n\t * pagevec that is currently being drained. Furthermore, marking\n\t * a remote pagevec's page PageActive potentially hits a race where\n\t * a page is marked PageActive just after it is added to the inactive\n\t * list causing accounting errors and BUG_ON checks to trigger.\n\t */\n\tfor (i = pagevec_count(pvec) - 1; i >= 0; i--) {\n\t\tstruct page *pagevec_page = pvec->pages[i];\n\n\t\tif (pagevec_page == page) {\n\t\t\tSetPageActive(page);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tput_cpu_var(lru_add_pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageReferenced",
          "args": [
            "page"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUnevictable",
          "args": [
            "page"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageActive",
          "args": [
            "page"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid mark_page_accessed(struct page *page)\n{\n\tpage = compound_head(page);\n\tif (!PageActive(page) && !PageUnevictable(page) &&\n\t\t\tPageReferenced(page)) {\n\n\t\t/*\n\t\t * If the page is on the LRU, queue it for activation via\n\t\t * activate_page_pvecs. Otherwise, assume the page is on a\n\t\t * pagevec, mark it active and it'll be moved to the active\n\t\t * LRU on the next drain.\n\t\t */\n\t\tif (PageLRU(page))\n\t\t\tactivate_page(page);\n\t\telse\n\t\t\t__lru_cache_activate_page(page);\n\t\tClearPageReferenced(page);\n\t\tif (page_is_file_cache(page))\n\t\t\tworkingset_activation(page);\n\t} else if (!PageReferenced(page)) {\n\t\tSetPageReferenced(page);\n\t}\n\tif (page_is_idle(page))\n\t\tclear_page_idle(page);\n}"
  },
  {
    "function_name": "__lru_cache_activate_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "339-364",
    "snippet": "static void __lru_cache_activate_page(struct page *page)\n{\n\tstruct pagevec *pvec = &get_cpu_var(lru_add_pvec);\n\tint i;\n\n\t/*\n\t * Search backwards on the optimistic assumption that the page being\n\t * activated has just been added to this pagevec. Note that only\n\t * the local pagevec is examined as a !PageLRU page could be in the\n\t * process of being released, reclaimed, migrated or on a remote\n\t * pagevec that is currently being drained. Furthermore, marking\n\t * a remote pagevec's page PageActive potentially hits a race where\n\t * a page is marked PageActive just after it is added to the inactive\n\t * list causing accounting errors and BUG_ON checks to trigger.\n\t */\n\tfor (i = pagevec_count(pvec) - 1; i >= 0; i--) {\n\t\tstruct page *pagevec_page = pvec->pages[i];\n\n\t\tif (pagevec_page == page) {\n\t\t\tSetPageActive(page);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tput_cpu_var(lru_add_pvec);\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cpu_var",
          "args": [
            "lru_add_pvec"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageActive",
          "args": [
            "page"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "pvec"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu_var",
          "args": [
            "lru_add_pvec"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\n\nstatic void __lru_cache_activate_page(struct page *page)\n{\n\tstruct pagevec *pvec = &get_cpu_var(lru_add_pvec);\n\tint i;\n\n\t/*\n\t * Search backwards on the optimistic assumption that the page being\n\t * activated has just been added to this pagevec. Note that only\n\t * the local pagevec is examined as a !PageLRU page could be in the\n\t * process of being released, reclaimed, migrated or on a remote\n\t * pagevec that is currently being drained. Furthermore, marking\n\t * a remote pagevec's page PageActive potentially hits a race where\n\t * a page is marked PageActive just after it is added to the inactive\n\t * list causing accounting errors and BUG_ON checks to trigger.\n\t */\n\tfor (i = pagevec_count(pvec) - 1; i >= 0; i--) {\n\t\tstruct page *pagevec_page = pvec->pages[i];\n\n\t\tif (pagevec_page == page) {\n\t\t\tSetPageActive(page);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tput_cpu_var(lru_add_pvec);\n}"
  },
  {
    "function_name": "activate_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "328-336",
    "snippet": "void activate_page(struct page *page)\n{\n\tstruct zone *zone = page_zone(page);\n\n\tpage = compound_head(page);\n\tspin_lock_irq(zone_lru_lock(zone));\n\t__activate_page(page, mem_cgroup_page_lruvec(page, zone->zone_pgdat), NULL);\n\tspin_unlock_irq(zone_lru_lock(zone));\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "zone_lru_lock(zone)"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_lru_lock",
          "args": [
            "zone"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__activate_page",
          "args": [
            "page",
            "mem_cgroup_page_lruvec(page, zone->zone_pgdat)",
            "NULL"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "__activate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "273-289",
          "snippet": "static void __activate_page(struct page *page, struct lruvec *lruvec,\n\t\t\t    void *arg)\n{\n\tif (PageLRU(page) && !PageActive(page) && !PageUnevictable(page)) {\n\t\tint file = page_is_file_cache(page);\n\t\tint lru = page_lru_base_type(page);\n\n\t\tdel_page_from_lru_list(page, lruvec, lru);\n\t\tSetPageActive(page);\n\t\tlru += LRU_ACTIVE;\n\t\tadd_page_to_lru_list(page, lruvec, lru);\n\t\ttrace_mm_lru_activate(page);\n\n\t\t__count_vm_event(PGACTIVATE);\n\t\tupdate_page_reclaim_stat(lruvec, file, 1);\n\t}\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void __activate_page(struct page *page, struct lruvec *lruvec,\n\t\t\t    void *arg)\n{\n\tif (PageLRU(page) && !PageActive(page) && !PageUnevictable(page)) {\n\t\tint file = page_is_file_cache(page);\n\t\tint lru = page_lru_base_type(page);\n\n\t\tdel_page_from_lru_list(page, lruvec, lru);\n\t\tSetPageActive(page);\n\t\tlru += LRU_ACTIVE;\n\t\tadd_page_to_lru_list(page, lruvec, lru);\n\t\ttrace_mm_lru_activate(page);\n\n\t\t__count_vm_event(PGACTIVATE);\n\t\tupdate_page_reclaim_stat(lruvec, file, 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_page_lruvec",
          "args": [
            "page",
            "zone->zone_pgdat"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_page_lruvec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1100-1130",
          "snippet": "struct lruvec *mem_cgroup_page_lruvec(struct page *page, struct pglist_data *pgdat)\n{\n\tstruct mem_cgroup_per_node *mz;\n\tstruct mem_cgroup *memcg;\n\tstruct lruvec *lruvec;\n\n\tif (mem_cgroup_disabled()) {\n\t\tlruvec = &pgdat->lruvec;\n\t\tgoto out;\n\t}\n\n\tmemcg = page->mem_cgroup;\n\t/*\n\t * Swapcache readahead pages are added to the LRU - and\n\t * possibly migrated - before they are charged.\n\t */\n\tif (!memcg)\n\t\tmemcg = root_mem_cgroup;\n\n\tmz = mem_cgroup_page_nodeinfo(memcg, page);\n\tlruvec = &mz->lruvec;\nout:\n\t/*\n\t * Since a node can be onlined after the mem_cgroup was created,\n\t * we have to be prepared to initialize lruvec->zone here;\n\t * and if offlined then reonlined, we need to reinitialize it.\n\t */\n\tif (unlikely(lruvec->pgdat != pgdat))\n\t\tlruvec->pgdat = pgdat;\n\treturn lruvec;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstruct lruvec *mem_cgroup_page_lruvec(struct page *page, struct pglist_data *pgdat)\n{\n\tstruct mem_cgroup_per_node *mz;\n\tstruct mem_cgroup *memcg;\n\tstruct lruvec *lruvec;\n\n\tif (mem_cgroup_disabled()) {\n\t\tlruvec = &pgdat->lruvec;\n\t\tgoto out;\n\t}\n\n\tmemcg = page->mem_cgroup;\n\t/*\n\t * Swapcache readahead pages are added to the LRU - and\n\t * possibly migrated - before they are charged.\n\t */\n\tif (!memcg)\n\t\tmemcg = root_mem_cgroup;\n\n\tmz = mem_cgroup_page_nodeinfo(memcg, page);\n\tlruvec = &mz->lruvec;\nout:\n\t/*\n\t * Since a node can be onlined after the mem_cgroup was created,\n\t * we have to be prepared to initialize lruvec->zone here;\n\t * and if offlined then reonlined, we need to reinitialize it.\n\t */\n\tif (unlikely(lruvec->pgdat != pgdat))\n\t\tlruvec->pgdat = pgdat;\n\treturn lruvec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "zone_lru_lock(zone)"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_lru_lock",
          "args": [
            "zone"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid activate_page(struct page *page)\n{\n\tstruct zone *zone = page_zone(page);\n\n\tpage = compound_head(page);\n\tspin_lock_irq(zone_lru_lock(zone));\n\t__activate_page(page, mem_cgroup_page_lruvec(page, zone->zone_pgdat), NULL);\n\tspin_unlock_irq(zone_lru_lock(zone));\n}"
  },
  {
    "function_name": "need_activate_page_drain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "323-326",
    "snippet": "static bool need_activate_page_drain(int cpu)\n{\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic bool need_activate_page_drain(int cpu)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "activate_page_drain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "319-321",
    "snippet": "static inline void activate_page_drain(int cpu)\n{\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic inline void activate_page_drain(int cpu)\n{\n}"
  },
  {
    "function_name": "activate_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "305-316",
    "snippet": "void activate_page(struct page *page)\n{\n\tpage = compound_head(page);\n\tif (PageLRU(page) && !PageActive(page) && !PageUnevictable(page)) {\n\t\tstruct pagevec *pvec = &get_cpu_var(activate_page_pvecs);\n\n\t\tget_page(page);\n\t\tif (!pagevec_add(pvec, page) || PageCompound(page))\n\t\t\tpagevec_lru_move_fn(pvec, __activate_page, NULL);\n\t\tput_cpu_var(activate_page_pvecs);\n\t}\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cpu_var",
          "args": [
            "activate_page_pvecs"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_lru_move_fn",
          "args": [
            "pvec",
            "__activate_page",
            "NULL"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "pagevec_lru_move_fn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "188-215",
          "snippet": "static void pagevec_lru_move_fn(struct pagevec *pvec,\n\tvoid (*move_fn)(struct page *page, struct lruvec *lruvec, void *arg),\n\tvoid *arg)\n{\n\tint i;\n\tstruct pglist_data *pgdat = NULL;\n\tstruct lruvec *lruvec;\n\tunsigned long flags = 0;\n\n\tfor (i = 0; i < pagevec_count(pvec); i++) {\n\t\tstruct page *page = pvec->pages[i];\n\t\tstruct pglist_data *pagepgdat = page_pgdat(page);\n\n\t\tif (pagepgdat != pgdat) {\n\t\t\tif (pgdat)\n\t\t\t\tspin_unlock_irqrestore(&pgdat->lru_lock, flags);\n\t\t\tpgdat = pagepgdat;\n\t\t\tspin_lock_irqsave(&pgdat->lru_lock, flags);\n\t\t}\n\n\t\tlruvec = mem_cgroup_page_lruvec(page, pgdat);\n\t\t(*move_fn)(page, lruvec, arg);\n\t}\n\tif (pgdat)\n\t\tspin_unlock_irqrestore(&pgdat->lru_lock, flags);\n\trelease_pages(pvec->pages, pvec->nr);\n\tpagevec_reinit(pvec);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void pagevec_lru_move_fn(struct pagevec *pvec,\n\tvoid (*move_fn)(struct page *page, struct lruvec *lruvec, void *arg),\n\tvoid *arg)\n{\n\tint i;\n\tstruct pglist_data *pgdat = NULL;\n\tstruct lruvec *lruvec;\n\tunsigned long flags = 0;\n\n\tfor (i = 0; i < pagevec_count(pvec); i++) {\n\t\tstruct page *page = pvec->pages[i];\n\t\tstruct pglist_data *pagepgdat = page_pgdat(page);\n\n\t\tif (pagepgdat != pgdat) {\n\t\t\tif (pgdat)\n\t\t\t\tspin_unlock_irqrestore(&pgdat->lru_lock, flags);\n\t\t\tpgdat = pagepgdat;\n\t\t\tspin_lock_irqsave(&pgdat->lru_lock, flags);\n\t\t}\n\n\t\tlruvec = mem_cgroup_page_lruvec(page, pgdat);\n\t\t(*move_fn)(page, lruvec, arg);\n\t}\n\tif (pgdat)\n\t\tspin_unlock_irqrestore(&pgdat->lru_lock, flags);\n\trelease_pages(pvec->pages, pvec->nr);\n\tpagevec_reinit(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "page"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_add",
          "args": [
            "pvec",
            "page"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "page"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cpu_var",
          "args": [
            "activate_page_pvecs"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUnevictable",
          "args": [
            "page"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageActive",
          "args": [
            "page"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid activate_page(struct page *page)\n{\n\tpage = compound_head(page);\n\tif (PageLRU(page) && !PageActive(page) && !PageUnevictable(page)) {\n\t\tstruct pagevec *pvec = &get_cpu_var(activate_page_pvecs);\n\n\t\tget_page(page);\n\t\tif (!pagevec_add(pvec, page) || PageCompound(page))\n\t\t\tpagevec_lru_move_fn(pvec, __activate_page, NULL);\n\t\tput_cpu_var(activate_page_pvecs);\n\t}\n}"
  },
  {
    "function_name": "need_activate_page_drain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "300-303",
    "snippet": "static bool need_activate_page_drain(int cpu)\n{\n\treturn pagevec_count(&per_cpu(activate_page_pvecs, cpu)) != 0;\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "&per_cpu(activate_page_pvecs, cpu)"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "activate_page_pvecs",
            "cpu"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic bool need_activate_page_drain(int cpu)\n{\n\treturn pagevec_count(&per_cpu(activate_page_pvecs, cpu)) != 0;\n}"
  },
  {
    "function_name": "activate_page_drain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "292-298",
    "snippet": "static void activate_page_drain(int cpu)\n{\n\tstruct pagevec *pvec = &per_cpu(activate_page_pvecs, cpu);\n\n\tif (pagevec_count(pvec))\n\t\tpagevec_lru_move_fn(pvec, __activate_page, NULL);\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pagevec_lru_move_fn",
          "args": [
            "pvec",
            "__activate_page",
            "NULL"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "pagevec_lru_move_fn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "188-215",
          "snippet": "static void pagevec_lru_move_fn(struct pagevec *pvec,\n\tvoid (*move_fn)(struct page *page, struct lruvec *lruvec, void *arg),\n\tvoid *arg)\n{\n\tint i;\n\tstruct pglist_data *pgdat = NULL;\n\tstruct lruvec *lruvec;\n\tunsigned long flags = 0;\n\n\tfor (i = 0; i < pagevec_count(pvec); i++) {\n\t\tstruct page *page = pvec->pages[i];\n\t\tstruct pglist_data *pagepgdat = page_pgdat(page);\n\n\t\tif (pagepgdat != pgdat) {\n\t\t\tif (pgdat)\n\t\t\t\tspin_unlock_irqrestore(&pgdat->lru_lock, flags);\n\t\t\tpgdat = pagepgdat;\n\t\t\tspin_lock_irqsave(&pgdat->lru_lock, flags);\n\t\t}\n\n\t\tlruvec = mem_cgroup_page_lruvec(page, pgdat);\n\t\t(*move_fn)(page, lruvec, arg);\n\t}\n\tif (pgdat)\n\t\tspin_unlock_irqrestore(&pgdat->lru_lock, flags);\n\trelease_pages(pvec->pages, pvec->nr);\n\tpagevec_reinit(pvec);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void pagevec_lru_move_fn(struct pagevec *pvec,\n\tvoid (*move_fn)(struct page *page, struct lruvec *lruvec, void *arg),\n\tvoid *arg)\n{\n\tint i;\n\tstruct pglist_data *pgdat = NULL;\n\tstruct lruvec *lruvec;\n\tunsigned long flags = 0;\n\n\tfor (i = 0; i < pagevec_count(pvec); i++) {\n\t\tstruct page *page = pvec->pages[i];\n\t\tstruct pglist_data *pagepgdat = page_pgdat(page);\n\n\t\tif (pagepgdat != pgdat) {\n\t\t\tif (pgdat)\n\t\t\t\tspin_unlock_irqrestore(&pgdat->lru_lock, flags);\n\t\t\tpgdat = pagepgdat;\n\t\t\tspin_lock_irqsave(&pgdat->lru_lock, flags);\n\t\t}\n\n\t\tlruvec = mem_cgroup_page_lruvec(page, pgdat);\n\t\t(*move_fn)(page, lruvec, arg);\n\t}\n\tif (pgdat)\n\t\tspin_unlock_irqrestore(&pgdat->lru_lock, flags);\n\trelease_pages(pvec->pages, pvec->nr);\n\tpagevec_reinit(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "pvec"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "activate_page_pvecs",
            "cpu"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void activate_page_drain(int cpu)\n{\n\tstruct pagevec *pvec = &per_cpu(activate_page_pvecs, cpu);\n\n\tif (pagevec_count(pvec))\n\t\tpagevec_lru_move_fn(pvec, __activate_page, NULL);\n}"
  },
  {
    "function_name": "__activate_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "273-289",
    "snippet": "static void __activate_page(struct page *page, struct lruvec *lruvec,\n\t\t\t    void *arg)\n{\n\tif (PageLRU(page) && !PageActive(page) && !PageUnevictable(page)) {\n\t\tint file = page_is_file_cache(page);\n\t\tint lru = page_lru_base_type(page);\n\n\t\tdel_page_from_lru_list(page, lruvec, lru);\n\t\tSetPageActive(page);\n\t\tlru += LRU_ACTIVE;\n\t\tadd_page_to_lru_list(page, lruvec, lru);\n\t\ttrace_mm_lru_activate(page);\n\n\t\t__count_vm_event(PGACTIVATE);\n\t\tupdate_page_reclaim_stat(lruvec, file, 1);\n\t}\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_page_reclaim_stat",
          "args": [
            "lruvec",
            "file",
            "1"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "update_page_reclaim_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "263-271",
          "snippet": "static void update_page_reclaim_stat(struct lruvec *lruvec,\n\t\t\t\t     int file, int rotated)\n{\n\tstruct zone_reclaim_stat *reclaim_stat = &lruvec->reclaim_stat;\n\n\treclaim_stat->recent_scanned[file]++;\n\tif (rotated)\n\t\treclaim_stat->recent_rotated[file]++;\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void update_page_reclaim_stat(struct lruvec *lruvec,\n\t\t\t\t     int file, int rotated)\n{\n\tstruct zone_reclaim_stat *reclaim_stat = &lruvec->reclaim_stat;\n\n\treclaim_stat->recent_scanned[file]++;\n\tif (rotated)\n\t\treclaim_stat->recent_rotated[file]++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__count_vm_event",
          "args": [
            "PGACTIVATE"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_mm_lru_activate",
          "args": [
            "page"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_page_to_lru_list",
          "args": [
            "page",
            "lruvec",
            "lru"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageActive",
          "args": [
            "page"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "del_page_from_lru_list",
          "args": [
            "page",
            "lruvec",
            "lru"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_lru_base_type",
          "args": [
            "page"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_is_file_cache",
          "args": [
            "page"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUnevictable",
          "args": [
            "page"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageActive",
          "args": [
            "page"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void __activate_page(struct page *page, struct lruvec *lruvec,\n\t\t\t    void *arg)\n{\n\tif (PageLRU(page) && !PageActive(page) && !PageUnevictable(page)) {\n\t\tint file = page_is_file_cache(page);\n\t\tint lru = page_lru_base_type(page);\n\n\t\tdel_page_from_lru_list(page, lruvec, lru);\n\t\tSetPageActive(page);\n\t\tlru += LRU_ACTIVE;\n\t\tadd_page_to_lru_list(page, lruvec, lru);\n\t\ttrace_mm_lru_activate(page);\n\n\t\t__count_vm_event(PGACTIVATE);\n\t\tupdate_page_reclaim_stat(lruvec, file, 1);\n\t}\n}"
  },
  {
    "function_name": "update_page_reclaim_stat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "263-271",
    "snippet": "static void update_page_reclaim_stat(struct lruvec *lruvec,\n\t\t\t\t     int file, int rotated)\n{\n\tstruct zone_reclaim_stat *reclaim_stat = &lruvec->reclaim_stat;\n\n\treclaim_stat->recent_scanned[file]++;\n\tif (rotated)\n\t\treclaim_stat->recent_rotated[file]++;\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void update_page_reclaim_stat(struct lruvec *lruvec,\n\t\t\t\t     int file, int rotated)\n{\n\tstruct zone_reclaim_stat *reclaim_stat = &lruvec->reclaim_stat;\n\n\treclaim_stat->recent_scanned[file]++;\n\tif (rotated)\n\t\treclaim_stat->recent_rotated[file]++;\n}"
  },
  {
    "function_name": "rotate_reclaimable_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "247-261",
    "snippet": "void rotate_reclaimable_page(struct page *page)\n{\n\tif (!PageLocked(page) && !PageDirty(page) &&\n\t    !PageUnevictable(page) && PageLRU(page)) {\n\t\tstruct pagevec *pvec;\n\t\tunsigned long flags;\n\n\t\tget_page(page);\n\t\tlocal_irq_save(flags);\n\t\tpvec = this_cpu_ptr(&lru_rotate_pvecs);\n\t\tif (!pagevec_add(pvec, page) || PageCompound(page))\n\t\t\tpagevec_move_tail(pvec);\n\t\tlocal_irq_restore(flags);\n\t}\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_move_tail",
          "args": [
            "pvec"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "pagevec_move_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "234-240",
          "snippet": "static void pagevec_move_tail(struct pagevec *pvec)\n{\n\tint pgmoved = 0;\n\n\tpagevec_lru_move_fn(pvec, pagevec_move_tail_fn, &pgmoved);\n\t__count_vm_events(PGROTATED, pgmoved);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void pagevec_move_tail(struct pagevec *pvec)\n{\n\tint pgmoved = 0;\n\n\tpagevec_lru_move_fn(pvec, pagevec_move_tail_fn, &pgmoved);\n\t__count_vm_events(PGROTATED, pgmoved);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "page"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_add",
          "args": [
            "pvec",
            "page"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&lru_rotate_pvecs"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "page"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUnevictable",
          "args": [
            "page"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);\n\nvoid rotate_reclaimable_page(struct page *page)\n{\n\tif (!PageLocked(page) && !PageDirty(page) &&\n\t    !PageUnevictable(page) && PageLRU(page)) {\n\t\tstruct pagevec *pvec;\n\t\tunsigned long flags;\n\n\t\tget_page(page);\n\t\tlocal_irq_save(flags);\n\t\tpvec = this_cpu_ptr(&lru_rotate_pvecs);\n\t\tif (!pagevec_add(pvec, page) || PageCompound(page))\n\t\t\tpagevec_move_tail(pvec);\n\t\tlocal_irq_restore(flags);\n\t}\n}"
  },
  {
    "function_name": "pagevec_move_tail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "234-240",
    "snippet": "static void pagevec_move_tail(struct pagevec *pvec)\n{\n\tint pgmoved = 0;\n\n\tpagevec_lru_move_fn(pvec, pagevec_move_tail_fn, &pgmoved);\n\t__count_vm_events(PGROTATED, pgmoved);\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__count_vm_events",
          "args": [
            "PGROTATED",
            "pgmoved"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_lru_move_fn",
          "args": [
            "pvec",
            "pagevec_move_tail_fn",
            "&pgmoved"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "pagevec_lru_move_fn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "188-215",
          "snippet": "static void pagevec_lru_move_fn(struct pagevec *pvec,\n\tvoid (*move_fn)(struct page *page, struct lruvec *lruvec, void *arg),\n\tvoid *arg)\n{\n\tint i;\n\tstruct pglist_data *pgdat = NULL;\n\tstruct lruvec *lruvec;\n\tunsigned long flags = 0;\n\n\tfor (i = 0; i < pagevec_count(pvec); i++) {\n\t\tstruct page *page = pvec->pages[i];\n\t\tstruct pglist_data *pagepgdat = page_pgdat(page);\n\n\t\tif (pagepgdat != pgdat) {\n\t\t\tif (pgdat)\n\t\t\t\tspin_unlock_irqrestore(&pgdat->lru_lock, flags);\n\t\t\tpgdat = pagepgdat;\n\t\t\tspin_lock_irqsave(&pgdat->lru_lock, flags);\n\t\t}\n\n\t\tlruvec = mem_cgroup_page_lruvec(page, pgdat);\n\t\t(*move_fn)(page, lruvec, arg);\n\t}\n\tif (pgdat)\n\t\tspin_unlock_irqrestore(&pgdat->lru_lock, flags);\n\trelease_pages(pvec->pages, pvec->nr);\n\tpagevec_reinit(pvec);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void pagevec_lru_move_fn(struct pagevec *pvec,\n\tvoid (*move_fn)(struct page *page, struct lruvec *lruvec, void *arg),\n\tvoid *arg)\n{\n\tint i;\n\tstruct pglist_data *pgdat = NULL;\n\tstruct lruvec *lruvec;\n\tunsigned long flags = 0;\n\n\tfor (i = 0; i < pagevec_count(pvec); i++) {\n\t\tstruct page *page = pvec->pages[i];\n\t\tstruct pglist_data *pagepgdat = page_pgdat(page);\n\n\t\tif (pagepgdat != pgdat) {\n\t\t\tif (pgdat)\n\t\t\t\tspin_unlock_irqrestore(&pgdat->lru_lock, flags);\n\t\t\tpgdat = pagepgdat;\n\t\t\tspin_lock_irqsave(&pgdat->lru_lock, flags);\n\t\t}\n\n\t\tlruvec = mem_cgroup_page_lruvec(page, pgdat);\n\t\t(*move_fn)(page, lruvec, arg);\n\t}\n\tif (pgdat)\n\t\tspin_unlock_irqrestore(&pgdat->lru_lock, flags);\n\trelease_pages(pvec->pages, pvec->nr);\n\tpagevec_reinit(pvec);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void pagevec_move_tail(struct pagevec *pvec)\n{\n\tint pgmoved = 0;\n\n\tpagevec_lru_move_fn(pvec, pagevec_move_tail_fn, &pgmoved);\n\t__count_vm_events(PGROTATED, pgmoved);\n}"
  },
  {
    "function_name": "pagevec_move_tail_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "217-228",
    "snippet": "static void pagevec_move_tail_fn(struct page *page, struct lruvec *lruvec,\n\t\t\t\t void *arg)\n{\n\tint *pgmoved = arg;\n\n\tif (PageLRU(page) && !PageUnevictable(page)) {\n\t\tdel_page_from_lru_list(page, lruvec, page_lru(page));\n\t\tClearPageActive(page);\n\t\tadd_page_to_lru_list_tail(page, lruvec, page_lru(page));\n\t\t(*pgmoved)++;\n\t}\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_page_to_lru_list_tail",
          "args": [
            "page",
            "lruvec",
            "page_lru(page)"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_lru",
          "args": [
            "page"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageActive",
          "args": [
            "page"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "del_page_from_lru_list",
          "args": [
            "page",
            "lruvec",
            "page_lru(page)"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_lru",
          "args": [
            "page"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUnevictable",
          "args": [
            "page"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void pagevec_move_tail_fn(struct page *page, struct lruvec *lruvec,\n\t\t\t\t void *arg)\n{\n\tint *pgmoved = arg;\n\n\tif (PageLRU(page) && !PageUnevictable(page)) {\n\t\tdel_page_from_lru_list(page, lruvec, page_lru(page));\n\t\tClearPageActive(page);\n\t\tadd_page_to_lru_list_tail(page, lruvec, page_lru(page));\n\t\t(*pgmoved)++;\n\t}\n}"
  },
  {
    "function_name": "pagevec_lru_move_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "188-215",
    "snippet": "static void pagevec_lru_move_fn(struct pagevec *pvec,\n\tvoid (*move_fn)(struct page *page, struct lruvec *lruvec, void *arg),\n\tvoid *arg)\n{\n\tint i;\n\tstruct pglist_data *pgdat = NULL;\n\tstruct lruvec *lruvec;\n\tunsigned long flags = 0;\n\n\tfor (i = 0; i < pagevec_count(pvec); i++) {\n\t\tstruct page *page = pvec->pages[i];\n\t\tstruct pglist_data *pagepgdat = page_pgdat(page);\n\n\t\tif (pagepgdat != pgdat) {\n\t\t\tif (pgdat)\n\t\t\t\tspin_unlock_irqrestore(&pgdat->lru_lock, flags);\n\t\t\tpgdat = pagepgdat;\n\t\t\tspin_lock_irqsave(&pgdat->lru_lock, flags);\n\t\t}\n\n\t\tlruvec = mem_cgroup_page_lruvec(page, pgdat);\n\t\t(*move_fn)(page, lruvec, arg);\n\t}\n\tif (pgdat)\n\t\tspin_unlock_irqrestore(&pgdat->lru_lock, flags);\n\trelease_pages(pvec->pages, pvec->nr);\n\tpagevec_reinit(pvec);\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pagevec_reinit",
          "args": [
            "pvec"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "release_pages",
          "args": [
            "pvec->pages",
            "pvec->nr"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "release_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "714-792",
          "snippet": "void release_pages(struct page **pages, int nr)\n{\n\tint i;\n\tLIST_HEAD(pages_to_free);\n\tstruct pglist_data *locked_pgdat = NULL;\n\tstruct lruvec *lruvec;\n\tunsigned long uninitialized_var(flags);\n\tunsigned int uninitialized_var(lock_batch);\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct page *page = pages[i];\n\n\t\t/*\n\t\t * Make sure the IRQ-safe lock-holding time does not get\n\t\t * excessive with a continuous string of pages from the\n\t\t * same pgdat. The lock is held only if pgdat != NULL.\n\t\t */\n\t\tif (locked_pgdat && ++lock_batch == SWAP_CLUSTER_MAX) {\n\t\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock, flags);\n\t\t\tlocked_pgdat = NULL;\n\t\t}\n\n\t\tif (is_huge_zero_page(page))\n\t\t\tcontinue;\n\n\t\t/* Device public page can not be huge page */\n\t\tif (is_device_public_page(page)) {\n\t\t\tif (locked_pgdat) {\n\t\t\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock,\n\t\t\t\t\t\t       flags);\n\t\t\t\tlocked_pgdat = NULL;\n\t\t\t}\n\t\t\tput_devmap_managed_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpage = compound_head(page);\n\t\tif (!put_page_testzero(page))\n\t\t\tcontinue;\n\n\t\tif (PageCompound(page)) {\n\t\t\tif (locked_pgdat) {\n\t\t\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock, flags);\n\t\t\t\tlocked_pgdat = NULL;\n\t\t\t}\n\t\t\t__put_compound_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (PageLRU(page)) {\n\t\t\tstruct pglist_data *pgdat = page_pgdat(page);\n\n\t\t\tif (pgdat != locked_pgdat) {\n\t\t\t\tif (locked_pgdat)\n\t\t\t\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock,\n\t\t\t\t\t\t\t\t\tflags);\n\t\t\t\tlock_batch = 0;\n\t\t\t\tlocked_pgdat = pgdat;\n\t\t\t\tspin_lock_irqsave(&locked_pgdat->lru_lock, flags);\n\t\t\t}\n\n\t\t\tlruvec = mem_cgroup_page_lruvec(page, locked_pgdat);\n\t\t\tVM_BUG_ON_PAGE(!PageLRU(page), page);\n\t\t\t__ClearPageLRU(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, page_off_lru(page));\n\t\t}\n\n\t\t/* Clear Active bit in case of parallel mark_page_accessed */\n\t\t__ClearPageActive(page);\n\t\t__ClearPageWaiters(page);\n\n\t\tlist_add(&page->lru, &pages_to_free);\n\t}\n\tif (locked_pgdat)\n\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock, flags);\n\n\tmem_cgroup_uncharge_list(&pages_to_free);\n\tfree_unref_page_list(&pages_to_free);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid release_pages(struct page **pages, int nr)\n{\n\tint i;\n\tLIST_HEAD(pages_to_free);\n\tstruct pglist_data *locked_pgdat = NULL;\n\tstruct lruvec *lruvec;\n\tunsigned long uninitialized_var(flags);\n\tunsigned int uninitialized_var(lock_batch);\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct page *page = pages[i];\n\n\t\t/*\n\t\t * Make sure the IRQ-safe lock-holding time does not get\n\t\t * excessive with a continuous string of pages from the\n\t\t * same pgdat. The lock is held only if pgdat != NULL.\n\t\t */\n\t\tif (locked_pgdat && ++lock_batch == SWAP_CLUSTER_MAX) {\n\t\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock, flags);\n\t\t\tlocked_pgdat = NULL;\n\t\t}\n\n\t\tif (is_huge_zero_page(page))\n\t\t\tcontinue;\n\n\t\t/* Device public page can not be huge page */\n\t\tif (is_device_public_page(page)) {\n\t\t\tif (locked_pgdat) {\n\t\t\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock,\n\t\t\t\t\t\t       flags);\n\t\t\t\tlocked_pgdat = NULL;\n\t\t\t}\n\t\t\tput_devmap_managed_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpage = compound_head(page);\n\t\tif (!put_page_testzero(page))\n\t\t\tcontinue;\n\n\t\tif (PageCompound(page)) {\n\t\t\tif (locked_pgdat) {\n\t\t\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock, flags);\n\t\t\t\tlocked_pgdat = NULL;\n\t\t\t}\n\t\t\t__put_compound_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (PageLRU(page)) {\n\t\t\tstruct pglist_data *pgdat = page_pgdat(page);\n\n\t\t\tif (pgdat != locked_pgdat) {\n\t\t\t\tif (locked_pgdat)\n\t\t\t\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock,\n\t\t\t\t\t\t\t\t\tflags);\n\t\t\t\tlock_batch = 0;\n\t\t\t\tlocked_pgdat = pgdat;\n\t\t\t\tspin_lock_irqsave(&locked_pgdat->lru_lock, flags);\n\t\t\t}\n\n\t\t\tlruvec = mem_cgroup_page_lruvec(page, locked_pgdat);\n\t\t\tVM_BUG_ON_PAGE(!PageLRU(page), page);\n\t\t\t__ClearPageLRU(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, page_off_lru(page));\n\t\t}\n\n\t\t/* Clear Active bit in case of parallel mark_page_accessed */\n\t\t__ClearPageActive(page);\n\t\t__ClearPageWaiters(page);\n\n\t\tlist_add(&page->lru, &pages_to_free);\n\t}\n\tif (locked_pgdat)\n\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock, flags);\n\n\tmem_cgroup_uncharge_list(&pages_to_free);\n\tfree_unref_page_list(&pages_to_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pgdat->lru_lock",
            "flags"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "page",
            "lruvec",
            "arg"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_page_lruvec",
          "args": [
            "page",
            "pgdat"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_page_lruvec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1100-1130",
          "snippet": "struct lruvec *mem_cgroup_page_lruvec(struct page *page, struct pglist_data *pgdat)\n{\n\tstruct mem_cgroup_per_node *mz;\n\tstruct mem_cgroup *memcg;\n\tstruct lruvec *lruvec;\n\n\tif (mem_cgroup_disabled()) {\n\t\tlruvec = &pgdat->lruvec;\n\t\tgoto out;\n\t}\n\n\tmemcg = page->mem_cgroup;\n\t/*\n\t * Swapcache readahead pages are added to the LRU - and\n\t * possibly migrated - before they are charged.\n\t */\n\tif (!memcg)\n\t\tmemcg = root_mem_cgroup;\n\n\tmz = mem_cgroup_page_nodeinfo(memcg, page);\n\tlruvec = &mz->lruvec;\nout:\n\t/*\n\t * Since a node can be onlined after the mem_cgroup was created,\n\t * we have to be prepared to initialize lruvec->zone here;\n\t * and if offlined then reonlined, we need to reinitialize it.\n\t */\n\tif (unlikely(lruvec->pgdat != pgdat))\n\t\tlruvec->pgdat = pgdat;\n\treturn lruvec;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstruct lruvec *mem_cgroup_page_lruvec(struct page *page, struct pglist_data *pgdat)\n{\n\tstruct mem_cgroup_per_node *mz;\n\tstruct mem_cgroup *memcg;\n\tstruct lruvec *lruvec;\n\n\tif (mem_cgroup_disabled()) {\n\t\tlruvec = &pgdat->lruvec;\n\t\tgoto out;\n\t}\n\n\tmemcg = page->mem_cgroup;\n\t/*\n\t * Swapcache readahead pages are added to the LRU - and\n\t * possibly migrated - before they are charged.\n\t */\n\tif (!memcg)\n\t\tmemcg = root_mem_cgroup;\n\n\tmz = mem_cgroup_page_nodeinfo(memcg, page);\n\tlruvec = &mz->lruvec;\nout:\n\t/*\n\t * Since a node can be onlined after the mem_cgroup was created,\n\t * we have to be prepared to initialize lruvec->zone here;\n\t * and if offlined then reonlined, we need to reinitialize it.\n\t */\n\tif (unlikely(lruvec->pgdat != pgdat))\n\t\tlruvec->pgdat = pgdat;\n\treturn lruvec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&pgdat->lru_lock",
            "flags"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pgdat->lru_lock",
            "flags"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_pgdat",
          "args": [
            "page"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "pvec"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void pagevec_lru_move_fn(struct pagevec *pvec,\n\tvoid (*move_fn)(struct page *page, struct lruvec *lruvec, void *arg),\n\tvoid *arg)\n{\n\tint i;\n\tstruct pglist_data *pgdat = NULL;\n\tstruct lruvec *lruvec;\n\tunsigned long flags = 0;\n\n\tfor (i = 0; i < pagevec_count(pvec); i++) {\n\t\tstruct page *page = pvec->pages[i];\n\t\tstruct pglist_data *pagepgdat = page_pgdat(page);\n\n\t\tif (pagepgdat != pgdat) {\n\t\t\tif (pgdat)\n\t\t\t\tspin_unlock_irqrestore(&pgdat->lru_lock, flags);\n\t\t\tpgdat = pagepgdat;\n\t\t\tspin_lock_irqsave(&pgdat->lru_lock, flags);\n\t\t}\n\n\t\tlruvec = mem_cgroup_page_lruvec(page, pgdat);\n\t\t(*move_fn)(page, lruvec, arg);\n\t}\n\tif (pgdat)\n\t\tspin_unlock_irqrestore(&pgdat->lru_lock, flags);\n\trelease_pages(pvec->pages, pvec->nr);\n\tpagevec_reinit(pvec);\n}"
  },
  {
    "function_name": "get_kernel_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "177-185",
    "snippet": "int get_kernel_page(unsigned long start, int write, struct page **pages)\n{\n\tconst struct kvec kiov = {\n\t\t.iov_base = (void *)start,\n\t\t.iov_len = PAGE_SIZE\n\t};\n\n\treturn get_kernel_pages(&kiov, 1, write, pages);\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_kernel_pages",
          "args": [
            "&kiov",
            "1",
            "write",
            "pages"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "get_kernel_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "149-163",
          "snippet": "int get_kernel_pages(const struct kvec *kiov, int nr_segs, int write,\n\t\tstruct page **pages)\n{\n\tint seg;\n\n\tfor (seg = 0; seg < nr_segs; seg++) {\n\t\tif (WARN_ON(kiov[seg].iov_len != PAGE_SIZE))\n\t\t\treturn seg;\n\n\t\tpages[seg] = kmap_to_page(kiov[seg].iov_base);\n\t\tget_page(pages[seg]);\n\t}\n\n\treturn seg;\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nint get_kernel_pages(const struct kvec *kiov, int nr_segs, int write,\n\t\tstruct page **pages)\n{\n\tint seg;\n\n\tfor (seg = 0; seg < nr_segs; seg++) {\n\t\tif (WARN_ON(kiov[seg].iov_len != PAGE_SIZE))\n\t\t\treturn seg;\n\n\t\tpages[seg] = kmap_to_page(kiov[seg].iov_base);\n\t\tget_page(pages[seg]);\n\t}\n\n\treturn seg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nint get_kernel_page(unsigned long start, int write, struct page **pages)\n{\n\tconst struct kvec kiov = {\n\t\t.iov_base = (void *)start,\n\t\t.iov_len = PAGE_SIZE\n\t};\n\n\treturn get_kernel_pages(&kiov, 1, write, pages);\n}"
  },
  {
    "function_name": "get_kernel_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "149-163",
    "snippet": "int get_kernel_pages(const struct kvec *kiov, int nr_segs, int write,\n\t\tstruct page **pages)\n{\n\tint seg;\n\n\tfor (seg = 0; seg < nr_segs; seg++) {\n\t\tif (WARN_ON(kiov[seg].iov_len != PAGE_SIZE))\n\t\t\treturn seg;\n\n\t\tpages[seg] = kmap_to_page(kiov[seg].iov_base);\n\t\tget_page(pages[seg]);\n\t}\n\n\treturn seg;\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "pages[seg]"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_to_page",
          "args": [
            "kiov[seg].iov_base"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "kmap_to_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "151-161",
          "snippet": "struct page *kmap_to_page(void *vaddr)\n{\n\tunsigned long addr = (unsigned long)vaddr;\n\n\tif (addr >= PKMAP_ADDR(0) && addr < PKMAP_ADDR(LAST_PKMAP)) {\n\t\tint i = PKMAP_NR(addr);\n\t\treturn pte_page(pkmap_page_table[i]);\n\t}\n\n\treturn virt_to_page(addr);\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct page *kmap_to_page(void *vaddr)\n{\n\tunsigned long addr = (unsigned long)vaddr;\n\n\tif (addr >= PKMAP_ADDR(0) && addr < PKMAP_ADDR(LAST_PKMAP)) {\n\t\tint i = PKMAP_NR(addr);\n\t\treturn pte_page(pkmap_page_table[i]);\n\t}\n\n\treturn virt_to_page(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "kiov[seg].iov_len != PAGE_SIZE"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nint get_kernel_pages(const struct kvec *kiov, int nr_segs, int write,\n\t\tstruct page **pages)\n{\n\tint seg;\n\n\tfor (seg = 0; seg < nr_segs; seg++) {\n\t\tif (WARN_ON(kiov[seg].iov_len != PAGE_SIZE))\n\t\t\treturn seg;\n\n\t\tpages[seg] = kmap_to_page(kiov[seg].iov_base);\n\t\tget_page(pages[seg]);\n\t}\n\n\treturn seg;\n}"
  },
  {
    "function_name": "put_pages_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "124-133",
    "snippet": "void put_pages_list(struct list_head *pages)\n{\n\twhile (!list_empty(pages)) {\n\t\tstruct page *victim;\n\n\t\tvictim = list_entry(pages->prev, struct page, lru);\n\t\tlist_del(&victim->lru);\n\t\tput_page(victim);\n\t}\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "victim"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "put_pages_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "124-133",
          "snippet": "void put_pages_list(struct list_head *pages)\n{\n\twhile (!list_empty(pages)) {\n\t\tstruct page *victim;\n\n\t\tvictim = list_entry(pages->prev, struct page, lru);\n\t\tlist_del(&victim->lru);\n\t\tput_page(victim);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&victim->lru"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "pages->prev",
            "structpage",
            "lru"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "pages"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid put_pages_list(struct list_head *pages)\n{\n\twhile (!list_empty(pages)) {\n\t\tstruct page *victim;\n\n\t\tvictim = list_entry(pages->prev, struct page, lru);\n\t\tlist_del(&victim->lru);\n\t\tput_page(victim);\n\t}\n}"
  },
  {
    "function_name": "__put_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "98-114",
    "snippet": "void __put_page(struct page *page)\n{\n\tif (is_zone_device_page(page)) {\n\t\tput_dev_pagemap(page->pgmap);\n\n\t\t/*\n\t\t * The page belongs to the device that created pgmap. Do\n\t\t * not return it to page allocator.\n\t\t */\n\t\treturn;\n\t}\n\n\tif (unlikely(PageCompound(page)))\n\t\t__put_compound_page(page);\n\telse\n\t\t__put_single_page(page);\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_single_page",
          "args": [
            "page"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "__put_single_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "76-80",
          "snippet": "static void __put_single_page(struct page *page)\n{\n\t__page_cache_release(page);\n\tfree_unref_page(page);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void __put_single_page(struct page *page)\n{\n\t__page_cache_release(page);\n\tfree_unref_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_compound_page",
          "args": [
            "page"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "__put_compound_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "82-96",
          "snippet": "static void __put_compound_page(struct page *page)\n{\n\tcompound_page_dtor *dtor;\n\n\t/*\n\t * __page_cache_release() is supposed to be called for thp, not for\n\t * hugetlb. This is because hugetlb page does never have PageLRU set\n\t * (it's never listed to any LRU lists) and no memcg routines should\n\t * be called for hugetlb (it has a separate hugetlb_cgroup.)\n\t */\n\tif (!PageHuge(page))\n\t\t__page_cache_release(page);\n\tdtor = get_compound_page_dtor(page);\n\t(*dtor)(page);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void __put_compound_page(struct page *page)\n{\n\tcompound_page_dtor *dtor;\n\n\t/*\n\t * __page_cache_release() is supposed to be called for thp, not for\n\t * hugetlb. This is because hugetlb page does never have PageLRU set\n\t * (it's never listed to any LRU lists) and no memcg routines should\n\t * be called for hugetlb (it has a separate hugetlb_cgroup.)\n\t */\n\tif (!PageHuge(page))\n\t\t__page_cache_release(page);\n\tdtor = get_compound_page_dtor(page);\n\t(*dtor)(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "PageCompound(page)"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "page"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_dev_pagemap",
          "args": [
            "page->pgmap"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_zone_device_page",
          "args": [
            "page"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid __put_page(struct page *page)\n{\n\tif (is_zone_device_page(page)) {\n\t\tput_dev_pagemap(page->pgmap);\n\n\t\t/*\n\t\t * The page belongs to the device that created pgmap. Do\n\t\t * not return it to page allocator.\n\t\t */\n\t\treturn;\n\t}\n\n\tif (unlikely(PageCompound(page)))\n\t\t__put_compound_page(page);\n\telse\n\t\t__put_single_page(page);\n}"
  },
  {
    "function_name": "__put_compound_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "82-96",
    "snippet": "static void __put_compound_page(struct page *page)\n{\n\tcompound_page_dtor *dtor;\n\n\t/*\n\t * __page_cache_release() is supposed to be called for thp, not for\n\t * hugetlb. This is because hugetlb page does never have PageLRU set\n\t * (it's never listed to any LRU lists) and no memcg routines should\n\t * be called for hugetlb (it has a separate hugetlb_cgroup.)\n\t */\n\tif (!PageHuge(page))\n\t\t__page_cache_release(page);\n\tdtor = get_compound_page_dtor(page);\n\t(*dtor)(page);\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "page"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_compound_page_dtor",
          "args": [
            "page"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__page_cache_release",
          "args": [
            "page"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "__page_cache_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "58-74",
          "snippet": "static void __page_cache_release(struct page *page)\n{\n\tif (PageLRU(page)) {\n\t\tstruct zone *zone = page_zone(page);\n\t\tstruct lruvec *lruvec;\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(zone_lru_lock(zone), flags);\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\t\tVM_BUG_ON_PAGE(!PageLRU(page), page);\n\t\t__ClearPageLRU(page);\n\t\tdel_page_from_lru_list(page, lruvec, page_off_lru(page));\n\t\tspin_unlock_irqrestore(zone_lru_lock(zone), flags);\n\t}\n\t__ClearPageWaiters(page);\n\tmem_cgroup_uncharge(page);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void __page_cache_release(struct page *page)\n{\n\tif (PageLRU(page)) {\n\t\tstruct zone *zone = page_zone(page);\n\t\tstruct lruvec *lruvec;\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(zone_lru_lock(zone), flags);\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\t\tVM_BUG_ON_PAGE(!PageLRU(page), page);\n\t\t__ClearPageLRU(page);\n\t\tdel_page_from_lru_list(page, lruvec, page_off_lru(page));\n\t\tspin_unlock_irqrestore(zone_lru_lock(zone), flags);\n\t}\n\t__ClearPageWaiters(page);\n\tmem_cgroup_uncharge(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "page"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "PageHugeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "225-228",
          "snippet": "static int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void __put_compound_page(struct page *page)\n{\n\tcompound_page_dtor *dtor;\n\n\t/*\n\t * __page_cache_release() is supposed to be called for thp, not for\n\t * hugetlb. This is because hugetlb page does never have PageLRU set\n\t * (it's never listed to any LRU lists) and no memcg routines should\n\t * be called for hugetlb (it has a separate hugetlb_cgroup.)\n\t */\n\tif (!PageHuge(page))\n\t\t__page_cache_release(page);\n\tdtor = get_compound_page_dtor(page);\n\t(*dtor)(page);\n}"
  },
  {
    "function_name": "__put_single_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "76-80",
    "snippet": "static void __put_single_page(struct page *page)\n{\n\t__page_cache_release(page);\n\tfree_unref_page(page);\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_unref_page",
          "args": [
            "page"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "free_unref_page_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2803-2836",
          "snippet": "void free_unref_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\tunsigned long flags, pfn;\n\tint batch_count = 0;\n\n\t/* Prepare pages for freeing */\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tpfn = page_to_pfn(page);\n\t\tif (!free_unref_page_prepare(page, pfn))\n\t\t\tlist_del(&page->lru);\n\t\tset_page_private(page, pfn);\n\t}\n\n\tlocal_irq_save(flags);\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tunsigned long pfn = page_private(page);\n\n\t\tset_page_private(page, 0);\n\t\ttrace_mm_page_free_batched(page);\n\t\tfree_unref_page_commit(page, pfn);\n\n\t\t/*\n\t\t * Guard against excessive IRQ disabled times when we get\n\t\t * a large list of pages to free.\n\t\t */\n\t\tif (++batch_count == SWAP_CLUSTER_MAX) {\n\t\t\tlocal_irq_restore(flags);\n\t\t\tbatch_count = 0;\n\t\t\tlocal_irq_save(flags);\n\t\t}\n\t}\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid free_unref_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\tunsigned long flags, pfn;\n\tint batch_count = 0;\n\n\t/* Prepare pages for freeing */\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tpfn = page_to_pfn(page);\n\t\tif (!free_unref_page_prepare(page, pfn))\n\t\t\tlist_del(&page->lru);\n\t\tset_page_private(page, pfn);\n\t}\n\n\tlocal_irq_save(flags);\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tunsigned long pfn = page_private(page);\n\n\t\tset_page_private(page, 0);\n\t\ttrace_mm_page_free_batched(page);\n\t\tfree_unref_page_commit(page, pfn);\n\n\t\t/*\n\t\t * Guard against excessive IRQ disabled times when we get\n\t\t * a large list of pages to free.\n\t\t */\n\t\tif (++batch_count == SWAP_CLUSTER_MAX) {\n\t\t\tlocal_irq_restore(flags);\n\t\t\tbatch_count = 0;\n\t\t\tlocal_irq_save(flags);\n\t\t}\n\t}\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__page_cache_release",
          "args": [
            "page"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "__page_cache_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "58-74",
          "snippet": "static void __page_cache_release(struct page *page)\n{\n\tif (PageLRU(page)) {\n\t\tstruct zone *zone = page_zone(page);\n\t\tstruct lruvec *lruvec;\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(zone_lru_lock(zone), flags);\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\t\tVM_BUG_ON_PAGE(!PageLRU(page), page);\n\t\t__ClearPageLRU(page);\n\t\tdel_page_from_lru_list(page, lruvec, page_off_lru(page));\n\t\tspin_unlock_irqrestore(zone_lru_lock(zone), flags);\n\t}\n\t__ClearPageWaiters(page);\n\tmem_cgroup_uncharge(page);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void __page_cache_release(struct page *page)\n{\n\tif (PageLRU(page)) {\n\t\tstruct zone *zone = page_zone(page);\n\t\tstruct lruvec *lruvec;\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(zone_lru_lock(zone), flags);\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\t\tVM_BUG_ON_PAGE(!PageLRU(page), page);\n\t\t__ClearPageLRU(page);\n\t\tdel_page_from_lru_list(page, lruvec, page_off_lru(page));\n\t\tspin_unlock_irqrestore(zone_lru_lock(zone), flags);\n\t}\n\t__ClearPageWaiters(page);\n\tmem_cgroup_uncharge(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void __put_single_page(struct page *page)\n{\n\t__page_cache_release(page);\n\tfree_unref_page(page);\n}"
  },
  {
    "function_name": "__page_cache_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
    "lines": "58-74",
    "snippet": "static void __page_cache_release(struct page *page)\n{\n\tif (PageLRU(page)) {\n\t\tstruct zone *zone = page_zone(page);\n\t\tstruct lruvec *lruvec;\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(zone_lru_lock(zone), flags);\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\t\tVM_BUG_ON_PAGE(!PageLRU(page), page);\n\t\t__ClearPageLRU(page);\n\t\tdel_page_from_lru_list(page, lruvec, page_off_lru(page));\n\t\tspin_unlock_irqrestore(zone_lru_lock(zone), flags);\n\t}\n\t__ClearPageWaiters(page);\n\tmem_cgroup_uncharge(page);\n}",
    "includes": [
      "#include <trace/events/pagemap.h>",
      "#include \"internal.h\"",
      "#include <linux/page_idle.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/uio.h>",
      "#include <linux/gfp.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/memremap.h>",
      "#include <linux/percpu_counter.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/swap.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cgroup_uncharge",
          "args": [
            "page"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_uncharge_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "6136-6143",
          "snippet": "void mem_cgroup_uncharge_list(struct list_head *page_list)\n{\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\tif (!list_empty(page_list))\n\t\tuncharge_list(page_list);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid mem_cgroup_uncharge_list(struct list_head *page_list)\n{\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\tif (!list_empty(page_list))\n\t\tuncharge_list(page_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ClearPageWaiters",
          "args": [
            "page"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "zone_lru_lock(zone)",
            "flags"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_lru_lock",
          "args": [
            "zone"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "del_page_from_lru_list",
          "args": [
            "page",
            "lruvec",
            "page_off_lru(page)"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_off_lru",
          "args": [
            "page"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ClearPageLRU",
          "args": [
            "page"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLRU(page)",
            "page"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_page_lruvec",
          "args": [
            "page",
            "zone->zone_pgdat"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_page_lruvec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1100-1130",
          "snippet": "struct lruvec *mem_cgroup_page_lruvec(struct page *page, struct pglist_data *pgdat)\n{\n\tstruct mem_cgroup_per_node *mz;\n\tstruct mem_cgroup *memcg;\n\tstruct lruvec *lruvec;\n\n\tif (mem_cgroup_disabled()) {\n\t\tlruvec = &pgdat->lruvec;\n\t\tgoto out;\n\t}\n\n\tmemcg = page->mem_cgroup;\n\t/*\n\t * Swapcache readahead pages are added to the LRU - and\n\t * possibly migrated - before they are charged.\n\t */\n\tif (!memcg)\n\t\tmemcg = root_mem_cgroup;\n\n\tmz = mem_cgroup_page_nodeinfo(memcg, page);\n\tlruvec = &mz->lruvec;\nout:\n\t/*\n\t * Since a node can be onlined after the mem_cgroup was created,\n\t * we have to be prepared to initialize lruvec->zone here;\n\t * and if offlined then reonlined, we need to reinitialize it.\n\t */\n\tif (unlikely(lruvec->pgdat != pgdat))\n\t\tlruvec->pgdat = pgdat;\n\treturn lruvec;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstruct lruvec *mem_cgroup_page_lruvec(struct page *page, struct pglist_data *pgdat)\n{\n\tstruct mem_cgroup_per_node *mz;\n\tstruct mem_cgroup *memcg;\n\tstruct lruvec *lruvec;\n\n\tif (mem_cgroup_disabled()) {\n\t\tlruvec = &pgdat->lruvec;\n\t\tgoto out;\n\t}\n\n\tmemcg = page->mem_cgroup;\n\t/*\n\t * Swapcache readahead pages are added to the LRU - and\n\t * possibly migrated - before they are charged.\n\t */\n\tif (!memcg)\n\t\tmemcg = root_mem_cgroup;\n\n\tmz = mem_cgroup_page_nodeinfo(memcg, page);\n\tlruvec = &mz->lruvec;\nout:\n\t/*\n\t * Since a node can be onlined after the mem_cgroup was created,\n\t * we have to be prepared to initialize lruvec->zone here;\n\t * and if offlined then reonlined, we need to reinitialize it.\n\t */\n\tif (unlikely(lruvec->pgdat != pgdat))\n\t\tlruvec->pgdat = pgdat;\n\treturn lruvec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "zone_lru_lock(zone)",
            "flags"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_lru_lock",
          "args": [
            "zone"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void __page_cache_release(struct page *page)\n{\n\tif (PageLRU(page)) {\n\t\tstruct zone *zone = page_zone(page);\n\t\tstruct lruvec *lruvec;\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(zone_lru_lock(zone), flags);\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\t\tVM_BUG_ON_PAGE(!PageLRU(page), page);\n\t\t__ClearPageLRU(page);\n\t\tdel_page_from_lru_list(page, lruvec, page_off_lru(page));\n\t\tspin_unlock_irqrestore(zone_lru_lock(zone), flags);\n\t}\n\t__ClearPageWaiters(page);\n\tmem_cgroup_uncharge(page);\n}"
  }
]