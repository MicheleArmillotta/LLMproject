[
  {
    "function_name": "ksys_readahead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/readahead.c",
    "lines": "577-601",
    "snippet": "ssize_t ksys_readahead(int fd, loff_t offset, size_t count)\n{\n\tssize_t ret;\n\tstruct fd f;\n\n\tret = -EBADF;\n\tf = fdget(fd);\n\tif (!f.file || !(f.file->f_mode & FMODE_READ))\n\t\tgoto out;\n\n\t/*\n\t * The readahead() syscall is intended to run only on files\n\t * that can execute readahead. If readahead is not possible\n\t * on this file, then we must return -EINVAL.\n\t */\n\tret = -EINVAL;\n\tif (!f.file->f_mapping || !f.file->f_mapping->a_ops ||\n\t    !S_ISREG(file_inode(f.file)->i_mode))\n\t\tgoto out;\n\n\tret = vfs_fadvise(f.file, offset, count, POSIX_FADV_WILLNEED);\nout:\n\tfdput(f);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/fadvise.h>",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/file.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/export.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dax.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_fadvise",
          "args": [
            "f.file",
            "offset",
            "count",
            "POSIX_FADV_WILLNEED"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_fadvise",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/fadvise.c",
          "lines": "182-188",
          "snippet": "int vfs_fadvise(struct file *file, loff_t offset, loff_t len, int advice)\n{\n\tif (file->f_op->fadvise)\n\t\treturn file->f_op->fadvise(file, offset, len, advice);\n\n\treturn generic_fadvise(file, offset, len, advice);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/swap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/fadvise.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/fadvise.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint vfs_fadvise(struct file *file, loff_t offset, loff_t len, int advice)\n{\n\tif (file->f_op->fadvise)\n\t\treturn file->f_op->fadvise(file, offset, len, advice);\n\n\treturn generic_fadvise(file, offset, len, advice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "file_inode(f.file)->i_mode"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "f.file"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "fd"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/fadvise.h>\n#include <linux/blk-cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/file.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/pagevec.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/export.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/kernel.h>\n\nssize_t ksys_readahead(int fd, loff_t offset, size_t count)\n{\n\tssize_t ret;\n\tstruct fd f;\n\n\tret = -EBADF;\n\tf = fdget(fd);\n\tif (!f.file || !(f.file->f_mode & FMODE_READ))\n\t\tgoto out;\n\n\t/*\n\t * The readahead() syscall is intended to run only on files\n\t * that can execute readahead. If readahead is not possible\n\t * on this file, then we must return -EINVAL.\n\t */\n\tret = -EINVAL;\n\tif (!f.file->f_mapping || !f.file->f_mapping->a_ops ||\n\t    !S_ISREG(file_inode(f.file)->i_mode))\n\t\tgoto out;\n\n\tret = vfs_fadvise(f.file, offset, count, POSIX_FADV_WILLNEED);\nout:\n\tfdput(f);\n\treturn ret;\n}"
  },
  {
    "function_name": "page_cache_async_readahead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/readahead.c",
    "lines": "545-574",
    "snippet": "void\npage_cache_async_readahead(struct address_space *mapping,\n\t\t\t   struct file_ra_state *ra, struct file *filp,\n\t\t\t   struct page *page, pgoff_t offset,\n\t\t\t   unsigned long req_size)\n{\n\t/* no read-ahead */\n\tif (!ra->ra_pages)\n\t\treturn;\n\n\t/*\n\t * Same bit is used for PG_readahead and PG_reclaim.\n\t */\n\tif (PageWriteback(page))\n\t\treturn;\n\n\tClearPageReadahead(page);\n\n\t/*\n\t * Defer asynchronous read-ahead on IO congestion.\n\t */\n\tif (inode_read_congested(mapping->host))\n\t\treturn;\n\n\tif (blk_cgroup_congested())\n\t\treturn;\n\n\t/* do read-ahead */\n\tondemand_readahead(mapping, ra, filp, true, offset, req_size);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/fadvise.h>",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/file.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/export.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dax.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ondemand_readahead",
          "args": [
            "mapping",
            "ra",
            "filp",
            "true",
            "offset",
            "req_size"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "ondemand_readahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/readahead.c",
          "lines": "380-492",
          "snippet": "static unsigned long\nondemand_readahead(struct address_space *mapping,\n\t\t   struct file_ra_state *ra, struct file *filp,\n\t\t   bool hit_readahead_marker, pgoff_t offset,\n\t\t   unsigned long req_size)\n{\n\tstruct backing_dev_info *bdi = inode_to_bdi(mapping->host);\n\tunsigned long max_pages = ra->ra_pages;\n\tunsigned long add_pages;\n\tpgoff_t prev_offset;\n\n\t/*\n\t * If the request exceeds the readahead window, allow the read to\n\t * be up to the optimal hardware IO size\n\t */\n\tif (req_size > max_pages && bdi->io_pages > max_pages)\n\t\tmax_pages = min(req_size, bdi->io_pages);\n\n\t/*\n\t * start of file\n\t */\n\tif (!offset)\n\t\tgoto initial_readahead;\n\n\t/*\n\t * It's the expected callback offset, assume sequential access.\n\t * Ramp up sizes, and push forward the readahead window.\n\t */\n\tif ((offset == (ra->start + ra->size - ra->async_size) ||\n\t     offset == (ra->start + ra->size))) {\n\t\tra->start += ra->size;\n\t\tra->size = get_next_ra_size(ra, max_pages);\n\t\tra->async_size = ra->size;\n\t\tgoto readit;\n\t}\n\n\t/*\n\t * Hit a marked page without valid readahead state.\n\t * E.g. interleaved reads.\n\t * Query the pagecache for async_size, which normally equals to\n\t * readahead size. Ramp it up and use it as the new readahead size.\n\t */\n\tif (hit_readahead_marker) {\n\t\tpgoff_t start;\n\n\t\trcu_read_lock();\n\t\tstart = page_cache_next_miss(mapping, offset + 1, max_pages);\n\t\trcu_read_unlock();\n\n\t\tif (!start || start - offset > max_pages)\n\t\t\treturn 0;\n\n\t\tra->start = start;\n\t\tra->size = start - offset;\t/* old async_size */\n\t\tra->size += req_size;\n\t\tra->size = get_next_ra_size(ra, max_pages);\n\t\tra->async_size = ra->size;\n\t\tgoto readit;\n\t}\n\n\t/*\n\t * oversize read\n\t */\n\tif (req_size > max_pages)\n\t\tgoto initial_readahead;\n\n\t/*\n\t * sequential cache miss\n\t * trivial case: (offset - prev_offset) == 1\n\t * unaligned reads: (offset - prev_offset) == 0\n\t */\n\tprev_offset = (unsigned long long)ra->prev_pos >> PAGE_SHIFT;\n\tif (offset - prev_offset <= 1UL)\n\t\tgoto initial_readahead;\n\n\t/*\n\t * Query the page cache and look for the traces(cached history pages)\n\t * that a sequential stream would leave behind.\n\t */\n\tif (try_context_readahead(mapping, ra, offset, req_size, max_pages))\n\t\tgoto readit;\n\n\t/*\n\t * standalone, small random read\n\t * Read as is, and do not pollute the readahead state.\n\t */\n\treturn __do_page_cache_readahead(mapping, filp, offset, req_size, 0);\n\ninitial_readahead:\n\tra->start = offset;\n\tra->size = get_init_ra_size(req_size, max_pages);\n\tra->async_size = ra->size > req_size ? ra->size - req_size : ra->size;\n\nreadit:\n\t/*\n\t * Will this read hit the readahead marker made by itself?\n\t * If so, trigger the readahead marker hit now, and merge\n\t * the resulted next readahead window into the current one.\n\t * Take care of maximum IO pages as above.\n\t */\n\tif (offset == ra->start && ra->size == ra->async_size) {\n\t\tadd_pages = get_next_ra_size(ra, max_pages);\n\t\tif (ra->size + add_pages <= max_pages) {\n\t\t\tra->async_size = add_pages;\n\t\t\tra->size += add_pages;\n\t\t} else {\n\t\t\tra->size = max_pages;\n\t\t\tra->async_size = max_pages >> 1;\n\t\t}\n\t}\n\n\treturn ra_submit(ra, mapping, filp);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fadvise.h>",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/file.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/export.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fadvise.h>\n#include <linux/blk-cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/file.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/pagevec.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/export.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/kernel.h>\n\nstatic unsigned long\nondemand_readahead(struct address_space *mapping,\n\t\t   struct file_ra_state *ra, struct file *filp,\n\t\t   bool hit_readahead_marker, pgoff_t offset,\n\t\t   unsigned long req_size)\n{\n\tstruct backing_dev_info *bdi = inode_to_bdi(mapping->host);\n\tunsigned long max_pages = ra->ra_pages;\n\tunsigned long add_pages;\n\tpgoff_t prev_offset;\n\n\t/*\n\t * If the request exceeds the readahead window, allow the read to\n\t * be up to the optimal hardware IO size\n\t */\n\tif (req_size > max_pages && bdi->io_pages > max_pages)\n\t\tmax_pages = min(req_size, bdi->io_pages);\n\n\t/*\n\t * start of file\n\t */\n\tif (!offset)\n\t\tgoto initial_readahead;\n\n\t/*\n\t * It's the expected callback offset, assume sequential access.\n\t * Ramp up sizes, and push forward the readahead window.\n\t */\n\tif ((offset == (ra->start + ra->size - ra->async_size) ||\n\t     offset == (ra->start + ra->size))) {\n\t\tra->start += ra->size;\n\t\tra->size = get_next_ra_size(ra, max_pages);\n\t\tra->async_size = ra->size;\n\t\tgoto readit;\n\t}\n\n\t/*\n\t * Hit a marked page without valid readahead state.\n\t * E.g. interleaved reads.\n\t * Query the pagecache for async_size, which normally equals to\n\t * readahead size. Ramp it up and use it as the new readahead size.\n\t */\n\tif (hit_readahead_marker) {\n\t\tpgoff_t start;\n\n\t\trcu_read_lock();\n\t\tstart = page_cache_next_miss(mapping, offset + 1, max_pages);\n\t\trcu_read_unlock();\n\n\t\tif (!start || start - offset > max_pages)\n\t\t\treturn 0;\n\n\t\tra->start = start;\n\t\tra->size = start - offset;\t/* old async_size */\n\t\tra->size += req_size;\n\t\tra->size = get_next_ra_size(ra, max_pages);\n\t\tra->async_size = ra->size;\n\t\tgoto readit;\n\t}\n\n\t/*\n\t * oversize read\n\t */\n\tif (req_size > max_pages)\n\t\tgoto initial_readahead;\n\n\t/*\n\t * sequential cache miss\n\t * trivial case: (offset - prev_offset) == 1\n\t * unaligned reads: (offset - prev_offset) == 0\n\t */\n\tprev_offset = (unsigned long long)ra->prev_pos >> PAGE_SHIFT;\n\tif (offset - prev_offset <= 1UL)\n\t\tgoto initial_readahead;\n\n\t/*\n\t * Query the page cache and look for the traces(cached history pages)\n\t * that a sequential stream would leave behind.\n\t */\n\tif (try_context_readahead(mapping, ra, offset, req_size, max_pages))\n\t\tgoto readit;\n\n\t/*\n\t * standalone, small random read\n\t * Read as is, and do not pollute the readahead state.\n\t */\n\treturn __do_page_cache_readahead(mapping, filp, offset, req_size, 0);\n\ninitial_readahead:\n\tra->start = offset;\n\tra->size = get_init_ra_size(req_size, max_pages);\n\tra->async_size = ra->size > req_size ? ra->size - req_size : ra->size;\n\nreadit:\n\t/*\n\t * Will this read hit the readahead marker made by itself?\n\t * If so, trigger the readahead marker hit now, and merge\n\t * the resulted next readahead window into the current one.\n\t * Take care of maximum IO pages as above.\n\t */\n\tif (offset == ra->start && ra->size == ra->async_size) {\n\t\tadd_pages = get_next_ra_size(ra, max_pages);\n\t\tif (ra->size + add_pages <= max_pages) {\n\t\t\tra->async_size = add_pages;\n\t\t\tra->size += add_pages;\n\t\t} else {\n\t\t\tra->size = max_pages;\n\t\t\tra->async_size = max_pages >> 1;\n\t\t}\n\t}\n\n\treturn ra_submit(ra, mapping, filp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_cgroup_congested",
          "args": [],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_read_congested",
          "args": [
            "mapping->host"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageReadahead",
          "args": [
            "page"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/fadvise.h>\n#include <linux/blk-cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/file.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/pagevec.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/export.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/kernel.h>\n\nvoid\npage_cache_async_readahead(struct address_space *mapping,\n\t\t\t   struct file_ra_state *ra, struct file *filp,\n\t\t\t   struct page *page, pgoff_t offset,\n\t\t\t   unsigned long req_size)\n{\n\t/* no read-ahead */\n\tif (!ra->ra_pages)\n\t\treturn;\n\n\t/*\n\t * Same bit is used for PG_readahead and PG_reclaim.\n\t */\n\tif (PageWriteback(page))\n\t\treturn;\n\n\tClearPageReadahead(page);\n\n\t/*\n\t * Defer asynchronous read-ahead on IO congestion.\n\t */\n\tif (inode_read_congested(mapping->host))\n\t\treturn;\n\n\tif (blk_cgroup_congested())\n\t\treturn;\n\n\t/* do read-ahead */\n\tondemand_readahead(mapping, ra, filp, true, offset, req_size);\n}"
  },
  {
    "function_name": "page_cache_sync_readahead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/readahead.c",
    "lines": "508-527",
    "snippet": "void page_cache_sync_readahead(struct address_space *mapping,\n\t\t\t       struct file_ra_state *ra, struct file *filp,\n\t\t\t       pgoff_t offset, unsigned long req_size)\n{\n\t/* no read-ahead */\n\tif (!ra->ra_pages)\n\t\treturn;\n\n\tif (blk_cgroup_congested())\n\t\treturn;\n\n\t/* be dumb */\n\tif (filp && (filp->f_mode & FMODE_RANDOM)) {\n\t\tforce_page_cache_readahead(mapping, filp, offset, req_size);\n\t\treturn;\n\t}\n\n\t/* do read-ahead */\n\tondemand_readahead(mapping, ra, filp, false, offset, req_size);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/fadvise.h>",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/file.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/export.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dax.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ondemand_readahead",
          "args": [
            "mapping",
            "ra",
            "filp",
            "false",
            "offset",
            "req_size"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "ondemand_readahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/readahead.c",
          "lines": "380-492",
          "snippet": "static unsigned long\nondemand_readahead(struct address_space *mapping,\n\t\t   struct file_ra_state *ra, struct file *filp,\n\t\t   bool hit_readahead_marker, pgoff_t offset,\n\t\t   unsigned long req_size)\n{\n\tstruct backing_dev_info *bdi = inode_to_bdi(mapping->host);\n\tunsigned long max_pages = ra->ra_pages;\n\tunsigned long add_pages;\n\tpgoff_t prev_offset;\n\n\t/*\n\t * If the request exceeds the readahead window, allow the read to\n\t * be up to the optimal hardware IO size\n\t */\n\tif (req_size > max_pages && bdi->io_pages > max_pages)\n\t\tmax_pages = min(req_size, bdi->io_pages);\n\n\t/*\n\t * start of file\n\t */\n\tif (!offset)\n\t\tgoto initial_readahead;\n\n\t/*\n\t * It's the expected callback offset, assume sequential access.\n\t * Ramp up sizes, and push forward the readahead window.\n\t */\n\tif ((offset == (ra->start + ra->size - ra->async_size) ||\n\t     offset == (ra->start + ra->size))) {\n\t\tra->start += ra->size;\n\t\tra->size = get_next_ra_size(ra, max_pages);\n\t\tra->async_size = ra->size;\n\t\tgoto readit;\n\t}\n\n\t/*\n\t * Hit a marked page without valid readahead state.\n\t * E.g. interleaved reads.\n\t * Query the pagecache for async_size, which normally equals to\n\t * readahead size. Ramp it up and use it as the new readahead size.\n\t */\n\tif (hit_readahead_marker) {\n\t\tpgoff_t start;\n\n\t\trcu_read_lock();\n\t\tstart = page_cache_next_miss(mapping, offset + 1, max_pages);\n\t\trcu_read_unlock();\n\n\t\tif (!start || start - offset > max_pages)\n\t\t\treturn 0;\n\n\t\tra->start = start;\n\t\tra->size = start - offset;\t/* old async_size */\n\t\tra->size += req_size;\n\t\tra->size = get_next_ra_size(ra, max_pages);\n\t\tra->async_size = ra->size;\n\t\tgoto readit;\n\t}\n\n\t/*\n\t * oversize read\n\t */\n\tif (req_size > max_pages)\n\t\tgoto initial_readahead;\n\n\t/*\n\t * sequential cache miss\n\t * trivial case: (offset - prev_offset) == 1\n\t * unaligned reads: (offset - prev_offset) == 0\n\t */\n\tprev_offset = (unsigned long long)ra->prev_pos >> PAGE_SHIFT;\n\tif (offset - prev_offset <= 1UL)\n\t\tgoto initial_readahead;\n\n\t/*\n\t * Query the page cache and look for the traces(cached history pages)\n\t * that a sequential stream would leave behind.\n\t */\n\tif (try_context_readahead(mapping, ra, offset, req_size, max_pages))\n\t\tgoto readit;\n\n\t/*\n\t * standalone, small random read\n\t * Read as is, and do not pollute the readahead state.\n\t */\n\treturn __do_page_cache_readahead(mapping, filp, offset, req_size, 0);\n\ninitial_readahead:\n\tra->start = offset;\n\tra->size = get_init_ra_size(req_size, max_pages);\n\tra->async_size = ra->size > req_size ? ra->size - req_size : ra->size;\n\nreadit:\n\t/*\n\t * Will this read hit the readahead marker made by itself?\n\t * If so, trigger the readahead marker hit now, and merge\n\t * the resulted next readahead window into the current one.\n\t * Take care of maximum IO pages as above.\n\t */\n\tif (offset == ra->start && ra->size == ra->async_size) {\n\t\tadd_pages = get_next_ra_size(ra, max_pages);\n\t\tif (ra->size + add_pages <= max_pages) {\n\t\t\tra->async_size = add_pages;\n\t\t\tra->size += add_pages;\n\t\t} else {\n\t\t\tra->size = max_pages;\n\t\t\tra->async_size = max_pages >> 1;\n\t\t}\n\t}\n\n\treturn ra_submit(ra, mapping, filp);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fadvise.h>",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/file.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/export.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fadvise.h>\n#include <linux/blk-cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/file.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/pagevec.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/export.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/kernel.h>\n\nstatic unsigned long\nondemand_readahead(struct address_space *mapping,\n\t\t   struct file_ra_state *ra, struct file *filp,\n\t\t   bool hit_readahead_marker, pgoff_t offset,\n\t\t   unsigned long req_size)\n{\n\tstruct backing_dev_info *bdi = inode_to_bdi(mapping->host);\n\tunsigned long max_pages = ra->ra_pages;\n\tunsigned long add_pages;\n\tpgoff_t prev_offset;\n\n\t/*\n\t * If the request exceeds the readahead window, allow the read to\n\t * be up to the optimal hardware IO size\n\t */\n\tif (req_size > max_pages && bdi->io_pages > max_pages)\n\t\tmax_pages = min(req_size, bdi->io_pages);\n\n\t/*\n\t * start of file\n\t */\n\tif (!offset)\n\t\tgoto initial_readahead;\n\n\t/*\n\t * It's the expected callback offset, assume sequential access.\n\t * Ramp up sizes, and push forward the readahead window.\n\t */\n\tif ((offset == (ra->start + ra->size - ra->async_size) ||\n\t     offset == (ra->start + ra->size))) {\n\t\tra->start += ra->size;\n\t\tra->size = get_next_ra_size(ra, max_pages);\n\t\tra->async_size = ra->size;\n\t\tgoto readit;\n\t}\n\n\t/*\n\t * Hit a marked page without valid readahead state.\n\t * E.g. interleaved reads.\n\t * Query the pagecache for async_size, which normally equals to\n\t * readahead size. Ramp it up and use it as the new readahead size.\n\t */\n\tif (hit_readahead_marker) {\n\t\tpgoff_t start;\n\n\t\trcu_read_lock();\n\t\tstart = page_cache_next_miss(mapping, offset + 1, max_pages);\n\t\trcu_read_unlock();\n\n\t\tif (!start || start - offset > max_pages)\n\t\t\treturn 0;\n\n\t\tra->start = start;\n\t\tra->size = start - offset;\t/* old async_size */\n\t\tra->size += req_size;\n\t\tra->size = get_next_ra_size(ra, max_pages);\n\t\tra->async_size = ra->size;\n\t\tgoto readit;\n\t}\n\n\t/*\n\t * oversize read\n\t */\n\tif (req_size > max_pages)\n\t\tgoto initial_readahead;\n\n\t/*\n\t * sequential cache miss\n\t * trivial case: (offset - prev_offset) == 1\n\t * unaligned reads: (offset - prev_offset) == 0\n\t */\n\tprev_offset = (unsigned long long)ra->prev_pos >> PAGE_SHIFT;\n\tif (offset - prev_offset <= 1UL)\n\t\tgoto initial_readahead;\n\n\t/*\n\t * Query the page cache and look for the traces(cached history pages)\n\t * that a sequential stream would leave behind.\n\t */\n\tif (try_context_readahead(mapping, ra, offset, req_size, max_pages))\n\t\tgoto readit;\n\n\t/*\n\t * standalone, small random read\n\t * Read as is, and do not pollute the readahead state.\n\t */\n\treturn __do_page_cache_readahead(mapping, filp, offset, req_size, 0);\n\ninitial_readahead:\n\tra->start = offset;\n\tra->size = get_init_ra_size(req_size, max_pages);\n\tra->async_size = ra->size > req_size ? ra->size - req_size : ra->size;\n\nreadit:\n\t/*\n\t * Will this read hit the readahead marker made by itself?\n\t * If so, trigger the readahead marker hit now, and merge\n\t * the resulted next readahead window into the current one.\n\t * Take care of maximum IO pages as above.\n\t */\n\tif (offset == ra->start && ra->size == ra->async_size) {\n\t\tadd_pages = get_next_ra_size(ra, max_pages);\n\t\tif (ra->size + add_pages <= max_pages) {\n\t\t\tra->async_size = add_pages;\n\t\t\tra->size += add_pages;\n\t\t} else {\n\t\t\tra->size = max_pages;\n\t\t\tra->async_size = max_pages >> 1;\n\t\t}\n\t}\n\n\treturn ra_submit(ra, mapping, filp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "force_page_cache_readahead",
          "args": [
            "mapping",
            "filp",
            "offset",
            "req_size"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "force_page_cache_readahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/readahead.c",
          "lines": "219-246",
          "snippet": "int force_page_cache_readahead(struct address_space *mapping, struct file *filp,\n\t\t\t       pgoff_t offset, unsigned long nr_to_read)\n{\n\tstruct backing_dev_info *bdi = inode_to_bdi(mapping->host);\n\tstruct file_ra_state *ra = &filp->f_ra;\n\tunsigned long max_pages;\n\n\tif (unlikely(!mapping->a_ops->readpage && !mapping->a_ops->readpages))\n\t\treturn -EINVAL;\n\n\t/*\n\t * If the request exceeds the readahead window, allow the read to\n\t * be up to the optimal hardware IO size\n\t */\n\tmax_pages = max_t(unsigned long, bdi->io_pages, ra->ra_pages);\n\tnr_to_read = min(nr_to_read, max_pages);\n\twhile (nr_to_read) {\n\t\tunsigned long this_chunk = (2 * 1024 * 1024) / PAGE_SIZE;\n\n\t\tif (this_chunk > nr_to_read)\n\t\t\tthis_chunk = nr_to_read;\n\t\t__do_page_cache_readahead(mapping, filp, offset, this_chunk, 0);\n\n\t\toffset += this_chunk;\n\t\tnr_to_read -= this_chunk;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fadvise.h>",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/file.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/export.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fadvise.h>\n#include <linux/blk-cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/file.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/pagevec.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/export.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/kernel.h>\n\nint force_page_cache_readahead(struct address_space *mapping, struct file *filp,\n\t\t\t       pgoff_t offset, unsigned long nr_to_read)\n{\n\tstruct backing_dev_info *bdi = inode_to_bdi(mapping->host);\n\tstruct file_ra_state *ra = &filp->f_ra;\n\tunsigned long max_pages;\n\n\tif (unlikely(!mapping->a_ops->readpage && !mapping->a_ops->readpages))\n\t\treturn -EINVAL;\n\n\t/*\n\t * If the request exceeds the readahead window, allow the read to\n\t * be up to the optimal hardware IO size\n\t */\n\tmax_pages = max_t(unsigned long, bdi->io_pages, ra->ra_pages);\n\tnr_to_read = min(nr_to_read, max_pages);\n\twhile (nr_to_read) {\n\t\tunsigned long this_chunk = (2 * 1024 * 1024) / PAGE_SIZE;\n\n\t\tif (this_chunk > nr_to_read)\n\t\t\tthis_chunk = nr_to_read;\n\t\t__do_page_cache_readahead(mapping, filp, offset, this_chunk, 0);\n\n\t\toffset += this_chunk;\n\t\tnr_to_read -= this_chunk;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_cgroup_congested",
          "args": [],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/fadvise.h>\n#include <linux/blk-cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/file.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/pagevec.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/export.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/kernel.h>\n\nvoid page_cache_sync_readahead(struct address_space *mapping,\n\t\t\t       struct file_ra_state *ra, struct file *filp,\n\t\t\t       pgoff_t offset, unsigned long req_size)\n{\n\t/* no read-ahead */\n\tif (!ra->ra_pages)\n\t\treturn;\n\n\tif (blk_cgroup_congested())\n\t\treturn;\n\n\t/* be dumb */\n\tif (filp && (filp->f_mode & FMODE_RANDOM)) {\n\t\tforce_page_cache_readahead(mapping, filp, offset, req_size);\n\t\treturn;\n\t}\n\n\t/* do read-ahead */\n\tondemand_readahead(mapping, ra, filp, false, offset, req_size);\n}"
  },
  {
    "function_name": "ondemand_readahead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/readahead.c",
    "lines": "380-492",
    "snippet": "static unsigned long\nondemand_readahead(struct address_space *mapping,\n\t\t   struct file_ra_state *ra, struct file *filp,\n\t\t   bool hit_readahead_marker, pgoff_t offset,\n\t\t   unsigned long req_size)\n{\n\tstruct backing_dev_info *bdi = inode_to_bdi(mapping->host);\n\tunsigned long max_pages = ra->ra_pages;\n\tunsigned long add_pages;\n\tpgoff_t prev_offset;\n\n\t/*\n\t * If the request exceeds the readahead window, allow the read to\n\t * be up to the optimal hardware IO size\n\t */\n\tif (req_size > max_pages && bdi->io_pages > max_pages)\n\t\tmax_pages = min(req_size, bdi->io_pages);\n\n\t/*\n\t * start of file\n\t */\n\tif (!offset)\n\t\tgoto initial_readahead;\n\n\t/*\n\t * It's the expected callback offset, assume sequential access.\n\t * Ramp up sizes, and push forward the readahead window.\n\t */\n\tif ((offset == (ra->start + ra->size - ra->async_size) ||\n\t     offset == (ra->start + ra->size))) {\n\t\tra->start += ra->size;\n\t\tra->size = get_next_ra_size(ra, max_pages);\n\t\tra->async_size = ra->size;\n\t\tgoto readit;\n\t}\n\n\t/*\n\t * Hit a marked page without valid readahead state.\n\t * E.g. interleaved reads.\n\t * Query the pagecache for async_size, which normally equals to\n\t * readahead size. Ramp it up and use it as the new readahead size.\n\t */\n\tif (hit_readahead_marker) {\n\t\tpgoff_t start;\n\n\t\trcu_read_lock();\n\t\tstart = page_cache_next_miss(mapping, offset + 1, max_pages);\n\t\trcu_read_unlock();\n\n\t\tif (!start || start - offset > max_pages)\n\t\t\treturn 0;\n\n\t\tra->start = start;\n\t\tra->size = start - offset;\t/* old async_size */\n\t\tra->size += req_size;\n\t\tra->size = get_next_ra_size(ra, max_pages);\n\t\tra->async_size = ra->size;\n\t\tgoto readit;\n\t}\n\n\t/*\n\t * oversize read\n\t */\n\tif (req_size > max_pages)\n\t\tgoto initial_readahead;\n\n\t/*\n\t * sequential cache miss\n\t * trivial case: (offset - prev_offset) == 1\n\t * unaligned reads: (offset - prev_offset) == 0\n\t */\n\tprev_offset = (unsigned long long)ra->prev_pos >> PAGE_SHIFT;\n\tif (offset - prev_offset <= 1UL)\n\t\tgoto initial_readahead;\n\n\t/*\n\t * Query the page cache and look for the traces(cached history pages)\n\t * that a sequential stream would leave behind.\n\t */\n\tif (try_context_readahead(mapping, ra, offset, req_size, max_pages))\n\t\tgoto readit;\n\n\t/*\n\t * standalone, small random read\n\t * Read as is, and do not pollute the readahead state.\n\t */\n\treturn __do_page_cache_readahead(mapping, filp, offset, req_size, 0);\n\ninitial_readahead:\n\tra->start = offset;\n\tra->size = get_init_ra_size(req_size, max_pages);\n\tra->async_size = ra->size > req_size ? ra->size - req_size : ra->size;\n\nreadit:\n\t/*\n\t * Will this read hit the readahead marker made by itself?\n\t * If so, trigger the readahead marker hit now, and merge\n\t * the resulted next readahead window into the current one.\n\t * Take care of maximum IO pages as above.\n\t */\n\tif (offset == ra->start && ra->size == ra->async_size) {\n\t\tadd_pages = get_next_ra_size(ra, max_pages);\n\t\tif (ra->size + add_pages <= max_pages) {\n\t\t\tra->async_size = add_pages;\n\t\t\tra->size += add_pages;\n\t\t} else {\n\t\t\tra->size = max_pages;\n\t\t\tra->async_size = max_pages >> 1;\n\t\t}\n\t}\n\n\treturn ra_submit(ra, mapping, filp);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/fadvise.h>",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/file.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/export.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dax.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ra_submit",
          "args": [
            "ra",
            "mapping",
            "filp"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "ra_submit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "63-68",
          "snippet": "static inline unsigned long ra_submit(struct file_ra_state *ra,\n\t\tstruct address_space *mapping, struct file *filp)\n{\n\treturn __do_page_cache_readahead(mapping, filp,\n\t\t\t\t\tra->start, ra->size, ra->async_size);\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline unsigned long ra_submit(struct file_ra_state *ra,\n\t\tstruct address_space *mapping, struct file *filp)\n{\n\treturn __do_page_cache_readahead(mapping, filp,\n\t\t\t\t\tra->start, ra->size, ra->async_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_next_ra_size",
          "args": [
            "ra",
            "max_pages"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "get_next_ra_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/readahead.c",
          "lines": "272-284",
          "snippet": "static unsigned long get_next_ra_size(struct file_ra_state *ra,\n\t\t\t\t\t\tunsigned long max)\n{\n\tunsigned long cur = ra->size;\n\tunsigned long newsize;\n\n\tif (cur < max / 16)\n\t\tnewsize = 4 * cur;\n\telse\n\t\tnewsize = 2 * cur;\n\n\treturn min(newsize, max);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fadvise.h>",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/file.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/export.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fadvise.h>\n#include <linux/blk-cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/file.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/pagevec.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/export.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/kernel.h>\n\nstatic unsigned long get_next_ra_size(struct file_ra_state *ra,\n\t\t\t\t\t\tunsigned long max)\n{\n\tunsigned long cur = ra->size;\n\tunsigned long newsize;\n\n\tif (cur < max / 16)\n\t\tnewsize = 4 * cur;\n\telse\n\t\tnewsize = 2 * cur;\n\n\treturn min(newsize, max);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_init_ra_size",
          "args": [
            "req_size",
            "max_pages"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "get_init_ra_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/readahead.c",
          "lines": "254-266",
          "snippet": "static unsigned long get_init_ra_size(unsigned long size, unsigned long max)\n{\n\tunsigned long newsize = roundup_pow_of_two(size);\n\n\tif (newsize <= max / 32)\n\t\tnewsize = newsize * 4;\n\telse if (newsize <= max / 4)\n\t\tnewsize = newsize * 2;\n\telse\n\t\tnewsize = max;\n\n\treturn newsize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fadvise.h>",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/file.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/export.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fadvise.h>\n#include <linux/blk-cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/file.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/pagevec.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/export.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/kernel.h>\n\nstatic unsigned long get_init_ra_size(unsigned long size, unsigned long max)\n{\n\tunsigned long newsize = roundup_pow_of_two(size);\n\n\tif (newsize <= max / 32)\n\t\tnewsize = newsize * 4;\n\telse if (newsize <= max / 4)\n\t\tnewsize = newsize * 2;\n\telse\n\t\tnewsize = max;\n\n\treturn newsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__do_page_cache_readahead",
          "args": [
            "mapping",
            "filp",
            "offset",
            "req_size",
            "0"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "__do_page_cache_readahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/readahead.c",
          "lines": "152-213",
          "snippet": "unsigned int __do_page_cache_readahead(struct address_space *mapping,\n\t\tstruct file *filp, pgoff_t offset, unsigned long nr_to_read,\n\t\tunsigned long lookahead_size)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct page *page;\n\tunsigned long end_index;\t/* The last page we want to read */\n\tLIST_HEAD(page_pool);\n\tint page_idx;\n\tunsigned int nr_pages = 0;\n\tloff_t isize = i_size_read(inode);\n\tgfp_t gfp_mask = readahead_gfp_mask(mapping);\n\n\tif (isize == 0)\n\t\tgoto out;\n\n\tend_index = ((isize - 1) >> PAGE_SHIFT);\n\n\t/*\n\t * Preallocate as many pages as we will need.\n\t */\n\tfor (page_idx = 0; page_idx < nr_to_read; page_idx++) {\n\t\tpgoff_t page_offset = offset + page_idx;\n\n\t\tif (page_offset > end_index)\n\t\t\tbreak;\n\n\t\tpage = xa_load(&mapping->i_pages, page_offset);\n\t\tif (page && !xa_is_value(page)) {\n\t\t\t/*\n\t\t\t * Page already present?  Kick off the current batch of\n\t\t\t * contiguous pages before continuing with the next\n\t\t\t * batch.\n\t\t\t */\n\t\t\tif (nr_pages)\n\t\t\t\tread_pages(mapping, filp, &page_pool, nr_pages,\n\t\t\t\t\t\tgfp_mask);\n\t\t\tnr_pages = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpage = __page_cache_alloc(gfp_mask);\n\t\tif (!page)\n\t\t\tbreak;\n\t\tpage->index = page_offset;\n\t\tlist_add(&page->lru, &page_pool);\n\t\tif (page_idx == nr_to_read - lookahead_size)\n\t\t\tSetPageReadahead(page);\n\t\tnr_pages++;\n\t}\n\n\t/*\n\t * Now start the IO.  We ignore I/O errors - if the page is not\n\t * uptodate then the caller will launch readpage again, and\n\t * will then handle the error.\n\t */\n\tif (nr_pages)\n\t\tread_pages(mapping, filp, &page_pool, nr_pages, gfp_mask);\n\tBUG_ON(!list_empty(&page_pool));\nout:\n\treturn nr_pages;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fadvise.h>",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/file.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/export.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fadvise.h>\n#include <linux/blk-cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/file.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/pagevec.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/export.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/kernel.h>\n\nunsigned int __do_page_cache_readahead(struct address_space *mapping,\n\t\tstruct file *filp, pgoff_t offset, unsigned long nr_to_read,\n\t\tunsigned long lookahead_size)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct page *page;\n\tunsigned long end_index;\t/* The last page we want to read */\n\tLIST_HEAD(page_pool);\n\tint page_idx;\n\tunsigned int nr_pages = 0;\n\tloff_t isize = i_size_read(inode);\n\tgfp_t gfp_mask = readahead_gfp_mask(mapping);\n\n\tif (isize == 0)\n\t\tgoto out;\n\n\tend_index = ((isize - 1) >> PAGE_SHIFT);\n\n\t/*\n\t * Preallocate as many pages as we will need.\n\t */\n\tfor (page_idx = 0; page_idx < nr_to_read; page_idx++) {\n\t\tpgoff_t page_offset = offset + page_idx;\n\n\t\tif (page_offset > end_index)\n\t\t\tbreak;\n\n\t\tpage = xa_load(&mapping->i_pages, page_offset);\n\t\tif (page && !xa_is_value(page)) {\n\t\t\t/*\n\t\t\t * Page already present?  Kick off the current batch of\n\t\t\t * contiguous pages before continuing with the next\n\t\t\t * batch.\n\t\t\t */\n\t\t\tif (nr_pages)\n\t\t\t\tread_pages(mapping, filp, &page_pool, nr_pages,\n\t\t\t\t\t\tgfp_mask);\n\t\t\tnr_pages = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpage = __page_cache_alloc(gfp_mask);\n\t\tif (!page)\n\t\t\tbreak;\n\t\tpage->index = page_offset;\n\t\tlist_add(&page->lru, &page_pool);\n\t\tif (page_idx == nr_to_read - lookahead_size)\n\t\t\tSetPageReadahead(page);\n\t\tnr_pages++;\n\t}\n\n\t/*\n\t * Now start the IO.  We ignore I/O errors - if the page is not\n\t * uptodate then the caller will launch readpage again, and\n\t * will then handle the error.\n\t */\n\tif (nr_pages)\n\t\tread_pages(mapping, filp, &page_pool, nr_pages, gfp_mask);\n\tBUG_ON(!list_empty(&page_pool));\nout:\n\treturn nr_pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_context_readahead",
          "args": [
            "mapping",
            "ra",
            "offset",
            "req_size",
            "max_pages"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "try_context_readahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/readahead.c",
          "lines": "346-375",
          "snippet": "static int try_context_readahead(struct address_space *mapping,\n\t\t\t\t struct file_ra_state *ra,\n\t\t\t\t pgoff_t offset,\n\t\t\t\t unsigned long req_size,\n\t\t\t\t unsigned long max)\n{\n\tpgoff_t size;\n\n\tsize = count_history_pages(mapping, offset, max);\n\n\t/*\n\t * not enough history pages:\n\t * it could be a random read\n\t */\n\tif (size <= req_size)\n\t\treturn 0;\n\n\t/*\n\t * starts from beginning of file:\n\t * it is a strong indication of long-run stream (or whole-file-read)\n\t */\n\tif (size >= offset)\n\t\tsize *= 2;\n\n\tra->start = offset;\n\tra->size = min(size + req_size, max);\n\tra->async_size = 1;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fadvise.h>",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/file.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/export.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fadvise.h>\n#include <linux/blk-cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/file.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/pagevec.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/export.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/kernel.h>\n\nstatic int try_context_readahead(struct address_space *mapping,\n\t\t\t\t struct file_ra_state *ra,\n\t\t\t\t pgoff_t offset,\n\t\t\t\t unsigned long req_size,\n\t\t\t\t unsigned long max)\n{\n\tpgoff_t size;\n\n\tsize = count_history_pages(mapping, offset, max);\n\n\t/*\n\t * not enough history pages:\n\t * it could be a random read\n\t */\n\tif (size <= req_size)\n\t\treturn 0;\n\n\t/*\n\t * starts from beginning of file:\n\t * it is a strong indication of long-run stream (or whole-file-read)\n\t */\n\tif (size >= offset)\n\t\tsize *= 2;\n\n\tra->start = offset;\n\tra->size = min(size + req_size, max);\n\tra->async_size = 1;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_next_miss",
          "args": [
            "mapping",
            "offset + 1",
            "max_pages"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "page_cache_next_miss",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1341-1355",
          "snippet": "pgoff_t page_cache_next_miss(struct address_space *mapping,\n\t\t\t     pgoff_t index, unsigned long max_scan)\n{\n\tXA_STATE(xas, &mapping->i_pages, index);\n\n\twhile (max_scan--) {\n\t\tvoid *entry = xas_next(&xas);\n\t\tif (!entry || xa_is_value(entry))\n\t\t\tbreak;\n\t\tif (xas.xa_index == 0)\n\t\t\tbreak;\n\t}\n\n\treturn xas.xa_index;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\npgoff_t page_cache_next_miss(struct address_space *mapping,\n\t\t\t     pgoff_t index, unsigned long max_scan)\n{\n\tXA_STATE(xas, &mapping->i_pages, index);\n\n\twhile (max_scan--) {\n\t\tvoid *entry = xas_next(&xas);\n\t\tif (!entry || xa_is_value(entry))\n\t\t\tbreak;\n\t\tif (xas.xa_index == 0)\n\t\t\tbreak;\n\t}\n\n\treturn xas.xa_index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "req_size",
            "bdi->io_pages"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_to_bdi",
          "args": [
            "mapping->host"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/fadvise.h>\n#include <linux/blk-cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/file.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/pagevec.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/export.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/kernel.h>\n\nstatic unsigned long\nondemand_readahead(struct address_space *mapping,\n\t\t   struct file_ra_state *ra, struct file *filp,\n\t\t   bool hit_readahead_marker, pgoff_t offset,\n\t\t   unsigned long req_size)\n{\n\tstruct backing_dev_info *bdi = inode_to_bdi(mapping->host);\n\tunsigned long max_pages = ra->ra_pages;\n\tunsigned long add_pages;\n\tpgoff_t prev_offset;\n\n\t/*\n\t * If the request exceeds the readahead window, allow the read to\n\t * be up to the optimal hardware IO size\n\t */\n\tif (req_size > max_pages && bdi->io_pages > max_pages)\n\t\tmax_pages = min(req_size, bdi->io_pages);\n\n\t/*\n\t * start of file\n\t */\n\tif (!offset)\n\t\tgoto initial_readahead;\n\n\t/*\n\t * It's the expected callback offset, assume sequential access.\n\t * Ramp up sizes, and push forward the readahead window.\n\t */\n\tif ((offset == (ra->start + ra->size - ra->async_size) ||\n\t     offset == (ra->start + ra->size))) {\n\t\tra->start += ra->size;\n\t\tra->size = get_next_ra_size(ra, max_pages);\n\t\tra->async_size = ra->size;\n\t\tgoto readit;\n\t}\n\n\t/*\n\t * Hit a marked page without valid readahead state.\n\t * E.g. interleaved reads.\n\t * Query the pagecache for async_size, which normally equals to\n\t * readahead size. Ramp it up and use it as the new readahead size.\n\t */\n\tif (hit_readahead_marker) {\n\t\tpgoff_t start;\n\n\t\trcu_read_lock();\n\t\tstart = page_cache_next_miss(mapping, offset + 1, max_pages);\n\t\trcu_read_unlock();\n\n\t\tif (!start || start - offset > max_pages)\n\t\t\treturn 0;\n\n\t\tra->start = start;\n\t\tra->size = start - offset;\t/* old async_size */\n\t\tra->size += req_size;\n\t\tra->size = get_next_ra_size(ra, max_pages);\n\t\tra->async_size = ra->size;\n\t\tgoto readit;\n\t}\n\n\t/*\n\t * oversize read\n\t */\n\tif (req_size > max_pages)\n\t\tgoto initial_readahead;\n\n\t/*\n\t * sequential cache miss\n\t * trivial case: (offset - prev_offset) == 1\n\t * unaligned reads: (offset - prev_offset) == 0\n\t */\n\tprev_offset = (unsigned long long)ra->prev_pos >> PAGE_SHIFT;\n\tif (offset - prev_offset <= 1UL)\n\t\tgoto initial_readahead;\n\n\t/*\n\t * Query the page cache and look for the traces(cached history pages)\n\t * that a sequential stream would leave behind.\n\t */\n\tif (try_context_readahead(mapping, ra, offset, req_size, max_pages))\n\t\tgoto readit;\n\n\t/*\n\t * standalone, small random read\n\t * Read as is, and do not pollute the readahead state.\n\t */\n\treturn __do_page_cache_readahead(mapping, filp, offset, req_size, 0);\n\ninitial_readahead:\n\tra->start = offset;\n\tra->size = get_init_ra_size(req_size, max_pages);\n\tra->async_size = ra->size > req_size ? ra->size - req_size : ra->size;\n\nreadit:\n\t/*\n\t * Will this read hit the readahead marker made by itself?\n\t * If so, trigger the readahead marker hit now, and merge\n\t * the resulted next readahead window into the current one.\n\t * Take care of maximum IO pages as above.\n\t */\n\tif (offset == ra->start && ra->size == ra->async_size) {\n\t\tadd_pages = get_next_ra_size(ra, max_pages);\n\t\tif (ra->size + add_pages <= max_pages) {\n\t\t\tra->async_size = add_pages;\n\t\t\tra->size += add_pages;\n\t\t} else {\n\t\t\tra->size = max_pages;\n\t\t\tra->async_size = max_pages >> 1;\n\t\t}\n\t}\n\n\treturn ra_submit(ra, mapping, filp);\n}"
  },
  {
    "function_name": "try_context_readahead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/readahead.c",
    "lines": "346-375",
    "snippet": "static int try_context_readahead(struct address_space *mapping,\n\t\t\t\t struct file_ra_state *ra,\n\t\t\t\t pgoff_t offset,\n\t\t\t\t unsigned long req_size,\n\t\t\t\t unsigned long max)\n{\n\tpgoff_t size;\n\n\tsize = count_history_pages(mapping, offset, max);\n\n\t/*\n\t * not enough history pages:\n\t * it could be a random read\n\t */\n\tif (size <= req_size)\n\t\treturn 0;\n\n\t/*\n\t * starts from beginning of file:\n\t * it is a strong indication of long-run stream (or whole-file-read)\n\t */\n\tif (size >= offset)\n\t\tsize *= 2;\n\n\tra->start = offset;\n\tra->size = min(size + req_size, max);\n\tra->async_size = 1;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/fadvise.h>",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/file.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/export.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dax.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "size + req_size",
            "max"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "count_history_pages",
          "args": [
            "mapping",
            "offset",
            "max"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "count_history_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/readahead.c",
          "lines": "331-341",
          "snippet": "static pgoff_t count_history_pages(struct address_space *mapping,\n\t\t\t\t   pgoff_t offset, unsigned long max)\n{\n\tpgoff_t head;\n\n\trcu_read_lock();\n\thead = page_cache_prev_miss(mapping, offset - 1, max);\n\trcu_read_unlock();\n\n\treturn offset - 1 - head;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fadvise.h>",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/file.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/export.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fadvise.h>\n#include <linux/blk-cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/file.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/pagevec.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/export.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/kernel.h>\n\nstatic pgoff_t count_history_pages(struct address_space *mapping,\n\t\t\t\t   pgoff_t offset, unsigned long max)\n{\n\tpgoff_t head;\n\n\trcu_read_lock();\n\thead = page_cache_prev_miss(mapping, offset - 1, max);\n\trcu_read_unlock();\n\n\treturn offset - 1 - head;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/fadvise.h>\n#include <linux/blk-cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/file.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/pagevec.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/export.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/kernel.h>\n\nstatic int try_context_readahead(struct address_space *mapping,\n\t\t\t\t struct file_ra_state *ra,\n\t\t\t\t pgoff_t offset,\n\t\t\t\t unsigned long req_size,\n\t\t\t\t unsigned long max)\n{\n\tpgoff_t size;\n\n\tsize = count_history_pages(mapping, offset, max);\n\n\t/*\n\t * not enough history pages:\n\t * it could be a random read\n\t */\n\tif (size <= req_size)\n\t\treturn 0;\n\n\t/*\n\t * starts from beginning of file:\n\t * it is a strong indication of long-run stream (or whole-file-read)\n\t */\n\tif (size >= offset)\n\t\tsize *= 2;\n\n\tra->start = offset;\n\tra->size = min(size + req_size, max);\n\tra->async_size = 1;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "count_history_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/readahead.c",
    "lines": "331-341",
    "snippet": "static pgoff_t count_history_pages(struct address_space *mapping,\n\t\t\t\t   pgoff_t offset, unsigned long max)\n{\n\tpgoff_t head;\n\n\trcu_read_lock();\n\thead = page_cache_prev_miss(mapping, offset - 1, max);\n\trcu_read_unlock();\n\n\treturn offset - 1 - head;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/fadvise.h>",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/file.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/export.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dax.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_prev_miss",
          "args": [
            "mapping",
            "offset - 1",
            "max"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "page_cache_prev_miss",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1377-1391",
          "snippet": "pgoff_t page_cache_prev_miss(struct address_space *mapping,\n\t\t\t     pgoff_t index, unsigned long max_scan)\n{\n\tXA_STATE(xas, &mapping->i_pages, index);\n\n\twhile (max_scan--) {\n\t\tvoid *entry = xas_prev(&xas);\n\t\tif (!entry || xa_is_value(entry))\n\t\t\tbreak;\n\t\tif (xas.xa_index == ULONG_MAX)\n\t\t\tbreak;\n\t}\n\n\treturn xas.xa_index;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\npgoff_t page_cache_prev_miss(struct address_space *mapping,\n\t\t\t     pgoff_t index, unsigned long max_scan)\n{\n\tXA_STATE(xas, &mapping->i_pages, index);\n\n\twhile (max_scan--) {\n\t\tvoid *entry = xas_prev(&xas);\n\t\tif (!entry || xa_is_value(entry))\n\t\t\tbreak;\n\t\tif (xas.xa_index == ULONG_MAX)\n\t\t\tbreak;\n\t}\n\n\treturn xas.xa_index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/fadvise.h>\n#include <linux/blk-cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/file.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/pagevec.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/export.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/kernel.h>\n\nstatic pgoff_t count_history_pages(struct address_space *mapping,\n\t\t\t\t   pgoff_t offset, unsigned long max)\n{\n\tpgoff_t head;\n\n\trcu_read_lock();\n\thead = page_cache_prev_miss(mapping, offset - 1, max);\n\trcu_read_unlock();\n\n\treturn offset - 1 - head;\n}"
  },
  {
    "function_name": "get_next_ra_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/readahead.c",
    "lines": "272-284",
    "snippet": "static unsigned long get_next_ra_size(struct file_ra_state *ra,\n\t\t\t\t\t\tunsigned long max)\n{\n\tunsigned long cur = ra->size;\n\tunsigned long newsize;\n\n\tif (cur < max / 16)\n\t\tnewsize = 4 * cur;\n\telse\n\t\tnewsize = 2 * cur;\n\n\treturn min(newsize, max);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/fadvise.h>",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/file.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/export.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dax.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "newsize",
            "max"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/fadvise.h>\n#include <linux/blk-cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/file.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/pagevec.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/export.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/kernel.h>\n\nstatic unsigned long get_next_ra_size(struct file_ra_state *ra,\n\t\t\t\t\t\tunsigned long max)\n{\n\tunsigned long cur = ra->size;\n\tunsigned long newsize;\n\n\tif (cur < max / 16)\n\t\tnewsize = 4 * cur;\n\telse\n\t\tnewsize = 2 * cur;\n\n\treturn min(newsize, max);\n}"
  },
  {
    "function_name": "get_init_ra_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/readahead.c",
    "lines": "254-266",
    "snippet": "static unsigned long get_init_ra_size(unsigned long size, unsigned long max)\n{\n\tunsigned long newsize = roundup_pow_of_two(size);\n\n\tif (newsize <= max / 32)\n\t\tnewsize = newsize * 4;\n\telse if (newsize <= max / 4)\n\t\tnewsize = newsize * 2;\n\telse\n\t\tnewsize = max;\n\n\treturn newsize;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/fadvise.h>",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/file.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/export.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dax.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "roundup_pow_of_two",
          "args": [
            "size"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/fadvise.h>\n#include <linux/blk-cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/file.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/pagevec.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/export.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/kernel.h>\n\nstatic unsigned long get_init_ra_size(unsigned long size, unsigned long max)\n{\n\tunsigned long newsize = roundup_pow_of_two(size);\n\n\tif (newsize <= max / 32)\n\t\tnewsize = newsize * 4;\n\telse if (newsize <= max / 4)\n\t\tnewsize = newsize * 2;\n\telse\n\t\tnewsize = max;\n\n\treturn newsize;\n}"
  },
  {
    "function_name": "force_page_cache_readahead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/readahead.c",
    "lines": "219-246",
    "snippet": "int force_page_cache_readahead(struct address_space *mapping, struct file *filp,\n\t\t\t       pgoff_t offset, unsigned long nr_to_read)\n{\n\tstruct backing_dev_info *bdi = inode_to_bdi(mapping->host);\n\tstruct file_ra_state *ra = &filp->f_ra;\n\tunsigned long max_pages;\n\n\tif (unlikely(!mapping->a_ops->readpage && !mapping->a_ops->readpages))\n\t\treturn -EINVAL;\n\n\t/*\n\t * If the request exceeds the readahead window, allow the read to\n\t * be up to the optimal hardware IO size\n\t */\n\tmax_pages = max_t(unsigned long, bdi->io_pages, ra->ra_pages);\n\tnr_to_read = min(nr_to_read, max_pages);\n\twhile (nr_to_read) {\n\t\tunsigned long this_chunk = (2 * 1024 * 1024) / PAGE_SIZE;\n\n\t\tif (this_chunk > nr_to_read)\n\t\t\tthis_chunk = nr_to_read;\n\t\t__do_page_cache_readahead(mapping, filp, offset, this_chunk, 0);\n\n\t\toffset += this_chunk;\n\t\tnr_to_read -= this_chunk;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/fadvise.h>",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/file.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/export.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dax.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__do_page_cache_readahead",
          "args": [
            "mapping",
            "filp",
            "offset",
            "this_chunk",
            "0"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "__do_page_cache_readahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/readahead.c",
          "lines": "152-213",
          "snippet": "unsigned int __do_page_cache_readahead(struct address_space *mapping,\n\t\tstruct file *filp, pgoff_t offset, unsigned long nr_to_read,\n\t\tunsigned long lookahead_size)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct page *page;\n\tunsigned long end_index;\t/* The last page we want to read */\n\tLIST_HEAD(page_pool);\n\tint page_idx;\n\tunsigned int nr_pages = 0;\n\tloff_t isize = i_size_read(inode);\n\tgfp_t gfp_mask = readahead_gfp_mask(mapping);\n\n\tif (isize == 0)\n\t\tgoto out;\n\n\tend_index = ((isize - 1) >> PAGE_SHIFT);\n\n\t/*\n\t * Preallocate as many pages as we will need.\n\t */\n\tfor (page_idx = 0; page_idx < nr_to_read; page_idx++) {\n\t\tpgoff_t page_offset = offset + page_idx;\n\n\t\tif (page_offset > end_index)\n\t\t\tbreak;\n\n\t\tpage = xa_load(&mapping->i_pages, page_offset);\n\t\tif (page && !xa_is_value(page)) {\n\t\t\t/*\n\t\t\t * Page already present?  Kick off the current batch of\n\t\t\t * contiguous pages before continuing with the next\n\t\t\t * batch.\n\t\t\t */\n\t\t\tif (nr_pages)\n\t\t\t\tread_pages(mapping, filp, &page_pool, nr_pages,\n\t\t\t\t\t\tgfp_mask);\n\t\t\tnr_pages = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpage = __page_cache_alloc(gfp_mask);\n\t\tif (!page)\n\t\t\tbreak;\n\t\tpage->index = page_offset;\n\t\tlist_add(&page->lru, &page_pool);\n\t\tif (page_idx == nr_to_read - lookahead_size)\n\t\t\tSetPageReadahead(page);\n\t\tnr_pages++;\n\t}\n\n\t/*\n\t * Now start the IO.  We ignore I/O errors - if the page is not\n\t * uptodate then the caller will launch readpage again, and\n\t * will then handle the error.\n\t */\n\tif (nr_pages)\n\t\tread_pages(mapping, filp, &page_pool, nr_pages, gfp_mask);\n\tBUG_ON(!list_empty(&page_pool));\nout:\n\treturn nr_pages;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fadvise.h>",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/file.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/export.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fadvise.h>\n#include <linux/blk-cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/file.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/pagevec.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/export.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/kernel.h>\n\nunsigned int __do_page_cache_readahead(struct address_space *mapping,\n\t\tstruct file *filp, pgoff_t offset, unsigned long nr_to_read,\n\t\tunsigned long lookahead_size)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct page *page;\n\tunsigned long end_index;\t/* The last page we want to read */\n\tLIST_HEAD(page_pool);\n\tint page_idx;\n\tunsigned int nr_pages = 0;\n\tloff_t isize = i_size_read(inode);\n\tgfp_t gfp_mask = readahead_gfp_mask(mapping);\n\n\tif (isize == 0)\n\t\tgoto out;\n\n\tend_index = ((isize - 1) >> PAGE_SHIFT);\n\n\t/*\n\t * Preallocate as many pages as we will need.\n\t */\n\tfor (page_idx = 0; page_idx < nr_to_read; page_idx++) {\n\t\tpgoff_t page_offset = offset + page_idx;\n\n\t\tif (page_offset > end_index)\n\t\t\tbreak;\n\n\t\tpage = xa_load(&mapping->i_pages, page_offset);\n\t\tif (page && !xa_is_value(page)) {\n\t\t\t/*\n\t\t\t * Page already present?  Kick off the current batch of\n\t\t\t * contiguous pages before continuing with the next\n\t\t\t * batch.\n\t\t\t */\n\t\t\tif (nr_pages)\n\t\t\t\tread_pages(mapping, filp, &page_pool, nr_pages,\n\t\t\t\t\t\tgfp_mask);\n\t\t\tnr_pages = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpage = __page_cache_alloc(gfp_mask);\n\t\tif (!page)\n\t\t\tbreak;\n\t\tpage->index = page_offset;\n\t\tlist_add(&page->lru, &page_pool);\n\t\tif (page_idx == nr_to_read - lookahead_size)\n\t\t\tSetPageReadahead(page);\n\t\tnr_pages++;\n\t}\n\n\t/*\n\t * Now start the IO.  We ignore I/O errors - if the page is not\n\t * uptodate then the caller will launch readpage again, and\n\t * will then handle the error.\n\t */\n\tif (nr_pages)\n\t\tread_pages(mapping, filp, &page_pool, nr_pages, gfp_mask);\n\tBUG_ON(!list_empty(&page_pool));\nout:\n\treturn nr_pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "nr_to_read",
            "max_pages"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "unsignedlong",
            "bdi->io_pages",
            "ra->ra_pages"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!mapping->a_ops->readpage && !mapping->a_ops->readpages"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_to_bdi",
          "args": [
            "mapping->host"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/fadvise.h>\n#include <linux/blk-cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/file.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/pagevec.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/export.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/kernel.h>\n\nint force_page_cache_readahead(struct address_space *mapping, struct file *filp,\n\t\t\t       pgoff_t offset, unsigned long nr_to_read)\n{\n\tstruct backing_dev_info *bdi = inode_to_bdi(mapping->host);\n\tstruct file_ra_state *ra = &filp->f_ra;\n\tunsigned long max_pages;\n\n\tif (unlikely(!mapping->a_ops->readpage && !mapping->a_ops->readpages))\n\t\treturn -EINVAL;\n\n\t/*\n\t * If the request exceeds the readahead window, allow the read to\n\t * be up to the optimal hardware IO size\n\t */\n\tmax_pages = max_t(unsigned long, bdi->io_pages, ra->ra_pages);\n\tnr_to_read = min(nr_to_read, max_pages);\n\twhile (nr_to_read) {\n\t\tunsigned long this_chunk = (2 * 1024 * 1024) / PAGE_SIZE;\n\n\t\tif (this_chunk > nr_to_read)\n\t\t\tthis_chunk = nr_to_read;\n\t\t__do_page_cache_readahead(mapping, filp, offset, this_chunk, 0);\n\n\t\toffset += this_chunk;\n\t\tnr_to_read -= this_chunk;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "__do_page_cache_readahead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/readahead.c",
    "lines": "152-213",
    "snippet": "unsigned int __do_page_cache_readahead(struct address_space *mapping,\n\t\tstruct file *filp, pgoff_t offset, unsigned long nr_to_read,\n\t\tunsigned long lookahead_size)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct page *page;\n\tunsigned long end_index;\t/* The last page we want to read */\n\tLIST_HEAD(page_pool);\n\tint page_idx;\n\tunsigned int nr_pages = 0;\n\tloff_t isize = i_size_read(inode);\n\tgfp_t gfp_mask = readahead_gfp_mask(mapping);\n\n\tif (isize == 0)\n\t\tgoto out;\n\n\tend_index = ((isize - 1) >> PAGE_SHIFT);\n\n\t/*\n\t * Preallocate as many pages as we will need.\n\t */\n\tfor (page_idx = 0; page_idx < nr_to_read; page_idx++) {\n\t\tpgoff_t page_offset = offset + page_idx;\n\n\t\tif (page_offset > end_index)\n\t\t\tbreak;\n\n\t\tpage = xa_load(&mapping->i_pages, page_offset);\n\t\tif (page && !xa_is_value(page)) {\n\t\t\t/*\n\t\t\t * Page already present?  Kick off the current batch of\n\t\t\t * contiguous pages before continuing with the next\n\t\t\t * batch.\n\t\t\t */\n\t\t\tif (nr_pages)\n\t\t\t\tread_pages(mapping, filp, &page_pool, nr_pages,\n\t\t\t\t\t\tgfp_mask);\n\t\t\tnr_pages = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpage = __page_cache_alloc(gfp_mask);\n\t\tif (!page)\n\t\t\tbreak;\n\t\tpage->index = page_offset;\n\t\tlist_add(&page->lru, &page_pool);\n\t\tif (page_idx == nr_to_read - lookahead_size)\n\t\t\tSetPageReadahead(page);\n\t\tnr_pages++;\n\t}\n\n\t/*\n\t * Now start the IO.  We ignore I/O errors - if the page is not\n\t * uptodate then the caller will launch readpage again, and\n\t * will then handle the error.\n\t */\n\tif (nr_pages)\n\t\tread_pages(mapping, filp, &page_pool, nr_pages, gfp_mask);\n\tBUG_ON(!list_empty(&page_pool));\nout:\n\treturn nr_pages;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/fadvise.h>",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/file.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/export.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dax.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&page_pool)"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&page_pool"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_pages",
          "args": [
            "mapping",
            "filp",
            "&page_pool",
            "nr_pages",
            "gfp_mask"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "read_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/readahead.c",
          "lines": "113-142",
          "snippet": "static int read_pages(struct address_space *mapping, struct file *filp,\n\t\tstruct list_head *pages, unsigned int nr_pages, gfp_t gfp)\n{\n\tstruct blk_plug plug;\n\tunsigned page_idx;\n\tint ret;\n\n\tblk_start_plug(&plug);\n\n\tif (mapping->a_ops->readpages) {\n\t\tret = mapping->a_ops->readpages(filp, mapping, pages, nr_pages);\n\t\t/* Clean up the remaining pages */\n\t\tput_pages_list(pages);\n\t\tgoto out;\n\t}\n\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tstruct page *page = lru_to_page(pages);\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, mapping, page->index, gfp))\n\t\t\tmapping->a_ops->readpage(filp, page);\n\t\tput_page(page);\n\t}\n\tret = 0;\n\nout:\n\tblk_finish_plug(&plug);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fadvise.h>",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/file.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/export.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fadvise.h>\n#include <linux/blk-cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/file.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/pagevec.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/export.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/kernel.h>\n\nstatic int read_pages(struct address_space *mapping, struct file *filp,\n\t\tstruct list_head *pages, unsigned int nr_pages, gfp_t gfp)\n{\n\tstruct blk_plug plug;\n\tunsigned page_idx;\n\tint ret;\n\n\tblk_start_plug(&plug);\n\n\tif (mapping->a_ops->readpages) {\n\t\tret = mapping->a_ops->readpages(filp, mapping, pages, nr_pages);\n\t\t/* Clean up the remaining pages */\n\t\tput_pages_list(pages);\n\t\tgoto out;\n\t}\n\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tstruct page *page = lru_to_page(pages);\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, mapping, page->index, gfp))\n\t\t\tmapping->a_ops->readpage(filp, page);\n\t\tput_page(page);\n\t}\n\tret = 0;\n\nout:\n\tblk_finish_plug(&plug);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageReadahead",
          "args": [
            "page"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&page->lru",
            "&page_pool"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__page_cache_alloc",
          "args": [
            "gfp_mask"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "__page_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "909-925",
          "snippet": "struct page *__page_cache_alloc(gfp_t gfp)\n{\n\tint n;\n\tstruct page *page;\n\n\tif (cpuset_do_page_mem_spread()) {\n\t\tunsigned int cpuset_mems_cookie;\n\t\tdo {\n\t\t\tcpuset_mems_cookie = read_mems_allowed_begin();\n\t\t\tn = cpuset_mem_spread_node();\n\t\t\tpage = __alloc_pages_node(n, gfp, 0);\n\t\t} while (!page && read_mems_allowed_retry(cpuset_mems_cookie));\n\n\t\treturn page;\n\t}\n\treturn alloc_pages(gfp, 0);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstruct page *__page_cache_alloc(gfp_t gfp)\n{\n\tint n;\n\tstruct page *page;\n\n\tif (cpuset_do_page_mem_spread()) {\n\t\tunsigned int cpuset_mems_cookie;\n\t\tdo {\n\t\t\tcpuset_mems_cookie = read_mems_allowed_begin();\n\t\t\tn = cpuset_mem_spread_node();\n\t\t\tpage = __alloc_pages_node(n, gfp, 0);\n\t\t} while (!page && read_mems_allowed_retry(cpuset_mems_cookie));\n\n\t\treturn page;\n\t}\n\treturn alloc_pages(gfp, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xa_is_value",
          "args": [
            "page"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_load",
          "args": [
            "&mapping->i_pages",
            "page_offset"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readahead_gfp_mask",
          "args": [
            "mapping"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "page_pool"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/fadvise.h>\n#include <linux/blk-cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/file.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/pagevec.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/export.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/kernel.h>\n\nunsigned int __do_page_cache_readahead(struct address_space *mapping,\n\t\tstruct file *filp, pgoff_t offset, unsigned long nr_to_read,\n\t\tunsigned long lookahead_size)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct page *page;\n\tunsigned long end_index;\t/* The last page we want to read */\n\tLIST_HEAD(page_pool);\n\tint page_idx;\n\tunsigned int nr_pages = 0;\n\tloff_t isize = i_size_read(inode);\n\tgfp_t gfp_mask = readahead_gfp_mask(mapping);\n\n\tif (isize == 0)\n\t\tgoto out;\n\n\tend_index = ((isize - 1) >> PAGE_SHIFT);\n\n\t/*\n\t * Preallocate as many pages as we will need.\n\t */\n\tfor (page_idx = 0; page_idx < nr_to_read; page_idx++) {\n\t\tpgoff_t page_offset = offset + page_idx;\n\n\t\tif (page_offset > end_index)\n\t\t\tbreak;\n\n\t\tpage = xa_load(&mapping->i_pages, page_offset);\n\t\tif (page && !xa_is_value(page)) {\n\t\t\t/*\n\t\t\t * Page already present?  Kick off the current batch of\n\t\t\t * contiguous pages before continuing with the next\n\t\t\t * batch.\n\t\t\t */\n\t\t\tif (nr_pages)\n\t\t\t\tread_pages(mapping, filp, &page_pool, nr_pages,\n\t\t\t\t\t\tgfp_mask);\n\t\t\tnr_pages = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpage = __page_cache_alloc(gfp_mask);\n\t\tif (!page)\n\t\t\tbreak;\n\t\tpage->index = page_offset;\n\t\tlist_add(&page->lru, &page_pool);\n\t\tif (page_idx == nr_to_read - lookahead_size)\n\t\t\tSetPageReadahead(page);\n\t\tnr_pages++;\n\t}\n\n\t/*\n\t * Now start the IO.  We ignore I/O errors - if the page is not\n\t * uptodate then the caller will launch readpage again, and\n\t * will then handle the error.\n\t */\n\tif (nr_pages)\n\t\tread_pages(mapping, filp, &page_pool, nr_pages, gfp_mask);\n\tBUG_ON(!list_empty(&page_pool));\nout:\n\treturn nr_pages;\n}"
  },
  {
    "function_name": "read_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/readahead.c",
    "lines": "113-142",
    "snippet": "static int read_pages(struct address_space *mapping, struct file *filp,\n\t\tstruct list_head *pages, unsigned int nr_pages, gfp_t gfp)\n{\n\tstruct blk_plug plug;\n\tunsigned page_idx;\n\tint ret;\n\n\tblk_start_plug(&plug);\n\n\tif (mapping->a_ops->readpages) {\n\t\tret = mapping->a_ops->readpages(filp, mapping, pages, nr_pages);\n\t\t/* Clean up the remaining pages */\n\t\tput_pages_list(pages);\n\t\tgoto out;\n\t}\n\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tstruct page *page = lru_to_page(pages);\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, mapping, page->index, gfp))\n\t\t\tmapping->a_ops->readpage(filp, page);\n\t\tput_page(page);\n\t}\n\tret = 0;\n\nout:\n\tblk_finish_plug(&plug);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/fadvise.h>",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/file.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/export.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dax.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping->a_ops->readpage",
          "args": [
            "filp",
            "page"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_to_page_cache_lru",
          "args": [
            "page",
            "mapping",
            "page->index",
            "gfp"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "add_to_page_cache_lru",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "879-905",
          "snippet": "int add_to_page_cache_lru(struct page *page, struct address_space *mapping,\n\t\t\t\tpgoff_t offset, gfp_t gfp_mask)\n{\n\tvoid *shadow = NULL;\n\tint ret;\n\n\t__SetPageLocked(page);\n\tret = __add_to_page_cache_locked(page, mapping, offset,\n\t\t\t\t\t gfp_mask, &shadow);\n\tif (unlikely(ret))\n\t\t__ClearPageLocked(page);\n\telse {\n\t\t/*\n\t\t * The page might have been evicted from cache only\n\t\t * recently, in which case it should be activated like\n\t\t * any other repeatedly accessed page.\n\t\t * The exception is pages getting rewritten; evicting other\n\t\t * data from the working set, only to cache data that will\n\t\t * get overwritten with something else, is a waste of memory.\n\t\t */\n\t\tWARN_ON_ONCE(PageActive(page));\n\t\tif (!(gfp_mask & __GFP_WRITE) && shadow)\n\t\t\tworkingset_refault(page, shadow);\n\t\tlru_cache_add(page);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint add_to_page_cache_lru(struct page *page, struct address_space *mapping,\n\t\t\t\tpgoff_t offset, gfp_t gfp_mask)\n{\n\tvoid *shadow = NULL;\n\tint ret;\n\n\t__SetPageLocked(page);\n\tret = __add_to_page_cache_locked(page, mapping, offset,\n\t\t\t\t\t gfp_mask, &shadow);\n\tif (unlikely(ret))\n\t\t__ClearPageLocked(page);\n\telse {\n\t\t/*\n\t\t * The page might have been evicted from cache only\n\t\t * recently, in which case it should be activated like\n\t\t * any other repeatedly accessed page.\n\t\t * The exception is pages getting rewritten; evicting other\n\t\t * data from the working set, only to cache data that will\n\t\t * get overwritten with something else, is a waste of memory.\n\t\t */\n\t\tWARN_ON_ONCE(PageActive(page));\n\t\tif (!(gfp_mask & __GFP_WRITE) && shadow)\n\t\t\tworkingset_refault(page, shadow);\n\t\tlru_cache_add(page);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lru_to_page",
          "args": [
            "pages"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_pages_list",
          "args": [
            "pages"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "put_pages_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "124-133",
          "snippet": "void put_pages_list(struct list_head *pages)\n{\n\twhile (!list_empty(pages)) {\n\t\tstruct page *victim;\n\n\t\tvictim = list_entry(pages->prev, struct page, lru);\n\t\tlist_del(&victim->lru);\n\t\tput_page(victim);\n\t}\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid put_pages_list(struct list_head *pages)\n{\n\twhile (!list_empty(pages)) {\n\t\tstruct page *victim;\n\n\t\tvictim = list_entry(pages->prev, struct page, lru);\n\t\tlist_del(&victim->lru);\n\t\tput_page(victim);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping->a_ops->readpages",
          "args": [
            "filp",
            "mapping",
            "pages",
            "nr_pages"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_start_plug",
          "args": [
            "&plug"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/fadvise.h>\n#include <linux/blk-cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/file.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/pagevec.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/export.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/kernel.h>\n\nstatic int read_pages(struct address_space *mapping, struct file *filp,\n\t\tstruct list_head *pages, unsigned int nr_pages, gfp_t gfp)\n{\n\tstruct blk_plug plug;\n\tunsigned page_idx;\n\tint ret;\n\n\tblk_start_plug(&plug);\n\n\tif (mapping->a_ops->readpages) {\n\t\tret = mapping->a_ops->readpages(filp, mapping, pages, nr_pages);\n\t\t/* Clean up the remaining pages */\n\t\tput_pages_list(pages);\n\t\tgoto out;\n\t}\n\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tstruct page *page = lru_to_page(pages);\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, mapping, page->index, gfp))\n\t\t\tmapping->a_ops->readpage(filp, page);\n\t\tput_page(page);\n\t}\n\tret = 0;\n\nout:\n\tblk_finish_plug(&plug);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "read_cache_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/readahead.c",
    "lines": "85-109",
    "snippet": "int read_cache_pages(struct address_space *mapping, struct list_head *pages,\n\t\t\tint (*filler)(void *, struct page *), void *data)\n{\n\tstruct page *page;\n\tint ret = 0;\n\n\twhile (!list_empty(pages)) {\n\t\tpage = lru_to_page(pages);\n\t\tlist_del(&page->lru);\n\t\tif (add_to_page_cache_lru(page, mapping, page->index,\n\t\t\t\treadahead_gfp_mask(mapping))) {\n\t\t\tread_cache_pages_invalidate_page(mapping, page);\n\t\t\tcontinue;\n\t\t}\n\t\tput_page(page);\n\n\t\tret = filler(data, page);\n\t\tif (unlikely(ret)) {\n\t\t\tread_cache_pages_invalidate_pages(mapping, pages);\n\t\t\tbreak;\n\t\t}\n\t\ttask_io_account_read(PAGE_SIZE);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/fadvise.h>",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/file.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/export.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dax.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_io_account_read",
          "args": [
            "PAGE_SIZE"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_cache_pages_invalidate_pages",
          "args": [
            "mapping",
            "pages"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "read_cache_pages_invalidate_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/readahead.c",
          "lines": "63-73",
          "snippet": "static void read_cache_pages_invalidate_pages(struct address_space *mapping,\n\t\t\t\t\t      struct list_head *pages)\n{\n\tstruct page *victim;\n\n\twhile (!list_empty(pages)) {\n\t\tvictim = lru_to_page(pages);\n\t\tlist_del(&victim->lru);\n\t\tread_cache_pages_invalidate_page(mapping, victim);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fadvise.h>",
            "#include <linux/blk-cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/file.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/export.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fadvise.h>\n#include <linux/blk-cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/file.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/pagevec.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/export.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/kernel.h>\n\nstatic void read_cache_pages_invalidate_pages(struct address_space *mapping,\n\t\t\t\t\t      struct list_head *pages)\n{\n\tstruct page *victim;\n\n\twhile (!list_empty(pages)) {\n\t\tvictim = lru_to_page(pages);\n\t\tlist_del(&victim->lru);\n\t\tread_cache_pages_invalidate_page(mapping, victim);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filler",
          "args": [
            "data",
            "page"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_to_page_cache_lru",
          "args": [
            "page",
            "mapping",
            "page->index",
            "readahead_gfp_mask(mapping)"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "add_to_page_cache_lru",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "879-905",
          "snippet": "int add_to_page_cache_lru(struct page *page, struct address_space *mapping,\n\t\t\t\tpgoff_t offset, gfp_t gfp_mask)\n{\n\tvoid *shadow = NULL;\n\tint ret;\n\n\t__SetPageLocked(page);\n\tret = __add_to_page_cache_locked(page, mapping, offset,\n\t\t\t\t\t gfp_mask, &shadow);\n\tif (unlikely(ret))\n\t\t__ClearPageLocked(page);\n\telse {\n\t\t/*\n\t\t * The page might have been evicted from cache only\n\t\t * recently, in which case it should be activated like\n\t\t * any other repeatedly accessed page.\n\t\t * The exception is pages getting rewritten; evicting other\n\t\t * data from the working set, only to cache data that will\n\t\t * get overwritten with something else, is a waste of memory.\n\t\t */\n\t\tWARN_ON_ONCE(PageActive(page));\n\t\tif (!(gfp_mask & __GFP_WRITE) && shadow)\n\t\t\tworkingset_refault(page, shadow);\n\t\tlru_cache_add(page);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nint add_to_page_cache_lru(struct page *page, struct address_space *mapping,\n\t\t\t\tpgoff_t offset, gfp_t gfp_mask)\n{\n\tvoid *shadow = NULL;\n\tint ret;\n\n\t__SetPageLocked(page);\n\tret = __add_to_page_cache_locked(page, mapping, offset,\n\t\t\t\t\t gfp_mask, &shadow);\n\tif (unlikely(ret))\n\t\t__ClearPageLocked(page);\n\telse {\n\t\t/*\n\t\t * The page might have been evicted from cache only\n\t\t * recently, in which case it should be activated like\n\t\t * any other repeatedly accessed page.\n\t\t * The exception is pages getting rewritten; evicting other\n\t\t * data from the working set, only to cache data that will\n\t\t * get overwritten with something else, is a waste of memory.\n\t\t */\n\t\tWARN_ON_ONCE(PageActive(page));\n\t\tif (!(gfp_mask & __GFP_WRITE) && shadow)\n\t\t\tworkingset_refault(page, shadow);\n\t\tlru_cache_add(page);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "readahead_gfp_mask",
          "args": [
            "mapping"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lru_to_page",
          "args": [
            "pages"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "pages"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/fadvise.h>\n#include <linux/blk-cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/file.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/pagevec.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/export.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/kernel.h>\n\nint read_cache_pages(struct address_space *mapping, struct list_head *pages,\n\t\t\tint (*filler)(void *, struct page *), void *data)\n{\n\tstruct page *page;\n\tint ret = 0;\n\n\twhile (!list_empty(pages)) {\n\t\tpage = lru_to_page(pages);\n\t\tlist_del(&page->lru);\n\t\tif (add_to_page_cache_lru(page, mapping, page->index,\n\t\t\t\treadahead_gfp_mask(mapping))) {\n\t\t\tread_cache_pages_invalidate_page(mapping, page);\n\t\t\tcontinue;\n\t\t}\n\t\tput_page(page);\n\n\t\tret = filler(data, page);\n\t\tif (unlikely(ret)) {\n\t\t\tread_cache_pages_invalidate_pages(mapping, pages);\n\t\t\tbreak;\n\t\t}\n\t\ttask_io_account_read(PAGE_SIZE);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "read_cache_pages_invalidate_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/readahead.c",
    "lines": "63-73",
    "snippet": "static void read_cache_pages_invalidate_pages(struct address_space *mapping,\n\t\t\t\t\t      struct list_head *pages)\n{\n\tstruct page *victim;\n\n\twhile (!list_empty(pages)) {\n\t\tvictim = lru_to_page(pages);\n\t\tlist_del(&victim->lru);\n\t\tread_cache_pages_invalidate_page(mapping, victim);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/fadvise.h>",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/file.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/export.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dax.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_cache_pages_invalidate_page",
          "args": [
            "mapping",
            "victim"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "read_cache_pages_invalidate_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/readahead.c",
          "lines": "63-73",
          "snippet": "static void read_cache_pages_invalidate_pages(struct address_space *mapping,\n\t\t\t\t\t      struct list_head *pages)\n{\n\tstruct page *victim;\n\n\twhile (!list_empty(pages)) {\n\t\tvictim = lru_to_page(pages);\n\t\tlist_del(&victim->lru);\n\t\tread_cache_pages_invalidate_page(mapping, victim);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&victim->lru"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lru_to_page",
          "args": [
            "pages"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "pages"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/fadvise.h>\n#include <linux/blk-cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/file.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/pagevec.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/export.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/kernel.h>\n\nstatic void read_cache_pages_invalidate_pages(struct address_space *mapping,\n\t\t\t\t\t      struct list_head *pages)\n{\n\tstruct page *victim;\n\n\twhile (!list_empty(pages)) {\n\t\tvictim = lru_to_page(pages);\n\t\tlist_del(&victim->lru);\n\t\tread_cache_pages_invalidate_page(mapping, victim);\n\t}\n}"
  },
  {
    "function_name": "read_cache_pages_invalidate_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/readahead.c",
    "lines": "46-58",
    "snippet": "static void read_cache_pages_invalidate_page(struct address_space *mapping,\n\t\t\t\t\t     struct page *page)\n{\n\tif (page_has_private(page)) {\n\t\tif (!trylock_page(page))\n\t\t\tBUG();\n\t\tpage->mapping = mapping;\n\t\tdo_invalidatepage(page, 0, PAGE_SIZE);\n\t\tpage->mapping = NULL;\n\t\tunlock_page(page);\n\t}\n\tput_page(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/fadvise.h>",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/file.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/export.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dax.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_invalidatepage",
          "args": [
            "page",
            "0",
            "PAGE_SIZE"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "do_invalidatepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/truncate.c",
          "lines": "151-163",
          "snippet": "void do_invalidatepage(struct page *page, unsigned int offset,\n\t\t       unsigned int length)\n{\n\tvoid (*invalidatepage)(struct page *, unsigned int, unsigned int);\n\n\tinvalidatepage = page->mapping->a_ops->invalidatepage;\n#ifdef CONFIG_BLOCK\n\tif (!invalidatepage)\n\t\tinvalidatepage = block_invalidatepage;\n#endif\n\tif (invalidatepage)\n\t\t(*invalidatepage)(page, offset, length);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/rmap.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dax.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/rmap.h>\n#include <linux/cleancache.h>\n#include <linux/shmem_fs.h>\n#include <linux/buffer_head.h>\t/* grr. try_to_release_page,\n\t\t\t\t   do_invalidatepage */\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/backing-dev.h>\n#include <linux/kernel.h>\n\nvoid do_invalidatepage(struct page *page, unsigned int offset,\n\t\t       unsigned int length)\n{\n\tvoid (*invalidatepage)(struct page *, unsigned int, unsigned int);\n\n\tinvalidatepage = page->mapping->a_ops->invalidatepage;\n#ifdef CONFIG_BLOCK\n\tif (!invalidatepage)\n\t\tinvalidatepage = block_invalidatepage;\n#endif\n\tif (invalidatepage)\n\t\t(*invalidatepage)(page, offset, length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_private",
          "args": [
            "page"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/fadvise.h>\n#include <linux/blk-cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/file.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/pagevec.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/export.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/kernel.h>\n\nstatic void read_cache_pages_invalidate_page(struct address_space *mapping,\n\t\t\t\t\t     struct page *page)\n{\n\tif (page_has_private(page)) {\n\t\tif (!trylock_page(page))\n\t\t\tBUG();\n\t\tpage->mapping = mapping;\n\t\tdo_invalidatepage(page, 0, PAGE_SIZE);\n\t\tpage->mapping = NULL;\n\t\tunlock_page(page);\n\t}\n\tput_page(page);\n}"
  },
  {
    "function_name": "file_ra_state_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/readahead.c",
    "lines": "31-36",
    "snippet": "void\nfile_ra_state_init(struct file_ra_state *ra, struct address_space *mapping)\n{\n\tra->ra_pages = inode_to_bdi(mapping->host)->ra_pages;\n\tra->prev_pos = -1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/fadvise.h>",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/file.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/export.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dax.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_to_bdi",
          "args": [
            "mapping->host"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/fadvise.h>\n#include <linux/blk-cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/file.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/pagevec.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/export.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/kernel.h>\n\nvoid\nfile_ra_state_init(struct file_ra_state *ra, struct address_space *mapping)\n{\n\tra->ra_pages = inode_to_bdi(mapping->host)->ra_pages;\n\tra->prev_pos = -1;\n}"
  },
  {
    "function_name": "readahead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/readahead.c",
    "lines": "603-606",
    "snippet": "SYSCALL_DEFINE3(readahead, int, fd, loff_t, offset, size_t, count)\n{\n\treturn ksys_readahead(fd, offset, count);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/fadvise.h>",
      "#include <linux/blk-cgroup.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/file.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/export.h>",
      "#include <linux/gfp.h>",
      "#include <linux/dax.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/fadvise.h>\n#include <linux/blk-cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/file.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/pagevec.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/export.h>\n#include <linux/gfp.h>\n#include <linux/dax.h>\n#include <linux/kernel.h>\n\nSYSCALL_DEFINE3(readahead, int, fd, loff_t, offset, size_t, count)\n{\n\treturn ksys_readahead(fd, offset, count);\n}"
  }
]