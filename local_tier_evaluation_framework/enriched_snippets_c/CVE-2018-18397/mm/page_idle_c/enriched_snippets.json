[
  {
    "function_name": "page_idle_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_idle.c",
    "lines": "227-237",
    "snippet": "static int __init page_idle_init(void)\n{\n\tint err;\n\n\terr = sysfs_create_group(mm_kobj, &page_idle_attr_group);\n\tif (err) {\n\t\tpr_err(\"page_idle: register sysfs failed\\n\");\n\t\treturn err;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/page_idle.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/kobject.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct attribute_group page_idle_attr_group = {\n\t.bin_attrs = page_idle_bin_attrs,\n\t.name = \"page_idle\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"page_idle: register sysfs failed\\n\""
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_create_group",
          "args": [
            "mm_kobj",
            "&page_idle_attr_group"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_ext.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/kobject.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n\nstatic const struct attribute_group page_idle_attr_group = {\n\t.bin_attrs = page_idle_bin_attrs,\n\t.name = \"page_idle\",\n};\n\nstatic int __init page_idle_init(void)\n{\n\tint err;\n\n\terr = sysfs_create_group(mm_kobj, &page_idle_attr_group);\n\tif (err) {\n\t\tpr_err(\"page_idle: register sysfs failed\\n\");\n\t\treturn err;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "need_page_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_idle.c",
    "lines": "218-221",
    "snippet": "static bool need_page_idle(void)\n{\n\treturn true;\n}",
    "includes": [
      "#include <linux/page_idle.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/kobject.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_ext.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/kobject.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n\nstatic bool need_page_idle(void)\n{\n\treturn true;\n}"
  },
  {
    "function_name": "page_idle_bitmap_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_idle.c",
    "lines": "166-201",
    "snippet": "static ssize_t page_idle_bitmap_write(struct file *file, struct kobject *kobj,\n\t\t\t\t      struct bin_attribute *attr, char *buf,\n\t\t\t\t      loff_t pos, size_t count)\n{\n\tconst u64 *in = (u64 *)buf;\n\tstruct page *page;\n\tunsigned long pfn, end_pfn;\n\tint bit;\n\n\tif (pos % BITMAP_CHUNK_SIZE || count % BITMAP_CHUNK_SIZE)\n\t\treturn -EINVAL;\n\n\tpfn = pos * BITS_PER_BYTE;\n\tif (pfn >= max_pfn)\n\t\treturn -ENXIO;\n\n\tend_pfn = pfn + count * BITS_PER_BYTE;\n\tif (end_pfn > max_pfn)\n\t\tend_pfn = ALIGN(max_pfn, BITMAP_CHUNK_BITS);\n\n\tfor (; pfn < end_pfn; pfn++) {\n\t\tbit = pfn % BITMAP_CHUNK_BITS;\n\t\tif ((*in >> bit) & 1) {\n\t\t\tpage = page_idle_get_page(pfn);\n\t\t\tif (page) {\n\t\t\t\tpage_idle_clear_pte_refs(page);\n\t\t\t\tset_page_idle(page);\n\t\t\t\tput_page(page);\n\t\t\t}\n\t\t}\n\t\tif (bit == BITMAP_CHUNK_BITS - 1)\n\t\t\tin++;\n\t\tcond_resched();\n\t}\n\treturn (char *)in - buf;\n}",
    "includes": [
      "#include <linux/page_idle.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/kobject.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define BITMAP_CHUNK_BITS\t(BITMAP_CHUNK_SIZE * BITS_PER_BYTE)",
      "#define BITMAP_CHUNK_SIZE\tsizeof(u64)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_idle",
          "args": [
            "page"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_idle_clear_pte_refs",
          "args": [
            "page"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "page_idle_clear_pte_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_idle.c",
          "lines": "95-119",
          "snippet": "static void page_idle_clear_pte_refs(struct page *page)\n{\n\t/*\n\t * Since rwc.arg is unused, rwc is effectively immutable, so we\n\t * can make it static const to save some cycles and stack.\n\t */\n\tstatic const struct rmap_walk_control rwc = {\n\t\t.rmap_one = page_idle_clear_pte_refs_one,\n\t\t.anon_lock = page_lock_anon_vma_read,\n\t};\n\tbool need_lock;\n\n\tif (!page_mapped(page) ||\n\t    !page_rmapping(page))\n\t\treturn;\n\n\tneed_lock = !PageAnon(page) || PageKsm(page);\n\tif (need_lock && !trylock_page(page))\n\t\treturn;\n\n\trmap_walk(page, (struct rmap_walk_control *)&rwc);\n\n\tif (need_lock)\n\t\tunlock_page(page);\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/kobject.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_ext.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/kobject.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n\nstatic void page_idle_clear_pte_refs(struct page *page)\n{\n\t/*\n\t * Since rwc.arg is unused, rwc is effectively immutable, so we\n\t * can make it static const to save some cycles and stack.\n\t */\n\tstatic const struct rmap_walk_control rwc = {\n\t\t.rmap_one = page_idle_clear_pte_refs_one,\n\t\t.anon_lock = page_lock_anon_vma_read,\n\t};\n\tbool need_lock;\n\n\tif (!page_mapped(page) ||\n\t    !page_rmapping(page))\n\t\treturn;\n\n\tneed_lock = !PageAnon(page) || PageKsm(page);\n\tif (need_lock && !trylock_page(page))\n\t\treturn;\n\n\trmap_walk(page, (struct rmap_walk_control *)&rwc);\n\n\tif (need_lock)\n\t\tunlock_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_idle_get_page",
          "args": [
            "pfn"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "page_idle_get_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_idle.c",
          "lines": "31-52",
          "snippet": "static struct page *page_idle_get_page(unsigned long pfn)\n{\n\tstruct page *page;\n\tstruct zone *zone;\n\n\tif (!pfn_valid(pfn))\n\t\treturn NULL;\n\n\tpage = pfn_to_page(pfn);\n\tif (!page || !PageLRU(page) ||\n\t    !get_page_unless_zero(page))\n\t\treturn NULL;\n\n\tzone = page_zone(page);\n\tspin_lock_irq(zone_lru_lock(zone));\n\tif (unlikely(!PageLRU(page))) {\n\t\tput_page(page);\n\t\tpage = NULL;\n\t}\n\tspin_unlock_irq(zone_lru_lock(zone));\n\treturn page;\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/kobject.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_ext.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/kobject.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n\nstatic struct page *page_idle_get_page(unsigned long pfn)\n{\n\tstruct page *page;\n\tstruct zone *zone;\n\n\tif (!pfn_valid(pfn))\n\t\treturn NULL;\n\n\tpage = pfn_to_page(pfn);\n\tif (!page || !PageLRU(page) ||\n\t    !get_page_unless_zero(page))\n\t\treturn NULL;\n\n\tzone = page_zone(page);\n\tspin_lock_irq(zone_lru_lock(zone));\n\tif (unlikely(!PageLRU(page))) {\n\t\tput_page(page);\n\t\tpage = NULL;\n\t}\n\tspin_unlock_irq(zone_lru_lock(zone));\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "max_pfn",
            "BITMAP_CHUNK_BITS"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_ext.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/kobject.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n\n#define BITMAP_CHUNK_BITS\t(BITMAP_CHUNK_SIZE * BITS_PER_BYTE)\n#define BITMAP_CHUNK_SIZE\tsizeof(u64)\n\nstatic ssize_t page_idle_bitmap_write(struct file *file, struct kobject *kobj,\n\t\t\t\t      struct bin_attribute *attr, char *buf,\n\t\t\t\t      loff_t pos, size_t count)\n{\n\tconst u64 *in = (u64 *)buf;\n\tstruct page *page;\n\tunsigned long pfn, end_pfn;\n\tint bit;\n\n\tif (pos % BITMAP_CHUNK_SIZE || count % BITMAP_CHUNK_SIZE)\n\t\treturn -EINVAL;\n\n\tpfn = pos * BITS_PER_BYTE;\n\tif (pfn >= max_pfn)\n\t\treturn -ENXIO;\n\n\tend_pfn = pfn + count * BITS_PER_BYTE;\n\tif (end_pfn > max_pfn)\n\t\tend_pfn = ALIGN(max_pfn, BITMAP_CHUNK_BITS);\n\n\tfor (; pfn < end_pfn; pfn++) {\n\t\tbit = pfn % BITMAP_CHUNK_BITS;\n\t\tif ((*in >> bit) & 1) {\n\t\t\tpage = page_idle_get_page(pfn);\n\t\t\tif (page) {\n\t\t\t\tpage_idle_clear_pte_refs(page);\n\t\t\t\tset_page_idle(page);\n\t\t\t\tput_page(page);\n\t\t\t}\n\t\t}\n\t\tif (bit == BITMAP_CHUNK_BITS - 1)\n\t\t\tin++;\n\t\tcond_resched();\n\t}\n\treturn (char *)in - buf;\n}"
  },
  {
    "function_name": "page_idle_bitmap_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_idle.c",
    "lines": "121-164",
    "snippet": "static ssize_t page_idle_bitmap_read(struct file *file, struct kobject *kobj,\n\t\t\t\t     struct bin_attribute *attr, char *buf,\n\t\t\t\t     loff_t pos, size_t count)\n{\n\tu64 *out = (u64 *)buf;\n\tstruct page *page;\n\tunsigned long pfn, end_pfn;\n\tint bit;\n\n\tif (pos % BITMAP_CHUNK_SIZE || count % BITMAP_CHUNK_SIZE)\n\t\treturn -EINVAL;\n\n\tpfn = pos * BITS_PER_BYTE;\n\tif (pfn >= max_pfn)\n\t\treturn 0;\n\n\tend_pfn = pfn + count * BITS_PER_BYTE;\n\tif (end_pfn > max_pfn)\n\t\tend_pfn = ALIGN(max_pfn, BITMAP_CHUNK_BITS);\n\n\tfor (; pfn < end_pfn; pfn++) {\n\t\tbit = pfn % BITMAP_CHUNK_BITS;\n\t\tif (!bit)\n\t\t\t*out = 0ULL;\n\t\tpage = page_idle_get_page(pfn);\n\t\tif (page) {\n\t\t\tif (page_is_idle(page)) {\n\t\t\t\t/*\n\t\t\t\t * The page might have been referenced via a\n\t\t\t\t * pte, in which case it is not idle. Clear\n\t\t\t\t * refs and recheck.\n\t\t\t\t */\n\t\t\t\tpage_idle_clear_pte_refs(page);\n\t\t\t\tif (page_is_idle(page))\n\t\t\t\t\t*out |= 1ULL << bit;\n\t\t\t}\n\t\t\tput_page(page);\n\t\t}\n\t\tif (bit == BITMAP_CHUNK_BITS - 1)\n\t\t\tout++;\n\t\tcond_resched();\n\t}\n\treturn (char *)out - buf;\n}",
    "includes": [
      "#include <linux/page_idle.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/kobject.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define BITMAP_CHUNK_BITS\t(BITMAP_CHUNK_SIZE * BITS_PER_BYTE)",
      "#define BITMAP_CHUNK_SIZE\tsizeof(u64)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_is_idle",
          "args": [
            "page"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_idle_clear_pte_refs",
          "args": [
            "page"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "page_idle_clear_pte_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_idle.c",
          "lines": "95-119",
          "snippet": "static void page_idle_clear_pte_refs(struct page *page)\n{\n\t/*\n\t * Since rwc.arg is unused, rwc is effectively immutable, so we\n\t * can make it static const to save some cycles and stack.\n\t */\n\tstatic const struct rmap_walk_control rwc = {\n\t\t.rmap_one = page_idle_clear_pte_refs_one,\n\t\t.anon_lock = page_lock_anon_vma_read,\n\t};\n\tbool need_lock;\n\n\tif (!page_mapped(page) ||\n\t    !page_rmapping(page))\n\t\treturn;\n\n\tneed_lock = !PageAnon(page) || PageKsm(page);\n\tif (need_lock && !trylock_page(page))\n\t\treturn;\n\n\trmap_walk(page, (struct rmap_walk_control *)&rwc);\n\n\tif (need_lock)\n\t\tunlock_page(page);\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/kobject.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_ext.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/kobject.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n\nstatic void page_idle_clear_pte_refs(struct page *page)\n{\n\t/*\n\t * Since rwc.arg is unused, rwc is effectively immutable, so we\n\t * can make it static const to save some cycles and stack.\n\t */\n\tstatic const struct rmap_walk_control rwc = {\n\t\t.rmap_one = page_idle_clear_pte_refs_one,\n\t\t.anon_lock = page_lock_anon_vma_read,\n\t};\n\tbool need_lock;\n\n\tif (!page_mapped(page) ||\n\t    !page_rmapping(page))\n\t\treturn;\n\n\tneed_lock = !PageAnon(page) || PageKsm(page);\n\tif (need_lock && !trylock_page(page))\n\t\treturn;\n\n\trmap_walk(page, (struct rmap_walk_control *)&rwc);\n\n\tif (need_lock)\n\t\tunlock_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_is_idle",
          "args": [
            "page"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_idle_get_page",
          "args": [
            "pfn"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "page_idle_get_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_idle.c",
          "lines": "31-52",
          "snippet": "static struct page *page_idle_get_page(unsigned long pfn)\n{\n\tstruct page *page;\n\tstruct zone *zone;\n\n\tif (!pfn_valid(pfn))\n\t\treturn NULL;\n\n\tpage = pfn_to_page(pfn);\n\tif (!page || !PageLRU(page) ||\n\t    !get_page_unless_zero(page))\n\t\treturn NULL;\n\n\tzone = page_zone(page);\n\tspin_lock_irq(zone_lru_lock(zone));\n\tif (unlikely(!PageLRU(page))) {\n\t\tput_page(page);\n\t\tpage = NULL;\n\t}\n\tspin_unlock_irq(zone_lru_lock(zone));\n\treturn page;\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/kobject.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_ext.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/kobject.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n\nstatic struct page *page_idle_get_page(unsigned long pfn)\n{\n\tstruct page *page;\n\tstruct zone *zone;\n\n\tif (!pfn_valid(pfn))\n\t\treturn NULL;\n\n\tpage = pfn_to_page(pfn);\n\tif (!page || !PageLRU(page) ||\n\t    !get_page_unless_zero(page))\n\t\treturn NULL;\n\n\tzone = page_zone(page);\n\tspin_lock_irq(zone_lru_lock(zone));\n\tif (unlikely(!PageLRU(page))) {\n\t\tput_page(page);\n\t\tpage = NULL;\n\t}\n\tspin_unlock_irq(zone_lru_lock(zone));\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "max_pfn",
            "BITMAP_CHUNK_BITS"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_ext.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/kobject.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n\n#define BITMAP_CHUNK_BITS\t(BITMAP_CHUNK_SIZE * BITS_PER_BYTE)\n#define BITMAP_CHUNK_SIZE\tsizeof(u64)\n\nstatic ssize_t page_idle_bitmap_read(struct file *file, struct kobject *kobj,\n\t\t\t\t     struct bin_attribute *attr, char *buf,\n\t\t\t\t     loff_t pos, size_t count)\n{\n\tu64 *out = (u64 *)buf;\n\tstruct page *page;\n\tunsigned long pfn, end_pfn;\n\tint bit;\n\n\tif (pos % BITMAP_CHUNK_SIZE || count % BITMAP_CHUNK_SIZE)\n\t\treturn -EINVAL;\n\n\tpfn = pos * BITS_PER_BYTE;\n\tif (pfn >= max_pfn)\n\t\treturn 0;\n\n\tend_pfn = pfn + count * BITS_PER_BYTE;\n\tif (end_pfn > max_pfn)\n\t\tend_pfn = ALIGN(max_pfn, BITMAP_CHUNK_BITS);\n\n\tfor (; pfn < end_pfn; pfn++) {\n\t\tbit = pfn % BITMAP_CHUNK_BITS;\n\t\tif (!bit)\n\t\t\t*out = 0ULL;\n\t\tpage = page_idle_get_page(pfn);\n\t\tif (page) {\n\t\t\tif (page_is_idle(page)) {\n\t\t\t\t/*\n\t\t\t\t * The page might have been referenced via a\n\t\t\t\t * pte, in which case it is not idle. Clear\n\t\t\t\t * refs and recheck.\n\t\t\t\t */\n\t\t\t\tpage_idle_clear_pte_refs(page);\n\t\t\t\tif (page_is_idle(page))\n\t\t\t\t\t*out |= 1ULL << bit;\n\t\t\t}\n\t\t\tput_page(page);\n\t\t}\n\t\tif (bit == BITMAP_CHUNK_BITS - 1)\n\t\t\tout++;\n\t\tcond_resched();\n\t}\n\treturn (char *)out - buf;\n}"
  },
  {
    "function_name": "page_idle_clear_pte_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_idle.c",
    "lines": "95-119",
    "snippet": "static void page_idle_clear_pte_refs(struct page *page)\n{\n\t/*\n\t * Since rwc.arg is unused, rwc is effectively immutable, so we\n\t * can make it static const to save some cycles and stack.\n\t */\n\tstatic const struct rmap_walk_control rwc = {\n\t\t.rmap_one = page_idle_clear_pte_refs_one,\n\t\t.anon_lock = page_lock_anon_vma_read,\n\t};\n\tbool need_lock;\n\n\tif (!page_mapped(page) ||\n\t    !page_rmapping(page))\n\t\treturn;\n\n\tneed_lock = !PageAnon(page) || PageKsm(page);\n\tif (need_lock && !trylock_page(page))\n\t\treturn;\n\n\trmap_walk(page, (struct rmap_walk_control *)&rwc);\n\n\tif (need_lock)\n\t\tunlock_page(page);\n}",
    "includes": [
      "#include <linux/page_idle.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/kobject.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmap_walk",
          "args": [
            "page",
            "(struct rmap_walk_control *)&rwc"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "rmap_walk_ksm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/ksm.c",
          "lines": "2579-2641",
          "snippet": "void rmap_walk_ksm(struct page *page, struct rmap_walk_control *rwc)\n{\n\tstruct stable_node *stable_node;\n\tstruct rmap_item *rmap_item;\n\tint search_new_forks = 0;\n\n\tVM_BUG_ON_PAGE(!PageKsm(page), page);\n\n\t/*\n\t * Rely on the page lock to protect against concurrent modifications\n\t * to that page's node of the stable tree.\n\t */\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tstable_node = page_stable_node(page);\n\tif (!stable_node)\n\t\treturn;\nagain:\n\thlist_for_each_entry(rmap_item, &stable_node->hlist, hlist) {\n\t\tstruct anon_vma *anon_vma = rmap_item->anon_vma;\n\t\tstruct anon_vma_chain *vmac;\n\t\tstruct vm_area_struct *vma;\n\n\t\tcond_resched();\n\t\tanon_vma_lock_read(anon_vma);\n\t\tanon_vma_interval_tree_foreach(vmac, &anon_vma->rb_root,\n\t\t\t\t\t       0, ULONG_MAX) {\n\t\t\tunsigned long addr;\n\n\t\t\tcond_resched();\n\t\t\tvma = vmac->vma;\n\n\t\t\t/* Ignore the stable/unstable/sqnr flags */\n\t\t\taddr = rmap_item->address & ~KSM_FLAG_MASK;\n\n\t\t\tif (addr < vma->vm_start || addr >= vma->vm_end)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Initially we examine only the vma which covers this\n\t\t\t * rmap_item; but later, if there is still work to do,\n\t\t\t * we examine covering vmas in other mms: in case they\n\t\t\t * were forked from the original since ksmd passed.\n\t\t\t */\n\t\t\tif ((rmap_item->mm == vma->vm_mm) == search_new_forks)\n\t\t\t\tcontinue;\n\n\t\t\tif (rwc->invalid_vma && rwc->invalid_vma(vma, rwc->arg))\n\t\t\t\tcontinue;\n\n\t\t\tif (!rwc->rmap_one(page, vma, addr, rwc->arg)) {\n\t\t\t\tanon_vma_unlock_read(anon_vma);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (rwc->done && rwc->done(page)) {\n\t\t\t\tanon_vma_unlock_read(anon_vma);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tanon_vma_unlock_read(anon_vma);\n\t}\n\tif (!search_new_forks++)\n\t\tgoto again;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/numa.h>",
            "#include <linux/oom.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/ksm.h>",
            "#include <linux/swap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memory.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/jhash.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rmap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mman.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define KSM_FLAG_MASK\t(SEQNR_MASK|UNSTABLE_FLAG|STABLE_FLAG)"
          ],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/numa.h>\n#include <linux/oom.h>\n#include <linux/freezer.h>\n#include <linux/hashtable.h>\n#include <linux/ksm.h>\n#include <linux/swap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memory.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/jhash.h>\n#include <linux/spinlock.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mman.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n\n#define KSM_FLAG_MASK\t(SEQNR_MASK|UNSTABLE_FLAG|STABLE_FLAG)\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nvoid rmap_walk_ksm(struct page *page, struct rmap_walk_control *rwc)\n{\n\tstruct stable_node *stable_node;\n\tstruct rmap_item *rmap_item;\n\tint search_new_forks = 0;\n\n\tVM_BUG_ON_PAGE(!PageKsm(page), page);\n\n\t/*\n\t * Rely on the page lock to protect against concurrent modifications\n\t * to that page's node of the stable tree.\n\t */\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tstable_node = page_stable_node(page);\n\tif (!stable_node)\n\t\treturn;\nagain:\n\thlist_for_each_entry(rmap_item, &stable_node->hlist, hlist) {\n\t\tstruct anon_vma *anon_vma = rmap_item->anon_vma;\n\t\tstruct anon_vma_chain *vmac;\n\t\tstruct vm_area_struct *vma;\n\n\t\tcond_resched();\n\t\tanon_vma_lock_read(anon_vma);\n\t\tanon_vma_interval_tree_foreach(vmac, &anon_vma->rb_root,\n\t\t\t\t\t       0, ULONG_MAX) {\n\t\t\tunsigned long addr;\n\n\t\t\tcond_resched();\n\t\t\tvma = vmac->vma;\n\n\t\t\t/* Ignore the stable/unstable/sqnr flags */\n\t\t\taddr = rmap_item->address & ~KSM_FLAG_MASK;\n\n\t\t\tif (addr < vma->vm_start || addr >= vma->vm_end)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Initially we examine only the vma which covers this\n\t\t\t * rmap_item; but later, if there is still work to do,\n\t\t\t * we examine covering vmas in other mms: in case they\n\t\t\t * were forked from the original since ksmd passed.\n\t\t\t */\n\t\t\tif ((rmap_item->mm == vma->vm_mm) == search_new_forks)\n\t\t\t\tcontinue;\n\n\t\t\tif (rwc->invalid_vma && rwc->invalid_vma(vma, rwc->arg))\n\t\t\t\tcontinue;\n\n\t\t\tif (!rwc->rmap_one(page, vma, addr, rwc->arg)) {\n\t\t\t\tanon_vma_unlock_read(anon_vma);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (rwc->done && rwc->done(page)) {\n\t\t\t\tanon_vma_unlock_read(anon_vma);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tanon_vma_unlock_read(anon_vma);\n\t}\n\tif (!search_new_forks++)\n\t\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageKsm",
          "args": [
            "page"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_rmapping",
          "args": [
            "page"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "page_rmapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "460-464",
          "snippet": "void *page_rmapping(struct page *page)\n{\n\tpage = compound_head(page);\n\treturn __page_rmapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid *page_rmapping(struct page *page)\n{\n\tpage = compound_head(page);\n\treturn __page_rmapping(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_mapped",
          "args": [
            "page"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "470-486",
          "snippet": "bool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nbool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_ext.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/kobject.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n\nstatic void page_idle_clear_pte_refs(struct page *page)\n{\n\t/*\n\t * Since rwc.arg is unused, rwc is effectively immutable, so we\n\t * can make it static const to save some cycles and stack.\n\t */\n\tstatic const struct rmap_walk_control rwc = {\n\t\t.rmap_one = page_idle_clear_pte_refs_one,\n\t\t.anon_lock = page_lock_anon_vma_read,\n\t};\n\tbool need_lock;\n\n\tif (!page_mapped(page) ||\n\t    !page_rmapping(page))\n\t\treturn;\n\n\tneed_lock = !PageAnon(page) || PageKsm(page);\n\tif (need_lock && !trylock_page(page))\n\t\treturn;\n\n\trmap_walk(page, (struct rmap_walk_control *)&rwc);\n\n\tif (need_lock)\n\t\tunlock_page(page);\n}"
  },
  {
    "function_name": "page_idle_clear_pte_refs_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_idle.c",
    "lines": "54-93",
    "snippet": "static bool page_idle_clear_pte_refs_one(struct page *page,\n\t\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\t\tunsigned long addr, void *arg)\n{\n\tstruct page_vma_mapped_walk pvmw = {\n\t\t.page = page,\n\t\t.vma = vma,\n\t\t.address = addr,\n\t};\n\tbool referenced = false;\n\n\twhile (page_vma_mapped_walk(&pvmw)) {\n\t\taddr = pvmw.address;\n\t\tif (pvmw.pte) {\n\t\t\t/*\n\t\t\t * For PTE-mapped THP, one sub page is referenced,\n\t\t\t * the whole THP is referenced.\n\t\t\t */\n\t\t\tif (ptep_clear_young_notify(vma, addr, pvmw.pte))\n\t\t\t\treferenced = true;\n\t\t} else if (IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE)) {\n\t\t\tif (pmdp_clear_young_notify(vma, addr, pvmw.pmd))\n\t\t\t\treferenced = true;\n\t\t} else {\n\t\t\t/* unexpected pmd-mapped page? */\n\t\t\tWARN_ON_ONCE(1);\n\t\t}\n\t}\n\n\tif (referenced) {\n\t\tclear_page_idle(page);\n\t\t/*\n\t\t * We cleared the referenced bit in a mapping to this page. To\n\t\t * avoid interference with page reclaim, mark it young so that\n\t\t * page_referenced() will return > 0.\n\t\t */\n\t\tset_page_young(page);\n\t}\n\treturn true;\n}",
    "includes": [
      "#include <linux/page_idle.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/kobject.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_page_young",
          "args": [
            "page"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_page_idle",
          "args": [
            "page"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmdp_clear_young_notify",
          "args": [
            "vma",
            "addr",
            "pvmw.pmd"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_TRANSPARENT_HUGEPAGE"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptep_clear_young_notify",
          "args": [
            "vma",
            "addr",
            "pvmw.pte"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_vma_mapped_walk",
          "args": [
            "&pvmw"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "page_vma_mapped_walk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_vma_mapped.c",
          "lines": "138-247",
          "snippet": "bool page_vma_mapped_walk(struct page_vma_mapped_walk *pvmw)\n{\n\tstruct mm_struct *mm = pvmw->vma->vm_mm;\n\tstruct page *page = pvmw->page;\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t pmde;\n\n\t/* The only possible pmd mapping has been handled on last iteration */\n\tif (pvmw->pmd && !pvmw->pte)\n\t\treturn not_found(pvmw);\n\n\tif (pvmw->pte)\n\t\tgoto next_pte;\n\n\tif (unlikely(PageHuge(pvmw->page))) {\n\t\t/* when pud is not present, pte will be NULL */\n\t\tpvmw->pte = huge_pte_offset(mm, pvmw->address,\n\t\t\t\t\t    PAGE_SIZE << compound_order(page));\n\t\tif (!pvmw->pte)\n\t\t\treturn false;\n\n\t\tpvmw->ptl = huge_pte_lockptr(page_hstate(page), mm, pvmw->pte);\n\t\tspin_lock(pvmw->ptl);\n\t\tif (!check_pte(pvmw))\n\t\t\treturn not_found(pvmw);\n\t\treturn true;\n\t}\nrestart:\n\tpgd = pgd_offset(mm, pvmw->address);\n\tif (!pgd_present(*pgd))\n\t\treturn false;\n\tp4d = p4d_offset(pgd, pvmw->address);\n\tif (!p4d_present(*p4d))\n\t\treturn false;\n\tpud = pud_offset(p4d, pvmw->address);\n\tif (!pud_present(*pud))\n\t\treturn false;\n\tpvmw->pmd = pmd_offset(pud, pvmw->address);\n\t/*\n\t * Make sure the pmd value isn't cached in a register by the\n\t * compiler and used as a stale value after we've observed a\n\t * subsequent update.\n\t */\n\tpmde = READ_ONCE(*pvmw->pmd);\n\tif (pmd_trans_huge(pmde) || is_pmd_migration_entry(pmde)) {\n\t\tpvmw->ptl = pmd_lock(mm, pvmw->pmd);\n\t\tif (likely(pmd_trans_huge(*pvmw->pmd))) {\n\t\t\tif (pvmw->flags & PVMW_MIGRATION)\n\t\t\t\treturn not_found(pvmw);\n\t\t\tif (pmd_page(*pvmw->pmd) != page)\n\t\t\t\treturn not_found(pvmw);\n\t\t\treturn true;\n\t\t} else if (!pmd_present(*pvmw->pmd)) {\n\t\t\tif (thp_migration_supported()) {\n\t\t\t\tif (!(pvmw->flags & PVMW_MIGRATION))\n\t\t\t\t\treturn not_found(pvmw);\n\t\t\t\tif (is_migration_entry(pmd_to_swp_entry(*pvmw->pmd))) {\n\t\t\t\t\tswp_entry_t entry = pmd_to_swp_entry(*pvmw->pmd);\n\n\t\t\t\t\tif (migration_entry_to_page(entry) != page)\n\t\t\t\t\t\treturn not_found(pvmw);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn not_found(pvmw);\n\t\t} else {\n\t\t\t/* THP pmd was split under us: handle on pte level */\n\t\t\tspin_unlock(pvmw->ptl);\n\t\t\tpvmw->ptl = NULL;\n\t\t}\n\t} else if (!pmd_present(pmde)) {\n\t\treturn false;\n\t}\n\tif (!map_pte(pvmw))\n\t\tgoto next_pte;\n\twhile (1) {\n\t\tif (check_pte(pvmw))\n\t\t\treturn true;\nnext_pte:\n\t\t/* Seek to next pte only makes sense for THP */\n\t\tif (!PageTransHuge(pvmw->page) || PageHuge(pvmw->page))\n\t\t\treturn not_found(pvmw);\n\t\tdo {\n\t\t\tpvmw->address += PAGE_SIZE;\n\t\t\tif (pvmw->address >= pvmw->vma->vm_end ||\n\t\t\t    pvmw->address >=\n\t\t\t\t\t__vma_address(pvmw->page, pvmw->vma) +\n\t\t\t\t\thpage_nr_pages(pvmw->page) * PAGE_SIZE)\n\t\t\t\treturn not_found(pvmw);\n\t\t\t/* Did we cross page table boundary? */\n\t\t\tif (pvmw->address % PMD_SIZE == 0) {\n\t\t\t\tpte_unmap(pvmw->pte);\n\t\t\t\tif (pvmw->ptl) {\n\t\t\t\t\tspin_unlock(pvmw->ptl);\n\t\t\t\t\tpvmw->ptl = NULL;\n\t\t\t\t}\n\t\t\t\tgoto restart;\n\t\t\t} else {\n\t\t\t\tpvmw->pte++;\n\t\t\t}\n\t\t} while (pte_none(*pvmw->pte));\n\n\t\tif (!pvmw->ptl) {\n\t\t\tpvmw->ptl = pte_lockptr(mm, pvmw->pmd);\n\t\t\tspin_lock(pvmw->ptl);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/hugetlb.h>\n#include <linux/rmap.h>\n#include <linux/mm.h>\n\nbool page_vma_mapped_walk(struct page_vma_mapped_walk *pvmw)\n{\n\tstruct mm_struct *mm = pvmw->vma->vm_mm;\n\tstruct page *page = pvmw->page;\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t pmde;\n\n\t/* The only possible pmd mapping has been handled on last iteration */\n\tif (pvmw->pmd && !pvmw->pte)\n\t\treturn not_found(pvmw);\n\n\tif (pvmw->pte)\n\t\tgoto next_pte;\n\n\tif (unlikely(PageHuge(pvmw->page))) {\n\t\t/* when pud is not present, pte will be NULL */\n\t\tpvmw->pte = huge_pte_offset(mm, pvmw->address,\n\t\t\t\t\t    PAGE_SIZE << compound_order(page));\n\t\tif (!pvmw->pte)\n\t\t\treturn false;\n\n\t\tpvmw->ptl = huge_pte_lockptr(page_hstate(page), mm, pvmw->pte);\n\t\tspin_lock(pvmw->ptl);\n\t\tif (!check_pte(pvmw))\n\t\t\treturn not_found(pvmw);\n\t\treturn true;\n\t}\nrestart:\n\tpgd = pgd_offset(mm, pvmw->address);\n\tif (!pgd_present(*pgd))\n\t\treturn false;\n\tp4d = p4d_offset(pgd, pvmw->address);\n\tif (!p4d_present(*p4d))\n\t\treturn false;\n\tpud = pud_offset(p4d, pvmw->address);\n\tif (!pud_present(*pud))\n\t\treturn false;\n\tpvmw->pmd = pmd_offset(pud, pvmw->address);\n\t/*\n\t * Make sure the pmd value isn't cached in a register by the\n\t * compiler and used as a stale value after we've observed a\n\t * subsequent update.\n\t */\n\tpmde = READ_ONCE(*pvmw->pmd);\n\tif (pmd_trans_huge(pmde) || is_pmd_migration_entry(pmde)) {\n\t\tpvmw->ptl = pmd_lock(mm, pvmw->pmd);\n\t\tif (likely(pmd_trans_huge(*pvmw->pmd))) {\n\t\t\tif (pvmw->flags & PVMW_MIGRATION)\n\t\t\t\treturn not_found(pvmw);\n\t\t\tif (pmd_page(*pvmw->pmd) != page)\n\t\t\t\treturn not_found(pvmw);\n\t\t\treturn true;\n\t\t} else if (!pmd_present(*pvmw->pmd)) {\n\t\t\tif (thp_migration_supported()) {\n\t\t\t\tif (!(pvmw->flags & PVMW_MIGRATION))\n\t\t\t\t\treturn not_found(pvmw);\n\t\t\t\tif (is_migration_entry(pmd_to_swp_entry(*pvmw->pmd))) {\n\t\t\t\t\tswp_entry_t entry = pmd_to_swp_entry(*pvmw->pmd);\n\n\t\t\t\t\tif (migration_entry_to_page(entry) != page)\n\t\t\t\t\t\treturn not_found(pvmw);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn not_found(pvmw);\n\t\t} else {\n\t\t\t/* THP pmd was split under us: handle on pte level */\n\t\t\tspin_unlock(pvmw->ptl);\n\t\t\tpvmw->ptl = NULL;\n\t\t}\n\t} else if (!pmd_present(pmde)) {\n\t\treturn false;\n\t}\n\tif (!map_pte(pvmw))\n\t\tgoto next_pte;\n\twhile (1) {\n\t\tif (check_pte(pvmw))\n\t\t\treturn true;\nnext_pte:\n\t\t/* Seek to next pte only makes sense for THP */\n\t\tif (!PageTransHuge(pvmw->page) || PageHuge(pvmw->page))\n\t\t\treturn not_found(pvmw);\n\t\tdo {\n\t\t\tpvmw->address += PAGE_SIZE;\n\t\t\tif (pvmw->address >= pvmw->vma->vm_end ||\n\t\t\t    pvmw->address >=\n\t\t\t\t\t__vma_address(pvmw->page, pvmw->vma) +\n\t\t\t\t\thpage_nr_pages(pvmw->page) * PAGE_SIZE)\n\t\t\t\treturn not_found(pvmw);\n\t\t\t/* Did we cross page table boundary? */\n\t\t\tif (pvmw->address % PMD_SIZE == 0) {\n\t\t\t\tpte_unmap(pvmw->pte);\n\t\t\t\tif (pvmw->ptl) {\n\t\t\t\t\tspin_unlock(pvmw->ptl);\n\t\t\t\t\tpvmw->ptl = NULL;\n\t\t\t\t}\n\t\t\t\tgoto restart;\n\t\t\t} else {\n\t\t\t\tpvmw->pte++;\n\t\t\t}\n\t\t} while (pte_none(*pvmw->pte));\n\n\t\tif (!pvmw->ptl) {\n\t\t\tpvmw->ptl = pte_lockptr(mm, pvmw->pmd);\n\t\t\tspin_lock(pvmw->ptl);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_ext.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/kobject.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n\nstatic bool page_idle_clear_pte_refs_one(struct page *page,\n\t\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\t\tunsigned long addr, void *arg)\n{\n\tstruct page_vma_mapped_walk pvmw = {\n\t\t.page = page,\n\t\t.vma = vma,\n\t\t.address = addr,\n\t};\n\tbool referenced = false;\n\n\twhile (page_vma_mapped_walk(&pvmw)) {\n\t\taddr = pvmw.address;\n\t\tif (pvmw.pte) {\n\t\t\t/*\n\t\t\t * For PTE-mapped THP, one sub page is referenced,\n\t\t\t * the whole THP is referenced.\n\t\t\t */\n\t\t\tif (ptep_clear_young_notify(vma, addr, pvmw.pte))\n\t\t\t\treferenced = true;\n\t\t} else if (IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE)) {\n\t\t\tif (pmdp_clear_young_notify(vma, addr, pvmw.pmd))\n\t\t\t\treferenced = true;\n\t\t} else {\n\t\t\t/* unexpected pmd-mapped page? */\n\t\t\tWARN_ON_ONCE(1);\n\t\t}\n\t}\n\n\tif (referenced) {\n\t\tclear_page_idle(page);\n\t\t/*\n\t\t * We cleared the referenced bit in a mapping to this page. To\n\t\t * avoid interference with page reclaim, mark it young so that\n\t\t * page_referenced() will return > 0.\n\t\t */\n\t\tset_page_young(page);\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "page_idle_get_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_idle.c",
    "lines": "31-52",
    "snippet": "static struct page *page_idle_get_page(unsigned long pfn)\n{\n\tstruct page *page;\n\tstruct zone *zone;\n\n\tif (!pfn_valid(pfn))\n\t\treturn NULL;\n\n\tpage = pfn_to_page(pfn);\n\tif (!page || !PageLRU(page) ||\n\t    !get_page_unless_zero(page))\n\t\treturn NULL;\n\n\tzone = page_zone(page);\n\tspin_lock_irq(zone_lru_lock(zone));\n\tif (unlikely(!PageLRU(page))) {\n\t\tput_page(page);\n\t\tpage = NULL;\n\t}\n\tspin_unlock_irq(zone_lru_lock(zone));\n\treturn page;\n}",
    "includes": [
      "#include <linux/page_idle.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/rmap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/kobject.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/memblock.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "zone_lru_lock(zone)"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_lru_lock",
          "args": [
            "zone"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!PageLRU(page)"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "zone_lru_lock(zone)"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_lru_lock",
          "args": [
            "zone"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page_unless_zero",
          "args": [
            "page"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "pfn"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_ext.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rmap.h>\n#include <linux/pagemap.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/kobject.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n\nstatic struct page *page_idle_get_page(unsigned long pfn)\n{\n\tstruct page *page;\n\tstruct zone *zone;\n\n\tif (!pfn_valid(pfn))\n\t\treturn NULL;\n\n\tpage = pfn_to_page(pfn);\n\tif (!page || !PageLRU(page) ||\n\t    !get_page_unless_zero(page))\n\t\treturn NULL;\n\n\tzone = page_zone(page);\n\tspin_lock_irq(zone_lru_lock(zone));\n\tif (unlikely(!PageLRU(page))) {\n\t\tput_page(page);\n\t\tpage = NULL;\n\t}\n\tspin_unlock_irq(zone_lru_lock(zone));\n\treturn page;\n}"
  }
]