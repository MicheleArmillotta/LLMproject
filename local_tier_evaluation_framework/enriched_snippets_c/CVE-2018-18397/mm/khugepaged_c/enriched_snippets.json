[
  {
    "function_name": "start_stop_khugepaged",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "1886-1915",
    "snippet": "int start_stop_khugepaged(void)\n{\n\tstatic struct task_struct *khugepaged_thread __read_mostly;\n\tstatic DEFINE_MUTEX(khugepaged_mutex);\n\tint err = 0;\n\n\tmutex_lock(&khugepaged_mutex);\n\tif (khugepaged_enabled()) {\n\t\tif (!khugepaged_thread)\n\t\t\tkhugepaged_thread = kthread_run(khugepaged, NULL,\n\t\t\t\t\t\t\t\"khugepaged\");\n\t\tif (IS_ERR(khugepaged_thread)) {\n\t\t\tpr_err(\"khugepaged: kthread_run(khugepaged) failed\\n\");\n\t\t\terr = PTR_ERR(khugepaged_thread);\n\t\t\tkhugepaged_thread = NULL;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (!list_empty(&khugepaged_scan.mm_head))\n\t\t\twake_up_interruptible(&khugepaged_wait);\n\n\t\tset_recommended_min_free_kbytes();\n\t} else if (khugepaged_thread) {\n\t\tkthread_stop(khugepaged_thread);\n\t\tkhugepaged_thread = NULL;\n\t}\nfail:\n\tmutex_unlock(&khugepaged_mutex);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_WAIT_QUEUE_HEAD(khugepaged_wait);",
      "static struct khugepaged_scan khugepaged_scan = {\n\t.mm_head = LIST_HEAD_INIT(khugepaged_scan.mm_head),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&khugepaged_mutex"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "khugepaged_thread"
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_recommended_min_free_kbytes",
          "args": [],
          "line": 1907
        },
        "resolved": true,
        "details": {
          "function_name": "set_recommended_min_free_kbytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "1842-1884",
          "snippet": "static void set_recommended_min_free_kbytes(void)\n{\n\tstruct zone *zone;\n\tint nr_zones = 0;\n\tunsigned long recommended_min;\n\n\tfor_each_populated_zone(zone) {\n\t\t/*\n\t\t * We don't need to worry about fragmentation of\n\t\t * ZONE_MOVABLE since it only has movable pages.\n\t\t */\n\t\tif (zone_idx(zone) > gfp_zone(GFP_USER))\n\t\t\tcontinue;\n\n\t\tnr_zones++;\n\t}\n\n\t/* Ensure 2 pageblocks are free to assist fragmentation avoidance */\n\trecommended_min = pageblock_nr_pages * nr_zones * 2;\n\n\t/*\n\t * Make sure that on average at least two pageblocks are almost free\n\t * of another type, one for a migratetype to fall back to and a\n\t * second to avoid subsequent fallbacks of other types There are 3\n\t * MIGRATE_TYPES we care about.\n\t */\n\trecommended_min += pageblock_nr_pages * nr_zones *\n\t\t\t   MIGRATE_PCPTYPES * MIGRATE_PCPTYPES;\n\n\t/* don't ever allow to reserve more than 5% of the lowmem */\n\trecommended_min = min(recommended_min,\n\t\t\t      (unsigned long) nr_free_buffer_pages() / 20);\n\trecommended_min <<= (PAGE_SHIFT-10);\n\n\tif (recommended_min > min_free_kbytes) {\n\t\tif (user_min_free_kbytes >= 0)\n\t\t\tpr_info(\"raising min_free_kbytes from %d to %lu to help transparent hugepage allocations\\n\",\n\t\t\t\tmin_free_kbytes, recommended_min);\n\n\t\tmin_free_kbytes = recommended_min;\n\t}\n\tsetup_per_zone_wmarks();\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void set_recommended_min_free_kbytes(void)\n{\n\tstruct zone *zone;\n\tint nr_zones = 0;\n\tunsigned long recommended_min;\n\n\tfor_each_populated_zone(zone) {\n\t\t/*\n\t\t * We don't need to worry about fragmentation of\n\t\t * ZONE_MOVABLE since it only has movable pages.\n\t\t */\n\t\tif (zone_idx(zone) > gfp_zone(GFP_USER))\n\t\t\tcontinue;\n\n\t\tnr_zones++;\n\t}\n\n\t/* Ensure 2 pageblocks are free to assist fragmentation avoidance */\n\trecommended_min = pageblock_nr_pages * nr_zones * 2;\n\n\t/*\n\t * Make sure that on average at least two pageblocks are almost free\n\t * of another type, one for a migratetype to fall back to and a\n\t * second to avoid subsequent fallbacks of other types There are 3\n\t * MIGRATE_TYPES we care about.\n\t */\n\trecommended_min += pageblock_nr_pages * nr_zones *\n\t\t\t   MIGRATE_PCPTYPES * MIGRATE_PCPTYPES;\n\n\t/* don't ever allow to reserve more than 5% of the lowmem */\n\trecommended_min = min(recommended_min,\n\t\t\t      (unsigned long) nr_free_buffer_pages() / 20);\n\trecommended_min <<= (PAGE_SHIFT-10);\n\n\tif (recommended_min > min_free_kbytes) {\n\t\tif (user_min_free_kbytes >= 0)\n\t\t\tpr_info(\"raising min_free_kbytes from %d to %lu to help transparent hugepage allocations\\n\",\n\t\t\t\tmin_free_kbytes, recommended_min);\n\n\t\tmin_free_kbytes = recommended_min;\n\t}\n\tsetup_per_zone_wmarks();\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&khugepaged_wait"
          ],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&khugepaged_scan.mm_head"
          ],
          "line": 1904
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "khugepaged_thread"
          ],
          "line": 1899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"khugepaged: kthread_run(khugepaged) failed\\n\""
          ],
          "line": 1898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "khugepaged_thread"
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "khugepaged",
            "NULL",
            "\"khugepaged\""
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "khugepaged_enabled",
          "args": [],
          "line": 1893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&khugepaged_mutex"
          ],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(khugepaged_wait);\nstatic struct khugepaged_scan khugepaged_scan = {\n\t.mm_head = LIST_HEAD_INIT(khugepaged_scan.mm_head),\n};\n\nint start_stop_khugepaged(void)\n{\n\tstatic struct task_struct *khugepaged_thread __read_mostly;\n\tstatic DEFINE_MUTEX(khugepaged_mutex);\n\tint err = 0;\n\n\tmutex_lock(&khugepaged_mutex);\n\tif (khugepaged_enabled()) {\n\t\tif (!khugepaged_thread)\n\t\t\tkhugepaged_thread = kthread_run(khugepaged, NULL,\n\t\t\t\t\t\t\t\"khugepaged\");\n\t\tif (IS_ERR(khugepaged_thread)) {\n\t\t\tpr_err(\"khugepaged: kthread_run(khugepaged) failed\\n\");\n\t\t\terr = PTR_ERR(khugepaged_thread);\n\t\t\tkhugepaged_thread = NULL;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (!list_empty(&khugepaged_scan.mm_head))\n\t\t\twake_up_interruptible(&khugepaged_wait);\n\n\t\tset_recommended_min_free_kbytes();\n\t} else if (khugepaged_thread) {\n\t\tkthread_stop(khugepaged_thread);\n\t\tkhugepaged_thread = NULL;\n\t}\nfail:\n\tmutex_unlock(&khugepaged_mutex);\n\treturn err;\n}"
  },
  {
    "function_name": "set_recommended_min_free_kbytes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "1842-1884",
    "snippet": "static void set_recommended_min_free_kbytes(void)\n{\n\tstruct zone *zone;\n\tint nr_zones = 0;\n\tunsigned long recommended_min;\n\n\tfor_each_populated_zone(zone) {\n\t\t/*\n\t\t * We don't need to worry about fragmentation of\n\t\t * ZONE_MOVABLE since it only has movable pages.\n\t\t */\n\t\tif (zone_idx(zone) > gfp_zone(GFP_USER))\n\t\t\tcontinue;\n\n\t\tnr_zones++;\n\t}\n\n\t/* Ensure 2 pageblocks are free to assist fragmentation avoidance */\n\trecommended_min = pageblock_nr_pages * nr_zones * 2;\n\n\t/*\n\t * Make sure that on average at least two pageblocks are almost free\n\t * of another type, one for a migratetype to fall back to and a\n\t * second to avoid subsequent fallbacks of other types There are 3\n\t * MIGRATE_TYPES we care about.\n\t */\n\trecommended_min += pageblock_nr_pages * nr_zones *\n\t\t\t   MIGRATE_PCPTYPES * MIGRATE_PCPTYPES;\n\n\t/* don't ever allow to reserve more than 5% of the lowmem */\n\trecommended_min = min(recommended_min,\n\t\t\t      (unsigned long) nr_free_buffer_pages() / 20);\n\trecommended_min <<= (PAGE_SHIFT-10);\n\n\tif (recommended_min > min_free_kbytes) {\n\t\tif (user_min_free_kbytes >= 0)\n\t\t\tpr_info(\"raising min_free_kbytes from %d to %lu to help transparent hugepage allocations\\n\",\n\t\t\t\tmin_free_kbytes, recommended_min);\n\n\t\tmin_free_kbytes = recommended_min;\n\t}\n\tsetup_per_zone_wmarks();\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setup_per_zone_wmarks",
          "args": [],
          "line": 1883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"raising min_free_kbytes from %d to %lu to help transparent hugepage allocations\\n\"",
            "min_free_kbytes",
            "recommended_min"
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "recommended_min",
            "(unsigned long) nr_free_buffer_pages() / 20"
          ],
          "line": 1872
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nr_free_buffer_pages",
          "args": [],
          "line": 1873
        },
        "resolved": true,
        "details": {
          "function_name": "nr_free_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4678-4681",
          "snippet": "unsigned long nr_free_buffer_pages(void)\n{\n\treturn nr_free_zone_pages(gfp_zone(GFP_USER));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nunsigned long nr_free_buffer_pages(void)\n{\n\treturn nr_free_zone_pages(gfp_zone(GFP_USER));\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfp_zone",
          "args": [
            "GFP_USER"
          ],
          "line": 1853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_idx",
          "args": [
            "zone"
          ],
          "line": 1853
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void set_recommended_min_free_kbytes(void)\n{\n\tstruct zone *zone;\n\tint nr_zones = 0;\n\tunsigned long recommended_min;\n\n\tfor_each_populated_zone(zone) {\n\t\t/*\n\t\t * We don't need to worry about fragmentation of\n\t\t * ZONE_MOVABLE since it only has movable pages.\n\t\t */\n\t\tif (zone_idx(zone) > gfp_zone(GFP_USER))\n\t\t\tcontinue;\n\n\t\tnr_zones++;\n\t}\n\n\t/* Ensure 2 pageblocks are free to assist fragmentation avoidance */\n\trecommended_min = pageblock_nr_pages * nr_zones * 2;\n\n\t/*\n\t * Make sure that on average at least two pageblocks are almost free\n\t * of another type, one for a migratetype to fall back to and a\n\t * second to avoid subsequent fallbacks of other types There are 3\n\t * MIGRATE_TYPES we care about.\n\t */\n\trecommended_min += pageblock_nr_pages * nr_zones *\n\t\t\t   MIGRATE_PCPTYPES * MIGRATE_PCPTYPES;\n\n\t/* don't ever allow to reserve more than 5% of the lowmem */\n\trecommended_min = min(recommended_min,\n\t\t\t      (unsigned long) nr_free_buffer_pages() / 20);\n\trecommended_min <<= (PAGE_SHIFT-10);\n\n\tif (recommended_min > min_free_kbytes) {\n\t\tif (user_min_free_kbytes >= 0)\n\t\t\tpr_info(\"raising min_free_kbytes from %d to %lu to help transparent hugepage allocations\\n\",\n\t\t\t\tmin_free_kbytes, recommended_min);\n\n\t\tmin_free_kbytes = recommended_min;\n\t}\n\tsetup_per_zone_wmarks();\n}"
  },
  {
    "function_name": "khugepaged",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "1821-1840",
    "snippet": "static int khugepaged(void *none)\n{\n\tstruct mm_slot *mm_slot;\n\n\tset_freezable();\n\tset_user_nice(current, MAX_NICE);\n\n\twhile (!kthread_should_stop()) {\n\t\tkhugepaged_do_scan();\n\t\tkhugepaged_wait_work();\n\t}\n\n\tspin_lock(&khugepaged_mm_lock);\n\tmm_slot = khugepaged_scan.mm_slot;\n\tkhugepaged_scan.mm_slot = NULL;\n\tif (mm_slot)\n\t\tcollect_mm_slot(mm_slot);\n\tspin_unlock(&khugepaged_mm_lock);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(khugepaged_mm_lock);",
      "static struct khugepaged_scan khugepaged_scan = {\n\t.mm_head = LIST_HEAD_INIT(khugepaged_scan.mm_head),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&khugepaged_mm_lock"
          ],
          "line": 1838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "collect_mm_slot",
          "args": [
            "mm_slot"
          ],
          "line": 1837
        },
        "resolved": true,
        "details": {
          "function_name": "collect_mm_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "1224-1245",
          "snippet": "static void collect_mm_slot(struct mm_slot *mm_slot)\n{\n\tstruct mm_struct *mm = mm_slot->mm;\n\n\tVM_BUG_ON(NR_CPUS != 1 && !spin_is_locked(&khugepaged_mm_lock));\n\n\tif (khugepaged_test_exit(mm)) {\n\t\t/* free mm_slot */\n\t\thash_del(&mm_slot->hash);\n\t\tlist_del(&mm_slot->mm_node);\n\n\t\t/*\n\t\t * Not strictly needed because the mm exited already.\n\t\t *\n\t\t * clear_bit(MMF_VM_HUGEPAGE, &mm->flags);\n\t\t */\n\n\t\t/* khugepaged_mm_lock actually not necessary for the below */\n\t\tfree_mm_slot(mm_slot);\n\t\tmmdrop(mm);\n\t}\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(khugepaged_mm_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_SPINLOCK(khugepaged_mm_lock);\n\nstatic void collect_mm_slot(struct mm_slot *mm_slot)\n{\n\tstruct mm_struct *mm = mm_slot->mm;\n\n\tVM_BUG_ON(NR_CPUS != 1 && !spin_is_locked(&khugepaged_mm_lock));\n\n\tif (khugepaged_test_exit(mm)) {\n\t\t/* free mm_slot */\n\t\thash_del(&mm_slot->hash);\n\t\tlist_del(&mm_slot->mm_node);\n\n\t\t/*\n\t\t * Not strictly needed because the mm exited already.\n\t\t *\n\t\t * clear_bit(MMF_VM_HUGEPAGE, &mm->flags);\n\t\t */\n\n\t\t/* khugepaged_mm_lock actually not necessary for the below */\n\t\tfree_mm_slot(mm_slot);\n\t\tmmdrop(mm);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&khugepaged_mm_lock"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "khugepaged_wait_work",
          "args": [],
          "line": 1830
        },
        "resolved": true,
        "details": {
          "function_name": "khugepaged_wait_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "1801-1819",
          "snippet": "static void khugepaged_wait_work(void)\n{\n\tif (khugepaged_has_work()) {\n\t\tconst unsigned long scan_sleep_jiffies =\n\t\t\tmsecs_to_jiffies(khugepaged_scan_sleep_millisecs);\n\n\t\tif (!scan_sleep_jiffies)\n\t\t\treturn;\n\n\t\tkhugepaged_sleep_expire = jiffies + scan_sleep_jiffies;\n\t\twait_event_freezable_timeout(khugepaged_wait,\n\t\t\t\t\t     khugepaged_should_wakeup(),\n\t\t\t\t\t     scan_sleep_jiffies);\n\t\treturn;\n\t}\n\n\tif (khugepaged_enabled())\n\t\twait_event_freezable(khugepaged_wait, khugepaged_wait_event());\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int khugepaged_scan_sleep_millisecs",
            "static unsigned long khugepaged_sleep_expire;",
            "static DECLARE_WAIT_QUEUE_HEAD(khugepaged_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic unsigned int khugepaged_scan_sleep_millisecs;\nstatic unsigned long khugepaged_sleep_expire;\nstatic DECLARE_WAIT_QUEUE_HEAD(khugepaged_wait);\n\nstatic void khugepaged_wait_work(void)\n{\n\tif (khugepaged_has_work()) {\n\t\tconst unsigned long scan_sleep_jiffies =\n\t\t\tmsecs_to_jiffies(khugepaged_scan_sleep_millisecs);\n\n\t\tif (!scan_sleep_jiffies)\n\t\t\treturn;\n\n\t\tkhugepaged_sleep_expire = jiffies + scan_sleep_jiffies;\n\t\twait_event_freezable_timeout(khugepaged_wait,\n\t\t\t\t\t     khugepaged_should_wakeup(),\n\t\t\t\t\t     scan_sleep_jiffies);\n\t\treturn;\n\t}\n\n\tif (khugepaged_enabled())\n\t\twait_event_freezable(khugepaged_wait, khugepaged_wait_event());\n}"
        }
      },
      {
        "call_info": {
          "callee": "khugepaged_do_scan",
          "args": [],
          "line": 1829
        },
        "resolved": true,
        "details": {
          "function_name": "khugepaged_do_scan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "1761-1793",
          "snippet": "static void khugepaged_do_scan(void)\n{\n\tstruct page *hpage = NULL;\n\tunsigned int progress = 0, pass_through_head = 0;\n\tunsigned int pages = khugepaged_pages_to_scan;\n\tbool wait = true;\n\n\tbarrier(); /* write khugepaged_pages_to_scan to local stack */\n\n\twhile (progress < pages) {\n\t\tif (!khugepaged_prealloc_page(&hpage, &wait))\n\t\t\tbreak;\n\n\t\tcond_resched();\n\n\t\tif (unlikely(kthread_should_stop() || try_to_freeze()))\n\t\t\tbreak;\n\n\t\tspin_lock(&khugepaged_mm_lock);\n\t\tif (!khugepaged_scan.mm_slot)\n\t\t\tpass_through_head++;\n\t\tif (khugepaged_has_work() &&\n\t\t    pass_through_head < 2)\n\t\t\tprogress += khugepaged_scan_mm_slot(pages - progress,\n\t\t\t\t\t\t\t    &hpage);\n\t\telse\n\t\t\tprogress = pages;\n\t\tspin_unlock(&khugepaged_mm_lock);\n\t}\n\n\tif (!IS_ERR_OR_NULL(hpage))\n\t\tput_page(hpage);\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int khugepaged_pages_to_scan",
            "static DEFINE_SPINLOCK(khugepaged_mm_lock);",
            "static struct khugepaged_scan khugepaged_scan = {\n\t.mm_head = LIST_HEAD_INIT(khugepaged_scan.mm_head),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic unsigned int khugepaged_pages_to_scan;\nstatic DEFINE_SPINLOCK(khugepaged_mm_lock);\nstatic struct khugepaged_scan khugepaged_scan = {\n\t.mm_head = LIST_HEAD_INIT(khugepaged_scan.mm_head),\n};\n\nstatic void khugepaged_do_scan(void)\n{\n\tstruct page *hpage = NULL;\n\tunsigned int progress = 0, pass_through_head = 0;\n\tunsigned int pages = khugepaged_pages_to_scan;\n\tbool wait = true;\n\n\tbarrier(); /* write khugepaged_pages_to_scan to local stack */\n\n\twhile (progress < pages) {\n\t\tif (!khugepaged_prealloc_page(&hpage, &wait))\n\t\t\tbreak;\n\n\t\tcond_resched();\n\n\t\tif (unlikely(kthread_should_stop() || try_to_freeze()))\n\t\t\tbreak;\n\n\t\tspin_lock(&khugepaged_mm_lock);\n\t\tif (!khugepaged_scan.mm_slot)\n\t\t\tpass_through_head++;\n\t\tif (khugepaged_has_work() &&\n\t\t    pass_through_head < 2)\n\t\t\tprogress += khugepaged_scan_mm_slot(pages - progress,\n\t\t\t\t\t\t\t    &hpage);\n\t\telse\n\t\t\tprogress = pages;\n\t\tspin_unlock(&khugepaged_mm_lock);\n\t}\n\n\tif (!IS_ERR_OR_NULL(hpage))\n\t\tput_page(hpage);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_user_nice",
          "args": [
            "current",
            "MAX_NICE"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_freezable",
          "args": [],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_SPINLOCK(khugepaged_mm_lock);\nstatic struct khugepaged_scan khugepaged_scan = {\n\t.mm_head = LIST_HEAD_INIT(khugepaged_scan.mm_head),\n};\n\nstatic int khugepaged(void *none)\n{\n\tstruct mm_slot *mm_slot;\n\n\tset_freezable();\n\tset_user_nice(current, MAX_NICE);\n\n\twhile (!kthread_should_stop()) {\n\t\tkhugepaged_do_scan();\n\t\tkhugepaged_wait_work();\n\t}\n\n\tspin_lock(&khugepaged_mm_lock);\n\tmm_slot = khugepaged_scan.mm_slot;\n\tkhugepaged_scan.mm_slot = NULL;\n\tif (mm_slot)\n\t\tcollect_mm_slot(mm_slot);\n\tspin_unlock(&khugepaged_mm_lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "khugepaged_wait_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "1801-1819",
    "snippet": "static void khugepaged_wait_work(void)\n{\n\tif (khugepaged_has_work()) {\n\t\tconst unsigned long scan_sleep_jiffies =\n\t\t\tmsecs_to_jiffies(khugepaged_scan_sleep_millisecs);\n\n\t\tif (!scan_sleep_jiffies)\n\t\t\treturn;\n\n\t\tkhugepaged_sleep_expire = jiffies + scan_sleep_jiffies;\n\t\twait_event_freezable_timeout(khugepaged_wait,\n\t\t\t\t\t     khugepaged_should_wakeup(),\n\t\t\t\t\t     scan_sleep_jiffies);\n\t\treturn;\n\t}\n\n\tif (khugepaged_enabled())\n\t\twait_event_freezable(khugepaged_wait, khugepaged_wait_event());\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int khugepaged_scan_sleep_millisecs",
      "static unsigned long khugepaged_sleep_expire;",
      "static DECLARE_WAIT_QUEUE_HEAD(khugepaged_wait);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event_freezable",
          "args": [
            "khugepaged_wait",
            "khugepaged_wait_event()"
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "khugepaged_wait_event",
          "args": [],
          "line": 1818
        },
        "resolved": true,
        "details": {
          "function_name": "khugepaged_wait_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "1755-1759",
          "snippet": "static int khugepaged_wait_event(void)\n{\n\treturn !list_empty(&khugepaged_scan.mm_head) ||\n\t\tkthread_should_stop();\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct khugepaged_scan khugepaged_scan = {\n\t.mm_head = LIST_HEAD_INIT(khugepaged_scan.mm_head),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic struct khugepaged_scan khugepaged_scan = {\n\t.mm_head = LIST_HEAD_INIT(khugepaged_scan.mm_head),\n};\n\nstatic int khugepaged_wait_event(void)\n{\n\treturn !list_empty(&khugepaged_scan.mm_head) ||\n\t\tkthread_should_stop();\n}"
        }
      },
      {
        "call_info": {
          "callee": "khugepaged_enabled",
          "args": [],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event_freezable_timeout",
          "args": [
            "khugepaged_wait",
            "khugepaged_should_wakeup()",
            "scan_sleep_jiffies"
          ],
          "line": 1811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "khugepaged_should_wakeup",
          "args": [],
          "line": 1812
        },
        "resolved": true,
        "details": {
          "function_name": "khugepaged_should_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "1795-1799",
          "snippet": "static bool khugepaged_should_wakeup(void)\n{\n\treturn kthread_should_stop() ||\n\t       time_after_eq(jiffies, khugepaged_sleep_expire);\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long khugepaged_sleep_expire;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic unsigned long khugepaged_sleep_expire;\n\nstatic bool khugepaged_should_wakeup(void)\n{\n\treturn kthread_should_stop() ||\n\t       time_after_eq(jiffies, khugepaged_sleep_expire);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "khugepaged_scan_sleep_millisecs"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "khugepaged_has_work",
          "args": [],
          "line": 1803
        },
        "resolved": true,
        "details": {
          "function_name": "khugepaged_has_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "1749-1753",
          "snippet": "static int khugepaged_has_work(void)\n{\n\treturn !list_empty(&khugepaged_scan.mm_head) &&\n\t\tkhugepaged_enabled();\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct khugepaged_scan khugepaged_scan = {\n\t.mm_head = LIST_HEAD_INIT(khugepaged_scan.mm_head),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic struct khugepaged_scan khugepaged_scan = {\n\t.mm_head = LIST_HEAD_INIT(khugepaged_scan.mm_head),\n};\n\nstatic int khugepaged_has_work(void)\n{\n\treturn !list_empty(&khugepaged_scan.mm_head) &&\n\t\tkhugepaged_enabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic unsigned int khugepaged_scan_sleep_millisecs;\nstatic unsigned long khugepaged_sleep_expire;\nstatic DECLARE_WAIT_QUEUE_HEAD(khugepaged_wait);\n\nstatic void khugepaged_wait_work(void)\n{\n\tif (khugepaged_has_work()) {\n\t\tconst unsigned long scan_sleep_jiffies =\n\t\t\tmsecs_to_jiffies(khugepaged_scan_sleep_millisecs);\n\n\t\tif (!scan_sleep_jiffies)\n\t\t\treturn;\n\n\t\tkhugepaged_sleep_expire = jiffies + scan_sleep_jiffies;\n\t\twait_event_freezable_timeout(khugepaged_wait,\n\t\t\t\t\t     khugepaged_should_wakeup(),\n\t\t\t\t\t     scan_sleep_jiffies);\n\t\treturn;\n\t}\n\n\tif (khugepaged_enabled())\n\t\twait_event_freezable(khugepaged_wait, khugepaged_wait_event());\n}"
  },
  {
    "function_name": "khugepaged_should_wakeup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "1795-1799",
    "snippet": "static bool khugepaged_should_wakeup(void)\n{\n\treturn kthread_should_stop() ||\n\t       time_after_eq(jiffies, khugepaged_sleep_expire);\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long khugepaged_sleep_expire;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "time_after_eq",
          "args": [
            "jiffies",
            "khugepaged_sleep_expire"
          ],
          "line": 1798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 1797
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic unsigned long khugepaged_sleep_expire;\n\nstatic bool khugepaged_should_wakeup(void)\n{\n\treturn kthread_should_stop() ||\n\t       time_after_eq(jiffies, khugepaged_sleep_expire);\n}"
  },
  {
    "function_name": "khugepaged_do_scan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "1761-1793",
    "snippet": "static void khugepaged_do_scan(void)\n{\n\tstruct page *hpage = NULL;\n\tunsigned int progress = 0, pass_through_head = 0;\n\tunsigned int pages = khugepaged_pages_to_scan;\n\tbool wait = true;\n\n\tbarrier(); /* write khugepaged_pages_to_scan to local stack */\n\n\twhile (progress < pages) {\n\t\tif (!khugepaged_prealloc_page(&hpage, &wait))\n\t\t\tbreak;\n\n\t\tcond_resched();\n\n\t\tif (unlikely(kthread_should_stop() || try_to_freeze()))\n\t\t\tbreak;\n\n\t\tspin_lock(&khugepaged_mm_lock);\n\t\tif (!khugepaged_scan.mm_slot)\n\t\t\tpass_through_head++;\n\t\tif (khugepaged_has_work() &&\n\t\t    pass_through_head < 2)\n\t\t\tprogress += khugepaged_scan_mm_slot(pages - progress,\n\t\t\t\t\t\t\t    &hpage);\n\t\telse\n\t\t\tprogress = pages;\n\t\tspin_unlock(&khugepaged_mm_lock);\n\t}\n\n\tif (!IS_ERR_OR_NULL(hpage))\n\t\tput_page(hpage);\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int khugepaged_pages_to_scan",
      "static DEFINE_SPINLOCK(khugepaged_mm_lock);",
      "static struct khugepaged_scan khugepaged_scan = {\n\t.mm_head = LIST_HEAD_INIT(khugepaged_scan.mm_head),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "hpage"
          ],
          "line": 1792
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "hpage"
          ],
          "line": 1791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&khugepaged_mm_lock"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "khugepaged_scan_mm_slot",
          "args": [
            "pages - progress",
            "&hpage"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "khugepaged_scan_mm_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "1623-1747",
          "snippet": "static unsigned int khugepaged_scan_mm_slot(unsigned int pages,\n\t\t\t\t\t    struct page **hpage)\n\t__releases(&khugepaged_mm_lock)\n\t__acquires(&khugepaged_mm_lock)\n{\n\tstruct mm_slot *mm_slot;\n\tstruct mm_struct *mm;\n\tstruct vm_area_struct *vma;\n\tint progress = 0;\n\n\tVM_BUG_ON(!pages);\n\tVM_BUG_ON(NR_CPUS != 1 && !spin_is_locked(&khugepaged_mm_lock));\n\n\tif (khugepaged_scan.mm_slot)\n\t\tmm_slot = khugepaged_scan.mm_slot;\n\telse {\n\t\tmm_slot = list_entry(khugepaged_scan.mm_head.next,\n\t\t\t\t     struct mm_slot, mm_node);\n\t\tkhugepaged_scan.address = 0;\n\t\tkhugepaged_scan.mm_slot = mm_slot;\n\t}\n\tspin_unlock(&khugepaged_mm_lock);\n\n\tmm = mm_slot->mm;\n\t/*\n\t * Don't wait for semaphore (to avoid long wait times).  Just move to\n\t * the next mm on the list.\n\t */\n\tvma = NULL;\n\tif (unlikely(!down_read_trylock(&mm->mmap_sem)))\n\t\tgoto breakouterloop_mmap_sem;\n\tif (likely(!khugepaged_test_exit(mm)))\n\t\tvma = find_vma(mm, khugepaged_scan.address);\n\n\tprogress++;\n\tfor (; vma; vma = vma->vm_next) {\n\t\tunsigned long hstart, hend;\n\n\t\tcond_resched();\n\t\tif (unlikely(khugepaged_test_exit(mm))) {\n\t\t\tprogress++;\n\t\t\tbreak;\n\t\t}\n\t\tif (!hugepage_vma_check(vma, vma->vm_flags)) {\nskip:\n\t\t\tprogress++;\n\t\t\tcontinue;\n\t\t}\n\t\thstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;\n\t\thend = vma->vm_end & HPAGE_PMD_MASK;\n\t\tif (hstart >= hend)\n\t\t\tgoto skip;\n\t\tif (khugepaged_scan.address > hend)\n\t\t\tgoto skip;\n\t\tif (khugepaged_scan.address < hstart)\n\t\t\tkhugepaged_scan.address = hstart;\n\t\tVM_BUG_ON(khugepaged_scan.address & ~HPAGE_PMD_MASK);\n\n\t\twhile (khugepaged_scan.address < hend) {\n\t\t\tint ret;\n\t\t\tcond_resched();\n\t\t\tif (unlikely(khugepaged_test_exit(mm)))\n\t\t\t\tgoto breakouterloop;\n\n\t\t\tVM_BUG_ON(khugepaged_scan.address < hstart ||\n\t\t\t\t  khugepaged_scan.address + HPAGE_PMD_SIZE >\n\t\t\t\t  hend);\n\t\t\tif (shmem_file(vma->vm_file)) {\n\t\t\t\tstruct file *file;\n\t\t\t\tpgoff_t pgoff = linear_page_index(vma,\n\t\t\t\t\t\tkhugepaged_scan.address);\n\t\t\t\tif (!shmem_huge_enabled(vma))\n\t\t\t\t\tgoto skip;\n\t\t\t\tfile = get_file(vma->vm_file);\n\t\t\t\tup_read(&mm->mmap_sem);\n\t\t\t\tret = 1;\n\t\t\t\tkhugepaged_scan_shmem(mm, file->f_mapping,\n\t\t\t\t\t\tpgoff, hpage);\n\t\t\t\tfput(file);\n\t\t\t} else {\n\t\t\t\tret = khugepaged_scan_pmd(mm, vma,\n\t\t\t\t\t\tkhugepaged_scan.address,\n\t\t\t\t\t\thpage);\n\t\t\t}\n\t\t\t/* move to next address */\n\t\t\tkhugepaged_scan.address += HPAGE_PMD_SIZE;\n\t\t\tprogress += HPAGE_PMD_NR;\n\t\t\tif (ret)\n\t\t\t\t/* we released mmap_sem so break loop */\n\t\t\t\tgoto breakouterloop_mmap_sem;\n\t\t\tif (progress >= pages)\n\t\t\t\tgoto breakouterloop;\n\t\t}\n\t}\nbreakouterloop:\n\tup_read(&mm->mmap_sem); /* exit_mmap will destroy ptes after this */\nbreakouterloop_mmap_sem:\n\n\tspin_lock(&khugepaged_mm_lock);\n\tVM_BUG_ON(khugepaged_scan.mm_slot != mm_slot);\n\t/*\n\t * Release the current mm_slot if this mm is about to die, or\n\t * if we scanned all vmas of this mm.\n\t */\n\tif (khugepaged_test_exit(mm) || !vma) {\n\t\t/*\n\t\t * Make sure that if mm_users is reaching zero while\n\t\t * khugepaged runs here, khugepaged_exit will find\n\t\t * mm_slot not pointing to the exiting mm.\n\t\t */\n\t\tif (mm_slot->mm_node.next != &khugepaged_scan.mm_head) {\n\t\t\tkhugepaged_scan.mm_slot = list_entry(\n\t\t\t\tmm_slot->mm_node.next,\n\t\t\t\tstruct mm_slot, mm_node);\n\t\t\tkhugepaged_scan.address = 0;\n\t\t} else {\n\t\t\tkhugepaged_scan.mm_slot = NULL;\n\t\t\tkhugepaged_full_scans++;\n\t\t}\n\n\t\tcollect_mm_slot(mm_slot);\n\t}\n\n\treturn progress;\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int khugepaged_full_scans;",
            "static DEFINE_SPINLOCK(khugepaged_mm_lock);",
            "static struct khugepaged_scan khugepaged_scan = {\n\t.mm_head = LIST_HEAD_INIT(khugepaged_scan.mm_head),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic unsigned int khugepaged_full_scans;\nstatic DEFINE_SPINLOCK(khugepaged_mm_lock);\nstatic struct khugepaged_scan khugepaged_scan = {\n\t.mm_head = LIST_HEAD_INIT(khugepaged_scan.mm_head),\n};\n\nstatic unsigned int khugepaged_scan_mm_slot(unsigned int pages,\n\t\t\t\t\t    struct page **hpage)\n\t__releases(&khugepaged_mm_lock)\n\t__acquires(&khugepaged_mm_lock)\n{\n\tstruct mm_slot *mm_slot;\n\tstruct mm_struct *mm;\n\tstruct vm_area_struct *vma;\n\tint progress = 0;\n\n\tVM_BUG_ON(!pages);\n\tVM_BUG_ON(NR_CPUS != 1 && !spin_is_locked(&khugepaged_mm_lock));\n\n\tif (khugepaged_scan.mm_slot)\n\t\tmm_slot = khugepaged_scan.mm_slot;\n\telse {\n\t\tmm_slot = list_entry(khugepaged_scan.mm_head.next,\n\t\t\t\t     struct mm_slot, mm_node);\n\t\tkhugepaged_scan.address = 0;\n\t\tkhugepaged_scan.mm_slot = mm_slot;\n\t}\n\tspin_unlock(&khugepaged_mm_lock);\n\n\tmm = mm_slot->mm;\n\t/*\n\t * Don't wait for semaphore (to avoid long wait times).  Just move to\n\t * the next mm on the list.\n\t */\n\tvma = NULL;\n\tif (unlikely(!down_read_trylock(&mm->mmap_sem)))\n\t\tgoto breakouterloop_mmap_sem;\n\tif (likely(!khugepaged_test_exit(mm)))\n\t\tvma = find_vma(mm, khugepaged_scan.address);\n\n\tprogress++;\n\tfor (; vma; vma = vma->vm_next) {\n\t\tunsigned long hstart, hend;\n\n\t\tcond_resched();\n\t\tif (unlikely(khugepaged_test_exit(mm))) {\n\t\t\tprogress++;\n\t\t\tbreak;\n\t\t}\n\t\tif (!hugepage_vma_check(vma, vma->vm_flags)) {\nskip:\n\t\t\tprogress++;\n\t\t\tcontinue;\n\t\t}\n\t\thstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;\n\t\thend = vma->vm_end & HPAGE_PMD_MASK;\n\t\tif (hstart >= hend)\n\t\t\tgoto skip;\n\t\tif (khugepaged_scan.address > hend)\n\t\t\tgoto skip;\n\t\tif (khugepaged_scan.address < hstart)\n\t\t\tkhugepaged_scan.address = hstart;\n\t\tVM_BUG_ON(khugepaged_scan.address & ~HPAGE_PMD_MASK);\n\n\t\twhile (khugepaged_scan.address < hend) {\n\t\t\tint ret;\n\t\t\tcond_resched();\n\t\t\tif (unlikely(khugepaged_test_exit(mm)))\n\t\t\t\tgoto breakouterloop;\n\n\t\t\tVM_BUG_ON(khugepaged_scan.address < hstart ||\n\t\t\t\t  khugepaged_scan.address + HPAGE_PMD_SIZE >\n\t\t\t\t  hend);\n\t\t\tif (shmem_file(vma->vm_file)) {\n\t\t\t\tstruct file *file;\n\t\t\t\tpgoff_t pgoff = linear_page_index(vma,\n\t\t\t\t\t\tkhugepaged_scan.address);\n\t\t\t\tif (!shmem_huge_enabled(vma))\n\t\t\t\t\tgoto skip;\n\t\t\t\tfile = get_file(vma->vm_file);\n\t\t\t\tup_read(&mm->mmap_sem);\n\t\t\t\tret = 1;\n\t\t\t\tkhugepaged_scan_shmem(mm, file->f_mapping,\n\t\t\t\t\t\tpgoff, hpage);\n\t\t\t\tfput(file);\n\t\t\t} else {\n\t\t\t\tret = khugepaged_scan_pmd(mm, vma,\n\t\t\t\t\t\tkhugepaged_scan.address,\n\t\t\t\t\t\thpage);\n\t\t\t}\n\t\t\t/* move to next address */\n\t\t\tkhugepaged_scan.address += HPAGE_PMD_SIZE;\n\t\t\tprogress += HPAGE_PMD_NR;\n\t\t\tif (ret)\n\t\t\t\t/* we released mmap_sem so break loop */\n\t\t\t\tgoto breakouterloop_mmap_sem;\n\t\t\tif (progress >= pages)\n\t\t\t\tgoto breakouterloop;\n\t\t}\n\t}\nbreakouterloop:\n\tup_read(&mm->mmap_sem); /* exit_mmap will destroy ptes after this */\nbreakouterloop_mmap_sem:\n\n\tspin_lock(&khugepaged_mm_lock);\n\tVM_BUG_ON(khugepaged_scan.mm_slot != mm_slot);\n\t/*\n\t * Release the current mm_slot if this mm is about to die, or\n\t * if we scanned all vmas of this mm.\n\t */\n\tif (khugepaged_test_exit(mm) || !vma) {\n\t\t/*\n\t\t * Make sure that if mm_users is reaching zero while\n\t\t * khugepaged runs here, khugepaged_exit will find\n\t\t * mm_slot not pointing to the exiting mm.\n\t\t */\n\t\tif (mm_slot->mm_node.next != &khugepaged_scan.mm_head) {\n\t\t\tkhugepaged_scan.mm_slot = list_entry(\n\t\t\t\tmm_slot->mm_node.next,\n\t\t\t\tstruct mm_slot, mm_node);\n\t\t\tkhugepaged_scan.address = 0;\n\t\t} else {\n\t\t\tkhugepaged_scan.mm_slot = NULL;\n\t\t\tkhugepaged_full_scans++;\n\t\t}\n\n\t\tcollect_mm_slot(mm_slot);\n\t}\n\n\treturn progress;\n}"
        }
      },
      {
        "call_info": {
          "callee": "khugepaged_has_work",
          "args": [],
          "line": 1782
        },
        "resolved": true,
        "details": {
          "function_name": "khugepaged_has_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "1749-1753",
          "snippet": "static int khugepaged_has_work(void)\n{\n\treturn !list_empty(&khugepaged_scan.mm_head) &&\n\t\tkhugepaged_enabled();\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct khugepaged_scan khugepaged_scan = {\n\t.mm_head = LIST_HEAD_INIT(khugepaged_scan.mm_head),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic struct khugepaged_scan khugepaged_scan = {\n\t.mm_head = LIST_HEAD_INIT(khugepaged_scan.mm_head),\n};\n\nstatic int khugepaged_has_work(void)\n{\n\treturn !list_empty(&khugepaged_scan.mm_head) &&\n\t\tkhugepaged_enabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&khugepaged_mm_lock"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "kthread_should_stop() || try_to_freeze()"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_freeze",
          "args": [],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "khugepaged_prealloc_page",
          "args": [
            "&hpage",
            "&wait"
          ],
          "line": 1771
        },
        "resolved": true,
        "details": {
          "function_name": "khugepaged_prealloc_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "821-830",
          "snippet": "static bool khugepaged_prealloc_page(struct page **hpage, bool *wait)\n{\n\tif (!*hpage)\n\t\t*hpage = khugepaged_alloc_hugepage(wait);\n\n\tif (unlikely(!*hpage))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic bool khugepaged_prealloc_page(struct page **hpage, bool *wait)\n{\n\tif (!*hpage)\n\t\t*hpage = khugepaged_alloc_hugepage(wait);\n\n\tif (unlikely(!*hpage))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic unsigned int khugepaged_pages_to_scan;\nstatic DEFINE_SPINLOCK(khugepaged_mm_lock);\nstatic struct khugepaged_scan khugepaged_scan = {\n\t.mm_head = LIST_HEAD_INIT(khugepaged_scan.mm_head),\n};\n\nstatic void khugepaged_do_scan(void)\n{\n\tstruct page *hpage = NULL;\n\tunsigned int progress = 0, pass_through_head = 0;\n\tunsigned int pages = khugepaged_pages_to_scan;\n\tbool wait = true;\n\n\tbarrier(); /* write khugepaged_pages_to_scan to local stack */\n\n\twhile (progress < pages) {\n\t\tif (!khugepaged_prealloc_page(&hpage, &wait))\n\t\t\tbreak;\n\n\t\tcond_resched();\n\n\t\tif (unlikely(kthread_should_stop() || try_to_freeze()))\n\t\t\tbreak;\n\n\t\tspin_lock(&khugepaged_mm_lock);\n\t\tif (!khugepaged_scan.mm_slot)\n\t\t\tpass_through_head++;\n\t\tif (khugepaged_has_work() &&\n\t\t    pass_through_head < 2)\n\t\t\tprogress += khugepaged_scan_mm_slot(pages - progress,\n\t\t\t\t\t\t\t    &hpage);\n\t\telse\n\t\t\tprogress = pages;\n\t\tspin_unlock(&khugepaged_mm_lock);\n\t}\n\n\tif (!IS_ERR_OR_NULL(hpage))\n\t\tput_page(hpage);\n}"
  },
  {
    "function_name": "khugepaged_wait_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "1755-1759",
    "snippet": "static int khugepaged_wait_event(void)\n{\n\treturn !list_empty(&khugepaged_scan.mm_head) ||\n\t\tkthread_should_stop();\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct khugepaged_scan khugepaged_scan = {\n\t.mm_head = LIST_HEAD_INIT(khugepaged_scan.mm_head),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&khugepaged_scan.mm_head"
          ],
          "line": 1757
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic struct khugepaged_scan khugepaged_scan = {\n\t.mm_head = LIST_HEAD_INIT(khugepaged_scan.mm_head),\n};\n\nstatic int khugepaged_wait_event(void)\n{\n\treturn !list_empty(&khugepaged_scan.mm_head) ||\n\t\tkthread_should_stop();\n}"
  },
  {
    "function_name": "khugepaged_has_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "1749-1753",
    "snippet": "static int khugepaged_has_work(void)\n{\n\treturn !list_empty(&khugepaged_scan.mm_head) &&\n\t\tkhugepaged_enabled();\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct khugepaged_scan khugepaged_scan = {\n\t.mm_head = LIST_HEAD_INIT(khugepaged_scan.mm_head),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "khugepaged_enabled",
          "args": [],
          "line": 1752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&khugepaged_scan.mm_head"
          ],
          "line": 1751
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic struct khugepaged_scan khugepaged_scan = {\n\t.mm_head = LIST_HEAD_INIT(khugepaged_scan.mm_head),\n};\n\nstatic int khugepaged_has_work(void)\n{\n\treturn !list_empty(&khugepaged_scan.mm_head) &&\n\t\tkhugepaged_enabled();\n}"
  },
  {
    "function_name": "khugepaged_scan_mm_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "1623-1747",
    "snippet": "static unsigned int khugepaged_scan_mm_slot(unsigned int pages,\n\t\t\t\t\t    struct page **hpage)\n\t__releases(&khugepaged_mm_lock)\n\t__acquires(&khugepaged_mm_lock)\n{\n\tstruct mm_slot *mm_slot;\n\tstruct mm_struct *mm;\n\tstruct vm_area_struct *vma;\n\tint progress = 0;\n\n\tVM_BUG_ON(!pages);\n\tVM_BUG_ON(NR_CPUS != 1 && !spin_is_locked(&khugepaged_mm_lock));\n\n\tif (khugepaged_scan.mm_slot)\n\t\tmm_slot = khugepaged_scan.mm_slot;\n\telse {\n\t\tmm_slot = list_entry(khugepaged_scan.mm_head.next,\n\t\t\t\t     struct mm_slot, mm_node);\n\t\tkhugepaged_scan.address = 0;\n\t\tkhugepaged_scan.mm_slot = mm_slot;\n\t}\n\tspin_unlock(&khugepaged_mm_lock);\n\n\tmm = mm_slot->mm;\n\t/*\n\t * Don't wait for semaphore (to avoid long wait times).  Just move to\n\t * the next mm on the list.\n\t */\n\tvma = NULL;\n\tif (unlikely(!down_read_trylock(&mm->mmap_sem)))\n\t\tgoto breakouterloop_mmap_sem;\n\tif (likely(!khugepaged_test_exit(mm)))\n\t\tvma = find_vma(mm, khugepaged_scan.address);\n\n\tprogress++;\n\tfor (; vma; vma = vma->vm_next) {\n\t\tunsigned long hstart, hend;\n\n\t\tcond_resched();\n\t\tif (unlikely(khugepaged_test_exit(mm))) {\n\t\t\tprogress++;\n\t\t\tbreak;\n\t\t}\n\t\tif (!hugepage_vma_check(vma, vma->vm_flags)) {\nskip:\n\t\t\tprogress++;\n\t\t\tcontinue;\n\t\t}\n\t\thstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;\n\t\thend = vma->vm_end & HPAGE_PMD_MASK;\n\t\tif (hstart >= hend)\n\t\t\tgoto skip;\n\t\tif (khugepaged_scan.address > hend)\n\t\t\tgoto skip;\n\t\tif (khugepaged_scan.address < hstart)\n\t\t\tkhugepaged_scan.address = hstart;\n\t\tVM_BUG_ON(khugepaged_scan.address & ~HPAGE_PMD_MASK);\n\n\t\twhile (khugepaged_scan.address < hend) {\n\t\t\tint ret;\n\t\t\tcond_resched();\n\t\t\tif (unlikely(khugepaged_test_exit(mm)))\n\t\t\t\tgoto breakouterloop;\n\n\t\t\tVM_BUG_ON(khugepaged_scan.address < hstart ||\n\t\t\t\t  khugepaged_scan.address + HPAGE_PMD_SIZE >\n\t\t\t\t  hend);\n\t\t\tif (shmem_file(vma->vm_file)) {\n\t\t\t\tstruct file *file;\n\t\t\t\tpgoff_t pgoff = linear_page_index(vma,\n\t\t\t\t\t\tkhugepaged_scan.address);\n\t\t\t\tif (!shmem_huge_enabled(vma))\n\t\t\t\t\tgoto skip;\n\t\t\t\tfile = get_file(vma->vm_file);\n\t\t\t\tup_read(&mm->mmap_sem);\n\t\t\t\tret = 1;\n\t\t\t\tkhugepaged_scan_shmem(mm, file->f_mapping,\n\t\t\t\t\t\tpgoff, hpage);\n\t\t\t\tfput(file);\n\t\t\t} else {\n\t\t\t\tret = khugepaged_scan_pmd(mm, vma,\n\t\t\t\t\t\tkhugepaged_scan.address,\n\t\t\t\t\t\thpage);\n\t\t\t}\n\t\t\t/* move to next address */\n\t\t\tkhugepaged_scan.address += HPAGE_PMD_SIZE;\n\t\t\tprogress += HPAGE_PMD_NR;\n\t\t\tif (ret)\n\t\t\t\t/* we released mmap_sem so break loop */\n\t\t\t\tgoto breakouterloop_mmap_sem;\n\t\t\tif (progress >= pages)\n\t\t\t\tgoto breakouterloop;\n\t\t}\n\t}\nbreakouterloop:\n\tup_read(&mm->mmap_sem); /* exit_mmap will destroy ptes after this */\nbreakouterloop_mmap_sem:\n\n\tspin_lock(&khugepaged_mm_lock);\n\tVM_BUG_ON(khugepaged_scan.mm_slot != mm_slot);\n\t/*\n\t * Release the current mm_slot if this mm is about to die, or\n\t * if we scanned all vmas of this mm.\n\t */\n\tif (khugepaged_test_exit(mm) || !vma) {\n\t\t/*\n\t\t * Make sure that if mm_users is reaching zero while\n\t\t * khugepaged runs here, khugepaged_exit will find\n\t\t * mm_slot not pointing to the exiting mm.\n\t\t */\n\t\tif (mm_slot->mm_node.next != &khugepaged_scan.mm_head) {\n\t\t\tkhugepaged_scan.mm_slot = list_entry(\n\t\t\t\tmm_slot->mm_node.next,\n\t\t\t\tstruct mm_slot, mm_node);\n\t\t\tkhugepaged_scan.address = 0;\n\t\t} else {\n\t\t\tkhugepaged_scan.mm_slot = NULL;\n\t\t\tkhugepaged_full_scans++;\n\t\t}\n\n\t\tcollect_mm_slot(mm_slot);\n\t}\n\n\treturn progress;\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int khugepaged_full_scans;",
      "static DEFINE_SPINLOCK(khugepaged_mm_lock);",
      "static struct khugepaged_scan khugepaged_scan = {\n\t.mm_head = LIST_HEAD_INIT(khugepaged_scan.mm_head),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "collect_mm_slot",
          "args": [
            "mm_slot"
          ],
          "line": 1743
        },
        "resolved": true,
        "details": {
          "function_name": "collect_mm_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "1224-1245",
          "snippet": "static void collect_mm_slot(struct mm_slot *mm_slot)\n{\n\tstruct mm_struct *mm = mm_slot->mm;\n\n\tVM_BUG_ON(NR_CPUS != 1 && !spin_is_locked(&khugepaged_mm_lock));\n\n\tif (khugepaged_test_exit(mm)) {\n\t\t/* free mm_slot */\n\t\thash_del(&mm_slot->hash);\n\t\tlist_del(&mm_slot->mm_node);\n\n\t\t/*\n\t\t * Not strictly needed because the mm exited already.\n\t\t *\n\t\t * clear_bit(MMF_VM_HUGEPAGE, &mm->flags);\n\t\t */\n\n\t\t/* khugepaged_mm_lock actually not necessary for the below */\n\t\tfree_mm_slot(mm_slot);\n\t\tmmdrop(mm);\n\t}\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(khugepaged_mm_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_SPINLOCK(khugepaged_mm_lock);\n\nstatic void collect_mm_slot(struct mm_slot *mm_slot)\n{\n\tstruct mm_struct *mm = mm_slot->mm;\n\n\tVM_BUG_ON(NR_CPUS != 1 && !spin_is_locked(&khugepaged_mm_lock));\n\n\tif (khugepaged_test_exit(mm)) {\n\t\t/* free mm_slot */\n\t\thash_del(&mm_slot->hash);\n\t\tlist_del(&mm_slot->mm_node);\n\n\t\t/*\n\t\t * Not strictly needed because the mm exited already.\n\t\t *\n\t\t * clear_bit(MMF_VM_HUGEPAGE, &mm->flags);\n\t\t */\n\n\t\t/* khugepaged_mm_lock actually not necessary for the below */\n\t\tfree_mm_slot(mm_slot);\n\t\tmmdrop(mm);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "mm_slot->mm_node.next",
            "structmm_slot",
            "mm_node"
          ],
          "line": 1734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "khugepaged_test_exit",
          "args": [
            "mm"
          ],
          "line": 1727
        },
        "resolved": true,
        "details": {
          "function_name": "khugepaged_test_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "395-398",
          "snippet": "static inline int khugepaged_test_exit(struct mm_struct *mm)\n{\n\treturn atomic_read(&mm->mm_users) == 0;\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic inline int khugepaged_test_exit(struct mm_struct *mm)\n{\n\treturn atomic_read(&mm->mm_users) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "khugepaged_scan.mm_slot != mm_slot"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&khugepaged_mm_lock"
          ],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "khugepaged_scan_pmd",
          "args": [
            "mm",
            "vma",
            "khugepaged_scan.address",
            "hpage"
          ],
          "line": 1703
        },
        "resolved": true,
        "details": {
          "function_name": "khugepaged_scan_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "1099-1222",
          "snippet": "static int khugepaged_scan_pmd(struct mm_struct *mm,\n\t\t\t       struct vm_area_struct *vma,\n\t\t\t       unsigned long address,\n\t\t\t       struct page **hpage)\n{\n\tpmd_t *pmd;\n\tpte_t *pte, *_pte;\n\tint ret = 0, none_or_zero = 0, result = 0, referenced = 0;\n\tstruct page *page = NULL;\n\tunsigned long _address;\n\tspinlock_t *ptl;\n\tint node = NUMA_NO_NODE, unmapped = 0;\n\tbool writable = false;\n\n\tVM_BUG_ON(address & ~HPAGE_PMD_MASK);\n\n\tpmd = mm_find_pmd(mm, address);\n\tif (!pmd) {\n\t\tresult = SCAN_PMD_NULL;\n\t\tgoto out;\n\t}\n\n\tmemset(khugepaged_node_load, 0, sizeof(khugepaged_node_load));\n\tpte = pte_offset_map_lock(mm, pmd, address, &ptl);\n\tfor (_address = address, _pte = pte; _pte < pte+HPAGE_PMD_NR;\n\t     _pte++, _address += PAGE_SIZE) {\n\t\tpte_t pteval = *_pte;\n\t\tif (is_swap_pte(pteval)) {\n\t\t\tif (++unmapped <= khugepaged_max_ptes_swap) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tresult = SCAN_EXCEED_SWAP_PTE;\n\t\t\t\tgoto out_unmap;\n\t\t\t}\n\t\t}\n\t\tif (pte_none(pteval) || is_zero_pfn(pte_pfn(pteval))) {\n\t\t\tif (!userfaultfd_armed(vma) &&\n\t\t\t    ++none_or_zero <= khugepaged_max_ptes_none) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tresult = SCAN_EXCEED_NONE_PTE;\n\t\t\t\tgoto out_unmap;\n\t\t\t}\n\t\t}\n\t\tif (!pte_present(pteval)) {\n\t\t\tresult = SCAN_PTE_NON_PRESENT;\n\t\t\tgoto out_unmap;\n\t\t}\n\t\tif (pte_write(pteval))\n\t\t\twritable = true;\n\n\t\tpage = vm_normal_page(vma, _address, pteval);\n\t\tif (unlikely(!page)) {\n\t\t\tresult = SCAN_PAGE_NULL;\n\t\t\tgoto out_unmap;\n\t\t}\n\n\t\t/* TODO: teach khugepaged to collapse THP mapped with pte */\n\t\tif (PageCompound(page)) {\n\t\t\tresult = SCAN_PAGE_COMPOUND;\n\t\t\tgoto out_unmap;\n\t\t}\n\n\t\t/*\n\t\t * Record which node the original page is from and save this\n\t\t * information to khugepaged_node_load[].\n\t\t * Khupaged will allocate hugepage from the node has the max\n\t\t * hit record.\n\t\t */\n\t\tnode = page_to_nid(page);\n\t\tif (khugepaged_scan_abort(node)) {\n\t\t\tresult = SCAN_SCAN_ABORT;\n\t\t\tgoto out_unmap;\n\t\t}\n\t\tkhugepaged_node_load[node]++;\n\t\tif (!PageLRU(page)) {\n\t\t\tresult = SCAN_PAGE_LRU;\n\t\t\tgoto out_unmap;\n\t\t}\n\t\tif (PageLocked(page)) {\n\t\t\tresult = SCAN_PAGE_LOCK;\n\t\t\tgoto out_unmap;\n\t\t}\n\t\tif (!PageAnon(page)) {\n\t\t\tresult = SCAN_PAGE_ANON;\n\t\t\tgoto out_unmap;\n\t\t}\n\n\t\t/*\n\t\t * cannot use mapcount: can't collapse if there's a gup pin.\n\t\t * The page must only be referenced by the scanned process\n\t\t * and page swap cache.\n\t\t */\n\t\tif (page_count(page) != 1 + PageSwapCache(page)) {\n\t\t\tresult = SCAN_PAGE_COUNT;\n\t\t\tgoto out_unmap;\n\t\t}\n\t\tif (pte_young(pteval) ||\n\t\t    page_is_young(page) || PageReferenced(page) ||\n\t\t    mmu_notifier_test_young(vma->vm_mm, address))\n\t\t\treferenced++;\n\t}\n\tif (writable) {\n\t\tif (referenced) {\n\t\t\tresult = SCAN_SUCCEED;\n\t\t\tret = 1;\n\t\t} else {\n\t\t\tresult = SCAN_LACK_REFERENCED_PAGE;\n\t\t}\n\t} else {\n\t\tresult = SCAN_PAGE_RO;\n\t}\nout_unmap:\n\tpte_unmap_unlock(pte, ptl);\n\tif (ret) {\n\t\tnode = khugepaged_find_target_node();\n\t\t/* collapse_huge_page will return with the mmap_sem released */\n\t\tcollapse_huge_page(mm, address, hpage, node, referenced);\n\t}\nout:\n\ttrace_mm_khugepaged_scan_pmd(mm, page, writable, referenced,\n\t\t\t\t     none_or_zero, result, unmapped);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int khugepaged_max_ptes_none",
            "static unsigned int khugepaged_max_ptes_swap",
            "static int khugepaged_node_load[MAX_NUMNODES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic unsigned int khugepaged_max_ptes_none;\nstatic unsigned int khugepaged_max_ptes_swap;\nstatic int khugepaged_node_load[MAX_NUMNODES];\n\nstatic int khugepaged_scan_pmd(struct mm_struct *mm,\n\t\t\t       struct vm_area_struct *vma,\n\t\t\t       unsigned long address,\n\t\t\t       struct page **hpage)\n{\n\tpmd_t *pmd;\n\tpte_t *pte, *_pte;\n\tint ret = 0, none_or_zero = 0, result = 0, referenced = 0;\n\tstruct page *page = NULL;\n\tunsigned long _address;\n\tspinlock_t *ptl;\n\tint node = NUMA_NO_NODE, unmapped = 0;\n\tbool writable = false;\n\n\tVM_BUG_ON(address & ~HPAGE_PMD_MASK);\n\n\tpmd = mm_find_pmd(mm, address);\n\tif (!pmd) {\n\t\tresult = SCAN_PMD_NULL;\n\t\tgoto out;\n\t}\n\n\tmemset(khugepaged_node_load, 0, sizeof(khugepaged_node_load));\n\tpte = pte_offset_map_lock(mm, pmd, address, &ptl);\n\tfor (_address = address, _pte = pte; _pte < pte+HPAGE_PMD_NR;\n\t     _pte++, _address += PAGE_SIZE) {\n\t\tpte_t pteval = *_pte;\n\t\tif (is_swap_pte(pteval)) {\n\t\t\tif (++unmapped <= khugepaged_max_ptes_swap) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tresult = SCAN_EXCEED_SWAP_PTE;\n\t\t\t\tgoto out_unmap;\n\t\t\t}\n\t\t}\n\t\tif (pte_none(pteval) || is_zero_pfn(pte_pfn(pteval))) {\n\t\t\tif (!userfaultfd_armed(vma) &&\n\t\t\t    ++none_or_zero <= khugepaged_max_ptes_none) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tresult = SCAN_EXCEED_NONE_PTE;\n\t\t\t\tgoto out_unmap;\n\t\t\t}\n\t\t}\n\t\tif (!pte_present(pteval)) {\n\t\t\tresult = SCAN_PTE_NON_PRESENT;\n\t\t\tgoto out_unmap;\n\t\t}\n\t\tif (pte_write(pteval))\n\t\t\twritable = true;\n\n\t\tpage = vm_normal_page(vma, _address, pteval);\n\t\tif (unlikely(!page)) {\n\t\t\tresult = SCAN_PAGE_NULL;\n\t\t\tgoto out_unmap;\n\t\t}\n\n\t\t/* TODO: teach khugepaged to collapse THP mapped with pte */\n\t\tif (PageCompound(page)) {\n\t\t\tresult = SCAN_PAGE_COMPOUND;\n\t\t\tgoto out_unmap;\n\t\t}\n\n\t\t/*\n\t\t * Record which node the original page is from and save this\n\t\t * information to khugepaged_node_load[].\n\t\t * Khupaged will allocate hugepage from the node has the max\n\t\t * hit record.\n\t\t */\n\t\tnode = page_to_nid(page);\n\t\tif (khugepaged_scan_abort(node)) {\n\t\t\tresult = SCAN_SCAN_ABORT;\n\t\t\tgoto out_unmap;\n\t\t}\n\t\tkhugepaged_node_load[node]++;\n\t\tif (!PageLRU(page)) {\n\t\t\tresult = SCAN_PAGE_LRU;\n\t\t\tgoto out_unmap;\n\t\t}\n\t\tif (PageLocked(page)) {\n\t\t\tresult = SCAN_PAGE_LOCK;\n\t\t\tgoto out_unmap;\n\t\t}\n\t\tif (!PageAnon(page)) {\n\t\t\tresult = SCAN_PAGE_ANON;\n\t\t\tgoto out_unmap;\n\t\t}\n\n\t\t/*\n\t\t * cannot use mapcount: can't collapse if there's a gup pin.\n\t\t * The page must only be referenced by the scanned process\n\t\t * and page swap cache.\n\t\t */\n\t\tif (page_count(page) != 1 + PageSwapCache(page)) {\n\t\t\tresult = SCAN_PAGE_COUNT;\n\t\t\tgoto out_unmap;\n\t\t}\n\t\tif (pte_young(pteval) ||\n\t\t    page_is_young(page) || PageReferenced(page) ||\n\t\t    mmu_notifier_test_young(vma->vm_mm, address))\n\t\t\treferenced++;\n\t}\n\tif (writable) {\n\t\tif (referenced) {\n\t\t\tresult = SCAN_SUCCEED;\n\t\t\tret = 1;\n\t\t} else {\n\t\t\tresult = SCAN_LACK_REFERENCED_PAGE;\n\t\t}\n\t} else {\n\t\tresult = SCAN_PAGE_RO;\n\t}\nout_unmap:\n\tpte_unmap_unlock(pte, ptl);\n\tif (ret) {\n\t\tnode = khugepaged_find_target_node();\n\t\t/* collapse_huge_page will return with the mmap_sem released */\n\t\tcollapse_huge_page(mm, address, hpage, node, referenced);\n\t}\nout:\n\ttrace_mm_khugepaged_scan_pmd(mm, page, writable, referenced,\n\t\t\t\t     none_or_zero, result, unmapped);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "file"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "khugepaged_scan_shmem",
          "args": [
            "mm",
            "file->f_mapping",
            "pgoff",
            "hpage"
          ],
          "line": 1699
        },
        "resolved": true,
        "details": {
          "function_name": "khugepaged_scan_shmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "1615-1620",
          "snippet": "static void khugepaged_scan_shmem(struct mm_struct *mm,\n\t\tstruct address_space *mapping,\n\t\tpgoff_t start, struct page **hpage)\n{\n\tBUILD_BUG();\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void khugepaged_scan_shmem(struct mm_struct *mm,\n\t\tstruct address_space *mapping,\n\t\tpgoff_t start, struct page **hpage)\n{\n\tBUILD_BUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_file",
          "args": [
            "vma->vm_file"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shmem_huge_enabled",
          "args": [
            "vma"
          ],
          "line": 1694
        },
        "resolved": true,
        "details": {
          "function_name": "shmem_huge_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/shmem.c",
          "lines": "3756-3786",
          "snippet": "bool shmem_huge_enabled(struct vm_area_struct *vma)\n{\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct shmem_sb_info *sbinfo = SHMEM_SB(inode->i_sb);\n\tloff_t i_size;\n\tpgoff_t off;\n\n\tif (shmem_huge == SHMEM_HUGE_FORCE)\n\t\treturn true;\n\tif (shmem_huge == SHMEM_HUGE_DENY)\n\t\treturn false;\n\tswitch (sbinfo->huge) {\n\t\tcase SHMEM_HUGE_NEVER:\n\t\t\treturn false;\n\t\tcase SHMEM_HUGE_ALWAYS:\n\t\t\treturn true;\n\t\tcase SHMEM_HUGE_WITHIN_SIZE:\n\t\t\toff = round_up(vma->vm_pgoff, HPAGE_PMD_NR);\n\t\t\ti_size = round_up(i_size_read(inode), PAGE_SIZE);\n\t\t\tif (i_size >= HPAGE_PMD_SIZE &&\n\t\t\t\t\ti_size >> PAGE_SHIFT >= off)\n\t\t\t\treturn true;\n\t\t\t/* fall through */\n\t\tcase SHMEM_HUGE_ADVISE:\n\t\t\t/* TODO: implement fadvise() hints */\n\t\t\treturn (vma->vm_flags & VM_HUGEPAGE);\n\t\tdefault:\n\t\t\tVM_BUG_ON(1);\n\t\t\treturn false;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/uuid.h>",
            "#include <linux/rmap.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <uapi/linux/memfd.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/magic.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/highmem.h>",
            "#include <linux/migrate.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/swapops.h>",
            "#include <linux/security.h>",
            "#include <linux/splice.h>",
            "#include <linux/falloc.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/mman.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/xattr.h>",
            "#include <asm/tlbflush.h> /* for arch/microblaze update_mmu_cache() */",
            "#include <linux/hugetlb.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/uio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/random.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define shmem_huge SHMEM_HUGE_DENY",
            "#define SHMEM_HUGE_FORCE\t(-2)",
            "#define SHMEM_HUGE_DENY\t\t(-1)",
            "#define SHMEM_HUGE_ADVISE\t3",
            "#define SHMEM_HUGE_WITHIN_SIZE\t2",
            "#define SHMEM_HUGE_ALWAYS\t1",
            "#define SHMEM_HUGE_NEVER\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/uuid.h>\n#include <linux/rmap.h>\n#include <linux/userfaultfd_k.h>\n#include <uapi/linux/memfd.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/magic.h>\n#include <linux/seq_file.h>\n#include <linux/highmem.h>\n#include <linux/migrate.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/mempolicy.h>\n#include <linux/swapops.h>\n#include <linux/security.h>\n#include <linux/splice.h>\n#include <linux/falloc.h>\n#include <linux/percpu_counter.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/shmem_fs.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mman.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/exportfs.h>\n#include <linux/xattr.h>\n#include <asm/tlbflush.h> /* for arch/microblaze update_mmu_cache() */\n#include <linux/hugetlb.h>\n#include <linux/khugepaged.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/sched/signal.h>\n#include <linux/random.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/ramfs.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\n#define shmem_huge SHMEM_HUGE_DENY\n#define SHMEM_HUGE_FORCE\t(-2)\n#define SHMEM_HUGE_DENY\t\t(-1)\n#define SHMEM_HUGE_ADVISE\t3\n#define SHMEM_HUGE_WITHIN_SIZE\t2\n#define SHMEM_HUGE_ALWAYS\t1\n#define SHMEM_HUGE_NEVER\t0\n\nbool shmem_huge_enabled(struct vm_area_struct *vma)\n{\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct shmem_sb_info *sbinfo = SHMEM_SB(inode->i_sb);\n\tloff_t i_size;\n\tpgoff_t off;\n\n\tif (shmem_huge == SHMEM_HUGE_FORCE)\n\t\treturn true;\n\tif (shmem_huge == SHMEM_HUGE_DENY)\n\t\treturn false;\n\tswitch (sbinfo->huge) {\n\t\tcase SHMEM_HUGE_NEVER:\n\t\t\treturn false;\n\t\tcase SHMEM_HUGE_ALWAYS:\n\t\t\treturn true;\n\t\tcase SHMEM_HUGE_WITHIN_SIZE:\n\t\t\toff = round_up(vma->vm_pgoff, HPAGE_PMD_NR);\n\t\t\ti_size = round_up(i_size_read(inode), PAGE_SIZE);\n\t\t\tif (i_size >= HPAGE_PMD_SIZE &&\n\t\t\t\t\ti_size >> PAGE_SHIFT >= off)\n\t\t\t\treturn true;\n\t\t\t/* fall through */\n\t\tcase SHMEM_HUGE_ADVISE:\n\t\t\t/* TODO: implement fadvise() hints */\n\t\t\treturn (vma->vm_flags & VM_HUGEPAGE);\n\t\tdefault:\n\t\t\tVM_BUG_ON(1);\n\t\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "linear_page_index",
          "args": [
            "vma",
            "khugepaged_scan.address"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shmem_file",
          "args": [
            "vma->vm_file"
          ],
          "line": 1690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "khugepaged_scan.address < hstart ||\n\t\t\t\t  khugepaged_scan.address + HPAGE_PMD_SIZE >\n\t\t\t\t  hend"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "khugepaged_test_exit(mm)"
          ],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "khugepaged_scan.address & ~HPAGE_PMD_MASK"
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugepage_vma_check",
          "args": [
            "vma",
            "vma->vm_flags"
          ],
          "line": 1666
        },
        "resolved": true,
        "details": {
          "function_name": "hugepage_vma_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "400-418",
          "snippet": "static bool hugepage_vma_check(struct vm_area_struct *vma,\n\t\t\t       unsigned long vm_flags)\n{\n\tif ((!(vm_flags & VM_HUGEPAGE) && !khugepaged_always()) ||\n\t    (vm_flags & VM_NOHUGEPAGE) ||\n\t    test_bit(MMF_DISABLE_THP, &vma->vm_mm->flags))\n\t\treturn false;\n\tif (shmem_file(vma->vm_file)) {\n\t\tif (!IS_ENABLED(CONFIG_TRANSPARENT_HUGE_PAGECACHE))\n\t\t\treturn false;\n\t\treturn IS_ALIGNED((vma->vm_start >> PAGE_SHIFT) - vma->vm_pgoff,\n\t\t\t\tHPAGE_PMD_NR);\n\t}\n\tif (!vma->anon_vma || vma->vm_ops)\n\t\treturn false;\n\tif (is_vma_temporary_stack(vma))\n\t\treturn false;\n\treturn !(vm_flags & VM_NO_KHUGEPAGED);\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define VM_NO_KHUGEPAGED (VM_SPECIAL | VM_HUGETLB)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\n#define VM_NO_KHUGEPAGED (VM_SPECIAL | VM_HUGETLB)\n\nstatic bool hugepage_vma_check(struct vm_area_struct *vma,\n\t\t\t       unsigned long vm_flags)\n{\n\tif ((!(vm_flags & VM_HUGEPAGE) && !khugepaged_always()) ||\n\t    (vm_flags & VM_NOHUGEPAGE) ||\n\t    test_bit(MMF_DISABLE_THP, &vma->vm_mm->flags))\n\t\treturn false;\n\tif (shmem_file(vma->vm_file)) {\n\t\tif (!IS_ENABLED(CONFIG_TRANSPARENT_HUGE_PAGECACHE))\n\t\t\treturn false;\n\t\treturn IS_ALIGNED((vma->vm_start >> PAGE_SHIFT) - vma->vm_pgoff,\n\t\t\t\tHPAGE_PMD_NR);\n\t}\n\tif (!vma->anon_vma || vma->vm_ops)\n\t\treturn false;\n\tif (is_vma_temporary_stack(vma))\n\t\treturn false;\n\treturn !(vm_flags & VM_NO_KHUGEPAGED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "khugepaged_test_exit(mm)"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_vma",
          "args": [
            "mm",
            "khugepaged_scan.address"
          ],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "find_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "775-796",
          "snippet": "struct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\n\t/* check the cache first */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\t/* trawl the list (there may be multiple mappings in which addr\n\t * resides) */\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_start > addr)\n\t\t\treturn NULL;\n\t\tif (vma->vm_end > addr) {\n\t\t\tvmacache_update(addr, vma);\n\t\t\treturn vma;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nstruct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\n\t/* check the cache first */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\t/* trawl the list (there may be multiple mappings in which addr\n\t * resides) */\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_start > addr)\n\t\t\treturn NULL;\n\t\tif (vma->vm_end > addr) {\n\t\t\tvmacache_update(addr, vma);\n\t\t\treturn vma;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!khugepaged_test_exit(mm)"
          ],
          "line": 1654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!down_read_trylock(&mm->mmap_sem)"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read_trylock",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&khugepaged_mm_lock"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "khugepaged_scan.mm_head.next",
            "structmm_slot",
            "mm_node"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "NR_CPUS != 1 && !spin_is_locked(&khugepaged_mm_lock)"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_is_locked",
          "args": [
            "&khugepaged_mm_lock"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!pages"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&khugepaged_mm_lock"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&khugepaged_mm_lock"
          ],
          "line": 1625
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic unsigned int khugepaged_full_scans;\nstatic DEFINE_SPINLOCK(khugepaged_mm_lock);\nstatic struct khugepaged_scan khugepaged_scan = {\n\t.mm_head = LIST_HEAD_INIT(khugepaged_scan.mm_head),\n};\n\nstatic unsigned int khugepaged_scan_mm_slot(unsigned int pages,\n\t\t\t\t\t    struct page **hpage)\n\t__releases(&khugepaged_mm_lock)\n\t__acquires(&khugepaged_mm_lock)\n{\n\tstruct mm_slot *mm_slot;\n\tstruct mm_struct *mm;\n\tstruct vm_area_struct *vma;\n\tint progress = 0;\n\n\tVM_BUG_ON(!pages);\n\tVM_BUG_ON(NR_CPUS != 1 && !spin_is_locked(&khugepaged_mm_lock));\n\n\tif (khugepaged_scan.mm_slot)\n\t\tmm_slot = khugepaged_scan.mm_slot;\n\telse {\n\t\tmm_slot = list_entry(khugepaged_scan.mm_head.next,\n\t\t\t\t     struct mm_slot, mm_node);\n\t\tkhugepaged_scan.address = 0;\n\t\tkhugepaged_scan.mm_slot = mm_slot;\n\t}\n\tspin_unlock(&khugepaged_mm_lock);\n\n\tmm = mm_slot->mm;\n\t/*\n\t * Don't wait for semaphore (to avoid long wait times).  Just move to\n\t * the next mm on the list.\n\t */\n\tvma = NULL;\n\tif (unlikely(!down_read_trylock(&mm->mmap_sem)))\n\t\tgoto breakouterloop_mmap_sem;\n\tif (likely(!khugepaged_test_exit(mm)))\n\t\tvma = find_vma(mm, khugepaged_scan.address);\n\n\tprogress++;\n\tfor (; vma; vma = vma->vm_next) {\n\t\tunsigned long hstart, hend;\n\n\t\tcond_resched();\n\t\tif (unlikely(khugepaged_test_exit(mm))) {\n\t\t\tprogress++;\n\t\t\tbreak;\n\t\t}\n\t\tif (!hugepage_vma_check(vma, vma->vm_flags)) {\nskip:\n\t\t\tprogress++;\n\t\t\tcontinue;\n\t\t}\n\t\thstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;\n\t\thend = vma->vm_end & HPAGE_PMD_MASK;\n\t\tif (hstart >= hend)\n\t\t\tgoto skip;\n\t\tif (khugepaged_scan.address > hend)\n\t\t\tgoto skip;\n\t\tif (khugepaged_scan.address < hstart)\n\t\t\tkhugepaged_scan.address = hstart;\n\t\tVM_BUG_ON(khugepaged_scan.address & ~HPAGE_PMD_MASK);\n\n\t\twhile (khugepaged_scan.address < hend) {\n\t\t\tint ret;\n\t\t\tcond_resched();\n\t\t\tif (unlikely(khugepaged_test_exit(mm)))\n\t\t\t\tgoto breakouterloop;\n\n\t\t\tVM_BUG_ON(khugepaged_scan.address < hstart ||\n\t\t\t\t  khugepaged_scan.address + HPAGE_PMD_SIZE >\n\t\t\t\t  hend);\n\t\t\tif (shmem_file(vma->vm_file)) {\n\t\t\t\tstruct file *file;\n\t\t\t\tpgoff_t pgoff = linear_page_index(vma,\n\t\t\t\t\t\tkhugepaged_scan.address);\n\t\t\t\tif (!shmem_huge_enabled(vma))\n\t\t\t\t\tgoto skip;\n\t\t\t\tfile = get_file(vma->vm_file);\n\t\t\t\tup_read(&mm->mmap_sem);\n\t\t\t\tret = 1;\n\t\t\t\tkhugepaged_scan_shmem(mm, file->f_mapping,\n\t\t\t\t\t\tpgoff, hpage);\n\t\t\t\tfput(file);\n\t\t\t} else {\n\t\t\t\tret = khugepaged_scan_pmd(mm, vma,\n\t\t\t\t\t\tkhugepaged_scan.address,\n\t\t\t\t\t\thpage);\n\t\t\t}\n\t\t\t/* move to next address */\n\t\t\tkhugepaged_scan.address += HPAGE_PMD_SIZE;\n\t\t\tprogress += HPAGE_PMD_NR;\n\t\t\tif (ret)\n\t\t\t\t/* we released mmap_sem so break loop */\n\t\t\t\tgoto breakouterloop_mmap_sem;\n\t\t\tif (progress >= pages)\n\t\t\t\tgoto breakouterloop;\n\t\t}\n\t}\nbreakouterloop:\n\tup_read(&mm->mmap_sem); /* exit_mmap will destroy ptes after this */\nbreakouterloop_mmap_sem:\n\n\tspin_lock(&khugepaged_mm_lock);\n\tVM_BUG_ON(khugepaged_scan.mm_slot != mm_slot);\n\t/*\n\t * Release the current mm_slot if this mm is about to die, or\n\t * if we scanned all vmas of this mm.\n\t */\n\tif (khugepaged_test_exit(mm) || !vma) {\n\t\t/*\n\t\t * Make sure that if mm_users is reaching zero while\n\t\t * khugepaged runs here, khugepaged_exit will find\n\t\t * mm_slot not pointing to the exiting mm.\n\t\t */\n\t\tif (mm_slot->mm_node.next != &khugepaged_scan.mm_head) {\n\t\t\tkhugepaged_scan.mm_slot = list_entry(\n\t\t\t\tmm_slot->mm_node.next,\n\t\t\t\tstruct mm_slot, mm_node);\n\t\t\tkhugepaged_scan.address = 0;\n\t\t} else {\n\t\t\tkhugepaged_scan.mm_slot = NULL;\n\t\t\tkhugepaged_full_scans++;\n\t\t}\n\n\t\tcollect_mm_slot(mm_slot);\n\t}\n\n\treturn progress;\n}"
  },
  {
    "function_name": "khugepaged_scan_shmem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "1615-1620",
    "snippet": "static void khugepaged_scan_shmem(struct mm_struct *mm,\n\t\tstruct address_space *mapping,\n\t\tpgoff_t start, struct page **hpage)\n{\n\tBUILD_BUG();\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUILD_BUG",
          "args": [],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void khugepaged_scan_shmem(struct mm_struct *mm,\n\t\tstruct address_space *mapping,\n\t\tpgoff_t start, struct page **hpage)\n{\n\tBUILD_BUG();\n}"
  },
  {
    "function_name": "khugepaged_scan_shmem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "1540-1613",
    "snippet": "static void khugepaged_scan_shmem(struct mm_struct *mm,\n\t\tstruct address_space *mapping,\n\t\tpgoff_t start, struct page **hpage)\n{\n\tstruct page *page = NULL;\n\tXA_STATE(xas, &mapping->i_pages, start);\n\tint present, swap;\n\tint node = NUMA_NO_NODE;\n\tint result = SCAN_SUCCEED;\n\n\tpresent = 0;\n\tswap = 0;\n\tmemset(khugepaged_node_load, 0, sizeof(khugepaged_node_load));\n\trcu_read_lock();\n\txas_for_each(&xas, page, start + HPAGE_PMD_NR - 1) {\n\t\tif (xas_retry(&xas, page))\n\t\t\tcontinue;\n\n\t\tif (xa_is_value(page)) {\n\t\t\tif (++swap > khugepaged_max_ptes_swap) {\n\t\t\t\tresult = SCAN_EXCEED_SWAP_PTE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (PageTransCompound(page)) {\n\t\t\tresult = SCAN_PAGE_COMPOUND;\n\t\t\tbreak;\n\t\t}\n\n\t\tnode = page_to_nid(page);\n\t\tif (khugepaged_scan_abort(node)) {\n\t\t\tresult = SCAN_SCAN_ABORT;\n\t\t\tbreak;\n\t\t}\n\t\tkhugepaged_node_load[node]++;\n\n\t\tif (!PageLRU(page)) {\n\t\t\tresult = SCAN_PAGE_LRU;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (page_count(page) != 1 + page_mapcount(page)) {\n\t\t\tresult = SCAN_PAGE_COUNT;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * We probably should check if the page is referenced here, but\n\t\t * nobody would transfer pte_young() to PageReferenced() for us.\n\t\t * And rmap walk here is just too costly...\n\t\t */\n\n\t\tpresent++;\n\n\t\tif (need_resched()) {\n\t\t\txas_pause(&xas);\n\t\t\tcond_resched_rcu();\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (result == SCAN_SUCCEED) {\n\t\tif (present < HPAGE_PMD_NR - khugepaged_max_ptes_none) {\n\t\t\tresult = SCAN_EXCEED_NONE_PTE;\n\t\t} else {\n\t\t\tnode = khugepaged_find_target_node();\n\t\t\tcollapse_shmem(mm, mapping, start, hpage, node);\n\t\t}\n\t}\n\n\t/* TODO: tracepoints */\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int khugepaged_max_ptes_none",
      "static unsigned int khugepaged_max_ptes_swap",
      "static int khugepaged_node_load[MAX_NUMNODES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "collapse_shmem",
          "args": [
            "mm",
            "mapping",
            "start",
            "hpage",
            "node"
          ],
          "line": 1608
        },
        "resolved": true,
        "details": {
          "function_name": "collapse_shmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "1304-1538",
          "snippet": "static void collapse_shmem(struct mm_struct *mm,\n\t\tstruct address_space *mapping, pgoff_t start,\n\t\tstruct page **hpage, int node)\n{\n\tgfp_t gfp;\n\tstruct page *new_page;\n\tstruct mem_cgroup *memcg;\n\tpgoff_t index, end = start + HPAGE_PMD_NR;\n\tLIST_HEAD(pagelist);\n\tXA_STATE_ORDER(xas, &mapping->i_pages, start, HPAGE_PMD_ORDER);\n\tint nr_none = 0, result = SCAN_SUCCEED;\n\n\tVM_BUG_ON(start & (HPAGE_PMD_NR - 1));\n\n\t/* Only allocate from the target node */\n\tgfp = alloc_hugepage_khugepaged_gfpmask() | __GFP_THISNODE;\n\n\tnew_page = khugepaged_alloc_page(hpage, gfp, node);\n\tif (!new_page) {\n\t\tresult = SCAN_ALLOC_HUGE_PAGE_FAIL;\n\t\tgoto out;\n\t}\n\n\tif (unlikely(mem_cgroup_try_charge(new_page, mm, gfp, &memcg, true))) {\n\t\tresult = SCAN_CGROUP_CHARGE_FAIL;\n\t\tgoto out;\n\t}\n\n\tnew_page->index = start;\n\tnew_page->mapping = mapping;\n\t__SetPageSwapBacked(new_page);\n\t__SetPageLocked(new_page);\n\tBUG_ON(!page_ref_freeze(new_page, 1));\n\n\t/*\n\t * At this point the new_page is 'frozen' (page_count() is zero),\n\t * locked and not up-to-date. It's safe to insert it into the page\n\t * cache, because nobody would be able to map it or use it in other\n\t * way until we unfreeze it.\n\t */\n\n\t/* This will be less messy when we use multi-index entries */\n\tdo {\n\t\txas_lock_irq(&xas);\n\t\txas_create_range(&xas);\n\t\tif (!xas_error(&xas))\n\t\t\tbreak;\n\t\txas_unlock_irq(&xas);\n\t\tif (!xas_nomem(&xas, GFP_KERNEL))\n\t\t\tgoto out;\n\t} while (1);\n\n\txas_set(&xas, start);\n\tfor (index = start; index < end; index++) {\n\t\tstruct page *page = xas_next(&xas);\n\n\t\tVM_BUG_ON(index != xas.xa_index);\n\t\tif (!page) {\n\t\t\tif (!shmem_charge(mapping->host, 1)) {\n\t\t\t\tresult = SCAN_FAIL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\txas_store(&xas, new_page + (index % HPAGE_PMD_NR));\n\t\t\tnr_none++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (xa_is_value(page) || !PageUptodate(page)) {\n\t\t\txas_unlock_irq(&xas);\n\t\t\t/* swap in or instantiate fallocated page */\n\t\t\tif (shmem_getpage(mapping->host, index, &page,\n\t\t\t\t\t\tSGP_NOHUGE)) {\n\t\t\t\tresult = SCAN_FAIL;\n\t\t\t\tgoto xa_unlocked;\n\t\t\t}\n\t\t\txas_lock_irq(&xas);\n\t\t\txas_set(&xas, index);\n\t\t} else if (trylock_page(page)) {\n\t\t\tget_page(page);\n\t\t} else {\n\t\t\tresult = SCAN_PAGE_LOCK;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * The page must be locked, so we can drop the i_pages lock\n\t\t * without racing with truncate.\n\t\t */\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\t\tVM_BUG_ON_PAGE(!PageUptodate(page), page);\n\t\tVM_BUG_ON_PAGE(PageTransCompound(page), page);\n\n\t\tif (page_mapping(page) != mapping) {\n\t\t\tresult = SCAN_TRUNCATED;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\txas_unlock_irq(&xas);\n\n\t\tif (isolate_lru_page(page)) {\n\t\t\tresult = SCAN_DEL_PAGE_LRU;\n\t\t\tgoto out_isolate_failed;\n\t\t}\n\n\t\tif (page_mapped(page))\n\t\t\tunmap_mapping_pages(mapping, index, 1, false);\n\n\t\txas_lock_irq(&xas);\n\t\txas_set(&xas, index);\n\n\t\tVM_BUG_ON_PAGE(page != xas_load(&xas), page);\n\t\tVM_BUG_ON_PAGE(page_mapped(page), page);\n\n\t\t/*\n\t\t * The page is expected to have page_count() == 3:\n\t\t *  - we hold a pin on it;\n\t\t *  - one reference from page cache;\n\t\t *  - one from isolate_lru_page;\n\t\t */\n\t\tif (!page_ref_freeze(page, 3)) {\n\t\t\tresult = SCAN_PAGE_COUNT;\n\t\t\tgoto out_lru;\n\t\t}\n\n\t\t/*\n\t\t * Add the page to the list to be able to undo the collapse if\n\t\t * something go wrong.\n\t\t */\n\t\tlist_add_tail(&page->lru, &pagelist);\n\n\t\t/* Finally, replace with the new page. */\n\t\txas_store(&xas, new_page + (index % HPAGE_PMD_NR));\n\t\tcontinue;\nout_lru:\n\t\txas_unlock_irq(&xas);\n\t\tputback_lru_page(page);\nout_isolate_failed:\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tgoto xa_unlocked;\nout_unlock:\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tbreak;\n\t}\n\txas_unlock_irq(&xas);\n\nxa_unlocked:\n\tif (result == SCAN_SUCCEED) {\n\t\tstruct page *page, *tmp;\n\t\tstruct zone *zone = page_zone(new_page);\n\n\t\t/*\n\t\t * Replacing old pages with new one has succeeded, now we\n\t\t * need to copy the content and free the old pages.\n\t\t */\n\t\tlist_for_each_entry_safe(page, tmp, &pagelist, lru) {\n\t\t\tcopy_highpage(new_page + (page->index % HPAGE_PMD_NR),\n\t\t\t\t\tpage);\n\t\t\tlist_del(&page->lru);\n\t\t\tunlock_page(page);\n\t\t\tpage_ref_unfreeze(page, 1);\n\t\t\tpage->mapping = NULL;\n\t\t\tClearPageActive(page);\n\t\t\tClearPageUnevictable(page);\n\t\t\tput_page(page);\n\t\t}\n\n\t\tlocal_irq_disable();\n\t\t__inc_node_page_state(new_page, NR_SHMEM_THPS);\n\t\tif (nr_none) {\n\t\t\t__mod_node_page_state(zone->zone_pgdat, NR_FILE_PAGES, nr_none);\n\t\t\t__mod_node_page_state(zone->zone_pgdat, NR_SHMEM, nr_none);\n\t\t}\n\t\tlocal_irq_enable();\n\n\t\t/*\n\t\t * Remove pte page tables, so we can re-fault\n\t\t * the page as huge.\n\t\t */\n\t\tretract_page_tables(mapping, start);\n\n\t\t/* Everything is ready, let's unfreeze the new_page */\n\t\tset_page_dirty(new_page);\n\t\tSetPageUptodate(new_page);\n\t\tpage_ref_unfreeze(new_page, HPAGE_PMD_NR);\n\t\tmem_cgroup_commit_charge(new_page, memcg, false, true);\n\t\tlru_cache_add_anon(new_page);\n\t\tunlock_page(new_page);\n\n\t\t*hpage = NULL;\n\n\t\tkhugepaged_pages_collapsed++;\n\t} else {\n\t\tstruct page *page;\n\t\t/* Something went wrong: roll back page cache changes */\n\t\tshmem_uncharge(mapping->host, nr_none);\n\t\txas_lock_irq(&xas);\n\t\txas_set(&xas, start);\n\t\txas_for_each(&xas, page, end - 1) {\n\t\t\tpage = list_first_entry_or_null(&pagelist,\n\t\t\t\t\tstruct page, lru);\n\t\t\tif (!page || xas.xa_index < page->index) {\n\t\t\t\tif (!nr_none)\n\t\t\t\t\tbreak;\n\t\t\t\tnr_none--;\n\t\t\t\t/* Put holes back where they were */\n\t\t\t\txas_store(&xas, NULL);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tVM_BUG_ON_PAGE(page->index != xas.xa_index, page);\n\n\t\t\t/* Unfreeze the page. */\n\t\t\tlist_del(&page->lru);\n\t\t\tpage_ref_unfreeze(page, 2);\n\t\t\txas_store(&xas, page);\n\t\t\txas_pause(&xas);\n\t\t\txas_unlock_irq(&xas);\n\t\t\tputback_lru_page(page);\n\t\t\tunlock_page(page);\n\t\t\txas_lock_irq(&xas);\n\t\t}\n\t\tVM_BUG_ON(nr_none);\n\t\txas_unlock_irq(&xas);\n\n\t\t/* Unfreeze new_page, caller would take care about freeing it */\n\t\tpage_ref_unfreeze(new_page, 1);\n\t\tmem_cgroup_cancel_charge(new_page, memcg, true);\n\t\tunlock_page(new_page);\n\t\tnew_page->mapping = NULL;\n\t}\nout:\n\tVM_BUG_ON(!list_empty(&pagelist));\n\t/* TODO: tracepoints */\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int khugepaged_pages_collapsed;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic unsigned int khugepaged_pages_collapsed;\n\nstatic void collapse_shmem(struct mm_struct *mm,\n\t\tstruct address_space *mapping, pgoff_t start,\n\t\tstruct page **hpage, int node)\n{\n\tgfp_t gfp;\n\tstruct page *new_page;\n\tstruct mem_cgroup *memcg;\n\tpgoff_t index, end = start + HPAGE_PMD_NR;\n\tLIST_HEAD(pagelist);\n\tXA_STATE_ORDER(xas, &mapping->i_pages, start, HPAGE_PMD_ORDER);\n\tint nr_none = 0, result = SCAN_SUCCEED;\n\n\tVM_BUG_ON(start & (HPAGE_PMD_NR - 1));\n\n\t/* Only allocate from the target node */\n\tgfp = alloc_hugepage_khugepaged_gfpmask() | __GFP_THISNODE;\n\n\tnew_page = khugepaged_alloc_page(hpage, gfp, node);\n\tif (!new_page) {\n\t\tresult = SCAN_ALLOC_HUGE_PAGE_FAIL;\n\t\tgoto out;\n\t}\n\n\tif (unlikely(mem_cgroup_try_charge(new_page, mm, gfp, &memcg, true))) {\n\t\tresult = SCAN_CGROUP_CHARGE_FAIL;\n\t\tgoto out;\n\t}\n\n\tnew_page->index = start;\n\tnew_page->mapping = mapping;\n\t__SetPageSwapBacked(new_page);\n\t__SetPageLocked(new_page);\n\tBUG_ON(!page_ref_freeze(new_page, 1));\n\n\t/*\n\t * At this point the new_page is 'frozen' (page_count() is zero),\n\t * locked and not up-to-date. It's safe to insert it into the page\n\t * cache, because nobody would be able to map it or use it in other\n\t * way until we unfreeze it.\n\t */\n\n\t/* This will be less messy when we use multi-index entries */\n\tdo {\n\t\txas_lock_irq(&xas);\n\t\txas_create_range(&xas);\n\t\tif (!xas_error(&xas))\n\t\t\tbreak;\n\t\txas_unlock_irq(&xas);\n\t\tif (!xas_nomem(&xas, GFP_KERNEL))\n\t\t\tgoto out;\n\t} while (1);\n\n\txas_set(&xas, start);\n\tfor (index = start; index < end; index++) {\n\t\tstruct page *page = xas_next(&xas);\n\n\t\tVM_BUG_ON(index != xas.xa_index);\n\t\tif (!page) {\n\t\t\tif (!shmem_charge(mapping->host, 1)) {\n\t\t\t\tresult = SCAN_FAIL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\txas_store(&xas, new_page + (index % HPAGE_PMD_NR));\n\t\t\tnr_none++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (xa_is_value(page) || !PageUptodate(page)) {\n\t\t\txas_unlock_irq(&xas);\n\t\t\t/* swap in or instantiate fallocated page */\n\t\t\tif (shmem_getpage(mapping->host, index, &page,\n\t\t\t\t\t\tSGP_NOHUGE)) {\n\t\t\t\tresult = SCAN_FAIL;\n\t\t\t\tgoto xa_unlocked;\n\t\t\t}\n\t\t\txas_lock_irq(&xas);\n\t\t\txas_set(&xas, index);\n\t\t} else if (trylock_page(page)) {\n\t\t\tget_page(page);\n\t\t} else {\n\t\t\tresult = SCAN_PAGE_LOCK;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * The page must be locked, so we can drop the i_pages lock\n\t\t * without racing with truncate.\n\t\t */\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\t\tVM_BUG_ON_PAGE(!PageUptodate(page), page);\n\t\tVM_BUG_ON_PAGE(PageTransCompound(page), page);\n\n\t\tif (page_mapping(page) != mapping) {\n\t\t\tresult = SCAN_TRUNCATED;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\txas_unlock_irq(&xas);\n\n\t\tif (isolate_lru_page(page)) {\n\t\t\tresult = SCAN_DEL_PAGE_LRU;\n\t\t\tgoto out_isolate_failed;\n\t\t}\n\n\t\tif (page_mapped(page))\n\t\t\tunmap_mapping_pages(mapping, index, 1, false);\n\n\t\txas_lock_irq(&xas);\n\t\txas_set(&xas, index);\n\n\t\tVM_BUG_ON_PAGE(page != xas_load(&xas), page);\n\t\tVM_BUG_ON_PAGE(page_mapped(page), page);\n\n\t\t/*\n\t\t * The page is expected to have page_count() == 3:\n\t\t *  - we hold a pin on it;\n\t\t *  - one reference from page cache;\n\t\t *  - one from isolate_lru_page;\n\t\t */\n\t\tif (!page_ref_freeze(page, 3)) {\n\t\t\tresult = SCAN_PAGE_COUNT;\n\t\t\tgoto out_lru;\n\t\t}\n\n\t\t/*\n\t\t * Add the page to the list to be able to undo the collapse if\n\t\t * something go wrong.\n\t\t */\n\t\tlist_add_tail(&page->lru, &pagelist);\n\n\t\t/* Finally, replace with the new page. */\n\t\txas_store(&xas, new_page + (index % HPAGE_PMD_NR));\n\t\tcontinue;\nout_lru:\n\t\txas_unlock_irq(&xas);\n\t\tputback_lru_page(page);\nout_isolate_failed:\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tgoto xa_unlocked;\nout_unlock:\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tbreak;\n\t}\n\txas_unlock_irq(&xas);\n\nxa_unlocked:\n\tif (result == SCAN_SUCCEED) {\n\t\tstruct page *page, *tmp;\n\t\tstruct zone *zone = page_zone(new_page);\n\n\t\t/*\n\t\t * Replacing old pages with new one has succeeded, now we\n\t\t * need to copy the content and free the old pages.\n\t\t */\n\t\tlist_for_each_entry_safe(page, tmp, &pagelist, lru) {\n\t\t\tcopy_highpage(new_page + (page->index % HPAGE_PMD_NR),\n\t\t\t\t\tpage);\n\t\t\tlist_del(&page->lru);\n\t\t\tunlock_page(page);\n\t\t\tpage_ref_unfreeze(page, 1);\n\t\t\tpage->mapping = NULL;\n\t\t\tClearPageActive(page);\n\t\t\tClearPageUnevictable(page);\n\t\t\tput_page(page);\n\t\t}\n\n\t\tlocal_irq_disable();\n\t\t__inc_node_page_state(new_page, NR_SHMEM_THPS);\n\t\tif (nr_none) {\n\t\t\t__mod_node_page_state(zone->zone_pgdat, NR_FILE_PAGES, nr_none);\n\t\t\t__mod_node_page_state(zone->zone_pgdat, NR_SHMEM, nr_none);\n\t\t}\n\t\tlocal_irq_enable();\n\n\t\t/*\n\t\t * Remove pte page tables, so we can re-fault\n\t\t * the page as huge.\n\t\t */\n\t\tretract_page_tables(mapping, start);\n\n\t\t/* Everything is ready, let's unfreeze the new_page */\n\t\tset_page_dirty(new_page);\n\t\tSetPageUptodate(new_page);\n\t\tpage_ref_unfreeze(new_page, HPAGE_PMD_NR);\n\t\tmem_cgroup_commit_charge(new_page, memcg, false, true);\n\t\tlru_cache_add_anon(new_page);\n\t\tunlock_page(new_page);\n\n\t\t*hpage = NULL;\n\n\t\tkhugepaged_pages_collapsed++;\n\t} else {\n\t\tstruct page *page;\n\t\t/* Something went wrong: roll back page cache changes */\n\t\tshmem_uncharge(mapping->host, nr_none);\n\t\txas_lock_irq(&xas);\n\t\txas_set(&xas, start);\n\t\txas_for_each(&xas, page, end - 1) {\n\t\t\tpage = list_first_entry_or_null(&pagelist,\n\t\t\t\t\tstruct page, lru);\n\t\t\tif (!page || xas.xa_index < page->index) {\n\t\t\t\tif (!nr_none)\n\t\t\t\t\tbreak;\n\t\t\t\tnr_none--;\n\t\t\t\t/* Put holes back where they were */\n\t\t\t\txas_store(&xas, NULL);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tVM_BUG_ON_PAGE(page->index != xas.xa_index, page);\n\n\t\t\t/* Unfreeze the page. */\n\t\t\tlist_del(&page->lru);\n\t\t\tpage_ref_unfreeze(page, 2);\n\t\t\txas_store(&xas, page);\n\t\t\txas_pause(&xas);\n\t\t\txas_unlock_irq(&xas);\n\t\t\tputback_lru_page(page);\n\t\t\tunlock_page(page);\n\t\t\txas_lock_irq(&xas);\n\t\t}\n\t\tVM_BUG_ON(nr_none);\n\t\txas_unlock_irq(&xas);\n\n\t\t/* Unfreeze new_page, caller would take care about freeing it */\n\t\tpage_ref_unfreeze(new_page, 1);\n\t\tmem_cgroup_cancel_charge(new_page, memcg, true);\n\t\tunlock_page(new_page);\n\t\tnew_page->mapping = NULL;\n\t}\nout:\n\tVM_BUG_ON(!list_empty(&pagelist));\n\t/* TODO: tracepoints */\n}"
        }
      },
      {
        "call_info": {
          "callee": "khugepaged_find_target_node",
          "args": [],
          "line": 1607
        },
        "resolved": true,
        "details": {
          "function_name": "khugepaged_find_target_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "785-788",
          "snippet": "static int khugepaged_find_target_node(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic int khugepaged_find_target_node(void)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched_rcu",
          "args": [],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_pause",
          "args": [
            "&xas"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapcount",
          "args": [
            "page"
          ],
          "line": 1583
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "khugepaged_scan_abort",
          "args": [
            "node"
          ],
          "line": 1572
        },
        "resolved": true,
        "details": {
          "function_name": "khugepaged_scan_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "695-717",
          "snippet": "static bool khugepaged_scan_abort(int nid)\n{\n\tint i;\n\n\t/*\n\t * If node_reclaim_mode is disabled, then no extra effort is made to\n\t * allocate memory locally.\n\t */\n\tif (!node_reclaim_mode)\n\t\treturn false;\n\n\t/* If there is a count for this node already, it must be acceptable */\n\tif (khugepaged_node_load[nid])\n\t\treturn false;\n\n\tfor (i = 0; i < MAX_NUMNODES; i++) {\n\t\tif (!khugepaged_node_load[i])\n\t\t\tcontinue;\n\t\tif (node_distance(nid, i) > RECLAIM_DISTANCE)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int khugepaged_node_load[MAX_NUMNODES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic int khugepaged_node_load[MAX_NUMNODES];\n\nstatic bool khugepaged_scan_abort(int nid)\n{\n\tint i;\n\n\t/*\n\t * If node_reclaim_mode is disabled, then no extra effort is made to\n\t * allocate memory locally.\n\t */\n\tif (!node_reclaim_mode)\n\t\treturn false;\n\n\t/* If there is a count for this node already, it must be acceptable */\n\tif (khugepaged_node_load[nid])\n\t\treturn false;\n\n\tfor (i = 0; i < MAX_NUMNODES; i++) {\n\t\tif (!khugepaged_node_load[i])\n\t\t\tcontinue;\n\t\tif (node_distance(nid, i) > RECLAIM_DISTANCE)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 1571
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageTransCompound",
          "args": [
            "page"
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_is_value",
          "args": [
            "page"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_retry",
          "args": [
            "&xas",
            "page"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_for_each",
          "args": [
            "&xas",
            "page",
            "start + HPAGE_PMD_NR - 1"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "khugepaged_node_load",
            "0",
            "sizeof(khugepaged_node_load)"
          ],
          "line": 1552
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XA_STATE",
          "args": [
            "xas",
            "&mapping->i_pages",
            "start"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic unsigned int khugepaged_max_ptes_none;\nstatic unsigned int khugepaged_max_ptes_swap;\nstatic int khugepaged_node_load[MAX_NUMNODES];\n\nstatic void khugepaged_scan_shmem(struct mm_struct *mm,\n\t\tstruct address_space *mapping,\n\t\tpgoff_t start, struct page **hpage)\n{\n\tstruct page *page = NULL;\n\tXA_STATE(xas, &mapping->i_pages, start);\n\tint present, swap;\n\tint node = NUMA_NO_NODE;\n\tint result = SCAN_SUCCEED;\n\n\tpresent = 0;\n\tswap = 0;\n\tmemset(khugepaged_node_load, 0, sizeof(khugepaged_node_load));\n\trcu_read_lock();\n\txas_for_each(&xas, page, start + HPAGE_PMD_NR - 1) {\n\t\tif (xas_retry(&xas, page))\n\t\t\tcontinue;\n\n\t\tif (xa_is_value(page)) {\n\t\t\tif (++swap > khugepaged_max_ptes_swap) {\n\t\t\t\tresult = SCAN_EXCEED_SWAP_PTE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (PageTransCompound(page)) {\n\t\t\tresult = SCAN_PAGE_COMPOUND;\n\t\t\tbreak;\n\t\t}\n\n\t\tnode = page_to_nid(page);\n\t\tif (khugepaged_scan_abort(node)) {\n\t\t\tresult = SCAN_SCAN_ABORT;\n\t\t\tbreak;\n\t\t}\n\t\tkhugepaged_node_load[node]++;\n\n\t\tif (!PageLRU(page)) {\n\t\t\tresult = SCAN_PAGE_LRU;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (page_count(page) != 1 + page_mapcount(page)) {\n\t\t\tresult = SCAN_PAGE_COUNT;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * We probably should check if the page is referenced here, but\n\t\t * nobody would transfer pte_young() to PageReferenced() for us.\n\t\t * And rmap walk here is just too costly...\n\t\t */\n\n\t\tpresent++;\n\n\t\tif (need_resched()) {\n\t\t\txas_pause(&xas);\n\t\t\tcond_resched_rcu();\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (result == SCAN_SUCCEED) {\n\t\tif (present < HPAGE_PMD_NR - khugepaged_max_ptes_none) {\n\t\t\tresult = SCAN_EXCEED_NONE_PTE;\n\t\t} else {\n\t\t\tnode = khugepaged_find_target_node();\n\t\t\tcollapse_shmem(mm, mapping, start, hpage, node);\n\t\t}\n\t}\n\n\t/* TODO: tracepoints */\n}"
  },
  {
    "function_name": "collapse_shmem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "1304-1538",
    "snippet": "static void collapse_shmem(struct mm_struct *mm,\n\t\tstruct address_space *mapping, pgoff_t start,\n\t\tstruct page **hpage, int node)\n{\n\tgfp_t gfp;\n\tstruct page *new_page;\n\tstruct mem_cgroup *memcg;\n\tpgoff_t index, end = start + HPAGE_PMD_NR;\n\tLIST_HEAD(pagelist);\n\tXA_STATE_ORDER(xas, &mapping->i_pages, start, HPAGE_PMD_ORDER);\n\tint nr_none = 0, result = SCAN_SUCCEED;\n\n\tVM_BUG_ON(start & (HPAGE_PMD_NR - 1));\n\n\t/* Only allocate from the target node */\n\tgfp = alloc_hugepage_khugepaged_gfpmask() | __GFP_THISNODE;\n\n\tnew_page = khugepaged_alloc_page(hpage, gfp, node);\n\tif (!new_page) {\n\t\tresult = SCAN_ALLOC_HUGE_PAGE_FAIL;\n\t\tgoto out;\n\t}\n\n\tif (unlikely(mem_cgroup_try_charge(new_page, mm, gfp, &memcg, true))) {\n\t\tresult = SCAN_CGROUP_CHARGE_FAIL;\n\t\tgoto out;\n\t}\n\n\tnew_page->index = start;\n\tnew_page->mapping = mapping;\n\t__SetPageSwapBacked(new_page);\n\t__SetPageLocked(new_page);\n\tBUG_ON(!page_ref_freeze(new_page, 1));\n\n\t/*\n\t * At this point the new_page is 'frozen' (page_count() is zero),\n\t * locked and not up-to-date. It's safe to insert it into the page\n\t * cache, because nobody would be able to map it or use it in other\n\t * way until we unfreeze it.\n\t */\n\n\t/* This will be less messy when we use multi-index entries */\n\tdo {\n\t\txas_lock_irq(&xas);\n\t\txas_create_range(&xas);\n\t\tif (!xas_error(&xas))\n\t\t\tbreak;\n\t\txas_unlock_irq(&xas);\n\t\tif (!xas_nomem(&xas, GFP_KERNEL))\n\t\t\tgoto out;\n\t} while (1);\n\n\txas_set(&xas, start);\n\tfor (index = start; index < end; index++) {\n\t\tstruct page *page = xas_next(&xas);\n\n\t\tVM_BUG_ON(index != xas.xa_index);\n\t\tif (!page) {\n\t\t\tif (!shmem_charge(mapping->host, 1)) {\n\t\t\t\tresult = SCAN_FAIL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\txas_store(&xas, new_page + (index % HPAGE_PMD_NR));\n\t\t\tnr_none++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (xa_is_value(page) || !PageUptodate(page)) {\n\t\t\txas_unlock_irq(&xas);\n\t\t\t/* swap in or instantiate fallocated page */\n\t\t\tif (shmem_getpage(mapping->host, index, &page,\n\t\t\t\t\t\tSGP_NOHUGE)) {\n\t\t\t\tresult = SCAN_FAIL;\n\t\t\t\tgoto xa_unlocked;\n\t\t\t}\n\t\t\txas_lock_irq(&xas);\n\t\t\txas_set(&xas, index);\n\t\t} else if (trylock_page(page)) {\n\t\t\tget_page(page);\n\t\t} else {\n\t\t\tresult = SCAN_PAGE_LOCK;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * The page must be locked, so we can drop the i_pages lock\n\t\t * without racing with truncate.\n\t\t */\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\t\tVM_BUG_ON_PAGE(!PageUptodate(page), page);\n\t\tVM_BUG_ON_PAGE(PageTransCompound(page), page);\n\n\t\tif (page_mapping(page) != mapping) {\n\t\t\tresult = SCAN_TRUNCATED;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\txas_unlock_irq(&xas);\n\n\t\tif (isolate_lru_page(page)) {\n\t\t\tresult = SCAN_DEL_PAGE_LRU;\n\t\t\tgoto out_isolate_failed;\n\t\t}\n\n\t\tif (page_mapped(page))\n\t\t\tunmap_mapping_pages(mapping, index, 1, false);\n\n\t\txas_lock_irq(&xas);\n\t\txas_set(&xas, index);\n\n\t\tVM_BUG_ON_PAGE(page != xas_load(&xas), page);\n\t\tVM_BUG_ON_PAGE(page_mapped(page), page);\n\n\t\t/*\n\t\t * The page is expected to have page_count() == 3:\n\t\t *  - we hold a pin on it;\n\t\t *  - one reference from page cache;\n\t\t *  - one from isolate_lru_page;\n\t\t */\n\t\tif (!page_ref_freeze(page, 3)) {\n\t\t\tresult = SCAN_PAGE_COUNT;\n\t\t\tgoto out_lru;\n\t\t}\n\n\t\t/*\n\t\t * Add the page to the list to be able to undo the collapse if\n\t\t * something go wrong.\n\t\t */\n\t\tlist_add_tail(&page->lru, &pagelist);\n\n\t\t/* Finally, replace with the new page. */\n\t\txas_store(&xas, new_page + (index % HPAGE_PMD_NR));\n\t\tcontinue;\nout_lru:\n\t\txas_unlock_irq(&xas);\n\t\tputback_lru_page(page);\nout_isolate_failed:\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tgoto xa_unlocked;\nout_unlock:\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tbreak;\n\t}\n\txas_unlock_irq(&xas);\n\nxa_unlocked:\n\tif (result == SCAN_SUCCEED) {\n\t\tstruct page *page, *tmp;\n\t\tstruct zone *zone = page_zone(new_page);\n\n\t\t/*\n\t\t * Replacing old pages with new one has succeeded, now we\n\t\t * need to copy the content and free the old pages.\n\t\t */\n\t\tlist_for_each_entry_safe(page, tmp, &pagelist, lru) {\n\t\t\tcopy_highpage(new_page + (page->index % HPAGE_PMD_NR),\n\t\t\t\t\tpage);\n\t\t\tlist_del(&page->lru);\n\t\t\tunlock_page(page);\n\t\t\tpage_ref_unfreeze(page, 1);\n\t\t\tpage->mapping = NULL;\n\t\t\tClearPageActive(page);\n\t\t\tClearPageUnevictable(page);\n\t\t\tput_page(page);\n\t\t}\n\n\t\tlocal_irq_disable();\n\t\t__inc_node_page_state(new_page, NR_SHMEM_THPS);\n\t\tif (nr_none) {\n\t\t\t__mod_node_page_state(zone->zone_pgdat, NR_FILE_PAGES, nr_none);\n\t\t\t__mod_node_page_state(zone->zone_pgdat, NR_SHMEM, nr_none);\n\t\t}\n\t\tlocal_irq_enable();\n\n\t\t/*\n\t\t * Remove pte page tables, so we can re-fault\n\t\t * the page as huge.\n\t\t */\n\t\tretract_page_tables(mapping, start);\n\n\t\t/* Everything is ready, let's unfreeze the new_page */\n\t\tset_page_dirty(new_page);\n\t\tSetPageUptodate(new_page);\n\t\tpage_ref_unfreeze(new_page, HPAGE_PMD_NR);\n\t\tmem_cgroup_commit_charge(new_page, memcg, false, true);\n\t\tlru_cache_add_anon(new_page);\n\t\tunlock_page(new_page);\n\n\t\t*hpage = NULL;\n\n\t\tkhugepaged_pages_collapsed++;\n\t} else {\n\t\tstruct page *page;\n\t\t/* Something went wrong: roll back page cache changes */\n\t\tshmem_uncharge(mapping->host, nr_none);\n\t\txas_lock_irq(&xas);\n\t\txas_set(&xas, start);\n\t\txas_for_each(&xas, page, end - 1) {\n\t\t\tpage = list_first_entry_or_null(&pagelist,\n\t\t\t\t\tstruct page, lru);\n\t\t\tif (!page || xas.xa_index < page->index) {\n\t\t\t\tif (!nr_none)\n\t\t\t\t\tbreak;\n\t\t\t\tnr_none--;\n\t\t\t\t/* Put holes back where they were */\n\t\t\t\txas_store(&xas, NULL);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tVM_BUG_ON_PAGE(page->index != xas.xa_index, page);\n\n\t\t\t/* Unfreeze the page. */\n\t\t\tlist_del(&page->lru);\n\t\t\tpage_ref_unfreeze(page, 2);\n\t\t\txas_store(&xas, page);\n\t\t\txas_pause(&xas);\n\t\t\txas_unlock_irq(&xas);\n\t\t\tputback_lru_page(page);\n\t\t\tunlock_page(page);\n\t\t\txas_lock_irq(&xas);\n\t\t}\n\t\tVM_BUG_ON(nr_none);\n\t\txas_unlock_irq(&xas);\n\n\t\t/* Unfreeze new_page, caller would take care about freeing it */\n\t\tpage_ref_unfreeze(new_page, 1);\n\t\tmem_cgroup_cancel_charge(new_page, memcg, true);\n\t\tunlock_page(new_page);\n\t\tnew_page->mapping = NULL;\n\t}\nout:\n\tVM_BUG_ON(!list_empty(&pagelist));\n\t/* TODO: tracepoints */\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int khugepaged_pages_collapsed;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!list_empty(&pagelist)"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pagelist"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "new_page"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_cancel_charge",
          "args": [
            "new_page",
            "memcg",
            "true"
          ],
          "line": 1531
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_cancel_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5972-5988",
          "snippet": "void mem_cgroup_cancel_charge(struct page *page, struct mem_cgroup *memcg,\n\t\tbool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcancel_charge(memcg, nr_pages);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid mem_cgroup_cancel_charge(struct page *page, struct mem_cgroup *memcg,\n\t\tbool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcancel_charge(memcg, nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_ref_unfreeze",
          "args": [
            "new_page",
            "1"
          ],
          "line": 1530
        },
        "resolved": true,
        "details": {
          "function_name": "__page_ref_unfreeze",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/debug_page_ref.c",
          "lines": "50-53",
          "snippet": "void __page_ref_unfreeze(struct page *page, int v)\n{\n\ttrace_page_ref_unfreeze(page, v);\n}",
          "includes": [
            "#include <trace/events/page_ref.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/page_ref.h>\n#include <linux/tracepoint.h>\n#include <linux/mm_types.h>\n\nvoid __page_ref_unfreeze(struct page *page, int v)\n{\n\ttrace_page_ref_unfreeze(page, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xas_unlock_irq",
          "args": [
            "&xas"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "nr_none"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_lock_irq",
          "args": [
            "&xas"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "putback_lru_page",
          "args": [
            "page"
          ],
          "line": 1522
        },
        "resolved": true,
        "details": {
          "function_name": "putback_lru_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1005-1009",
          "snippet": "void putback_lru_page(struct page *page)\n{\n\tlru_cache_add(page);\n\tput_page(page);\t\t/* drop ref from isolate */\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid putback_lru_page(struct page *page)\n{\n\tlru_cache_add(page);\n\tput_page(page);\t\t/* drop ref from isolate */\n}"
        }
      },
      {
        "call_info": {
          "callee": "xas_unlock_irq",
          "args": [
            "&xas"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_pause",
          "args": [
            "&xas"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_store",
          "args": [
            "&xas",
            "page"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "page->index != xas.xa_index",
            "page"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_store",
          "args": [
            "&xas",
            "NULL"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry_or_null",
          "args": [
            "&pagelist",
            "structpage",
            "lru"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_for_each",
          "args": [
            "&xas",
            "page",
            "end - 1"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_set",
          "args": [
            "&xas",
            "start"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_lock_irq",
          "args": [
            "&xas"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shmem_uncharge",
          "args": [
            "mapping->host",
            "nr_none"
          ],
          "line": 1499
        },
        "resolved": true,
        "details": {
          "function_name": "shmem_uncharge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/shmem.c",
          "lines": "310-322",
          "snippet": "void shmem_uncharge(struct inode *inode, long pages)\n{\n\tstruct shmem_inode_info *info = SHMEM_I(inode);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&info->lock, flags);\n\tinfo->alloced -= pages;\n\tinode->i_blocks -= pages * BLOCKS_PER_PAGE;\n\tshmem_recalc_inode(inode);\n\tspin_unlock_irqrestore(&info->lock, flags);\n\n\tshmem_inode_unacct_blocks(inode, pages);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/uuid.h>",
            "#include <linux/rmap.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <uapi/linux/memfd.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/magic.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/highmem.h>",
            "#include <linux/migrate.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/swapops.h>",
            "#include <linux/security.h>",
            "#include <linux/splice.h>",
            "#include <linux/falloc.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/mman.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/xattr.h>",
            "#include <asm/tlbflush.h> /* for arch/microblaze update_mmu_cache() */",
            "#include <linux/hugetlb.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/uio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/random.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define BLOCKS_PER_PAGE  (PAGE_SIZE/512)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/uuid.h>\n#include <linux/rmap.h>\n#include <linux/userfaultfd_k.h>\n#include <uapi/linux/memfd.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/magic.h>\n#include <linux/seq_file.h>\n#include <linux/highmem.h>\n#include <linux/migrate.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/mempolicy.h>\n#include <linux/swapops.h>\n#include <linux/security.h>\n#include <linux/splice.h>\n#include <linux/falloc.h>\n#include <linux/percpu_counter.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/shmem_fs.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mman.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/exportfs.h>\n#include <linux/xattr.h>\n#include <asm/tlbflush.h> /* for arch/microblaze update_mmu_cache() */\n#include <linux/hugetlb.h>\n#include <linux/khugepaged.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/sched/signal.h>\n#include <linux/random.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/ramfs.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\n#define BLOCKS_PER_PAGE  (PAGE_SIZE/512)\n\nvoid shmem_uncharge(struct inode *inode, long pages)\n{\n\tstruct shmem_inode_info *info = SHMEM_I(inode);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&info->lock, flags);\n\tinfo->alloced -= pages;\n\tinode->i_blocks -= pages * BLOCKS_PER_PAGE;\n\tshmem_recalc_inode(inode);\n\tspin_unlock_irqrestore(&info->lock, flags);\n\n\tshmem_inode_unacct_blocks(inode, pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lru_cache_add_anon",
          "args": [
            "new_page"
          ],
          "line": 1490
        },
        "resolved": true,
        "details": {
          "function_name": "lru_cache_add_anon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "417-422",
          "snippet": "void lru_cache_add_anon(struct page *page)\n{\n\tif (PageActive(page))\n\t\tClearPageActive(page);\n\t__lru_cache_add(page);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid lru_cache_add_anon(struct page *page)\n{\n\tif (PageActive(page))\n\t\tClearPageActive(page);\n\t__lru_cache_add(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_commit_charge",
          "args": [
            "new_page",
            "memcg",
            "false",
            "true"
          ],
          "line": 1489
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_commit_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5928-5962",
          "snippet": "void mem_cgroup_commit_charge(struct page *page, struct mem_cgroup *memcg,\n\t\t\t      bool lrucare, bool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_PAGE(!page->mapping, page);\n\tVM_BUG_ON_PAGE(PageLRU(page) && !lrucare, page);\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcommit_charge(page, memcg, lrucare);\n\n\tlocal_irq_disable();\n\tmem_cgroup_charge_statistics(memcg, page, compound, nr_pages);\n\tmemcg_check_events(memcg, page);\n\tlocal_irq_enable();\n\n\tif (do_memsw_account() && PageSwapCache(page)) {\n\t\tswp_entry_t entry = { .val = page_private(page) };\n\t\t/*\n\t\t * The swap entry might not get freed for a long time,\n\t\t * let's not wait for it.  The page already received a\n\t\t * memory+swap charge, drop the swap entry duplicate.\n\t\t */\n\t\tmem_cgroup_uncharge_swap(entry, nr_pages);\n\t}\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid mem_cgroup_commit_charge(struct page *page, struct mem_cgroup *memcg,\n\t\t\t      bool lrucare, bool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_PAGE(!page->mapping, page);\n\tVM_BUG_ON_PAGE(PageLRU(page) && !lrucare, page);\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcommit_charge(page, memcg, lrucare);\n\n\tlocal_irq_disable();\n\tmem_cgroup_charge_statistics(memcg, page, compound, nr_pages);\n\tmemcg_check_events(memcg, page);\n\tlocal_irq_enable();\n\n\tif (do_memsw_account() && PageSwapCache(page)) {\n\t\tswp_entry_t entry = { .val = page_private(page) };\n\t\t/*\n\t\t * The swap entry might not get freed for a long time,\n\t\t * let's not wait for it.  The page already received a\n\t\t * memory+swap charge, drop the swap entry duplicate.\n\t\t */\n\t\tmem_cgroup_uncharge_swap(entry, nr_pages);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "new_page"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "new_page"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_dirty_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "2573-2581",
          "snippet": "int set_page_dirty_lock(struct page *page)\n{\n\tint ret;\n\n\tlock_page(page);\n\tret = set_page_dirty(page);\n\tunlock_page(page);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint set_page_dirty_lock(struct page *page)\n{\n\tint ret;\n\n\tlock_page(page);\n\tret = set_page_dirty(page);\n\tunlock_page(page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "retract_page_tables",
          "args": [
            "mapping",
            "start"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "retract_page_tables",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "1248-1284",
          "snippet": "static void retract_page_tables(struct address_space *mapping, pgoff_t pgoff)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned long addr;\n\tpmd_t *pmd, _pmd;\n\n\ti_mmap_lock_write(mapping);\n\tvma_interval_tree_foreach(vma, &mapping->i_mmap, pgoff, pgoff) {\n\t\t/* probably overkill */\n\t\tif (vma->anon_vma)\n\t\t\tcontinue;\n\t\taddr = vma->vm_start + ((pgoff - vma->vm_pgoff) << PAGE_SHIFT);\n\t\tif (addr & ~HPAGE_PMD_MASK)\n\t\t\tcontinue;\n\t\tif (vma->vm_end < addr + HPAGE_PMD_SIZE)\n\t\t\tcontinue;\n\t\tpmd = mm_find_pmd(vma->vm_mm, addr);\n\t\tif (!pmd)\n\t\t\tcontinue;\n\t\t/*\n\t\t * We need exclusive mmap_sem to retract page table.\n\t\t * If trylock fails we would end up with pte-mapped THP after\n\t\t * re-fault. Not ideal, but it's more important to not disturb\n\t\t * the system too much.\n\t\t */\n\t\tif (down_write_trylock(&vma->vm_mm->mmap_sem)) {\n\t\t\tspinlock_t *ptl = pmd_lock(vma->vm_mm, pmd);\n\t\t\t/* assume page table is clear */\n\t\t\t_pmd = pmdp_collapse_flush(vma, addr, pmd);\n\t\t\tspin_unlock(ptl);\n\t\t\tup_write(&vma->vm_mm->mmap_sem);\n\t\t\tmm_dec_nr_ptes(vma->vm_mm);\n\t\t\tpte_free(vma->vm_mm, pmd_pgtable(_pmd));\n\t\t}\n\t}\n\ti_mmap_unlock_write(mapping);\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void retract_page_tables(struct address_space *mapping, pgoff_t pgoff)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned long addr;\n\tpmd_t *pmd, _pmd;\n\n\ti_mmap_lock_write(mapping);\n\tvma_interval_tree_foreach(vma, &mapping->i_mmap, pgoff, pgoff) {\n\t\t/* probably overkill */\n\t\tif (vma->anon_vma)\n\t\t\tcontinue;\n\t\taddr = vma->vm_start + ((pgoff - vma->vm_pgoff) << PAGE_SHIFT);\n\t\tif (addr & ~HPAGE_PMD_MASK)\n\t\t\tcontinue;\n\t\tif (vma->vm_end < addr + HPAGE_PMD_SIZE)\n\t\t\tcontinue;\n\t\tpmd = mm_find_pmd(vma->vm_mm, addr);\n\t\tif (!pmd)\n\t\t\tcontinue;\n\t\t/*\n\t\t * We need exclusive mmap_sem to retract page table.\n\t\t * If trylock fails we would end up with pte-mapped THP after\n\t\t * re-fault. Not ideal, but it's more important to not disturb\n\t\t * the system too much.\n\t\t */\n\t\tif (down_write_trylock(&vma->vm_mm->mmap_sem)) {\n\t\t\tspinlock_t *ptl = pmd_lock(vma->vm_mm, pmd);\n\t\t\t/* assume page table is clear */\n\t\t\t_pmd = pmdp_collapse_flush(vma, addr, pmd);\n\t\t\tspin_unlock(ptl);\n\t\t\tup_write(&vma->vm_mm->mmap_sem);\n\t\t\tmm_dec_nr_ptes(vma->vm_mm);\n\t\t\tpte_free(vma->vm_mm, pmd_pgtable(_pmd));\n\t\t}\n\t}\n\ti_mmap_unlock_write(mapping);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mod_node_page_state",
          "args": [
            "zone->zone_pgdat",
            "NR_SHMEM",
            "nr_none"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "__mod_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "335-352",
          "snippet": "void __mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,\n\t\t\t\tlong delta)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\tlong x;\n\tlong t;\n\n\tx = delta + __this_cpu_read(*p);\n\n\tt = __this_cpu_read(pcp->stat_threshold);\n\n\tif (unlikely(x > t || x < -t)) {\n\t\tnode_page_state_add(x, pgdat, item);\n\t\tx = 0;\n\t}\n\t__this_cpu_write(*p, x);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item,\n\t\t\t\tlong delta)\n{\n\tstruct per_cpu_nodestat __percpu *pcp = pgdat->per_cpu_nodestats;\n\ts8 __percpu *p = pcp->vm_node_stat_diff + item;\n\tlong x;\n\tlong t;\n\n\tx = delta + __this_cpu_read(*p);\n\n\tt = __this_cpu_read(pcp->stat_threshold);\n\n\tif (unlikely(x > t || x < -t)) {\n\t\tnode_page_state_add(x, pgdat, item);\n\t\tx = 0;\n\t}\n\t__this_cpu_write(*p, x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__inc_node_page_state",
          "args": [
            "new_page",
            "NR_SHMEM_THPS"
          ],
          "line": 1472
        },
        "resolved": true,
        "details": {
          "function_name": "__inc_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "416-419",
          "snippet": "void __inc_node_page_state(struct page *page, enum node_stat_item item)\n{\n\t__inc_node_state(page_pgdat(page), item);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __inc_node_page_state(struct page *page, enum node_stat_item item)\n{\n\t__inc_node_state(page_pgdat(page), item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPageUnevictable",
          "args": [
            "page"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageActive",
          "args": [
            "page"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_highpage",
          "args": [
            "new_page + (page->index % HPAGE_PMD_NR)",
            "page"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "page",
            "tmp",
            "&pagelist",
            "lru"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "new_page"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_unlock_irq",
          "args": [
            "&xas"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_unlock_irq",
          "args": [
            "&xas"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_store",
          "args": [
            "&xas",
            "new_page + (index % HPAGE_PMD_NR)"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&page->lru",
            "&pagelist"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_ref_freeze",
          "args": [
            "page",
            "3"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "page_mapped(page)",
            "page"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapped",
          "args": [
            "page"
          ],
          "line": 1414
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "470-486",
          "snippet": "bool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nbool page_mapped(struct page *page)\n{\n\tint i;\n\n\tif (likely(!PageCompound(page)))\n\t\treturn atomic_read(&page->_mapcount) >= 0;\n\tpage = compound_head(page);\n\tif (atomic_read(compound_mapcount_ptr(page)) >= 0)\n\t\treturn true;\n\tif (PageHuge(page))\n\t\treturn false;\n\tfor (i = 0; i < hpage_nr_pages(page); i++) {\n\t\tif (atomic_read(&page[i]._mapcount) >= 0)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "page != xas_load(&xas)",
            "page"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_load",
          "args": [
            "&xas"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_set",
          "args": [
            "&xas",
            "index"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_lock_irq",
          "args": [
            "&xas"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_mapping_pages",
          "args": [
            "mapping",
            "index",
            "1",
            "false"
          ],
          "line": 1408
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_mapping_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "2596-2611",
          "snippet": "void unmap_mapping_pages(struct address_space *mapping, pgoff_t start,\n\t\tpgoff_t nr, bool even_cows)\n{\n\tstruct zap_details details = { };\n\n\tdetails.check_mapping = even_cows ? NULL : mapping;\n\tdetails.first_index = start;\n\tdetails.last_index = start + nr - 1;\n\tif (details.last_index < details.first_index)\n\t\tdetails.last_index = ULONG_MAX;\n\n\ti_mmap_lock_write(mapping);\n\tif (unlikely(!RB_EMPTY_ROOT(&mapping->i_mmap.rb_root)))\n\t\tunmap_mapping_range_tree(&mapping->i_mmap, &details);\n\ti_mmap_unlock_write(mapping);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvoid unmap_mapping_pages(struct address_space *mapping, pgoff_t start,\n\t\tpgoff_t nr, bool even_cows)\n{\n\tstruct zap_details details = { };\n\n\tdetails.check_mapping = even_cows ? NULL : mapping;\n\tdetails.first_index = start;\n\tdetails.last_index = start + nr - 1;\n\tif (details.last_index < details.first_index)\n\t\tdetails.last_index = ULONG_MAX;\n\n\ti_mmap_lock_write(mapping);\n\tif (unlikely(!RB_EMPTY_ROOT(&mapping->i_mmap.rb_root)))\n\t\tunmap_mapping_range_tree(&mapping->i_mmap, &details);\n\ti_mmap_unlock_write(mapping);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isolate_lru_page",
          "args": [
            "page"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "isolate_lru_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1772-1795",
          "snippet": "int isolate_lru_page(struct page *page)\n{\n\tint ret = -EBUSY;\n\n\tVM_BUG_ON_PAGE(!page_count(page), page);\n\tWARN_RATELIMIT(PageTail(page), \"trying to isolate tail page\");\n\n\tif (PageLRU(page)) {\n\t\tstruct zone *zone = page_zone(page);\n\t\tstruct lruvec *lruvec;\n\n\t\tspin_lock_irq(zone_lru_lock(zone));\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\t\tif (PageLRU(page)) {\n\t\t\tint lru = page_lru(page);\n\t\t\tget_page(page);\n\t\t\tClearPageLRU(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, lru);\n\t\t\tret = 0;\n\t\t}\n\t\tspin_unlock_irq(zone_lru_lock(zone));\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint isolate_lru_page(struct page *page)\n{\n\tint ret = -EBUSY;\n\n\tVM_BUG_ON_PAGE(!page_count(page), page);\n\tWARN_RATELIMIT(PageTail(page), \"trying to isolate tail page\");\n\n\tif (PageLRU(page)) {\n\t\tstruct zone *zone = page_zone(page);\n\t\tstruct lruvec *lruvec;\n\n\t\tspin_lock_irq(zone_lru_lock(zone));\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\t\tif (PageLRU(page)) {\n\t\t\tint lru = page_lru(page);\n\t\t\tget_page(page);\n\t\t\tClearPageLRU(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, lru);\n\t\t\tret = 0;\n\t\t}\n\t\tspin_unlock_irq(zone_lru_lock(zone));\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xas_unlock_irq",
          "args": [
            "&xas"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "page"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "page_mapping_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "528-533",
          "snippet": "struct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct address_space *page_mapping_file(struct page *page)\n{\n\tif (unlikely(PageSwapCache(page)))\n\t\treturn NULL;\n\treturn page_mapping(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageTransCompound(page)",
            "page"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTransCompound",
          "args": [
            "page"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageUptodate(page)",
            "page"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLocked(page)",
            "page"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "page"
          ],
          "line": 1382
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_get_page_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "247-250",
          "snippet": "static struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic struct pcpu_chunk *pcpu_get_page_chunk(struct page *page)\n{\n\treturn (struct pcpu_chunk *)page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_set",
          "args": [
            "&xas",
            "index"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_lock_irq",
          "args": [
            "&xas"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shmem_getpage",
          "args": [
            "mapping->host",
            "index",
            "&page",
            "SGP_NOHUGE"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "shmem_getpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/shmem.c",
          "lines": "129-134",
          "snippet": "int shmem_getpage(struct inode *inode, pgoff_t index,\n\t\tstruct page **pagep, enum sgp_type sgp)\n{\n\treturn shmem_getpage_gfp(inode, index, pagep, sgp,\n\t\tmapping_gfp_mask(inode->i_mapping), NULL, NULL, NULL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/uuid.h>",
            "#include <linux/rmap.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <uapi/linux/memfd.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/magic.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/highmem.h>",
            "#include <linux/migrate.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/swapops.h>",
            "#include <linux/security.h>",
            "#include <linux/splice.h>",
            "#include <linux/falloc.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/mman.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/xattr.h>",
            "#include <asm/tlbflush.h> /* for arch/microblaze update_mmu_cache() */",
            "#include <linux/hugetlb.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/uio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/random.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/uuid.h>\n#include <linux/rmap.h>\n#include <linux/userfaultfd_k.h>\n#include <uapi/linux/memfd.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/magic.h>\n#include <linux/seq_file.h>\n#include <linux/highmem.h>\n#include <linux/migrate.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/mempolicy.h>\n#include <linux/swapops.h>\n#include <linux/security.h>\n#include <linux/splice.h>\n#include <linux/falloc.h>\n#include <linux/percpu_counter.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/shmem_fs.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mman.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/exportfs.h>\n#include <linux/xattr.h>\n#include <asm/tlbflush.h> /* for arch/microblaze update_mmu_cache() */\n#include <linux/hugetlb.h>\n#include <linux/khugepaged.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/sched/signal.h>\n#include <linux/random.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/ramfs.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint shmem_getpage(struct inode *inode, pgoff_t index,\n\t\tstruct page **pagep, enum sgp_type sgp)\n{\n\treturn shmem_getpage_gfp(inode, index, pagep, sgp,\n\t\tmapping_gfp_mask(inode->i_mapping), NULL, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xas_unlock_irq",
          "args": [
            "&xas"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_is_value",
          "args": [
            "page"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_store",
          "args": [
            "&xas",
            "new_page + (index % HPAGE_PMD_NR)"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shmem_charge",
          "args": [
            "mapping->host",
            "1"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "shmem_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/shmem.c",
          "lines": "292-308",
          "snippet": "bool shmem_charge(struct inode *inode, long pages)\n{\n\tstruct shmem_inode_info *info = SHMEM_I(inode);\n\tunsigned long flags;\n\n\tif (!shmem_inode_acct_block(inode, pages))\n\t\treturn false;\n\n\tspin_lock_irqsave(&info->lock, flags);\n\tinfo->alloced += pages;\n\tinode->i_blocks += pages * BLOCKS_PER_PAGE;\n\tshmem_recalc_inode(inode);\n\tspin_unlock_irqrestore(&info->lock, flags);\n\tinode->i_mapping->nrpages += pages;\n\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/uuid.h>",
            "#include <linux/rmap.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <uapi/linux/memfd.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/magic.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/highmem.h>",
            "#include <linux/migrate.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/swapops.h>",
            "#include <linux/security.h>",
            "#include <linux/splice.h>",
            "#include <linux/falloc.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/mman.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/xattr.h>",
            "#include <asm/tlbflush.h> /* for arch/microblaze update_mmu_cache() */",
            "#include <linux/hugetlb.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/uio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/random.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/ramfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define BLOCKS_PER_PAGE  (PAGE_SIZE/512)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/uuid.h>\n#include <linux/rmap.h>\n#include <linux/userfaultfd_k.h>\n#include <uapi/linux/memfd.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/magic.h>\n#include <linux/seq_file.h>\n#include <linux/highmem.h>\n#include <linux/migrate.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/mempolicy.h>\n#include <linux/swapops.h>\n#include <linux/security.h>\n#include <linux/splice.h>\n#include <linux/falloc.h>\n#include <linux/percpu_counter.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/shmem_fs.h>\n#include <linux/backing-dev.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mman.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/exportfs.h>\n#include <linux/xattr.h>\n#include <asm/tlbflush.h> /* for arch/microblaze update_mmu_cache() */\n#include <linux/hugetlb.h>\n#include <linux/khugepaged.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/sched/signal.h>\n#include <linux/random.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/ramfs.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\n#define BLOCKS_PER_PAGE  (PAGE_SIZE/512)\n\nbool shmem_charge(struct inode *inode, long pages)\n{\n\tstruct shmem_inode_info *info = SHMEM_I(inode);\n\tunsigned long flags;\n\n\tif (!shmem_inode_acct_block(inode, pages))\n\t\treturn false;\n\n\tspin_lock_irqsave(&info->lock, flags);\n\tinfo->alloced += pages;\n\tinode->i_blocks += pages * BLOCKS_PER_PAGE;\n\tshmem_recalc_inode(inode);\n\tspin_unlock_irqrestore(&info->lock, flags);\n\tinode->i_mapping->nrpages += pages;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "index != xas.xa_index"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_next",
          "args": [
            "&xas"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_set",
          "args": [
            "&xas",
            "start"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_nomem",
          "args": [
            "&xas",
            "GFP_KERNEL"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_unlock_irq",
          "args": [
            "&xas"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_error",
          "args": [
            "&xas"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_create_range",
          "args": [
            "&xas"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_lock_irq",
          "args": [
            "&xas"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!page_ref_freeze(new_page, 1)"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_ref_freeze",
          "args": [
            "new_page",
            "1"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__SetPageLocked",
          "args": [
            "new_page"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__SetPageSwapBacked",
          "args": [
            "new_page"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "mem_cgroup_try_charge(new_page, mm, gfp, &memcg, true)"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_try_charge",
          "args": [
            "new_page",
            "mm",
            "gfp",
            "&memcg",
            "true"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_try_charge_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5898-5909",
          "snippet": "int mem_cgroup_try_charge_delay(struct page *page, struct mm_struct *mm,\n\t\t\t  gfp_t gfp_mask, struct mem_cgroup **memcgp,\n\t\t\t  bool compound)\n{\n\tstruct mem_cgroup *memcg;\n\tint ret;\n\n\tret = mem_cgroup_try_charge(page, mm, gfp_mask, memcgp, compound);\n\tmemcg = *memcgp;\n\tmem_cgroup_throttle_swaprate(memcg, page_to_nid(page), gfp_mask);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nint mem_cgroup_try_charge_delay(struct page *page, struct mm_struct *mm,\n\t\t\t  gfp_t gfp_mask, struct mem_cgroup **memcgp,\n\t\t\t  bool compound)\n{\n\tstruct mem_cgroup *memcg;\n\tint ret;\n\n\tret = mem_cgroup_try_charge(page, mm, gfp_mask, memcgp, compound);\n\tmemcg = *memcgp;\n\tmem_cgroup_throttle_swaprate(memcg, page_to_nid(page), gfp_mask);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "khugepaged_alloc_page",
          "args": [
            "hpage",
            "gfp",
            "node"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "khugepaged_alloc_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "832-838",
          "snippet": "static struct page *\nkhugepaged_alloc_page(struct page **hpage, gfp_t gfp, int node)\n{\n\tVM_BUG_ON(!*hpage);\n\n\treturn  *hpage;\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic struct page *\nkhugepaged_alloc_page(struct page **hpage, gfp_t gfp, int node)\n{\n\tVM_BUG_ON(!*hpage);\n\n\treturn  *hpage;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_hugepage_khugepaged_gfpmask",
          "args": [],
          "line": 1319
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_hugepage_khugepaged_gfpmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "720-723",
          "snippet": "static inline gfp_t alloc_hugepage_khugepaged_gfpmask(void)\n{\n\treturn khugepaged_defrag() ? GFP_TRANSHUGE : GFP_TRANSHUGE_LIGHT;\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic inline gfp_t alloc_hugepage_khugepaged_gfpmask(void)\n{\n\treturn khugepaged_defrag() ? GFP_TRANSHUGE : GFP_TRANSHUGE_LIGHT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "start & (HPAGE_PMD_NR - 1)"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XA_STATE_ORDER",
          "args": [
            "xas",
            "&mapping->i_pages",
            "start",
            "HPAGE_PMD_ORDER"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "pagelist"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic unsigned int khugepaged_pages_collapsed;\n\nstatic void collapse_shmem(struct mm_struct *mm,\n\t\tstruct address_space *mapping, pgoff_t start,\n\t\tstruct page **hpage, int node)\n{\n\tgfp_t gfp;\n\tstruct page *new_page;\n\tstruct mem_cgroup *memcg;\n\tpgoff_t index, end = start + HPAGE_PMD_NR;\n\tLIST_HEAD(pagelist);\n\tXA_STATE_ORDER(xas, &mapping->i_pages, start, HPAGE_PMD_ORDER);\n\tint nr_none = 0, result = SCAN_SUCCEED;\n\n\tVM_BUG_ON(start & (HPAGE_PMD_NR - 1));\n\n\t/* Only allocate from the target node */\n\tgfp = alloc_hugepage_khugepaged_gfpmask() | __GFP_THISNODE;\n\n\tnew_page = khugepaged_alloc_page(hpage, gfp, node);\n\tif (!new_page) {\n\t\tresult = SCAN_ALLOC_HUGE_PAGE_FAIL;\n\t\tgoto out;\n\t}\n\n\tif (unlikely(mem_cgroup_try_charge(new_page, mm, gfp, &memcg, true))) {\n\t\tresult = SCAN_CGROUP_CHARGE_FAIL;\n\t\tgoto out;\n\t}\n\n\tnew_page->index = start;\n\tnew_page->mapping = mapping;\n\t__SetPageSwapBacked(new_page);\n\t__SetPageLocked(new_page);\n\tBUG_ON(!page_ref_freeze(new_page, 1));\n\n\t/*\n\t * At this point the new_page is 'frozen' (page_count() is zero),\n\t * locked and not up-to-date. It's safe to insert it into the page\n\t * cache, because nobody would be able to map it or use it in other\n\t * way until we unfreeze it.\n\t */\n\n\t/* This will be less messy when we use multi-index entries */\n\tdo {\n\t\txas_lock_irq(&xas);\n\t\txas_create_range(&xas);\n\t\tif (!xas_error(&xas))\n\t\t\tbreak;\n\t\txas_unlock_irq(&xas);\n\t\tif (!xas_nomem(&xas, GFP_KERNEL))\n\t\t\tgoto out;\n\t} while (1);\n\n\txas_set(&xas, start);\n\tfor (index = start; index < end; index++) {\n\t\tstruct page *page = xas_next(&xas);\n\n\t\tVM_BUG_ON(index != xas.xa_index);\n\t\tif (!page) {\n\t\t\tif (!shmem_charge(mapping->host, 1)) {\n\t\t\t\tresult = SCAN_FAIL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\txas_store(&xas, new_page + (index % HPAGE_PMD_NR));\n\t\t\tnr_none++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (xa_is_value(page) || !PageUptodate(page)) {\n\t\t\txas_unlock_irq(&xas);\n\t\t\t/* swap in or instantiate fallocated page */\n\t\t\tif (shmem_getpage(mapping->host, index, &page,\n\t\t\t\t\t\tSGP_NOHUGE)) {\n\t\t\t\tresult = SCAN_FAIL;\n\t\t\t\tgoto xa_unlocked;\n\t\t\t}\n\t\t\txas_lock_irq(&xas);\n\t\t\txas_set(&xas, index);\n\t\t} else if (trylock_page(page)) {\n\t\t\tget_page(page);\n\t\t} else {\n\t\t\tresult = SCAN_PAGE_LOCK;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * The page must be locked, so we can drop the i_pages lock\n\t\t * without racing with truncate.\n\t\t */\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\t\tVM_BUG_ON_PAGE(!PageUptodate(page), page);\n\t\tVM_BUG_ON_PAGE(PageTransCompound(page), page);\n\n\t\tif (page_mapping(page) != mapping) {\n\t\t\tresult = SCAN_TRUNCATED;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\txas_unlock_irq(&xas);\n\n\t\tif (isolate_lru_page(page)) {\n\t\t\tresult = SCAN_DEL_PAGE_LRU;\n\t\t\tgoto out_isolate_failed;\n\t\t}\n\n\t\tif (page_mapped(page))\n\t\t\tunmap_mapping_pages(mapping, index, 1, false);\n\n\t\txas_lock_irq(&xas);\n\t\txas_set(&xas, index);\n\n\t\tVM_BUG_ON_PAGE(page != xas_load(&xas), page);\n\t\tVM_BUG_ON_PAGE(page_mapped(page), page);\n\n\t\t/*\n\t\t * The page is expected to have page_count() == 3:\n\t\t *  - we hold a pin on it;\n\t\t *  - one reference from page cache;\n\t\t *  - one from isolate_lru_page;\n\t\t */\n\t\tif (!page_ref_freeze(page, 3)) {\n\t\t\tresult = SCAN_PAGE_COUNT;\n\t\t\tgoto out_lru;\n\t\t}\n\n\t\t/*\n\t\t * Add the page to the list to be able to undo the collapse if\n\t\t * something go wrong.\n\t\t */\n\t\tlist_add_tail(&page->lru, &pagelist);\n\n\t\t/* Finally, replace with the new page. */\n\t\txas_store(&xas, new_page + (index % HPAGE_PMD_NR));\n\t\tcontinue;\nout_lru:\n\t\txas_unlock_irq(&xas);\n\t\tputback_lru_page(page);\nout_isolate_failed:\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tgoto xa_unlocked;\nout_unlock:\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tbreak;\n\t}\n\txas_unlock_irq(&xas);\n\nxa_unlocked:\n\tif (result == SCAN_SUCCEED) {\n\t\tstruct page *page, *tmp;\n\t\tstruct zone *zone = page_zone(new_page);\n\n\t\t/*\n\t\t * Replacing old pages with new one has succeeded, now we\n\t\t * need to copy the content and free the old pages.\n\t\t */\n\t\tlist_for_each_entry_safe(page, tmp, &pagelist, lru) {\n\t\t\tcopy_highpage(new_page + (page->index % HPAGE_PMD_NR),\n\t\t\t\t\tpage);\n\t\t\tlist_del(&page->lru);\n\t\t\tunlock_page(page);\n\t\t\tpage_ref_unfreeze(page, 1);\n\t\t\tpage->mapping = NULL;\n\t\t\tClearPageActive(page);\n\t\t\tClearPageUnevictable(page);\n\t\t\tput_page(page);\n\t\t}\n\n\t\tlocal_irq_disable();\n\t\t__inc_node_page_state(new_page, NR_SHMEM_THPS);\n\t\tif (nr_none) {\n\t\t\t__mod_node_page_state(zone->zone_pgdat, NR_FILE_PAGES, nr_none);\n\t\t\t__mod_node_page_state(zone->zone_pgdat, NR_SHMEM, nr_none);\n\t\t}\n\t\tlocal_irq_enable();\n\n\t\t/*\n\t\t * Remove pte page tables, so we can re-fault\n\t\t * the page as huge.\n\t\t */\n\t\tretract_page_tables(mapping, start);\n\n\t\t/* Everything is ready, let's unfreeze the new_page */\n\t\tset_page_dirty(new_page);\n\t\tSetPageUptodate(new_page);\n\t\tpage_ref_unfreeze(new_page, HPAGE_PMD_NR);\n\t\tmem_cgroup_commit_charge(new_page, memcg, false, true);\n\t\tlru_cache_add_anon(new_page);\n\t\tunlock_page(new_page);\n\n\t\t*hpage = NULL;\n\n\t\tkhugepaged_pages_collapsed++;\n\t} else {\n\t\tstruct page *page;\n\t\t/* Something went wrong: roll back page cache changes */\n\t\tshmem_uncharge(mapping->host, nr_none);\n\t\txas_lock_irq(&xas);\n\t\txas_set(&xas, start);\n\t\txas_for_each(&xas, page, end - 1) {\n\t\t\tpage = list_first_entry_or_null(&pagelist,\n\t\t\t\t\tstruct page, lru);\n\t\t\tif (!page || xas.xa_index < page->index) {\n\t\t\t\tif (!nr_none)\n\t\t\t\t\tbreak;\n\t\t\t\tnr_none--;\n\t\t\t\t/* Put holes back where they were */\n\t\t\t\txas_store(&xas, NULL);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tVM_BUG_ON_PAGE(page->index != xas.xa_index, page);\n\n\t\t\t/* Unfreeze the page. */\n\t\t\tlist_del(&page->lru);\n\t\t\tpage_ref_unfreeze(page, 2);\n\t\t\txas_store(&xas, page);\n\t\t\txas_pause(&xas);\n\t\t\txas_unlock_irq(&xas);\n\t\t\tputback_lru_page(page);\n\t\t\tunlock_page(page);\n\t\t\txas_lock_irq(&xas);\n\t\t}\n\t\tVM_BUG_ON(nr_none);\n\t\txas_unlock_irq(&xas);\n\n\t\t/* Unfreeze new_page, caller would take care about freeing it */\n\t\tpage_ref_unfreeze(new_page, 1);\n\t\tmem_cgroup_cancel_charge(new_page, memcg, true);\n\t\tunlock_page(new_page);\n\t\tnew_page->mapping = NULL;\n\t}\nout:\n\tVM_BUG_ON(!list_empty(&pagelist));\n\t/* TODO: tracepoints */\n}"
  },
  {
    "function_name": "retract_page_tables",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "1248-1284",
    "snippet": "static void retract_page_tables(struct address_space *mapping, pgoff_t pgoff)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned long addr;\n\tpmd_t *pmd, _pmd;\n\n\ti_mmap_lock_write(mapping);\n\tvma_interval_tree_foreach(vma, &mapping->i_mmap, pgoff, pgoff) {\n\t\t/* probably overkill */\n\t\tif (vma->anon_vma)\n\t\t\tcontinue;\n\t\taddr = vma->vm_start + ((pgoff - vma->vm_pgoff) << PAGE_SHIFT);\n\t\tif (addr & ~HPAGE_PMD_MASK)\n\t\t\tcontinue;\n\t\tif (vma->vm_end < addr + HPAGE_PMD_SIZE)\n\t\t\tcontinue;\n\t\tpmd = mm_find_pmd(vma->vm_mm, addr);\n\t\tif (!pmd)\n\t\t\tcontinue;\n\t\t/*\n\t\t * We need exclusive mmap_sem to retract page table.\n\t\t * If trylock fails we would end up with pte-mapped THP after\n\t\t * re-fault. Not ideal, but it's more important to not disturb\n\t\t * the system too much.\n\t\t */\n\t\tif (down_write_trylock(&vma->vm_mm->mmap_sem)) {\n\t\t\tspinlock_t *ptl = pmd_lock(vma->vm_mm, pmd);\n\t\t\t/* assume page table is clear */\n\t\t\t_pmd = pmdp_collapse_flush(vma, addr, pmd);\n\t\t\tspin_unlock(ptl);\n\t\t\tup_write(&vma->vm_mm->mmap_sem);\n\t\t\tmm_dec_nr_ptes(vma->vm_mm);\n\t\t\tpte_free(vma->vm_mm, pmd_pgtable(_pmd));\n\t\t}\n\t}\n\ti_mmap_unlock_write(mapping);\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i_mmap_unlock_write",
          "args": [
            "mapping"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_free",
          "args": [
            "vma->vm_mm",
            "pmd_pgtable(_pmd)"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_pgtable",
          "args": [
            "_pmd"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_dec_nr_ptes",
          "args": [
            "vma->vm_mm"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&vma->vm_mm->mmap_sem"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmdp_collapse_flush",
          "args": [
            "vma",
            "addr",
            "pmd"
          ],
          "line": 1276
        },
        "resolved": true,
        "details": {
          "function_name": "pmdp_collapse_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pgtable-generic.c",
          "lines": "195-211",
          "snippet": "pmd_t pmdp_collapse_flush(struct vm_area_struct *vma, unsigned long address,\n\t\t\t  pmd_t *pmdp)\n{\n\t/*\n\t * pmd and hugepage pte format are same. So we could\n\t * use the same function.\n\t */\n\tpmd_t pmd;\n\n\tVM_BUG_ON(address & ~HPAGE_PMD_MASK);\n\tVM_BUG_ON(pmd_trans_huge(*pmdp));\n\tpmd = pmdp_huge_get_and_clear(vma->vm_mm, address, pmdp);\n\n\t/* collapse entails shooting down ptes not pmd */\n\tflush_tlb_range(vma, address, address + HPAGE_PMD_SIZE);\n\treturn pmd;\n}",
          "includes": [
            "#include <asm-generic/pgtable.h>",
            "#include <asm/tlb.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm-generic/pgtable.h>\n#include <asm/tlb.h>\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n\npmd_t pmdp_collapse_flush(struct vm_area_struct *vma, unsigned long address,\n\t\t\t  pmd_t *pmdp)\n{\n\t/*\n\t * pmd and hugepage pte format are same. So we could\n\t * use the same function.\n\t */\n\tpmd_t pmd;\n\n\tVM_BUG_ON(address & ~HPAGE_PMD_MASK);\n\tVM_BUG_ON(pmd_trans_huge(*pmdp));\n\tpmd = pmdp_huge_get_and_clear(vma->vm_mm, address, pmdp);\n\n\t/* collapse entails shooting down ptes not pmd */\n\tflush_tlb_range(vma, address, address + HPAGE_PMD_SIZE);\n\treturn pmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_lock",
          "args": [
            "vma->vm_mm",
            "pmd"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write_trylock",
          "args": [
            "&vma->vm_mm->mmap_sem"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_find_pmd",
          "args": [
            "vma->vm_mm",
            "addr"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "mm_find_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "710-742",
          "snippet": "pmd_t *mm_find_pmd(struct mm_struct *mm, unsigned long address)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd = NULL;\n\tpmd_t pmde;\n\n\tpgd = pgd_offset(mm, address);\n\tif (!pgd_present(*pgd))\n\t\tgoto out;\n\n\tp4d = p4d_offset(pgd, address);\n\tif (!p4d_present(*p4d))\n\t\tgoto out;\n\n\tpud = pud_offset(p4d, address);\n\tif (!pud_present(*pud))\n\t\tgoto out;\n\n\tpmd = pmd_offset(pud, address);\n\t/*\n\t * Some THP functions use the sequence pmdp_huge_clear_flush(), set_pmd_at()\n\t * without holding anon_vma lock for write.  So when looking for a\n\t * genuine pmde (in which to find pte), test present and !THP together.\n\t */\n\tpmde = *pmd;\n\tbarrier();\n\tif (!pmd_present(pmde) || pmd_trans_huge(pmde))\n\t\tpmd = NULL;\nout:\n\treturn pmd;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\npmd_t *mm_find_pmd(struct mm_struct *mm, unsigned long address)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd = NULL;\n\tpmd_t pmde;\n\n\tpgd = pgd_offset(mm, address);\n\tif (!pgd_present(*pgd))\n\t\tgoto out;\n\n\tp4d = p4d_offset(pgd, address);\n\tif (!p4d_present(*p4d))\n\t\tgoto out;\n\n\tpud = pud_offset(p4d, address);\n\tif (!pud_present(*pud))\n\t\tgoto out;\n\n\tpmd = pmd_offset(pud, address);\n\t/*\n\t * Some THP functions use the sequence pmdp_huge_clear_flush(), set_pmd_at()\n\t * without holding anon_vma lock for write.  So when looking for a\n\t * genuine pmde (in which to find pte), test present and !THP together.\n\t */\n\tpmde = *pmd;\n\tbarrier();\n\tif (!pmd_present(pmde) || pmd_trans_huge(pmde))\n\t\tpmd = NULL;\nout:\n\treturn pmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_interval_tree_foreach",
          "args": [
            "vma",
            "&mapping->i_mmap",
            "pgoff",
            "pgoff"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_mmap_lock_write",
          "args": [
            "mapping"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void retract_page_tables(struct address_space *mapping, pgoff_t pgoff)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned long addr;\n\tpmd_t *pmd, _pmd;\n\n\ti_mmap_lock_write(mapping);\n\tvma_interval_tree_foreach(vma, &mapping->i_mmap, pgoff, pgoff) {\n\t\t/* probably overkill */\n\t\tif (vma->anon_vma)\n\t\t\tcontinue;\n\t\taddr = vma->vm_start + ((pgoff - vma->vm_pgoff) << PAGE_SHIFT);\n\t\tif (addr & ~HPAGE_PMD_MASK)\n\t\t\tcontinue;\n\t\tif (vma->vm_end < addr + HPAGE_PMD_SIZE)\n\t\t\tcontinue;\n\t\tpmd = mm_find_pmd(vma->vm_mm, addr);\n\t\tif (!pmd)\n\t\t\tcontinue;\n\t\t/*\n\t\t * We need exclusive mmap_sem to retract page table.\n\t\t * If trylock fails we would end up with pte-mapped THP after\n\t\t * re-fault. Not ideal, but it's more important to not disturb\n\t\t * the system too much.\n\t\t */\n\t\tif (down_write_trylock(&vma->vm_mm->mmap_sem)) {\n\t\t\tspinlock_t *ptl = pmd_lock(vma->vm_mm, pmd);\n\t\t\t/* assume page table is clear */\n\t\t\t_pmd = pmdp_collapse_flush(vma, addr, pmd);\n\t\t\tspin_unlock(ptl);\n\t\t\tup_write(&vma->vm_mm->mmap_sem);\n\t\t\tmm_dec_nr_ptes(vma->vm_mm);\n\t\t\tpte_free(vma->vm_mm, pmd_pgtable(_pmd));\n\t\t}\n\t}\n\ti_mmap_unlock_write(mapping);\n}"
  },
  {
    "function_name": "collect_mm_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "1224-1245",
    "snippet": "static void collect_mm_slot(struct mm_slot *mm_slot)\n{\n\tstruct mm_struct *mm = mm_slot->mm;\n\n\tVM_BUG_ON(NR_CPUS != 1 && !spin_is_locked(&khugepaged_mm_lock));\n\n\tif (khugepaged_test_exit(mm)) {\n\t\t/* free mm_slot */\n\t\thash_del(&mm_slot->hash);\n\t\tlist_del(&mm_slot->mm_node);\n\n\t\t/*\n\t\t * Not strictly needed because the mm exited already.\n\t\t *\n\t\t * clear_bit(MMF_VM_HUGEPAGE, &mm->flags);\n\t\t */\n\n\t\t/* khugepaged_mm_lock actually not necessary for the below */\n\t\tfree_mm_slot(mm_slot);\n\t\tmmdrop(mm);\n\t}\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(khugepaged_mm_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmdrop",
          "args": [
            "mm"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_mm_slot",
          "args": [
            "mm_slot"
          ],
          "line": 1242
        },
        "resolved": true,
        "details": {
          "function_name": "free_mm_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "372-375",
          "snippet": "static inline void free_mm_slot(struct mm_slot *mm_slot)\n{\n\tkmem_cache_free(mm_slot_cache, mm_slot);\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *mm_slot_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic struct kmem_cache *mm_slot_cache;\n\nstatic inline void free_mm_slot(struct mm_slot *mm_slot)\n{\n\tkmem_cache_free(mm_slot_cache, mm_slot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&mm_slot->mm_node"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_del",
          "args": [
            "&mm_slot->hash"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "khugepaged_test_exit",
          "args": [
            "mm"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "khugepaged_test_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "395-398",
          "snippet": "static inline int khugepaged_test_exit(struct mm_struct *mm)\n{\n\treturn atomic_read(&mm->mm_users) == 0;\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic inline int khugepaged_test_exit(struct mm_struct *mm)\n{\n\treturn atomic_read(&mm->mm_users) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "NR_CPUS != 1 && !spin_is_locked(&khugepaged_mm_lock)"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_is_locked",
          "args": [
            "&khugepaged_mm_lock"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_SPINLOCK(khugepaged_mm_lock);\n\nstatic void collect_mm_slot(struct mm_slot *mm_slot)\n{\n\tstruct mm_struct *mm = mm_slot->mm;\n\n\tVM_BUG_ON(NR_CPUS != 1 && !spin_is_locked(&khugepaged_mm_lock));\n\n\tif (khugepaged_test_exit(mm)) {\n\t\t/* free mm_slot */\n\t\thash_del(&mm_slot->hash);\n\t\tlist_del(&mm_slot->mm_node);\n\n\t\t/*\n\t\t * Not strictly needed because the mm exited already.\n\t\t *\n\t\t * clear_bit(MMF_VM_HUGEPAGE, &mm->flags);\n\t\t */\n\n\t\t/* khugepaged_mm_lock actually not necessary for the below */\n\t\tfree_mm_slot(mm_slot);\n\t\tmmdrop(mm);\n\t}\n}"
  },
  {
    "function_name": "khugepaged_scan_pmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "1099-1222",
    "snippet": "static int khugepaged_scan_pmd(struct mm_struct *mm,\n\t\t\t       struct vm_area_struct *vma,\n\t\t\t       unsigned long address,\n\t\t\t       struct page **hpage)\n{\n\tpmd_t *pmd;\n\tpte_t *pte, *_pte;\n\tint ret = 0, none_or_zero = 0, result = 0, referenced = 0;\n\tstruct page *page = NULL;\n\tunsigned long _address;\n\tspinlock_t *ptl;\n\tint node = NUMA_NO_NODE, unmapped = 0;\n\tbool writable = false;\n\n\tVM_BUG_ON(address & ~HPAGE_PMD_MASK);\n\n\tpmd = mm_find_pmd(mm, address);\n\tif (!pmd) {\n\t\tresult = SCAN_PMD_NULL;\n\t\tgoto out;\n\t}\n\n\tmemset(khugepaged_node_load, 0, sizeof(khugepaged_node_load));\n\tpte = pte_offset_map_lock(mm, pmd, address, &ptl);\n\tfor (_address = address, _pte = pte; _pte < pte+HPAGE_PMD_NR;\n\t     _pte++, _address += PAGE_SIZE) {\n\t\tpte_t pteval = *_pte;\n\t\tif (is_swap_pte(pteval)) {\n\t\t\tif (++unmapped <= khugepaged_max_ptes_swap) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tresult = SCAN_EXCEED_SWAP_PTE;\n\t\t\t\tgoto out_unmap;\n\t\t\t}\n\t\t}\n\t\tif (pte_none(pteval) || is_zero_pfn(pte_pfn(pteval))) {\n\t\t\tif (!userfaultfd_armed(vma) &&\n\t\t\t    ++none_or_zero <= khugepaged_max_ptes_none) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tresult = SCAN_EXCEED_NONE_PTE;\n\t\t\t\tgoto out_unmap;\n\t\t\t}\n\t\t}\n\t\tif (!pte_present(pteval)) {\n\t\t\tresult = SCAN_PTE_NON_PRESENT;\n\t\t\tgoto out_unmap;\n\t\t}\n\t\tif (pte_write(pteval))\n\t\t\twritable = true;\n\n\t\tpage = vm_normal_page(vma, _address, pteval);\n\t\tif (unlikely(!page)) {\n\t\t\tresult = SCAN_PAGE_NULL;\n\t\t\tgoto out_unmap;\n\t\t}\n\n\t\t/* TODO: teach khugepaged to collapse THP mapped with pte */\n\t\tif (PageCompound(page)) {\n\t\t\tresult = SCAN_PAGE_COMPOUND;\n\t\t\tgoto out_unmap;\n\t\t}\n\n\t\t/*\n\t\t * Record which node the original page is from and save this\n\t\t * information to khugepaged_node_load[].\n\t\t * Khupaged will allocate hugepage from the node has the max\n\t\t * hit record.\n\t\t */\n\t\tnode = page_to_nid(page);\n\t\tif (khugepaged_scan_abort(node)) {\n\t\t\tresult = SCAN_SCAN_ABORT;\n\t\t\tgoto out_unmap;\n\t\t}\n\t\tkhugepaged_node_load[node]++;\n\t\tif (!PageLRU(page)) {\n\t\t\tresult = SCAN_PAGE_LRU;\n\t\t\tgoto out_unmap;\n\t\t}\n\t\tif (PageLocked(page)) {\n\t\t\tresult = SCAN_PAGE_LOCK;\n\t\t\tgoto out_unmap;\n\t\t}\n\t\tif (!PageAnon(page)) {\n\t\t\tresult = SCAN_PAGE_ANON;\n\t\t\tgoto out_unmap;\n\t\t}\n\n\t\t/*\n\t\t * cannot use mapcount: can't collapse if there's a gup pin.\n\t\t * The page must only be referenced by the scanned process\n\t\t * and page swap cache.\n\t\t */\n\t\tif (page_count(page) != 1 + PageSwapCache(page)) {\n\t\t\tresult = SCAN_PAGE_COUNT;\n\t\t\tgoto out_unmap;\n\t\t}\n\t\tif (pte_young(pteval) ||\n\t\t    page_is_young(page) || PageReferenced(page) ||\n\t\t    mmu_notifier_test_young(vma->vm_mm, address))\n\t\t\treferenced++;\n\t}\n\tif (writable) {\n\t\tif (referenced) {\n\t\t\tresult = SCAN_SUCCEED;\n\t\t\tret = 1;\n\t\t} else {\n\t\t\tresult = SCAN_LACK_REFERENCED_PAGE;\n\t\t}\n\t} else {\n\t\tresult = SCAN_PAGE_RO;\n\t}\nout_unmap:\n\tpte_unmap_unlock(pte, ptl);\n\tif (ret) {\n\t\tnode = khugepaged_find_target_node();\n\t\t/* collapse_huge_page will return with the mmap_sem released */\n\t\tcollapse_huge_page(mm, address, hpage, node, referenced);\n\t}\nout:\n\ttrace_mm_khugepaged_scan_pmd(mm, page, writable, referenced,\n\t\t\t\t     none_or_zero, result, unmapped);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int khugepaged_max_ptes_none",
      "static unsigned int khugepaged_max_ptes_swap",
      "static int khugepaged_node_load[MAX_NUMNODES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_mm_khugepaged_scan_pmd",
          "args": [
            "mm",
            "page",
            "writable",
            "referenced",
            "none_or_zero",
            "result",
            "unmapped"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "collapse_huge_page",
          "args": [
            "mm",
            "address",
            "hpage",
            "node",
            "referenced"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "collapse_huge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "934-1097",
          "snippet": "static void collapse_huge_page(struct mm_struct *mm,\n\t\t\t\t   unsigned long address,\n\t\t\t\t   struct page **hpage,\n\t\t\t\t   int node, int referenced)\n{\n\tpmd_t *pmd, _pmd;\n\tpte_t *pte;\n\tpgtable_t pgtable;\n\tstruct page *new_page;\n\tspinlock_t *pmd_ptl, *pte_ptl;\n\tint isolated = 0, result = 0;\n\tstruct mem_cgroup *memcg;\n\tstruct vm_area_struct *vma;\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\tgfp_t gfp;\n\n\tVM_BUG_ON(address & ~HPAGE_PMD_MASK);\n\n\t/* Only allocate from the target node */\n\tgfp = alloc_hugepage_khugepaged_gfpmask() | __GFP_THISNODE;\n\n\t/*\n\t * Before allocating the hugepage, release the mmap_sem read lock.\n\t * The allocation can take potentially a long time if it involves\n\t * sync compaction, and we do not need to hold the mmap_sem during\n\t * that. We will recheck the vma after taking it again in write mode.\n\t */\n\tup_read(&mm->mmap_sem);\n\tnew_page = khugepaged_alloc_page(hpage, gfp, node);\n\tif (!new_page) {\n\t\tresult = SCAN_ALLOC_HUGE_PAGE_FAIL;\n\t\tgoto out_nolock;\n\t}\n\n\tif (unlikely(mem_cgroup_try_charge(new_page, mm, gfp, &memcg, true))) {\n\t\tresult = SCAN_CGROUP_CHARGE_FAIL;\n\t\tgoto out_nolock;\n\t}\n\n\tdown_read(&mm->mmap_sem);\n\tresult = hugepage_vma_revalidate(mm, address, &vma);\n\tif (result) {\n\t\tmem_cgroup_cancel_charge(new_page, memcg, true);\n\t\tup_read(&mm->mmap_sem);\n\t\tgoto out_nolock;\n\t}\n\n\tpmd = mm_find_pmd(mm, address);\n\tif (!pmd) {\n\t\tresult = SCAN_PMD_NULL;\n\t\tmem_cgroup_cancel_charge(new_page, memcg, true);\n\t\tup_read(&mm->mmap_sem);\n\t\tgoto out_nolock;\n\t}\n\n\t/*\n\t * __collapse_huge_page_swapin always returns with mmap_sem locked.\n\t * If it fails, we release mmap_sem and jump out_nolock.\n\t * Continuing to collapse causes inconsistency.\n\t */\n\tif (!__collapse_huge_page_swapin(mm, vma, address, pmd, referenced)) {\n\t\tmem_cgroup_cancel_charge(new_page, memcg, true);\n\t\tup_read(&mm->mmap_sem);\n\t\tgoto out_nolock;\n\t}\n\n\tup_read(&mm->mmap_sem);\n\t/*\n\t * Prevent all access to pagetables with the exception of\n\t * gup_fast later handled by the ptep_clear_flush and the VM\n\t * handled by the anon_vma lock + PG_lock.\n\t */\n\tdown_write(&mm->mmap_sem);\n\tresult = hugepage_vma_revalidate(mm, address, &vma);\n\tif (result)\n\t\tgoto out;\n\t/* check if the pmd is still valid */\n\tif (mm_find_pmd(mm, address) != pmd)\n\t\tgoto out;\n\n\tanon_vma_lock_write(vma->anon_vma);\n\n\tpte = pte_offset_map(pmd, address);\n\tpte_ptl = pte_lockptr(mm, pmd);\n\n\tmmun_start = address;\n\tmmun_end   = address + HPAGE_PMD_SIZE;\n\tmmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);\n\tpmd_ptl = pmd_lock(mm, pmd); /* probably unnecessary */\n\t/*\n\t * After this gup_fast can't run anymore. This also removes\n\t * any huge TLB entry from the CPU so we won't allow\n\t * huge and small TLB entries for the same virtual address\n\t * to avoid the risk of CPU bugs in that area.\n\t */\n\t_pmd = pmdp_collapse_flush(vma, address, pmd);\n\tspin_unlock(pmd_ptl);\n\tmmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);\n\n\tspin_lock(pte_ptl);\n\tisolated = __collapse_huge_page_isolate(vma, address, pte);\n\tspin_unlock(pte_ptl);\n\n\tif (unlikely(!isolated)) {\n\t\tpte_unmap(pte);\n\t\tspin_lock(pmd_ptl);\n\t\tBUG_ON(!pmd_none(*pmd));\n\t\t/*\n\t\t * We can only use set_pmd_at when establishing\n\t\t * hugepmds and never for establishing regular pmds that\n\t\t * points to regular pagetables. Use pmd_populate for that\n\t\t */\n\t\tpmd_populate(mm, pmd, pmd_pgtable(_pmd));\n\t\tspin_unlock(pmd_ptl);\n\t\tanon_vma_unlock_write(vma->anon_vma);\n\t\tresult = SCAN_FAIL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * All pages are isolated and locked so anon_vma rmap\n\t * can't run anymore.\n\t */\n\tanon_vma_unlock_write(vma->anon_vma);\n\n\t__collapse_huge_page_copy(pte, new_page, vma, address, pte_ptl);\n\tpte_unmap(pte);\n\t__SetPageUptodate(new_page);\n\tpgtable = pmd_pgtable(_pmd);\n\n\t_pmd = mk_huge_pmd(new_page, vma->vm_page_prot);\n\t_pmd = maybe_pmd_mkwrite(pmd_mkdirty(_pmd), vma);\n\n\t/*\n\t * spin_lock() below is not the equivalent of smp_wmb(), so\n\t * this is needed to avoid the copy_huge_page writes to become\n\t * visible after the set_pmd_at() write.\n\t */\n\tsmp_wmb();\n\n\tspin_lock(pmd_ptl);\n\tBUG_ON(!pmd_none(*pmd));\n\tpage_add_new_anon_rmap(new_page, vma, address, true);\n\tmem_cgroup_commit_charge(new_page, memcg, false, true);\n\tlru_cache_add_active_or_unevictable(new_page, vma);\n\tpgtable_trans_huge_deposit(mm, pmd, pgtable);\n\tset_pmd_at(mm, address, pmd, _pmd);\n\tupdate_mmu_cache_pmd(vma, address, pmd);\n\tspin_unlock(pmd_ptl);\n\n\t*hpage = NULL;\n\n\tkhugepaged_pages_collapsed++;\n\tresult = SCAN_SUCCEED;\nout_up_write:\n\tup_write(&mm->mmap_sem);\nout_nolock:\n\ttrace_mm_collapse_huge_page(mm, isolated, result);\n\treturn;\nout:\n\tmem_cgroup_cancel_charge(new_page, memcg, true);\n\tgoto out_up_write;\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int khugepaged_pages_collapsed;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic unsigned int khugepaged_pages_collapsed;\n\nstatic void collapse_huge_page(struct mm_struct *mm,\n\t\t\t\t   unsigned long address,\n\t\t\t\t   struct page **hpage,\n\t\t\t\t   int node, int referenced)\n{\n\tpmd_t *pmd, _pmd;\n\tpte_t *pte;\n\tpgtable_t pgtable;\n\tstruct page *new_page;\n\tspinlock_t *pmd_ptl, *pte_ptl;\n\tint isolated = 0, result = 0;\n\tstruct mem_cgroup *memcg;\n\tstruct vm_area_struct *vma;\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\tgfp_t gfp;\n\n\tVM_BUG_ON(address & ~HPAGE_PMD_MASK);\n\n\t/* Only allocate from the target node */\n\tgfp = alloc_hugepage_khugepaged_gfpmask() | __GFP_THISNODE;\n\n\t/*\n\t * Before allocating the hugepage, release the mmap_sem read lock.\n\t * The allocation can take potentially a long time if it involves\n\t * sync compaction, and we do not need to hold the mmap_sem during\n\t * that. We will recheck the vma after taking it again in write mode.\n\t */\n\tup_read(&mm->mmap_sem);\n\tnew_page = khugepaged_alloc_page(hpage, gfp, node);\n\tif (!new_page) {\n\t\tresult = SCAN_ALLOC_HUGE_PAGE_FAIL;\n\t\tgoto out_nolock;\n\t}\n\n\tif (unlikely(mem_cgroup_try_charge(new_page, mm, gfp, &memcg, true))) {\n\t\tresult = SCAN_CGROUP_CHARGE_FAIL;\n\t\tgoto out_nolock;\n\t}\n\n\tdown_read(&mm->mmap_sem);\n\tresult = hugepage_vma_revalidate(mm, address, &vma);\n\tif (result) {\n\t\tmem_cgroup_cancel_charge(new_page, memcg, true);\n\t\tup_read(&mm->mmap_sem);\n\t\tgoto out_nolock;\n\t}\n\n\tpmd = mm_find_pmd(mm, address);\n\tif (!pmd) {\n\t\tresult = SCAN_PMD_NULL;\n\t\tmem_cgroup_cancel_charge(new_page, memcg, true);\n\t\tup_read(&mm->mmap_sem);\n\t\tgoto out_nolock;\n\t}\n\n\t/*\n\t * __collapse_huge_page_swapin always returns with mmap_sem locked.\n\t * If it fails, we release mmap_sem and jump out_nolock.\n\t * Continuing to collapse causes inconsistency.\n\t */\n\tif (!__collapse_huge_page_swapin(mm, vma, address, pmd, referenced)) {\n\t\tmem_cgroup_cancel_charge(new_page, memcg, true);\n\t\tup_read(&mm->mmap_sem);\n\t\tgoto out_nolock;\n\t}\n\n\tup_read(&mm->mmap_sem);\n\t/*\n\t * Prevent all access to pagetables with the exception of\n\t * gup_fast later handled by the ptep_clear_flush and the VM\n\t * handled by the anon_vma lock + PG_lock.\n\t */\n\tdown_write(&mm->mmap_sem);\n\tresult = hugepage_vma_revalidate(mm, address, &vma);\n\tif (result)\n\t\tgoto out;\n\t/* check if the pmd is still valid */\n\tif (mm_find_pmd(mm, address) != pmd)\n\t\tgoto out;\n\n\tanon_vma_lock_write(vma->anon_vma);\n\n\tpte = pte_offset_map(pmd, address);\n\tpte_ptl = pte_lockptr(mm, pmd);\n\n\tmmun_start = address;\n\tmmun_end   = address + HPAGE_PMD_SIZE;\n\tmmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);\n\tpmd_ptl = pmd_lock(mm, pmd); /* probably unnecessary */\n\t/*\n\t * After this gup_fast can't run anymore. This also removes\n\t * any huge TLB entry from the CPU so we won't allow\n\t * huge and small TLB entries for the same virtual address\n\t * to avoid the risk of CPU bugs in that area.\n\t */\n\t_pmd = pmdp_collapse_flush(vma, address, pmd);\n\tspin_unlock(pmd_ptl);\n\tmmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);\n\n\tspin_lock(pte_ptl);\n\tisolated = __collapse_huge_page_isolate(vma, address, pte);\n\tspin_unlock(pte_ptl);\n\n\tif (unlikely(!isolated)) {\n\t\tpte_unmap(pte);\n\t\tspin_lock(pmd_ptl);\n\t\tBUG_ON(!pmd_none(*pmd));\n\t\t/*\n\t\t * We can only use set_pmd_at when establishing\n\t\t * hugepmds and never for establishing regular pmds that\n\t\t * points to regular pagetables. Use pmd_populate for that\n\t\t */\n\t\tpmd_populate(mm, pmd, pmd_pgtable(_pmd));\n\t\tspin_unlock(pmd_ptl);\n\t\tanon_vma_unlock_write(vma->anon_vma);\n\t\tresult = SCAN_FAIL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * All pages are isolated and locked so anon_vma rmap\n\t * can't run anymore.\n\t */\n\tanon_vma_unlock_write(vma->anon_vma);\n\n\t__collapse_huge_page_copy(pte, new_page, vma, address, pte_ptl);\n\tpte_unmap(pte);\n\t__SetPageUptodate(new_page);\n\tpgtable = pmd_pgtable(_pmd);\n\n\t_pmd = mk_huge_pmd(new_page, vma->vm_page_prot);\n\t_pmd = maybe_pmd_mkwrite(pmd_mkdirty(_pmd), vma);\n\n\t/*\n\t * spin_lock() below is not the equivalent of smp_wmb(), so\n\t * this is needed to avoid the copy_huge_page writes to become\n\t * visible after the set_pmd_at() write.\n\t */\n\tsmp_wmb();\n\n\tspin_lock(pmd_ptl);\n\tBUG_ON(!pmd_none(*pmd));\n\tpage_add_new_anon_rmap(new_page, vma, address, true);\n\tmem_cgroup_commit_charge(new_page, memcg, false, true);\n\tlru_cache_add_active_or_unevictable(new_page, vma);\n\tpgtable_trans_huge_deposit(mm, pmd, pgtable);\n\tset_pmd_at(mm, address, pmd, _pmd);\n\tupdate_mmu_cache_pmd(vma, address, pmd);\n\tspin_unlock(pmd_ptl);\n\n\t*hpage = NULL;\n\n\tkhugepaged_pages_collapsed++;\n\tresult = SCAN_SUCCEED;\nout_up_write:\n\tup_write(&mm->mmap_sem);\nout_nolock:\n\ttrace_mm_collapse_huge_page(mm, isolated, result);\n\treturn;\nout:\n\tmem_cgroup_cancel_charge(new_page, memcg, true);\n\tgoto out_up_write;\n}"
        }
      },
      {
        "call_info": {
          "callee": "khugepaged_find_target_node",
          "args": [],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "khugepaged_find_target_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "785-788",
          "snippet": "static int khugepaged_find_target_node(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic int khugepaged_find_target_node(void)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_unmap_unlock",
          "args": [
            "pte",
            "ptl"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_notifier_test_young",
          "args": [
            "vma->vm_mm",
            "address"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "__mmu_notifier_test_young",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_notifier.c",
          "lines": "144-161",
          "snippet": "int __mmu_notifier_test_young(struct mm_struct *mm,\n\t\t\t      unsigned long address)\n{\n\tstruct mmu_notifier *mn;\n\tint young = 0, id;\n\n\tid = srcu_read_lock(&srcu);\n\thlist_for_each_entry_rcu(mn, &mm->mmu_notifier_mm->list, hlist) {\n\t\tif (mn->ops->test_young) {\n\t\t\tyoung = mn->ops->test_young(mn, mm, address);\n\t\t\tif (young)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tsrcu_read_unlock(&srcu, id);\n\n\treturn young;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/srcu.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/srcu.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rculist.h>\n\nint __mmu_notifier_test_young(struct mm_struct *mm,\n\t\t\t      unsigned long address)\n{\n\tstruct mmu_notifier *mn;\n\tint young = 0, id;\n\n\tid = srcu_read_lock(&srcu);\n\thlist_for_each_entry_rcu(mn, &mm->mmu_notifier_mm->list, hlist) {\n\t\tif (mn->ops->test_young) {\n\t\t\tyoung = mn->ops->test_young(mn, mm, address);\n\t\t\tif (young)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tsrcu_read_unlock(&srcu, id);\n\n\treturn young;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageReferenced",
          "args": [
            "page"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_is_young",
          "args": [
            "page"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_young",
          "args": [
            "pteval"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "khugepaged_scan_abort",
          "args": [
            "node"
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "khugepaged_scan_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "695-717",
          "snippet": "static bool khugepaged_scan_abort(int nid)\n{\n\tint i;\n\n\t/*\n\t * If node_reclaim_mode is disabled, then no extra effort is made to\n\t * allocate memory locally.\n\t */\n\tif (!node_reclaim_mode)\n\t\treturn false;\n\n\t/* If there is a count for this node already, it must be acceptable */\n\tif (khugepaged_node_load[nid])\n\t\treturn false;\n\n\tfor (i = 0; i < MAX_NUMNODES; i++) {\n\t\tif (!khugepaged_node_load[i])\n\t\t\tcontinue;\n\t\tif (node_distance(nid, i) > RECLAIM_DISTANCE)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int khugepaged_node_load[MAX_NUMNODES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic int khugepaged_node_load[MAX_NUMNODES];\n\nstatic bool khugepaged_scan_abort(int nid)\n{\n\tint i;\n\n\t/*\n\t * If node_reclaim_mode is disabled, then no extra effort is made to\n\t * allocate memory locally.\n\t */\n\tif (!node_reclaim_mode)\n\t\treturn false;\n\n\t/* If there is a count for this node already, it must be acceptable */\n\tif (khugepaged_node_load[nid])\n\t\treturn false;\n\n\tfor (i = 0; i < MAX_NUMNODES; i++) {\n\t\tif (!khugepaged_node_load[i])\n\t\t\tcontinue;\n\t\tif (node_distance(nid, i) > RECLAIM_DISTANCE)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "page"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_normal_page",
          "args": [
            "vma",
            "_address",
            "pteval"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "vm_normal_page_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "651-689",
          "snippet": "struct page *vm_normal_page_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tpmd_t pmd)\n{\n\tunsigned long pfn = pmd_pfn(pmd);\n\n\t/*\n\t * There is no pmd_special() but there may be special pmds, e.g.\n\t * in a direct-access (dax) mapping, so let's just replicate the\n\t * !CONFIG_ARCH_HAS_PTE_SPECIAL case from vm_normal_page() here.\n\t */\n\tif (unlikely(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP))) {\n\t\tif (vma->vm_flags & VM_MIXEDMAP) {\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\treturn NULL;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tunsigned long off;\n\t\t\toff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\t\tif (pfn == vma->vm_pgoff + off)\n\t\t\t\treturn NULL;\n\t\t\tif (!is_cow_mapping(vma->vm_flags))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (pmd_devmap(pmd))\n\t\treturn NULL;\n\tif (is_zero_pfn(pfn))\n\t\treturn NULL;\n\tif (unlikely(pfn > highest_memmap_pfn))\n\t\treturn NULL;\n\n\t/*\n\t * NOTE! We still have PageReserved() pages in the page tables.\n\t * eg. VDSO mappings can cause them to exist.\n\t */\nout:\n\treturn pfn_to_page(pfn);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstruct page *vm_normal_page_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tpmd_t pmd)\n{\n\tunsigned long pfn = pmd_pfn(pmd);\n\n\t/*\n\t * There is no pmd_special() but there may be special pmds, e.g.\n\t * in a direct-access (dax) mapping, so let's just replicate the\n\t * !CONFIG_ARCH_HAS_PTE_SPECIAL case from vm_normal_page() here.\n\t */\n\tif (unlikely(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP))) {\n\t\tif (vma->vm_flags & VM_MIXEDMAP) {\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\treturn NULL;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tunsigned long off;\n\t\t\toff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\t\tif (pfn == vma->vm_pgoff + off)\n\t\t\t\treturn NULL;\n\t\t\tif (!is_cow_mapping(vma->vm_flags))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (pmd_devmap(pmd))\n\t\treturn NULL;\n\tif (is_zero_pfn(pfn))\n\t\treturn NULL;\n\tif (unlikely(pfn > highest_memmap_pfn))\n\t\treturn NULL;\n\n\t/*\n\t * NOTE! We still have PageReserved() pages in the page tables.\n\t * eg. VDSO mappings can cause them to exist.\n\t */\nout:\n\treturn pfn_to_page(pfn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_write",
          "args": [
            "pteval"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "pteval"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userfaultfd_armed",
          "args": [
            "vma"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_zero_pfn",
          "args": [
            "pte_pfn(pteval)"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_pfn",
          "args": [
            "pteval"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_none",
          "args": [
            "pteval"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_swap_pte",
          "args": [
            "pteval"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_offset_map_lock",
          "args": [
            "mm",
            "pmd",
            "address",
            "&ptl"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "khugepaged_node_load",
            "0",
            "sizeof(khugepaged_node_load)"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_find_pmd",
          "args": [
            "mm",
            "address"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "mm_find_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "710-742",
          "snippet": "pmd_t *mm_find_pmd(struct mm_struct *mm, unsigned long address)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd = NULL;\n\tpmd_t pmde;\n\n\tpgd = pgd_offset(mm, address);\n\tif (!pgd_present(*pgd))\n\t\tgoto out;\n\n\tp4d = p4d_offset(pgd, address);\n\tif (!p4d_present(*p4d))\n\t\tgoto out;\n\n\tpud = pud_offset(p4d, address);\n\tif (!pud_present(*pud))\n\t\tgoto out;\n\n\tpmd = pmd_offset(pud, address);\n\t/*\n\t * Some THP functions use the sequence pmdp_huge_clear_flush(), set_pmd_at()\n\t * without holding anon_vma lock for write.  So when looking for a\n\t * genuine pmde (in which to find pte), test present and !THP together.\n\t */\n\tpmde = *pmd;\n\tbarrier();\n\tif (!pmd_present(pmde) || pmd_trans_huge(pmde))\n\t\tpmd = NULL;\nout:\n\treturn pmd;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\npmd_t *mm_find_pmd(struct mm_struct *mm, unsigned long address)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd = NULL;\n\tpmd_t pmde;\n\n\tpgd = pgd_offset(mm, address);\n\tif (!pgd_present(*pgd))\n\t\tgoto out;\n\n\tp4d = p4d_offset(pgd, address);\n\tif (!p4d_present(*p4d))\n\t\tgoto out;\n\n\tpud = pud_offset(p4d, address);\n\tif (!pud_present(*pud))\n\t\tgoto out;\n\n\tpmd = pmd_offset(pud, address);\n\t/*\n\t * Some THP functions use the sequence pmdp_huge_clear_flush(), set_pmd_at()\n\t * without holding anon_vma lock for write.  So when looking for a\n\t * genuine pmde (in which to find pte), test present and !THP together.\n\t */\n\tpmde = *pmd;\n\tbarrier();\n\tif (!pmd_present(pmde) || pmd_trans_huge(pmde))\n\t\tpmd = NULL;\nout:\n\treturn pmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "address & ~HPAGE_PMD_MASK"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic unsigned int khugepaged_max_ptes_none;\nstatic unsigned int khugepaged_max_ptes_swap;\nstatic int khugepaged_node_load[MAX_NUMNODES];\n\nstatic int khugepaged_scan_pmd(struct mm_struct *mm,\n\t\t\t       struct vm_area_struct *vma,\n\t\t\t       unsigned long address,\n\t\t\t       struct page **hpage)\n{\n\tpmd_t *pmd;\n\tpte_t *pte, *_pte;\n\tint ret = 0, none_or_zero = 0, result = 0, referenced = 0;\n\tstruct page *page = NULL;\n\tunsigned long _address;\n\tspinlock_t *ptl;\n\tint node = NUMA_NO_NODE, unmapped = 0;\n\tbool writable = false;\n\n\tVM_BUG_ON(address & ~HPAGE_PMD_MASK);\n\n\tpmd = mm_find_pmd(mm, address);\n\tif (!pmd) {\n\t\tresult = SCAN_PMD_NULL;\n\t\tgoto out;\n\t}\n\n\tmemset(khugepaged_node_load, 0, sizeof(khugepaged_node_load));\n\tpte = pte_offset_map_lock(mm, pmd, address, &ptl);\n\tfor (_address = address, _pte = pte; _pte < pte+HPAGE_PMD_NR;\n\t     _pte++, _address += PAGE_SIZE) {\n\t\tpte_t pteval = *_pte;\n\t\tif (is_swap_pte(pteval)) {\n\t\t\tif (++unmapped <= khugepaged_max_ptes_swap) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tresult = SCAN_EXCEED_SWAP_PTE;\n\t\t\t\tgoto out_unmap;\n\t\t\t}\n\t\t}\n\t\tif (pte_none(pteval) || is_zero_pfn(pte_pfn(pteval))) {\n\t\t\tif (!userfaultfd_armed(vma) &&\n\t\t\t    ++none_or_zero <= khugepaged_max_ptes_none) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tresult = SCAN_EXCEED_NONE_PTE;\n\t\t\t\tgoto out_unmap;\n\t\t\t}\n\t\t}\n\t\tif (!pte_present(pteval)) {\n\t\t\tresult = SCAN_PTE_NON_PRESENT;\n\t\t\tgoto out_unmap;\n\t\t}\n\t\tif (pte_write(pteval))\n\t\t\twritable = true;\n\n\t\tpage = vm_normal_page(vma, _address, pteval);\n\t\tif (unlikely(!page)) {\n\t\t\tresult = SCAN_PAGE_NULL;\n\t\t\tgoto out_unmap;\n\t\t}\n\n\t\t/* TODO: teach khugepaged to collapse THP mapped with pte */\n\t\tif (PageCompound(page)) {\n\t\t\tresult = SCAN_PAGE_COMPOUND;\n\t\t\tgoto out_unmap;\n\t\t}\n\n\t\t/*\n\t\t * Record which node the original page is from and save this\n\t\t * information to khugepaged_node_load[].\n\t\t * Khupaged will allocate hugepage from the node has the max\n\t\t * hit record.\n\t\t */\n\t\tnode = page_to_nid(page);\n\t\tif (khugepaged_scan_abort(node)) {\n\t\t\tresult = SCAN_SCAN_ABORT;\n\t\t\tgoto out_unmap;\n\t\t}\n\t\tkhugepaged_node_load[node]++;\n\t\tif (!PageLRU(page)) {\n\t\t\tresult = SCAN_PAGE_LRU;\n\t\t\tgoto out_unmap;\n\t\t}\n\t\tif (PageLocked(page)) {\n\t\t\tresult = SCAN_PAGE_LOCK;\n\t\t\tgoto out_unmap;\n\t\t}\n\t\tif (!PageAnon(page)) {\n\t\t\tresult = SCAN_PAGE_ANON;\n\t\t\tgoto out_unmap;\n\t\t}\n\n\t\t/*\n\t\t * cannot use mapcount: can't collapse if there's a gup pin.\n\t\t * The page must only be referenced by the scanned process\n\t\t * and page swap cache.\n\t\t */\n\t\tif (page_count(page) != 1 + PageSwapCache(page)) {\n\t\t\tresult = SCAN_PAGE_COUNT;\n\t\t\tgoto out_unmap;\n\t\t}\n\t\tif (pte_young(pteval) ||\n\t\t    page_is_young(page) || PageReferenced(page) ||\n\t\t    mmu_notifier_test_young(vma->vm_mm, address))\n\t\t\treferenced++;\n\t}\n\tif (writable) {\n\t\tif (referenced) {\n\t\t\tresult = SCAN_SUCCEED;\n\t\t\tret = 1;\n\t\t} else {\n\t\t\tresult = SCAN_LACK_REFERENCED_PAGE;\n\t\t}\n\t} else {\n\t\tresult = SCAN_PAGE_RO;\n\t}\nout_unmap:\n\tpte_unmap_unlock(pte, ptl);\n\tif (ret) {\n\t\tnode = khugepaged_find_target_node();\n\t\t/* collapse_huge_page will return with the mmap_sem released */\n\t\tcollapse_huge_page(mm, address, hpage, node, referenced);\n\t}\nout:\n\ttrace_mm_khugepaged_scan_pmd(mm, page, writable, referenced,\n\t\t\t\t     none_or_zero, result, unmapped);\n\treturn ret;\n}"
  },
  {
    "function_name": "collapse_huge_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "934-1097",
    "snippet": "static void collapse_huge_page(struct mm_struct *mm,\n\t\t\t\t   unsigned long address,\n\t\t\t\t   struct page **hpage,\n\t\t\t\t   int node, int referenced)\n{\n\tpmd_t *pmd, _pmd;\n\tpte_t *pte;\n\tpgtable_t pgtable;\n\tstruct page *new_page;\n\tspinlock_t *pmd_ptl, *pte_ptl;\n\tint isolated = 0, result = 0;\n\tstruct mem_cgroup *memcg;\n\tstruct vm_area_struct *vma;\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\tgfp_t gfp;\n\n\tVM_BUG_ON(address & ~HPAGE_PMD_MASK);\n\n\t/* Only allocate from the target node */\n\tgfp = alloc_hugepage_khugepaged_gfpmask() | __GFP_THISNODE;\n\n\t/*\n\t * Before allocating the hugepage, release the mmap_sem read lock.\n\t * The allocation can take potentially a long time if it involves\n\t * sync compaction, and we do not need to hold the mmap_sem during\n\t * that. We will recheck the vma after taking it again in write mode.\n\t */\n\tup_read(&mm->mmap_sem);\n\tnew_page = khugepaged_alloc_page(hpage, gfp, node);\n\tif (!new_page) {\n\t\tresult = SCAN_ALLOC_HUGE_PAGE_FAIL;\n\t\tgoto out_nolock;\n\t}\n\n\tif (unlikely(mem_cgroup_try_charge(new_page, mm, gfp, &memcg, true))) {\n\t\tresult = SCAN_CGROUP_CHARGE_FAIL;\n\t\tgoto out_nolock;\n\t}\n\n\tdown_read(&mm->mmap_sem);\n\tresult = hugepage_vma_revalidate(mm, address, &vma);\n\tif (result) {\n\t\tmem_cgroup_cancel_charge(new_page, memcg, true);\n\t\tup_read(&mm->mmap_sem);\n\t\tgoto out_nolock;\n\t}\n\n\tpmd = mm_find_pmd(mm, address);\n\tif (!pmd) {\n\t\tresult = SCAN_PMD_NULL;\n\t\tmem_cgroup_cancel_charge(new_page, memcg, true);\n\t\tup_read(&mm->mmap_sem);\n\t\tgoto out_nolock;\n\t}\n\n\t/*\n\t * __collapse_huge_page_swapin always returns with mmap_sem locked.\n\t * If it fails, we release mmap_sem and jump out_nolock.\n\t * Continuing to collapse causes inconsistency.\n\t */\n\tif (!__collapse_huge_page_swapin(mm, vma, address, pmd, referenced)) {\n\t\tmem_cgroup_cancel_charge(new_page, memcg, true);\n\t\tup_read(&mm->mmap_sem);\n\t\tgoto out_nolock;\n\t}\n\n\tup_read(&mm->mmap_sem);\n\t/*\n\t * Prevent all access to pagetables with the exception of\n\t * gup_fast later handled by the ptep_clear_flush and the VM\n\t * handled by the anon_vma lock + PG_lock.\n\t */\n\tdown_write(&mm->mmap_sem);\n\tresult = hugepage_vma_revalidate(mm, address, &vma);\n\tif (result)\n\t\tgoto out;\n\t/* check if the pmd is still valid */\n\tif (mm_find_pmd(mm, address) != pmd)\n\t\tgoto out;\n\n\tanon_vma_lock_write(vma->anon_vma);\n\n\tpte = pte_offset_map(pmd, address);\n\tpte_ptl = pte_lockptr(mm, pmd);\n\n\tmmun_start = address;\n\tmmun_end   = address + HPAGE_PMD_SIZE;\n\tmmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);\n\tpmd_ptl = pmd_lock(mm, pmd); /* probably unnecessary */\n\t/*\n\t * After this gup_fast can't run anymore. This also removes\n\t * any huge TLB entry from the CPU so we won't allow\n\t * huge and small TLB entries for the same virtual address\n\t * to avoid the risk of CPU bugs in that area.\n\t */\n\t_pmd = pmdp_collapse_flush(vma, address, pmd);\n\tspin_unlock(pmd_ptl);\n\tmmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);\n\n\tspin_lock(pte_ptl);\n\tisolated = __collapse_huge_page_isolate(vma, address, pte);\n\tspin_unlock(pte_ptl);\n\n\tif (unlikely(!isolated)) {\n\t\tpte_unmap(pte);\n\t\tspin_lock(pmd_ptl);\n\t\tBUG_ON(!pmd_none(*pmd));\n\t\t/*\n\t\t * We can only use set_pmd_at when establishing\n\t\t * hugepmds and never for establishing regular pmds that\n\t\t * points to regular pagetables. Use pmd_populate for that\n\t\t */\n\t\tpmd_populate(mm, pmd, pmd_pgtable(_pmd));\n\t\tspin_unlock(pmd_ptl);\n\t\tanon_vma_unlock_write(vma->anon_vma);\n\t\tresult = SCAN_FAIL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * All pages are isolated and locked so anon_vma rmap\n\t * can't run anymore.\n\t */\n\tanon_vma_unlock_write(vma->anon_vma);\n\n\t__collapse_huge_page_copy(pte, new_page, vma, address, pte_ptl);\n\tpte_unmap(pte);\n\t__SetPageUptodate(new_page);\n\tpgtable = pmd_pgtable(_pmd);\n\n\t_pmd = mk_huge_pmd(new_page, vma->vm_page_prot);\n\t_pmd = maybe_pmd_mkwrite(pmd_mkdirty(_pmd), vma);\n\n\t/*\n\t * spin_lock() below is not the equivalent of smp_wmb(), so\n\t * this is needed to avoid the copy_huge_page writes to become\n\t * visible after the set_pmd_at() write.\n\t */\n\tsmp_wmb();\n\n\tspin_lock(pmd_ptl);\n\tBUG_ON(!pmd_none(*pmd));\n\tpage_add_new_anon_rmap(new_page, vma, address, true);\n\tmem_cgroup_commit_charge(new_page, memcg, false, true);\n\tlru_cache_add_active_or_unevictable(new_page, vma);\n\tpgtable_trans_huge_deposit(mm, pmd, pgtable);\n\tset_pmd_at(mm, address, pmd, _pmd);\n\tupdate_mmu_cache_pmd(vma, address, pmd);\n\tspin_unlock(pmd_ptl);\n\n\t*hpage = NULL;\n\n\tkhugepaged_pages_collapsed++;\n\tresult = SCAN_SUCCEED;\nout_up_write:\n\tup_write(&mm->mmap_sem);\nout_nolock:\n\ttrace_mm_collapse_huge_page(mm, isolated, result);\n\treturn;\nout:\n\tmem_cgroup_cancel_charge(new_page, memcg, true);\n\tgoto out_up_write;\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int khugepaged_pages_collapsed;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cgroup_cancel_charge",
          "args": [
            "new_page",
            "memcg",
            "true"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_cancel_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5972-5988",
          "snippet": "void mem_cgroup_cancel_charge(struct page *page, struct mem_cgroup *memcg,\n\t\tbool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcancel_charge(memcg, nr_pages);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid mem_cgroup_cancel_charge(struct page *page, struct mem_cgroup *memcg,\n\t\tbool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcancel_charge(memcg, nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_mm_collapse_huge_page",
          "args": [
            "mm",
            "isolated",
            "result"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "pmd_ptl"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_mmu_cache_pmd",
          "args": [
            "vma",
            "address",
            "pmd"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pmd_at",
          "args": [
            "mm",
            "address",
            "pmd",
            "_pmd"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgtable_trans_huge_deposit",
          "args": [
            "mm",
            "pmd",
            "pgtable"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "pgtable_trans_huge_deposit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pgtable-generic.c",
          "lines": "152-163",
          "snippet": "void pgtable_trans_huge_deposit(struct mm_struct *mm, pmd_t *pmdp,\n\t\t\t\tpgtable_t pgtable)\n{\n\tassert_spin_locked(pmd_lockptr(mm, pmdp));\n\n\t/* FIFO */\n\tif (!pmd_huge_pte(mm, pmdp))\n\t\tINIT_LIST_HEAD(&pgtable->lru);\n\telse\n\t\tlist_add(&pgtable->lru, &pmd_huge_pte(mm, pmdp)->lru);\n\tpmd_huge_pte(mm, pmdp) = pgtable;\n}",
          "includes": [
            "#include <asm-generic/pgtable.h>",
            "#include <asm/tlb.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm-generic/pgtable.h>\n#include <asm/tlb.h>\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n\nvoid pgtable_trans_huge_deposit(struct mm_struct *mm, pmd_t *pmdp,\n\t\t\t\tpgtable_t pgtable)\n{\n\tassert_spin_locked(pmd_lockptr(mm, pmdp));\n\n\t/* FIFO */\n\tif (!pmd_huge_pte(mm, pmdp))\n\t\tINIT_LIST_HEAD(&pgtable->lru);\n\telse\n\t\tlist_add(&pgtable->lru, &pmd_huge_pte(mm, pmdp)->lru);\n\tpmd_huge_pte(mm, pmdp) = pgtable;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lru_cache_add_active_or_unevictable",
          "args": [
            "new_page",
            "vma"
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "lru_cache_add_active_or_unevictable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "458-476",
          "snippet": "void lru_cache_add_active_or_unevictable(struct page *page,\n\t\t\t\t\t struct vm_area_struct *vma)\n{\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\n\tif (likely((vma->vm_flags & (VM_LOCKED | VM_SPECIAL)) != VM_LOCKED))\n\t\tSetPageActive(page);\n\telse if (!TestSetPageMlocked(page)) {\n\t\t/*\n\t\t * We use the irq-unsafe __mod_zone_page_stat because this\n\t\t * counter is not modified from interrupt context, and the pte\n\t\t * lock is held(spinlock), which implies preemption disabled.\n\t\t */\n\t\t__mod_zone_page_state(page_zone(page), NR_MLOCK,\n\t\t\t\t    hpage_nr_pages(page));\n\t\tcount_vm_event(UNEVICTABLE_PGMLOCKED);\n\t}\n\tlru_cache_add(page);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid lru_cache_add_active_or_unevictable(struct page *page,\n\t\t\t\t\t struct vm_area_struct *vma)\n{\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\n\tif (likely((vma->vm_flags & (VM_LOCKED | VM_SPECIAL)) != VM_LOCKED))\n\t\tSetPageActive(page);\n\telse if (!TestSetPageMlocked(page)) {\n\t\t/*\n\t\t * We use the irq-unsafe __mod_zone_page_stat because this\n\t\t * counter is not modified from interrupt context, and the pte\n\t\t * lock is held(spinlock), which implies preemption disabled.\n\t\t */\n\t\t__mod_zone_page_state(page_zone(page), NR_MLOCK,\n\t\t\t\t    hpage_nr_pages(page));\n\t\tcount_vm_event(UNEVICTABLE_PGMLOCKED);\n\t}\n\tlru_cache_add(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_commit_charge",
          "args": [
            "new_page",
            "memcg",
            "false",
            "true"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_commit_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5928-5962",
          "snippet": "void mem_cgroup_commit_charge(struct page *page, struct mem_cgroup *memcg,\n\t\t\t      bool lrucare, bool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_PAGE(!page->mapping, page);\n\tVM_BUG_ON_PAGE(PageLRU(page) && !lrucare, page);\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcommit_charge(page, memcg, lrucare);\n\n\tlocal_irq_disable();\n\tmem_cgroup_charge_statistics(memcg, page, compound, nr_pages);\n\tmemcg_check_events(memcg, page);\n\tlocal_irq_enable();\n\n\tif (do_memsw_account() && PageSwapCache(page)) {\n\t\tswp_entry_t entry = { .val = page_private(page) };\n\t\t/*\n\t\t * The swap entry might not get freed for a long time,\n\t\t * let's not wait for it.  The page already received a\n\t\t * memory+swap charge, drop the swap entry duplicate.\n\t\t */\n\t\tmem_cgroup_uncharge_swap(entry, nr_pages);\n\t}\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid mem_cgroup_commit_charge(struct page *page, struct mem_cgroup *memcg,\n\t\t\t      bool lrucare, bool compound)\n{\n\tunsigned int nr_pages = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_PAGE(!page->mapping, page);\n\tVM_BUG_ON_PAGE(PageLRU(page) && !lrucare, page);\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\t/*\n\t * Swap faults will attempt to charge the same page multiple\n\t * times.  But reuse_swap_page() might have removed the page\n\t * from swapcache already, so we can't check PageSwapCache().\n\t */\n\tif (!memcg)\n\t\treturn;\n\n\tcommit_charge(page, memcg, lrucare);\n\n\tlocal_irq_disable();\n\tmem_cgroup_charge_statistics(memcg, page, compound, nr_pages);\n\tmemcg_check_events(memcg, page);\n\tlocal_irq_enable();\n\n\tif (do_memsw_account() && PageSwapCache(page)) {\n\t\tswp_entry_t entry = { .val = page_private(page) };\n\t\t/*\n\t\t * The swap entry might not get freed for a long time,\n\t\t * let's not wait for it.  The page already received a\n\t\t * memory+swap charge, drop the swap entry duplicate.\n\t\t */\n\t\tmem_cgroup_uncharge_swap(entry, nr_pages);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_add_new_anon_rmap",
          "args": [
            "new_page",
            "vma",
            "address",
            "true"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "page_add_new_anon_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1150-1170",
          "snippet": "void page_add_new_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, bool compound)\n{\n\tint nr = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_VMA(address < vma->vm_start || address >= vma->vm_end, vma);\n\t__SetPageSwapBacked(page);\n\tif (compound) {\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(compound_mapcount_ptr(page), 0);\n\t\t__inc_node_page_state(page, NR_ANON_THPS);\n\t} else {\n\t\t/* Anon THP always mapped first with PMD */\n\t\tVM_BUG_ON_PAGE(PageTransCompound(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(&page->_mapcount, 0);\n\t}\n\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, nr);\n\t__page_set_anon_rmap(page, vma, address, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid page_add_new_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address, bool compound)\n{\n\tint nr = compound ? hpage_nr_pages(page) : 1;\n\n\tVM_BUG_ON_VMA(address < vma->vm_start || address >= vma->vm_end, vma);\n\t__SetPageSwapBacked(page);\n\tif (compound) {\n\t\tVM_BUG_ON_PAGE(!PageTransHuge(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(compound_mapcount_ptr(page), 0);\n\t\t__inc_node_page_state(page, NR_ANON_THPS);\n\t} else {\n\t\t/* Anon THP always mapped first with PMD */\n\t\tVM_BUG_ON_PAGE(PageTransCompound(page), page);\n\t\t/* increment count (starts at -1) */\n\t\tatomic_set(&page->_mapcount, 0);\n\t}\n\t__mod_node_page_state(page_pgdat(page), NR_ANON_MAPPED, nr);\n\t__page_set_anon_rmap(page, vma, address, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!pmd_none(*pmd)"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_none",
          "args": [
            "*pmd"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "pmd_ptl"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "maybe_pmd_mkwrite",
          "args": [
            "pmd_mkdirty(_pmd)",
            "vma"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_pmd_mkwrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "477-482",
          "snippet": "pmd_t maybe_pmd_mkwrite(pmd_t pmd, struct vm_area_struct *vma)\n{\n\tif (likely(vma->vm_flags & VM_WRITE))\n\t\tpmd = pmd_mkwrite(pmd);\n\treturn pmd;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\npmd_t maybe_pmd_mkwrite(pmd_t pmd, struct vm_area_struct *vma)\n{\n\tif (likely(vma->vm_flags & VM_WRITE))\n\t\tpmd = pmd_mkwrite(pmd);\n\treturn pmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_mkdirty",
          "args": [
            "_pmd"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mk_huge_pmd",
          "args": [
            "new_page",
            "vma->vm_page_prot"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_pgtable",
          "args": [
            "_pmd"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__SetPageUptodate",
          "args": [
            "new_page"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unmap",
          "args": [
            "pte"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__collapse_huge_page_copy",
          "args": [
            "pte",
            "new_page",
            "vma",
            "address",
            "pte_ptl"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "__collapse_huge_page_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "634-681",
          "snippet": "static void __collapse_huge_page_copy(pte_t *pte, struct page *page,\n\t\t\t\t      struct vm_area_struct *vma,\n\t\t\t\t      unsigned long address,\n\t\t\t\t      spinlock_t *ptl)\n{\n\tpte_t *_pte;\n\tfor (_pte = pte; _pte < pte + HPAGE_PMD_NR;\n\t\t\t\t_pte++, page++, address += PAGE_SIZE) {\n\t\tpte_t pteval = *_pte;\n\t\tstruct page *src_page;\n\n\t\tif (pte_none(pteval) || is_zero_pfn(pte_pfn(pteval))) {\n\t\t\tclear_user_highpage(page, address);\n\t\t\tadd_mm_counter(vma->vm_mm, MM_ANONPAGES, 1);\n\t\t\tif (is_zero_pfn(pte_pfn(pteval))) {\n\t\t\t\t/*\n\t\t\t\t * ptl mostly unnecessary.\n\t\t\t\t */\n\t\t\t\tspin_lock(ptl);\n\t\t\t\t/*\n\t\t\t\t * paravirt calls inside pte_clear here are\n\t\t\t\t * superfluous.\n\t\t\t\t */\n\t\t\t\tpte_clear(vma->vm_mm, address, _pte);\n\t\t\t\tspin_unlock(ptl);\n\t\t\t}\n\t\t} else {\n\t\t\tsrc_page = pte_page(pteval);\n\t\t\tcopy_user_highpage(page, src_page, address, vma);\n\t\t\tVM_BUG_ON_PAGE(page_mapcount(src_page) != 1, src_page);\n\t\t\trelease_pte_page(src_page);\n\t\t\t/*\n\t\t\t * ptl mostly unnecessary, but preempt has to\n\t\t\t * be disabled to update the per-cpu stats\n\t\t\t * inside page_remove_rmap().\n\t\t\t */\n\t\t\tspin_lock(ptl);\n\t\t\t/*\n\t\t\t * paravirt calls inside pte_clear here are\n\t\t\t * superfluous.\n\t\t\t */\n\t\t\tpte_clear(vma->vm_mm, address, _pte);\n\t\t\tpage_remove_rmap(src_page, false);\n\t\t\tspin_unlock(ptl);\n\t\t\tfree_page_and_swap_cache(src_page);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void __collapse_huge_page_copy(pte_t *pte, struct page *page,\n\t\t\t\t      struct vm_area_struct *vma,\n\t\t\t\t      unsigned long address,\n\t\t\t\t      spinlock_t *ptl)\n{\n\tpte_t *_pte;\n\tfor (_pte = pte; _pte < pte + HPAGE_PMD_NR;\n\t\t\t\t_pte++, page++, address += PAGE_SIZE) {\n\t\tpte_t pteval = *_pte;\n\t\tstruct page *src_page;\n\n\t\tif (pte_none(pteval) || is_zero_pfn(pte_pfn(pteval))) {\n\t\t\tclear_user_highpage(page, address);\n\t\t\tadd_mm_counter(vma->vm_mm, MM_ANONPAGES, 1);\n\t\t\tif (is_zero_pfn(pte_pfn(pteval))) {\n\t\t\t\t/*\n\t\t\t\t * ptl mostly unnecessary.\n\t\t\t\t */\n\t\t\t\tspin_lock(ptl);\n\t\t\t\t/*\n\t\t\t\t * paravirt calls inside pte_clear here are\n\t\t\t\t * superfluous.\n\t\t\t\t */\n\t\t\t\tpte_clear(vma->vm_mm, address, _pte);\n\t\t\t\tspin_unlock(ptl);\n\t\t\t}\n\t\t} else {\n\t\t\tsrc_page = pte_page(pteval);\n\t\t\tcopy_user_highpage(page, src_page, address, vma);\n\t\t\tVM_BUG_ON_PAGE(page_mapcount(src_page) != 1, src_page);\n\t\t\trelease_pte_page(src_page);\n\t\t\t/*\n\t\t\t * ptl mostly unnecessary, but preempt has to\n\t\t\t * be disabled to update the per-cpu stats\n\t\t\t * inside page_remove_rmap().\n\t\t\t */\n\t\t\tspin_lock(ptl);\n\t\t\t/*\n\t\t\t * paravirt calls inside pte_clear here are\n\t\t\t * superfluous.\n\t\t\t */\n\t\t\tpte_clear(vma->vm_mm, address, _pte);\n\t\t\tpage_remove_rmap(src_page, false);\n\t\t\tspin_unlock(ptl);\n\t\t\tfree_page_and_swap_cache(src_page);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "anon_vma_unlock_write",
          "args": [
            "vma->anon_vma"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_vma_unlock_write",
          "args": [
            "vma->anon_vma"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "pmd_ptl"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_populate",
          "args": [
            "mm",
            "pmd",
            "pmd_pgtable(_pmd)"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "zero_pmd_populate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan_init.c",
          "lines": "105-135",
          "snippet": "static int __ref zero_pmd_populate(pud_t *pud, unsigned long addr,\n\t\t\t\tunsigned long end)\n{\n\tpmd_t *pmd = pmd_offset(pud, addr);\n\tunsigned long next;\n\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\n\t\tif (IS_ALIGNED(addr, PMD_SIZE) && end - addr >= PMD_SIZE) {\n\t\t\tpmd_populate_kernel(&init_mm, pmd, lm_alias(kasan_zero_pte));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pmd_none(*pmd)) {\n\t\t\tpte_t *p;\n\n\t\t\tif (slab_is_available())\n\t\t\t\tp = pte_alloc_one_kernel(&init_mm, addr);\n\t\t\telse\n\t\t\t\tp = early_alloc(PAGE_SIZE, NUMA_NO_NODE);\n\t\t\tif (!p)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tpmd_populate_kernel(&init_mm, pmd, p);\n\t\t}\n\t\tzero_pte_populate(pmd, addr, next);\n\t} while (pmd++, addr = next, addr != end);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kasan.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/page.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/memblock.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "pte_t kasan_zero_pte[PTRS_PER_PTE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kasan.h\"\n#include <asm/pgalloc.h>\n#include <asm/page.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/memblock.h>\n\npte_t kasan_zero_pte[PTRS_PER_PTE];\n\nstatic int __ref zero_pmd_populate(pud_t *pud, unsigned long addr,\n\t\t\t\tunsigned long end)\n{\n\tpmd_t *pmd = pmd_offset(pud, addr);\n\tunsigned long next;\n\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\n\t\tif (IS_ALIGNED(addr, PMD_SIZE) && end - addr >= PMD_SIZE) {\n\t\t\tpmd_populate_kernel(&init_mm, pmd, lm_alias(kasan_zero_pte));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pmd_none(*pmd)) {\n\t\t\tpte_t *p;\n\n\t\t\tif (slab_is_available())\n\t\t\t\tp = pte_alloc_one_kernel(&init_mm, addr);\n\t\t\telse\n\t\t\t\tp = early_alloc(PAGE_SIZE, NUMA_NO_NODE);\n\t\t\tif (!p)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tpmd_populate_kernel(&init_mm, pmd, p);\n\t\t}\n\t\tzero_pte_populate(pmd, addr, next);\n\t} while (pmd++, addr = next, addr != end);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_pgtable",
          "args": [
            "_pmd"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!pmd_none(*pmd)"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmd_none",
          "args": [
            "*pmd"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "pmd_ptl"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unmap",
          "args": [
            "pte"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!isolated"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "pte_ptl"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__collapse_huge_page_isolate",
          "args": [
            "vma",
            "address",
            "pte"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "__collapse_huge_page_isolate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "520-632",
          "snippet": "static int __collapse_huge_page_isolate(struct vm_area_struct *vma,\n\t\t\t\t\tunsigned long address,\n\t\t\t\t\tpte_t *pte)\n{\n\tstruct page *page = NULL;\n\tpte_t *_pte;\n\tint none_or_zero = 0, result = 0, referenced = 0;\n\tbool writable = false;\n\n\tfor (_pte = pte; _pte < pte+HPAGE_PMD_NR;\n\t     _pte++, address += PAGE_SIZE) {\n\t\tpte_t pteval = *_pte;\n\t\tif (pte_none(pteval) || (pte_present(pteval) &&\n\t\t\t\tis_zero_pfn(pte_pfn(pteval)))) {\n\t\t\tif (!userfaultfd_armed(vma) &&\n\t\t\t    ++none_or_zero <= khugepaged_max_ptes_none) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tresult = SCAN_EXCEED_NONE_PTE;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (!pte_present(pteval)) {\n\t\t\tresult = SCAN_PTE_NON_PRESENT;\n\t\t\tgoto out;\n\t\t}\n\t\tpage = vm_normal_page(vma, address, pteval);\n\t\tif (unlikely(!page)) {\n\t\t\tresult = SCAN_PAGE_NULL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* TODO: teach khugepaged to collapse THP mapped with pte */\n\t\tif (PageCompound(page)) {\n\t\t\tresult = SCAN_PAGE_COMPOUND;\n\t\t\tgoto out;\n\t\t}\n\n\t\tVM_BUG_ON_PAGE(!PageAnon(page), page);\n\n\t\t/*\n\t\t * We can do it before isolate_lru_page because the\n\t\t * page can't be freed from under us. NOTE: PG_lock\n\t\t * is needed to serialize against split_huge_page\n\t\t * when invoked from the VM.\n\t\t */\n\t\tif (!trylock_page(page)) {\n\t\t\tresult = SCAN_PAGE_LOCK;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * cannot use mapcount: can't collapse if there's a gup pin.\n\t\t * The page must only be referenced by the scanned process\n\t\t * and page swap cache.\n\t\t */\n\t\tif (page_count(page) != 1 + PageSwapCache(page)) {\n\t\t\tunlock_page(page);\n\t\t\tresult = SCAN_PAGE_COUNT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (pte_write(pteval)) {\n\t\t\twritable = true;\n\t\t} else {\n\t\t\tif (PageSwapCache(page) &&\n\t\t\t    !reuse_swap_page(page, NULL)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tresult = SCAN_SWAP_CACHE_PAGE;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Page is not in the swap cache. It can be collapsed\n\t\t\t * into a THP.\n\t\t\t */\n\t\t}\n\n\t\t/*\n\t\t * Isolate the page to avoid collapsing an hugepage\n\t\t * currently in use by the VM.\n\t\t */\n\t\tif (isolate_lru_page(page)) {\n\t\t\tunlock_page(page);\n\t\t\tresult = SCAN_DEL_PAGE_LRU;\n\t\t\tgoto out;\n\t\t}\n\t\tinc_node_page_state(page,\n\t\t\t\tNR_ISOLATED_ANON + page_is_file_cache(page));\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\t\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\n\t\t/* There should be enough young pte to collapse the page */\n\t\tif (pte_young(pteval) ||\n\t\t    page_is_young(page) || PageReferenced(page) ||\n\t\t    mmu_notifier_test_young(vma->vm_mm, address))\n\t\t\treferenced++;\n\t}\n\tif (likely(writable)) {\n\t\tif (likely(referenced)) {\n\t\t\tresult = SCAN_SUCCEED;\n\t\t\ttrace_mm_collapse_huge_page_isolate(page, none_or_zero,\n\t\t\t\t\t\t\t    referenced, writable, result);\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\tresult = SCAN_PAGE_RO;\n\t}\n\nout:\n\trelease_pte_pages(pte, _pte);\n\ttrace_mm_collapse_huge_page_isolate(page, none_or_zero,\n\t\t\t\t\t    referenced, writable, result);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int khugepaged_max_ptes_none"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic unsigned int khugepaged_max_ptes_none;\n\nstatic int __collapse_huge_page_isolate(struct vm_area_struct *vma,\n\t\t\t\t\tunsigned long address,\n\t\t\t\t\tpte_t *pte)\n{\n\tstruct page *page = NULL;\n\tpte_t *_pte;\n\tint none_or_zero = 0, result = 0, referenced = 0;\n\tbool writable = false;\n\n\tfor (_pte = pte; _pte < pte+HPAGE_PMD_NR;\n\t     _pte++, address += PAGE_SIZE) {\n\t\tpte_t pteval = *_pte;\n\t\tif (pte_none(pteval) || (pte_present(pteval) &&\n\t\t\t\tis_zero_pfn(pte_pfn(pteval)))) {\n\t\t\tif (!userfaultfd_armed(vma) &&\n\t\t\t    ++none_or_zero <= khugepaged_max_ptes_none) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tresult = SCAN_EXCEED_NONE_PTE;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (!pte_present(pteval)) {\n\t\t\tresult = SCAN_PTE_NON_PRESENT;\n\t\t\tgoto out;\n\t\t}\n\t\tpage = vm_normal_page(vma, address, pteval);\n\t\tif (unlikely(!page)) {\n\t\t\tresult = SCAN_PAGE_NULL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* TODO: teach khugepaged to collapse THP mapped with pte */\n\t\tif (PageCompound(page)) {\n\t\t\tresult = SCAN_PAGE_COMPOUND;\n\t\t\tgoto out;\n\t\t}\n\n\t\tVM_BUG_ON_PAGE(!PageAnon(page), page);\n\n\t\t/*\n\t\t * We can do it before isolate_lru_page because the\n\t\t * page can't be freed from under us. NOTE: PG_lock\n\t\t * is needed to serialize against split_huge_page\n\t\t * when invoked from the VM.\n\t\t */\n\t\tif (!trylock_page(page)) {\n\t\t\tresult = SCAN_PAGE_LOCK;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * cannot use mapcount: can't collapse if there's a gup pin.\n\t\t * The page must only be referenced by the scanned process\n\t\t * and page swap cache.\n\t\t */\n\t\tif (page_count(page) != 1 + PageSwapCache(page)) {\n\t\t\tunlock_page(page);\n\t\t\tresult = SCAN_PAGE_COUNT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (pte_write(pteval)) {\n\t\t\twritable = true;\n\t\t} else {\n\t\t\tif (PageSwapCache(page) &&\n\t\t\t    !reuse_swap_page(page, NULL)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tresult = SCAN_SWAP_CACHE_PAGE;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Page is not in the swap cache. It can be collapsed\n\t\t\t * into a THP.\n\t\t\t */\n\t\t}\n\n\t\t/*\n\t\t * Isolate the page to avoid collapsing an hugepage\n\t\t * currently in use by the VM.\n\t\t */\n\t\tif (isolate_lru_page(page)) {\n\t\t\tunlock_page(page);\n\t\t\tresult = SCAN_DEL_PAGE_LRU;\n\t\t\tgoto out;\n\t\t}\n\t\tinc_node_page_state(page,\n\t\t\t\tNR_ISOLATED_ANON + page_is_file_cache(page));\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\t\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\n\t\t/* There should be enough young pte to collapse the page */\n\t\tif (pte_young(pteval) ||\n\t\t    page_is_young(page) || PageReferenced(page) ||\n\t\t    mmu_notifier_test_young(vma->vm_mm, address))\n\t\t\treferenced++;\n\t}\n\tif (likely(writable)) {\n\t\tif (likely(referenced)) {\n\t\t\tresult = SCAN_SUCCEED;\n\t\t\ttrace_mm_collapse_huge_page_isolate(page, none_or_zero,\n\t\t\t\t\t\t\t    referenced, writable, result);\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\tresult = SCAN_PAGE_RO;\n\t}\n\nout:\n\trelease_pte_pages(pte, _pte);\n\ttrace_mm_collapse_huge_page_isolate(page, none_or_zero,\n\t\t\t\t\t    referenced, writable, result);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "pte_ptl"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_end",
          "args": [
            "mm",
            "mmun_start",
            "mmun_end"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "pmd_ptl"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmdp_collapse_flush",
          "args": [
            "vma",
            "address",
            "pmd"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "pmdp_collapse_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/pgtable-generic.c",
          "lines": "195-211",
          "snippet": "pmd_t pmdp_collapse_flush(struct vm_area_struct *vma, unsigned long address,\n\t\t\t  pmd_t *pmdp)\n{\n\t/*\n\t * pmd and hugepage pte format are same. So we could\n\t * use the same function.\n\t */\n\tpmd_t pmd;\n\n\tVM_BUG_ON(address & ~HPAGE_PMD_MASK);\n\tVM_BUG_ON(pmd_trans_huge(*pmdp));\n\tpmd = pmdp_huge_get_and_clear(vma->vm_mm, address, pmdp);\n\n\t/* collapse entails shooting down ptes not pmd */\n\tflush_tlb_range(vma, address, address + HPAGE_PMD_SIZE);\n\treturn pmd;\n}",
          "includes": [
            "#include <asm-generic/pgtable.h>",
            "#include <asm/tlb.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm-generic/pgtable.h>\n#include <asm/tlb.h>\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n\npmd_t pmdp_collapse_flush(struct vm_area_struct *vma, unsigned long address,\n\t\t\t  pmd_t *pmdp)\n{\n\t/*\n\t * pmd and hugepage pte format are same. So we could\n\t * use the same function.\n\t */\n\tpmd_t pmd;\n\n\tVM_BUG_ON(address & ~HPAGE_PMD_MASK);\n\tVM_BUG_ON(pmd_trans_huge(*pmdp));\n\tpmd = pmdp_huge_get_and_clear(vma->vm_mm, address, pmdp);\n\n\t/* collapse entails shooting down ptes not pmd */\n\tflush_tlb_range(vma, address, address + HPAGE_PMD_SIZE);\n\treturn pmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmd_lock",
          "args": [
            "mm",
            "pmd"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_start",
          "args": [
            "mm",
            "mmun_start",
            "mmun_end"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_lockptr",
          "args": [
            "mm",
            "pmd"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_offset_map",
          "args": [
            "pmd",
            "address"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_vma_lock_write",
          "args": [
            "vma->anon_vma"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_find_pmd",
          "args": [
            "mm",
            "address"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "mm_find_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "710-742",
          "snippet": "pmd_t *mm_find_pmd(struct mm_struct *mm, unsigned long address)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd = NULL;\n\tpmd_t pmde;\n\n\tpgd = pgd_offset(mm, address);\n\tif (!pgd_present(*pgd))\n\t\tgoto out;\n\n\tp4d = p4d_offset(pgd, address);\n\tif (!p4d_present(*p4d))\n\t\tgoto out;\n\n\tpud = pud_offset(p4d, address);\n\tif (!pud_present(*pud))\n\t\tgoto out;\n\n\tpmd = pmd_offset(pud, address);\n\t/*\n\t * Some THP functions use the sequence pmdp_huge_clear_flush(), set_pmd_at()\n\t * without holding anon_vma lock for write.  So when looking for a\n\t * genuine pmde (in which to find pte), test present and !THP together.\n\t */\n\tpmde = *pmd;\n\tbarrier();\n\tif (!pmd_present(pmde) || pmd_trans_huge(pmde))\n\t\tpmd = NULL;\nout:\n\treturn pmd;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\npmd_t *mm_find_pmd(struct mm_struct *mm, unsigned long address)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd = NULL;\n\tpmd_t pmde;\n\n\tpgd = pgd_offset(mm, address);\n\tif (!pgd_present(*pgd))\n\t\tgoto out;\n\n\tp4d = p4d_offset(pgd, address);\n\tif (!p4d_present(*p4d))\n\t\tgoto out;\n\n\tpud = pud_offset(p4d, address);\n\tif (!pud_present(*pud))\n\t\tgoto out;\n\n\tpmd = pmd_offset(pud, address);\n\t/*\n\t * Some THP functions use the sequence pmdp_huge_clear_flush(), set_pmd_at()\n\t * without holding anon_vma lock for write.  So when looking for a\n\t * genuine pmde (in which to find pte), test present and !THP together.\n\t */\n\tpmde = *pmd;\n\tbarrier();\n\tif (!pmd_present(pmde) || pmd_trans_huge(pmde))\n\t\tpmd = NULL;\nout:\n\treturn pmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hugepage_vma_revalidate",
          "args": [
            "mm",
            "address",
            "&vma"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "hugepage_vma_revalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "848-868",
          "snippet": "static int hugepage_vma_revalidate(struct mm_struct *mm, unsigned long address,\n\t\tstruct vm_area_struct **vmap)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned long hstart, hend;\n\n\tif (unlikely(khugepaged_test_exit(mm)))\n\t\treturn SCAN_ANY_PROCESS;\n\n\t*vmap = vma = find_vma(mm, address);\n\tif (!vma)\n\t\treturn SCAN_VMA_NULL;\n\n\thstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;\n\thend = vma->vm_end & HPAGE_PMD_MASK;\n\tif (address < hstart || address + HPAGE_PMD_SIZE > hend)\n\t\treturn SCAN_ADDRESS_RANGE;\n\tif (!hugepage_vma_check(vma, vma->vm_flags))\n\t\treturn SCAN_VMA_CHECK;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic int hugepage_vma_revalidate(struct mm_struct *mm, unsigned long address,\n\t\tstruct vm_area_struct **vmap)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned long hstart, hend;\n\n\tif (unlikely(khugepaged_test_exit(mm)))\n\t\treturn SCAN_ANY_PROCESS;\n\n\t*vmap = vma = find_vma(mm, address);\n\tif (!vma)\n\t\treturn SCAN_VMA_NULL;\n\n\thstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;\n\thend = vma->vm_end & HPAGE_PMD_MASK;\n\tif (address < hstart || address + HPAGE_PMD_SIZE > hend)\n\t\treturn SCAN_ADDRESS_RANGE;\n\tif (!hugepage_vma_check(vma, vma->vm_flags))\n\t\treturn SCAN_VMA_CHECK;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__collapse_huge_page_swapin",
          "args": [
            "mm",
            "vma",
            "address",
            "pmd",
            "referenced"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "__collapse_huge_page_swapin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "878-932",
          "snippet": "static bool __collapse_huge_page_swapin(struct mm_struct *mm,\n\t\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\t\tunsigned long address, pmd_t *pmd,\n\t\t\t\t\tint referenced)\n{\n\tint swapped_in = 0;\n\tvm_fault_t ret = 0;\n\tstruct vm_fault vmf = {\n\t\t.vma = vma,\n\t\t.address = address,\n\t\t.flags = FAULT_FLAG_ALLOW_RETRY,\n\t\t.pmd = pmd,\n\t\t.pgoff = linear_page_index(vma, address),\n\t};\n\n\t/* we only decide to swapin, if there is enough young ptes */\n\tif (referenced < HPAGE_PMD_NR/2) {\n\t\ttrace_mm_collapse_huge_page_swapin(mm, swapped_in, referenced, 0);\n\t\treturn false;\n\t}\n\tvmf.pte = pte_offset_map(pmd, address);\n\tfor (; vmf.address < address + HPAGE_PMD_NR*PAGE_SIZE;\n\t\t\tvmf.pte++, vmf.address += PAGE_SIZE) {\n\t\tvmf.orig_pte = *vmf.pte;\n\t\tif (!is_swap_pte(vmf.orig_pte))\n\t\t\tcontinue;\n\t\tswapped_in++;\n\t\tret = do_swap_page(&vmf);\n\n\t\t/* do_swap_page returns VM_FAULT_RETRY with released mmap_sem */\n\t\tif (ret & VM_FAULT_RETRY) {\n\t\t\tdown_read(&mm->mmap_sem);\n\t\t\tif (hugepage_vma_revalidate(mm, address, &vmf.vma)) {\n\t\t\t\t/* vma is no longer available, don't continue to swapin */\n\t\t\t\ttrace_mm_collapse_huge_page_swapin(mm, swapped_in, referenced, 0);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t/* check if the pmd is still valid */\n\t\t\tif (mm_find_pmd(mm, address) != pmd) {\n\t\t\t\ttrace_mm_collapse_huge_page_swapin(mm, swapped_in, referenced, 0);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (ret & VM_FAULT_ERROR) {\n\t\t\ttrace_mm_collapse_huge_page_swapin(mm, swapped_in, referenced, 0);\n\t\t\treturn false;\n\t\t}\n\t\t/* pte is unmapped now, we need to map it */\n\t\tvmf.pte = pte_offset_map(pmd, vmf.address);\n\t}\n\tvmf.pte--;\n\tpte_unmap(vmf.pte);\n\ttrace_mm_collapse_huge_page_swapin(mm, swapped_in, referenced, 1);\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic bool __collapse_huge_page_swapin(struct mm_struct *mm,\n\t\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\t\tunsigned long address, pmd_t *pmd,\n\t\t\t\t\tint referenced)\n{\n\tint swapped_in = 0;\n\tvm_fault_t ret = 0;\n\tstruct vm_fault vmf = {\n\t\t.vma = vma,\n\t\t.address = address,\n\t\t.flags = FAULT_FLAG_ALLOW_RETRY,\n\t\t.pmd = pmd,\n\t\t.pgoff = linear_page_index(vma, address),\n\t};\n\n\t/* we only decide to swapin, if there is enough young ptes */\n\tif (referenced < HPAGE_PMD_NR/2) {\n\t\ttrace_mm_collapse_huge_page_swapin(mm, swapped_in, referenced, 0);\n\t\treturn false;\n\t}\n\tvmf.pte = pte_offset_map(pmd, address);\n\tfor (; vmf.address < address + HPAGE_PMD_NR*PAGE_SIZE;\n\t\t\tvmf.pte++, vmf.address += PAGE_SIZE) {\n\t\tvmf.orig_pte = *vmf.pte;\n\t\tif (!is_swap_pte(vmf.orig_pte))\n\t\t\tcontinue;\n\t\tswapped_in++;\n\t\tret = do_swap_page(&vmf);\n\n\t\t/* do_swap_page returns VM_FAULT_RETRY with released mmap_sem */\n\t\tif (ret & VM_FAULT_RETRY) {\n\t\t\tdown_read(&mm->mmap_sem);\n\t\t\tif (hugepage_vma_revalidate(mm, address, &vmf.vma)) {\n\t\t\t\t/* vma is no longer available, don't continue to swapin */\n\t\t\t\ttrace_mm_collapse_huge_page_swapin(mm, swapped_in, referenced, 0);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t/* check if the pmd is still valid */\n\t\t\tif (mm_find_pmd(mm, address) != pmd) {\n\t\t\t\ttrace_mm_collapse_huge_page_swapin(mm, swapped_in, referenced, 0);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (ret & VM_FAULT_ERROR) {\n\t\t\ttrace_mm_collapse_huge_page_swapin(mm, swapped_in, referenced, 0);\n\t\t\treturn false;\n\t\t}\n\t\t/* pte is unmapped now, we need to map it */\n\t\tvmf.pte = pte_offset_map(pmd, vmf.address);\n\t}\n\tvmf.pte--;\n\tpte_unmap(vmf.pte);\n\ttrace_mm_collapse_huge_page_swapin(mm, swapped_in, referenced, 1);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "mem_cgroup_try_charge(new_page, mm, gfp, &memcg, true)"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_try_charge",
          "args": [
            "new_page",
            "mm",
            "gfp",
            "&memcg",
            "true"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_try_charge_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "5898-5909",
          "snippet": "int mem_cgroup_try_charge_delay(struct page *page, struct mm_struct *mm,\n\t\t\t  gfp_t gfp_mask, struct mem_cgroup **memcgp,\n\t\t\t  bool compound)\n{\n\tstruct mem_cgroup *memcg;\n\tint ret;\n\n\tret = mem_cgroup_try_charge(page, mm, gfp_mask, memcgp, compound);\n\tmemcg = *memcgp;\n\tmem_cgroup_throttle_swaprate(memcg, page_to_nid(page), gfp_mask);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nint mem_cgroup_try_charge_delay(struct page *page, struct mm_struct *mm,\n\t\t\t  gfp_t gfp_mask, struct mem_cgroup **memcgp,\n\t\t\t  bool compound)\n{\n\tstruct mem_cgroup *memcg;\n\tint ret;\n\n\tret = mem_cgroup_try_charge(page, mm, gfp_mask, memcgp, compound);\n\tmemcg = *memcgp;\n\tmem_cgroup_throttle_swaprate(memcg, page_to_nid(page), gfp_mask);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "khugepaged_alloc_page",
          "args": [
            "hpage",
            "gfp",
            "node"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "khugepaged_alloc_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "832-838",
          "snippet": "static struct page *\nkhugepaged_alloc_page(struct page **hpage, gfp_t gfp, int node)\n{\n\tVM_BUG_ON(!*hpage);\n\n\treturn  *hpage;\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic struct page *\nkhugepaged_alloc_page(struct page **hpage, gfp_t gfp, int node)\n{\n\tVM_BUG_ON(!*hpage);\n\n\treturn  *hpage;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_hugepage_khugepaged_gfpmask",
          "args": [],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_hugepage_khugepaged_gfpmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "720-723",
          "snippet": "static inline gfp_t alloc_hugepage_khugepaged_gfpmask(void)\n{\n\treturn khugepaged_defrag() ? GFP_TRANSHUGE : GFP_TRANSHUGE_LIGHT;\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic inline gfp_t alloc_hugepage_khugepaged_gfpmask(void)\n{\n\treturn khugepaged_defrag() ? GFP_TRANSHUGE : GFP_TRANSHUGE_LIGHT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "address & ~HPAGE_PMD_MASK"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic unsigned int khugepaged_pages_collapsed;\n\nstatic void collapse_huge_page(struct mm_struct *mm,\n\t\t\t\t   unsigned long address,\n\t\t\t\t   struct page **hpage,\n\t\t\t\t   int node, int referenced)\n{\n\tpmd_t *pmd, _pmd;\n\tpte_t *pte;\n\tpgtable_t pgtable;\n\tstruct page *new_page;\n\tspinlock_t *pmd_ptl, *pte_ptl;\n\tint isolated = 0, result = 0;\n\tstruct mem_cgroup *memcg;\n\tstruct vm_area_struct *vma;\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\tgfp_t gfp;\n\n\tVM_BUG_ON(address & ~HPAGE_PMD_MASK);\n\n\t/* Only allocate from the target node */\n\tgfp = alloc_hugepage_khugepaged_gfpmask() | __GFP_THISNODE;\n\n\t/*\n\t * Before allocating the hugepage, release the mmap_sem read lock.\n\t * The allocation can take potentially a long time if it involves\n\t * sync compaction, and we do not need to hold the mmap_sem during\n\t * that. We will recheck the vma after taking it again in write mode.\n\t */\n\tup_read(&mm->mmap_sem);\n\tnew_page = khugepaged_alloc_page(hpage, gfp, node);\n\tif (!new_page) {\n\t\tresult = SCAN_ALLOC_HUGE_PAGE_FAIL;\n\t\tgoto out_nolock;\n\t}\n\n\tif (unlikely(mem_cgroup_try_charge(new_page, mm, gfp, &memcg, true))) {\n\t\tresult = SCAN_CGROUP_CHARGE_FAIL;\n\t\tgoto out_nolock;\n\t}\n\n\tdown_read(&mm->mmap_sem);\n\tresult = hugepage_vma_revalidate(mm, address, &vma);\n\tif (result) {\n\t\tmem_cgroup_cancel_charge(new_page, memcg, true);\n\t\tup_read(&mm->mmap_sem);\n\t\tgoto out_nolock;\n\t}\n\n\tpmd = mm_find_pmd(mm, address);\n\tif (!pmd) {\n\t\tresult = SCAN_PMD_NULL;\n\t\tmem_cgroup_cancel_charge(new_page, memcg, true);\n\t\tup_read(&mm->mmap_sem);\n\t\tgoto out_nolock;\n\t}\n\n\t/*\n\t * __collapse_huge_page_swapin always returns with mmap_sem locked.\n\t * If it fails, we release mmap_sem and jump out_nolock.\n\t * Continuing to collapse causes inconsistency.\n\t */\n\tif (!__collapse_huge_page_swapin(mm, vma, address, pmd, referenced)) {\n\t\tmem_cgroup_cancel_charge(new_page, memcg, true);\n\t\tup_read(&mm->mmap_sem);\n\t\tgoto out_nolock;\n\t}\n\n\tup_read(&mm->mmap_sem);\n\t/*\n\t * Prevent all access to pagetables with the exception of\n\t * gup_fast later handled by the ptep_clear_flush and the VM\n\t * handled by the anon_vma lock + PG_lock.\n\t */\n\tdown_write(&mm->mmap_sem);\n\tresult = hugepage_vma_revalidate(mm, address, &vma);\n\tif (result)\n\t\tgoto out;\n\t/* check if the pmd is still valid */\n\tif (mm_find_pmd(mm, address) != pmd)\n\t\tgoto out;\n\n\tanon_vma_lock_write(vma->anon_vma);\n\n\tpte = pte_offset_map(pmd, address);\n\tpte_ptl = pte_lockptr(mm, pmd);\n\n\tmmun_start = address;\n\tmmun_end   = address + HPAGE_PMD_SIZE;\n\tmmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);\n\tpmd_ptl = pmd_lock(mm, pmd); /* probably unnecessary */\n\t/*\n\t * After this gup_fast can't run anymore. This also removes\n\t * any huge TLB entry from the CPU so we won't allow\n\t * huge and small TLB entries for the same virtual address\n\t * to avoid the risk of CPU bugs in that area.\n\t */\n\t_pmd = pmdp_collapse_flush(vma, address, pmd);\n\tspin_unlock(pmd_ptl);\n\tmmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);\n\n\tspin_lock(pte_ptl);\n\tisolated = __collapse_huge_page_isolate(vma, address, pte);\n\tspin_unlock(pte_ptl);\n\n\tif (unlikely(!isolated)) {\n\t\tpte_unmap(pte);\n\t\tspin_lock(pmd_ptl);\n\t\tBUG_ON(!pmd_none(*pmd));\n\t\t/*\n\t\t * We can only use set_pmd_at when establishing\n\t\t * hugepmds and never for establishing regular pmds that\n\t\t * points to regular pagetables. Use pmd_populate for that\n\t\t */\n\t\tpmd_populate(mm, pmd, pmd_pgtable(_pmd));\n\t\tspin_unlock(pmd_ptl);\n\t\tanon_vma_unlock_write(vma->anon_vma);\n\t\tresult = SCAN_FAIL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * All pages are isolated and locked so anon_vma rmap\n\t * can't run anymore.\n\t */\n\tanon_vma_unlock_write(vma->anon_vma);\n\n\t__collapse_huge_page_copy(pte, new_page, vma, address, pte_ptl);\n\tpte_unmap(pte);\n\t__SetPageUptodate(new_page);\n\tpgtable = pmd_pgtable(_pmd);\n\n\t_pmd = mk_huge_pmd(new_page, vma->vm_page_prot);\n\t_pmd = maybe_pmd_mkwrite(pmd_mkdirty(_pmd), vma);\n\n\t/*\n\t * spin_lock() below is not the equivalent of smp_wmb(), so\n\t * this is needed to avoid the copy_huge_page writes to become\n\t * visible after the set_pmd_at() write.\n\t */\n\tsmp_wmb();\n\n\tspin_lock(pmd_ptl);\n\tBUG_ON(!pmd_none(*pmd));\n\tpage_add_new_anon_rmap(new_page, vma, address, true);\n\tmem_cgroup_commit_charge(new_page, memcg, false, true);\n\tlru_cache_add_active_or_unevictable(new_page, vma);\n\tpgtable_trans_huge_deposit(mm, pmd, pgtable);\n\tset_pmd_at(mm, address, pmd, _pmd);\n\tupdate_mmu_cache_pmd(vma, address, pmd);\n\tspin_unlock(pmd_ptl);\n\n\t*hpage = NULL;\n\n\tkhugepaged_pages_collapsed++;\n\tresult = SCAN_SUCCEED;\nout_up_write:\n\tup_write(&mm->mmap_sem);\nout_nolock:\n\ttrace_mm_collapse_huge_page(mm, isolated, result);\n\treturn;\nout:\n\tmem_cgroup_cancel_charge(new_page, memcg, true);\n\tgoto out_up_write;\n}"
  },
  {
    "function_name": "__collapse_huge_page_swapin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "878-932",
    "snippet": "static bool __collapse_huge_page_swapin(struct mm_struct *mm,\n\t\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\t\tunsigned long address, pmd_t *pmd,\n\t\t\t\t\tint referenced)\n{\n\tint swapped_in = 0;\n\tvm_fault_t ret = 0;\n\tstruct vm_fault vmf = {\n\t\t.vma = vma,\n\t\t.address = address,\n\t\t.flags = FAULT_FLAG_ALLOW_RETRY,\n\t\t.pmd = pmd,\n\t\t.pgoff = linear_page_index(vma, address),\n\t};\n\n\t/* we only decide to swapin, if there is enough young ptes */\n\tif (referenced < HPAGE_PMD_NR/2) {\n\t\ttrace_mm_collapse_huge_page_swapin(mm, swapped_in, referenced, 0);\n\t\treturn false;\n\t}\n\tvmf.pte = pte_offset_map(pmd, address);\n\tfor (; vmf.address < address + HPAGE_PMD_NR*PAGE_SIZE;\n\t\t\tvmf.pte++, vmf.address += PAGE_SIZE) {\n\t\tvmf.orig_pte = *vmf.pte;\n\t\tif (!is_swap_pte(vmf.orig_pte))\n\t\t\tcontinue;\n\t\tswapped_in++;\n\t\tret = do_swap_page(&vmf);\n\n\t\t/* do_swap_page returns VM_FAULT_RETRY with released mmap_sem */\n\t\tif (ret & VM_FAULT_RETRY) {\n\t\t\tdown_read(&mm->mmap_sem);\n\t\t\tif (hugepage_vma_revalidate(mm, address, &vmf.vma)) {\n\t\t\t\t/* vma is no longer available, don't continue to swapin */\n\t\t\t\ttrace_mm_collapse_huge_page_swapin(mm, swapped_in, referenced, 0);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t/* check if the pmd is still valid */\n\t\t\tif (mm_find_pmd(mm, address) != pmd) {\n\t\t\t\ttrace_mm_collapse_huge_page_swapin(mm, swapped_in, referenced, 0);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (ret & VM_FAULT_ERROR) {\n\t\t\ttrace_mm_collapse_huge_page_swapin(mm, swapped_in, referenced, 0);\n\t\t\treturn false;\n\t\t}\n\t\t/* pte is unmapped now, we need to map it */\n\t\tvmf.pte = pte_offset_map(pmd, vmf.address);\n\t}\n\tvmf.pte--;\n\tpte_unmap(vmf.pte);\n\ttrace_mm_collapse_huge_page_swapin(mm, swapped_in, referenced, 1);\n\treturn true;\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_mm_collapse_huge_page_swapin",
          "args": [
            "mm",
            "swapped_in",
            "referenced",
            "1"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_unmap",
          "args": [
            "vmf.pte"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_offset_map",
          "args": [
            "pmd",
            "vmf.address"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_mm_collapse_huge_page_swapin",
          "args": [
            "mm",
            "swapped_in",
            "referenced",
            "0"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_mm_collapse_huge_page_swapin",
          "args": [
            "mm",
            "swapped_in",
            "referenced",
            "0"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_find_pmd",
          "args": [
            "mm",
            "address"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "mm_find_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "710-742",
          "snippet": "pmd_t *mm_find_pmd(struct mm_struct *mm, unsigned long address)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd = NULL;\n\tpmd_t pmde;\n\n\tpgd = pgd_offset(mm, address);\n\tif (!pgd_present(*pgd))\n\t\tgoto out;\n\n\tp4d = p4d_offset(pgd, address);\n\tif (!p4d_present(*p4d))\n\t\tgoto out;\n\n\tpud = pud_offset(p4d, address);\n\tif (!pud_present(*pud))\n\t\tgoto out;\n\n\tpmd = pmd_offset(pud, address);\n\t/*\n\t * Some THP functions use the sequence pmdp_huge_clear_flush(), set_pmd_at()\n\t * without holding anon_vma lock for write.  So when looking for a\n\t * genuine pmde (in which to find pte), test present and !THP together.\n\t */\n\tpmde = *pmd;\n\tbarrier();\n\tif (!pmd_present(pmde) || pmd_trans_huge(pmde))\n\t\tpmd = NULL;\nout:\n\treturn pmd;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\npmd_t *mm_find_pmd(struct mm_struct *mm, unsigned long address)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd = NULL;\n\tpmd_t pmde;\n\n\tpgd = pgd_offset(mm, address);\n\tif (!pgd_present(*pgd))\n\t\tgoto out;\n\n\tp4d = p4d_offset(pgd, address);\n\tif (!p4d_present(*p4d))\n\t\tgoto out;\n\n\tpud = pud_offset(p4d, address);\n\tif (!pud_present(*pud))\n\t\tgoto out;\n\n\tpmd = pmd_offset(pud, address);\n\t/*\n\t * Some THP functions use the sequence pmdp_huge_clear_flush(), set_pmd_at()\n\t * without holding anon_vma lock for write.  So when looking for a\n\t * genuine pmde (in which to find pte), test present and !THP together.\n\t */\n\tpmde = *pmd;\n\tbarrier();\n\tif (!pmd_present(pmde) || pmd_trans_huge(pmde))\n\t\tpmd = NULL;\nout:\n\treturn pmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_mm_collapse_huge_page_swapin",
          "args": [
            "mm",
            "swapped_in",
            "referenced",
            "0"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugepage_vma_revalidate",
          "args": [
            "mm",
            "address",
            "&vmf.vma"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "hugepage_vma_revalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "848-868",
          "snippet": "static int hugepage_vma_revalidate(struct mm_struct *mm, unsigned long address,\n\t\tstruct vm_area_struct **vmap)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned long hstart, hend;\n\n\tif (unlikely(khugepaged_test_exit(mm)))\n\t\treturn SCAN_ANY_PROCESS;\n\n\t*vmap = vma = find_vma(mm, address);\n\tif (!vma)\n\t\treturn SCAN_VMA_NULL;\n\n\thstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;\n\thend = vma->vm_end & HPAGE_PMD_MASK;\n\tif (address < hstart || address + HPAGE_PMD_SIZE > hend)\n\t\treturn SCAN_ADDRESS_RANGE;\n\tif (!hugepage_vma_check(vma, vma->vm_flags))\n\t\treturn SCAN_VMA_CHECK;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic int hugepage_vma_revalidate(struct mm_struct *mm, unsigned long address,\n\t\tstruct vm_area_struct **vmap)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned long hstart, hend;\n\n\tif (unlikely(khugepaged_test_exit(mm)))\n\t\treturn SCAN_ANY_PROCESS;\n\n\t*vmap = vma = find_vma(mm, address);\n\tif (!vma)\n\t\treturn SCAN_VMA_NULL;\n\n\thstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;\n\thend = vma->vm_end & HPAGE_PMD_MASK;\n\tif (address < hstart || address + HPAGE_PMD_SIZE > hend)\n\t\treturn SCAN_ADDRESS_RANGE;\n\tif (!hugepage_vma_check(vma, vma->vm_flags))\n\t\treturn SCAN_VMA_CHECK;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_swap_page",
          "args": [
            "&vmf"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "do_swap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "2656-2869",
          "snippet": "vm_fault_t do_swap_page(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct page *page = NULL, *swapcache;\n\tstruct mem_cgroup *memcg;\n\tswp_entry_t entry;\n\tpte_t pte;\n\tint locked;\n\tint exclusive = 0;\n\tvm_fault_t ret = 0;\n\n\tif (!pte_unmap_same(vma->vm_mm, vmf->pmd, vmf->pte, vmf->orig_pte))\n\t\tgoto out;\n\n\tentry = pte_to_swp_entry(vmf->orig_pte);\n\tif (unlikely(non_swap_entry(entry))) {\n\t\tif (is_migration_entry(entry)) {\n\t\t\tmigration_entry_wait(vma->vm_mm, vmf->pmd,\n\t\t\t\t\t     vmf->address);\n\t\t} else if (is_device_private_entry(entry)) {\n\t\t\t/*\n\t\t\t * For un-addressable device memory we call the pgmap\n\t\t\t * fault handler callback. The callback must migrate\n\t\t\t * the page back to some CPU accessible page.\n\t\t\t */\n\t\t\tret = device_private_entry_fault(vma, vmf->address, entry,\n\t\t\t\t\t\t vmf->flags, vmf->pmd);\n\t\t} else if (is_hwpoison_entry(entry)) {\n\t\t\tret = VM_FAULT_HWPOISON;\n\t\t} else {\n\t\t\tprint_bad_pte(vma, vmf->address, vmf->orig_pte, NULL);\n\t\t\tret = VM_FAULT_SIGBUS;\n\t\t}\n\t\tgoto out;\n\t}\n\n\n\tdelayacct_set_flag(DELAYACCT_PF_SWAPIN);\n\tpage = lookup_swap_cache(entry, vma, vmf->address);\n\tswapcache = page;\n\n\tif (!page) {\n\t\tstruct swap_info_struct *si = swp_swap_info(entry);\n\n\t\tif (si->flags & SWP_SYNCHRONOUS_IO &&\n\t\t\t\t__swap_count(si, entry) == 1) {\n\t\t\t/* skip swapcache */\n\t\t\tpage = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma,\n\t\t\t\t\t\t\tvmf->address);\n\t\t\tif (page) {\n\t\t\t\t__SetPageLocked(page);\n\t\t\t\t__SetPageSwapBacked(page);\n\t\t\t\tset_page_private(page, entry.val);\n\t\t\t\tlru_cache_add_anon(page);\n\t\t\t\tswap_readpage(page, true);\n\t\t\t}\n\t\t} else {\n\t\t\tpage = swapin_readahead(entry, GFP_HIGHUSER_MOVABLE,\n\t\t\t\t\t\tvmf);\n\t\t\tswapcache = page;\n\t\t}\n\n\t\tif (!page) {\n\t\t\t/*\n\t\t\t * Back out if somebody else faulted in this pte\n\t\t\t * while we released the pte lock.\n\t\t\t */\n\t\t\tvmf->pte = pte_offset_map_lock(vma->vm_mm, vmf->pmd,\n\t\t\t\t\tvmf->address, &vmf->ptl);\n\t\t\tif (likely(pte_same(*vmf->pte, vmf->orig_pte)))\n\t\t\t\tret = VM_FAULT_OOM;\n\t\t\tdelayacct_clear_flag(DELAYACCT_PF_SWAPIN);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\t/* Had to read the page from swap area: Major fault */\n\t\tret = VM_FAULT_MAJOR;\n\t\tcount_vm_event(PGMAJFAULT);\n\t\tcount_memcg_event_mm(vma->vm_mm, PGMAJFAULT);\n\t} else if (PageHWPoison(page)) {\n\t\t/*\n\t\t * hwpoisoned dirty swapcache pages are kept for killing\n\t\t * owner processes (which may be unknown at hwpoison time)\n\t\t */\n\t\tret = VM_FAULT_HWPOISON;\n\t\tdelayacct_clear_flag(DELAYACCT_PF_SWAPIN);\n\t\tgoto out_release;\n\t}\n\n\tlocked = lock_page_or_retry(page, vma->vm_mm, vmf->flags);\n\n\tdelayacct_clear_flag(DELAYACCT_PF_SWAPIN);\n\tif (!locked) {\n\t\tret |= VM_FAULT_RETRY;\n\t\tgoto out_release;\n\t}\n\n\t/*\n\t * Make sure try_to_free_swap or reuse_swap_page or swapoff did not\n\t * release the swapcache from under us.  The page pin, and pte_same\n\t * test below, are not enough to exclude that.  Even if it is still\n\t * swapcache, we need to check that the page's swap has not changed.\n\t */\n\tif (unlikely((!PageSwapCache(page) ||\n\t\t\tpage_private(page) != entry.val)) && swapcache)\n\t\tgoto out_page;\n\n\tpage = ksm_might_need_to_copy(page, vma, vmf->address);\n\tif (unlikely(!page)) {\n\t\tret = VM_FAULT_OOM;\n\t\tpage = swapcache;\n\t\tgoto out_page;\n\t}\n\n\tif (mem_cgroup_try_charge_delay(page, vma->vm_mm, GFP_KERNEL,\n\t\t\t\t\t&memcg, false)) {\n\t\tret = VM_FAULT_OOM;\n\t\tgoto out_page;\n\t}\n\n\t/*\n\t * Back out if somebody else already faulted in this pte.\n\t */\n\tvmf->pte = pte_offset_map_lock(vma->vm_mm, vmf->pmd, vmf->address,\n\t\t\t&vmf->ptl);\n\tif (unlikely(!pte_same(*vmf->pte, vmf->orig_pte)))\n\t\tgoto out_nomap;\n\n\tif (unlikely(!PageUptodate(page))) {\n\t\tret = VM_FAULT_SIGBUS;\n\t\tgoto out_nomap;\n\t}\n\n\t/*\n\t * The page isn't present yet, go ahead with the fault.\n\t *\n\t * Be careful about the sequence of operations here.\n\t * To get its accounting right, reuse_swap_page() must be called\n\t * while the page is counted on swap but not yet in mapcount i.e.\n\t * before page_add_anon_rmap() and swap_free(); try_to_free_swap()\n\t * must be called after the swap_free(), or it will never succeed.\n\t */\n\n\tinc_mm_counter_fast(vma->vm_mm, MM_ANONPAGES);\n\tdec_mm_counter_fast(vma->vm_mm, MM_SWAPENTS);\n\tpte = mk_pte(page, vma->vm_page_prot);\n\tif ((vmf->flags & FAULT_FLAG_WRITE) && reuse_swap_page(page, NULL)) {\n\t\tpte = maybe_mkwrite(pte_mkdirty(pte), vma);\n\t\tvmf->flags &= ~FAULT_FLAG_WRITE;\n\t\tret |= VM_FAULT_WRITE;\n\t\texclusive = RMAP_EXCLUSIVE;\n\t}\n\tflush_icache_page(vma, page);\n\tif (pte_swp_soft_dirty(vmf->orig_pte))\n\t\tpte = pte_mksoft_dirty(pte);\n\tset_pte_at(vma->vm_mm, vmf->address, vmf->pte, pte);\n\tarch_do_swap_page(vma->vm_mm, vma, vmf->address, pte, vmf->orig_pte);\n\tvmf->orig_pte = pte;\n\n\t/* ksm created a completely new copy */\n\tif (unlikely(page != swapcache && swapcache)) {\n\t\tpage_add_new_anon_rmap(page, vma, vmf->address, false);\n\t\tmem_cgroup_commit_charge(page, memcg, false, false);\n\t\tlru_cache_add_active_or_unevictable(page, vma);\n\t} else {\n\t\tdo_page_add_anon_rmap(page, vma, vmf->address, exclusive);\n\t\tmem_cgroup_commit_charge(page, memcg, true, false);\n\t\tactivate_page(page);\n\t}\n\n\tswap_free(entry);\n\tif (mem_cgroup_swap_full(page) ||\n\t    (vma->vm_flags & VM_LOCKED) || PageMlocked(page))\n\t\ttry_to_free_swap(page);\n\tunlock_page(page);\n\tif (page != swapcache && swapcache) {\n\t\t/*\n\t\t * Hold the lock to avoid the swap entry to be reused\n\t\t * until we take the PT lock for the pte_same() check\n\t\t * (to avoid false positives from pte_same). For\n\t\t * further safety release the lock after the swap_free\n\t\t * so that the swap count won't change under a\n\t\t * parallel locked swapcache.\n\t\t */\n\t\tunlock_page(swapcache);\n\t\tput_page(swapcache);\n\t}\n\n\tif (vmf->flags & FAULT_FLAG_WRITE) {\n\t\tret |= do_wp_page(vmf);\n\t\tif (ret & VM_FAULT_ERROR)\n\t\t\tret &= VM_FAULT_ERROR;\n\t\tgoto out;\n\t}\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(vma, vmf->address, vmf->pte);\nunlock:\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\nout:\n\treturn ret;\nout_nomap:\n\tmem_cgroup_cancel_charge(page, memcg, false);\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\nout_page:\n\tunlock_page(page);\nout_release:\n\tput_page(page);\n\tif (page != swapcache && swapcache) {\n\t\tunlock_page(swapcache);\n\t\tput_page(swapcache);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvm_fault_t do_swap_page(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct page *page = NULL, *swapcache;\n\tstruct mem_cgroup *memcg;\n\tswp_entry_t entry;\n\tpte_t pte;\n\tint locked;\n\tint exclusive = 0;\n\tvm_fault_t ret = 0;\n\n\tif (!pte_unmap_same(vma->vm_mm, vmf->pmd, vmf->pte, vmf->orig_pte))\n\t\tgoto out;\n\n\tentry = pte_to_swp_entry(vmf->orig_pte);\n\tif (unlikely(non_swap_entry(entry))) {\n\t\tif (is_migration_entry(entry)) {\n\t\t\tmigration_entry_wait(vma->vm_mm, vmf->pmd,\n\t\t\t\t\t     vmf->address);\n\t\t} else if (is_device_private_entry(entry)) {\n\t\t\t/*\n\t\t\t * For un-addressable device memory we call the pgmap\n\t\t\t * fault handler callback. The callback must migrate\n\t\t\t * the page back to some CPU accessible page.\n\t\t\t */\n\t\t\tret = device_private_entry_fault(vma, vmf->address, entry,\n\t\t\t\t\t\t vmf->flags, vmf->pmd);\n\t\t} else if (is_hwpoison_entry(entry)) {\n\t\t\tret = VM_FAULT_HWPOISON;\n\t\t} else {\n\t\t\tprint_bad_pte(vma, vmf->address, vmf->orig_pte, NULL);\n\t\t\tret = VM_FAULT_SIGBUS;\n\t\t}\n\t\tgoto out;\n\t}\n\n\n\tdelayacct_set_flag(DELAYACCT_PF_SWAPIN);\n\tpage = lookup_swap_cache(entry, vma, vmf->address);\n\tswapcache = page;\n\n\tif (!page) {\n\t\tstruct swap_info_struct *si = swp_swap_info(entry);\n\n\t\tif (si->flags & SWP_SYNCHRONOUS_IO &&\n\t\t\t\t__swap_count(si, entry) == 1) {\n\t\t\t/* skip swapcache */\n\t\t\tpage = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma,\n\t\t\t\t\t\t\tvmf->address);\n\t\t\tif (page) {\n\t\t\t\t__SetPageLocked(page);\n\t\t\t\t__SetPageSwapBacked(page);\n\t\t\t\tset_page_private(page, entry.val);\n\t\t\t\tlru_cache_add_anon(page);\n\t\t\t\tswap_readpage(page, true);\n\t\t\t}\n\t\t} else {\n\t\t\tpage = swapin_readahead(entry, GFP_HIGHUSER_MOVABLE,\n\t\t\t\t\t\tvmf);\n\t\t\tswapcache = page;\n\t\t}\n\n\t\tif (!page) {\n\t\t\t/*\n\t\t\t * Back out if somebody else faulted in this pte\n\t\t\t * while we released the pte lock.\n\t\t\t */\n\t\t\tvmf->pte = pte_offset_map_lock(vma->vm_mm, vmf->pmd,\n\t\t\t\t\tvmf->address, &vmf->ptl);\n\t\t\tif (likely(pte_same(*vmf->pte, vmf->orig_pte)))\n\t\t\t\tret = VM_FAULT_OOM;\n\t\t\tdelayacct_clear_flag(DELAYACCT_PF_SWAPIN);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\t/* Had to read the page from swap area: Major fault */\n\t\tret = VM_FAULT_MAJOR;\n\t\tcount_vm_event(PGMAJFAULT);\n\t\tcount_memcg_event_mm(vma->vm_mm, PGMAJFAULT);\n\t} else if (PageHWPoison(page)) {\n\t\t/*\n\t\t * hwpoisoned dirty swapcache pages are kept for killing\n\t\t * owner processes (which may be unknown at hwpoison time)\n\t\t */\n\t\tret = VM_FAULT_HWPOISON;\n\t\tdelayacct_clear_flag(DELAYACCT_PF_SWAPIN);\n\t\tgoto out_release;\n\t}\n\n\tlocked = lock_page_or_retry(page, vma->vm_mm, vmf->flags);\n\n\tdelayacct_clear_flag(DELAYACCT_PF_SWAPIN);\n\tif (!locked) {\n\t\tret |= VM_FAULT_RETRY;\n\t\tgoto out_release;\n\t}\n\n\t/*\n\t * Make sure try_to_free_swap or reuse_swap_page or swapoff did not\n\t * release the swapcache from under us.  The page pin, and pte_same\n\t * test below, are not enough to exclude that.  Even if it is still\n\t * swapcache, we need to check that the page's swap has not changed.\n\t */\n\tif (unlikely((!PageSwapCache(page) ||\n\t\t\tpage_private(page) != entry.val)) && swapcache)\n\t\tgoto out_page;\n\n\tpage = ksm_might_need_to_copy(page, vma, vmf->address);\n\tif (unlikely(!page)) {\n\t\tret = VM_FAULT_OOM;\n\t\tpage = swapcache;\n\t\tgoto out_page;\n\t}\n\n\tif (mem_cgroup_try_charge_delay(page, vma->vm_mm, GFP_KERNEL,\n\t\t\t\t\t&memcg, false)) {\n\t\tret = VM_FAULT_OOM;\n\t\tgoto out_page;\n\t}\n\n\t/*\n\t * Back out if somebody else already faulted in this pte.\n\t */\n\tvmf->pte = pte_offset_map_lock(vma->vm_mm, vmf->pmd, vmf->address,\n\t\t\t&vmf->ptl);\n\tif (unlikely(!pte_same(*vmf->pte, vmf->orig_pte)))\n\t\tgoto out_nomap;\n\n\tif (unlikely(!PageUptodate(page))) {\n\t\tret = VM_FAULT_SIGBUS;\n\t\tgoto out_nomap;\n\t}\n\n\t/*\n\t * The page isn't present yet, go ahead with the fault.\n\t *\n\t * Be careful about the sequence of operations here.\n\t * To get its accounting right, reuse_swap_page() must be called\n\t * while the page is counted on swap but not yet in mapcount i.e.\n\t * before page_add_anon_rmap() and swap_free(); try_to_free_swap()\n\t * must be called after the swap_free(), or it will never succeed.\n\t */\n\n\tinc_mm_counter_fast(vma->vm_mm, MM_ANONPAGES);\n\tdec_mm_counter_fast(vma->vm_mm, MM_SWAPENTS);\n\tpte = mk_pte(page, vma->vm_page_prot);\n\tif ((vmf->flags & FAULT_FLAG_WRITE) && reuse_swap_page(page, NULL)) {\n\t\tpte = maybe_mkwrite(pte_mkdirty(pte), vma);\n\t\tvmf->flags &= ~FAULT_FLAG_WRITE;\n\t\tret |= VM_FAULT_WRITE;\n\t\texclusive = RMAP_EXCLUSIVE;\n\t}\n\tflush_icache_page(vma, page);\n\tif (pte_swp_soft_dirty(vmf->orig_pte))\n\t\tpte = pte_mksoft_dirty(pte);\n\tset_pte_at(vma->vm_mm, vmf->address, vmf->pte, pte);\n\tarch_do_swap_page(vma->vm_mm, vma, vmf->address, pte, vmf->orig_pte);\n\tvmf->orig_pte = pte;\n\n\t/* ksm created a completely new copy */\n\tif (unlikely(page != swapcache && swapcache)) {\n\t\tpage_add_new_anon_rmap(page, vma, vmf->address, false);\n\t\tmem_cgroup_commit_charge(page, memcg, false, false);\n\t\tlru_cache_add_active_or_unevictable(page, vma);\n\t} else {\n\t\tdo_page_add_anon_rmap(page, vma, vmf->address, exclusive);\n\t\tmem_cgroup_commit_charge(page, memcg, true, false);\n\t\tactivate_page(page);\n\t}\n\n\tswap_free(entry);\n\tif (mem_cgroup_swap_full(page) ||\n\t    (vma->vm_flags & VM_LOCKED) || PageMlocked(page))\n\t\ttry_to_free_swap(page);\n\tunlock_page(page);\n\tif (page != swapcache && swapcache) {\n\t\t/*\n\t\t * Hold the lock to avoid the swap entry to be reused\n\t\t * until we take the PT lock for the pte_same() check\n\t\t * (to avoid false positives from pte_same). For\n\t\t * further safety release the lock after the swap_free\n\t\t * so that the swap count won't change under a\n\t\t * parallel locked swapcache.\n\t\t */\n\t\tunlock_page(swapcache);\n\t\tput_page(swapcache);\n\t}\n\n\tif (vmf->flags & FAULT_FLAG_WRITE) {\n\t\tret |= do_wp_page(vmf);\n\t\tif (ret & VM_FAULT_ERROR)\n\t\t\tret &= VM_FAULT_ERROR;\n\t\tgoto out;\n\t}\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(vma, vmf->address, vmf->pte);\nunlock:\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\nout:\n\treturn ret;\nout_nomap:\n\tmem_cgroup_cancel_charge(page, memcg, false);\n\tpte_unmap_unlock(vmf->pte, vmf->ptl);\nout_page:\n\tunlock_page(page);\nout_release:\n\tput_page(page);\n\tif (page != swapcache && swapcache) {\n\t\tunlock_page(swapcache);\n\t\tput_page(swapcache);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_swap_pte",
          "args": [
            "vmf.orig_pte"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_offset_map",
          "args": [
            "pmd",
            "address"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_mm_collapse_huge_page_swapin",
          "args": [
            "mm",
            "swapped_in",
            "referenced",
            "0"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "linear_page_index",
          "args": [
            "vma",
            "address"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic bool __collapse_huge_page_swapin(struct mm_struct *mm,\n\t\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\t\tunsigned long address, pmd_t *pmd,\n\t\t\t\t\tint referenced)\n{\n\tint swapped_in = 0;\n\tvm_fault_t ret = 0;\n\tstruct vm_fault vmf = {\n\t\t.vma = vma,\n\t\t.address = address,\n\t\t.flags = FAULT_FLAG_ALLOW_RETRY,\n\t\t.pmd = pmd,\n\t\t.pgoff = linear_page_index(vma, address),\n\t};\n\n\t/* we only decide to swapin, if there is enough young ptes */\n\tif (referenced < HPAGE_PMD_NR/2) {\n\t\ttrace_mm_collapse_huge_page_swapin(mm, swapped_in, referenced, 0);\n\t\treturn false;\n\t}\n\tvmf.pte = pte_offset_map(pmd, address);\n\tfor (; vmf.address < address + HPAGE_PMD_NR*PAGE_SIZE;\n\t\t\tvmf.pte++, vmf.address += PAGE_SIZE) {\n\t\tvmf.orig_pte = *vmf.pte;\n\t\tif (!is_swap_pte(vmf.orig_pte))\n\t\t\tcontinue;\n\t\tswapped_in++;\n\t\tret = do_swap_page(&vmf);\n\n\t\t/* do_swap_page returns VM_FAULT_RETRY with released mmap_sem */\n\t\tif (ret & VM_FAULT_RETRY) {\n\t\t\tdown_read(&mm->mmap_sem);\n\t\t\tif (hugepage_vma_revalidate(mm, address, &vmf.vma)) {\n\t\t\t\t/* vma is no longer available, don't continue to swapin */\n\t\t\t\ttrace_mm_collapse_huge_page_swapin(mm, swapped_in, referenced, 0);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t/* check if the pmd is still valid */\n\t\t\tif (mm_find_pmd(mm, address) != pmd) {\n\t\t\t\ttrace_mm_collapse_huge_page_swapin(mm, swapped_in, referenced, 0);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (ret & VM_FAULT_ERROR) {\n\t\t\ttrace_mm_collapse_huge_page_swapin(mm, swapped_in, referenced, 0);\n\t\t\treturn false;\n\t\t}\n\t\t/* pte is unmapped now, we need to map it */\n\t\tvmf.pte = pte_offset_map(pmd, vmf.address);\n\t}\n\tvmf.pte--;\n\tpte_unmap(vmf.pte);\n\ttrace_mm_collapse_huge_page_swapin(mm, swapped_in, referenced, 1);\n\treturn true;\n}"
  },
  {
    "function_name": "hugepage_vma_revalidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "848-868",
    "snippet": "static int hugepage_vma_revalidate(struct mm_struct *mm, unsigned long address,\n\t\tstruct vm_area_struct **vmap)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned long hstart, hend;\n\n\tif (unlikely(khugepaged_test_exit(mm)))\n\t\treturn SCAN_ANY_PROCESS;\n\n\t*vmap = vma = find_vma(mm, address);\n\tif (!vma)\n\t\treturn SCAN_VMA_NULL;\n\n\thstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;\n\thend = vma->vm_end & HPAGE_PMD_MASK;\n\tif (address < hstart || address + HPAGE_PMD_SIZE > hend)\n\t\treturn SCAN_ADDRESS_RANGE;\n\tif (!hugepage_vma_check(vma, vma->vm_flags))\n\t\treturn SCAN_VMA_CHECK;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hugepage_vma_check",
          "args": [
            "vma",
            "vma->vm_flags"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "hugepage_vma_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "400-418",
          "snippet": "static bool hugepage_vma_check(struct vm_area_struct *vma,\n\t\t\t       unsigned long vm_flags)\n{\n\tif ((!(vm_flags & VM_HUGEPAGE) && !khugepaged_always()) ||\n\t    (vm_flags & VM_NOHUGEPAGE) ||\n\t    test_bit(MMF_DISABLE_THP, &vma->vm_mm->flags))\n\t\treturn false;\n\tif (shmem_file(vma->vm_file)) {\n\t\tif (!IS_ENABLED(CONFIG_TRANSPARENT_HUGE_PAGECACHE))\n\t\t\treturn false;\n\t\treturn IS_ALIGNED((vma->vm_start >> PAGE_SHIFT) - vma->vm_pgoff,\n\t\t\t\tHPAGE_PMD_NR);\n\t}\n\tif (!vma->anon_vma || vma->vm_ops)\n\t\treturn false;\n\tif (is_vma_temporary_stack(vma))\n\t\treturn false;\n\treturn !(vm_flags & VM_NO_KHUGEPAGED);\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define VM_NO_KHUGEPAGED (VM_SPECIAL | VM_HUGETLB)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\n#define VM_NO_KHUGEPAGED (VM_SPECIAL | VM_HUGETLB)\n\nstatic bool hugepage_vma_check(struct vm_area_struct *vma,\n\t\t\t       unsigned long vm_flags)\n{\n\tif ((!(vm_flags & VM_HUGEPAGE) && !khugepaged_always()) ||\n\t    (vm_flags & VM_NOHUGEPAGE) ||\n\t    test_bit(MMF_DISABLE_THP, &vma->vm_mm->flags))\n\t\treturn false;\n\tif (shmem_file(vma->vm_file)) {\n\t\tif (!IS_ENABLED(CONFIG_TRANSPARENT_HUGE_PAGECACHE))\n\t\t\treturn false;\n\t\treturn IS_ALIGNED((vma->vm_start >> PAGE_SHIFT) - vma->vm_pgoff,\n\t\t\t\tHPAGE_PMD_NR);\n\t}\n\tif (!vma->anon_vma || vma->vm_ops)\n\t\treturn false;\n\tif (is_vma_temporary_stack(vma))\n\t\treturn false;\n\treturn !(vm_flags & VM_NO_KHUGEPAGED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_vma",
          "args": [
            "mm",
            "address"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "find_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "775-796",
          "snippet": "struct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\n\t/* check the cache first */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\t/* trawl the list (there may be multiple mappings in which addr\n\t * resides) */\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_start > addr)\n\t\t\treturn NULL;\n\t\tif (vma->vm_end > addr) {\n\t\t\tvmacache_update(addr, vma);\n\t\t\treturn vma;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nstruct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma;\n\n\t/* check the cache first */\n\tvma = vmacache_find(mm, addr);\n\tif (likely(vma))\n\t\treturn vma;\n\n\t/* trawl the list (there may be multiple mappings in which addr\n\t * resides) */\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_start > addr)\n\t\t\treturn NULL;\n\t\tif (vma->vm_end > addr) {\n\t\t\tvmacache_update(addr, vma);\n\t\t\treturn vma;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "khugepaged_test_exit(mm)"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "khugepaged_test_exit",
          "args": [
            "mm"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "khugepaged_test_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "395-398",
          "snippet": "static inline int khugepaged_test_exit(struct mm_struct *mm)\n{\n\treturn atomic_read(&mm->mm_users) == 0;\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic inline int khugepaged_test_exit(struct mm_struct *mm)\n{\n\treturn atomic_read(&mm->mm_users) == 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic int hugepage_vma_revalidate(struct mm_struct *mm, unsigned long address,\n\t\tstruct vm_area_struct **vmap)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned long hstart, hend;\n\n\tif (unlikely(khugepaged_test_exit(mm)))\n\t\treturn SCAN_ANY_PROCESS;\n\n\t*vmap = vma = find_vma(mm, address);\n\tif (!vma)\n\t\treturn SCAN_VMA_NULL;\n\n\thstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;\n\thend = vma->vm_end & HPAGE_PMD_MASK;\n\tif (address < hstart || address + HPAGE_PMD_SIZE > hend)\n\t\treturn SCAN_ADDRESS_RANGE;\n\tif (!hugepage_vma_check(vma, vma->vm_flags))\n\t\treturn SCAN_VMA_CHECK;\n\treturn 0;\n}"
  },
  {
    "function_name": "khugepaged_alloc_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "832-838",
    "snippet": "static struct page *\nkhugepaged_alloc_page(struct page **hpage, gfp_t gfp, int node)\n{\n\tVM_BUG_ON(!*hpage);\n\n\treturn  *hpage;\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!*hpage"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic struct page *\nkhugepaged_alloc_page(struct page **hpage, gfp_t gfp, int node)\n{\n\tVM_BUG_ON(!*hpage);\n\n\treturn  *hpage;\n}"
  },
  {
    "function_name": "khugepaged_prealloc_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "821-830",
    "snippet": "static bool khugepaged_prealloc_page(struct page **hpage, bool *wait)\n{\n\tif (!*hpage)\n\t\t*hpage = khugepaged_alloc_hugepage(wait);\n\n\tif (unlikely(!*hpage))\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!*hpage"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "khugepaged_alloc_hugepage",
          "args": [
            "wait"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "khugepaged_alloc_hugepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "801-819",
          "snippet": "static struct page *khugepaged_alloc_hugepage(bool *wait)\n{\n\tstruct page *hpage;\n\n\tdo {\n\t\thpage = alloc_khugepaged_hugepage();\n\t\tif (!hpage) {\n\t\t\tcount_vm_event(THP_COLLAPSE_ALLOC_FAILED);\n\t\t\tif (!*wait)\n\t\t\t\treturn NULL;\n\n\t\t\t*wait = false;\n\t\t\tkhugepaged_alloc_sleep();\n\t\t} else\n\t\t\tcount_vm_event(THP_COLLAPSE_ALLOC);\n\t} while (unlikely(!hpage) && likely(khugepaged_enabled()));\n\n\treturn hpage;\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic struct page *khugepaged_alloc_hugepage(bool *wait)\n{\n\tstruct page *hpage;\n\n\tdo {\n\t\thpage = alloc_khugepaged_hugepage();\n\t\tif (!hpage) {\n\t\t\tcount_vm_event(THP_COLLAPSE_ALLOC_FAILED);\n\t\t\tif (!*wait)\n\t\t\t\treturn NULL;\n\n\t\t\t*wait = false;\n\t\t\tkhugepaged_alloc_sleep();\n\t\t} else\n\t\t\tcount_vm_event(THP_COLLAPSE_ALLOC);\n\t} while (unlikely(!hpage) && likely(khugepaged_enabled()));\n\n\treturn hpage;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic bool khugepaged_prealloc_page(struct page **hpage, bool *wait)\n{\n\tif (!*hpage)\n\t\t*hpage = khugepaged_alloc_hugepage(wait);\n\n\tif (unlikely(!*hpage))\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "khugepaged_alloc_hugepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "801-819",
    "snippet": "static struct page *khugepaged_alloc_hugepage(bool *wait)\n{\n\tstruct page *hpage;\n\n\tdo {\n\t\thpage = alloc_khugepaged_hugepage();\n\t\tif (!hpage) {\n\t\t\tcount_vm_event(THP_COLLAPSE_ALLOC_FAILED);\n\t\t\tif (!*wait)\n\t\t\t\treturn NULL;\n\n\t\t\t*wait = false;\n\t\t\tkhugepaged_alloc_sleep();\n\t\t} else\n\t\t\tcount_vm_event(THP_COLLAPSE_ALLOC);\n\t} while (unlikely(!hpage) && likely(khugepaged_enabled()));\n\n\treturn hpage;\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "khugepaged_enabled()"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "khugepaged_enabled",
          "args": [],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!hpage"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "THP_COLLAPSE_ALLOC"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "khugepaged_alloc_sleep",
          "args": [],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "khugepaged_alloc_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "683-691",
          "snippet": "static void khugepaged_alloc_sleep(void)\n{\n\tDEFINE_WAIT(wait);\n\n\tadd_wait_queue(&khugepaged_wait, &wait);\n\tfreezable_schedule_timeout_interruptible(\n\t\tmsecs_to_jiffies(khugepaged_alloc_sleep_millisecs));\n\tremove_wait_queue(&khugepaged_wait, &wait);\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int khugepaged_alloc_sleep_millisecs",
            "static DECLARE_WAIT_QUEUE_HEAD(khugepaged_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic unsigned int khugepaged_alloc_sleep_millisecs;\nstatic DECLARE_WAIT_QUEUE_HEAD(khugepaged_wait);\n\nstatic void khugepaged_alloc_sleep(void)\n{\n\tDEFINE_WAIT(wait);\n\n\tadd_wait_queue(&khugepaged_wait, &wait);\n\tfreezable_schedule_timeout_interruptible(\n\t\tmsecs_to_jiffies(khugepaged_alloc_sleep_millisecs));\n\tremove_wait_queue(&khugepaged_wait, &wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "THP_COLLAPSE_ALLOC_FAILED"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_khugepaged_hugepage",
          "args": [],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_khugepaged_hugepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "790-799",
          "snippet": "static inline struct page *alloc_khugepaged_hugepage(void)\n{\n\tstruct page *page;\n\n\tpage = alloc_pages(alloc_hugepage_khugepaged_gfpmask(),\n\t\t\t   HPAGE_PMD_ORDER);\n\tif (page)\n\t\tprep_transhuge_page(page);\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic inline struct page *alloc_khugepaged_hugepage(void)\n{\n\tstruct page *page;\n\n\tpage = alloc_pages(alloc_hugepage_khugepaged_gfpmask(),\n\t\t\t   HPAGE_PMD_ORDER);\n\tif (page)\n\t\tprep_transhuge_page(page);\n\treturn page;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic struct page *khugepaged_alloc_hugepage(bool *wait)\n{\n\tstruct page *hpage;\n\n\tdo {\n\t\thpage = alloc_khugepaged_hugepage();\n\t\tif (!hpage) {\n\t\t\tcount_vm_event(THP_COLLAPSE_ALLOC_FAILED);\n\t\t\tif (!*wait)\n\t\t\t\treturn NULL;\n\n\t\t\t*wait = false;\n\t\t\tkhugepaged_alloc_sleep();\n\t\t} else\n\t\t\tcount_vm_event(THP_COLLAPSE_ALLOC);\n\t} while (unlikely(!hpage) && likely(khugepaged_enabled()));\n\n\treturn hpage;\n}"
  },
  {
    "function_name": "alloc_khugepaged_hugepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "790-799",
    "snippet": "static inline struct page *alloc_khugepaged_hugepage(void)\n{\n\tstruct page *page;\n\n\tpage = alloc_pages(alloc_hugepage_khugepaged_gfpmask(),\n\t\t\t   HPAGE_PMD_ORDER);\n\tif (page)\n\t\tprep_transhuge_page(page);\n\treturn page;\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "prep_transhuge_page",
          "args": [
            "page"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "prep_transhuge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "490-499",
          "snippet": "void prep_transhuge_page(struct page *page)\n{\n\t/*\n\t * we use page->mapping and page->indexlru in second tail page\n\t * as list_head: assuming THP order >= 2\n\t */\n\n\tINIT_LIST_HEAD(page_deferred_list(page));\n\tset_compound_page_dtor(page, TRANSHUGE_PAGE_DTOR);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid prep_transhuge_page(struct page *page)\n{\n\t/*\n\t * we use page->mapping and page->indexlru in second tail page\n\t * as list_head: assuming THP order >= 2\n\t */\n\n\tINIT_LIST_HEAD(page_deferred_list(page));\n\tset_compound_page_dtor(page, TRANSHUGE_PAGE_DTOR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_pages",
          "args": [
            "alloc_hugepage_khugepaged_gfpmask()",
            "HPAGE_PMD_ORDER"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_pages_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4594-4601",
          "snippet": "void *alloc_pages_exact(size_t size, gfp_t gfp_mask)\n{\n\tunsigned int order = get_order(size);\n\tunsigned long addr;\n\n\taddr = __get_free_pages(gfp_mask, order);\n\treturn make_alloc_exact(addr, order, size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\n\nvoid *alloc_pages_exact(size_t size, gfp_t gfp_mask)\n{\n\tunsigned int order = get_order(size);\n\tunsigned long addr;\n\n\taddr = __get_free_pages(gfp_mask, order);\n\treturn make_alloc_exact(addr, order, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_hugepage_khugepaged_gfpmask",
          "args": [],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_hugepage_khugepaged_gfpmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "720-723",
          "snippet": "static inline gfp_t alloc_hugepage_khugepaged_gfpmask(void)\n{\n\treturn khugepaged_defrag() ? GFP_TRANSHUGE : GFP_TRANSHUGE_LIGHT;\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic inline gfp_t alloc_hugepage_khugepaged_gfpmask(void)\n{\n\treturn khugepaged_defrag() ? GFP_TRANSHUGE : GFP_TRANSHUGE_LIGHT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic inline struct page *alloc_khugepaged_hugepage(void)\n{\n\tstruct page *page;\n\n\tpage = alloc_pages(alloc_hugepage_khugepaged_gfpmask(),\n\t\t\t   HPAGE_PMD_ORDER);\n\tif (page)\n\t\tprep_transhuge_page(page);\n\treturn page;\n}"
  },
  {
    "function_name": "khugepaged_find_target_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "785-788",
    "snippet": "static int khugepaged_find_target_node(void)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic int khugepaged_find_target_node(void)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "khugepaged_alloc_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "768-783",
    "snippet": "static struct page *\nkhugepaged_alloc_page(struct page **hpage, gfp_t gfp, int node)\n{\n\tVM_BUG_ON_PAGE(*hpage, *hpage);\n\n\t*hpage = __alloc_pages_node(node, gfp, HPAGE_PMD_ORDER);\n\tif (unlikely(!*hpage)) {\n\t\tcount_vm_event(THP_COLLAPSE_ALLOC_FAILED);\n\t\t*hpage = ERR_PTR(-ENOMEM);\n\t\treturn NULL;\n\t}\n\n\tprep_transhuge_page(*hpage);\n\tcount_vm_event(THP_COLLAPSE_ALLOC);\n\treturn *hpage;\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "THP_COLLAPSE_ALLOC"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prep_transhuge_page",
          "args": [
            "*hpage"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "prep_transhuge_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "490-499",
          "snippet": "void prep_transhuge_page(struct page *page)\n{\n\t/*\n\t * we use page->mapping and page->indexlru in second tail page\n\t * as list_head: assuming THP order >= 2\n\t */\n\n\tINIT_LIST_HEAD(page_deferred_list(page));\n\tset_compound_page_dtor(page, TRANSHUGE_PAGE_DTOR);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nvoid prep_transhuge_page(struct page *page)\n{\n\t/*\n\t * we use page->mapping and page->indexlru in second tail page\n\t * as list_head: assuming THP order >= 2\n\t */\n\n\tINIT_LIST_HEAD(page_deferred_list(page));\n\tset_compound_page_dtor(page, TRANSHUGE_PAGE_DTOR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "THP_COLLAPSE_ALLOC_FAILED"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!*hpage"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__alloc_pages_node",
          "args": [
            "node",
            "gfp",
            "HPAGE_PMD_ORDER"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "*hpage",
            "*hpage"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic struct page *\nkhugepaged_alloc_page(struct page **hpage, gfp_t gfp, int node)\n{\n\tVM_BUG_ON_PAGE(*hpage, *hpage);\n\n\t*hpage = __alloc_pages_node(node, gfp, HPAGE_PMD_ORDER);\n\tif (unlikely(!*hpage)) {\n\t\tcount_vm_event(THP_COLLAPSE_ALLOC_FAILED);\n\t\t*hpage = ERR_PTR(-ENOMEM);\n\t\treturn NULL;\n\t}\n\n\tprep_transhuge_page(*hpage);\n\tcount_vm_event(THP_COLLAPSE_ALLOC);\n\treturn *hpage;\n}"
  },
  {
    "function_name": "khugepaged_prealloc_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "751-766",
    "snippet": "static bool khugepaged_prealloc_page(struct page **hpage, bool *wait)\n{\n\tif (IS_ERR(*hpage)) {\n\t\tif (!*wait)\n\t\t\treturn false;\n\n\t\t*wait = false;\n\t\t*hpage = NULL;\n\t\tkhugepaged_alloc_sleep();\n\t} else if (*hpage) {\n\t\tput_page(*hpage);\n\t\t*hpage = NULL;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "*hpage"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "put_page_bootmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "143-158",
          "snippet": "void put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void generic_online_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void generic_online_page(struct page *page);\n\nvoid put_page_bootmem(struct page *page)\n{\n\tunsigned long type;\n\n\ttype = (unsigned long) page->freelist;\n\tBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\n\t       type > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\n\n\tif (page_ref_dec_return(page) == 1) {\n\t\tpage->freelist = NULL;\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tINIT_LIST_HEAD(&page->lru);\n\t\tfree_reserved_page(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "khugepaged_alloc_sleep",
          "args": [],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "khugepaged_alloc_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "683-691",
          "snippet": "static void khugepaged_alloc_sleep(void)\n{\n\tDEFINE_WAIT(wait);\n\n\tadd_wait_queue(&khugepaged_wait, &wait);\n\tfreezable_schedule_timeout_interruptible(\n\t\tmsecs_to_jiffies(khugepaged_alloc_sleep_millisecs));\n\tremove_wait_queue(&khugepaged_wait, &wait);\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int khugepaged_alloc_sleep_millisecs",
            "static DECLARE_WAIT_QUEUE_HEAD(khugepaged_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic unsigned int khugepaged_alloc_sleep_millisecs;\nstatic DECLARE_WAIT_QUEUE_HEAD(khugepaged_wait);\n\nstatic void khugepaged_alloc_sleep(void)\n{\n\tDEFINE_WAIT(wait);\n\n\tadd_wait_queue(&khugepaged_wait, &wait);\n\tfreezable_schedule_timeout_interruptible(\n\t\tmsecs_to_jiffies(khugepaged_alloc_sleep_millisecs));\n\tremove_wait_queue(&khugepaged_wait, &wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "*hpage"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic bool khugepaged_prealloc_page(struct page **hpage, bool *wait)\n{\n\tif (IS_ERR(*hpage)) {\n\t\tif (!*wait)\n\t\t\treturn false;\n\n\t\t*wait = false;\n\t\t*hpage = NULL;\n\t\tkhugepaged_alloc_sleep();\n\t} else if (*hpage) {\n\t\tput_page(*hpage);\n\t\t*hpage = NULL;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "khugepaged_find_target_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "726-749",
    "snippet": "static int khugepaged_find_target_node(void)\n{\n\tstatic int last_khugepaged_target_node = NUMA_NO_NODE;\n\tint nid, target_node = 0, max_value = 0;\n\n\t/* find first node with max normal pages hit */\n\tfor (nid = 0; nid < MAX_NUMNODES; nid++)\n\t\tif (khugepaged_node_load[nid] > max_value) {\n\t\t\tmax_value = khugepaged_node_load[nid];\n\t\t\ttarget_node = nid;\n\t\t}\n\n\t/* do some balance if several nodes have the same hit record */\n\tif (target_node <= last_khugepaged_target_node)\n\t\tfor (nid = last_khugepaged_target_node + 1; nid < MAX_NUMNODES;\n\t\t\t\tnid++)\n\t\t\tif (max_value == khugepaged_node_load[nid]) {\n\t\t\t\ttarget_node = nid;\n\t\t\t\tbreak;\n\t\t\t}\n\n\tlast_khugepaged_target_node = target_node;\n\treturn target_node;\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int khugepaged_node_load[MAX_NUMNODES];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic int khugepaged_node_load[MAX_NUMNODES];\n\nstatic int khugepaged_find_target_node(void)\n{\n\tstatic int last_khugepaged_target_node = NUMA_NO_NODE;\n\tint nid, target_node = 0, max_value = 0;\n\n\t/* find first node with max normal pages hit */\n\tfor (nid = 0; nid < MAX_NUMNODES; nid++)\n\t\tif (khugepaged_node_load[nid] > max_value) {\n\t\t\tmax_value = khugepaged_node_load[nid];\n\t\t\ttarget_node = nid;\n\t\t}\n\n\t/* do some balance if several nodes have the same hit record */\n\tif (target_node <= last_khugepaged_target_node)\n\t\tfor (nid = last_khugepaged_target_node + 1; nid < MAX_NUMNODES;\n\t\t\t\tnid++)\n\t\t\tif (max_value == khugepaged_node_load[nid]) {\n\t\t\t\ttarget_node = nid;\n\t\t\t\tbreak;\n\t\t\t}\n\n\tlast_khugepaged_target_node = target_node;\n\treturn target_node;\n}"
  },
  {
    "function_name": "alloc_hugepage_khugepaged_gfpmask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "720-723",
    "snippet": "static inline gfp_t alloc_hugepage_khugepaged_gfpmask(void)\n{\n\treturn khugepaged_defrag() ? GFP_TRANSHUGE : GFP_TRANSHUGE_LIGHT;\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "khugepaged_defrag",
          "args": [],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic inline gfp_t alloc_hugepage_khugepaged_gfpmask(void)\n{\n\treturn khugepaged_defrag() ? GFP_TRANSHUGE : GFP_TRANSHUGE_LIGHT;\n}"
  },
  {
    "function_name": "khugepaged_scan_abort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "695-717",
    "snippet": "static bool khugepaged_scan_abort(int nid)\n{\n\tint i;\n\n\t/*\n\t * If node_reclaim_mode is disabled, then no extra effort is made to\n\t * allocate memory locally.\n\t */\n\tif (!node_reclaim_mode)\n\t\treturn false;\n\n\t/* If there is a count for this node already, it must be acceptable */\n\tif (khugepaged_node_load[nid])\n\t\treturn false;\n\n\tfor (i = 0; i < MAX_NUMNODES; i++) {\n\t\tif (!khugepaged_node_load[i])\n\t\t\tcontinue;\n\t\tif (node_distance(nid, i) > RECLAIM_DISTANCE)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int khugepaged_node_load[MAX_NUMNODES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "node_distance",
          "args": [
            "nid",
            "i"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic int khugepaged_node_load[MAX_NUMNODES];\n\nstatic bool khugepaged_scan_abort(int nid)\n{\n\tint i;\n\n\t/*\n\t * If node_reclaim_mode is disabled, then no extra effort is made to\n\t * allocate memory locally.\n\t */\n\tif (!node_reclaim_mode)\n\t\treturn false;\n\n\t/* If there is a count for this node already, it must be acceptable */\n\tif (khugepaged_node_load[nid])\n\t\treturn false;\n\n\tfor (i = 0; i < MAX_NUMNODES; i++) {\n\t\tif (!khugepaged_node_load[i])\n\t\t\tcontinue;\n\t\tif (node_distance(nid, i) > RECLAIM_DISTANCE)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "khugepaged_alloc_sleep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "683-691",
    "snippet": "static void khugepaged_alloc_sleep(void)\n{\n\tDEFINE_WAIT(wait);\n\n\tadd_wait_queue(&khugepaged_wait, &wait);\n\tfreezable_schedule_timeout_interruptible(\n\t\tmsecs_to_jiffies(khugepaged_alloc_sleep_millisecs));\n\tremove_wait_queue(&khugepaged_wait, &wait);\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int khugepaged_alloc_sleep_millisecs",
      "static DECLARE_WAIT_QUEUE_HEAD(khugepaged_wait);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_wait_queue",
          "args": [
            "&khugepaged_wait",
            "&wait"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freezable_schedule_timeout_interruptible",
          "args": [
            "msecs_to_jiffies(khugepaged_alloc_sleep_millisecs)"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "khugepaged_alloc_sleep_millisecs"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wait_queue",
          "args": [
            "&khugepaged_wait",
            "&wait"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT",
          "args": [
            "wait"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic unsigned int khugepaged_alloc_sleep_millisecs;\nstatic DECLARE_WAIT_QUEUE_HEAD(khugepaged_wait);\n\nstatic void khugepaged_alloc_sleep(void)\n{\n\tDEFINE_WAIT(wait);\n\n\tadd_wait_queue(&khugepaged_wait, &wait);\n\tfreezable_schedule_timeout_interruptible(\n\t\tmsecs_to_jiffies(khugepaged_alloc_sleep_millisecs));\n\tremove_wait_queue(&khugepaged_wait, &wait);\n}"
  },
  {
    "function_name": "__collapse_huge_page_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "634-681",
    "snippet": "static void __collapse_huge_page_copy(pte_t *pte, struct page *page,\n\t\t\t\t      struct vm_area_struct *vma,\n\t\t\t\t      unsigned long address,\n\t\t\t\t      spinlock_t *ptl)\n{\n\tpte_t *_pte;\n\tfor (_pte = pte; _pte < pte + HPAGE_PMD_NR;\n\t\t\t\t_pte++, page++, address += PAGE_SIZE) {\n\t\tpte_t pteval = *_pte;\n\t\tstruct page *src_page;\n\n\t\tif (pte_none(pteval) || is_zero_pfn(pte_pfn(pteval))) {\n\t\t\tclear_user_highpage(page, address);\n\t\t\tadd_mm_counter(vma->vm_mm, MM_ANONPAGES, 1);\n\t\t\tif (is_zero_pfn(pte_pfn(pteval))) {\n\t\t\t\t/*\n\t\t\t\t * ptl mostly unnecessary.\n\t\t\t\t */\n\t\t\t\tspin_lock(ptl);\n\t\t\t\t/*\n\t\t\t\t * paravirt calls inside pte_clear here are\n\t\t\t\t * superfluous.\n\t\t\t\t */\n\t\t\t\tpte_clear(vma->vm_mm, address, _pte);\n\t\t\t\tspin_unlock(ptl);\n\t\t\t}\n\t\t} else {\n\t\t\tsrc_page = pte_page(pteval);\n\t\t\tcopy_user_highpage(page, src_page, address, vma);\n\t\t\tVM_BUG_ON_PAGE(page_mapcount(src_page) != 1, src_page);\n\t\t\trelease_pte_page(src_page);\n\t\t\t/*\n\t\t\t * ptl mostly unnecessary, but preempt has to\n\t\t\t * be disabled to update the per-cpu stats\n\t\t\t * inside page_remove_rmap().\n\t\t\t */\n\t\t\tspin_lock(ptl);\n\t\t\t/*\n\t\t\t * paravirt calls inside pte_clear here are\n\t\t\t * superfluous.\n\t\t\t */\n\t\t\tpte_clear(vma->vm_mm, address, _pte);\n\t\t\tpage_remove_rmap(src_page, false);\n\t\t\tspin_unlock(ptl);\n\t\t\tfree_page_and_swap_cache(src_page);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_page_and_swap_cache",
          "args": [
            "src_page"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "free_page_and_swap_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "276-281",
          "snippet": "void free_page_and_swap_cache(struct page *page)\n{\n\tfree_swap_cache(page);\n\tif (!is_huge_zero_page(page))\n\t\tput_page(page);\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nvoid free_page_and_swap_cache(struct page *page)\n{\n\tfree_swap_cache(page);\n\tif (!is_huge_zero_page(page))\n\t\tput_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_remove_rmap",
          "args": [
            "src_page",
            "false"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "page_remove_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1297-1331",
          "snippet": "void page_remove_rmap(struct page *page, bool compound)\n{\n\tif (!PageAnon(page))\n\t\treturn page_remove_file_rmap(page, compound);\n\n\tif (compound)\n\t\treturn page_remove_anon_compound_rmap(page);\n\n\t/* page still mapped by someone else? */\n\tif (!atomic_add_negative(-1, &page->_mapcount))\n\t\treturn;\n\n\t/*\n\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t * these counters are not modified in interrupt context, and\n\t * pte lock(a spinlock) is held, which implies preemption disabled.\n\t */\n\t__dec_node_page_state(page, NR_ANON_MAPPED);\n\n\tif (unlikely(PageMlocked(page)))\n\t\tclear_page_mlock(page);\n\n\tif (PageTransCompound(page))\n\t\tdeferred_split_huge_page(compound_head(page));\n\n\t/*\n\t * It would be tidy to reset the PageAnon mapping here,\n\t * but that might overwrite a racing page_add_anon_rmap\n\t * which increments mapcount after us but sets mapping\n\t * before us: so leave the reset to free_unref_page,\n\t * and remember that it's only reliable while mapped.\n\t * Leaving it set also helps swapoff to reinstate ptes\n\t * faster for those pages still in swapcache.\n\t */\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid page_remove_rmap(struct page *page, bool compound)\n{\n\tif (!PageAnon(page))\n\t\treturn page_remove_file_rmap(page, compound);\n\n\tif (compound)\n\t\treturn page_remove_anon_compound_rmap(page);\n\n\t/* page still mapped by someone else? */\n\tif (!atomic_add_negative(-1, &page->_mapcount))\n\t\treturn;\n\n\t/*\n\t * We use the irq-unsafe __{inc|mod}_zone_page_stat because\n\t * these counters are not modified in interrupt context, and\n\t * pte lock(a spinlock) is held, which implies preemption disabled.\n\t */\n\t__dec_node_page_state(page, NR_ANON_MAPPED);\n\n\tif (unlikely(PageMlocked(page)))\n\t\tclear_page_mlock(page);\n\n\tif (PageTransCompound(page))\n\t\tdeferred_split_huge_page(compound_head(page));\n\n\t/*\n\t * It would be tidy to reset the PageAnon mapping here,\n\t * but that might overwrite a racing page_add_anon_rmap\n\t * which increments mapcount after us but sets mapping\n\t * before us: so leave the reset to free_unref_page,\n\t * and remember that it's only reliable while mapped.\n\t * Leaving it set also helps swapoff to reinstate ptes\n\t * faster for those pages still in swapcache.\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_clear",
          "args": [
            "vma->vm_mm",
            "address",
            "_pte"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "ptl"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "release_pte_page",
          "args": [
            "src_page"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "release_pte_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "504-509",
          "snippet": "static void release_pte_page(struct page *page)\n{\n\tdec_node_page_state(page, NR_ISOLATED_ANON + page_is_file_cache(page));\n\tunlock_page(page);\n\tputback_lru_page(page);\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void release_pte_page(struct page *page)\n{\n\tdec_node_page_state(page, NR_ISOLATED_ANON + page_is_file_cache(page));\n\tunlock_page(page);\n\tputback_lru_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "page_mapcount(src_page) != 1",
            "src_page"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapcount",
          "args": [
            "src_page"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_user_highpage",
          "args": [
            "page",
            "src_page",
            "address",
            "vma"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "ptl"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_clear",
          "args": [
            "vma->vm_mm",
            "address",
            "_pte"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "ptl"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_zero_pfn",
          "args": [
            "pte_pfn(pteval)"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_pfn",
          "args": [
            "pteval"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_mm_counter",
          "args": [
            "vma->vm_mm",
            "MM_ANONPAGES",
            "1"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "add_mm_counter_fast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "157-165",
          "snippet": "static void add_mm_counter_fast(struct mm_struct *mm, int member, int val)\n{\n\tstruct task_struct *task = current;\n\n\tif (likely(task->mm == mm))\n\t\ttask->rss_stat.count[member] += val;\n\telse\n\t\tadd_mm_counter(mm, member, val);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstatic void add_mm_counter_fast(struct mm_struct *mm, int member, int val)\n{\n\tstruct task_struct *task = current;\n\n\tif (likely(task->mm == mm))\n\t\ttask->rss_stat.count[member] += val;\n\telse\n\t\tadd_mm_counter(mm, member, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_user_highpage",
          "args": [
            "page",
            "address"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_zero_pfn",
          "args": [
            "pte_pfn(pteval)"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_pfn",
          "args": [
            "pteval"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_none",
          "args": [
            "pteval"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void __collapse_huge_page_copy(pte_t *pte, struct page *page,\n\t\t\t\t      struct vm_area_struct *vma,\n\t\t\t\t      unsigned long address,\n\t\t\t\t      spinlock_t *ptl)\n{\n\tpte_t *_pte;\n\tfor (_pte = pte; _pte < pte + HPAGE_PMD_NR;\n\t\t\t\t_pte++, page++, address += PAGE_SIZE) {\n\t\tpte_t pteval = *_pte;\n\t\tstruct page *src_page;\n\n\t\tif (pte_none(pteval) || is_zero_pfn(pte_pfn(pteval))) {\n\t\t\tclear_user_highpage(page, address);\n\t\t\tadd_mm_counter(vma->vm_mm, MM_ANONPAGES, 1);\n\t\t\tif (is_zero_pfn(pte_pfn(pteval))) {\n\t\t\t\t/*\n\t\t\t\t * ptl mostly unnecessary.\n\t\t\t\t */\n\t\t\t\tspin_lock(ptl);\n\t\t\t\t/*\n\t\t\t\t * paravirt calls inside pte_clear here are\n\t\t\t\t * superfluous.\n\t\t\t\t */\n\t\t\t\tpte_clear(vma->vm_mm, address, _pte);\n\t\t\t\tspin_unlock(ptl);\n\t\t\t}\n\t\t} else {\n\t\t\tsrc_page = pte_page(pteval);\n\t\t\tcopy_user_highpage(page, src_page, address, vma);\n\t\t\tVM_BUG_ON_PAGE(page_mapcount(src_page) != 1, src_page);\n\t\t\trelease_pte_page(src_page);\n\t\t\t/*\n\t\t\t * ptl mostly unnecessary, but preempt has to\n\t\t\t * be disabled to update the per-cpu stats\n\t\t\t * inside page_remove_rmap().\n\t\t\t */\n\t\t\tspin_lock(ptl);\n\t\t\t/*\n\t\t\t * paravirt calls inside pte_clear here are\n\t\t\t * superfluous.\n\t\t\t */\n\t\t\tpte_clear(vma->vm_mm, address, _pte);\n\t\t\tpage_remove_rmap(src_page, false);\n\t\t\tspin_unlock(ptl);\n\t\t\tfree_page_and_swap_cache(src_page);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "__collapse_huge_page_isolate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "520-632",
    "snippet": "static int __collapse_huge_page_isolate(struct vm_area_struct *vma,\n\t\t\t\t\tunsigned long address,\n\t\t\t\t\tpte_t *pte)\n{\n\tstruct page *page = NULL;\n\tpte_t *_pte;\n\tint none_or_zero = 0, result = 0, referenced = 0;\n\tbool writable = false;\n\n\tfor (_pte = pte; _pte < pte+HPAGE_PMD_NR;\n\t     _pte++, address += PAGE_SIZE) {\n\t\tpte_t pteval = *_pte;\n\t\tif (pte_none(pteval) || (pte_present(pteval) &&\n\t\t\t\tis_zero_pfn(pte_pfn(pteval)))) {\n\t\t\tif (!userfaultfd_armed(vma) &&\n\t\t\t    ++none_or_zero <= khugepaged_max_ptes_none) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tresult = SCAN_EXCEED_NONE_PTE;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (!pte_present(pteval)) {\n\t\t\tresult = SCAN_PTE_NON_PRESENT;\n\t\t\tgoto out;\n\t\t}\n\t\tpage = vm_normal_page(vma, address, pteval);\n\t\tif (unlikely(!page)) {\n\t\t\tresult = SCAN_PAGE_NULL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* TODO: teach khugepaged to collapse THP mapped with pte */\n\t\tif (PageCompound(page)) {\n\t\t\tresult = SCAN_PAGE_COMPOUND;\n\t\t\tgoto out;\n\t\t}\n\n\t\tVM_BUG_ON_PAGE(!PageAnon(page), page);\n\n\t\t/*\n\t\t * We can do it before isolate_lru_page because the\n\t\t * page can't be freed from under us. NOTE: PG_lock\n\t\t * is needed to serialize against split_huge_page\n\t\t * when invoked from the VM.\n\t\t */\n\t\tif (!trylock_page(page)) {\n\t\t\tresult = SCAN_PAGE_LOCK;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * cannot use mapcount: can't collapse if there's a gup pin.\n\t\t * The page must only be referenced by the scanned process\n\t\t * and page swap cache.\n\t\t */\n\t\tif (page_count(page) != 1 + PageSwapCache(page)) {\n\t\t\tunlock_page(page);\n\t\t\tresult = SCAN_PAGE_COUNT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (pte_write(pteval)) {\n\t\t\twritable = true;\n\t\t} else {\n\t\t\tif (PageSwapCache(page) &&\n\t\t\t    !reuse_swap_page(page, NULL)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tresult = SCAN_SWAP_CACHE_PAGE;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Page is not in the swap cache. It can be collapsed\n\t\t\t * into a THP.\n\t\t\t */\n\t\t}\n\n\t\t/*\n\t\t * Isolate the page to avoid collapsing an hugepage\n\t\t * currently in use by the VM.\n\t\t */\n\t\tif (isolate_lru_page(page)) {\n\t\t\tunlock_page(page);\n\t\t\tresult = SCAN_DEL_PAGE_LRU;\n\t\t\tgoto out;\n\t\t}\n\t\tinc_node_page_state(page,\n\t\t\t\tNR_ISOLATED_ANON + page_is_file_cache(page));\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\t\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\n\t\t/* There should be enough young pte to collapse the page */\n\t\tif (pte_young(pteval) ||\n\t\t    page_is_young(page) || PageReferenced(page) ||\n\t\t    mmu_notifier_test_young(vma->vm_mm, address))\n\t\t\treferenced++;\n\t}\n\tif (likely(writable)) {\n\t\tif (likely(referenced)) {\n\t\t\tresult = SCAN_SUCCEED;\n\t\t\ttrace_mm_collapse_huge_page_isolate(page, none_or_zero,\n\t\t\t\t\t\t\t    referenced, writable, result);\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\tresult = SCAN_PAGE_RO;\n\t}\n\nout:\n\trelease_pte_pages(pte, _pte);\n\ttrace_mm_collapse_huge_page_isolate(page, none_or_zero,\n\t\t\t\t\t    referenced, writable, result);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int khugepaged_max_ptes_none"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_mm_collapse_huge_page_isolate",
          "args": [
            "page",
            "none_or_zero",
            "referenced",
            "writable",
            "result"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "release_pte_pages",
          "args": [
            "pte",
            "_pte"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "release_pte_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "511-518",
          "snippet": "static void release_pte_pages(pte_t *pte, pte_t *_pte)\n{\n\twhile (--_pte >= pte) {\n\t\tpte_t pteval = *_pte;\n\t\tif (!pte_none(pteval) && !is_zero_pfn(pte_pfn(pteval)))\n\t\t\trelease_pte_page(pte_page(pteval));\n\t}\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void release_pte_pages(pte_t *pte, pte_t *_pte)\n{\n\twhile (--_pte >= pte) {\n\t\tpte_t pteval = *_pte;\n\t\tif (!pte_none(pteval) && !is_zero_pfn(pte_pfn(pteval)))\n\t\t\trelease_pte_page(pte_page(pteval));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_mm_collapse_huge_page_isolate",
          "args": [
            "page",
            "none_or_zero",
            "referenced",
            "writable",
            "result"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "referenced"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "writable"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_notifier_test_young",
          "args": [
            "vma->vm_mm",
            "address"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "__mmu_notifier_test_young",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_notifier.c",
          "lines": "144-161",
          "snippet": "int __mmu_notifier_test_young(struct mm_struct *mm,\n\t\t\t      unsigned long address)\n{\n\tstruct mmu_notifier *mn;\n\tint young = 0, id;\n\n\tid = srcu_read_lock(&srcu);\n\thlist_for_each_entry_rcu(mn, &mm->mmu_notifier_mm->list, hlist) {\n\t\tif (mn->ops->test_young) {\n\t\t\tyoung = mn->ops->test_young(mn, mm, address);\n\t\t\tif (young)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tsrcu_read_unlock(&srcu, id);\n\n\treturn young;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/srcu.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/srcu.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/mmu_notifier.h>\n#include <linux/rculist.h>\n\nint __mmu_notifier_test_young(struct mm_struct *mm,\n\t\t\t      unsigned long address)\n{\n\tstruct mmu_notifier *mn;\n\tint young = 0, id;\n\n\tid = srcu_read_lock(&srcu);\n\thlist_for_each_entry_rcu(mn, &mm->mmu_notifier_mm->list, hlist) {\n\t\tif (mn->ops->test_young) {\n\t\t\tyoung = mn->ops->test_young(mn, mm, address);\n\t\t\tif (young)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tsrcu_read_unlock(&srcu, id);\n\n\treturn young;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageReferenced",
          "args": [
            "page"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_is_young",
          "args": [
            "page"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_young",
          "args": [
            "pteval"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageLRU(page)",
            "page"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLocked(page)",
            "page"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_node_page_state",
          "args": [
            "page",
            "NR_ISOLATED_ANON + page_is_file_cache(page)"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "inc_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "655-664",
          "snippet": "void inc_node_page_state(struct page *page, enum node_stat_item item)\n{\n\tunsigned long flags;\n\tstruct pglist_data *pgdat;\n\n\tpgdat = page_pgdat(page);\n\tlocal_irq_save(flags);\n\t__inc_node_state(pgdat, item);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid inc_node_page_state(struct page *page, enum node_stat_item item)\n{\n\tunsigned long flags;\n\tstruct pglist_data *pgdat;\n\n\tpgdat = page_pgdat(page);\n\tlocal_irq_save(flags);\n\t__inc_node_state(pgdat, item);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_is_file_cache",
          "args": [
            "page"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isolate_lru_page",
          "args": [
            "page"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "isolate_lru_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1772-1795",
          "snippet": "int isolate_lru_page(struct page *page)\n{\n\tint ret = -EBUSY;\n\n\tVM_BUG_ON_PAGE(!page_count(page), page);\n\tWARN_RATELIMIT(PageTail(page), \"trying to isolate tail page\");\n\n\tif (PageLRU(page)) {\n\t\tstruct zone *zone = page_zone(page);\n\t\tstruct lruvec *lruvec;\n\n\t\tspin_lock_irq(zone_lru_lock(zone));\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\t\tif (PageLRU(page)) {\n\t\t\tint lru = page_lru(page);\n\t\t\tget_page(page);\n\t\t\tClearPageLRU(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, lru);\n\t\t\tret = 0;\n\t\t}\n\t\tspin_unlock_irq(zone_lru_lock(zone));\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint isolate_lru_page(struct page *page)\n{\n\tint ret = -EBUSY;\n\n\tVM_BUG_ON_PAGE(!page_count(page), page);\n\tWARN_RATELIMIT(PageTail(page), \"trying to isolate tail page\");\n\n\tif (PageLRU(page)) {\n\t\tstruct zone *zone = page_zone(page);\n\t\tstruct lruvec *lruvec;\n\n\t\tspin_lock_irq(zone_lru_lock(zone));\n\t\tlruvec = mem_cgroup_page_lruvec(page, zone->zone_pgdat);\n\t\tif (PageLRU(page)) {\n\t\t\tint lru = page_lru(page);\n\t\t\tget_page(page);\n\t\t\tClearPageLRU(page);\n\t\t\tdel_page_from_lru_list(page, lruvec, lru);\n\t\t\tret = 0;\n\t\t}\n\t\tspin_unlock_irq(zone_lru_lock(zone));\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reuse_swap_page",
          "args": [
            "page",
            "NULL"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "reuse_swap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "1544-1578",
          "snippet": "bool reuse_swap_page(struct page *page, int *total_map_swapcount)\n{\n\tint count, total_mapcount, total_swapcount;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tif (unlikely(PageKsm(page)))\n\t\treturn false;\n\tcount = page_trans_huge_map_swapcount(page, &total_mapcount,\n\t\t\t\t\t      &total_swapcount);\n\tif (total_map_swapcount)\n\t\t*total_map_swapcount = total_mapcount + total_swapcount;\n\tif (count == 1 && PageSwapCache(page) &&\n\t    (likely(!PageTransCompound(page)) ||\n\t     /* The remaining swap count will be freed soon */\n\t     total_swapcount == page_swapcount(page))) {\n\t\tif (!PageWriteback(page)) {\n\t\t\tpage = compound_head(page);\n\t\t\tdelete_from_swap_cache(page);\n\t\t\tSetPageDirty(page);\n\t\t} else {\n\t\t\tswp_entry_t entry;\n\t\t\tstruct swap_info_struct *p;\n\n\t\t\tentry.val = page_private(page);\n\t\t\tp = swap_info_get(entry);\n\t\t\tif (p->flags & SWP_STABLE_WRITES) {\n\t\t\t\tspin_unlock(&p->lock);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tspin_unlock(&p->lock);\n\t\t}\n\t}\n\n\treturn count <= 1;\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_swap_count_continuations(struct swap_info_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic void free_swap_count_continuations(struct swap_info_struct *);\n\nbool reuse_swap_page(struct page *page, int *total_map_swapcount)\n{\n\tint count, total_mapcount, total_swapcount;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tif (unlikely(PageKsm(page)))\n\t\treturn false;\n\tcount = page_trans_huge_map_swapcount(page, &total_mapcount,\n\t\t\t\t\t      &total_swapcount);\n\tif (total_map_swapcount)\n\t\t*total_map_swapcount = total_mapcount + total_swapcount;\n\tif (count == 1 && PageSwapCache(page) &&\n\t    (likely(!PageTransCompound(page)) ||\n\t     /* The remaining swap count will be freed soon */\n\t     total_swapcount == page_swapcount(page))) {\n\t\tif (!PageWriteback(page)) {\n\t\t\tpage = compound_head(page);\n\t\t\tdelete_from_swap_cache(page);\n\t\t\tSetPageDirty(page);\n\t\t} else {\n\t\t\tswp_entry_t entry;\n\t\t\tstruct swap_info_struct *p;\n\n\t\t\tentry.val = page_private(page);\n\t\t\tp = swap_info_get(entry);\n\t\t\tif (p->flags & SWP_STABLE_WRITES) {\n\t\t\t\tspin_unlock(&p->lock);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tspin_unlock(&p->lock);\n\t\t}\n\t}\n\n\treturn count <= 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_write",
          "args": [
            "pteval"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageAnon(page)",
            "page"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageAnon",
          "args": [
            "page"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "page"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_normal_page",
          "args": [
            "vma",
            "address",
            "pteval"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "vm_normal_page_pmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "651-689",
          "snippet": "struct page *vm_normal_page_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tpmd_t pmd)\n{\n\tunsigned long pfn = pmd_pfn(pmd);\n\n\t/*\n\t * There is no pmd_special() but there may be special pmds, e.g.\n\t * in a direct-access (dax) mapping, so let's just replicate the\n\t * !CONFIG_ARCH_HAS_PTE_SPECIAL case from vm_normal_page() here.\n\t */\n\tif (unlikely(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP))) {\n\t\tif (vma->vm_flags & VM_MIXEDMAP) {\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\treturn NULL;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tunsigned long off;\n\t\t\toff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\t\tif (pfn == vma->vm_pgoff + off)\n\t\t\t\treturn NULL;\n\t\t\tif (!is_cow_mapping(vma->vm_flags))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (pmd_devmap(pmd))\n\t\treturn NULL;\n\tif (is_zero_pfn(pfn))\n\t\treturn NULL;\n\tif (unlikely(pfn > highest_memmap_pfn))\n\t\treturn NULL;\n\n\t/*\n\t * NOTE! We still have PageReserved() pages in the page tables.\n\t * eg. VDSO mappings can cause them to exist.\n\t */\nout:\n\treturn pfn_to_page(pfn);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nstruct page *vm_normal_page_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tpmd_t pmd)\n{\n\tunsigned long pfn = pmd_pfn(pmd);\n\n\t/*\n\t * There is no pmd_special() but there may be special pmds, e.g.\n\t * in a direct-access (dax) mapping, so let's just replicate the\n\t * !CONFIG_ARCH_HAS_PTE_SPECIAL case from vm_normal_page() here.\n\t */\n\tif (unlikely(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP))) {\n\t\tif (vma->vm_flags & VM_MIXEDMAP) {\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\treturn NULL;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tunsigned long off;\n\t\t\toff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\t\tif (pfn == vma->vm_pgoff + off)\n\t\t\t\treturn NULL;\n\t\t\tif (!is_cow_mapping(vma->vm_flags))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (pmd_devmap(pmd))\n\t\treturn NULL;\n\tif (is_zero_pfn(pfn))\n\t\treturn NULL;\n\tif (unlikely(pfn > highest_memmap_pfn))\n\t\treturn NULL;\n\n\t/*\n\t * NOTE! We still have PageReserved() pages in the page tables.\n\t * eg. VDSO mappings can cause them to exist.\n\t */\nout:\n\treturn pfn_to_page(pfn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "pteval"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userfaultfd_armed",
          "args": [
            "vma"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_zero_pfn",
          "args": [
            "pte_pfn(pteval)"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_pfn",
          "args": [
            "pteval"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_present",
          "args": [
            "pteval"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_none",
          "args": [
            "pteval"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic unsigned int khugepaged_max_ptes_none;\n\nstatic int __collapse_huge_page_isolate(struct vm_area_struct *vma,\n\t\t\t\t\tunsigned long address,\n\t\t\t\t\tpte_t *pte)\n{\n\tstruct page *page = NULL;\n\tpte_t *_pte;\n\tint none_or_zero = 0, result = 0, referenced = 0;\n\tbool writable = false;\n\n\tfor (_pte = pte; _pte < pte+HPAGE_PMD_NR;\n\t     _pte++, address += PAGE_SIZE) {\n\t\tpte_t pteval = *_pte;\n\t\tif (pte_none(pteval) || (pte_present(pteval) &&\n\t\t\t\tis_zero_pfn(pte_pfn(pteval)))) {\n\t\t\tif (!userfaultfd_armed(vma) &&\n\t\t\t    ++none_or_zero <= khugepaged_max_ptes_none) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tresult = SCAN_EXCEED_NONE_PTE;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (!pte_present(pteval)) {\n\t\t\tresult = SCAN_PTE_NON_PRESENT;\n\t\t\tgoto out;\n\t\t}\n\t\tpage = vm_normal_page(vma, address, pteval);\n\t\tif (unlikely(!page)) {\n\t\t\tresult = SCAN_PAGE_NULL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* TODO: teach khugepaged to collapse THP mapped with pte */\n\t\tif (PageCompound(page)) {\n\t\t\tresult = SCAN_PAGE_COMPOUND;\n\t\t\tgoto out;\n\t\t}\n\n\t\tVM_BUG_ON_PAGE(!PageAnon(page), page);\n\n\t\t/*\n\t\t * We can do it before isolate_lru_page because the\n\t\t * page can't be freed from under us. NOTE: PG_lock\n\t\t * is needed to serialize against split_huge_page\n\t\t * when invoked from the VM.\n\t\t */\n\t\tif (!trylock_page(page)) {\n\t\t\tresult = SCAN_PAGE_LOCK;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * cannot use mapcount: can't collapse if there's a gup pin.\n\t\t * The page must only be referenced by the scanned process\n\t\t * and page swap cache.\n\t\t */\n\t\tif (page_count(page) != 1 + PageSwapCache(page)) {\n\t\t\tunlock_page(page);\n\t\t\tresult = SCAN_PAGE_COUNT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (pte_write(pteval)) {\n\t\t\twritable = true;\n\t\t} else {\n\t\t\tif (PageSwapCache(page) &&\n\t\t\t    !reuse_swap_page(page, NULL)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tresult = SCAN_SWAP_CACHE_PAGE;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Page is not in the swap cache. It can be collapsed\n\t\t\t * into a THP.\n\t\t\t */\n\t\t}\n\n\t\t/*\n\t\t * Isolate the page to avoid collapsing an hugepage\n\t\t * currently in use by the VM.\n\t\t */\n\t\tif (isolate_lru_page(page)) {\n\t\t\tunlock_page(page);\n\t\t\tresult = SCAN_DEL_PAGE_LRU;\n\t\t\tgoto out;\n\t\t}\n\t\tinc_node_page_state(page,\n\t\t\t\tNR_ISOLATED_ANON + page_is_file_cache(page));\n\t\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\t\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\n\t\t/* There should be enough young pte to collapse the page */\n\t\tif (pte_young(pteval) ||\n\t\t    page_is_young(page) || PageReferenced(page) ||\n\t\t    mmu_notifier_test_young(vma->vm_mm, address))\n\t\t\treferenced++;\n\t}\n\tif (likely(writable)) {\n\t\tif (likely(referenced)) {\n\t\t\tresult = SCAN_SUCCEED;\n\t\t\ttrace_mm_collapse_huge_page_isolate(page, none_or_zero,\n\t\t\t\t\t\t\t    referenced, writable, result);\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\tresult = SCAN_PAGE_RO;\n\t}\n\nout:\n\trelease_pte_pages(pte, _pte);\n\ttrace_mm_collapse_huge_page_isolate(page, none_or_zero,\n\t\t\t\t\t    referenced, writable, result);\n\treturn 0;\n}"
  },
  {
    "function_name": "release_pte_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "511-518",
    "snippet": "static void release_pte_pages(pte_t *pte, pte_t *_pte)\n{\n\twhile (--_pte >= pte) {\n\t\tpte_t pteval = *_pte;\n\t\tif (!pte_none(pteval) && !is_zero_pfn(pte_pfn(pteval)))\n\t\t\trelease_pte_page(pte_page(pteval));\n\t}\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_pte_page",
          "args": [
            "pte_page(pteval)"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "release_pte_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "504-509",
          "snippet": "static void release_pte_page(struct page *page)\n{\n\tdec_node_page_state(page, NR_ISOLATED_ANON + page_is_file_cache(page));\n\tunlock_page(page);\n\tputback_lru_page(page);\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void release_pte_page(struct page *page)\n{\n\tdec_node_page_state(page, NR_ISOLATED_ANON + page_is_file_cache(page));\n\tunlock_page(page);\n\tputback_lru_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_zero_pfn",
          "args": [
            "pte_pfn(pteval)"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_pfn",
          "args": [
            "pteval"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_none",
          "args": [
            "pteval"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void release_pte_pages(pte_t *pte, pte_t *_pte)\n{\n\twhile (--_pte >= pte) {\n\t\tpte_t pteval = *_pte;\n\t\tif (!pte_none(pteval) && !is_zero_pfn(pte_pfn(pteval)))\n\t\t\trelease_pte_page(pte_page(pteval));\n\t}\n}"
  },
  {
    "function_name": "release_pte_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "504-509",
    "snippet": "static void release_pte_page(struct page *page)\n{\n\tdec_node_page_state(page, NR_ISOLATED_ANON + page_is_file_cache(page));\n\tunlock_page(page);\n\tputback_lru_page(page);\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "putback_lru_page",
          "args": [
            "page"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "putback_lru_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1005-1009",
          "snippet": "void putback_lru_page(struct page *page)\n{\n\tlru_cache_add(page);\n\tput_page(page);\t\t/* drop ref from isolate */\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid putback_lru_page(struct page *page)\n{\n\tlru_cache_add(page);\n\tput_page(page);\t\t/* drop ref from isolate */\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dec_node_page_state",
          "args": [
            "page",
            "NR_ISOLATED_ANON + page_is_file_cache(page)"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "dec_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "667-674",
          "snippet": "void dec_node_page_state(struct page *page, enum node_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_node_page_state(page, item);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid dec_node_page_state(struct page *page, enum node_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_node_page_state(page, item);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_is_file_cache",
          "args": [
            "page"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void release_pte_page(struct page *page)\n{\n\tdec_node_page_state(page, NR_ISOLATED_ANON + page_is_file_cache(page));\n\tunlock_page(page);\n\tputback_lru_page(page);\n}"
  },
  {
    "function_name": "__khugepaged_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "472-502",
    "snippet": "void __khugepaged_exit(struct mm_struct *mm)\n{\n\tstruct mm_slot *mm_slot;\n\tint free = 0;\n\n\tspin_lock(&khugepaged_mm_lock);\n\tmm_slot = get_mm_slot(mm);\n\tif (mm_slot && khugepaged_scan.mm_slot != mm_slot) {\n\t\thash_del(&mm_slot->hash);\n\t\tlist_del(&mm_slot->mm_node);\n\t\tfree = 1;\n\t}\n\tspin_unlock(&khugepaged_mm_lock);\n\n\tif (free) {\n\t\tclear_bit(MMF_VM_HUGEPAGE, &mm->flags);\n\t\tfree_mm_slot(mm_slot);\n\t\tmmdrop(mm);\n\t} else if (mm_slot) {\n\t\t/*\n\t\t * This is required to serialize against\n\t\t * khugepaged_test_exit() (which is guaranteed to run\n\t\t * under mmap sem read mode). Stop here (after we\n\t\t * return all pagetables will be destroyed) until\n\t\t * khugepaged has finished working on the pagetables\n\t\t * under the mmap_sem.\n\t\t */\n\t\tdown_write(&mm->mmap_sem);\n\t\tup_write(&mm->mmap_sem);\n\t}\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(khugepaged_mm_lock);",
      "static struct khugepaged_scan khugepaged_scan = {\n\t.mm_head = LIST_HEAD_INIT(khugepaged_scan.mm_head),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmdrop",
          "args": [
            "mm"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_mm_slot",
          "args": [
            "mm_slot"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "free_mm_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "372-375",
          "snippet": "static inline void free_mm_slot(struct mm_slot *mm_slot)\n{\n\tkmem_cache_free(mm_slot_cache, mm_slot);\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *mm_slot_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic struct kmem_cache *mm_slot_cache;\n\nstatic inline void free_mm_slot(struct mm_slot *mm_slot)\n{\n\tkmem_cache_free(mm_slot_cache, mm_slot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "MMF_VM_HUGEPAGE",
            "&mm->flags"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "clear_bit_unlock_is_negative_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/filemap.c",
          "lines": "1171-1176",
          "snippet": "static inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}",
          "includes": [
            "#include <asm/mman.h>",
            "#include <linux/buffer_head.h> /* for try_to_free_buffers */",
            "#include <trace/events/filemap.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/rmap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/security.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/hash.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/capability.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/compiler.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mman.h>\n#include <linux/buffer_head.h> /* for try_to_free_buffers */\n#include <trace/events/filemap.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/delayacct.h>\n#include <linux/rmap.h>\n#include <linux/shmem_fs.h>\n#include <linux/cleancache.h>\n#include <linux/memcontrol.h>\n#include <linux/hugetlb.h>\n#include <linux/cpuset.h>\n#include <linux/security.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/hash.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel_stat.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\nstatic inline bool clear_bit_unlock_is_negative_byte(long nr, volatile void *mem)\n{\n\tclear_bit_unlock(nr, mem);\n\t/* smp_mb__after_atomic(); */\n\treturn test_bit(PG_waiters, mem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&khugepaged_mm_lock"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&mm_slot->mm_node"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_del",
          "args": [
            "&mm_slot->hash"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mm_slot",
          "args": [
            "mm"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "get_mm_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "377-386",
          "snippet": "static struct mm_slot *get_mm_slot(struct mm_struct *mm)\n{\n\tstruct mm_slot *mm_slot;\n\n\thash_for_each_possible(mm_slots_hash, mm_slot, hash, (unsigned long)mm)\n\t\tif (mm == mm_slot->mm)\n\t\t\treturn mm_slot;\n\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic struct mm_slot *get_mm_slot(struct mm_struct *mm)\n{\n\tstruct mm_slot *mm_slot;\n\n\thash_for_each_possible(mm_slots_hash, mm_slot, hash, (unsigned long)mm)\n\t\tif (mm == mm_slot->mm)\n\t\t\treturn mm_slot;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&khugepaged_mm_lock"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_SPINLOCK(khugepaged_mm_lock);\nstatic struct khugepaged_scan khugepaged_scan = {\n\t.mm_head = LIST_HEAD_INIT(khugepaged_scan.mm_head),\n};\n\nvoid __khugepaged_exit(struct mm_struct *mm)\n{\n\tstruct mm_slot *mm_slot;\n\tint free = 0;\n\n\tspin_lock(&khugepaged_mm_lock);\n\tmm_slot = get_mm_slot(mm);\n\tif (mm_slot && khugepaged_scan.mm_slot != mm_slot) {\n\t\thash_del(&mm_slot->hash);\n\t\tlist_del(&mm_slot->mm_node);\n\t\tfree = 1;\n\t}\n\tspin_unlock(&khugepaged_mm_lock);\n\n\tif (free) {\n\t\tclear_bit(MMF_VM_HUGEPAGE, &mm->flags);\n\t\tfree_mm_slot(mm_slot);\n\t\tmmdrop(mm);\n\t} else if (mm_slot) {\n\t\t/*\n\t\t * This is required to serialize against\n\t\t * khugepaged_test_exit() (which is guaranteed to run\n\t\t * under mmap sem read mode). Stop here (after we\n\t\t * return all pagetables will be destroyed) until\n\t\t * khugepaged has finished working on the pagetables\n\t\t * under the mmap_sem.\n\t\t */\n\t\tdown_write(&mm->mmap_sem);\n\t\tup_write(&mm->mmap_sem);\n\t}\n}"
  },
  {
    "function_name": "khugepaged_enter_vma_merge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "453-470",
    "snippet": "int khugepaged_enter_vma_merge(struct vm_area_struct *vma,\n\t\t\t       unsigned long vm_flags)\n{\n\tunsigned long hstart, hend;\n\n\t/*\n\t * khugepaged does not yet work on non-shmem files or special\n\t * mappings. And file-private shmem THP is not supported.\n\t */\n\tif (!hugepage_vma_check(vma, vm_flags))\n\t\treturn 0;\n\n\thstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;\n\thend = vma->vm_end & HPAGE_PMD_MASK;\n\tif (hstart < hend)\n\t\treturn khugepaged_enter(vma, vm_flags);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "khugepaged_enter",
          "args": [
            "vma",
            "vm_flags"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "khugepaged_enter_vma_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "453-470",
          "snippet": "int khugepaged_enter_vma_merge(struct vm_area_struct *vma,\n\t\t\t       unsigned long vm_flags)\n{\n\tunsigned long hstart, hend;\n\n\t/*\n\t * khugepaged does not yet work on non-shmem files or special\n\t * mappings. And file-private shmem THP is not supported.\n\t */\n\tif (!hugepage_vma_check(vma, vm_flags))\n\t\treturn 0;\n\n\thstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;\n\thend = vma->vm_end & HPAGE_PMD_MASK;\n\tif (hstart < hend)\n\t\treturn khugepaged_enter(vma, vm_flags);\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "hugepage_vma_check",
          "args": [
            "vma",
            "vm_flags"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "hugepage_vma_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "400-418",
          "snippet": "static bool hugepage_vma_check(struct vm_area_struct *vma,\n\t\t\t       unsigned long vm_flags)\n{\n\tif ((!(vm_flags & VM_HUGEPAGE) && !khugepaged_always()) ||\n\t    (vm_flags & VM_NOHUGEPAGE) ||\n\t    test_bit(MMF_DISABLE_THP, &vma->vm_mm->flags))\n\t\treturn false;\n\tif (shmem_file(vma->vm_file)) {\n\t\tif (!IS_ENABLED(CONFIG_TRANSPARENT_HUGE_PAGECACHE))\n\t\t\treturn false;\n\t\treturn IS_ALIGNED((vma->vm_start >> PAGE_SHIFT) - vma->vm_pgoff,\n\t\t\t\tHPAGE_PMD_NR);\n\t}\n\tif (!vma->anon_vma || vma->vm_ops)\n\t\treturn false;\n\tif (is_vma_temporary_stack(vma))\n\t\treturn false;\n\treturn !(vm_flags & VM_NO_KHUGEPAGED);\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define VM_NO_KHUGEPAGED (VM_SPECIAL | VM_HUGETLB)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\n#define VM_NO_KHUGEPAGED (VM_SPECIAL | VM_HUGETLB)\n\nstatic bool hugepage_vma_check(struct vm_area_struct *vma,\n\t\t\t       unsigned long vm_flags)\n{\n\tif ((!(vm_flags & VM_HUGEPAGE) && !khugepaged_always()) ||\n\t    (vm_flags & VM_NOHUGEPAGE) ||\n\t    test_bit(MMF_DISABLE_THP, &vma->vm_mm->flags))\n\t\treturn false;\n\tif (shmem_file(vma->vm_file)) {\n\t\tif (!IS_ENABLED(CONFIG_TRANSPARENT_HUGE_PAGECACHE))\n\t\t\treturn false;\n\t\treturn IS_ALIGNED((vma->vm_start >> PAGE_SHIFT) - vma->vm_pgoff,\n\t\t\t\tHPAGE_PMD_NR);\n\t}\n\tif (!vma->anon_vma || vma->vm_ops)\n\t\treturn false;\n\tif (is_vma_temporary_stack(vma))\n\t\treturn false;\n\treturn !(vm_flags & VM_NO_KHUGEPAGED);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nint khugepaged_enter_vma_merge(struct vm_area_struct *vma,\n\t\t\t       unsigned long vm_flags)\n{\n\tunsigned long hstart, hend;\n\n\t/*\n\t * khugepaged does not yet work on non-shmem files or special\n\t * mappings. And file-private shmem THP is not supported.\n\t */\n\tif (!hugepage_vma_check(vma, vm_flags))\n\t\treturn 0;\n\n\thstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;\n\thend = vma->vm_end & HPAGE_PMD_MASK;\n\tif (hstart < hend)\n\t\treturn khugepaged_enter(vma, vm_flags);\n\treturn 0;\n}"
  },
  {
    "function_name": "__khugepaged_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "420-451",
    "snippet": "int __khugepaged_enter(struct mm_struct *mm)\n{\n\tstruct mm_slot *mm_slot;\n\tint wakeup;\n\n\tmm_slot = alloc_mm_slot();\n\tif (!mm_slot)\n\t\treturn -ENOMEM;\n\n\t/* __khugepaged_exit() must not run from under us */\n\tVM_BUG_ON_MM(khugepaged_test_exit(mm), mm);\n\tif (unlikely(test_and_set_bit(MMF_VM_HUGEPAGE, &mm->flags))) {\n\t\tfree_mm_slot(mm_slot);\n\t\treturn 0;\n\t}\n\n\tspin_lock(&khugepaged_mm_lock);\n\tinsert_to_mm_slots_hash(mm, mm_slot);\n\t/*\n\t * Insert just behind the scanning cursor, to let the area settle\n\t * down a little.\n\t */\n\twakeup = list_empty(&khugepaged_scan.mm_head);\n\tlist_add_tail(&mm_slot->mm_node, &khugepaged_scan.mm_head);\n\tspin_unlock(&khugepaged_mm_lock);\n\n\tmmgrab(mm);\n\tif (wakeup)\n\t\twake_up_interruptible(&khugepaged_wait);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(khugepaged_mm_lock);",
      "static DECLARE_WAIT_QUEUE_HEAD(khugepaged_wait);",
      "static struct khugepaged_scan khugepaged_scan = {\n\t.mm_head = LIST_HEAD_INIT(khugepaged_scan.mm_head),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&khugepaged_wait"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmgrab",
          "args": [
            "mm"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&khugepaged_mm_lock"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&mm_slot->mm_node",
            "&khugepaged_scan.mm_head"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&khugepaged_scan.mm_head"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_to_mm_slots_hash",
          "args": [
            "mm",
            "mm_slot"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "insert_to_mm_slots_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "388-393",
          "snippet": "static void insert_to_mm_slots_hash(struct mm_struct *mm,\n\t\t\t\t    struct mm_slot *mm_slot)\n{\n\tmm_slot->mm = mm;\n\thash_add(mm_slots_hash, &mm_slot->hash, (long)mm);\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void insert_to_mm_slots_hash(struct mm_struct *mm,\n\t\t\t\t    struct mm_slot *mm_slot)\n{\n\tmm_slot->mm = mm;\n\thash_add(mm_slots_hash, &mm_slot->hash, (long)mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&khugepaged_mm_lock"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_mm_slot",
          "args": [
            "mm_slot"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "free_mm_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "372-375",
          "snippet": "static inline void free_mm_slot(struct mm_slot *mm_slot)\n{\n\tkmem_cache_free(mm_slot_cache, mm_slot);\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *mm_slot_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic struct kmem_cache *mm_slot_cache;\n\nstatic inline void free_mm_slot(struct mm_slot *mm_slot)\n{\n\tkmem_cache_free(mm_slot_cache, mm_slot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "test_and_set_bit(MMF_VM_HUGEPAGE, &mm->flags)"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "MMF_VM_HUGEPAGE",
            "&mm->flags"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_MM",
          "args": [
            "khugepaged_test_exit(mm)",
            "mm"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "khugepaged_test_exit",
          "args": [
            "mm"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "khugepaged_test_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "395-398",
          "snippet": "static inline int khugepaged_test_exit(struct mm_struct *mm)\n{\n\treturn atomic_read(&mm->mm_users) == 0;\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic inline int khugepaged_test_exit(struct mm_struct *mm)\n{\n\treturn atomic_read(&mm->mm_users) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_mm_slot",
          "args": [],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_mm_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "365-370",
          "snippet": "static inline struct mm_slot *alloc_mm_slot(void)\n{\n\tif (!mm_slot_cache)\t/* initialization failed */\n\t\treturn NULL;\n\treturn kmem_cache_zalloc(mm_slot_cache, GFP_KERNEL);\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *mm_slot_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic struct kmem_cache *mm_slot_cache;\n\nstatic inline struct mm_slot *alloc_mm_slot(void)\n{\n\tif (!mm_slot_cache)\t/* initialization failed */\n\t\treturn NULL;\n\treturn kmem_cache_zalloc(mm_slot_cache, GFP_KERNEL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_SPINLOCK(khugepaged_mm_lock);\nstatic DECLARE_WAIT_QUEUE_HEAD(khugepaged_wait);\nstatic struct khugepaged_scan khugepaged_scan = {\n\t.mm_head = LIST_HEAD_INIT(khugepaged_scan.mm_head),\n};\n\nint __khugepaged_enter(struct mm_struct *mm)\n{\n\tstruct mm_slot *mm_slot;\n\tint wakeup;\n\n\tmm_slot = alloc_mm_slot();\n\tif (!mm_slot)\n\t\treturn -ENOMEM;\n\n\t/* __khugepaged_exit() must not run from under us */\n\tVM_BUG_ON_MM(khugepaged_test_exit(mm), mm);\n\tif (unlikely(test_and_set_bit(MMF_VM_HUGEPAGE, &mm->flags))) {\n\t\tfree_mm_slot(mm_slot);\n\t\treturn 0;\n\t}\n\n\tspin_lock(&khugepaged_mm_lock);\n\tinsert_to_mm_slots_hash(mm, mm_slot);\n\t/*\n\t * Insert just behind the scanning cursor, to let the area settle\n\t * down a little.\n\t */\n\twakeup = list_empty(&khugepaged_scan.mm_head);\n\tlist_add_tail(&mm_slot->mm_node, &khugepaged_scan.mm_head);\n\tspin_unlock(&khugepaged_mm_lock);\n\n\tmmgrab(mm);\n\tif (wakeup)\n\t\twake_up_interruptible(&khugepaged_wait);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hugepage_vma_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "400-418",
    "snippet": "static bool hugepage_vma_check(struct vm_area_struct *vma,\n\t\t\t       unsigned long vm_flags)\n{\n\tif ((!(vm_flags & VM_HUGEPAGE) && !khugepaged_always()) ||\n\t    (vm_flags & VM_NOHUGEPAGE) ||\n\t    test_bit(MMF_DISABLE_THP, &vma->vm_mm->flags))\n\t\treturn false;\n\tif (shmem_file(vma->vm_file)) {\n\t\tif (!IS_ENABLED(CONFIG_TRANSPARENT_HUGE_PAGECACHE))\n\t\t\treturn false;\n\t\treturn IS_ALIGNED((vma->vm_start >> PAGE_SHIFT) - vma->vm_pgoff,\n\t\t\t\tHPAGE_PMD_NR);\n\t}\n\tif (!vma->anon_vma || vma->vm_ops)\n\t\treturn false;\n\tif (is_vma_temporary_stack(vma))\n\t\treturn false;\n\treturn !(vm_flags & VM_NO_KHUGEPAGED);\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define VM_NO_KHUGEPAGED (VM_SPECIAL | VM_HUGETLB)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_vma_temporary_stack",
          "args": [
            "vma"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "is_vma_temporary_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/rmap.c",
          "lines": "1665-1677",
          "snippet": "bool is_vma_temporary_stack(struct vm_area_struct *vma)\n{\n\tint maybe_stack = vma->vm_flags & (VM_GROWSDOWN | VM_GROWSUP);\n\n\tif (!maybe_stack)\n\t\treturn false;\n\n\tif ((vma->vm_flags & VM_STACK_INCOMPLETE_SETUP) ==\n\t\t\t\t\t\tVM_STACK_INCOMPLETE_SETUP)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/tlb.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/tlb.h>\n#include <asm/tlbflush.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/page_idle.h>\n#include <linux/backing-dev.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nbool is_vma_temporary_stack(struct vm_area_struct *vma)\n{\n\tint maybe_stack = vma->vm_flags & (VM_GROWSDOWN | VM_GROWSUP);\n\n\tif (!maybe_stack)\n\t\treturn false;\n\n\tif ((vma->vm_flags & VM_STACK_INCOMPLETE_SETUP) ==\n\t\t\t\t\t\tVM_STACK_INCOMPLETE_SETUP)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "(vma->vm_start >> PAGE_SHIFT) - vma->vm_pgoff",
            "HPAGE_PMD_NR"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_TRANSPARENT_HUGE_PAGECACHE"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shmem_file",
          "args": [
            "vma->vm_file"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "MMF_DISABLE_THP",
            "&vma->vm_mm->flags"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "khugepaged_always",
          "args": [],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\n#define VM_NO_KHUGEPAGED (VM_SPECIAL | VM_HUGETLB)\n\nstatic bool hugepage_vma_check(struct vm_area_struct *vma,\n\t\t\t       unsigned long vm_flags)\n{\n\tif ((!(vm_flags & VM_HUGEPAGE) && !khugepaged_always()) ||\n\t    (vm_flags & VM_NOHUGEPAGE) ||\n\t    test_bit(MMF_DISABLE_THP, &vma->vm_mm->flags))\n\t\treturn false;\n\tif (shmem_file(vma->vm_file)) {\n\t\tif (!IS_ENABLED(CONFIG_TRANSPARENT_HUGE_PAGECACHE))\n\t\t\treturn false;\n\t\treturn IS_ALIGNED((vma->vm_start >> PAGE_SHIFT) - vma->vm_pgoff,\n\t\t\t\tHPAGE_PMD_NR);\n\t}\n\tif (!vma->anon_vma || vma->vm_ops)\n\t\treturn false;\n\tif (is_vma_temporary_stack(vma))\n\t\treturn false;\n\treturn !(vm_flags & VM_NO_KHUGEPAGED);\n}"
  },
  {
    "function_name": "khugepaged_test_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "395-398",
    "snippet": "static inline int khugepaged_test_exit(struct mm_struct *mm)\n{\n\treturn atomic_read(&mm->mm_users) == 0;\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&mm->mm_users"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic inline int khugepaged_test_exit(struct mm_struct *mm)\n{\n\treturn atomic_read(&mm->mm_users) == 0;\n}"
  },
  {
    "function_name": "insert_to_mm_slots_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "388-393",
    "snippet": "static void insert_to_mm_slots_hash(struct mm_struct *mm,\n\t\t\t\t    struct mm_slot *mm_slot)\n{\n\tmm_slot->mm = mm;\n\thash_add(mm_slots_hash, &mm_slot->hash, (long)mm);\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_add",
          "args": [
            "mm_slots_hash",
            "&mm_slot->hash",
            "(long)mm"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic void insert_to_mm_slots_hash(struct mm_struct *mm,\n\t\t\t\t    struct mm_slot *mm_slot)\n{\n\tmm_slot->mm = mm;\n\thash_add(mm_slots_hash, &mm_slot->hash, (long)mm);\n}"
  },
  {
    "function_name": "get_mm_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "377-386",
    "snippet": "static struct mm_slot *get_mm_slot(struct mm_struct *mm)\n{\n\tstruct mm_slot *mm_slot;\n\n\thash_for_each_possible(mm_slots_hash, mm_slot, hash, (unsigned long)mm)\n\t\tif (mm == mm_slot->mm)\n\t\t\treturn mm_slot;\n\n\treturn NULL;\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_for_each_possible",
          "args": [
            "mm_slots_hash",
            "mm_slot",
            "hash",
            "(unsigned long)mm"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic struct mm_slot *get_mm_slot(struct mm_struct *mm)\n{\n\tstruct mm_slot *mm_slot;\n\n\thash_for_each_possible(mm_slots_hash, mm_slot, hash, (unsigned long)mm)\n\t\tif (mm == mm_slot->mm)\n\t\t\treturn mm_slot;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "free_mm_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "372-375",
    "snippet": "static inline void free_mm_slot(struct mm_slot *mm_slot)\n{\n\tkmem_cache_free(mm_slot_cache, mm_slot);\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *mm_slot_cache"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "mm_slot_cache",
            "mm_slot"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.c",
          "lines": "3749-3764",
          "snippet": "void kmem_cache_free(struct kmem_cache *cachep, void *objp)\n{\n\tunsigned long flags;\n\tcachep = cache_from_obj(cachep, objp);\n\tif (!cachep)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tdebug_check_no_locks_freed(objp, cachep->object_size);\n\tif (!(cachep->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(objp, cachep->object_size);\n\t__cache_free(cachep, objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n\n\ttrace_kmem_cache_free(_RET_IP_, objp);\n}",
          "includes": [
            "#include\t\"slab.h\"",
            "#include\t\"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include\t<asm/page.h>",
            "#include\t<asm/tlbflush.h>",
            "#include\t<asm/cacheflush.h>",
            "#include\t<net/sock.h>",
            "#include\t<linux/sched/task_stack.h>",
            "#include\t<linux/prefetch.h>",
            "#include\t<linux/memory.h>",
            "#include\t<linux/debugobjects.h>",
            "#include\t<linux/reciprocal_div.h>",
            "#include\t<linux/rtmutex.h>",
            "#include\t<linux/fault-inject.h>",
            "#include\t<linux/mutex.h>",
            "#include\t<linux/mempolicy.h>",
            "#include\t<linux/kmemleak.h>",
            "#include\t<linux/nodemask.h>",
            "#include\t<linux/uaccess.h>",
            "#include\t<linux/string.h>",
            "#include\t<linux/rcupdate.h>",
            "#include\t<linux/module.h>",
            "#include\t<linux/sysctl.h>",
            "#include\t<linux/cpu.h>",
            "#include\t<linux/kallsyms.h>",
            "#include\t<linux/notifier.h>",
            "#include\t<linux/seq_file.h>",
            "#include\t<linux/proc_fs.h>",
            "#include\t<linux/cpuset.h>",
            "#include\t<linux/compiler.h>",
            "#include\t<linux/init.h>",
            "#include\t<linux/interrupt.h>",
            "#include\t<linux/cache.h>",
            "#include\t<linux/swap.h>",
            "#include\t<linux/poison.h>",
            "#include\t<linux/mm.h>",
            "#include\t<linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include\t\"slab.h\"\n#include\t\"internal.h\"\n#include <trace/events/kmem.h>\n#include\t<asm/page.h>\n#include\t<asm/tlbflush.h>\n#include\t<asm/cacheflush.h>\n#include\t<net/sock.h>\n#include\t<linux/sched/task_stack.h>\n#include\t<linux/prefetch.h>\n#include\t<linux/memory.h>\n#include\t<linux/debugobjects.h>\n#include\t<linux/reciprocal_div.h>\n#include\t<linux/rtmutex.h>\n#include\t<linux/fault-inject.h>\n#include\t<linux/mutex.h>\n#include\t<linux/mempolicy.h>\n#include\t<linux/kmemleak.h>\n#include\t<linux/nodemask.h>\n#include\t<linux/uaccess.h>\n#include\t<linux/string.h>\n#include\t<linux/rcupdate.h>\n#include\t<linux/module.h>\n#include\t<linux/sysctl.h>\n#include\t<linux/cpu.h>\n#include\t<linux/kallsyms.h>\n#include\t<linux/notifier.h>\n#include\t<linux/seq_file.h>\n#include\t<linux/proc_fs.h>\n#include\t<linux/cpuset.h>\n#include\t<linux/compiler.h>\n#include\t<linux/init.h>\n#include\t<linux/interrupt.h>\n#include\t<linux/cache.h>\n#include\t<linux/swap.h>\n#include\t<linux/poison.h>\n#include\t<linux/mm.h>\n#include\t<linux/slab.h>\n\nstatic noinline struct;\n\nvoid kmem_cache_free(struct kmem_cache *cachep, void *objp)\n{\n\tunsigned long flags;\n\tcachep = cache_from_obj(cachep, objp);\n\tif (!cachep)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tdebug_check_no_locks_freed(objp, cachep->object_size);\n\tif (!(cachep->flags & SLAB_DEBUG_OBJECTS))\n\t\tdebug_check_no_obj_freed(objp, cachep->object_size);\n\t__cache_free(cachep, objp, _RET_IP_);\n\tlocal_irq_restore(flags);\n\n\ttrace_kmem_cache_free(_RET_IP_, objp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic struct kmem_cache *mm_slot_cache;\n\nstatic inline void free_mm_slot(struct mm_slot *mm_slot)\n{\n\tkmem_cache_free(mm_slot_cache, mm_slot);\n}"
  },
  {
    "function_name": "alloc_mm_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "365-370",
    "snippet": "static inline struct mm_slot *alloc_mm_slot(void)\n{\n\tif (!mm_slot_cache)\t/* initialization failed */\n\t\treturn NULL;\n\treturn kmem_cache_zalloc(mm_slot_cache, GFP_KERNEL);\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *mm_slot_cache"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "mm_slot_cache",
            "GFP_KERNEL"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic struct kmem_cache *mm_slot_cache;\n\nstatic inline struct mm_slot *alloc_mm_slot(void)\n{\n\tif (!mm_slot_cache)\t/* initialization failed */\n\t\treturn NULL;\n\treturn kmem_cache_zalloc(mm_slot_cache, GFP_KERNEL);\n}"
  },
  {
    "function_name": "khugepaged_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "360-363",
    "snippet": "void __init khugepaged_destroy(void)\n{\n\tkmem_cache_destroy(mm_slot_cache);\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *mm_slot_cache"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "mm_slot_cache"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "874-906",
          "snippet": "void kmem_cache_destroy(struct kmem_cache *s)\n{\n\tint err;\n\n\tif (unlikely(!s))\n\t\treturn;\n\n\tflush_memcg_workqueue(s);\n\n\tget_online_cpus();\n\tget_online_mems();\n\n\tmutex_lock(&slab_mutex);\n\n\ts->refcount--;\n\tif (s->refcount)\n\t\tgoto out_unlock;\n\n\terr = shutdown_memcg_caches(s);\n\tif (!err)\n\t\terr = shutdown_cache(s);\n\n\tif (err) {\n\t\tpr_err(\"kmem_cache_destroy %s: Slab cache still has objects\\n\",\n\t\t       s->name);\n\t\tdump_stack();\n\t}\nout_unlock:\n\tmutex_unlock(&slab_mutex);\n\n\tput_online_mems();\n\tput_online_cpus();\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nvoid kmem_cache_destroy(struct kmem_cache *s)\n{\n\tint err;\n\n\tif (unlikely(!s))\n\t\treturn;\n\n\tflush_memcg_workqueue(s);\n\n\tget_online_cpus();\n\tget_online_mems();\n\n\tmutex_lock(&slab_mutex);\n\n\ts->refcount--;\n\tif (s->refcount)\n\t\tgoto out_unlock;\n\n\terr = shutdown_memcg_caches(s);\n\tif (!err)\n\t\terr = shutdown_cache(s);\n\n\tif (err) {\n\t\tpr_err(\"kmem_cache_destroy %s: Slab cache still has objects\\n\",\n\t\t       s->name);\n\t\tdump_stack();\n\t}\nout_unlock:\n\tmutex_unlock(&slab_mutex);\n\n\tput_online_mems();\n\tput_online_cpus();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic struct kmem_cache *mm_slot_cache;\n\nvoid __init khugepaged_destroy(void)\n{\n\tkmem_cache_destroy(mm_slot_cache);\n}"
  },
  {
    "function_name": "khugepaged_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "345-358",
    "snippet": "int __init khugepaged_init(void)\n{\n\tmm_slot_cache = kmem_cache_create(\"khugepaged_mm_slot\",\n\t\t\t\t\t  sizeof(struct mm_slot),\n\t\t\t\t\t  __alignof__(struct mm_slot), 0, NULL);\n\tif (!mm_slot_cache)\n\t\treturn -ENOMEM;\n\n\tkhugepaged_pages_to_scan = HPAGE_PMD_NR * 8;\n\tkhugepaged_max_ptes_none = HPAGE_PMD_NR - 1;\n\tkhugepaged_max_ptes_swap = HPAGE_PMD_NR / 8;\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int khugepaged_pages_to_scan",
      "static unsigned int khugepaged_max_ptes_none",
      "static unsigned int khugepaged_max_ptes_swap",
      "static struct kmem_cache *mm_slot_cache"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"khugepaged_mm_slot\"",
            "sizeof(struct mm_slot)",
            "__alignof__(struct mm_slot)",
            "0",
            "NULL"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_cache_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "517-523",
          "snippet": "struct kmem_cache *\nkmem_cache_create(const char *name, unsigned int size, unsigned int align,\n\t\tslab_flags_t flags, void (*ctor)(void *))\n{\n\treturn kmem_cache_create_usercopy(name, size, align, flags, 0, 0,\n\t\t\t\t\t  ctor);\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nstruct kmem_cache *\nkmem_cache_create(const char *name, unsigned int size, unsigned int align,\n\t\tslab_flags_t flags, void (*ctor)(void *))\n{\n\treturn kmem_cache_create_usercopy(name, size, align, flags, 0, 0,\n\t\t\t\t\t  ctor);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic unsigned int khugepaged_pages_to_scan;\nstatic unsigned int khugepaged_max_ptes_none;\nstatic unsigned int khugepaged_max_ptes_swap;\nstatic struct kmem_cache *mm_slot_cache;\n\nint __init khugepaged_init(void)\n{\n\tmm_slot_cache = kmem_cache_create(\"khugepaged_mm_slot\",\n\t\t\t\t\t  sizeof(struct mm_slot),\n\t\t\t\t\t  __alignof__(struct mm_slot), 0, NULL);\n\tif (!mm_slot_cache)\n\t\treturn -ENOMEM;\n\n\tkhugepaged_pages_to_scan = HPAGE_PMD_NR * 8;\n\tkhugepaged_max_ptes_none = HPAGE_PMD_NR - 1;\n\tkhugepaged_max_ptes_swap = HPAGE_PMD_NR / 8;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hugepage_madvise",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "306-343",
    "snippet": "int hugepage_madvise(struct vm_area_struct *vma,\n\t\t     unsigned long *vm_flags, int advice)\n{\n\tswitch (advice) {\n\tcase MADV_HUGEPAGE:\n#ifdef CONFIG_S390\n\t\t/*\n\t\t * qemu blindly sets MADV_HUGEPAGE on all allocations, but s390\n\t\t * can't handle this properly after s390_enable_sie, so we simply\n\t\t * ignore the madvise to prevent qemu from causing a SIGSEGV.\n\t\t */\n\t\tif (mm_has_pgste(vma->vm_mm))\n\t\t\treturn 0;\n#endif\n\t\t*vm_flags &= ~VM_NOHUGEPAGE;\n\t\t*vm_flags |= VM_HUGEPAGE;\n\t\t/*\n\t\t * If the vma become good for khugepaged to scan,\n\t\t * register it here without waiting a page fault that\n\t\t * may not happen any time soon.\n\t\t */\n\t\tif (!(*vm_flags & VM_NO_KHUGEPAGED) &&\n\t\t\t\tkhugepaged_enter_vma_merge(vma, *vm_flags))\n\t\t\treturn -ENOMEM;\n\t\tbreak;\n\tcase MADV_NOHUGEPAGE:\n\t\t*vm_flags &= ~VM_HUGEPAGE;\n\t\t*vm_flags |= VM_NOHUGEPAGE;\n\t\t/*\n\t\t * Setting VM_NOHUGEPAGE will prevent khugepaged from scanning\n\t\t * this vma even if we leave the mm registered in khugepaged if\n\t\t * it got registered before VM_NOHUGEPAGE was set.\n\t\t */\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define VM_NO_KHUGEPAGED (VM_SPECIAL | VM_HUGETLB)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "khugepaged_enter_vma_merge",
          "args": [
            "vma",
            "*vm_flags"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "khugepaged_enter_vma_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
          "lines": "453-470",
          "snippet": "int khugepaged_enter_vma_merge(struct vm_area_struct *vma,\n\t\t\t       unsigned long vm_flags)\n{\n\tunsigned long hstart, hend;\n\n\t/*\n\t * khugepaged does not yet work on non-shmem files or special\n\t * mappings. And file-private shmem THP is not supported.\n\t */\n\tif (!hugepage_vma_check(vma, vm_flags))\n\t\treturn 0;\n\n\thstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;\n\thend = vma->vm_end & HPAGE_PMD_MASK;\n\tif (hstart < hend)\n\t\treturn khugepaged_enter(vma, vm_flags);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/huge_memory.h>",
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/swapops.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/mman.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nint khugepaged_enter_vma_merge(struct vm_area_struct *vma,\n\t\t\t       unsigned long vm_flags)\n{\n\tunsigned long hstart, hend;\n\n\t/*\n\t * khugepaged does not yet work on non-shmem files or special\n\t * mappings. And file-private shmem THP is not supported.\n\t */\n\tif (!hugepage_vma_check(vma, vm_flags))\n\t\treturn 0;\n\n\thstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;\n\thend = vma->vm_end & HPAGE_PMD_MASK;\n\tif (hstart < hend)\n\t\treturn khugepaged_enter(vma, vm_flags);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_has_pgste",
          "args": [
            "vma->vm_mm"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\n#define VM_NO_KHUGEPAGED (VM_SPECIAL | VM_HUGETLB)\n\nint hugepage_madvise(struct vm_area_struct *vma,\n\t\t     unsigned long *vm_flags, int advice)\n{\n\tswitch (advice) {\n\tcase MADV_HUGEPAGE:\n#ifdef CONFIG_S390\n\t\t/*\n\t\t * qemu blindly sets MADV_HUGEPAGE on all allocations, but s390\n\t\t * can't handle this properly after s390_enable_sie, so we simply\n\t\t * ignore the madvise to prevent qemu from causing a SIGSEGV.\n\t\t */\n\t\tif (mm_has_pgste(vma->vm_mm))\n\t\t\treturn 0;\n#endif\n\t\t*vm_flags &= ~VM_NOHUGEPAGE;\n\t\t*vm_flags |= VM_HUGEPAGE;\n\t\t/*\n\t\t * If the vma become good for khugepaged to scan,\n\t\t * register it here without waiting a page fault that\n\t\t * may not happen any time soon.\n\t\t */\n\t\tif (!(*vm_flags & VM_NO_KHUGEPAGED) &&\n\t\t\t\tkhugepaged_enter_vma_merge(vma, *vm_flags))\n\t\t\treturn -ENOMEM;\n\t\tbreak;\n\tcase MADV_NOHUGEPAGE:\n\t\t*vm_flags &= ~VM_HUGEPAGE;\n\t\t*vm_flags |= VM_NOHUGEPAGE;\n\t\t/*\n\t\t * Setting VM_NOHUGEPAGE will prevent khugepaged from scanning\n\t\t * this vma even if we leave the mm registered in khugepaged if\n\t\t * it got registered before VM_NOHUGEPAGE was set.\n\t\t */\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "khugepaged_max_ptes_swap_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "266-280",
    "snippet": "static ssize_t khugepaged_max_ptes_swap_store(struct kobject *kobj,\n\t\t\t\t\t      struct kobj_attribute *attr,\n\t\t\t\t\t      const char *buf, size_t count)\n{\n\tint err;\n\tunsigned long max_ptes_swap;\n\n\terr  = kstrtoul(buf, 10, &max_ptes_swap);\n\tif (err || max_ptes_swap > HPAGE_PMD_NR-1)\n\t\treturn -EINVAL;\n\n\tkhugepaged_max_ptes_swap = max_ptes_swap;\n\n\treturn count;\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int khugepaged_max_ptes_swap"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "buf",
            "10",
            "&max_ptes_swap"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic unsigned int khugepaged_max_ptes_swap;\n\nstatic ssize_t khugepaged_max_ptes_swap_store(struct kobject *kobj,\n\t\t\t\t\t      struct kobj_attribute *attr,\n\t\t\t\t\t      const char *buf, size_t count)\n{\n\tint err;\n\tunsigned long max_ptes_swap;\n\n\terr  = kstrtoul(buf, 10, &max_ptes_swap);\n\tif (err || max_ptes_swap > HPAGE_PMD_NR-1)\n\t\treturn -EINVAL;\n\n\tkhugepaged_max_ptes_swap = max_ptes_swap;\n\n\treturn count;\n}"
  },
  {
    "function_name": "khugepaged_max_ptes_swap_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "259-264",
    "snippet": "static ssize_t khugepaged_max_ptes_swap_show(struct kobject *kobj,\n\t\t\t\t\t     struct kobj_attribute *attr,\n\t\t\t\t\t     char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", khugepaged_max_ptes_swap);\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int khugepaged_max_ptes_swap"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%u\\n\"",
            "khugepaged_max_ptes_swap"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic unsigned int khugepaged_max_ptes_swap;\n\nstatic ssize_t khugepaged_max_ptes_swap_show(struct kobject *kobj,\n\t\t\t\t\t     struct kobj_attribute *attr,\n\t\t\t\t\t     char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", khugepaged_max_ptes_swap);\n}"
  },
  {
    "function_name": "khugepaged_max_ptes_none_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "240-254",
    "snippet": "static ssize_t khugepaged_max_ptes_none_store(struct kobject *kobj,\n\t\t\t\t\t      struct kobj_attribute *attr,\n\t\t\t\t\t      const char *buf, size_t count)\n{\n\tint err;\n\tunsigned long max_ptes_none;\n\n\terr = kstrtoul(buf, 10, &max_ptes_none);\n\tif (err || max_ptes_none > HPAGE_PMD_NR-1)\n\t\treturn -EINVAL;\n\n\tkhugepaged_max_ptes_none = max_ptes_none;\n\n\treturn count;\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int khugepaged_max_ptes_none"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "buf",
            "10",
            "&max_ptes_none"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic unsigned int khugepaged_max_ptes_none;\n\nstatic ssize_t khugepaged_max_ptes_none_store(struct kobject *kobj,\n\t\t\t\t\t      struct kobj_attribute *attr,\n\t\t\t\t\t      const char *buf, size_t count)\n{\n\tint err;\n\tunsigned long max_ptes_none;\n\n\terr = kstrtoul(buf, 10, &max_ptes_none);\n\tif (err || max_ptes_none > HPAGE_PMD_NR-1)\n\t\treturn -EINVAL;\n\n\tkhugepaged_max_ptes_none = max_ptes_none;\n\n\treturn count;\n}"
  },
  {
    "function_name": "khugepaged_max_ptes_none_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "234-239",
    "snippet": "static ssize_t khugepaged_max_ptes_none_show(struct kobject *kobj,\n\t\t\t\t\t     struct kobj_attribute *attr,\n\t\t\t\t\t     char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", khugepaged_max_ptes_none);\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int khugepaged_max_ptes_none"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%u\\n\"",
            "khugepaged_max_ptes_none"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic unsigned int khugepaged_max_ptes_none;\n\nstatic ssize_t khugepaged_max_ptes_none_show(struct kobject *kobj,\n\t\t\t\t\t     struct kobj_attribute *attr,\n\t\t\t\t\t     char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", khugepaged_max_ptes_none);\n}"
  },
  {
    "function_name": "khugepaged_defrag_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "215-221",
    "snippet": "static ssize_t khugepaged_defrag_store(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr,\n\t\t\t\t       const char *buf, size_t count)\n{\n\treturn single_hugepage_flag_store(kobj, attr, buf, count,\n\t\t\t\t TRANSPARENT_HUGEPAGE_DEFRAG_KHUGEPAGED_FLAG);\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_hugepage_flag_store",
          "args": [
            "kobj",
            "attr",
            "buf",
            "count",
            "TRANSPARENT_HUGEPAGE_DEFRAG_KHUGEPAGED_FLAG"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "single_hugepage_flag_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "198-218",
          "snippet": "ssize_t single_hugepage_flag_store(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t const char *buf, size_t count,\n\t\t\t\t enum transparent_hugepage_flag flag)\n{\n\tunsigned long value;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &value);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (value > 1)\n\t\treturn -EINVAL;\n\n\tif (value)\n\t\tset_bit(flag, &transparent_hugepage_flags);\n\telse\n\t\tclear_bit(flag, &transparent_hugepage_flags);\n\n\treturn count;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nssize_t single_hugepage_flag_store(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t const char *buf, size_t count,\n\t\t\t\t enum transparent_hugepage_flag flag)\n{\n\tunsigned long value;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &value);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (value > 1)\n\t\treturn -EINVAL;\n\n\tif (value)\n\t\tset_bit(flag, &transparent_hugepage_flags);\n\telse\n\t\tclear_bit(flag, &transparent_hugepage_flags);\n\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic ssize_t khugepaged_defrag_store(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr,\n\t\t\t\t       const char *buf, size_t count)\n{\n\treturn single_hugepage_flag_store(kobj, attr, buf, count,\n\t\t\t\t TRANSPARENT_HUGEPAGE_DEFRAG_KHUGEPAGED_FLAG);\n}"
  },
  {
    "function_name": "khugepaged_defrag_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "209-214",
    "snippet": "static ssize_t khugepaged_defrag_show(struct kobject *kobj,\n\t\t\t\t      struct kobj_attribute *attr, char *buf)\n{\n\treturn single_hugepage_flag_show(kobj, attr, buf,\n\t\t\t\tTRANSPARENT_HUGEPAGE_DEFRAG_KHUGEPAGED_FLAG);\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_hugepage_flag_show",
          "args": [
            "kobj",
            "attr",
            "buf",
            "TRANSPARENT_HUGEPAGE_DEFRAG_KHUGEPAGED_FLAG"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "single_hugepage_flag_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/huge_memory.c",
          "lines": "190-196",
          "snippet": "ssize_t single_hugepage_flag_show(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr, char *buf,\n\t\t\t\tenum transparent_hugepage_flag flag)\n{\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       !!test_bit(flag, &transparent_hugepage_flags));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgalloc.h>",
            "#include <asm/tlb.h>",
            "#include <linux/oom.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/migrate.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mman.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/freezer.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/dax.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/oom.h>\n#include <linux/shmem_fs.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/migrate.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/memremap.h>\n#include <linux/mman.h>\n#include <linux/pfn_t.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/dax.h>\n#include <linux/swapops.h>\n#include <linux/mm_inline.h>\n#include <linux/shrinker.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nssize_t single_hugepage_flag_show(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr, char *buf,\n\t\t\t\tenum transparent_hugepage_flag flag)\n{\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       !!test_bit(flag, &transparent_hugepage_flags));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic ssize_t khugepaged_defrag_show(struct kobject *kobj,\n\t\t\t\t      struct kobj_attribute *attr, char *buf)\n{\n\treturn single_hugepage_flag_show(kobj, attr, buf,\n\t\t\t\tTRANSPARENT_HUGEPAGE_DEFRAG_KHUGEPAGED_FLAG);\n}"
  },
  {
    "function_name": "full_scans_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "200-205",
    "snippet": "static ssize_t full_scans_show(struct kobject *kobj,\n\t\t\t       struct kobj_attribute *attr,\n\t\t\t       char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", khugepaged_full_scans);\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int khugepaged_full_scans;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%u\\n\"",
            "khugepaged_full_scans"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic unsigned int khugepaged_full_scans;\n\nstatic ssize_t full_scans_show(struct kobject *kobj,\n\t\t\t       struct kobj_attribute *attr,\n\t\t\t       char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", khugepaged_full_scans);\n}"
  },
  {
    "function_name": "pages_collapsed_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "191-196",
    "snippet": "static ssize_t pages_collapsed_show(struct kobject *kobj,\n\t\t\t\t    struct kobj_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", khugepaged_pages_collapsed);\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int khugepaged_pages_collapsed;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%u\\n\"",
            "khugepaged_pages_collapsed"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic unsigned int khugepaged_pages_collapsed;\n\nstatic ssize_t pages_collapsed_show(struct kobject *kobj,\n\t\t\t\t    struct kobj_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", khugepaged_pages_collapsed);\n}"
  },
  {
    "function_name": "pages_to_scan_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "172-186",
    "snippet": "static ssize_t pages_to_scan_store(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tint err;\n\tunsigned long pages;\n\n\terr = kstrtoul(buf, 10, &pages);\n\tif (err || !pages || pages > UINT_MAX)\n\t\treturn -EINVAL;\n\n\tkhugepaged_pages_to_scan = pages;\n\n\treturn count;\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int khugepaged_pages_to_scan"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "buf",
            "10",
            "&pages"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic unsigned int khugepaged_pages_to_scan;\n\nstatic ssize_t pages_to_scan_store(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tint err;\n\tunsigned long pages;\n\n\terr = kstrtoul(buf, 10, &pages);\n\tif (err || !pages || pages > UINT_MAX)\n\t\treturn -EINVAL;\n\n\tkhugepaged_pages_to_scan = pages;\n\n\treturn count;\n}"
  },
  {
    "function_name": "pages_to_scan_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "166-171",
    "snippet": "static ssize_t pages_to_scan_show(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr,\n\t\t\t\t  char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", khugepaged_pages_to_scan);\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int khugepaged_pages_to_scan"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%u\\n\"",
            "khugepaged_pages_to_scan"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic unsigned int khugepaged_pages_to_scan;\n\nstatic ssize_t pages_to_scan_show(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr,\n\t\t\t\t  char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", khugepaged_pages_to_scan);\n}"
  },
  {
    "function_name": "alloc_sleep_millisecs_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "145-161",
    "snippet": "static ssize_t alloc_sleep_millisecs_store(struct kobject *kobj,\n\t\t\t\t\t   struct kobj_attribute *attr,\n\t\t\t\t\t   const char *buf, size_t count)\n{\n\tunsigned long msecs;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &msecs);\n\tif (err || msecs > UINT_MAX)\n\t\treturn -EINVAL;\n\n\tkhugepaged_alloc_sleep_millisecs = msecs;\n\tkhugepaged_sleep_expire = 0;\n\twake_up_interruptible(&khugepaged_wait);\n\n\treturn count;\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int khugepaged_alloc_sleep_millisecs",
      "static unsigned long khugepaged_sleep_expire;",
      "static DECLARE_WAIT_QUEUE_HEAD(khugepaged_wait);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&khugepaged_wait"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "buf",
            "10",
            "&msecs"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic unsigned int khugepaged_alloc_sleep_millisecs;\nstatic unsigned long khugepaged_sleep_expire;\nstatic DECLARE_WAIT_QUEUE_HEAD(khugepaged_wait);\n\nstatic ssize_t alloc_sleep_millisecs_store(struct kobject *kobj,\n\t\t\t\t\t   struct kobj_attribute *attr,\n\t\t\t\t\t   const char *buf, size_t count)\n{\n\tunsigned long msecs;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &msecs);\n\tif (err || msecs > UINT_MAX)\n\t\treturn -EINVAL;\n\n\tkhugepaged_alloc_sleep_millisecs = msecs;\n\tkhugepaged_sleep_expire = 0;\n\twake_up_interruptible(&khugepaged_wait);\n\n\treturn count;\n}"
  },
  {
    "function_name": "alloc_sleep_millisecs_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "138-143",
    "snippet": "static ssize_t alloc_sleep_millisecs_show(struct kobject *kobj,\n\t\t\t\t\t  struct kobj_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", khugepaged_alloc_sleep_millisecs);\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int khugepaged_alloc_sleep_millisecs"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%u\\n\"",
            "khugepaged_alloc_sleep_millisecs"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic unsigned int khugepaged_alloc_sleep_millisecs;\n\nstatic ssize_t alloc_sleep_millisecs_show(struct kobject *kobj,\n\t\t\t\t\t  struct kobj_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", khugepaged_alloc_sleep_millisecs);\n}"
  },
  {
    "function_name": "scan_sleep_millisecs_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "117-133",
    "snippet": "static ssize_t scan_sleep_millisecs_store(struct kobject *kobj,\n\t\t\t\t\t  struct kobj_attribute *attr,\n\t\t\t\t\t  const char *buf, size_t count)\n{\n\tunsigned long msecs;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &msecs);\n\tif (err || msecs > UINT_MAX)\n\t\treturn -EINVAL;\n\n\tkhugepaged_scan_sleep_millisecs = msecs;\n\tkhugepaged_sleep_expire = 0;\n\twake_up_interruptible(&khugepaged_wait);\n\n\treturn count;\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int khugepaged_scan_sleep_millisecs",
      "static unsigned long khugepaged_sleep_expire;",
      "static DECLARE_WAIT_QUEUE_HEAD(khugepaged_wait);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&khugepaged_wait"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "buf",
            "10",
            "&msecs"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic unsigned int khugepaged_scan_sleep_millisecs;\nstatic unsigned long khugepaged_sleep_expire;\nstatic DECLARE_WAIT_QUEUE_HEAD(khugepaged_wait);\n\nstatic ssize_t scan_sleep_millisecs_store(struct kobject *kobj,\n\t\t\t\t\t  struct kobj_attribute *attr,\n\t\t\t\t\t  const char *buf, size_t count)\n{\n\tunsigned long msecs;\n\tint err;\n\n\terr = kstrtoul(buf, 10, &msecs);\n\tif (err || msecs > UINT_MAX)\n\t\treturn -EINVAL;\n\n\tkhugepaged_scan_sleep_millisecs = msecs;\n\tkhugepaged_sleep_expire = 0;\n\twake_up_interruptible(&khugepaged_wait);\n\n\treturn count;\n}"
  },
  {
    "function_name": "scan_sleep_millisecs_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/khugepaged.c",
    "lines": "110-115",
    "snippet": "static ssize_t scan_sleep_millisecs_show(struct kobject *kobj,\n\t\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", khugepaged_scan_sleep_millisecs);\n}",
    "includes": [
      "#include <trace/events/huge_memory.h>",
      "#include \"internal.h\"",
      "#include <asm/pgalloc.h>",
      "#include <asm/tlb.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/swapops.h>",
      "#include <linux/page_idle.h>",
      "#include <linux/userfaultfd_k.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/mman.h>",
      "#include <linux/freezer.h>",
      "#include <linux/khugepaged.h>",
      "#include <linux/kthread.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/swap.h>",
      "#include <linux/rmap.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int khugepaged_scan_sleep_millisecs"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%u\\n\"",
            "khugepaged_scan_sleep_millisecs"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/huge_memory.h>\n#include \"internal.h\"\n#include <asm/pgalloc.h>\n#include <asm/tlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/swapops.h>\n#include <linux/page_idle.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/hashtable.h>\n#include <linux/mman.h>\n#include <linux/freezer.h>\n#include <linux/khugepaged.h>\n#include <linux/kthread.h>\n#include <linux/mm_inline.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mmu_notifier.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic unsigned int khugepaged_scan_sleep_millisecs;\n\nstatic ssize_t scan_sleep_millisecs_show(struct kobject *kobj,\n\t\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", khugepaged_scan_sleep_millisecs);\n}"
  }
]